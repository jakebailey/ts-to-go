import assert from "assert";
import CodeBlockWriter from "code-block-writer";
import { execa } from "execa";
import path from "path";
import {
    ArrowFunction,
    BinaryExpression,
    Block,
    ConditionalExpression,
    Expression,
    ExpressionStatement,
    FunctionDeclaration,
    IfStatement,
    Node,
    Project,
    Statement,
    ts,
    Type,
    TypeNode,
} from "ts-morph";

process.stdout.write("\x1B[2J\x1B[3J\x1B[H");

const root = "/home/jabaile/work/TypeScript/src/compiler";
function pathFor(s: string) {
    return path.join(root, s);
}

const project = new Project({
    tsConfigFilePath: pathFor("tsconfig.json"),
});

const sourceFile = project.getSourceFileOrThrow(pathFor("checker.ts"));

const writer = new CodeBlockWriter({
    useTabs: true,
});

const { stdout: tsCommit } = await execa("git", ["rev-parse", "HEAD"], { cwd: root });

writer.writeLine(`// Code generated by ts-to-go at ${tsCommit}. DO NOT EDIT.`);
writer.newLine();
writer.writeLine("package output");
writer.newLine();

function asComment(text: string) {
    text = text.replaceAll("*/", "* /");
    text = text.replace(/\r?\n\s+/gm, " ");
    return `/* ${text} */`;
}

const todoCounts = new Map<string, number>();

let tmp = 0;

function writeTodoNode(node: Node) {
    const nodeKind = Node.isTypeNode(node) ? "TypeNode" : "Node";
    const kindName = node.getKindName();
    const todoName = `${nodeKind} ${kindName}`;
    const count = todoCounts.get(todoName) || 0;
    todoCounts.set(todoName, count + 1);
    writer.write(asComment(`TODO(${todoName}): ${node.getText()}`));
}

function writeType(node: Type): void {
    let text = node.getText();
    text = text.replaceAll(`import("/home/jabaile/work/TypeScript/src/compiler/types").`, "");
    writer.write(`${asComment("TODO inferred type " + text)} any`);
}

function visitTypeNode(type: TypeNode): void {
    // In Go, there's never a reason to parenthesize a type.
    while (Node.isParenthesizedTypeNode(type)) {
        type = type.getTypeNode();
    }

    if (Node.isFunctionTypeNode(type)) {
        writer.write("func(");
        const params = type.getParameters();
        for (let i = 0; i < params.length; i++) {
            const param = params[i];
            writer.write(getNameOfNamed(param));
            writer.write(" ");
            visitTypeNode(param.getTypeNodeOrThrow());
            writer.conditionalWrite(i < params.length - 1, ", ");
        }
        writer.write(") ");
        const ret = type.getReturnTypeNodeOrThrow();
        visitTypeNode(ret);
    }
    else if (Node.isBooleanKeyword(type)) {
        writer.write("bool");
    }
    else if (Node.isStringKeyword(type)) {
        writer.write("string");
    }
    else if (Node.isNumberKeyword(type)) {
        writer.write("number");
    }
    else if (type.getText() === "void") {
        const parent = type.getParentIfKind(ts.SyntaxKind.FunctionType);
        if (parent?.getReturnTypeNode() !== type) {
            writer.write("void");
        }
    }
    else if (Node.isArrayTypeNode(type)) {
        writer.write("[]");
        visitTypeNode(type.getElementTypeNode());
    }
    else if (Node.isTypeOperatorTypeNode(type)) {
        visitTypeNode(type.getTypeNode());
    }
    else if (Node.isTypeReference(type)) {
        const name = type.getTypeName();
        if (Node.isIdentifier(name)) {
            writer.write(sanitizeName(name.getText()));
        }
        else {
            writeTodoNode(name);
            writer.write(` TODO`);
        }
        const typeArguments = type.getTypeArguments();
        if (typeArguments.length > 0) {
            writer.write("[");
            for (let i = 0; i < typeArguments.length; i++) {
                visitTypeNode(typeArguments[i]);
                writer.conditionalWrite(i < typeArguments.length - 1, ", ");
            }
            writer.write("]");
        }
    }
    else if (Node.isUnionTypeNode(type)) {
        if (type.getTypeNodes().length === 2) {
            let [a, b] = type.getTypeNodes();
            if (Node.isUndefinedKeyword(a)) {
                [a, b] = [b, a];
            }
            if (Node.isUndefinedKeyword(b)) {
                switch (a.getText()) {
                    case "Node":
                    case "Declaration":
                        break;
                    default:
                        writer.write("*");
                }

                visitTypeNode(a);
            }
            else {
                writeTodoNode(type);
                writer.write(` any`);
            }
        }
        else {
            writeTodoNode(type);
            writer.write(` any`);
        }
    }
    else if (Node.isAnyKeyword(type)) {
        writer.write("any");
    }
    else {
        writeTodoNode(type);
        writer.write(` any`);
    }
}

function writeConditionalExpressionAsSwitchCase(node: ConditionalExpression, sideEffect: string) {
    writer.writeLine("// converted from conditional expression");
    writer.write("switch {");

    let ladder: Expression = node;
    while (Node.isConditionalExpression(ladder)) {
        const cond = ladder.getCondition();
        const whenTrue = ladder.getWhenTrue();
        const whenFalse = ladder.getWhenFalse();

        writer.newLine();
        writer.write("case ");
        visitExpression(cond);
        writer.write(":");
        writer.indent(() => {
            if (Node.isConditionalExpression(whenTrue)) {
                writeConditionalExpressionAsSwitchCase(whenTrue, sideEffect);
            }
            else {
                writer.write(sideEffect);
                visitExpression(whenTrue);
            }
        });

        ladder = whenFalse;
    }

    writer.newLine();
    writer.write("default:");
    writer.indent(() => {
        writer.write(sideEffect);
        visitExpression(ladder);
    });
    writer.newLine();
    writer.write("}");
    return;
}

function visitExpression(node: Expression, inStatement?: boolean): void {
    if (Node.isRegularExpressionLiteral(node)) {
        const re = node.getLiteralValue();
        let source = re.source.replaceAll("`", "\\`");

        for (const flag of re.flags.split("")) {
            switch (flag) {
                case "i":
                    source = `(?i:${source})`;
                    break;
                default:
                    writeTodoNode(node);
                    writer.write(` TODO`);
                    return;
            }
        }

        writer.write(`regexp.MustParse(\`${source}\`)`);
    }
    else if (Node.isLiteralExpression(node)) {
        writer.write(node.getText());
    }
    else if (Node.isAsExpression(node)) {
        visitExpression(node.getExpression());
        // writer.write(` /* as */ ${todo(node.getTypeNodeOrThrow())}`);
    }
    else if (Node.isNonNullExpression(node)) {
        visitExpression(node.getExpression());
        // writer.write(`/*!*/`);
    }
    else if (Node.isIdentifier(node) || node.getText() === "this") {
        if (node.getText() === "undefined") {
            writer.write("nil");
        }
        else {
            writer.write(sanitizeName(node.getText()));
        }
    }
    else if (Node.isCallExpression(node)) {
        const expression = node.getExpression();
        visitExpression(expression);
        writer.write("(");
        const args = node.getArguments();
        for (let i = 0; i < args.length; i++) {
            const expr = args[i];
            assert(Node.isExpression(expr));
            visitExpression(expr);
            writer.conditionalWrite(i < args.length - 1, ", ");
        }
        writer.write(")");
    }
    else if (Node.isPrefixUnaryExpression(node)) {
        const token = ts.tokenToString(node.getOperatorToken())!;
        if (inStatement && (token === "++" || token === "--")) {
            visitExpression(node.getOperand());
            writer.write(token);
        }
        else {
            writer.write(token);
            visitExpression(node.getOperand());
        }
    }
    else if (Node.isParenthesizedExpression(node)) {
        writer.write("(");
        visitExpression(node.getExpression());
        writer.write(")");
    }
    else if (Node.isBinaryExpression(node)) {
        writeBinaryExpression(node, inStatement);
    }
    else if (Node.isTrueLiteral(node)) {
        writer.write("true");
    }
    else if (Node.isFalseLiteral(node)) {
        writer.write("false");
    }
    else if (Node.isPropertyAccessExpression(node)) {
        // Check for enum accesses first
        const expression = node.getExpression();
        if (Node.isIdentifier(expression)) {
            const type = expression.getType();
            if (type.isEnum()) {
                const enumName = expression.getText();
                const enumMember = node.getNameNode();
                writer.write(`${enumName}${enumMember.getText()}`);
                return;
            }
        }

        visitExpression(node.getExpression());
        if (node.hasQuestionDotToken()) {
            writer.write("/*?*/");
        }
        writer.write(`.${sanitizeName(node.getName())}`);
    }
    else if (Node.isElementAccessExpression(node)) {
        visitExpression(node.getExpression());
        writer.write("[");
        visitExpression(node.getArgumentExpressionOrThrow());
        writer.write("]");
    }
    else if (Node.isArrowFunction(node)) {
        writer.write("func");
        writeFunctionParametersAndReturn(node);
        writer.write(" {");
        writer.indent(() => {
            const body = node.getBody();
            if (Node.isBlock(body)) {
                visitBlock(body);
            }
            else {
                assert(Node.isExpression(body));
                if (Node.isConditionalExpression(body)) {
                    writeConditionalExpressionAsSwitchCase(body, "return ");
                }
                else {
                    writer.write("return ");
                    visitExpression(body);
                }
            }
        });
        writer.write("}");
    }
    else if (Node.isNewExpression(node)) {
        const expression = node.getExpression();
        if (Node.isIdentifier(expression) && node.getArguments().length === 0) {
            const typeArguments = node.getTypeArguments();
            const name = expression.getText();
            if (name === "Map") {
                if (typeArguments.length === 2) {
                    writer.write("make(map[");
                    visitTypeNode(typeArguments[0]);
                    writer.write("]");
                    visitTypeNode(typeArguments[1]);
                    writer.write(")");
                }
                else {
                    writeTodoNode(node);
                    writer.write(` make(map[any]any)`);
                }
                return;
            }
            else if (name === "Set") {
                if (typeArguments.length === 1) {
                    writer.write("make(map[");
                    visitTypeNode(typeArguments[0]);
                    writer.write("]struct{})");
                }
                else {
                    writeTodoNode(node);
                    writer.write(` make(map[any]struct{})`);
                }
                return;
            }
        }
        writeTodoNode(node);
        writer.write(` TODO`);
    }
    else if (Node.isVoidExpression(node)) {
        visitExpression(node.getExpression());
        return;
    }
    else if (Node.isYieldExpression(node)) {
        writer.write("yield(");
        visitExpression(node.getExpressionOrThrow());
        writer.write(")");
        return;
    }
    else if (Node.isPostfixUnaryExpression(node)) {
        const tokenStr = ts.tokenToString(node.getOperatorToken());
        if (tokenStr) {
            visitExpression(node.getOperand());
            writer.write(tokenStr);
            return;
        }
    }
    else if (Node.isSpreadElement(node)) {
        visitExpression(node.getExpression());
        writer.write("...");
    }
    else if (Node.isArrayLiteralExpression(node)) {
        writer.write("[]");
        const type = node.getType().getArrayElementType();
        if (type) {
            writer.write(" ");
            writeType(type);
        }
        else {
            writer.write("TODO");
        }

        writer.write("{");
        const elements = node.getElements();
        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            if (Node.isSpreadElement(element)) {
                writeTodoNode(element);
            }
            else {
                visitExpression(element);
                writer.conditionalWrite(i < elements.length - 1, ", ");
            }
        }
        writer.write("}");
    }
    else if (Node.isObjectLiteralExpression(node)) {
        writer.write("map[any]any{ /* was object literal */");
        writer.indent(() => {
            const properties = node.getProperties();
            for (const prop of properties) {
                if (Node.isShorthandPropertyAssignment(prop)) {
                    writer.write(`"${getNameOfNamed(prop)}": ${getNameOfNamed(prop)}`);
                    writer.write(",");
                }
                else if (Node.isPropertyAssignment(prop)) {
                    writer.write(`"${getNameOfNamed(prop)}": `);
                    visitExpression(prop.getInitializerOrThrow());
                    writer.write(",");
                }
                else {
                    writeTodoNode(prop);
                }
                writer.newLine();
            }
        });
        writer.write("}");
    }
    else {
        writeTodoNode(node);
        writer.write(` TODO`);
    }
}

function isAssignmentOperator(kind: ts.SyntaxKind): boolean {
    switch (kind) {
        case ts.SyntaxKind.EqualsToken:
        case ts.SyntaxKind.BarEqualsToken:
        case ts.SyntaxKind.AmpersandEqualsToken:
        case ts.SyntaxKind.PlusEqualsToken:
        case ts.SyntaxKind.MinusEqualsToken:
        case ts.SyntaxKind.AsteriskEqualsToken:
        case ts.SyntaxKind.SlashEqualsToken:
        case ts.SyntaxKind.PercentEqualsToken:
        case ts.SyntaxKind.CaretEqualsToken:
        case ts.SyntaxKind.LessThanLessThanEqualsToken:
        case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
            return true;
        default:
            return false;
    }
}

function writeBinaryExpression(node: BinaryExpression, isStatement?: boolean) {
    const op = node.getOperatorToken();
    let tok;
    switch (op.getKind()) {
        case ts.SyntaxKind.AmpersandAmpersandToken:
        case ts.SyntaxKind.BarBarToken:
        case ts.SyntaxKind.LessThanEqualsToken:
        case ts.SyntaxKind.LessThanToken:
        case ts.SyntaxKind.GreaterThanEqualsToken:
        case ts.SyntaxKind.GreaterThanToken:
        case ts.SyntaxKind.AmpersandToken:
        case ts.SyntaxKind.BarToken:
        case ts.SyntaxKind.MinusToken:
        case ts.SyntaxKind.PlusToken:
        case ts.SyntaxKind.AsteriskToken:
        case ts.SyntaxKind.SlashToken:
            tok = ts.tokenToString(op.getKind());
            break;
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
            tok = "==";
            break;
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
            tok = "!=";
            break;
        default:
            if (isStatement) {
                if (isAssignmentOperator(op.getKind())) {
                    tok = ts.tokenToString(op.getKind());
                }
                else {
                    writeTodoNode(node);
                    writer.write(` TODO`);
                    return;
                }
                break;
            }

            writeTodoNode(node);
            writer.write(` TODO`);
            return;
    }

    visitExpression(node.getLeft());
    writer.write(` ${tok} `);
    visitExpression(node.getRight());
}

function sanitizeName(name: string | undefined) {
    switch (name) {
        case "break":
        case "case":
        case "chan":
        case "const":
        case "continue":
        case "default":
        case "defer":
        case "else":
        case "fallthrough":
        case "for":
        case "func":
        case "go":
        case "goto":
        case "if":
        case "import":
        case "interface":
        case "map":
        case "package":
        case "range":
        case "return":
        case "select":
        case "struct":
        case "switch":
        case "type":
        case "var":
            return `${name}_`;
        default:
            return name || "TODO";
    }
}

function getNameOfNamed(node: { getName(): string | undefined; }) {
    const name = sanitizeName(node.getName());
    if (/^[a-zA-Z0-9_]+$/.test(name)) {
        return name;
    }
    return `TODO_IDENTIFIER`;
}

function visitIfStatement(node: IfStatement) {
    writer.write("if ");
    visitExpression(node.getExpression());

    writer.write(" {");
    writer.indent(() => {
        const thenStatement = node.getThenStatement();
        if (thenStatement) {
            if (Node.isBlock(thenStatement)) {
                visitBlock(thenStatement);
            }
            else if (Node.isStatement(thenStatement)) {
                visitStatement(thenStatement);
            }
            else {
                writeTodoNode(node);
            }
        }
        writer.newLineIfLastNot();
    });

    const elseStatement = node.getElseStatement();
    if (elseStatement) {
        writer.write("} else ");
        if (Node.isIfStatement(elseStatement)) {
            return visitIfStatement(elseStatement);
        }
        writer.write("{");
        writer.indent(() => {
            if (Node.isBlock(elseStatement)) {
                visitBlock(elseStatement);
            }
            else if (Node.isStatement(elseStatement)) {
                visitStatement(elseStatement);
            }
            else {
                writeTodoNode(node);
            }
        });
        writer.write("}");
    }
    else {
        writer.write("}");
    }
}
function visitExpressionStatement(node: ExpressionStatement) {
    const expression = node.getExpression();
    visitExpression(expression, true);
    writer.newLine();
}

function writeFunctionParametersAndReturn(node: FunctionDeclaration | ArrowFunction) {
    writer.write("(");
    const params = node.getParameters();
    for (let i = 0; i < params.length; i++) {
        const param = params[i];
        writer.write(getNameOfNamed(param));
        writer.write(" ");
        const paramType = param.getTypeNode();
        if (paramType) {
            visitTypeNode(paramType);
        }
        else {
            writeType(param.getType());
        }
        const initializer = param.getInitializer();
        if (initializer) {
            writer.write(` ${asComment(" = " + initializer.getText())}`);
        }
        writer.conditionalWrite(i < params.length - 1, ", ");
    }
    writer.write(")");
    const ret = node.getReturnType();
    if (!ret.isVoid()) {
        writer.write(" ");
        const retNode = node.getReturnTypeNode();
        if (retNode) {
            visitTypeNode(retNode);
        }
        else {
            writeType(ret);
        }
    }
}

function visitBlock(node: Block) {
    node.forEachChild(node => {
        if (Node.isStatement(node)) {
            return visitStatement(node);
        }
        writeTodoNode(node);
    });
}

function visitStatement(node: Statement) {
    if (node.getKindName() === "EndOfFileToken") {
        return;
    }

    writer.newLineIfLastNot();

    if (Node.isImportDeclaration(node)) {
        return;
    }

    if (Node.isTypeAliasDeclaration(node)) {
        writer.write(`type ${getNameOfNamed(node)}`);

        const typeParameters = node.getTypeParameters();
        if (typeParameters.length > 0) {
            writer.write("[");

            for (let i = 0; i < typeParameters.length; i++) {
                const typeParameter = typeParameters[i];
                writer.write(getNameOfNamed(typeParameter));
                const constraint = typeParameter.getConstraint();
                if (constraint) {
                    writer.write(" ");
                    visitTypeNode(constraint);
                }
                writer.conditionalWrite(i < typeParameters.length - 1, ", ");
            }

            writer.write("]");
        }

        writer.write(" ");
        visitTypeNode(node.getTypeNodeOrThrow());

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isFunctionDeclaration(node)) {
        if (!node.hasBody()) {
            writer.write(asComment(`OVERLOAD: ${node.getText()}`));
            return;
        }

        const isGlobal = node.getParentIf((p): p is Node => Node.isSourceFile(p)) !== undefined;

        if (node.isGenerator()) {
            writer.writeLine("// TODO: was generator");
        }

        if (!isGlobal) {
            writer.write(`${getNameOfNamed(node)} := func`);
        }
        else {
            writer.write(`func ${getNameOfNamed(node)}`);
        }

        writeFunctionParametersAndReturn(node);

        writer.write(" {");
        writer.indent(() => {
            const body = node.getBodyOrThrow();
            assert(Node.isBlock(body));
            visitBlock(body);
        });
        writer.write("}");

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isInterfaceDeclaration(node)) {
        writer.write(`type ${getNameOfNamed(node)} struct`);

        const typeParameters = node.getTypeParameters();
        if (typeParameters.length > 0) {
            writer.write("[");

            for (let i = 0; i < typeParameters.length; i++) {
                const typeParameter = typeParameters[i];
                writer.write(getNameOfNamed(typeParameter));
                const constraint = typeParameter.getConstraint();
                if (constraint) {
                    writer.write(" ");
                    visitTypeNode(constraint);
                }
                writer.conditionalWrite(i < typeParameters.length - 1, ", ");
            }

            writer.write("]");
        }

        writer.write(" {");
        writer.indent(() => {
            const members = node.getMembers();
            for (const member of members) {
                if (Node.isMethodSignature(member)) {
                    assert.fail("oops");
                }
                else if (Node.isPropertySignature(member)) {
                    writer.write(`${getNameOfNamed(member)} `);
                    visitTypeNode(member.getTypeNodeOrThrow());
                    writer.newLine();
                }
                else {
                    writeTodoNode(node);
                }
            }
        });
        writer.write("}");

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isVariableStatement(node)) {
        const isGlobal = node.getParentIf((p): p is Node => Node.isSourceFile(p)) !== undefined;

        const declarations = node.getDeclarations();

        for (const declaration of declarations) {
            const typeNode = declaration.getTypeNode();
            const initializer = declaration.getInitializer();

            if (!isGlobal && Node.isConditionalExpression(initializer)) {
                writer.write(`var ${getNameOfNamed(declaration)} `);
                if (typeNode) {
                    visitTypeNode(typeNode);
                }
                else {
                    writeType(declaration.getType());
                }
                writeConditionalExpressionAsSwitchCase(initializer, `${getNameOfNamed(declaration)} = `);
            }
            else if (isGlobal) {
                writer.write(`var ${getNameOfNamed(declaration)}`);
                if (typeNode) {
                    writer.write(" ");
                    visitTypeNode(typeNode);
                }
                if (initializer) {
                    writer.write(" = ");
                    visitExpression(initializer);
                }
            }
            else {
                if (typeNode) {
                    writer.write(`var ${getNameOfNamed(declaration)} `);
                    visitTypeNode(typeNode);
                    if (initializer) {
                        writer.write(" = ");
                        visitExpression(initializer);
                    }
                }
                else if (initializer) {
                    writer.write(`${getNameOfNamed(declaration)} := `);
                    visitExpression(initializer);
                }
                else {
                    // No annotation or inferred type, comes from something later...
                    writer.write(`var ${getNameOfNamed(declaration)} TODO`);
                }
            }
            writer.newLineIfLastNot();
        }

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isEnumDeclaration(node)) {
        const enumName = getNameOfNamed(node);

        writer.write(`type ${enumName}`);
        if (node.getMembers()[0].getInitializer()?.getKindName() === "StringLiteral") {
            writer.write(` string`);
        }
        else {
            writer.write(` int32`);
        }

        writer.writeLine(`const (`);
        writer.indent(() => {
            const members = node.getMembers();
            const nameMapping = new Map<string, string>();
            for (const member of members) {
                const memberName = getNameOfNamed(member);
                nameMapping.set(memberName, `${enumName}${memberName}`);
            }
            const replacements = [...nameMapping.entries()].sort((a, b) => b[0].length - a[0].length);

            for (let i = 0; i < members.length; i++) {
                const member = members[i];
                const memberName = nameMapping.get(getNameOfNamed(member))!;
                writer.write(`${memberName} `);
                const initializer = member.getInitializer();
                if (i === 0 && !initializer) {
                    writer.write(`${enumName} = iota`);
                }
                else if (initializer) {
                    let initializerText = initializer.getText();

                    for (const [name, value] of replacements) {
                        initializerText = initializerText.replaceAll(name, value);
                    }

                    writer.write(`${enumName} = ${initializerText}`);
                }
                writer.newLine();
            }
        });
        writer.writeLine(")");

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isModuleDeclaration(node)) {
        writeTodoNode(node);

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isExpressionStatement(node)) {
        // Handling expressions separately so we _don't_ handle side effect expressions in writeExpression
        visitExpressionStatement(node);
        return;
    }

    if (Node.isReturnStatement(node)) {
        writer.newLineIfLastNot();

        const expression = node.getExpression();
        if (Node.isConditionalExpression(expression)) {
            writeConditionalExpressionAsSwitchCase(expression, "return ");
            return;
        }

        if (Node.isBinaryExpression(expression) && isAssignmentOperator(expression.getOperatorToken().getKind())) {
            writeBinaryExpression(expression, true);
            writer.newLine();
            writer.write("return ");
            visitExpression(expression.getLeft());
            writer.newLine();
            return;
        }

        writer.write("return");
        if (expression) {
            writer.write(" ");
            visitExpression(expression);
        }
        writer.newLine();
        return;
    }

    if (Node.isContinueStatement(node)) {
        writer.write("continue");
        writer.newLine();
        return;
    }

    if (Node.isBreakStatement(node)) {
        assert(!node.getLabel());
        writer.write("break");
        writer.newLine();
        return;
    }

    if (Node.isIfStatement(node)) {
        visitIfStatement(node);
        return;
    }

    if (Node.isForOfStatement(node)) {
        writer.write("for _, ");
        const initializer = node.getInitializer();
        if (Node.isVariableDeclarationList(initializer)) {
            writer.write(getNameOfNamed(initializer.getDeclarations()[0]));
        }
        else {
            writeTodoNode(initializer);
        }
        writer.write(" := range ");
        visitExpression(node.getExpression());
        writer.write(" {");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isForStatement(node)) {
        writer.write("for ");
        const initializer = node.getInitializer();
        if (initializer) {
            if (Node.isVariableDeclarationList(initializer)) {
                const declarations = initializer.getDeclarations();
                if (declarations.length > 1) {
                    writeTodoNode(initializer);
                }
                else {
                    const declaration = declarations[0];
                    writer.write(`${getNameOfNamed(declaration)} := `);
                    visitExpression(declaration.getInitializerOrThrow());
                }
            }
            else {
                visitExpression(initializer, true);
            }
        }
        writer.write("; ");
        const condition = node.getCondition();
        if (condition) {
            visitExpression(condition);
        }
        writer.write("; ");
        const incrementor = node.getIncrementor();
        if (incrementor) {
            visitExpression(incrementor, true);
        }
        writer.write(" {");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isWhileStatement(node)) {
        writer.write("for ");
        visitExpression(node.getExpression());
        writer.write(" {");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isDoStatement(node)) {
        writer.writeLine("// TODO: refactor do-while loop approximation");
        writer.write("for ok := true; ok; ok = ");
        visitExpression(node.getExpression());
        writer.write(" {");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isBlock(node)) {
        visitBlock(node);
        return;
    }

    if (Node.isSwitchStatement(node)) {
        writer.write("switch ");
        visitExpression(node.getExpression());
        writer.write(" {");
        const clauses = node.getClauses();
        for (let i = 0; i < clauses.length; i++) {
            const clause = clauses[i];
            const isLast = i === clauses.length - 1;
            // writer.write(todo(clause));
            writer.newLineIfLastNot();

            const statements = clause.getStatements();
            const lastStatement = statements.at(-1);
            const fallsThrough = !isLast &&
                (!lastStatement ||
                    (!Node.isBreakStatement(lastStatement) && !Node.isReturnStatement(lastStatement)));

            if (Node.isCaseClause(clause)) {
                writer.write("case ");
                const expression = clause.getExpression();
                visitExpression(expression);
                writer.write(":");
            }
            else {
                writer.write("default: ");
            }

            writer.indent(() => {
                for (const statement of statements) {
                    visitStatement(statement);
                }
                if (fallsThrough) {
                    writer.newLineIfLastNot();
                    writer.writeLine(`fallthrough${!lastStatement ? " // TODO: merge cases" : ""}`);
                }
            });
        }
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    writeTodoNode(node);
    // console.error(`Unhandled node kind: ${node.getKindName()}`);
}

sourceFile.forEachChild(node => {
    if (Node.isStatement(node)) {
        return visitStatement(node);
    }
    if (node.getKindName() === "EndOfFileToken") {
        return;
    }
    writeTodoNode(node);
});

const outFile = Bun.file("output.go.txt");

await Bun.write(outFile, writer.toString());

const formatted = await execa("gofmt", ["-w", "output.go.txt"], { reject: false });
if (formatted.exitCode === 0) {
    // await Bun.write(outFile, formatted.stdout);
    console.log("All good!");
}
else {
    console.log(formatted.stderr);
}

const totalTodo = [...todoCounts.values()].reduce((a, b) => a + b, 0);
console.log(`Total TODOs: ${totalTodo}`);
console.log([...todoCounts.entries()].sort((a, b) => b[1] - a[1]).map(([k, v]) => `${k} ${v}`).join("\n"));
