import assert from "assert";
import CodeBlockWriter from "code-block-writer";
import { execa } from "execa";
import path from "path";
import {
    ArrowFunction,
    BinaryExpression,
    Block,
    BodyableNode,
    type CaseOrDefaultClause,
    ConditionalExpression,
    Expression,
    ExpressionStatement,
    FunctionDeclaration,
    FunctionExpression,
    IfStatement,
    MethodDeclaration,
    Node,
    Project,
    Statement,
    ts,
    Type,
    TypeNode,
    TypeParameteredNode,
} from "ts-morph";

process.stdout.write("\x1B[2J\x1B[3J\x1B[H");

const root = "/home/jabaile/work/TypeScript/src/compiler";
function pathFor(s: string) {
    return path.join(root, s);
}

const project = new Project({
    tsConfigFilePath: pathFor("tsconfig.json"),
});

const sourceFile = project.getSourceFileOrThrow(pathFor("checker.ts"));

const writer = new CodeBlockWriter({
    useTabs: true,
});

const { stdout: tsCommit } = await execa("git", ["rev-parse", "HEAD"], { cwd: root });

writer.writeLine(`// Code generated by ts-to-go at ${tsCommit}. DO NOT EDIT.`);
writer.newLine();
writer.writeLine("package output");
writer.newLine();

writer.writeLine("func __COND__[C comparable, T any](cond C, a T, b T) T {");
writer.indent(() => {
    writer.writeLine("var zero C");
    writer.writeLine("if cond != zero {");
    writer.indent(() => {
        writer.writeLine("return a");
    });
    writer.writeLine("}");
    writer.writeLine("return b");
});
writer.writeLine("}");
writer.newLine();

function asComment(text: string) {
    text = text.replaceAll("*/", "* /");
    text = text.replace(/\r?\n\s+/gm, " ");
    return `/* ${text} */`;
}

const todoCounts = new Map<string, number>();

function writeTodoNode(node: Node) {
    let nodeKind = "Node";
    if (Node.isBinaryExpression(node)) {
        const token = node.getOperatorToken().getKindName();
        nodeKind = token;
    }
    else if (Node.isTypeNode(node)) {
        nodeKind = "TypeNode";
    }
    const kindName = node.getKindName();
    const todoName = `${nodeKind} ${kindName}`;
    const count = todoCounts.get(todoName) || 0;
    todoCounts.set(todoName, count + 1);
    writer.write(asComment(`TODO(TS-TO-GO) ${todoName}: ${node.getText()}`));
}

function isIdentifier(text: string) {
    return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(text);
}

function isInterfaceTypeName(name: string) {
    switch (name) {
        case "Node":
        case "Declaration":
        case "Expression":
        case "Statement":
        case "Symbol":
        case "Type":
        case "CancellationToken":
        case "any":
        case "unknown":
        case "void":
            return true;
        default:
            return false;
    }
}

function typeStringToGo(text: string): string {
    text = text.replace(/import\([^)]+\)\./g, "");
    text = text.trim();

    switch (text) {
        case "boolean":
            return "bool";
        case "void":
            return "void";
        case "object":
            return "any";
        case "{}":
            return "any";
        case "unknown":
            return "any";
    }

    if (isIdentifier(text)) {
        return text;
    }

    const orUndefined = " | undefined";
    if (text.endsWith(orUndefined)) {
        text = text.slice(0, -orUndefined.length);
        const goType = typeStringToGo(text);
        if (isInterfaceTypeName(goType)) {
            return goType;
        }
        assert(goType);
        return "*" + goType;
    }

    const bracketBracket = "[]";
    if (text.endsWith(bracketBracket)) {
        text = text.slice(0, -bracketBracket.length);
        return `[]${typeStringToGo(text)}`;
    }

    const readonly = "readonly ";
    if (text.startsWith(readonly)) {
        text = text.slice(readonly.length);
        return typeStringToGo(text);
    }

    const set = "Set<";
    if (text.startsWith(set)) {
        text = text.slice(set.length, -1);
        return `Set[${typeStringToGo(text)}]`;
    }

    const map = "Map<";
    if (text.startsWith(map)) {
        text = text.slice(map.length, -1);
        const [key, value] = text.split(", ", 2);
        return `Map[${typeStringToGo(key)}, ${typeStringToGo(value)}]`;
    }

    const nodeArray = "NodeArray<";
    if (text.startsWith(nodeArray)) {
        text = text.slice(nodeArray.length, -1);
        return `NodeArray[${typeStringToGo(text)}]`;
    }

    const todoName = "Type";
    const count = todoCounts.get(todoName) || 0;
    todoCounts.set(todoName, count + 1);
    return `${asComment("TODO(TS-TO-GO) inferred type " + text)} any`;
}

function writeType(host: Node, node: Type, isReturn?: boolean): void {
    const text = typeStringToGo(node.getText(host));
    if (isReturn && text === "void") {
        return;
    }
    writer.write(text);
}

function visitTypeNode(type: TypeNode): void {
    // In Go, there's never a reason to parenthesize a type.
    while (Node.isParenthesizedTypeNode(type)) {
        type = type.getTypeNode();
    }

    if (Node.isFunctionTypeNode(type)) {
        writer.write("func(");
        const params = type.getParameters();
        for (let i = 0; i < params.length; i++) {
            const param = params[i];
            writer.write(getNameOfNamed(param));
            writer.write(" ");
            visitTypeNode(param.getTypeNodeOrThrow());
            writer.conditionalWrite(i < params.length - 1, ", ");
        }
        writer.write(") ");
        const ret = type.getReturnTypeNodeOrThrow();
        visitTypeNode(ret);
    }
    else if (Node.isBooleanKeyword(type)) {
        writer.write("bool");
    }
    else if (Node.isStringKeyword(type)) {
        writer.write("string");
    }
    else if (Node.isNumberKeyword(type)) {
        writer.write("number");
    }
    else if (Node.isNeverKeyword(type)) {
        writer.write("never");
    }
    else if (Node.isObjectKeyword(type)) {
        writer.write("any");
    }
    else if (type.getText() === "void") {
        const parent = type.getParentIfKind(ts.SyntaxKind.FunctionType);
        if (parent?.getReturnTypeNode() !== type) {
            writer.write("void");
        }
    }
    else if (Node.isArrayTypeNode(type)) {
        writer.write("[]");
        visitTypeNode(type.getElementTypeNode());
    }
    else if (Node.isTypeOperatorTypeNode(type)) {
        visitTypeNode(type.getTypeNode());
    }
    else if (Node.isTypeReference(type)) {
        const name = type.getTypeName();
        if (Node.isIdentifier(name)) {
            writer.write(sanitizeName(name.getText()));
        }
        else {
            writeTodoNode(name);
            writer.write(` any`);
        }
        const typeArguments = type.getTypeArguments();
        if (typeArguments.length > 0) {
            writer.write("[");
            for (let i = 0; i < typeArguments.length; i++) {
                visitTypeNode(typeArguments[i]);
                writer.conditionalWrite(i < typeArguments.length - 1, ", ");
            }
            writer.write("]");
        }
    }
    else if (Node.isUnionTypeNode(type)) {
        if (type.getTypeNodes().length === 2) {
            let [a, b] = type.getTypeNodes();
            if (Node.isUndefinedKeyword(a)) {
                [a, b] = [b, a];
            }
            if (Node.isUndefinedKeyword(b)) {
                if (!isInterfaceTypeName(a.getText())) {
                    writer.write("*");
                }
                visitTypeNode(a);
            }
            else {
                writeTodoNode(type);
                writer.write(` any`);
            }
        }
        else {
            writeTodoNode(type);
            writer.write(` any`);
        }
    }
    else if (Node.isAnyKeyword(type)) {
        writer.write("any");
    }
    else {
        writeTodoNode(type);
        writer.write(` any`);
    }
}

function writeConditionalExpression(node: ConditionalExpression, sideEffect: () => void) {
    if (Node.isConditionalExpression(node.getWhenTrue()) || Node.isConditionalExpression(node.getWhenFalse())) {
        writeConditionalExpressionAsSwitchCase(node, sideEffect);
    }
    else {
        writeConditionalExpressionAsIfElse(node, sideEffect);
    }
}

function writeConditionalExpressionAsSwitchCase(node: ConditionalExpression, sideEffect: () => void) {
    writer.newLineIfLastNot();
    writer.write("switch {");

    let ladder: Expression = node;
    while (Node.isConditionalExpression(ladder)) {
        const cond = ladder.getCondition();
        const whenTrue = ladder.getWhenTrue();
        const whenFalse = ladder.getWhenFalse();

        writer.newLine();
        writer.write("case ");
        visitExpression(cond);
        writer.write(":");
        writer.indent(() => {
            if (Node.isConditionalExpression(whenTrue)) {
                writeConditionalExpression(whenTrue, sideEffect);
            }
            else {
                sideEffect();
                visitExpression(whenTrue);
            }
        });

        ladder = whenFalse;
    }

    writer.newLine();
    writer.write("default:");
    writer.indent(() => {
        sideEffect();
        visitExpression(ladder);
    });
    writer.newLine();
    writer.write("}");
    return;
}

function writeConditionalExpressionAsIfElse(node: ConditionalExpression, sideEffect: () => void) {
    const cond = node.getCondition();
    const whenTrue = node.getWhenTrue();
    const whenFalse = node.getWhenFalse();

    writer.newLineIfLastNot();
    writer.write("if ");
    visitExpression(cond);
    writer.write(" {");
    writer.indent(() => {
        sideEffect();
        visitExpression(whenTrue);
    });
    writer.write("} else {");
    writer.indent(() => {
        sideEffect();
        visitExpression(whenFalse);
    });
    writer.write("}");
}

function visitExpression(node: Expression, inStatement?: boolean): void {
    if (Node.isRegularExpressionLiteral(node)) {
        const re = node.getLiteralValue();
        let source = re.source.replaceAll("`", "\\`");

        for (const flag of re.flags.split("")) {
            switch (flag) {
                case "i":
                    source = `(?i:${source})`;
                    break;
                default:
                    writeTodoNode(node);
                    writer.write(` TODO`);
                    return;
            }
        }

        writer.write(`regexp.MustParse(\`${source}\`)`);
    }
    else if (Node.isLiteralExpression(node)) {
        writer.write(node.getText());
    }
    else if (Node.isAsExpression(node)) {
        visitExpression(node.getExpression());
        writer.write(` ${asComment("as " + node.getTypeNodeOrThrow().getText())}`);
    }
    else if (Node.isNonNullExpression(node)) {
        visitExpression(node.getExpression());
        // writer.write("/* TODO(TS-TO-GO): was ! */");
    }
    else if (Node.isIdentifier(node) || node.getText() === "this") {
        if (node.getText() === "undefined") {
            writer.write("nil");
        }
        else {
            writer.write(sanitizeName(node.getText()));
        }
    }
    else if (Node.isCallExpression(node)) {
        const expression = node.getExpression();
        visitExpression(expression);
        writer.write("(");
        const args = node.getArguments();
        for (let i = 0; i < args.length; i++) {
            const expr = args[i];
            const comment = expr.getPreviousSibling()?.getTrailingCommentRanges().at(0)?.getText();
            if (comment?.startsWith("/*")) {
                writer.write(comment);
            }
            assert(Node.isExpression(expr));
            visitExpression(expr);
            writer.conditionalWrite(i < args.length - 1, ", ");
        }
        writer.write(")");
    }
    else if (Node.isPrefixUnaryExpression(node)) {
        const token = ts.tokenToString(node.getOperatorToken())!;
        if (inStatement && (token === "++" || token === "--")) {
            visitExpression(node.getOperand());
            writer.write(token);
        }
        else {
            writer.write(token);
            visitExpression(node.getOperand());
        }
    }
    else if (Node.isParenthesizedExpression(node)) {
        writer.write("(");
        visitExpression(node.getExpression());
        writer.write(")");
    }
    else if (Node.isBinaryExpression(node)) {
        writeBinaryExpression(node, inStatement);
    }
    else if (Node.isTrueLiteral(node)) {
        writer.write("true");
    }
    else if (Node.isFalseLiteral(node)) {
        writer.write("false");
    }
    else if (Node.isPropertyAccessExpression(node)) {
        // Check for enum accesses first
        const expression = node.getExpression();
        if (Node.isIdentifier(expression)) {
            const type = expression.getType();
            if (type.isEnum()) {
                const enumName = expression.getText();
                const enumMember = node.getNameNode();
                writer.write(`${enumName}${enumMember.getText()}`);
                return;
            }
        }

        const expr = node.getExpression();
        const name = node.getNameNode();
        if (Node.isStringLiteral(node.getExpression())) {
            switch (name.getText()) {
                case "length":
                    writer.write("len(");
                    visitExpression(expr);
                    writer.write(")");
                    return;
                default:
                    throw new Error(`Unexpected string property access: ${name.getText()}`);
            }
        }

        visitExpression(expr);
        if (node.hasQuestionDotToken()) {
            writer.write("/* ? */");
        }
        writer.write(`.${sanitizeName(name.getText())}`);
    }
    else if (Node.isElementAccessExpression(node)) {
        visitExpression(node.getExpression());
        writer.write("[");
        visitExpression(node.getArgumentExpressionOrThrow());
        writer.write("]");
    }
    else if (Node.isArrowFunction(node) || Node.isFunctionExpression(node)) {
        writer.write("func");
        if (Node.isFunctionExpression(node)) {
            const name = node.getName();
            if (name) {
                writer.write(` ${asComment(node.getName()!)}`);
            }
            if (node.isGenerator()) {
                writer.write(` ${asComment("generator")}`);
            }
        }

        writeFunctionParametersAndReturn(node);
        writer.write(" {");
        writer.indent(() => {
            const body = node.getBody();
            if (Node.isBlock(body)) {
                visitBlock(body);
            }
            else {
                assert(Node.isExpression(body));
                if (Node.isConditionalExpression(body)) {
                    writeConditionalExpression(body, () => writer.write("return "));
                }
                else {
                    writer.write("return ");
                    visitExpression(body);
                }
            }
        });
        writer.write("}");
    }
    else if (Node.isNewExpression(node)) {
        const expression = node.getExpression();
        if (Node.isIdentifier(expression)) {
            const name = sanitizeName(expression.getText());
            writer.write(`New${name}`);
            const typeArguments = node.getTypeArguments();
            if (typeArguments.length > 0) {
                writer.write("[");
                for (let i = 0; i < typeArguments.length; i++) {
                    visitTypeNode(typeArguments[i]);
                    writer.conditionalWrite(i < typeArguments.length - 1, ", ");
                }
                writer.write("]");
            }
            writer.write("(");
            const args = node.getArguments();
            for (let i = 0; i < args.length; i++) {
                const arg = args[i];
                assert(Node.isExpression(arg));
                visitExpression(arg);
                writer.conditionalWrite(i < args.length - 1, ", ");
            }
            writer.write(")");
            return;
        }
        writeTodoNode(node);
        writer.write(` TODO`);
    }
    else if (Node.isVoidExpression(node)) {
        visitExpression(node.getExpression());
        return;
    }
    else if (Node.isYieldExpression(node)) {
        writer.write("yield(");
        visitExpression(node.getExpressionOrThrow());
        writer.write(")");
        return;
    }
    else if (Node.isPostfixUnaryExpression(node)) {
        const tokenStr = ts.tokenToString(node.getOperatorToken());
        if (tokenStr) {
            visitExpression(node.getOperand());
            writer.write(tokenStr);
            return;
        }
    }
    else if (Node.isSpreadElement(node)) {
        visitExpression(node.getExpression());
        writer.write("...");
    }
    else if (Node.isArrayLiteralExpression(node)) {
        writer.write("[]");
        const type = node.getType().getArrayElementType();
        if (type) {
            writer.write(" ");
            writeType(node, type);
        }
        else {
            writer.write("any");
        }

        writer.write("{");
        const elements = node.getElements();
        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            if (Node.isSpreadElement(element)) {
                writeTodoNode(element);
            }
            else {
                visitExpression(element);
                writer.conditionalWrite(i < elements.length - 1, ", ");
            }
        }
        writer.write("}");
    }
    else if (Node.isObjectLiteralExpression(node)) {
        writer.write("map[any]any{ /* TODO(TS-TO-GO): was object literal */");
        writer.indent(() => {
            const properties = node.getProperties();
            for (const prop of properties) {
                writeLeadingComments(prop);
                if (Node.isShorthandPropertyAssignment(prop)) {
                    writer.write(`"${getNameOfNamed(prop)}": ${getNameOfNamed(prop)}`);
                    writer.write(",");
                }
                else if (Node.isPropertyAssignment(prop)) {
                    writer.write(`"${getNameOfNamed(prop)}": `);
                    visitExpression(prop.getInitializerOrThrow());
                    writer.write(",");
                }
                else if (Node.isMethodDeclaration(prop)) {
                    writer.write(`"${getNameOfNamed(prop)}": func`);
                    writeTypeParameters(prop);
                    writeFunctionParametersAndReturn(prop);
                    writeBody(prop);
                    writer.write(",");
                }
                else {
                    writeTodoNode(prop);
                }
                writeTrailingComments(prop);
                writer.newLineIfLastNot();
            }
        });
        writer.write("}");
    }
    else if (Node.isConditionalExpression(node)) {
        const cond = node.getCondition();
        const whenTrue = node.getWhenTrue();
        const whenFalse = node.getWhenFalse();
        // TODO: this causes side effects; should these be funcs?
        writer.write("__COND__(");
        visitExpression(cond);
        writer.write(", ");
        visitExpression(whenTrue);
        writer.write(", ");
        visitExpression(whenFalse);
        writer.write(")");
    }
    else if (Node.isTemplateExpression(node)) {
        writer.write("__TEMPLATE__(");
        const head = node.getHead().getLiteralText();
        if (head) {
            writer.write(JSON.stringify(head));
        }

        const spans = node.getTemplateSpans();

        for (let i = 0; i < spans.length; i++) {
            const span = spans[i];
            if (i === 0 && head) {
                writer.write(", ");
            }

            visitExpression(span.getExpression());
            const literal = span.getLiteral().getLiteralText();
            if (literal) {
                writer.write(", ");
                writer.write(JSON.stringify(literal));
            }
            if (i < spans.length - 1) {
                writer.write(", ");
            }
        }
        writer.write(")");
    }
    else {
        writeTodoNode(node);
        writer.write(` TODO`);
    }
}

function isAssignmentOperator(kind: ts.SyntaxKind): boolean {
    switch (kind) {
        case ts.SyntaxKind.EqualsToken:
        case ts.SyntaxKind.BarEqualsToken:
        case ts.SyntaxKind.AmpersandEqualsToken:
        case ts.SyntaxKind.PlusEqualsToken:
        case ts.SyntaxKind.MinusEqualsToken:
        case ts.SyntaxKind.AsteriskEqualsToken:
        case ts.SyntaxKind.SlashEqualsToken:
        case ts.SyntaxKind.PercentEqualsToken:
        case ts.SyntaxKind.CaretEqualsToken:
        case ts.SyntaxKind.LessThanLessThanEqualsToken:
        case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
            return true;
        default:
            return false;
    }
}

function writeBinaryExpression(node: BinaryExpression, isStatement?: boolean) {
    const op = node.getOperatorToken();
    let tok: string;
    switch (op.getKind()) {
        case ts.SyntaxKind.AmpersandAmpersandToken:
        case ts.SyntaxKind.BarBarToken:
        case ts.SyntaxKind.LessThanEqualsToken:
        case ts.SyntaxKind.LessThanToken:
        case ts.SyntaxKind.GreaterThanEqualsToken:
        case ts.SyntaxKind.GreaterThanToken:
        case ts.SyntaxKind.AmpersandToken:
        case ts.SyntaxKind.BarToken:
        case ts.SyntaxKind.MinusToken:
        case ts.SyntaxKind.PlusToken:
        case ts.SyntaxKind.AsteriskToken:
        case ts.SyntaxKind.SlashToken:
        case ts.SyntaxKind.AsteriskAsteriskToken:
            tok = ts.tokenToString(op.getKind())!;
            break;
        case ts.SyntaxKind.EqualsEqualsEqualsToken:
            tok = "==";
            break;
        case ts.SyntaxKind.ExclamationEqualsEqualsToken:
            tok = "!=";
            break;
        default:
            if (isStatement && isAssignmentOperator(op.getKind())) {
                tok = ts.tokenToString(op.getKind())!;

                const left = node.getLeft();
                const right = node.getRight();
                if (Node.isConditionalExpression(right)) {
                    writeConditionalExpression(right, () => {
                        visitExpression(left);
                        writer.write(` ${tok} `);
                    });
                    return;
                }

                break;
            }

            writeTodoNode(node);
            writer.write(` TODO`);
            return;
    }

    visitExpression(node.getLeft());
    writer.write(` ${tok} `);
    visitExpression(node.getRight());
}

function sanitizeName(name: string | undefined) {
    switch (name) {
        case "break":
        case "case":
        case "chan":
        case "const":
        case "continue":
        case "default":
        case "defer":
        case "else":
        case "fallthrough":
        case "for":
        case "func":
        case "go":
        case "goto":
        case "if":
        case "import":
        case "interface":
        case "map":
        case "package":
        case "range":
        case "return":
        case "select":
        case "struct":
        case "switch":
        case "type":
        case "var":
            return `${name}_`;
        default:
            return name || "TODO";
    }
}

function getNameOfNamed(node: { getName(): string | undefined; }) {
    const name = sanitizeName(node.getName());
    if (/^[a-zA-Z0-9_]+$/.test(name)) {
        return name;
    }
    return `TODO_IDENTIFIER`;
}

function visitIfStatement(node: IfStatement) {
    writer.write("if ");
    visitExpression(node.getExpression());

    writer.write(" {");
    writer.indent(() => {
        const thenStatement = node.getThenStatement();
        if (thenStatement) {
            if (Node.isBlock(thenStatement)) {
                visitBlock(thenStatement);
            }
            else if (Node.isStatement(thenStatement)) {
                visitStatement(thenStatement);
            }
            else {
                writeTodoNode(node);
            }
        }
        writer.newLineIfLastNot();
    });

    const elseStatement = node.getElseStatement();
    if (elseStatement) {
        writer.write("} else ");
        if (Node.isIfStatement(elseStatement)) {
            return visitIfStatement(elseStatement);
        }
        writer.write("{");
        writer.indent(() => {
            if (Node.isBlock(elseStatement)) {
                visitBlock(elseStatement);
            }
            else if (Node.isStatement(elseStatement)) {
                visitStatement(elseStatement);
            }
            else {
                writeTodoNode(node);
            }
        });
        writer.write("}");
    }
    else {
        writer.write("}");
    }
}
function visitExpressionStatement(node: ExpressionStatement) {
    const expression = node.getExpression();
    visitExpression(expression, true);
    writer.newLine();
}

function writeTypeParameters(node: TypeParameteredNode) {
    const typeParameters = node.getTypeParameters();
    if (typeParameters.length > 0) {
        writer.write("[");

        for (let i = 0; i < typeParameters.length; i++) {
            const typeParameter = typeParameters[i];
            writer.write(getNameOfNamed(typeParameter));
            const constraint = typeParameter.getConstraint();
            if (constraint) {
                writer.write(" ");
                visitTypeNode(constraint);
            }
            writer.conditionalWrite(i < typeParameters.length - 1, ", ");
        }

        writer.write("]");
    }
}

function writeFunctionParametersAndReturn(
    node: FunctionDeclaration | ArrowFunction | MethodDeclaration | FunctionExpression,
) {
    writer.write("(");
    const params = node.getParameters();
    for (let i = 0; i < params.length; i++) {
        const param = params[i];
        writer.write(getNameOfNamed(param));
        writer.write(" ");
        const paramType = param.getTypeNode();
        if (paramType) {
            visitTypeNode(paramType);
        }
        else {
            writeType(node, param.getType());
        }
        const initializer = param.getInitializer();
        if (initializer) {
            writer.write(` ${asComment(" = " + initializer.getText())}`);
        }
        writer.conditionalWrite(i < params.length - 1, ", ");
    }
    writer.write(")");
    const ret = node.getReturnType();
    if (!ret.isVoid()) {
        writer.write(" ");
        const retNode = node.getReturnTypeNode();
        if (retNode) {
            visitTypeNode(retNode);
        }
        else {
            writeType(node, ret, true);
        }
    }
}

function writeBody(node: BodyableNode) {
    writer.write(" {");
    writer.indent(() => {
        const body = node.getBodyOrThrow();
        assert(Node.isBlock(body));
        visitBlock(body);
    });
    writer.write("}");
}

function visitBlock(node: Block) {
    node.getStatementsWithComments().forEach(visitStatement);
}

function writeLeadingComments(node: Node) {
    for (const range of node.getLeadingCommentRanges()) {
        if (range.compilerObject.hasTrailingNewLine) {
            writer.writeLine(range.getText());
        }
        else {
            writer.write(range.getText());
        }
    }
}

function writeTrailingComments(node: Node) {
    for (const range of node.getTrailingCommentRanges()) {
        if (range.compilerObject.hasTrailingNewLine) {
            writer.writeLine(range.getText());
        }
        else {
            writer.write(range.getText());
        }
    }
}

function visitStatement(node: Statement) {
    writer.newLineIfLastNot();
    if (!node.getPreviousSibling()?.getKindName()?.endsWith("Trivia")) {
        writeLeadingComments(node);
    }

    visitStatement2(node);

    if (!node.getNextSibling()?.getKindName()?.endsWith("Trivia")) {
        writeTrailingComments(node);
    }
}

function visitStatement2(node: Statement) {
    writer.newLineIfLastNot();

    if (Node.isImportDeclaration(node)) {
        return;
    }

    if (Node.isTypeAliasDeclaration(node)) {
        writer.write(`type ${getNameOfNamed(node)}`);
        writeTypeParameters(node);
        writer.write(" ");
        visitTypeNode(node.getTypeNodeOrThrow());

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isFunctionDeclaration(node)) {
        if (!node.hasBody()) {
            writer.write(asComment(`OVERLOAD: ${node.getText()}`));
            return;
        }

        const isGlobal = node.getParentIf((p): p is Node => Node.isSourceFile(p)) !== undefined;

        if (!isGlobal) {
            writer.write(`${getNameOfNamed(node)} := func`);
            if (node.isGenerator()) {
                writer.write("/* generator */");
            }
        }
        else {
            writer.write(`func `);
            if (node.isGenerator()) {
                writer.write("/* generator */");
            }
            writer.write(`${getNameOfNamed(node)}`);
        }

        writeFunctionParametersAndReturn(node);
        writeBody(node);

        writer.newLine();
        return;
    }

    if (Node.isInterfaceDeclaration(node)) {
        writer.write(`type ${getNameOfNamed(node)}`);
        writeTypeParameters(node);
        writer.write(" struct {");
        writer.indent(() => {
            const members = node.getMembers();
            for (const member of members) {
                if (Node.isMethodSignature(member)) {
                    assert.fail("oops");
                }
                else if (Node.isPropertySignature(member)) {
                    writer.write(`${getNameOfNamed(member)} `);
                    visitTypeNode(member.getTypeNodeOrThrow());
                    writer.newLine();
                }
                else {
                    writeTodoNode(node);
                }
            }
        });
        writer.write("}");

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isVariableStatement(node)) {
        const isGlobal = node.getParentIf((p): p is Node => Node.isSourceFile(p)) !== undefined;

        const declarations = node.getDeclarations();

        for (const declaration of declarations) {
            const typeNode = declaration.getTypeNode();
            const initializer = declaration.getInitializer();

            if (!isGlobal && Node.isConditionalExpression(initializer)) {
                writer.write(`var ${getNameOfNamed(declaration)} `);
                if (typeNode) {
                    visitTypeNode(typeNode);
                }
                else {
                    writeType(declaration, declaration.getType());
                }
                writeConditionalExpression(
                    initializer,
                    () => writer.write(`${getNameOfNamed(declaration)} = `),
                );
            }
            else if (isGlobal) {
                writer.write(`var ${getNameOfNamed(declaration)}`);
                if (typeNode) {
                    writer.write(" ");
                    visitTypeNode(typeNode);
                }
                if (initializer) {
                    writer.write(" = ");
                    visitExpression(initializer);
                }
            }
            else {
                if (typeNode) {
                    writer.write(`var ${getNameOfNamed(declaration)} `);
                    visitTypeNode(typeNode);
                    if (initializer) {
                        writer.write(" = ");
                        visitExpression(initializer);
                    }
                }
                else if (initializer) {
                    writer.write(`${getNameOfNamed(declaration)} := `);
                    visitExpression(initializer);
                }
                else {
                    // No annotation or inferred type, comes from something later...
                    writer.write(`var ${getNameOfNamed(declaration)} TODO`);
                }
            }
            writer.newLineIfLastNot();
        }

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isEnumDeclaration(node)) {
        const enumName = getNameOfNamed(node);

        writer.write(`type ${enumName}`);
        if (node.getMembers()[0].getInitializer()?.getKindName() === "StringLiteral") {
            writer.write(` string`);
        }
        else {
            writer.write(` int32`);
        }

        writer.writeLine(`const (`);
        writer.indent(() => {
            const members = node.getMembers();
            const nameMapping = new Map<string, string>();
            for (const member of members) {
                const memberName = getNameOfNamed(member);
                nameMapping.set(memberName, `${enumName}${memberName}`);
            }
            const replacements = [...nameMapping.entries()].sort((a, b) => b[0].length - a[0].length);

            for (let i = 0; i < members.length; i++) {
                const member = members[i];
                writeLeadingComments(member);
                const memberName = nameMapping.get(getNameOfNamed(member))!;
                writer.write(`${memberName} `);
                const initializer = member.getInitializer();
                if (i === 0 && !initializer) {
                    writer.write(`${enumName} = iota`);
                }
                else if (initializer) {
                    let initializerText = initializer.getText();

                    for (const [name, value] of replacements) {
                        initializerText = initializerText.replaceAll(name, value);
                    }

                    writer.write(`${enumName} = ${initializerText}`);
                }
                writer.newLineIfLastNot();
                writeTrailingComments(member);
                writer.newLineIfLastNot();
            }
        });
        writer.writeLine(")");

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isModuleDeclaration(node)) {
        if (node.getName() === "JsxNames") {
            // Special case for JsxNames only
            const exports = new Map<string, string>();

            for (const statement of node.getStatements()) {
                assert(Node.isVariableStatement(statement), statement.getKindName());
                assert(statement.isExported());

                const declaration = statement.getDeclarationList().getDeclarations()[0];

                const name = getNameOfNamed(declaration);
                const initializer = declaration.getInitializerOrThrow();
                assert(Node.isAsExpression(initializer), initializer.getKindName());
                const left = initializer.getExpression();
                assert(Node.isStringLiteral(left), left.getKindName());
                exports.set(name, left.getLiteralText());
            }

            writer.write("var JsxNames = struct {");
            writer.indent(() => {
                for (const [name, value] of exports) {
                    writer.write(`${name} __String`);
                    writer.newLine();
                }
            });
            writer.write("} {");
            writer.indent(() => {
                for (const [name, value] of exports) {
                    writer.write(`${name}: __String(${JSON.stringify(value)}),`);
                    writer.newLine();
                }
            });
            writer.write("}");

            return;
        }

        writeTodoNode(node);

        writer.newLineIfLastNot();
        return;
    }

    if (Node.isExpressionStatement(node)) {
        // Handling expressions separately so we _don't_ handle side effect expressions in writeExpression
        visitExpressionStatement(node);
        return;
    }

    if (Node.isReturnStatement(node)) {
        writer.newLineIfLastNot();

        const expression = node.getExpression();
        if (Node.isConditionalExpression(expression)) {
            writeConditionalExpression(expression, () => writer.write("return "));
            return;
        }

        if (Node.isBinaryExpression(expression) && isAssignmentOperator(expression.getOperatorToken().getKind())) {
            writeBinaryExpression(expression, true);
            writer.newLine();
            writer.write("return ");
            visitExpression(expression.getLeft());
            writer.newLine();
            return;
        }

        writer.write("return");
        if (expression) {
            writer.write(" ");
            visitExpression(expression);
        }
        writer.newLine();
        return;
    }

    if (Node.isContinueStatement(node)) {
        const label = node.getLabel();
        writer.write("continue");
        if (label) {
            writer.write(` ${sanitizeName(label.getText())}`);
        }
        writer.newLine();
        return;
    }

    if (Node.isBreakStatement(node)) {
        const label = node.getLabel();
        writer.write("break");
        if (label) {
            writer.write(` ${sanitizeName(label.getText())}`);
        }
        writer.newLine();
        return;
    }

    if (Node.isIfStatement(node)) {
        visitIfStatement(node);
        return;
    }

    if (Node.isForOfStatement(node)) {
        writer.write("for _, ");
        const initializer = node.getInitializer();
        if (Node.isVariableDeclarationList(initializer)) {
            writer.write(getNameOfNamed(initializer.getDeclarations()[0]));
        }
        else {
            writeTodoNode(initializer);
        }
        writer.write(" := range ");
        visitExpression(node.getExpression());
        writer.write(" {");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isForStatement(node)) {
        writer.write("for ");
        const initializer = node.getInitializer();
        if (initializer) {
            if (Node.isVariableDeclarationList(initializer)) {
                const declarations = initializer.getDeclarations();
                if (declarations.length > 1) {
                    writeTodoNode(initializer);
                }
                else {
                    const declaration = declarations[0];
                    writer.write(`${getNameOfNamed(declaration)} := `);
                    visitExpression(declaration.getInitializerOrThrow());
                }
            }
            else {
                visitExpression(initializer, true);
            }
        }
        writer.write("; ");
        const condition = node.getCondition();
        if (condition) {
            visitExpression(condition);
        }
        writer.write("; ");
        const incrementor = node.getIncrementor();
        if (incrementor) {
            visitExpression(incrementor, true);
        }
        writer.write(" {");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isWhileStatement(node)) {
        writer.write("for ");
        visitExpression(node.getExpression());
        writer.write(" {");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isDoStatement(node)) {
        writer.write("for ok := true; ok; ok = ");
        visitExpression(node.getExpression());
        writer.write(" { // do-while loop");
        writer.indent(() => {
            visitStatement(node.getStatement());
        });
        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isBlock(node)) {
        visitBlock(node);
        return;
    }

    if (Node.isSwitchStatement(node)) {
        writer.write("switch ");
        visitExpression(node.getExpression());
        writer.write(" {");
        const clauses = node.getClauses();

        function groupClauses() {
            // Group clauses into:
            // - Zero or more clauses with no statements followed by one non-empty case clause
            // - Default clauses
            // Groups should consist of (start, end] indices

            let groups: [number, number][] = [];

            let start = 0;

            while (start < clauses.length) {
                const first = clauses[start];
                if (Node.isDefaultClause(first)) {
                    groups.push([start, start + 1]);
                    start++;
                    continue;
                }

                const found = clauses.findIndex(
                    (clause, i) => i >= start && (Node.isDefaultClause(clause) || clause.getStatements().length > 0),
                );
                if (found === -1) {
                    groups.push([start, start + 1]);
                    start++;
                    continue;
                }

                if (Node.isDefaultClause(clauses[found])) {
                    groups.push([start, found]);
                    start = found;
                }
                else {
                    groups.push([start, found + 1]);
                    start = found + 1;
                }
            }

            return groups;
        }

        for (const [start, end] of groupClauses()) {
            function writeColonAndCaseBody(clause: CaseOrDefaultClause, idx: number) {
                const isLastClause = idx === clauses.length - 1;
                let statementsOfClause = clause.getStatements();
                const lastStatementOfClause = statementsOfClause.at(-1);
                if (lastStatementOfClause?.isKind(ts.SyntaxKind.BreakStatement)) {
                    statementsOfClause = statementsOfClause.slice(0, -1);
                }

                const fallsThrough = !isLastClause
                    && !lastStatementOfClause?.isKind(ts.SyntaxKind.BreakStatement)
                    && !lastStatementOfClause?.isKind(ts.SyntaxKind.ReturnStatement);

                writer.write(":");
                writer.indent(() => {
                    for (const statement of statementsOfClause) {
                        visitStatement(statement);
                    }
                    if (fallsThrough) {
                        writer.newLineIfLastNot();
                        writer.writeLine("fallthrough");
                    }
                });
            }

            const startingClause = clauses[start];
            if (Node.isCaseClause(startingClause)) {
                writer.newLineIfLastNot();
                writer.write("case ");
                for (let i = start; i < end; i++) {
                    const isLastInGroup = i === end - 1;

                    const clause = clauses[i];
                    assert(Node.isCaseClause(clause));
                    const expression = clause.getExpression();
                    visitExpression(expression);
                    if (isLastInGroup) {
                        writeColonAndCaseBody(clause, i);
                    }
                    else {
                        writer.write(",");
                        writer.newLine();
                    }
                }
            }
            else {
                writer.newLineIfLastNot();
                writer.write("default");
                writeColonAndCaseBody(startingClause, start);
            }
        }

        writer.write("}");
        writer.newLineIfLastNot();
        return;
    }

    if (Node.isCommentStatement(node)) {
        writer.write(node.getText());
        return;
    }

    if (Node.isLabeledStatement(node)) {
        const label = node.getLabel().getText();
        writer.write(`${sanitizeName(label)}: `);
        visitStatement(node.getStatement());
        return;
    }

    if (Node.isTryStatement(node)) {
        writer.write("{ // try");
        writer.indent(() => {
            visitStatement(node.getTryBlock());
        });
        writer.writeLine("}");
        const catchClause = node.getCatchClause();
        if (catchClause) {
            writer.write(`// catch ${catchClause.getVariableDeclaration()?.getText() ?? ""}`);
            writer.indent(() => {
                visitStatement(catchClause.getBlock());
            });
            writer.writeLine("}");
            writer.newLineIfLastNot();
        }
        const finallyBlock = node.getFinallyBlock();
        if (finallyBlock) {
            writer.write("{ // finally");
            writer.indent(() => {
                visitStatement(finallyBlock);
            });
            writer.writeLine("}");
            writer.newLineIfLastNot();
        }
        return;
    }

    writeTodoNode(node);
    // console.error(`Unhandled node kind: ${node.getKindName()}`);
}

sourceFile.getStatementsWithComments().forEach(visitStatement);

const outFile = Bun.file("output.go.txt");

await Bun.write(outFile, writer.toString());

const formatted = await execa("gofmt", ["-w", "output.go.txt"], { reject: false });
if (formatted.exitCode === 0) {
    // await Bun.write(outFile, formatted.stdout);
    console.log("All good!");
}
else {
    console.log(formatted.stderr);
}

const totalTodo = [...todoCounts.values()].reduce((a, b) => a + b, 0);
console.log(`Total TODOs: ${totalTodo}`);
console.log([...todoCounts.entries()].sort((a, b) => b[1] - a[1]).map(([k, v]) => `${k} ${v}`).join("\n"));
