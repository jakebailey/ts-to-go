import assert from "assert";
import cp from "child_process";
import CodeBlockWriter from "code-block-writer";
import path from "path";
import {
    ArrowFunction,
    BinaryExpression,
    Block,
    BodyableNode,
    type CaseOrDefaultClause,
    CommentStatement,
    ConditionalExpression,
    Expression,
    ExpressionStatement,
    FunctionDeclaration,
    FunctionExpression,
    IfStatement,
    MethodDeclaration,
    Node,
    Project,
    Statement,
    ts,
    Type,
    TypeNode,
    TypeParameteredNode,
} from "ts-morph";
import which from "which";

const root = "/home/jabaile/work/ts-native-pin/src/compiler";
function pathFor(s: string) {
    return path.join(root, s);
}

const tsCommit = cp.execFileSync(which.sync("git"), ["rev-parse", "HEAD"], { cwd: root, encoding: "utf8" }).trim();

const project = new Project({
    tsConfigFilePath: pathFor("tsconfig.json"),
});

async function convert(filename: string, output: string, mainStruct?: string) {
    const createFunction = mainStruct ? `create${mainStruct}` : undefined;
    let methodReceiver: string | undefined;
    if (mainStruct) {
        switch (mainStruct) {
            case "TypeChecker":
                methodReceiver = "c";
                break;
            case "Binder":
                methodReceiver = "b";
                break;
            case "Scanner":
                methodReceiver = "scanner";
                break;
            case "Printer":
                methodReceiver = "printer";
                break;
            default:
                throw new Error(`Unknown main struct: ${mainStruct}`);
        }
    }

    console.log(`Converting ${filename} to ${output}...`);

    const sourceFile = project.getSourceFileOrThrow(pathFor(filename));

    const writer = new CodeBlockWriter({
        useTabs: true,
    });

    writer.writeLine(`// Code generated by ts-to-go at ${tsCommit}. DO NOT EDIT.`);
    writer.newLine();
    writer.writeLine("package output");
    writer.newLine();

    // writer.writeLine("func __COND__[C comparable, T any](cond C, a T, b T) T {");
    // writer.indent(() => {
    //     writer.writeLine("var zero C");
    //     writer.writeLine("if cond != zero {");
    //     writer.indent(() => {
    //         writer.writeLine("return a");
    //     });
    //     writer.writeLine("}");
    //     writer.writeLine("return b");
    // });
    // writer.writeLine("}");
    // writer.newLine();

    function asComment(text: string) {
        text = text.replaceAll("*/", "* /");
        text = text.replace(/(\r?\n\s*)+/gm, " ");
        assert(!text.includes("\n"));
        return `/* ${text} */`;
    }

    const todoCounts = new Map<string, number>();

    function writeTodoNode(node: Node) {
        let nodeKind = "Node";
        if (Node.isBinaryExpression(node)) {
            const token = node.getOperatorToken().getKindName();
            nodeKind = token;
        }
        else if (Node.isTypeNode(node)) {
            nodeKind = "TypeNode";
        }
        const kindName = node.getKindName();
        const todoName = `${nodeKind} ${kindName}`;
        const count = todoCounts.get(todoName) || 0;
        todoCounts.set(todoName, count + 1);
        writer.write(asComment(`TODO(TS-TO-GO) ${todoName}: ${node.getText()}`));
    }

    function isIdentifier(text: string) {
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(text);
    }

    function isInterfaceTypeName(name: string) {
        switch (name) {
            case "Node":
            case "*Node":
            case "Declaration":
            case "Expression":
            case "Statement":
            case "Type":
            case "*Type":
            case "CancellationToken":
            case "any":
            case "unknown":
            case "void":
            case "Symbol":
            case "*Symbol":
                return true;
            default:
                return false;
        }
    }

    function typeStringToGo(text: string): string {
        text = text.replace(/import\([^)]+\)\./g, "");
        text = text.trim();

        switch (text) {
            case "__String":
                return "string";
            case "boolean":
                return "bool";
            case "void":
                return "void";
            case "object":
                return "any";
            case "{}":
                return "any";
            case "unknown":
                return "any";
            case "Symbol":
                return "*Symbol";
            case "Node":
                return "*Node";
            case "Type":
                return "*Type";
        }

        if (isIdentifier(text)) {
            return text;
        }

        const orUndefined = " | undefined";
        if (!text.startsWith("*") && text.endsWith(orUndefined)) {
            text = text.slice(0, -orUndefined.length);
            const goType = typeStringToGo(text);
            if (isInterfaceTypeName(goType)) {
                return goType;
            }
            assert(goType);
            return "*" + goType;
        }

        const bracketBracket = "[]";
        if (text.endsWith(bracketBracket)) {
            text = text.slice(0, -bracketBracket.length);
            return `[]${typeStringToGo(text)}`;
        }

        const readonly = "readonly ";
        if (text.startsWith(readonly)) {
            text = text.slice(readonly.length);
            return typeStringToGo(text);
        }

        const set = "Set<";
        if (text.startsWith(set)) {
            text = text.slice(set.length, -1);
            return `Set[${typeStringToGo(text)}]`;
        }

        const map = "Map<";
        if (text.startsWith(map)) {
            text = text.slice(map.length, -1);
            const [key, value] = text.split(", ", 2);
            return `Map[${typeStringToGo(key)}, ${typeStringToGo(value)}]`;
        }

        const nodeArray = "NodeArray<";
        if (text.startsWith(nodeArray)) {
            text = text.slice(nodeArray.length, -1);
            return `NodeArray[${typeStringToGo(text)}]`;
        }

        const todoName = "Type";
        const count = todoCounts.get(todoName) || 0;
        todoCounts.set(todoName, count + 1);
        return `${asComment("TODO(TS-TO-GO) inferred type " + text)} any`;
    }

    function writeType(host: Node, node: Type, isReturn?: boolean): void {
        const text = typeStringToGo(node.getText(host));
        if (isReturn && text === "void") {
            return;
        }
        writer.write(text);
    }

    function visitTypeNode(type: TypeNode): void {
        // In Go, there's never a reason to parenthesize a type.
        while (Node.isParenthesizedTypeNode(type)) {
            type = type.getTypeNode();
        }

        if (Node.isFunctionTypeNode(type)) {
            writer.write("func(");
            const params = type.getParameters();
            for (let i = 0; i < params.length; i++) {
                const param = params[i];
                writer.write(getNameOfNamed(param));
                writer.write(" ");
                visitTypeNode(param.getTypeNodeOrThrow());
                writer.conditionalWrite(i < params.length - 1, ", ");
            }
            writer.write(") ");
            const ret = type.getReturnTypeNodeOrThrow();
            visitTypeNode(ret);
        }
        else if (Node.isBooleanKeyword(type)) {
            writer.write("bool");
        }
        else if (Node.isStringKeyword(type)) {
            writer.write("string");
        }
        else if (Node.isNumberKeyword(type)) {
            writer.write("number");
        }
        else if (Node.isNeverKeyword(type)) {
            writer.write("never");
        }
        else if (Node.isObjectKeyword(type)) {
            writer.write("any");
        }
        else if (type.getText() === "void") {
            const parent = type.getParentIfKind(ts.SyntaxKind.FunctionType);
            if (parent?.getReturnTypeNode() !== type) {
                writer.write("void");
            }
        }
        else if (Node.isArrayTypeNode(type)) {
            writer.write("[]");
            visitTypeNode(type.getElementTypeNode());
        }
        else if (Node.isTypeOperatorTypeNode(type)) {
            visitTypeNode(type.getTypeNode());
        }
        else if (Node.isTypeReference(type)) {
            const name = type.getTypeName();
            if (Node.isIdentifier(name)) {
                writer.write(typeStringToGo(sanitizeName(name.getText())));
            }
            else {
                writeTodoNode(name);
                writer.write(` any`);
            }
            const typeArguments = type.getTypeArguments();
            if (typeArguments.length > 0) {
                writer.write("[");
                for (let i = 0; i < typeArguments.length; i++) {
                    visitTypeNode(typeArguments[i]);
                    writer.conditionalWrite(i < typeArguments.length - 1, ", ");
                }
                writer.write("]");
            }
        }
        else if (Node.isUnionTypeNode(type)) {
            if (type.getTypeNodes().length === 2) {
                let [a, b] = type.getTypeNodes();
                if (Node.isUndefinedKeyword(a)) {
                    [a, b] = [b, a];
                }
                if (Node.isUndefinedKeyword(b)) {
                    if (!isInterfaceTypeName(a.getText())) {
                        writer.write("*");
                    }
                    visitTypeNode(a);
                }
                else {
                    writeTodoNode(type);
                    writer.write(` any`);
                }
            }
            else {
                writeTodoNode(type);
                writer.write(` any`);
            }
        }
        else if (Node.isAnyKeyword(type) || type.getText() === "unknown") {
            writer.write("any");
        }
        else {
            writeTodoNode(type);
            writer.write(` any`);
        }
    }

    function writeConditionalExpression(node: ConditionalExpression, sideEffect: () => void) {
        if (Node.isConditionalExpression(node.getWhenTrue()) || Node.isConditionalExpression(node.getWhenFalse())) {
            writeConditionalExpressionAsSwitchCase(node, sideEffect);
        }
        else {
            writeConditionalExpressionAsIfElse(node, sideEffect);
        }
    }

    function writeConditionalExpressionAsSwitchCase(node: ConditionalExpression, sideEffect: () => void) {
        writer.newLineIfLastNot();
        writer.write("switch {");

        let ladder: Expression = node;
        while (Node.isConditionalExpression(ladder)) {
            const cond = ladder.getCondition();
            const whenTrue = ladder.getWhenTrue();
            const whenFalse = ladder.getWhenFalse();

            writer.newLine();
            writer.write("case ");
            visitExpression(cond);
            writer.write(":");
            writer.indent(() => {
                if (Node.isConditionalExpression(whenTrue)) {
                    writeConditionalExpression(whenTrue, sideEffect);
                }
                else {
                    sideEffect();
                    visitExpression(whenTrue);
                }
            });

            ladder = whenFalse;
        }

        writer.newLine();
        writer.write("default:");
        writer.indent(() => {
            sideEffect();
            visitExpression(ladder);
        });
        writer.newLine();
        writer.write("}");
        return;
    }

    function writeConditionalExpressionAsIfElse(node: ConditionalExpression, sideEffect: () => void) {
        const cond = node.getCondition();
        const whenTrue = node.getWhenTrue();
        const whenFalse = node.getWhenFalse();

        writer.newLineIfLastNot();
        writer.write("if ");
        visitExpression(cond);
        writer.write(" {");
        writer.indent(() => {
            sideEffect();
            visitExpression(whenTrue);
        });
        writer.write("} else {");
        writer.indent(() => {
            sideEffect();
            visitExpression(whenFalse);
        });
        writer.write("}");
    }

    function isVariableForMainStruct(node: Node) {
        if (!createFunction) return false;
        const block = node.getFirstAncestorByKind(ts.SyntaxKind.Block);
        return block?.getParentIfKind(ts.SyntaxKind.FunctionDeclaration)?.getName() === createFunction;
    }

    function visitExpression(node: Expression, inStatement?: boolean): void {
        if (Node.isRegularExpressionLiteral(node)) {
            const re = node.getLiteralValue();
            let source = re.source.replaceAll("`", "\\`");

            for (const flag of re.flags.split("")) {
                switch (flag) {
                    case "i":
                        source = `(?i:${source})`;
                        break;
                    default:
                        writeTodoNode(node);
                        writer.write(` TODO`);
                        return;
                }
            }

            writer.write(`regexp.MustParse(\`${source}\`)`);
        }
        else if (Node.isLiteralExpression(node)) {
            if (Node.isStringLiteral(node)) {
                writer.write(JSON.stringify(node.getLiteralValue()));
            }
            else {
                writer.write(node.getText());
            }
        }
        else if (Node.isAsExpression(node)) {
            visitExpression(node.getExpression());
            const type = node.getTypeNodeOrThrow();
            if (Node.isTypeReference(type) && !Node.isStringLiteral(node.getExpression())) {
                const entity = type.getTypeName();
                if (Node.isIdentifier(entity)) {
                    writer.write(".(");
                    visitTypeNode(type);
                    writer.write(")");
                    return;
                }
            }
            writer.write(` ${asComment("as " + node.getTypeNodeOrThrow().getText())}`);
        }
        else if (Node.isNonNullExpression(node)) {
            visitExpression(node.getExpression());
            // writer.write("/* TODO(TS-TO-GO): was ! */");
        }
        else if (Node.isIdentifier(node) || node.getText() === "this") {
            if (node.getText() === "undefined") {
                writer.write("nil");
            }
            else {
                const id = sanitizeName(node.getText());
                if (structFields.has(id)) {
                    const nodeSym = node.getSymbolOrThrow();
                    const decl = nodeSym.getValueDeclaration() ?? nodeSym.getDeclarations()[0];
                    if (isVariableForMainStruct(decl)) {
                        writer.write(`${methodReceiver}.${id}`);
                    }
                    else {
                        writer.write(id);
                    }
                }
                else {
                    writer.write(id);
                }
            }
        }
        else if (Node.isCallExpression(node)) {
            const expression = node.getExpression();

            if (Node.isPropertyAccessExpression(expression)) {
                const name = expression.getNameNode();
                const expr = expression.getExpression();
                if (Node.isStringLiteral(expr)) {
                    switch (name.getText()) {
                        case "padStart":
                            writer.write("PAD_START(");
                            visitExpression(expr);
                            if (node.getArguments().length === 1) {
                                writer.write(", ");
                                const arg = node.getArguments()[0];
                                assert(Node.isExpression(arg));
                                visitExpression(arg);
                            }
                            writer.write(")");
                            return;
                        default:
                            throw new Error(`Unexpected string property access: ${name.getText()}`);
                    }
                }
                else if (Node.isIdentifier(expr) && expr.getText() === "Math") {
                    switch (name.getText()) {
                        case "max": {
                            writer.write("max(");
                            const args = node.getArguments();
                            for (let i = 0; i < args.length; i++) {
                                const arg = args[i];
                                assert(Node.isExpression(arg));
                                visitExpression(arg);
                                writer.conditionalWrite(i < args.length - 1, ", ");
                            }
                            writer.write(")");
                            return;
                        }
                        case "min": {
                            writer.write("min(");
                            const args = node.getArguments();
                            for (let i = 0; i < args.length; i++) {
                                const arg = args[i];
                                assert(Node.isExpression(arg));
                                visitExpression(arg);
                                writer.conditionalWrite(i < args.length - 1, ", ");
                            }
                            writer.write(")");
                            return;
                        }
                    }
                }
            }

            visitExpression(expression);
            writer.write("(");
            const args = node.getArguments();
            for (let i = 0; i < args.length; i++) {
                const expr = args[i];
                const comment = expr.getPreviousSibling()?.getTrailingCommentRanges().at(0)?.getText();
                if (comment?.startsWith("/*")) {
                    writer.write(comment);
                }
                assert(Node.isExpression(expr));
                visitExpression(expr);
                writer.conditionalWrite(i < args.length - 1, ", ");
            }
            writer.write(")");
        }
        else if (Node.isPrefixUnaryExpression(node)) {
            let token = ts.tokenToString(node.getOperatorToken())!;
            if (token === "~") {
                token = "^";
            }
            if (inStatement && (token === "++" || token === "--")) {
                visitExpression(node.getOperand());
                writer.write(token);
            }
            else if (token === "++" || token === "--") {
                writeTodoNode(node);
                writer.write(` TODO`);
            }
            else {
                writer.write(token);
                visitExpression(node.getOperand());
            }
        }
        else if (Node.isParenthesizedExpression(node)) {
            writer.write("(");
            visitExpression(node.getExpression());
            writer.write(")");
        }
        else if (Node.isBinaryExpression(node)) {
            writeBinaryExpression(node, inStatement);
        }
        else if (Node.isTrueLiteral(node)) {
            writer.write("true");
        }
        else if (Node.isFalseLiteral(node)) {
            writer.write("false");
        }
        else if (Node.isPropertyAccessExpression(node)) {
            // Check for enum accesses first
            const expression = node.getExpression();
            if (Node.isIdentifier(expression)) {
                const type = expression.getType();
                if (type.isEnum()) {
                    const enumName = expression.getText();
                    writer.write(`${enumName}${getNameOfNamed(node)}`);
                    return;
                }
            }

            const expr = node.getExpression();
            const name = node.getNameNode();
            if (Node.isStringLiteral(node.getExpression())) {
                switch (name.getText()) {
                    case "length":
                        writer.write("len(");
                        visitExpression(expr);
                        writer.write(")");
                        return;
                    default:
                        throw new Error(`Unexpected string property access: ${name.getText()}`);
                }
            }

            visitExpression(expr);
            if (node.hasQuestionDotToken()) {
                writer.write("/* ? */");
            }
            writer.write(`.${sanitizeName(name.getText())}`);
        }
        else if (Node.isElementAccessExpression(node)) {
            visitExpression(node.getExpression());
            writer.write("[");
            visitExpression(node.getArgumentExpressionOrThrow());
            writer.write("]");
        }
        else if (Node.isArrowFunction(node) || Node.isFunctionExpression(node)) {
            writer.write("func");
            if (Node.isFunctionExpression(node)) {
                const name = node.getName();
                if (name) {
                    writer.write(` ${asComment(node.getName()!)}`);
                }
                if (node.isGenerator()) {
                    writer.write(` ${asComment("generator")}`);
                }
            }

            writeFunctionParametersAndReturn(node);
            writer.write(" {");
            writer.indent(() => {
                const body = node.getBody();
                if (Node.isBlock(body)) {
                    visitBlock(body);
                }
                else {
                    assert(Node.isExpression(body));
                    if (Node.isConditionalExpression(body)) {
                        writeConditionalExpression(body, () => writer.write("return "));
                    }
                    else {
                        writer.write("return ");
                        visitExpression(body);
                    }
                }
            });
            writer.write("}");
        }
        else if (Node.isNewExpression(node)) {
            const expression = node.getExpression();
            if (Node.isIdentifier(expression)) {
                const name = sanitizeName(expression.getText());
                writer.write(`New${name}`);
                const typeArguments = node.getTypeArguments();
                if (typeArguments.length > 0) {
                    writer.write("[");
                    for (let i = 0; i < typeArguments.length; i++) {
                        visitTypeNode(typeArguments[i]);
                        writer.conditionalWrite(i < typeArguments.length - 1, ", ");
                    }
                    writer.write("]");
                }
                writer.write("(");
                const args = node.getArguments();
                for (let i = 0; i < args.length; i++) {
                    const arg = args[i];
                    assert(Node.isExpression(arg));
                    visitExpression(arg);
                    writer.conditionalWrite(i < args.length - 1, ", ");
                }
                writer.write(")");
                return;
            }
            writeTodoNode(node);
            writer.write(` TODO`);
        }
        else if (Node.isVoidExpression(node)) {
            visitExpression(node.getExpression());
            return;
        }
        else if (Node.isYieldExpression(node)) {
            writer.write("yield(");
            visitExpression(node.getExpressionOrThrow());
            writer.write(")");
            return;
        }
        else if (Node.isPostfixUnaryExpression(node)) {
            const tokenStr = ts.tokenToString(node.getOperatorToken());
            if (tokenStr) {
                if (!inStatement && (tokenStr === "++" || tokenStr === "--")) {
                    writeTodoNode(node);
                    writer.write(` TODO`);
                    return;
                }

                visitExpression(node.getOperand());
                writer.write(tokenStr);
                return;
            }
            writeTodoNode(node);
            writer.write(` TODO`);
            return;
        }
        else if (Node.isSpreadElement(node)) {
            visitExpression(node.getExpression());
            writer.write("...");
            return;
        }
        else if (Node.isArrayLiteralExpression(node)) {
            writer.write("[]");
            const type = node.getType().getArrayElementType();
            if (type) {
                writer.write(" ");
                writeType(node, type);
            }
            else {
                writer.write("any");
            }

            writer.write("{");
            const elements = node.getElements();
            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                if (Node.isSpreadElement(element)) {
                    writeTodoNode(element);
                }
                else {
                    visitExpression(element);
                    writer.conditionalWrite(i < elements.length - 1, ", ");
                }
            }
            writer.write("}");
        }
        else if (Node.isObjectLiteralExpression(node)) {
            writer.write("map[any]any{ /* TODO(TS-TO-GO): was object literal */");
            writer.indent(() => {
                const properties = node.getProperties();
                for (const prop of properties) {
                    writeLeadingComments(prop);
                    if (Node.isShorthandPropertyAssignment(prop)) {
                        writer.write(`"${getNameOfNamed(prop)}": ${getNameOfNamed(prop)}`);
                        writer.write(",");
                    }
                    else if (Node.isPropertyAssignment(prop)) {
                        writer.write(`"${getNameOfNamed(prop)}": `);
                        visitExpression(prop.getInitializerOrThrow());
                        writer.write(",");
                    }
                    else if (Node.isMethodDeclaration(prop)) {
                        writer.write(`"${getNameOfNamed(prop)}": func`);
                        writeTypeParameters(prop);
                        writeFunctionParametersAndReturn(prop);
                        writeBody(prop);
                        writer.write(",");
                    }
                    else {
                        writeTodoNode(prop);
                    }
                    writeTrailingComments(prop);
                    writer.newLineIfLastNot();
                }
            });
            writer.write("}");
        }
        else if (Node.isConditionalExpression(node)) {
            const cond = node.getCondition();
            const whenTrue = node.getWhenTrue();
            const whenFalse = node.getWhenFalse();
            // TODO: this causes side effects; should these be funcs?
            writer.write("ifElse(");
            visitExpression(cond);
            writer.write(", ");
            visitExpression(whenTrue);
            writer.write(", ");
            visitExpression(whenFalse);
            writer.write(")");
        }
        else if (Node.isTemplateExpression(node)) {
            writer.write("__TEMPLATE__(");
            const head = node.getHead().getLiteralText();
            if (head) {
                writer.write(JSON.stringify(head));
            }

            const spans = node.getTemplateSpans();

            for (let i = 0; i < spans.length; i++) {
                const span = spans[i];
                if (i === 0 && head) {
                    writer.write(", ");
                }

                visitExpression(span.getExpression());
                const literal = span.getLiteral().getLiteralText();
                if (literal) {
                    writer.write(", ");
                    writer.write(JSON.stringify(literal));
                }
                if (i < spans.length - 1) {
                    writer.write(", ");
                }
            }
            writer.write(")");
        }
        else {
            writeTodoNode(node);
            writer.write(` TODO`);
        }
    }

    function isAssignmentOperator(kind: ts.SyntaxKind): boolean {
        switch (kind) {
            case ts.SyntaxKind.EqualsToken:
            case ts.SyntaxKind.BarEqualsToken:
            case ts.SyntaxKind.AmpersandEqualsToken:
            case ts.SyntaxKind.PlusEqualsToken:
            case ts.SyntaxKind.MinusEqualsToken:
            case ts.SyntaxKind.AsteriskEqualsToken:
            case ts.SyntaxKind.SlashEqualsToken:
            case ts.SyntaxKind.PercentEqualsToken:
            case ts.SyntaxKind.CaretEqualsToken:
            case ts.SyntaxKind.LessThanLessThanEqualsToken:
            case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:
            case ts.SyntaxKind.BarBarEqualsToken:
                return true;
            default:
                return false;
        }
    }

    function writeBinaryExpression(node: BinaryExpression, isStatement?: boolean) {
        const op = node.getOperatorToken();
        const left = node.getLeft();
        let right = node.getRight();

        let tok: string | undefined;
        switch (op.getKind()) {
            case ts.SyntaxKind.AmpersandAmpersandToken:
            case ts.SyntaxKind.BarBarToken:
            case ts.SyntaxKind.LessThanEqualsToken:
            case ts.SyntaxKind.LessThanToken:
            case ts.SyntaxKind.GreaterThanEqualsToken:
            case ts.SyntaxKind.GreaterThanToken:
            case ts.SyntaxKind.AmpersandToken:
            case ts.SyntaxKind.BarToken:
            case ts.SyntaxKind.MinusToken:
            case ts.SyntaxKind.PlusToken:
            case ts.SyntaxKind.AsteriskToken:
            case ts.SyntaxKind.SlashToken:
            case ts.SyntaxKind.AsteriskAsteriskToken:
            case ts.SyntaxKind.CaretToken:
            case ts.SyntaxKind.PercentToken:
                tok = ts.tokenToString(op.getKind())!;
                break;
            case ts.SyntaxKind.EqualsEqualsEqualsToken:
                tok = "==";
                break;
            case ts.SyntaxKind.ExclamationEqualsEqualsToken:
                tok = "!=";
                break;
            case ts.SyntaxKind.AmpersandEqualsToken:
                if (Node.isPrefixUnaryExpression(right) && right.getOperatorToken() === ts.SyntaxKind.TildeToken) {
                    tok = "&^=";
                    right = right.getOperand();
                }
                // falls through
            default:
                if (isStatement && isAssignmentOperator(op.getKind())) {
                    tok ??= ts.tokenToString(op.getKind())!;

                    if (Node.isConditionalExpression(right)) {
                        writeConditionalExpression(right, () => {
                            visitExpression(left);
                            if (tok === "||=") {
                                writer.write(" = ");
                                visitExpression(left);
                                writer.write(" || ");
                            }
                            else if (tok === "&&=") {
                                writer.write(" = ");
                                visitExpression(left);
                                writer.write(" && ");
                            }
                            else {
                                writer.write(` ${tok} `);
                            }
                        });
                        return;
                    }

                    break;
                }

                writeTodoNode(node);
                writer.write(` TODO`);
                return;
        }

        assert(tok);

        visitExpression(left);
        if (tok === "||=") {
            writer.write(" = ");
            visitExpression(left);
            writer.write(" || ");
        }
        else if (tok === "&&=") {
            writer.write(" = ");
            visitExpression(left);
            writer.write(" && ");
        }
        else {
            writer.write(` ${tok} `);
        }
        visitExpression(right);
    }

    function sanitizeName(name: string | undefined) {
        switch (name) {
            case "break":
            case "case":
            case "chan":
            case "const":
            case "continue":
            case "default":
            case "defer":
            case "else":
            case "fallthrough":
            case "for":
            case "func":
            case "go":
            case "goto":
            case "if":
            case "import":
            case "interface":
            case "map":
            case "package":
            case "range":
            case "return":
            case "select":
            case "struct":
            case "switch":
            case "type":
            case "var":
                name = `${name}_`;
                break;
            default:
                name = name || "TODO";
                break;
        }

        name = name.replaceAll("$", "_DOLLAR_");

        return name;
    }

    function getNameOfNamed(node: { getName(): string | undefined; }) {
        const name = sanitizeName(node.getName());
        if (/^[a-zA-Z0-9_]+$/.test(name)) {
            return name;
        }
        return `TODO_IDENTIFIER`;
    }

    function visitIfStatement(node: IfStatement) {
        writer.write("if ");
        visitExpression(node.getExpression());

        writer.write(" {");
        writer.indent(() => {
            const thenStatement = node.getThenStatement();
            if (thenStatement) {
                if (Node.isBlock(thenStatement)) {
                    visitBlock(thenStatement);
                }
                else if (Node.isStatement(thenStatement)) {
                    visitStatement(thenStatement);
                }
                else {
                    writeTodoNode(node);
                }
            }
            writer.newLineIfLastNot();
        });

        const elseStatement = node.getElseStatement();
        if (elseStatement) {
            writer.write("} else ");
            if (Node.isIfStatement(elseStatement)) {
                return visitIfStatement(elseStatement);
            }
            writer.write("{");
            writer.indent(() => {
                if (Node.isBlock(elseStatement)) {
                    visitBlock(elseStatement);
                }
                else if (Node.isStatement(elseStatement)) {
                    visitStatement(elseStatement);
                }
                else {
                    writeTodoNode(node);
                }
            });
            writer.write("}");
        }
        else {
            writer.write("}");
        }
    }
    function visitExpressionStatement(node: ExpressionStatement) {
        const expression = node.getExpression();
        visitExpression(expression, true);
        writer.newLine();
    }

    function writeTypeParameters(node: TypeParameteredNode) {
        const typeParameters = node.getTypeParameters();
        if (typeParameters.length > 0) {
            writer.write("[");

            for (let i = 0; i < typeParameters.length; i++) {
                const typeParameter = typeParameters[i];
                writer.write(getNameOfNamed(typeParameter));
                const constraint = typeParameter.getConstraint();
                if (constraint) {
                    writer.write(" ");
                    visitTypeNode(constraint);
                }
                else {
                    writer.write(" any");
                }
                writer.conditionalWrite(i < typeParameters.length - 1, ", ");
            }

            writer.write("]");
        }
    }

    function writeFunctionParametersAndReturn(
        node: FunctionDeclaration | ArrowFunction | MethodDeclaration | FunctionExpression,
    ) {
        writer.write("(");
        const params = node.getParameters();
        for (let i = 0; i < params.length; i++) {
            const param = params[i];
            writer.write(getNameOfNamed(param));
            writer.write(" ");
            const paramType = param.getTypeNode();
            if (paramType) {
                visitTypeNode(paramType);
            }
            else {
                writeType(node, param.getType());
            }
            const initializer = param.getInitializer();
            if (initializer) {
                writer.write(` ${asComment(" = " + initializer.getText())}`);
            }
            writer.conditionalWrite(i < params.length - 1, ", ");
        }
        writer.write(")");
        const ret = node.getReturnType();
        if (!ret.isVoid()) {
            writer.write(" ");
            const retNode = node.getReturnTypeNode();
            if (retNode) {
                if (Node.isTypePredicate(retNode)) {
                    writer.write("bool");
                }
                else {
                    visitTypeNode(retNode);
                }
            }
            else {
                writeType(node, ret, true);
            }
        }
    }

    function writeBody(node: BodyableNode) {
        writer.write(" {");
        writer.indent(() => {
            const body = node.getBodyOrThrow();
            assert(Node.isBlock(body));
            visitBlock(body);
        });
        writer.write("}");
    }

    function visitBlock(node: Block) {
        node.getStatementsWithComments().forEach(visitStatement);
    }

    function writeLeadingComments(node: Node) {
        for (const range of node.getLeadingCommentRanges()) {
            if (range.compilerObject.hasTrailingNewLine) {
                writer.writeLine(range.getText());
            }
            else {
                writer.write(range.getText());
            }
        }
    }

    function writeTrailingComments(node: Node) {
        for (const range of node.getTrailingCommentRanges()) {
            if (range.compilerObject.hasTrailingNewLine) {
                writer.writeLine(range.getText());
            }
            else {
                writer.write(range.getText());
            }
        }
    }

    let mainStructScanState: "before" | "after" | (FunctionDeclaration | CommentStatement)[] = "before";

    function visitStatement(node: Statement) {
        let isStructMethod = false;
        if (isVariableForMainStruct(node)) {
            if (Node.isFunctionDeclaration(node) || Node.isCommentStatement(node)) {
                if (mainStructScanState === "before") {
                    // Do nothing
                }
                else if (mainStructScanState === "after") {
                    isStructMethod = true;
                }
                else {
                    mainStructScanState.push(node);
                    return;
                }
            }
            else if (Node.isReturnStatement(node)) {
                mainStructScanState = [];
            }
        }

        writer.newLineIfLastNot();
        if (!node.getPreviousSibling()?.getKindName()?.endsWith("Trivia")) {
            writeLeadingComments(node);
        }

        visitStatement2(node, isStructMethod);

        if (!node.getNextSibling()?.getKindName()?.endsWith("Trivia")) {
            writeTrailingComments(node);
        }
    }

    function visitStatement2(node: Statement, isStructMethod: boolean) {
        writer.newLineIfLastNot();

        // If more than one newline, add another newline.
        const prev = node.getPreviousSibling()?.getEnd();
        if (prev !== undefined) {
            // This is much faster than asking ts-morph for the line numbers.
            const text = sourceFile.getText();
            const first = text.indexOf("\n", prev);
            if (first !== -1) {
                const second = text.indexOf("\n", first + 1);
                if (second !== -1 && second < node.getStart()) {
                    writer.newLine();
                }
            }
        }

        const isGlobal = node.getParentIf(p => Node.isSourceFile(p) || Node.isModuleBlock(p)) !== undefined;

        if (Node.isImportDeclaration(node)) {
            return;
        }

        if (Node.isTypeAliasDeclaration(node)) {
            writer.write(`type ${getNameOfNamed(node)}`);
            writeTypeParameters(node);
            writer.write(" ");
            visitTypeNode(node.getTypeNodeOrThrow());

            writer.newLineIfLastNot();
            return;
        }

        if (Node.isFunctionDeclaration(node)) {
            if (!node.hasBody()) {
                writer.write(asComment(`OVERLOAD: ${node.getText()}`));
                return;
            }

            const isGlobal = node.getParentIf(p => Node.isSourceFile(p) || Node.isModuleBlock(p)) !== undefined;

            if (isStructMethod) {
                writer.write(`func (${methodReceiver} *${mainStruct}) ${getNameOfNamed(node)}`);
            }
            else if (!isGlobal) {
                writer.write(`${getNameOfNamed(node)} := func`);
                if (node.isGenerator()) {
                    writer.write("/* generator */");
                }
            }
            else {
                writer.write(`func `);
                if (node.isGenerator()) {
                    writer.write("/* generator */");
                }
                writer.write(`${getNameOfNamed(node)}`);
            }

            writeFunctionParametersAndReturn(node);
            writeBody(node);

            writer.newLine();
            writer.newLine();

            if (createFunction && node.getName() === createFunction) {
                const funcs = mainStructScanState;
                assert(Array.isArray(funcs));
                mainStructScanState = "after";
                funcs.forEach(visitStatement);
            }

            return;
        }

        if (Node.isInterfaceDeclaration(node)) {
            writer.write(`type ${getNameOfNamed(node)}`);
            writeTypeParameters(node);
            writer.write(" struct {");
            writer.indent(() => {
                const members = node.getMembers();
                for (const member of members) {
                    if (Node.isPropertySignature(member)) {
                        writer.write(`${getNameOfNamed(member)} `);
                        visitTypeNode(member.getTypeNodeOrThrow());
                        writer.newLine();
                    }
                    else {
                        writeTodoNode(node);
                    }
                }
            });
            writer.write("}");

            writer.newLineIfLastNot();
            return;
        }

        if (Node.isVariableStatement(node)) {
            const isGlobal = node.getParentIf(p => Node.isSourceFile(p) || Node.isModuleBlock(p)) !== undefined;

            const declarations = node.getDeclarations();

            for (const declaration of declarations) {
                const typeNode = declaration.getTypeNode();
                const initializer = declaration.getInitializer();

                if (isVariableForMainStruct(declaration)) {
                    if (initializer) {
                        writer.write(`tc.${getNameOfNamed(declaration)} = `);
                        visitExpression(initializer);
                    }
                    continue;
                }

                if (!isGlobal && Node.isConditionalExpression(initializer)) {
                    writer.write(`var ${getNameOfNamed(declaration)} `);
                    if (typeNode) {
                        visitTypeNode(typeNode);
                    }
                    else {
                        writeType(declaration, declaration.getType());
                    }
                    writeConditionalExpression(
                        initializer,
                        () => writer.write(`${getNameOfNamed(declaration)} = `),
                    );
                }
                else if (isGlobal) {
                    writer.write(`var ${getNameOfNamed(declaration)}`);
                    if (typeNode) {
                        writer.write(" ");
                        visitTypeNode(typeNode);
                    }
                    if (initializer) {
                        writer.write(" = ");
                        visitExpression(initializer);
                    }
                }
                else {
                    if (typeNode) {
                        writer.write(`var ${getNameOfNamed(declaration)} `);
                        visitTypeNode(typeNode);
                        if (initializer) {
                            writer.write(" = ");
                            visitExpression(initializer);
                        }
                    }
                    else if (initializer) {
                        writer.write(`${getNameOfNamed(declaration)} := `);
                        visitExpression(initializer);
                    }
                    else {
                        // No annotation or inferred type, comes from something later...
                        writer.write(`var ${getNameOfNamed(declaration)} TODO`);
                    }
                }
                writer.newLineIfLastNot();
            }

            writer.newLineIfLastNot();
            return;
        }

        if (Node.isEnumDeclaration(node)) {
            const enumName = getNameOfNamed(node);

            writer.write(`type ${enumName}`);
            if (node.getMembers()[0].getInitializer()?.getKindName() === "StringLiteral") {
                writer.write(` string`);
            }
            else {
                writer.write(` int32`);
            }

            writer.writeLine(`const (`);
            writer.indent(() => {
                const members = node.getMembers();
                const nameMapping = new Map<string, string>();
                for (const member of members) {
                    const memberName = getNameOfNamed(member);
                    nameMapping.set(memberName, `${enumName}${memberName}`);
                }
                const replacements = [...nameMapping.entries()].sort((a, b) => b[0].length - a[0].length);

                for (let i = 0; i < members.length; i++) {
                    const member = members[i];
                    writeLeadingComments(member);
                    const memberName = nameMapping.get(getNameOfNamed(member))!;
                    writer.write(`${memberName} `);
                    const initializer = member.getInitializer();
                    if (i === 0 && !initializer) {
                        writer.write(`${enumName} = iota`);
                    }
                    else if (initializer) {
                        let initializerText = initializer.getText();

                        for (const [name, value] of replacements) {
                            initializerText = initializerText.replaceAll(name, value);
                        }

                        initializerText = initializerText.replaceAll("~", "^");

                        writer.write(`${enumName} = ${initializerText}`);
                    }
                    writer.newLineIfLastNot();
                    writeTrailingComments(member);
                    writer.newLineIfLastNot();
                }
            });
            writer.writeLine(")");

            writer.newLineIfLastNot();
            return;
        }

        if (Node.isModuleDeclaration(node)) {
            // TODO: add namespace name as prefix to each variable declared inside
            // TODO: error on namespace merging; check which things namespace can merge with?

            if (node.getName() === "JsxNames") {
                // Special case for JsxNames only
                const exports = new Map<string, string>();

                for (const statement of node.getStatements()) {
                    assert(Node.isVariableStatement(statement), statement.getKindName());
                    assert(statement.isExported());

                    const declaration = statement.getDeclarationList().getDeclarations()[0];

                    const name = getNameOfNamed(declaration);
                    const initializer = declaration.getInitializerOrThrow();
                    assert(Node.isAsExpression(initializer), initializer.getKindName());
                    const left = initializer.getExpression();
                    assert(Node.isStringLiteral(left), left.getKindName());
                    exports.set(name, left.getLiteralText());
                }

                writer.write("var JsxNames = struct {");
                writer.indent(() => {
                    for (const [name, value] of exports) {
                        writer.write(`${name} __String`);
                        writer.newLine();
                    }
                });
                writer.write("} {");
                writer.indent(() => {
                    for (const [name, value] of exports) {
                        writer.write(`${name}: __String(${JSON.stringify(value)}),`);
                        writer.newLine();
                    }
                });
                writer.write("}");

                return;
            }

            writer.writeLine(`// #region ${node.getName()}`);
            writer.newLine();
            writer.newLine();

            const statements = node.getStatementsWithComments();

            for (const statement of statements) {
                visitStatement(statement);
            }

            writer.writeLine(`// #endregion ${node.getName()}`);
            writer.newLine();
            writer.newLine();

            return;
        }

        if (!isGlobal && Node.isExpressionStatement(node)) {
            // Handling expressions separately so we _don't_ handle side effect expressions in writeExpression
            visitExpressionStatement(node);
            return;
        }

        if (!isGlobal && Node.isReturnStatement(node)) {
            writer.newLineIfLastNot();

            const expression = node.getExpression();
            if (Node.isBinaryExpression(expression) && expression.getOperatorToken().isKind(ts.SyntaxKind.CommaToken)) {
                const left = expression.getLeft();
                const right = expression.getRight();
                visitExpression(left, true);
                writer.newLineIfLastNot();
                writer.write("return ");
                visitExpression(right);
                writer.newLine();
                return;
            }

            if (Node.isConditionalExpression(expression)) {
                writeConditionalExpression(expression, () => writer.write("return "));
                return;
            }

            if (Node.isBinaryExpression(expression) && isAssignmentOperator(expression.getOperatorToken().getKind())) {
                writeBinaryExpression(expression, true);
                writer.newLine();
                writer.write("return ");
                visitExpression(expression.getLeft());
                writer.newLine();
                return;
            }

            writer.write("return");
            if (expression) {
                writer.write(" ");
                visitExpression(expression);
            }
            writer.newLine();
            return;
        }

        if (!isGlobal && Node.isContinueStatement(node)) {
            const label = node.getLabel();
            writer.write("continue");
            if (label) {
                writer.write(` ${sanitizeName(label.getText())}`);
            }
            writer.newLine();
            return;
        }

        if (!isGlobal && Node.isBreakStatement(node)) {
            const label = node.getLabel();
            writer.write("break");
            if (label) {
                writer.write(` ${sanitizeName(label.getText())}`);
            }
            writer.newLine();
            return;
        }

        if (!isGlobal && Node.isIfStatement(node)) {
            visitIfStatement(node);
            return;
        }

        if (!isGlobal && Node.isForOfStatement(node)) {
            writer.write("for _, ");
            const initializer = node.getInitializer();
            if (Node.isVariableDeclarationList(initializer)) {
                writer.write(getNameOfNamed(initializer.getDeclarations()[0]));
            }
            else {
                writeTodoNode(initializer);
            }
            writer.write(" := range ");
            visitExpression(node.getExpression());
            writer.write(" {");
            writer.indent(() => {
                visitStatement(node.getStatement());
            });
            writer.write("}");
            writer.newLineIfLastNot();
            return;
        }

        if (!isGlobal && Node.isForStatement(node)) {
            writer.write("for ");
            const initializer = node.getInitializer();
            if (initializer) {
                if (Node.isVariableDeclarationList(initializer)) {
                    const declarations = initializer.getDeclarations();
                    if (declarations.length > 1) {
                        writeTodoNode(initializer);
                    }
                    else {
                        const declaration = declarations[0];
                        writer.write(`${getNameOfNamed(declaration)} := `);
                        visitExpression(declaration.getInitializerOrThrow());
                    }
                }
                else {
                    visitExpression(initializer, true);
                }
            }
            writer.write("; ");
            const condition = node.getCondition();
            if (condition) {
                visitExpression(condition);
            }
            writer.write("; ");
            const incrementor = node.getIncrementor();
            if (incrementor) {
                visitExpression(incrementor, true);
            }
            writer.write(" {");
            writer.indent(() => {
                visitStatement(node.getStatement());
            });
            writer.write("}");
            writer.newLineIfLastNot();
            return;
        }

        if (!isGlobal && Node.isWhileStatement(node)) {
            writer.write("for ");
            visitExpression(node.getExpression());
            writer.write(" {");
            writer.indent(() => {
                visitStatement(node.getStatement());
            });
            writer.write("}");
            writer.newLineIfLastNot();
            return;
        }

        if (!isGlobal && Node.isDoStatement(node)) {
            writer.write("for ok := true; ok; ok = ");
            visitExpression(node.getExpression());
            writer.write(" { // do-while loop");
            writer.indent(() => {
                visitStatement(node.getStatement());
            });
            writer.write("}");
            writer.newLineIfLastNot();
            return;
        }

        if (!isGlobal && Node.isBlock(node)) {
            visitBlock(node);
            return;
        }

        if (!isGlobal && Node.isSwitchStatement(node)) {
            writer.write("switch ");
            visitExpression(node.getExpression());
            writer.write(" {");
            const clauses = node.getClauses();

            function groupClauses() {
                // Group clauses into:
                // - Zero or more clauses with no statements followed by one non-empty case clause
                // - Default clauses
                // Groups should consist of (start, end] indices

                let groups: [number, number][] = [];

                let start = 0;

                while (start < clauses.length) {
                    const first = clauses[start];
                    if (Node.isDefaultClause(first)) {
                        groups.push([start, start + 1]);
                        start++;
                        continue;
                    }

                    const found = clauses.findIndex(
                        (clause, i) =>
                            i >= start && (Node.isDefaultClause(clause) || clause.getStatements().length > 0),
                    );
                    if (found === -1) {
                        groups.push([start, start + 1]);
                        start++;
                        continue;
                    }

                    if (Node.isDefaultClause(clauses[found])) {
                        groups.push([start, found]);
                        start = found;
                    }
                    else {
                        groups.push([start, found + 1]);
                        start = found + 1;
                    }
                }

                return groups;
            }

            for (const [start, end] of groupClauses()) {
                function writeColonAndCaseBody(clause: CaseOrDefaultClause, idx: number) {
                    const isLastClause = idx === clauses.length - 1;
                    let statementsOfClause = clause.getStatementsWithComments();
                    const firstStatement = statementsOfClause.length === 1 ? statementsOfClause[0] : undefined;
                    if (firstStatement?.isKind(ts.SyntaxKind.Block)) {
                        statementsOfClause = firstStatement.getStatementsWithComments();
                    }

                    writer.write(":");
                    writer.indent(() => {
                        const end = statementsOfClause.findLastIndex(s => !s.getKindName().endsWith("Trivia"));

                        const first = statementsOfClause.slice(0, end);
                        const last = statementsOfClause.slice(end);

                        for (const statement of first) {
                            visitStatement(statement);
                        }

                        const lastStatement = last.at(0);
                        if (lastStatement) {
                            if (Node.isReturnStatement(lastStatement) || Node.isContinueStatement(lastStatement)) {
                                last.forEach(visitStatement);
                            }
                            else if (Node.isBreakStatement(lastStatement)) {
                                // Skip
                                last.slice(1).forEach(visitStatement);
                            }
                            else {
                                last.filter(node => {
                                    if (node.getKindName().endsWith("Trivia")) {
                                        if (/\/\/\s+falls? ?through/.test(node.getText())) {
                                            return false;
                                        }
                                    }
                                    return true;
                                }).forEach(visitStatement);
                                if (!isLastClause) {
                                    writer.newLineIfLastNot();
                                    writer.writeLine("fallthrough");
                                }
                            }
                        }
                    });
                }

                const startingClause = clauses[start];
                if (Node.isCaseClause(startingClause)) {
                    writer.newLineIfLastNot();
                    writer.write("case ");
                    for (let i = start; i < end; i++) {
                        const isLastInGroup = i === end - 1;

                        const clause = clauses[i];
                        assert(Node.isCaseClause(clause));
                        const expression = clause.getExpression();
                        visitExpression(expression);
                        if (isLastInGroup) {
                            writeColonAndCaseBody(clause, i);
                        }
                        else {
                            writer.write(",");
                            writer.newLine();
                        }
                    }
                }
                else {
                    writer.newLineIfLastNot();
                    writer.write("default");
                    writeColonAndCaseBody(startingClause, start);
                }
            }

            writer.write("}");
            writer.newLineIfLastNot();
            return;
        }

        if (Node.isCommentStatement(node)) {
            writer.write(node.getText());
            return;
        }

        if (!isGlobal && Node.isLabeledStatement(node)) {
            const label = node.getLabel().getText();
            writer.write(`${sanitizeName(label)}: `);
            visitStatement(node.getStatement());
            return;
        }

        if (!isGlobal && Node.isTryStatement(node)) {
            writer.write("{ // try");
            writer.indent(() => {
                visitStatement(node.getTryBlock());
            });
            writer.writeLine("}");
            const catchClause = node.getCatchClause();
            if (catchClause) {
                writer.write(`{ // catch ${catchClause.getVariableDeclaration()?.getText() ?? ""}`);
                writer.indent(() => {
                    visitStatement(catchClause.getBlock());
                });
                writer.writeLine("}");
                writer.newLineIfLastNot();
            }
            const finallyBlock = node.getFinallyBlock();
            if (finallyBlock) {
                writer.write("{ // finally");
                writer.indent(() => {
                    visitStatement(finallyBlock);
                });
                writer.writeLine("}");
                writer.newLineIfLastNot();
            }
            return;
        }

        writeTodoNode(node);
        // console.error(`Unhandled node kind: ${node.getKindName()}`);
    }

    const structFields = new Set<string>();

    if (mainStruct) {
        let seenReturn = false;

        writer.write(`type ${mainStruct} struct {`);

        writer.indent(() => {
            sourceFile.getFunctionOrThrow(`create${mainStruct}`).getStatements().forEach(statement => {
                if (!seenReturn && Node.isVariableStatement(statement)) {
                    for (const declaration of statement.getDeclarations()) {
                        structFields.add(getNameOfNamed(declaration));
                        writer.write(`${getNameOfNamed(declaration)} `);
                        const typeNode = declaration.getTypeNode();
                        if (typeNode) {
                            visitTypeNode(typeNode);
                        }
                        else {
                            writeType(declaration, declaration.getType());
                        }
                        writer.newLine();
                    }
                }
                else if (seenReturn && Node.isFunctionDeclaration(statement)) {
                    structFields.add(getNameOfNamed(statement));
                }
                else if (Node.isReturnStatement(statement)) {
                    seenReturn = true;
                }
            });
        });

        writer.write("}");
    }

    sourceFile.getStatementsWithComments().forEach(visitStatement);

    const outFile = Bun.file(output);

    await Bun.write(outFile, writer.toString());

    try {
        cp.execFileSync(which.sync("gofmt"), ["-w", "-s", output]);
        console.log("    All good!");
    }
    catch (e) {
        console.error(e);
    }

    const totalTodo = [...todoCounts.values()].reduce((a, b) => a + b, 0);
    console.log(`    Total TODOs: ${totalTodo}`);
    console.log([...todoCounts.entries()].sort((a, b) => b[1] - a[1]).map(([k, v]) => `    ${k} ${v}`).join("\n"));
}

await convert("checker.ts", "output/checker.go", "TypeChecker");
await convert("binder.ts", "output/binder.go", "Binder");
await convert("scanner.ts", "output/scanner.go", "Scanner");
await convert("parser.ts", "output/parser.go");
await convert("utilities.ts", "output/utilities.go");
await convert("utilitiesPublic.ts", "output/utilitiesPublic.go");
await convert("program.ts", "output/program.go");
await convert("emitter.ts", "output/emitter.go", "Printer");

console.log("Done!");
