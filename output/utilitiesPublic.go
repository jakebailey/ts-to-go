// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

func isExternalModuleNameRelative(moduleName string) bool {
	// TypeScript 1.0 spec (April 2014): 11.2.1
	// An external module name is "relative" if the first term is "." or "..".
	// Update: We also consider a path like `C:\foo.ts` "relative" because we do not search for it in `node_modules` or treat it as an ambient module.
	return pathIsRelative(moduleName) || isRootedDiskPath(moduleName)
}

func sortAndDeduplicateDiagnostics(diagnostics []T) SortedReadonlyArray[T] {
	return sortAndDeduplicate(diagnostics, compareDiagnostics, diagnosticsEqualityComparer)
}

/** @internal */

var targetToLibMap Map[ScriptTarget, string] = NewMap([] /* TODO(TS-TO-GO) inferred type [ScriptTarget.ESNext, string] | [ScriptTarget.ES2023, string] | [ScriptTarget.ES2022, string] | [ScriptTarget.ES2021, string] | [ScriptTarget.ES2020, string] | [ScriptTarget.ES2019, string] | [ScriptTarget.ES2018, string] | [ScriptTarget.ES2017, string] | [ScriptTarget.ES2016, string] | [ScriptTarget.ES2015, string] */ any{[]any{ScriptTargetESNext, "lib.esnext.full.d.ts"}, []any{ScriptTargetES2023, "lib.es2023.full.d.ts"}, []any{ScriptTargetES2022, "lib.es2022.full.d.ts"}, []any{ScriptTargetES2021, "lib.es2021.full.d.ts"}, []any{ScriptTargetES2020, "lib.es2020.full.d.ts"}, []any{ScriptTargetES2019, "lib.es2019.full.d.ts"}, []any{ScriptTargetES2018, "lib.es2018.full.d.ts"}, []any{ScriptTargetES2017, "lib.es2017.full.d.ts"}, []any{ScriptTargetES2016, "lib.es2016.full.d.ts"}, []any{ScriptTargetES2015, "lib.es6.d.ts"}})

func getDefaultLibFileName(options CompilerOptions) string {
	target := getEmitScriptTarget(options)
	switch target {
	case ScriptTargetESNext,
		ScriptTargetES2023,
		ScriptTargetES2022,
		ScriptTargetES2021,
		ScriptTargetES2020,
		ScriptTargetES2019,
		ScriptTargetES2018,
		ScriptTargetES2017,
		ScriptTargetES2016,
		ScriptTargetES2015:
		return targetToLibMap.get(target)
	default:
		return "lib.d.ts"
	}
}

func textSpanEnd(span TextSpan) number {
	return span.start + span.length
}

func textSpanIsEmpty(span TextSpan) bool {
	return span.length == 0
}

func textSpanContainsPosition(span TextSpan, position number) bool {
	return position >= span.start && position < textSpanEnd(span)
}

/** @internal */

func textRangeContainsPositionInclusive(range_ TextRange, position number) bool {
	return position >= range_.pos && position <= range_.end
}

// Returns true if 'span' contains 'other'.
func textSpanContainsTextSpan(span TextSpan, other TextSpan) bool {
	return other.start >= span.start && textSpanEnd(other) <= textSpanEnd(span)
}

/** @internal */

func textSpanContainsTextRange(span TextSpan, range_ TextRange) bool {
	return range_.pos >= span.start && range_.end <= textSpanEnd(span)
}

/** @internal */

func textRangeContainsTextSpan(range_ TextRange, span TextSpan) bool {
	return span.start >= range_.pos && textSpanEnd(span) <= range_.end
}

func textSpanOverlapsWith(span TextSpan, other TextSpan) bool {
	return textSpanOverlap(span, other) != nil
}

func textSpanOverlap(span1 TextSpan, span2 TextSpan) *TextSpan {
	overlap := textSpanIntersection(span1, span2)
	if overlap != nil && overlap.length == 0 {
		return nil
	} else {
		return overlap
	}
}

func textSpanIntersectsWithTextSpan(span TextSpan, other TextSpan) bool {
	return decodedTextSpanIntersectsWith(span.start, span.length, other.start, other.length)
}

func textSpanIntersectsWith(span TextSpan, start number, length number) bool {
	return decodedTextSpanIntersectsWith(span.start, span.length, start, length)
}

func decodedTextSpanIntersectsWith(start1 number, length1 number, start2 number, length2 number) bool {
	end1 := start1 + length1
	end2 := start2 + length2
	return start2 <= end1 && end2 >= start1
}

func textSpanIntersectsWithPosition(span TextSpan, position number) bool {
	return position <= textSpanEnd(span) && position >= span.start
}

/** @internal */

func textRangeIntersectsWithTextSpan(range_ TextRange, span TextSpan) bool {
	return textSpanIntersectsWith(span, range_.pos, range_.end-range_.pos)
}

func textSpanIntersection(span1 TextSpan, span2 TextSpan) *TextSpan {
	start := max(span1.start, span2.start)
	end := min(textSpanEnd(span1), textSpanEnd(span2))
	if start <= end {
		return createTextSpanFromBounds(start, end)
	} else {
		return nil
	}
}

/**
 * Given an array of text spans, returns an equivalent sorted array of text spans
 * where no span overlaps or is adjacent to another span in the array.
 * @internal
 */

func normalizeSpans(spans []TextSpan) []TextSpan {
	spans = spans.filter(func(span TextSpan) bool {
		return span.length > 0
	}).sort(func(a TextSpan, b TextSpan) number {
		if a.start != b.start {
			return a.start - b.start
		} else {
			return a.length - b.length
		}
	})

	var result []TextSpan = []never{}
	i := 0
	for i < spans.length {
		span := spans[i]
		j := i + 1
		for j < spans.length && textSpanIntersectsWithTextSpan(span, spans[j]) {
			start := min(span.start, spans[j].start)
			end := max(textSpanEnd(span), textSpanEnd(spans[j]))
			span = createTextSpanFromBounds(start, end)
			j++
		}
		i = j
		result.push(span)
	}

	return result
}

func createTextSpan(start number, length number) TextSpan {
	if start < 0 {
		/* TODO(TS-TO-GO) Node ThrowStatement: throw new Error("start < 0"); */
	}
	if length < 0 {
		/* TODO(TS-TO-GO) Node ThrowStatement: throw new Error("length < 0"); */
	}

	return TextSpan{
		start:  start,
		length: length,
	}
}

func createTextSpanFromBounds(start number, end number) TextSpan {
	return createTextSpan(start, end-start)
}

func textChangeRangeNewSpan(range_ TextChangeRange) TextSpan {
	return createTextSpan(range_.span.start, range_.newLength)
}

func textChangeRangeIsUnchanged(range_ TextChangeRange) bool {
	return textSpanIsEmpty(range_.span) && range_.newLength == 0
}

func createTextChangeRange(span TextSpan, newLength number) TextChangeRange {
	if newLength < 0 {
		/* TODO(TS-TO-GO) Node ThrowStatement: throw new Error("newLength < 0"); */
	}

	return TextChangeRange{
		span:      span,
		newLength: newLength,
	}
}

var unchangedTextChangeRange TextChangeRange = createTextChangeRange(createTextSpan(0, 0), 0)

/**
 * Called to merge all the changes that occurred across several versions of a script snapshot
 * into a single change.  i.e. if a user keeps making successive edits to a script we will
 * have a text change from V1 to V2, V2 to V3, ..., Vn.
 *
 * This function will then merge those changes into a single change range valid between V1 and
 * Vn.
 */

func collapseTextChangeRangesAcrossMultipleVersions(changes []TextChangeRange) TextChangeRange {
	if changes.length == 0 {
		return unchangedTextChangeRange
	}

	if changes.length == 1 {
		return changes[0]
	}

	// We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
	// as it makes things much easier to reason about.
	change0 := changes[0]

	oldStartN := change0.span.start
	oldEndN := textSpanEnd(change0.span)
	newEndN := oldStartN + change0.newLength

	for i := 1; i < changes.length; i++ {
		nextChange := changes[i]

		// Consider the following case:
		// i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
		// at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
		// i.e. the span starting at 30 with length 30 is increased to length 40.
		//
		//      0         10        20        30        40        50        60        70        80        90        100
		//      -------------------------------------------------------------------------------------------------------
		//                |                                                 /
		//                |                                            /----
		//  T1            |                                       /----
		//                |                                  /----
		//                |                             /----
		//      -------------------------------------------------------------------------------------------------------
		//                                     |                            \
		//                                     |                               \
		//   T2                                |                                 \
		//                                     |                                   \
		//                                     |                                      \
		//      -------------------------------------------------------------------------------------------------------
		//
		// Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
		// it's just the min of the old and new starts.  i.e.:
		//
		//      0         10        20        30        40        50        60        70        80        90        100
		//      ------------------------------------------------------------*------------------------------------------
		//                |                                                 /
		//                |                                            /----
		//  T1            |                                       /----
		//                |                                  /----
		//                |                             /----
		//      ----------------------------------------$-------------------$------------------------------------------
		//                .                    |                            \
		//                .                    |                               \
		//   T2           .                    |                                 \
		//                .                    |                                   \
		//                .                    |                                      \
		//      ----------------------------------------------------------------------*--------------------------------
		//
		// (Note the dots represent the newly inferred start.
		// Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
		// absolute positions at the asterisks, and the relative change between the dollar signs. Basically, we see
		// which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that
		// means:
		//
		//      0         10        20        30        40        50        60        70        80        90        100
		//      --------------------------------------------------------------------------------*----------------------
		//                |                                                                     /
		//                |                                                                /----
		//  T1            |                                                           /----
		//                |                                                      /----
		//                |                                                 /----
		//      ------------------------------------------------------------$------------------------------------------
		//                .                    |                            \
		//                .                    |                               \
		//   T2           .                    |                                 \
		//                .                    |                                   \
		//                .                    |                                      \
		//      ----------------------------------------------------------------------*--------------------------------
		//
		// In other words (in this case), we're recognizing that the second edit happened after where the first edit
		// ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started
		// that's the same as if we started at char 80 instead of 60.
		//
		// As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rather
		// than pushing the first edit forward to match the second, we'll push the second edit forward to match the
		// first.
		//
		// In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange
		// semantics: { { start: 10, length: 70 }, newLength: 60 }
		//
		// The math then works out as follows.
		// If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the
		// final result like so:
		//
		// {
		//      oldStart3: Min(oldStart1, oldStart2),
		//      oldEnd3: Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),
		//      newEnd3: Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))
		// }

		oldStart1 := oldStartN
		oldEnd1 := oldEndN
		newEnd1 := newEndN

		oldStart2 := nextChange.span.start
		oldEnd2 := textSpanEnd(nextChange.span)
		newEnd2 := oldStart2 + nextChange.newLength

		oldStartN = min(oldStart1, oldStart2)
		oldEndN = max(oldEnd1, oldEnd1+(oldEnd2-newEnd1))
		newEndN = max(newEnd2, newEnd2+(newEnd1-oldEnd2))
	}

	return createTextChangeRange(createTextSpanFromBounds(oldStartN, oldEndN), newEndN-oldStartN /*newLength*/)
}

func getTypeParameterOwner(d Declaration) Declaration {
	if d && d.kind == ast.KindTypeParameter {
		for current := d; current; current = current.parent {
			if isFunctionLike(current) || isClassLike(current) || current.kind == ast.KindInterfaceDeclaration {
				return current.AsDeclaration()
			}
		}
	}
}

type ParameterPropertyDeclaration Intersection[ParameterDeclaration /* TODO(TS-TO-GO) TypeNode TypeLiteral: { parent: ConstructorDeclaration; name: Identifier; } */, any]

func isParameterPropertyDeclaration(node *ast.Node, parent *ast.Node) bool {
	return isParameter(node) && hasSyntacticModifier(node, ast.ModifierFlagsParameterPropertyModifier) && parent.kind == ast.KindConstructor
}

func isEmptyBindingPattern(node BindingName) bool {
	if isBindingPattern(node) {
		return every(node.elements, isEmptyBindingElement)
	}
	return false
}

// TODO(jakebailey): It is very weird that we have BindingElement and ArrayBindingElement;
// we should have ObjectBindingElement and ArrayBindingElement, which are both BindingElement,
// just like BindingPattern is a ObjectBindingPattern or a ArrayBindingPattern.
func isEmptyBindingElement(node Union[BindingElement, ArrayBindingElement]) bool {
	if isOmittedExpression(node) {
		return true
	}
	return isEmptyBindingPattern(node.name)
}

func walkUpBindingElementsAndPatterns(binding BindingElement) Union[VariableDeclaration, ParameterDeclaration] {
	node := binding.parent
	for isBindingElement(node.parent) {
		node = node.parent.parent
	}
	return node.parent
}

func getCombinedFlags(node *ast.Node, getFlags func(n *ast.Node) number) number {
	if isBindingElement(node) {
		node = walkUpBindingElementsAndPatterns(node)
	}
	flags := getFlags(node)
	if node.kind == ast.KindVariableDeclaration {
		node = node.parent
	}
	if node && node.kind == ast.KindVariableDeclarationList {
		flags |= getFlags(node)
		node = node.parent
	}
	if node && node.kind == ast.KindVariableStatement {
		flags |= getFlags(node)
	}
	return flags
}

func getCombinedModifierFlags(node Declaration) ModifierFlags {
	return getCombinedFlags(node, getEffectiveModifierFlags)
}

/** @internal */

func getCombinedNodeFlagsAlwaysIncludeJSDoc(node Declaration) ModifierFlags {
	return getCombinedFlags(node, getEffectiveModifierFlagsAlwaysIncludeJSDoc)
}

// Returns the node flags for this node and all relevant parent nodes.  This is done so that
// nodes like variable declarations and binding elements can returned a view of their flags
// that includes the modifiers from their container.  i.e. flags like export/declare aren't
// stored on the variable declaration directly, but on the containing variable statement
// (if it has one).  Similarly, flags for let/const are stored on the variable declaration
// list.  By calling this function, all those flags are combined so that the client can treat
// the node as if it actually had those flags.
func getCombinedNodeFlags(node *ast.Node) NodeFlags {
	return getCombinedFlags(node, getNodeFlags)
}

func getNodeFlags(node *ast.Node) NodeFlags {
	return node.flags
}

/** @internal */

var supportedLocaleDirectories = []any{"cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"}

/**
 * Checks to see if the locale is in the appropriate format,
 * and if it is, attempts to set the appropriate language.
 */

func validateLocaleAndSetLanguage(locale string, sys /* TODO(TS-TO-GO) TypeNode TypeLiteral: { getExecutingFilePath(): string; resolvePath(path: string): string; fileExists(fileName: string): boolean; readFile(fileName: string): string | undefined; } */ any, errors []Diagnostic) {
	lowerCaseLocale := locale.toLowerCase()
	matchResult := regexp.MustParse(`^([a-z]+)(?:[_-]([a-z]+))?$`).exec(lowerCaseLocale)

	if matchResult == nil {
		if errors != nil {
			errors.push(createCompilerDiagnostic(Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, "en", "ja-jp"))
		}
		return
	}

	language := matchResult[1]
	territory := matchResult[2]

	// First try the entire locale, then fall back to just language if that's all we have.
	// Either ways do not fail, and fallback to the English diagnostic strings.
	if contains(supportedLocaleDirectories, lowerCaseLocale) && !trySetLanguageAndTerritory(language, territory, errors) {
		trySetLanguageAndTerritory(language, nil /*territory*/, errors)
	}

	// Set the UI locale for string collation
	setUILocale(locale)

	trySetLanguageAndTerritory := func(language string, territory *string, errors []Diagnostic) bool {
		compilerFilePath := normalizePath(sys.getExecutingFilePath())
		containingDirectoryPath := getDirectoryPath(compilerFilePath)

		filePath := combinePaths(containingDirectoryPath, language)

		if territory {
			filePath = filePath + "-" + territory
		}

		filePath = sys.resolvePath(combinePaths(filePath, "diagnosticMessages.generated.json"))

		if !sys.fileExists(filePath) {
			return false
		}

		// TODO: Add codePage support for readFile?
		var fileContents *string = ""
		{ // try
			fileContents = sys.readFile(filePath)
		}
		{ // catch
			if errors != nil {
				errors.push(createCompilerDiagnostic(Diagnostics.Unable_to_open_file_0, filePath))
			}
			return false
		}
		{ // try
			// this is a global mutation (or live binding update)!
			setLocalizedDiagnosticMessages(JSON.parse(fileContents))
		}
		{ // catch
			if errors != nil {
				errors.push(createCompilerDiagnostic(Diagnostics.Corrupted_locale_file_0, filePath))
			}
			return false
		}

		return true
	}

}

/* OVERLOAD: export function getOriginalNode(node: Node): Node; */
/* OVERLOAD: export function getOriginalNode<T extends Node>(node: Node, nodeTest: (node: Node) => node is T): T; */
/* OVERLOAD: export function getOriginalNode(node: Node | undefined): Node | undefined; */
/* OVERLOAD: export function getOriginalNode<T extends Node>(node: Node | undefined, nodeTest: (node: Node) => node is T): T | undefined; */
func getOriginalNode(node *ast.Node, nodeTest func(node *ast.Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is T */ any) *T {
	if node != nil {
		for node.original != nil {
			node = node.original
		}
	}

	if node == nil || nodeTest == nil {
		return node /* as T | undefined */
	}

	if nodeTest(node) {
		return node
	} else {
		return nil
	}
}

/**
 * Iterates through the parent chain of a node and performs the callback on each parent until the callback
 * returns a truthy value, then returns that value.
 * If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns "quit"
 * At that point findAncestor returns undefined.
 */

/* OVERLOAD: export function findAncestor<T extends Node>(node: Node | undefined, callback: (element: Node) => element is T): T | undefined; */
/* OVERLOAD: export function findAncestor(node: Node | undefined, callback: (element: Node) => boolean | "quit"): Node | undefined; */
func findAncestor(node *ast.Node, callback func(element *ast.Node) Union[bool /* TODO(TS-TO-GO) TypeNode LiteralType: "quit" */, any]) *ast.Node {
	for node != nil {
		result := callback(node)
		if result == "quit" {
			return nil
		} else if result {
			return node
		}
		node = node.parent
	}
	return nil
}

/**
 * Gets a value indicating whether a node originated in the parse tree.
 *
 * @param node The node to test.
 */

func isParseTreeNode(node *ast.Node) bool {
	return (node.flags & ast.NodeFlagsSynthesized) == 0
}

/**
 * Gets the original parse tree node for a node.
 *
 * @param node The original node.
 * @returns The original parse tree node if found; otherwise, undefined.
 */

/* OVERLOAD: export function getParseTreeNode(node: Node | undefined): Node | undefined; */
/**
 * Gets the original parse tree node for a node.
 *
 * @param node The original node.
 * @param nodeTest A callback used to ensure the correct type of parse tree node is returned.
 * @returns The original parse tree node if found; otherwise, undefined.
 */

/* OVERLOAD: export function getParseTreeNode<T extends Node>(node: T | undefined, nodeTest?: (node: Node) => node is T): T | undefined; */
func getParseTreeNode(node *ast.Node, nodeTest func(node *ast.Node) bool) *ast.Node {
	if node == nil || isParseTreeNode(node) {
		return node
	}

	node = node.original
	for node != nil {
		if isParseTreeNode(node) {
			if nodeTest == nil || nodeTest(node) {
				return node
			} else {
				return nil
			}
		}
		node = node.original
	}
}

/** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */

func escapeLeadingUnderscores(identifier string) string {
	return (ifElse(identifier.length >= 2 && identifier.charCodeAt(0) == CharacterCodes_ && identifier.charCodeAt(1) == CharacterCodes_, "_"+identifier, identifier)).(string)
}

/**
 * Remove extra underscore from escaped identifier text content.
 *
 * @param identifier The escaped identifier text.
 * @returns The unescaped identifier text.
 */

func unescapeLeadingUnderscores(identifier string) string {
	id := identifier /* as string */
	if id.length >= 3 && id.charCodeAt(0) == CharacterCodes_ && id.charCodeAt(1) == CharacterCodes_ && id.charCodeAt(2) == CharacterCodes_ {
		return id.substr(1)
	} else {
		return id
	}
}

func idText(identifierOrPrivateName Union[Identifier, PrivateIdentifier]) string {
	return unescapeLeadingUnderscores(identifierOrPrivateName.escapedText)
}

/**
 * If the text of an Identifier matches a keyword (including contextual and TypeScript-specific keywords), returns the
 * SyntaxKind for the matching keyword.
 */

func identifierToKeywordKind(node Identifier) *KeywordSyntaxKind {
	token := stringToToken(node.escapedText /* as string */)
	if token {
		return tryCast(token, isKeyword)
	} else {
		return nil
	}
}

func symbolName(symbol *ast.Symbol) string {
	if symbol.valueDeclaration != nil && isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration) {
		return idText(symbol.valueDeclaration.name)
	}
	return unescapeLeadingUnderscores(symbol.escapedName)
}

/**
 * A JSDocTypedef tag has an _optional_ name field - if a name is not directly present, we should
 * attempt to draw the name from the node the declaration is on (as that declaration is what its' symbol
 * will be merged with)
 */

func nameForNamelessJSDocTypedef(declaration Union[JSDocTypedefTag, JSDocEnumTag]) Union[Identifier, PrivateIdentifier, undefined] {
	hostNode := declaration.parent.parent
	if !hostNode {
		return nil
	}
	// Covers classes, functions - any named declaration host node
	if isDeclaration(hostNode) {
		return getDeclarationIdentifier(hostNode)
	}
	// Covers remaining cases (returning undefined if none match).
	switch hostNode.kind {
	case ast.KindVariableStatement:
		if hostNode.declarationList && hostNode.declarationList.declarations[0] {
			return getDeclarationIdentifier(hostNode.declarationList.declarations[0])
		}
	case ast.KindExpressionStatement:
		expr := hostNode.expression
		if expr.kind == ast.KindBinaryExpression && (expr.AsBinaryExpression()).operatorToken.kind == ast.KindEqualsToken {
			expr = (expr.AsBinaryExpression()).left
		}
		switch expr.kind {
		case ast.KindPropertyAccessExpression:
			return (expr.AsPropertyAccessExpression()).name
		case ast.KindElementAccessExpression:
			arg := (expr.AsElementAccessExpression()).argumentExpression
			if isIdentifier(arg) {
				return arg
			}
		}
	case ast.KindParenthesizedExpression:
		return getDeclarationIdentifier(hostNode.expression)
	case ast.KindLabeledStatement:
		if isDeclaration(hostNode.statement) || isExpression(hostNode.statement) {
			return getDeclarationIdentifier(hostNode.statement)
		}
	}
}

func getDeclarationIdentifier(node Union[Declaration, Expression]) *Identifier {
	name := getNameOfDeclaration(node)
	if name != nil && isIdentifier(name) {
		return name
	} else {
		return nil
	}
}

/** @internal */

func nodeHasName(statement *ast.Node, name Identifier) bool {
	if isNamedDeclaration(statement) && isIdentifier(statement.name) && idText(statement.name.AsIdentifier()) == idText(name) {
		return true
	}
	if isVariableStatement(statement) && some(statement.declarationList.declarations, func(d VariableDeclaration) bool {
		return nodeHasName(d, name)
	}) {
		return true
	}
	return false
}

func getNameOfJSDocTypedef(declaration JSDocTypedefTag) Union[Identifier, PrivateIdentifier, undefined] {
	return declaration.name || nameForNamelessJSDocTypedef(declaration)
}

/** @internal */

func isNamedDeclaration(node *ast.Node) bool {
	return (node.AsNamedDeclaration()).name != nil
	// A 'name' property should always be a DeclarationName.
}

/** @internal */

func getNonAssignedNameOfDeclaration(declaration Union[Declaration, Expression]) *DeclarationName {
	switch declaration.kind {
	case ast.KindIdentifier:
		return declaration.AsIdentifier()
	case ast.KindJSDocPropertyTag,
		ast.KindJSDocParameterTag:
		TODO_IDENTIFIER := declaration.AsJSDocPropertyLikeTag()
		if name.kind == ast.KindQualifiedName {
			return name.right
		}
	case ast.KindCallExpression,
		ast.KindBinaryExpression:
		expr := declaration /* as BinaryExpression | CallExpression */
		switch getAssignmentDeclarationKind(expr) {
		case AssignmentDeclarationKindExportsProperty,
			AssignmentDeclarationKindThisProperty,
			AssignmentDeclarationKindProperty,
			AssignmentDeclarationKindPrototypeProperty:
			return getElementOrPropertyAccessArgumentExpressionOrName((expr.AsBinaryExpression()).left.AsAccessExpression())
		case AssignmentDeclarationKindObjectDefinePropertyValue,
			AssignmentDeclarationKindObjectDefinePropertyExports,
			AssignmentDeclarationKindObjectDefinePrototypeProperty:
			return (expr.AsBindableObjectDefinePropertyCall()).arguments[1]
		default:
			return nil
		}
		fallthrough
	case ast.KindJSDocTypedefTag:
		return getNameOfJSDocTypedef(declaration.AsJSDocTypedefTag())
	case ast.KindJSDocEnumTag:
		return nameForNamelessJSDocTypedef(declaration.AsJSDocEnumTag())
	case ast.KindExportAssignment:
		TODO_IDENTIFIER := declaration.AsExportAssignment()
		if isIdentifier(expression) {
			return expression
		} else {
			return nil
		}
	case ast.KindElementAccessExpression:
		expr := declaration.AsElementAccessExpression()
		if isBindableStaticElementAccessExpression(expr) {
			return expr.argumentExpression
		}
	}
	return (declaration.AsNamedDeclaration()).name
}

func getNameOfDeclaration(declaration Union[Declaration, Expression, undefined]) *DeclarationName {
	if declaration == nil {
		return nil
	}
	return getNonAssignedNameOfDeclaration(declaration) || (ifElse(isFunctionExpression(declaration) || isArrowFunction(declaration) || isClassExpression(declaration), getAssignedName(declaration), nil))
}

/** @internal */

func getAssignedName(node *ast.Node) *DeclarationName {
	if !node.parent {
		return nil
	} else if isPropertyAssignment(node.parent) || isBindingElement(node.parent) {
		return node.parent.name
	} else if isBinaryExpression(node.parent) && node == node.parent.right {
		if isIdentifier(node.parent.left) {
			return node.parent.left
		} else if isAccessExpression(node.parent.left) {
			return getElementOrPropertyAccessArgumentExpressionOrName(node.parent.left)
		}
	} else if isVariableDeclaration(node.parent) && isIdentifier(node.parent.name) {
		return node.parent.name
	}
}

func getDecorators(node HasDecorators) *[]Decorator {
	if hasDecorators(node) {
		return filter(node.modifiers, isDecorator)
	}
}

func getModifiers(node HasModifiers) *[]Modifier {
	if hasSyntacticModifier(node, ast.ModifierFlagsModifier) {
		return filter(node.modifiers, isModifier)
	}
}

func getJSDocParameterTagsWorker(param ParameterDeclaration, noCache bool) []JSDocParameterTag {
	if param.name {
		if isIdentifier(param.name) {
			name := param.name.escapedText
			return getJSDocTagsWorker(param.parent, noCache).filter(func(tag JSDocTag) bool {
				return isJSDocParameterTag(tag) && isIdentifier(tag.name) && tag.name.escapedText == name
			})
		} else {
			i := param.parent.parameters.indexOf(param)
			Debug.assert(i > -1, "Parameters should always be in their parents' parameter list")
			paramTags := getJSDocTagsWorker(param.parent, noCache).filter(isJSDocParameterTag)
			if i < paramTags.length {
				return []JSDocParameterTag{paramTags[i]}
			}
		}
	}
	// return empty array for: out-of-order binding patterns and JSDoc function syntax, which has un-named parameters
	return emptyArray
}

/**
 * Gets the JSDoc parameter tags for the node if present.
 *
 * @remarks Returns any JSDoc param tag whose name matches the provided
 * parameter, whether a param tag on a containing function
 * expression, or a param tag on a variable declaration whose
 * initializer is the containing function. The tags closest to the
 * node are returned first, so in the previous example, the param
 * tag on the containing function expression would be first.
 *
 * For binding patterns, parameter tags are matched by position.
 */

func getJSDocParameterTags(param ParameterDeclaration) []JSDocParameterTag {
	return getJSDocParameterTagsWorker(param, false /*noCache*/)
}

/** @internal */

func getJSDocParameterTagsNoCache(param ParameterDeclaration) []JSDocParameterTag {
	return getJSDocParameterTagsWorker(param, true /*noCache*/)
}

func getJSDocTypeParameterTagsWorker(param TypeParameterDeclaration, noCache bool) []JSDocTemplateTag {
	name := param.name.escapedText
	return getJSDocTagsWorker(param.parent, noCache).filter(func(tag JSDocTag) bool {
		return isJSDocTemplateTag(tag) && tag.typeParameters.some(func(tp TypeParameterDeclaration) bool {
			return tp.name.escapedText == name
		})
	})
}

/**
 * Gets the JSDoc type parameter tags for the node if present.
 *
 * @remarks Returns any JSDoc template tag whose names match the provided
 * parameter, whether a template tag on a containing function
 * expression, or a template tag on a variable declaration whose
 * initializer is the containing function. The tags closest to the
 * node are returned first, so in the previous example, the template
 * tag on the containing function expression would be first.
 */

func getJSDocTypeParameterTags(param TypeParameterDeclaration) []JSDocTemplateTag {
	return getJSDocTypeParameterTagsWorker(param, false /*noCache*/)
}

/** @internal */

func getJSDocTypeParameterTagsNoCache(param TypeParameterDeclaration) []JSDocTemplateTag {
	return getJSDocTypeParameterTagsWorker(param, true /*noCache*/)
}

/**
 * Return true if the node has JSDoc parameter tags.
 *
 * @remarks Includes parameter tags that are not directly on the node,
 * for example on a variable declaration whose initializer is a function expression.
 */

func hasJSDocParameterTags(node Union[FunctionLikeDeclaration, SignatureDeclaration]) bool {
	return getFirstJSDocTag(node, isJSDocParameterTag) != nil
}

/** Gets the JSDoc augments tag for the node if present */

func getJSDocAugmentsTag(node *ast.Node) *JSDocAugmentsTag {
	return getFirstJSDocTag(node, isJSDocAugmentsTag)
}

/** Gets the JSDoc implements tags for the node if present */

func getJSDocImplementsTags(node *ast.Node) []JSDocImplementsTag {
	return getAllJSDocTags(node, isJSDocImplementsTag)
}

/** Gets the JSDoc class tag for the node if present */

func getJSDocClassTag(node *ast.Node) *JSDocClassTag {
	return getFirstJSDocTag(node, isJSDocClassTag)
}

/** Gets the JSDoc public tag for the node if present */

func getJSDocPublicTag(node *ast.Node) *JSDocPublicTag {
	return getFirstJSDocTag(node, isJSDocPublicTag)
}

/** @internal */

func getJSDocPublicTagNoCache(node *ast.Node) *JSDocPublicTag {
	return getFirstJSDocTag(node, isJSDocPublicTag, true /*noCache*/)
}

/** Gets the JSDoc private tag for the node if present */

func getJSDocPrivateTag(node *ast.Node) *JSDocPrivateTag {
	return getFirstJSDocTag(node, isJSDocPrivateTag)
}

/** @internal */

func getJSDocPrivateTagNoCache(node *ast.Node) *JSDocPrivateTag {
	return getFirstJSDocTag(node, isJSDocPrivateTag, true /*noCache*/)
}

/** Gets the JSDoc protected tag for the node if present */

func getJSDocProtectedTag(node *ast.Node) *JSDocProtectedTag {
	return getFirstJSDocTag(node, isJSDocProtectedTag)
}

/** @internal */

func getJSDocProtectedTagNoCache(node *ast.Node) *JSDocProtectedTag {
	return getFirstJSDocTag(node, isJSDocProtectedTag, true /*noCache*/)
}

/** Gets the JSDoc protected tag for the node if present */

func getJSDocReadonlyTag(node *ast.Node) *JSDocReadonlyTag {
	return getFirstJSDocTag(node, isJSDocReadonlyTag)
}

/** @internal */

func getJSDocReadonlyTagNoCache(node *ast.Node) *JSDocReadonlyTag {
	return getFirstJSDocTag(node, isJSDocReadonlyTag, true /*noCache*/)
}

func getJSDocOverrideTagNoCache(node *ast.Node) *JSDocOverrideTag {
	return getFirstJSDocTag(node, isJSDocOverrideTag, true /*noCache*/)
}

/** Gets the JSDoc deprecated tag for the node if present */

func getJSDocDeprecatedTag(node *ast.Node) *JSDocDeprecatedTag {
	return getFirstJSDocTag(node, isJSDocDeprecatedTag)
}

/** @internal */

func getJSDocDeprecatedTagNoCache(node *ast.Node) *JSDocDeprecatedTag {
	return getFirstJSDocTag(node, isJSDocDeprecatedTag, true /*noCache*/)
}

/** Gets the JSDoc enum tag for the node if present */

func getJSDocEnumTag(node *ast.Node) *JSDocEnumTag {
	return getFirstJSDocTag(node, isJSDocEnumTag)
}

/** Gets the JSDoc this tag for the node if present */

func getJSDocThisTag(node *ast.Node) *JSDocThisTag {
	return getFirstJSDocTag(node, isJSDocThisTag)
}

/** Gets the JSDoc return tag for the node if present */

func getJSDocReturnTag(node *ast.Node) *JSDocReturnTag {
	return getFirstJSDocTag(node, isJSDocReturnTag)
}

/** Gets the JSDoc template tag for the node if present */

func getJSDocTemplateTag(node *ast.Node) *JSDocTemplateTag {
	return getFirstJSDocTag(node, isJSDocTemplateTag)
}

func getJSDocSatisfiesTag(node *ast.Node) *JSDocSatisfiesTag {
	return getFirstJSDocTag(node, isJSDocSatisfiesTag)
}

/** Gets the JSDoc type tag for the node if present and valid */

func getJSDocTypeTag(node *ast.Node) *JSDocTypeTag {
	// We should have already issued an error if there were multiple type jsdocs, so just use the first one.
	tag := getFirstJSDocTag(node, isJSDocTypeTag)
	if tag != nil && tag.typeExpression && tag.typeExpression.type_ {
		return tag
	}
	return nil
}

/**
 * Gets the type node for the node if provided via JSDoc.
 *
 * @remarks The search includes any JSDoc param tag that relates
 * to the provided parameter, for example a type tag on the
 * parameter itself, or a param tag on a containing function
 * expression, or a param tag on a variable declaration whose
 * initializer is the containing function. The tags closest to the
 * node are examined first, so in the previous example, the type
 * tag directly on the node would be returned.
 */

func getJSDocType(node *ast.Node) *TypeNode {
	var tag Union[JSDocTypeTag, JSDocParameterTag, undefined] = getFirstJSDocTag(node, isJSDocTypeTag)
	if tag == nil && isParameter(node) {
		tag = find(getJSDocParameterTags(node), func(tag JSDocParameterTag) bool {
			return tag.typeExpression != nil
		})
	}

	return tag && tag.typeExpression && tag.typeExpression.type_
}

/**
 * Gets the return type node for the node if provided via JSDoc return tag or type tag.
 *
 * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
 * gets the type from inside the braces, after the fat arrow, etc.
 */

func getJSDocReturnType(node *ast.Node) *TypeNode {
	returnTag := getJSDocReturnTag(node)
	if returnTag != nil && returnTag.typeExpression != nil {
		return returnTag.typeExpression.type_
	}
	typeTag := getJSDocTypeTag(node)
	if typeTag != nil && typeTag.typeExpression {
		t := typeTag.typeExpression.type_
		if isTypeLiteralNode(t) {
			sig := find(t.members, isCallSignatureDeclaration)
			return sig && sig.type_
		}
		if isFunctionTypeNode(t) || isJSDocFunctionType(t) {
			return t.type_
		}
	}
}

func getJSDocTagsWorker(node *ast.Node, noCache bool) []JSDocTag {
	if !canHaveJSDoc(node) {
		return emptyArray
	}
	tags := node.jsDoc. /* ? */ jsDocCache
	// If cache is 'null', that means we did the work of searching for JSDoc tags and came up with nothing.
	if tags == nil || noCache {
		comments := getJSDocCommentsAndTags(node, noCache)
		Debug.assert(comments.length < 2 || comments[0] != comments[1])
		tags = flatMap(comments, func(j /* TODO(TS-TO-GO) inferred type JSDocTag | JSDoc */ any) * /* TODO(TS-TO-GO) inferred type JSDocTag | NodeArray<JSDocTag> */ any {
			if isJSDoc(j) {
				return j.tags
			} else {
				return j
			}
		})
		if !noCache {
			if node.jsDoc == nil {
				node.jsDoc = []never{}
			}
			node.jsDoc.jsDocCache = tags
		}
	}
	return tags
}

/** Get all JSDoc tags related to a node, including those on parent nodes. */

func getJSDocTags(node *ast.Node) []JSDocTag {
	return getJSDocTagsWorker(node, false /*noCache*/)
}

/** Get the first JSDoc tag of a specified kind, or undefined if not present. */

func getFirstJSDocTag(node *ast.Node, predicate func(tag JSDocTag) /* TODO(TS-TO-GO) TypeNode TypePredicate: tag is T */ any, noCache bool) *T {
	return find(getJSDocTagsWorker(node, noCache), predicate)
}

/** Gets all JSDoc tags that match a specified predicate */

func getAllJSDocTags(node *ast.Node, predicate func(tag JSDocTag) /* TODO(TS-TO-GO) TypeNode TypePredicate: tag is T */ any) []T {
	return getJSDocTags(node).filter(predicate)
}

/** Gets all JSDoc tags of a specified kind */

func getAllJSDocTagsOfKind(node *ast.Node, kind SyntaxKind) []JSDocTag {
	return getJSDocTags(node).filter(func(doc JSDocTag) bool {
		return doc.kind == kind
	})
}

/** Gets the text of a jsdoc comment, flattening links to their text. */

func getTextOfJSDocComment(comment Union[string, NodeArray[JSDocComment]]) *string {
	if /* TODO(TS-TO-GO) Expression TypeOfExpression: typeof comment */ TODO == "string" {
		return comment
	} else {
		return comment. /* ? */ map_(func(c JSDocComment) string {
			if c.kind == ast.KindJSDocText {
				return c.text
			} else {
				return formatJSDocLink(c)
			}
		}).join("")
	}
}

func formatJSDocLink(link Union[JSDocLink, JSDocLinkCode, JSDocLinkPlain]) string {
	var kind /* TODO(TS-TO-GO) inferred type "link" | "linkcode" | "linkplain" */ any
	switch {
	case link.kind == ast.KindJSDocLink:
		kind = "link"
	case link.kind == ast.KindJSDocLinkCode:
		kind = "linkcode"
	default:
		kind = "linkplain"
	}
	var name string
	if link.name != nil {
		name = entityNameToString(link.name)
	} else {
		name = ""
	}
	var space /* TODO(TS-TO-GO) inferred type "" | " " */ any
	if link.name != nil && (link.text == "" || link.text.startsWith("://")) {
		space = ""
	} else {
		space = " "
	}
	return __TEMPLATE__("{@", kind, " ", name, space, link.text, "}")
}

/**
 * Gets the effective type parameters. If the node was parsed in a
 * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
 *
 * This does *not* return type parameters from a jsdoc reference to a generic type, eg
 *
 * type Id = <T>(x: T) => T
 * /** @type {Id} /
 * function id(x) { return x }
 */

func getEffectiveTypeParameterDeclarations(node DeclarationWithTypeParameters) []TypeParameterDeclaration {
	if isJSDocSignature(node) {
		if isJSDocOverloadTag(node.parent) {
			jsDoc := getJSDocRoot(node.parent)
			if jsDoc != nil && length(jsDoc.tags) != 0 {
				return flatMap(jsDoc.tags, func(tag JSDocTag) *NodeArray[TypeParameterDeclaration] {
					if isJSDocTemplateTag(tag) {
						return tag.typeParameters
					} else {
						return nil
					}
				})
			}
		}
		return emptyArray
	}
	if isJSDocTypeAlias(node) {
		Debug.assert(node.parent.kind == ast.KindJSDoc)
		return flatMap(node.parent.tags, func(tag JSDocTag) *NodeArray[TypeParameterDeclaration] {
			if isJSDocTemplateTag(tag) {
				return tag.typeParameters
			} else {
				return nil
			}
		})
	}
	if node.typeParameters != nil {
		return node.typeParameters
	}
	if canHaveIllegalTypeParameters(node) && node.typeParameters {
		return node.typeParameters
	}
	if isInJSFile(node) {
		decls := getJSDocTypeParameterDeclarations(node)
		if decls.length != 0 {
			return decls
		}
		typeTag := getJSDocType(node)
		if typeTag != nil && isFunctionTypeNode(typeTag) && typeTag.typeParameters != nil {
			return typeTag.typeParameters
		}
	}
	return emptyArray
}

func getEffectiveConstraintOfTypeParameter(node TypeParameterDeclaration) *TypeNode {
	switch {
	case node.constraint != nil:
		return node.constraint
	case isJSDocTemplateTag(node.parent) && node == node.parent.typeParameters[0]:
		return node.parent.constraint
	default:
		return nil
	}
}

// #region

func isMemberName(node *ast.Node) bool {
	return node.kind == ast.KindIdentifier || node.kind == ast.KindPrivateIdentifier
}

/** @internal */

func isGetOrSetAccessorDeclaration(node *ast.Node) bool {
	return node.kind == ast.KindSetAccessor || node.kind == ast.KindGetAccessor
}

func isPropertyAccessChain(node *ast.Node) bool {
	return isPropertyAccessExpression(node) && node.flags&ast.NodeFlagsOptionalChain != 0
}

func isElementAccessChain(node *ast.Node) bool {
	return isElementAccessExpression(node) && node.flags&ast.NodeFlagsOptionalChain != 0
}

func isCallChain(node *ast.Node) bool {
	return isCallExpression(node) && node.flags&ast.NodeFlagsOptionalChain != 0
}

func isOptionalChain(node *ast.Node) bool {
	kind := node.kind
	return node.flags&ast.NodeFlagsOptionalChain != 0 && (kind == ast.KindPropertyAccessExpression || kind == ast.KindElementAccessExpression || kind == ast.KindCallExpression || kind == ast.KindNonNullExpression)
}

/** @internal */

func isOptionalChainRoot(node *ast.Node) bool {
	return isOptionalChain(node) && !isNonNullExpression(node) && node.questionDotToken != nil
}

/**
 * Determines whether a node is the expression preceding an optional chain (i.e. `a` in `a?.b`).
 *
 * @internal
 */

func isExpressionOfOptionalChainRoot(node *ast.Node) bool {
	return isOptionalChainRoot(node.parent) && node.parent.expression == node
}

/**
 * Determines whether a node is the outermost `OptionalChain` in an ECMAScript `OptionalExpression`:
 *
 * 1. For `a?.b.c`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.`)
 * 2. For `a?.b!`, the outermost chain is `a?.b` (`b` is the end of the chain starting at `a?.`)
 * 3. For `(a?.b.c).d`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.` since parens end the chain)
 * 4. For `a?.b.c?.d`, both `a?.b.c` and `a?.b.c?.d` are outermost (`c` is the end of the chain starting at `a?.`, and `d` is
 *   the end of the chain starting at `c?.`)
 * 5. For `a?.(b?.c).d`, both `b?.c` and `a?.(b?.c)d` are outermost (`c` is the end of the chain starting at `b`, and `d` is
 *   the end of the chain starting at `a?.`)
 *
 * @internal
 */

func isOutermostOptionalChain(node OptionalChain) bool {
	return !isOptionalChain(node.parent) || isOptionalChainRoot(node.parent) || node != node.parent.expression
	// case 5
}

func isNullishCoalesce(node *ast.Node) bool {
	return node.kind == ast.KindBinaryExpression && (node.AsBinaryExpression()).operatorToken.kind == ast.KindQuestionQuestionToken
}

func isConstTypeReference(node *ast.Node) bool {
	return isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText == "const" && node.typeArguments == nil
}

/* OVERLOAD: export function skipPartiallyEmittedExpressions(node: Expression): Expression; */
/* OVERLOAD: export function skipPartiallyEmittedExpressions(node: Node): Node; */
func skipPartiallyEmittedExpressions(node *ast.Node) *ast.Node {
	return skipOuterExpressions(node, OuterExpressionKindsPartiallyEmittedExpressions)
}

func isNonNullChain(node *ast.Node) bool {
	return isNonNullExpression(node) && node.flags&ast.NodeFlagsOptionalChain != 0
}

func isBreakOrContinueStatement(node *ast.Node) bool {
	return node.kind == ast.KindBreakStatement || node.kind == ast.KindContinueStatement
}

func isNamedExportBindings(node *ast.Node) bool {
	return node.kind == ast.KindNamespaceExport || node.kind == ast.KindNamedExports
}

func isJSDocPropertyLikeTag(node *ast.Node) bool {
	return node.kind == ast.KindJSDocPropertyTag || node.kind == ast.KindJSDocParameterTag
}

// #endregion

// #region
// Node tests
//
// All node tests in the following list should *not* reference parent pointers so that
// they may be used with transformations.

func isNodeKind(kind SyntaxKind) bool {
	return kind >= ast.KindFirstNode
}

/**
 * True if kind is of some token syntax kind.
 * For example, this is true for an IfKeyword but not for an IfStatement.
 * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
 */

func isTokenKind(kind SyntaxKind) bool {
	return kind >= ast.KindFirstToken && kind <= ast.KindLastToken
}

/**
 * True if node is of some token syntax kind.
 * For example, this is true for an IfKeyword but not for an IfStatement.
 * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
 */

func isToken(n *ast.Node) bool {
	return isTokenKind(n.kind)
}

// Node Arrays

func isNodeArray(array []T) bool {
	return hasProperty(array, "pos") && hasProperty(array, "end")
}

// Literals

func isLiteralKind(kind SyntaxKind) bool {
	return ast.KindFirstLiteralToken <= kind && kind <= ast.KindLastLiteralToken
}

func isLiteralExpression(node *ast.Node) bool {
	return isLiteralKind(node.kind)
}

/** @internal */

func isLiteralExpressionOfObject(node *ast.Node) bool {
	switch node.kind {
	case ast.KindObjectLiteralExpression,
		ast.KindArrayLiteralExpression,
		ast.KindRegularExpressionLiteral,
		ast.KindFunctionExpression,
		ast.KindClassExpression:
		return true
	}
	return false
}

// Pseudo-literals

func isTemplateLiteralKind(kind SyntaxKind) bool {
	return ast.KindFirstTemplateToken <= kind && kind <= ast.KindLastTemplateToken
}

func isTemplateLiteralToken(node *ast.Node) bool {
	return isTemplateLiteralKind(node.kind)
}

func isTemplateMiddleOrTemplateTail(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindTemplateMiddle || kind == ast.KindTemplateTail
}

func isImportOrExportSpecifier(node *ast.Node) bool {
	return isImportSpecifier(node) || isExportSpecifier(node)
}

func isTypeOnlyImportDeclaration(node *ast.Node) bool {
	switch node.kind {
	case ast.KindImportSpecifier:
		return (node.AsImportSpecifier()).isTypeOnly || (node.AsImportSpecifier()).parent.parent.isTypeOnly
	case ast.KindNamespaceImport:
		return (node.AsNamespaceImport()).parent.isTypeOnly
	case ast.KindImportClause,
		ast.KindImportEqualsDeclaration:
		return (node /* as ImportClause | ImportEqualsDeclaration */).isTypeOnly
	}
	return false
}

func isTypeOnlyExportDeclaration(node *ast.Node) bool {
	switch node.kind {
	case ast.KindExportSpecifier:
		return (node.AsExportSpecifier()).isTypeOnly || (node.AsExportSpecifier()).parent.parent.isTypeOnly
	case ast.KindExportDeclaration:
		return (node.AsExportDeclaration()).isTypeOnly && (node.AsExportDeclaration()).moduleSpecifier != nil && (node.AsExportDeclaration()).exportClause == nil
	case ast.KindNamespaceExport:
		return (node.AsNamespaceExport()).parent.isTypeOnly
	}
	return false
}

func isTypeOnlyImportOrExportDeclaration(node *ast.Node) bool {
	return isTypeOnlyImportDeclaration(node) || isTypeOnlyExportDeclaration(node)
}

func isStringTextContainingNode(node *ast.Node) bool {
	return node.kind == ast.KindStringLiteral || isTemplateLiteralKind(node.kind)
}

func isImportAttributeName(node *ast.Node) bool {
	return isStringLiteral(node) || isIdentifier(node)
}

// Identifiers

func isGeneratedIdentifier(node *ast.Node) bool {
	return isIdentifier(node) && node.emitNode. /* ? */ autoGenerate != nil
}

/** @internal */

func isGeneratedPrivateIdentifier(node *ast.Node) bool {
	return isPrivateIdentifier(node) && node.emitNode. /* ? */ autoGenerate != nil
}

/** @internal */

func isFileLevelReservedGeneratedIdentifier(node GeneratedIdentifier) bool {
	flags := node.emitNode.autoGenerate.flags
	return flags&GeneratedIdentifierFlagsFileLevel != 0 && flags&GeneratedIdentifierFlagsOptimistic != 0 && flags&GeneratedIdentifierFlagsReservedInNestedScopes != 0
}

// Private Identifiers

func isPrivateIdentifierClassElementDeclaration(node *ast.Node) bool {
	return (isPropertyDeclaration(node) || isMethodOrAccessor(node)) && isPrivateIdentifier(node.name)
}

/** @internal */

func isPrivateIdentifierPropertyAccessExpression(node *ast.Node) bool {
	return isPropertyAccessExpression(node) && isPrivateIdentifier(node.name)
}

// Keywords

func isModifierKind(token SyntaxKind) bool {
	switch token {
	case ast.KindAbstractKeyword,
		ast.KindAccessorKeyword,
		ast.KindAsyncKeyword,
		ast.KindConstKeyword,
		ast.KindDeclareKeyword,
		ast.KindDefaultKeyword,
		ast.KindExportKeyword,
		ast.KindInKeyword,
		ast.KindPublicKeyword,
		ast.KindPrivateKeyword,
		ast.KindProtectedKeyword,
		ast.KindReadonlyKeyword,
		ast.KindStaticKeyword,
		ast.KindOutKeyword,
		ast.KindOverrideKeyword:
		return true
	}
	return false
}

/** @internal */

func isParameterPropertyModifier(kind SyntaxKind) bool {
	return modifierToFlag(kind)&ast.ModifierFlagsParameterPropertyModifier != 0
}

/** @internal */

func isClassMemberModifier(idToken SyntaxKind) bool {
	return isParameterPropertyModifier(idToken) || idToken == ast.KindStaticKeyword || idToken == ast.KindOverrideKeyword || idToken == ast.KindAccessorKeyword
}

func isModifier(node *ast.Node) bool {
	return isModifierKind(node.kind)
}

func isEntityName(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindQualifiedName || kind == ast.KindIdentifier
}

func isPropertyName(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindIdentifier || kind == ast.KindPrivateIdentifier || kind == ast.KindStringLiteral || kind == ast.KindNumericLiteral || kind == ast.KindComputedPropertyName
}

func isBindingName(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindIdentifier || kind == ast.KindObjectBindingPattern || kind == ast.KindArrayBindingPattern
}

// Functions

func isFunctionLike(node *ast.Node) bool {
	return node != nil && isFunctionLikeKind(node.kind)
}

/** @internal */

func isFunctionLikeOrClassStaticBlockDeclaration(node *ast.Node) bool {
	return node != nil && (isFunctionLikeKind(node.kind) || isClassStaticBlockDeclaration(node))
}

/** @internal */

func isFunctionLikeDeclaration(node *ast.Node) bool {
	return node && isFunctionLikeDeclarationKind(node.kind)
}

/** @internal */

func isBooleanLiteral(node *ast.Node) bool {
	return node.kind == ast.KindTrueKeyword || node.kind == ast.KindFalseKeyword
}

func isFunctionLikeDeclarationKind(kind SyntaxKind) bool {
	switch kind {
	case ast.KindFunctionDeclaration,
		ast.KindMethodDeclaration,
		ast.KindConstructor,
		ast.KindGetAccessor,
		ast.KindSetAccessor,
		ast.KindFunctionExpression,
		ast.KindArrowFunction:
		return true
	default:
		return false
	}
}

/** @internal */

func isFunctionLikeKind(kind SyntaxKind) bool {
	switch kind {
	case ast.KindMethodSignature,
		ast.KindCallSignature,
		ast.KindJSDocSignature,
		ast.KindConstructSignature,
		ast.KindIndexSignature,
		ast.KindFunctionType,
		ast.KindJSDocFunctionType,
		ast.KindConstructorType:
		return true
	default:
		return isFunctionLikeDeclarationKind(kind)
	}
}

/** @internal */

func isFunctionOrModuleBlock(node *ast.Node) bool {
	return isSourceFile(node) || isModuleBlock(node) || isBlock(node) && isFunctionLike(node.parent)
}

// Classes
func isClassElement(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindConstructor || kind == ast.KindPropertyDeclaration || kind == ast.KindMethodDeclaration || kind == ast.KindGetAccessor || kind == ast.KindSetAccessor || kind == ast.KindIndexSignature || kind == ast.KindClassStaticBlockDeclaration || kind == ast.KindSemicolonClassElement
}

func isClassLike(node *ast.Node) bool {
	return node && (node.kind == ast.KindClassDeclaration || node.kind == ast.KindClassExpression)
}

func isAccessor(node *ast.Node) bool {
	return node && (node.kind == ast.KindGetAccessor || node.kind == ast.KindSetAccessor)
}

func isAutoAccessorPropertyDeclaration(node *ast.Node) bool {
	return isPropertyDeclaration(node) && hasAccessorModifier(node)
}

/** @internal */

func isClassInstanceProperty(node Declaration) bool {
	if isInJSFile(node) && isExpandoPropertyDeclaration(node) {
		return (!isBindableStaticAccessExpression(node) || !isPrototypeAccess(node.expression)) && !isBindableStaticNameExpression(node, true /*excludeThisKeyword*/)
	}
	return node.parent && isClassLike(node.parent) && isPropertyDeclaration(node) && !hasAccessorModifier(node)
}

/** @internal */

func isMethodOrAccessor(node *ast.Node) bool {
	switch node.kind {
	case ast.KindMethodDeclaration,
		ast.KindGetAccessor,
		ast.KindSetAccessor:
		return true
	default:
		return false
	}
}

// Type members

func isModifierLike(node *ast.Node) bool {
	return isModifier(node) || isDecorator(node)
}

func isTypeElement(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindConstructSignature || kind == ast.KindCallSignature || kind == ast.KindPropertySignature || kind == ast.KindMethodSignature || kind == ast.KindIndexSignature || kind == ast.KindGetAccessor || kind == ast.KindSetAccessor || kind == ast.KindNotEmittedTypeElement
}

func isClassOrTypeElement(node *ast.Node) bool {
	return isTypeElement(node) || isClassElement(node)
}

func isObjectLiteralElementLike(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindPropertyAssignment || kind == ast.KindShorthandPropertyAssignment || kind == ast.KindSpreadAssignment || kind == ast.KindMethodDeclaration || kind == ast.KindGetAccessor || kind == ast.KindSetAccessor
}

// Type

func isTypeNode(node *ast.Node) bool {
	return isTypeNodeKind(node.kind)
}

func isFunctionOrConstructorTypeNode(node *ast.Node) bool {
	switch node.kind {
	case ast.KindFunctionType,
		ast.KindConstructorType:
		return true
	}

	return false
}

// Binding patterns

func isBindingPattern(node *ast.Node) bool {
	if node != nil {
		kind := node.kind
		return kind == ast.KindArrayBindingPattern || kind == ast.KindObjectBindingPattern
	}

	return false
}

/** @internal */

func isAssignmentPattern(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindArrayLiteralExpression || kind == ast.KindObjectLiteralExpression
}

func isArrayBindingElement(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindBindingElement || kind == ast.KindOmittedExpression
}

/**
 * Determines whether the BindingOrAssignmentElement is a BindingElement-like declaration
 *
 * @internal
 */

func isDeclarationBindingElement(bindingElement BindingOrAssignmentElement) bool {
	switch bindingElement.kind {
	case ast.KindVariableDeclaration,
		ast.KindParameter,
		ast.KindBindingElement:
		return true
	}

	return false
}

/** @internal */

func isBindingOrAssignmentElement(node *ast.Node) bool {
	return isVariableDeclaration(node) || isParameter(node) || isObjectBindingOrAssignmentElement(node) || isArrayBindingOrAssignmentElement(node)
}

/**
 * Determines whether a node is a BindingOrAssignmentPattern
 *
 * @internal
 */

func isBindingOrAssignmentPattern(node BindingOrAssignmentElementTarget) bool {
	return isObjectBindingOrAssignmentPattern(node) || isArrayBindingOrAssignmentPattern(node)
}

/**
 * Determines whether a node is an ObjectBindingOrAssignmentPattern
 *
 * @internal
 */

func isObjectBindingOrAssignmentPattern(node BindingOrAssignmentElementTarget) bool {
	switch node.kind {
	case ast.KindObjectBindingPattern,
		ast.KindObjectLiteralExpression:
		return true
	}

	return false
}

/** @internal */

func isObjectBindingOrAssignmentElement(node *ast.Node) bool {
	switch node.kind {
	case ast.KindBindingElement,
		ast.KindPropertyAssignment,
		ast.KindShorthandPropertyAssignment,
		ast.KindSpreadAssignment:
		return true
	}
	return false
}

/**
 * Determines whether a node is an ArrayBindingOrAssignmentPattern
 *
 * @internal
 */

func isArrayBindingOrAssignmentPattern(node BindingOrAssignmentElementTarget) bool {
	switch node.kind {
	case ast.KindArrayBindingPattern,
		ast.KindArrayLiteralExpression:
		return true
	}

	return false
}

/** @internal */

func isArrayBindingOrAssignmentElement(node *ast.Node) bool {
	switch node.kind {
	case ast.KindBindingElement,
		ast.KindOmittedExpression,
		ast.KindSpreadElement,
		ast.KindArrayLiteralExpression,
		ast.KindObjectLiteralExpression,
		ast.KindIdentifier,
		ast.KindPropertyAccessExpression,
		ast.KindElementAccessExpression:
		return true
	}
	return isAssignmentExpression(node, true /*excludeCompoundAssignment*/)
	// AssignmentElement
}

/** @internal */

func isPropertyAccessOrQualifiedNameOrImportTypeNode(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindPropertyAccessExpression || kind == ast.KindQualifiedName || kind == ast.KindImportType
}

// Expression

func isPropertyAccessOrQualifiedName(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindPropertyAccessExpression || kind == ast.KindQualifiedName
}

/** @internal */

func isCallLikeOrFunctionLikeExpression(node *ast.Node) bool {
	return isCallLikeExpression(node) || isFunctionExpressionOrArrowFunction(node)
}

func isCallLikeExpression(node *ast.Node) bool {
	switch node.kind {
	case ast.KindJsxOpeningElement,
		ast.KindJsxSelfClosingElement,
		ast.KindCallExpression,
		ast.KindNewExpression,
		ast.KindTaggedTemplateExpression,
		ast.KindDecorator:
		return true
	default:
		return false
	}
}

func isCallOrNewExpression(node *ast.Node) bool {
	return node.kind == ast.KindCallExpression || node.kind == ast.KindNewExpression
}

func isTemplateLiteral(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindTemplateExpression || kind == ast.KindNoSubstitutionTemplateLiteral
}

func isLeftHandSideExpression(node *ast.Node) bool {
	return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind)
}

func isLeftHandSideExpressionKind(kind SyntaxKind) bool {
	switch kind {
	case ast.KindPropertyAccessExpression,
		ast.KindElementAccessExpression,
		ast.KindNewExpression,
		ast.KindCallExpression,
		ast.KindJsxElement,
		ast.KindJsxSelfClosingElement,
		ast.KindJsxFragment,
		ast.KindTaggedTemplateExpression,
		ast.KindArrayLiteralExpression,
		ast.KindParenthesizedExpression,
		ast.KindObjectLiteralExpression,
		ast.KindClassExpression,
		ast.KindFunctionExpression,
		ast.KindIdentifier,
		ast.KindPrivateIdentifier,
		ast.KindRegularExpressionLiteral,
		ast.KindNumericLiteral,
		ast.KindBigIntLiteral,
		ast.KindStringLiteral,
		ast.KindNoSubstitutionTemplateLiteral,
		ast.KindTemplateExpression,
		ast.KindFalseKeyword,
		ast.KindNullKeyword,
		ast.KindThisKeyword,
		ast.KindTrueKeyword,
		ast.KindSuperKeyword,
		ast.KindNonNullExpression,
		ast.KindExpressionWithTypeArguments,
		ast.KindMetaProperty,
		ast.KindImportKeyword,
		ast.KindMissingDeclaration:
		return true
	default:
		return false
	}
}

/** @internal */

func isUnaryExpression(node *ast.Node) bool {
	return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind)
}

func isUnaryExpressionKind(kind SyntaxKind) bool {
	switch kind {
	case ast.KindPrefixUnaryExpression,
		ast.KindPostfixUnaryExpression,
		ast.KindDeleteExpression,
		ast.KindTypeOfExpression,
		ast.KindVoidExpression,
		ast.KindAwaitExpression,
		ast.KindTypeAssertionExpression:
		return true
	default:
		return isLeftHandSideExpressionKind(kind)
	}
}

/** @internal */

func isUnaryExpressionWithWrite(expr *ast.Node) bool {
	switch expr.kind {
	case ast.KindPostfixUnaryExpression:
		return true
	case ast.KindPrefixUnaryExpression:
		return (expr.AsPrefixUnaryExpression()).operator == ast.KindPlusPlusToken || (expr.AsPrefixUnaryExpression()).operator == ast.KindMinusMinusToken
	default:
		return false
	}
}

func isLiteralTypeLiteral(node *ast.Node) bool {
	switch node.kind {
	case ast.KindNullKeyword,
		ast.KindTrueKeyword,
		ast.KindFalseKeyword,
		ast.KindPrefixUnaryExpression:
		return true
	default:
		return isLiteralExpression(node)
	}
}

/**
 * Determines whether a node is an expression based only on its kind.
 */

func isExpression(node *ast.Node) bool {
	return isExpressionKind(skipPartiallyEmittedExpressions(node).kind)
}

func isExpressionKind(kind SyntaxKind) bool {
	switch kind {
	case ast.KindConditionalExpression,
		ast.KindYieldExpression,
		ast.KindArrowFunction,
		ast.KindBinaryExpression,
		ast.KindSpreadElement,
		ast.KindAsExpression,
		ast.KindOmittedExpression,
		ast.KindCommaListExpression,
		ast.KindPartiallyEmittedExpression,
		ast.KindSatisfiesExpression:
		return true
	default:
		return isUnaryExpressionKind(kind)
	}
}

func isAssertionExpression(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindTypeAssertionExpression || kind == ast.KindAsExpression
}

// Statement

/* OVERLOAD: export function isIterationStatement(node: Node, lookInLabeledStatements: false): node is IterationStatement; */
/* OVERLOAD: export function isIterationStatement(node: Node, lookInLabeledStatements: boolean): node is IterationStatement | LabeledStatement; */
func isIterationStatement(node *ast.Node, lookInLabeledStatements bool) bool {
	switch node.kind {
	case ast.KindForStatement,
		ast.KindForInStatement,
		ast.KindForOfStatement,
		ast.KindDoStatement,
		ast.KindWhileStatement:
		return true
	case ast.KindLabeledStatement:
		return lookInLabeledStatements && isIterationStatement((node.AsLabeledStatement()).statement, lookInLabeledStatements)
	}

	return false
}

func isScopeMarker(node *ast.Node) bool {
	return isExportAssignment(node) || isExportDeclaration(node)
}

/** @internal */

func hasScopeMarker(statements []Statement) bool {
	return some(statements, isScopeMarker)
}

/** @internal */

func needsScopeMarker(result Statement) bool {
	return !isAnyImportOrReExport(result) && !isExportAssignment(result) && !hasSyntacticModifier(result, ast.ModifierFlagsExport) && !isAmbientModule(result)
}

/** @internal */

func isExternalModuleIndicator(result Statement) bool {
	// Exported top-level member indicates moduleness
	return isAnyImportOrReExport(result) || isExportAssignment(result) || hasSyntacticModifier(result, ast.ModifierFlagsExport)
}

/** @internal */

func isForInOrOfStatement(node *ast.Node) bool {
	return node.kind == ast.KindForInStatement || node.kind == ast.KindForOfStatement
}

// Element

func isConciseBody(node *ast.Node) bool {
	return isBlock(node) || isExpression(node)
}

/** @internal */

func isFunctionBody(node *ast.Node) bool {
	return isBlock(node)
}

func isForInitializer(node *ast.Node) bool {
	return isVariableDeclarationList(node) || isExpression(node)
}

func isModuleBody(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindModuleBlock || kind == ast.KindModuleDeclaration || kind == ast.KindIdentifier
}

/** @internal @knipignore */

func isNamespaceBody(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindModuleBlock || kind == ast.KindModuleDeclaration
}

/** @internal @knipignore */

func isJSDocNamespaceBody(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindIdentifier || kind == ast.KindModuleDeclaration
}

func isNamedImportBindings(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindNamedImports || kind == ast.KindNamespaceImport
}

/** @internal */

func isModuleOrEnumDeclaration(node *ast.Node) bool {
	return node.kind == ast.KindModuleDeclaration || node.kind == ast.KindEnumDeclaration
}

/** @internal */

func canHaveSymbol(node *ast.Node) bool {
	// NOTE: This should cover all possible declarations except MissingDeclaration and SemicolonClassElement
	//       since they aren't actually declarations and can't have a symbol.
	switch node.kind {
	case ast.KindArrowFunction,
		ast.KindBinaryExpression,
		ast.KindBindingElement,
		ast.KindCallExpression,
		ast.KindCallSignature,
		ast.KindClassDeclaration,
		ast.KindClassExpression,
		ast.KindClassStaticBlockDeclaration,
		ast.KindConstructor,
		ast.KindConstructorType,
		ast.KindConstructSignature,
		ast.KindElementAccessExpression,
		ast.KindEnumDeclaration,
		ast.KindEnumMember,
		ast.KindExportAssignment,
		ast.KindExportDeclaration,
		ast.KindExportSpecifier,
		ast.KindFunctionDeclaration,
		ast.KindFunctionExpression,
		ast.KindFunctionType,
		ast.KindGetAccessor,
		ast.KindIdentifier,
		ast.KindImportClause,
		ast.KindImportEqualsDeclaration,
		ast.KindImportSpecifier,
		ast.KindIndexSignature,
		ast.KindInterfaceDeclaration,
		ast.KindJSDocCallbackTag,
		ast.KindJSDocEnumTag,
		ast.KindJSDocFunctionType,
		ast.KindJSDocParameterTag,
		ast.KindJSDocPropertyTag,
		ast.KindJSDocSignature,
		ast.KindJSDocTypedefTag,
		ast.KindJSDocTypeLiteral,
		ast.KindJsxAttribute,
		ast.KindJsxAttributes,
		ast.KindJsxSpreadAttribute,
		ast.KindMappedType,
		ast.KindMethodDeclaration,
		ast.KindMethodSignature,
		ast.KindModuleDeclaration,
		ast.KindNamedTupleMember,
		ast.KindNamespaceExport,
		ast.KindNamespaceExportDeclaration,
		ast.KindNamespaceImport,
		ast.KindNewExpression,
		ast.KindNoSubstitutionTemplateLiteral,
		ast.KindNumericLiteral,
		ast.KindObjectLiteralExpression,
		ast.KindParameter,
		ast.KindPropertyAccessExpression,
		ast.KindPropertyAssignment,
		ast.KindPropertyDeclaration,
		ast.KindPropertySignature,
		ast.KindSetAccessor,
		ast.KindShorthandPropertyAssignment,
		ast.KindSourceFile,
		ast.KindSpreadAssignment,
		ast.KindStringLiteral,
		ast.KindTypeAliasDeclaration,
		ast.KindTypeLiteral,
		ast.KindTypeParameter,
		ast.KindVariableDeclaration:
		return true
	default:
		return false
	}
}

/** @internal */

func canHaveLocals(node *ast.Node) bool {
	switch node.kind {
	case ast.KindArrowFunction,
		ast.KindBlock,
		ast.KindCallSignature,
		ast.KindCaseBlock,
		ast.KindCatchClause,
		ast.KindClassStaticBlockDeclaration,
		ast.KindConditionalType,
		ast.KindConstructor,
		ast.KindConstructorType,
		ast.KindConstructSignature,
		ast.KindForStatement,
		ast.KindForInStatement,
		ast.KindForOfStatement,
		ast.KindFunctionDeclaration,
		ast.KindFunctionExpression,
		ast.KindFunctionType,
		ast.KindGetAccessor,
		ast.KindIndexSignature,
		ast.KindJSDocCallbackTag,
		ast.KindJSDocEnumTag,
		ast.KindJSDocFunctionType,
		ast.KindJSDocSignature,
		ast.KindJSDocTypedefTag,
		ast.KindMappedType,
		ast.KindMethodDeclaration,
		ast.KindMethodSignature,
		ast.KindModuleDeclaration,
		ast.KindSetAccessor,
		ast.KindSourceFile,
		ast.KindTypeAliasDeclaration:
		return true
	default:
		return false
	}
}

func isDeclarationKind(kind SyntaxKind) bool {
	return kind == ast.KindArrowFunction || kind == ast.KindBindingElement || kind == ast.KindClassDeclaration || kind == ast.KindClassExpression || kind == ast.KindClassStaticBlockDeclaration || kind == ast.KindConstructor || kind == ast.KindEnumDeclaration || kind == ast.KindEnumMember || kind == ast.KindExportSpecifier || kind == ast.KindFunctionDeclaration || kind == ast.KindFunctionExpression || kind == ast.KindGetAccessor || kind == ast.KindImportClause || kind == ast.KindImportEqualsDeclaration || kind == ast.KindImportSpecifier || kind == ast.KindInterfaceDeclaration || kind == ast.KindJsxAttribute || kind == ast.KindMethodDeclaration || kind == ast.KindMethodSignature || kind == ast.KindModuleDeclaration || kind == ast.KindNamespaceExportDeclaration || kind == ast.KindNamespaceImport || kind == ast.KindNamespaceExport || kind == ast.KindParameter || kind == ast.KindPropertyAssignment || kind == ast.KindPropertyDeclaration || kind == ast.KindPropertySignature || kind == ast.KindSetAccessor || kind == ast.KindShorthandPropertyAssignment || kind == ast.KindTypeAliasDeclaration || kind == ast.KindTypeParameter || kind == ast.KindVariableDeclaration || kind == ast.KindJSDocTypedefTag || kind == ast.KindJSDocCallbackTag || kind == ast.KindJSDocPropertyTag || kind == ast.KindNamedTupleMember
}

func isDeclarationStatementKind(kind SyntaxKind) bool {
	return kind == ast.KindFunctionDeclaration || kind == ast.KindMissingDeclaration || kind == ast.KindClassDeclaration || kind == ast.KindInterfaceDeclaration || kind == ast.KindTypeAliasDeclaration || kind == ast.KindEnumDeclaration || kind == ast.KindModuleDeclaration || kind == ast.KindImportDeclaration || kind == ast.KindImportEqualsDeclaration || kind == ast.KindExportDeclaration || kind == ast.KindExportAssignment || kind == ast.KindNamespaceExportDeclaration
}

func isStatementKindButNotDeclarationKind(kind SyntaxKind) bool {
	return kind == ast.KindBreakStatement || kind == ast.KindContinueStatement || kind == ast.KindDebuggerStatement || kind == ast.KindDoStatement || kind == ast.KindExpressionStatement || kind == ast.KindEmptyStatement || kind == ast.KindForInStatement || kind == ast.KindForOfStatement || kind == ast.KindForStatement || kind == ast.KindIfStatement || kind == ast.KindLabeledStatement || kind == ast.KindReturnStatement || kind == ast.KindSwitchStatement || kind == ast.KindThrowStatement || kind == ast.KindTryStatement || kind == ast.KindVariableStatement || kind == ast.KindWhileStatement || kind == ast.KindWithStatement || kind == ast.KindNotEmittedStatement
}

/** @internal */

func isDeclaration(node *ast.Node) bool {
	if node.kind == ast.KindTypeParameter {
		return (node.parent && node.parent.kind != ast.KindJSDocTemplateTag) || isInJSFile(node)
	}

	return isDeclarationKind(node.kind)
}

func isDeclarationStatement(node *ast.Node) bool {
	return isDeclarationStatementKind(node.kind)
}

/**
 * Determines whether the node is a statement that is not also a declaration
 *
 * @internal
 */

func isStatementButNotDeclaration(node *ast.Node) bool {
	return isStatementKindButNotDeclarationKind(node.kind)
}

func isStatement(node *ast.Node) bool {
	kind := node.kind
	return isStatementKindButNotDeclarationKind(kind) || isDeclarationStatementKind(kind) || isBlockStatement(node)
}

func isBlockStatement(node *ast.Node) bool {
	if node.kind != ast.KindBlock {
		return false
	}
	if node.parent != nil {
		if node.parent.kind == ast.KindTryStatement || node.parent.kind == ast.KindCatchClause {
			return false
		}
	}
	return !isFunctionBlock(node)
}

// TODO(jakebailey): should we be exporting this function and not isStatement?

func isStatementOrBlock(node *ast.Node) bool {
	kind := node.kind
	return isStatementKindButNotDeclarationKind(kind) || isDeclarationStatementKind(kind) || kind == ast.KindBlock
}

// Module references

func isModuleReference(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindExternalModuleReference || kind == ast.KindQualifiedName || kind == ast.KindIdentifier
}

// JSX

func isJsxTagNameExpression(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindThisKeyword || kind == ast.KindIdentifier || kind == ast.KindPropertyAccessExpression || kind == ast.KindJsxNamespacedName
}

func isJsxChild(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindJsxElement || kind == ast.KindJsxExpression || kind == ast.KindJsxSelfClosingElement || kind == ast.KindJsxText || kind == ast.KindJsxFragment
}

func isJsxAttributeLike(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindJsxAttribute || kind == ast.KindJsxSpreadAttribute
}

func isStringLiteralOrJsxExpression(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindStringLiteral || kind == ast.KindJsxExpression
}

func isJsxOpeningLikeElement(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindJsxOpeningElement || kind == ast.KindJsxSelfClosingElement
}

// Clauses

func isCaseOrDefaultClause(node *ast.Node) bool {
	kind := node.kind
	return kind == ast.KindCaseClause || kind == ast.KindDefaultClause
}

// JSDoc

func isJSDocNode(node *ast.Node) bool {
	return node.kind >= ast.KindFirstJSDocNode && node.kind <= ast.KindLastJSDocNode
}

/** True if node is of a kind that may contain comment text. */

func isJSDocCommentContainingNode(node *ast.Node) bool {
	return node.kind == ast.KindJSDoc || node.kind == ast.KindJSDocNamepathType || node.kind == ast.KindJSDocText || isJSDocLinkLike(node) || isJSDocTag(node) || isJSDocTypeLiteral(node) || isJSDocSignature(node)
}

// TODO: determine what this does before making it public.

func isJSDocTag(node *ast.Node) bool {
	return node.kind >= ast.KindFirstJSDocTagNode && node.kind <= ast.KindLastJSDocTagNode
}

func isSetAccessor(node *ast.Node) bool {
	return node.kind == ast.KindSetAccessor
}

func isGetAccessor(node *ast.Node) bool {
	return node.kind == ast.KindGetAccessor
}

/**
 * True if has jsdoc nodes attached to it.
 *
 * @internal
 */
// TODO: GH#19856 Would like to return `node is Node & { jsDoc: JSDoc[] }` but it causes long compile times

func hasJSDocNodes(node *ast.Node) bool {
	if !canHaveJSDoc(node) {
		return false
	}

	TODO_IDENTIFIER := node.AsJSDocContainer()
	return jsDoc != nil && jsDoc.length > 0
}

/**
 * True if has type node attached to it.
 *
 * @internal
 */

func hasType(node *ast.Node) bool {
	return (node.AsHasType()).type_ != nil
}

/**
 * True if has initializer node attached to it.
 *
 * @internal
 */

func hasInitializer(node *ast.Node) bool {
	return (node.AsHasInitializer()).initializer != nil
}

/** True if has initializer node attached to it. */

func hasOnlyExpressionInitializer(node *ast.Node) bool {
	switch node.kind {
	case ast.KindVariableDeclaration,
		ast.KindParameter,
		ast.KindBindingElement,
		ast.KindPropertyDeclaration,
		ast.KindPropertyAssignment,
		ast.KindEnumMember:
		return true
	default:
		return false
	}
}

func isObjectLiteralElement(node *ast.Node) bool {
	return node.kind == ast.KindJsxAttribute || node.kind == ast.KindJsxSpreadAttribute || isObjectLiteralElementLike(node)
}

/** @internal */

func isTypeReferenceType(node *ast.Node) bool {
	return node.kind == ast.KindTypeReference || node.kind == ast.KindExpressionWithTypeArguments
}

var MAX_SMI_X86 = 0x3fff_ffff

/** @internal */

func guessIndentation(lines []string) *number {
	indentation := MAX_SMI_X86
	for _, line := range lines {
		if line.length == 0 {
			continue
		}
		i := 0
		for ; i < line.length && i < indentation; i++ {
			if !isWhiteSpaceLike(line.charCodeAt(i)) {
				break
			}
		}
		if i < indentation {
			indentation = i
		}
		if indentation == 0 {
			return 0
		}
	}
	if indentation == MAX_SMI_X86 {
		return nil
	} else {
		return indentation
	}
}

func isStringLiteralLike(node Union[*ast.Node, FileReference]) bool {
	return (node.AsNode()).kind == ast.KindStringLiteral || (node.AsNode()).kind == ast.KindNoSubstitutionTemplateLiteral
}

func isJSDocLinkLike(node *ast.Node) bool {
	return node.kind == ast.KindJSDocLink || node.kind == ast.KindJSDocLinkCode || node.kind == ast.KindJSDocLinkPlain
}

func hasRestParameter(s Union[SignatureDeclaration, JSDocSignature]) bool {
	last := lastOrUndefined(s.parameters)
	return last != nil && isRestParameter(last)
}

func isRestParameter(node Union[ParameterDeclaration, JSDocParameterTag]) bool {
	var t *TypeNode
	if isJSDocParameterTag(node) {
		t = (node.typeExpression && node.typeExpression.type_)
	} else {
		t = node.type_
	}
	return (node.AsParameterDeclaration()).dotDotDotToken != nil || t && t.kind == ast.KindJSDocVariadicType
}

func hasInternalAnnotation(range_ CommentRange, sourceFile SourceFile) bool {
	comment := sourceFile.text.substring(range_.pos, range_.end)
	return comment.includes("@internal")
}

func isInternalDeclaration(node *ast.Node, sourceFile SourceFile) bool {
	if sourceFile == nil {
		sourceFile = getSourceFileOfNode(node)
	}
	parseTreeNode := getParseTreeNode(node)
	if parseTreeNode != nil && parseTreeNode.kind == ast.KindParameter {
		paramIdx := (parseTreeNode.parent.AsSignatureDeclaration()).parameters.indexOf(parseTreeNode.AsParameterDeclaration())
		var previousSibling *ParameterDeclaration
		if paramIdx > 0 {
			previousSibling = (parseTreeNode.parent.AsSignatureDeclaration()).parameters[paramIdx-1]
		} else {
			previousSibling = nil
		}
		text := sourceFile.text
		var commentRanges *[]CommentRange
		if previousSibling != nil {
			commentRanges = concatenate(getTrailingCommentRanges(text, skipTrivia(text, previousSibling.end+1, false /*stopAfterLineBreak*/, true /*stopAtComments*/)), getLeadingCommentRanges(text, node.pos))
		} else {
			commentRanges = getTrailingCommentRanges(text, skipTrivia(text, node.pos, false /*stopAfterLineBreak*/, true /*stopAtComments*/))
		}
		return some(commentRanges) && hasInternalAnnotation(last(commentRanges), sourceFile)
	}
	leadingCommentRanges := parseTreeNode && getLeadingCommentRangesOfNode(parseTreeNode, sourceFile)
	return forEach(leadingCommentRanges, func(range_ CommentRange) bool {
		return hasInternalAnnotation(range_, sourceFile)
	})
}
