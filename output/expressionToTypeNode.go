// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

type SyntacticTypeNodeBuilder struct {
	strictNullChecks bool
}

/** @internal */

func createSyntacticTypeNodeBuilder(options CompilerOptions, resolver SyntacticTypeNodeBuilderResolver) SyntacticNodeBuilder {
	tc.strictNullChecks = getStrictOptionValue(options, "strictNullChecks")

	return SyntacticNodeBuilder{
		typeFromExpression:              typeFromExpression,
		serializeTypeOfDeclaration:      serializeTypeOfDeclaration,
		serializeReturnTypeForSignature: serializeReturnTypeForSignature,
		serializeTypeOfExpression:       serializeTypeOfExpression,
	}
}

func (stnb *SyntacticTypeNodeBuilder) serializeExistingTypeAnnotation(t *TypeNode, addUndefined bool) *true {
	if t != nil && (!addUndefined || (t && stnb.canAddUndefined(t))) {
		return true
	} else {
		return nil
	}
}

func (stnb *SyntacticTypeNodeBuilder) serializeTypeOfExpression(expr Expression, context SyntacticTypeNodeBuilderContext, addUndefined bool, preserveLiterals bool) bool {
	return ifNotNilElse(stnb.typeFromExpression(expr, context, false /*isConstContext*/, addUndefined, preserveLiterals), stnb.inferExpressionType(expr, context))
}

func (stnb *SyntacticTypeNodeBuilder) serializeTypeOfDeclaration(node HasInferredType, context SyntacticTypeNodeBuilderContext) *bool {
	switch node.Kind {
	case ast.KindPropertySignature:
		return stnb.serializeExistingTypeAnnotation(getEffectiveTypeAnnotationNode(node))
	case ast.KindParameter:
		return stnb.typeFromParameter(node, context)
	case ast.KindVariableDeclaration:
		return stnb.typeFromVariable(node, context)
	case ast.KindPropertyDeclaration:
		return stnb.typeFromProperty(node, context)
	case ast.KindBindingElement:
		return stnb.inferTypeOfDeclaration(node, context)
	case ast.KindExportAssignment:
		return stnb.serializeTypeOfExpression(node.Expression, context, nil /*addUndefined*/, true /*preserveLiterals*/)
	case ast.KindPropertyAccessExpression,
		ast.KindElementAccessExpression,
		ast.KindBinaryExpression:
		return stnb.serializeExistingTypeAnnotation(getEffectiveTypeAnnotationNode(node)) || stnb.inferTypeOfDeclaration(node, context)
	case ast.KindPropertyAssignment:
		return stnb.typeFromExpression(node.Initializer, context) || stnb.inferTypeOfDeclaration(node, context)
	default:
		Debug.assertNever(node, __TEMPLATE__("Node needs to be an inferrable node, found ", Debug.formatSyntaxKind(node.AsNode().Kind)))
	}
}

func (stnb *SyntacticTypeNodeBuilder) serializeReturnTypeForSignature(node Union[SignatureDeclaration, JSDocSignature], context SyntacticTypeNodeBuilderContext) *bool {
	switch node.Kind {
	case ast.KindGetAccessor:
		return stnb.typeFromAccessor(node, context)
	case ast.KindMethodDeclaration,
		ast.KindFunctionDeclaration,
		ast.KindConstructSignature,
		ast.KindMethodSignature,
		ast.KindCallSignature,
		ast.KindConstructor,
		ast.KindSetAccessor,
		ast.KindIndexSignature,
		ast.KindFunctionType,
		ast.KindConstructorType,
		ast.KindFunctionExpression,
		ast.KindArrowFunction,
		ast.KindJSDocFunctionType,
		ast.KindJSDocSignature:
		return stnb.createReturnFromSignature(node, context)
	default:
		Debug.assertNever(node, __TEMPLATE__("Node needs to be an inferrable node, found ", Debug.formatSyntaxKind(node.AsNode().Kind)))
	}
}

func (stnb *SyntacticTypeNodeBuilder) getTypeAnnotationFromAccessor(accessor AccessorDeclaration) *TypeNode {
	if accessor {
		switch {
		case accessor.Kind == ast.KindGetAccessor:
			return getEffectiveReturnTypeNode(accessor)
		case accessor.Parameters.length > 0:
			return getEffectiveTypeAnnotationNode(accessor.Parameters[0])
		default:
			return nil
		}
	}
}

func (stnb *SyntacticTypeNodeBuilder) getTypeAnnotationFromAllAccessorDeclarations(node AccessorDeclaration, accessors AllAccessorDeclarations) *TypeNode {
	accessorType := stnb.getTypeAnnotationFromAccessor(node)
	if accessorType == nil && node != accessors.firstAccessor {
		accessorType = stnb.getTypeAnnotationFromAccessor(accessors.firstAccessor)
	}
	if accessorType == nil && accessors.secondAccessor != nil && node != accessors.secondAccessor {
		accessorType = stnb.getTypeAnnotationFromAccessor(accessors.secondAccessor)
	}
	return accessorType
}

func (stnb *SyntacticTypeNodeBuilder) typeFromAccessor(node AccessorDeclaration, context SyntacticTypeNodeBuilderContext) *bool {
	accessorDeclarations := resolver.getAllAccessorDeclarations(node)
	accessorType := stnb.getTypeAnnotationFromAllAccessorDeclarations(node, accessorDeclarations)
	if accessorType != nil {
		return stnb.serializeExistingTypeAnnotation(accessorType)
	}
	if accessorDeclarations.getAccessor != nil {
		return stnb.createReturnFromSignature(accessorDeclarations.getAccessor, context)
	}
	return false
}

func (stnb *SyntacticTypeNodeBuilder) typeFromVariable(node VariableDeclaration, context SyntacticTypeNodeBuilderContext) *bool {
	declaredType := getEffectiveTypeAnnotationNode(node)
	if declaredType != nil {
		return stnb.serializeExistingTypeAnnotation(declaredType)
	}
	var resultType TODO
	if node.Initializer != nil {
		if !resolver.isExpandoFunctionDeclaration(node) {
			resultType = stnb.typeFromExpression(node.Initializer, context, nil /*isConstContext*/, nil /*requiresAddingUndefined*/, isVarConstLike(node))
		}
	}
	return ifNotNilElse(resultType, stnb.inferTypeOfDeclaration(node, context))
}

func (stnb *SyntacticTypeNodeBuilder) typeFromParameter(node ParameterDeclaration, context SyntacticTypeNodeBuilderContext) *bool {
	parent := node.Parent
	if parent.Kind == ast.KindSetAccessor {
		return stnb.typeFromAccessor(parent, context)
	}
	declaredType := getEffectiveTypeAnnotationNode(node)
	addUndefined := resolver.requiresAddingImplicitUndefined(node, context.enclosingDeclaration)
	var resultType TODO
	if declaredType != nil {
		resultType = stnb.serializeExistingTypeAnnotation(declaredType, addUndefined)
	} else {
		if node.Initializer != nil && isIdentifier(node.Name) {
			resultType = stnb.typeFromExpression(node.Initializer, context, nil /*isConstContext*/, addUndefined)
		}
	}
	return ifNotNilElse(resultType, stnb.inferTypeOfDeclaration(node, context))
}

func (stnb *SyntacticTypeNodeBuilder) typeFromProperty(node PropertyDeclaration, context SyntacticTypeNodeBuilderContext) *bool {
	declaredType := getEffectiveTypeAnnotationNode(node)
	if declaredType != nil {
		return stnb.serializeExistingTypeAnnotation(declaredType)
	}
	var resultType TODO
	if node.Initializer != nil {
		isReadonly := isDeclarationReadonly(node)
		resultType = stnb.typeFromExpression(node.Initializer, context, nil /*isConstContext*/, nil /*requiresAddingUndefined*/, isReadonly)
	}
	return ifNotNilElse(resultType, stnb.inferTypeOfDeclaration(node, context))
}

func (stnb *SyntacticTypeNodeBuilder) inferTypeOfDeclaration(node Union[PropertyAssignment, PropertyAccessExpression, BinaryExpression, ElementAccessExpression, VariableDeclaration, ParameterDeclaration, BindingElement, PropertyDeclaration, PropertySignature, ExportAssignment], context SyntacticTypeNodeBuilderContext) bool {
	context.tracker.reportInferenceFallback(node)
	return false
}

func (stnb *SyntacticTypeNodeBuilder) inferExpressionType(node Expression, context SyntacticTypeNodeBuilderContext) bool {
	context.tracker.reportInferenceFallback(node)
	return false
}

func (stnb *SyntacticTypeNodeBuilder) inferReturnTypeOfSignatureSignature(node Union[SignatureDeclaration, JSDocSignature], context SyntacticTypeNodeBuilderContext) bool {
	context.tracker.reportInferenceFallback(node)
	return false
}

func (stnb *SyntacticTypeNodeBuilder) inferAccessorType(node Union[GetAccessorDeclaration, SetAccessorDeclaration], allAccessors AllAccessorDeclarations, context SyntacticTypeNodeBuilderContext) bool {
	if node.Kind == ast.KindGetAccessor {
		return stnb.createReturnFromSignature(node, context)
	} else {
		context.tracker.reportInferenceFallback(node)
		return false
	}
}

func (stnb *SyntacticTypeNodeBuilder) typeFromTypeAssertion(expression Expression, t TypeNode, context SyntacticTypeNodeBuilderContext, requiresAddingUndefined bool) *bool {
	if isConstTypeReference(t) {
		return stnb.typeFromExpression(expression, context, true /*isConstContext*/, requiresAddingUndefined)
	}
	if requiresAddingUndefined && !stnb.canAddUndefined(t) {
		context.tracker.reportInferenceFallback(t)
	}
	return stnb.serializeExistingTypeAnnotation(t)
}

func (stnb *SyntacticTypeNodeBuilder) typeFromExpression(node Expression, context SyntacticTypeNodeBuilderContext, isConstContext bool /*  = false */, requiresAddingUndefined bool /*  = false */, preserveLiterals bool /*  = false */) *bool {
	switch node.Kind {
	case ast.KindParenthesizedExpression:
		if isJSDocTypeAssertion(node) {
			return stnb.typeFromTypeAssertion(node.Expression, getJSDocTypeAssertionType(node), context, requiresAddingUndefined)
		}
		return stnb.typeFromExpression(node.AsParenthesizedExpression().Expression, context, isConstContext, requiresAddingUndefined)
	case ast.KindIdentifier:
		if resolver.isUndefinedIdentifierExpression(node.AsIdentifier()) {
			return true
		}
	case ast.KindNullKeyword:
		return true
	case ast.KindArrowFunction,
		ast.KindFunctionExpression:
		return stnb.typeFromFunctionLikeExpression(node /* as ArrowFunction | FunctionExpression */, context)
	case ast.KindTypeAssertionExpression,
		ast.KindAsExpression:
		asExpression := node /* as AsExpression | TypeAssertion */
		return stnb.typeFromTypeAssertion(asExpression.Expression, asExpression.Type_, context, requiresAddingUndefined)
	case ast.KindPrefixUnaryExpression:
		unaryExpression := node.AsPrefixUnaryExpression()
		if isPrimitiveLiteralValue(unaryExpression) {
			if unaryExpression.Operand.Kind == ast.KindBigIntLiteral {
				return stnb.typeFromPrimitiveLiteral()
			}
			if unaryExpression.Operand.Kind == ast.KindNumericLiteral {
				return stnb.typeFromPrimitiveLiteral()
			}
		}
	case ast.KindNumericLiteral:
		return stnb.typeFromPrimitiveLiteral()
	case ast.KindTemplateExpression:
		if !isConstContext && !preserveLiterals {
			return true
		}
	case ast.KindNoSubstitutionTemplateLiteral,
		ast.KindStringLiteral:
		return stnb.typeFromPrimitiveLiteral()
	case ast.KindBigIntLiteral:
		return stnb.typeFromPrimitiveLiteral()
	case ast.KindTrueKeyword,
		ast.KindFalseKeyword:
		return stnb.typeFromPrimitiveLiteral()
	case ast.KindArrayLiteralExpression:
		return stnb.typeFromArrayLiteral(node.AsArrayLiteralExpression(), context, isConstContext)
	case ast.KindObjectLiteralExpression:
		return stnb.typeFromObjectLiteral(node.AsObjectLiteralExpression(), context, isConstContext)
	case ast.KindClassExpression:
		return stnb.inferExpressionType(node.AsClassExpression(), context)
	}
	return nil
}

func (stnb *SyntacticTypeNodeBuilder) typeFromFunctionLikeExpression(fnNode Union[FunctionExpression, ArrowFunction], context SyntacticTypeNodeBuilderContext) bool {
	returnType := ifNotNilElse(stnb.serializeExistingTypeAnnotation(fnNode.Type_), stnb.createReturnFromSignature(fnNode, context))
	typeParameters := stnb.reuseTypeParameters(fnNode.TypeParameters)
	parameters := fnNode.Parameters.every(func(p ParameterDeclaration) *bool {
		return stnb.ensureParameter(p, context)
	})
	return returnType && typeParameters && parameters
}

func (stnb *SyntacticTypeNodeBuilder) canGetTypeFromArrayLiteral(arrayLiteral ArrayLiteralExpression, context SyntacticTypeNodeBuilderContext, isConstContext bool) bool {
	if !isConstContext {
		context.tracker.reportInferenceFallback(arrayLiteral)
		return false
	}
	for _, element := range arrayLiteral.Elements {
		if element.Kind == ast.KindSpreadElement {
			context.tracker.reportInferenceFallback(element)
			return false
		}
	}
	return true
}

func (stnb *SyntacticTypeNodeBuilder) typeFromArrayLiteral(arrayLiteral ArrayLiteralExpression, context SyntacticTypeNodeBuilderContext, isConstContext bool) bool {
	if !stnb.canGetTypeFromArrayLiteral(arrayLiteral, context, isConstContext) {
		return false
	}

	canInferArray := true
	for _, element := range arrayLiteral.Elements {
		Debug.assert(element.Kind != ast.KindSpreadElement)
		if element.Kind != ast.KindOmittedExpression {
			canInferArray = (ifNotNilElse(stnb.typeFromExpression(element, context, isConstContext), stnb.inferExpressionType(element, context))) && canInferArray
		}
	}
	return true
}

func (stnb *SyntacticTypeNodeBuilder) canGetTypeFromObjectLiteral(objectLiteral ObjectLiteralExpression, context SyntacticTypeNodeBuilderContext) bool {
	result := true
	for _, prop := range objectLiteral.Properties {
		if prop.Flags&ast.NodeFlagsThisNodeHasError != 0 {
			result = false
			break
			// Bail if parse errors
		}
		if prop.Kind == ast.KindShorthandPropertyAssignment || prop.Kind == ast.KindSpreadAssignment {
			context.tracker.reportInferenceFallback(prop)
			result = false
		} else if prop.Name.Flags&ast.NodeFlagsThisNodeHasError != 0 {
			result = false
			break
			// Bail if parse errors
		} else if prop.Name.Kind == ast.KindPrivateIdentifier {
			// Not valid in object literals but the compiler will complain about this, we just ignore it here.
			result = false
		} else if prop.Name.Kind == ast.KindComputedPropertyName {
			expression := prop.Name.Expression
			if !isPrimitiveLiteralValue(expression, false /*includeBigInt*/) && !resolver.isDefinitelyReferenceToGlobalSymbolObject(expression) {
				context.tracker.reportInferenceFallback(prop.Name)
				result = false
			}
		}
	}
	return result
}

func (stnb *SyntacticTypeNodeBuilder) typeFromObjectLiteral(objectLiteral ObjectLiteralExpression, context SyntacticTypeNodeBuilderContext, isConstContext bool) bool {
	if !stnb.canGetTypeFromObjectLiteral(objectLiteral, context) {
		return false
	}

	canInferObjectLiteral := true
	for _, prop := range objectLiteral.Properties {
		Debug.assert(!isShorthandPropertyAssignment(prop) && !isSpreadAssignment(prop))

		name := prop.Name
		switch prop.Kind {
		case ast.KindMethodDeclaration:
			canInferObjectLiteral = stnb.typeFromObjectLiteralMethod(prop, name, context) && canInferObjectLiteral
		case ast.KindPropertyAssignment:
			canInferObjectLiteral = stnb.typeFromObjectLiteralPropertyAssignment(prop, name, context, isConstContext) && canInferObjectLiteral
		case ast.KindSetAccessor,
			ast.KindGetAccessor:
			canInferObjectLiteral = stnb.typeFromObjectLiteralAccessor(prop, name, context) && canInferObjectLiteral
		}
	}

	return canInferObjectLiteral
}

func (stnb *SyntacticTypeNodeBuilder) typeFromObjectLiteralPropertyAssignment(prop PropertyAssignment, name PropertyName, context SyntacticTypeNodeBuilderContext, isConstContext bool) bool {
	return ifNotNilElse(stnb.typeFromExpression(prop.Initializer, context, isConstContext), stnb.inferTypeOfDeclaration(prop, context))
}

func (stnb *SyntacticTypeNodeBuilder) ensureParameter(p ParameterDeclaration, context SyntacticTypeNodeBuilderContext) *bool {
	return stnb.typeFromParameter(p, context)
}

func (stnb *SyntacticTypeNodeBuilder) reuseTypeParameters(typeParameters *NodeArray[TypeParameterDeclaration]) bool {
	// TODO: We will probably need to add a fake scopes for the signature (to hold the type parameters and the parameter)
	// For now this is good enough since the new serialization is used for Nodes in the same context.
	return ifNotNilElse(typeParameters. /* ? */ every(func(tp TypeParameterDeclaration) *true {
		return stnb.serializeExistingTypeAnnotation(tp.Constraint) && stnb.serializeExistingTypeAnnotation(tp.Default_)
	}), true)
}

func (stnb *SyntacticTypeNodeBuilder) typeFromObjectLiteralMethod(method MethodDeclaration, name PropertyName, context SyntacticTypeNodeBuilderContext) bool {
	returnType := stnb.createReturnFromSignature(method, context)
	typeParameters := stnb.reuseTypeParameters(method.TypeParameters)
	parameters := method.Parameters.every(func(p ParameterDeclaration) *bool {
		return stnb.ensureParameter(p, context)
	})
	return returnType && typeParameters && parameters
}

func (stnb *SyntacticTypeNodeBuilder) typeFromObjectLiteralAccessor(accessor Union[GetAccessorDeclaration, SetAccessorDeclaration], name PropertyName, context SyntacticTypeNodeBuilderContext) *bool {
	allAccessors := resolver.getAllAccessorDeclarations(accessor)
	getAccessorType := allAccessors.getAccessor && stnb.getTypeAnnotationFromAccessor(allAccessors.getAccessor)
	setAccessorType := allAccessors.setAccessor && stnb.getTypeAnnotationFromAccessor(allAccessors.setAccessor)
	// We have types for both accessors, we can't know if they are the same type so we keep both accessors
	if getAccessorType != nil && setAccessorType != nil {
		parameters := accessor.Parameters.every(func(p ParameterDeclaration) *bool {
			return stnb.ensureParameter(p, context)
		})

		if isGetAccessor(accessor) {
			return parameters && stnb.serializeExistingTypeAnnotation(getAccessorType)
		} else {
			return parameters
		}
	} else if allAccessors.firstAccessor == accessor {
		foundType := ifNotNilElse(getAccessorType, setAccessorType)
		var propertyType *bool
		if foundType != nil {
			propertyType = stnb.serializeExistingTypeAnnotation(foundType)
		} else {
			propertyType = stnb.inferAccessorType(accessor, allAccessors, context)
		}

		return propertyType
	}
	return false
}

func (stnb *SyntacticTypeNodeBuilder) typeFromPrimitiveLiteral() bool {
	return true
}

func (stnb *SyntacticTypeNodeBuilder) canAddUndefined(node TypeNode) bool {
	if !stnb.strictNullChecks {
		return true
	}
	if isKeyword(node.Kind) || node.Kind == ast.KindLiteralType || node.Kind == ast.KindFunctionType || node.Kind == ast.KindConstructorType || node.Kind == ast.KindArrayType || node.Kind == ast.KindTupleType || node.Kind == ast.KindTypeLiteral || node.Kind == ast.KindTemplateLiteralType || node.Kind == ast.KindThisType {
		return true
	}
	if node.Kind == ast.KindParenthesizedType {
		return stnb.canAddUndefined(node.AsParenthesizedTypeNode().Type_)
	}
	if node.Kind == ast.KindUnionType || node.Kind == ast.KindIntersectionType {
		return (node /* as UnionTypeNode | IntersectionTypeNode */).Types.every(stnb.canAddUndefined)
	}
	return false
}

func (stnb *SyntacticTypeNodeBuilder) createReturnFromSignature(fn Union[SignatureDeclaration, JSDocSignature], context SyntacticTypeNodeBuilderContext) bool {
	var returnType TODO
	returnTypeNode := getEffectiveReturnTypeNode(fn)
	if returnTypeNode != nil {
		returnType = stnb.serializeExistingTypeAnnotation(returnTypeNode)
	}
	if !returnType && isValueSignatureDeclaration(fn) {
		returnType = stnb.typeFromSingleReturnExpression(fn, context)
	}
	return ifNotNilElse(returnType, stnb.inferReturnTypeOfSignatureSignature(fn, context))
}

func (stnb *SyntacticTypeNodeBuilder) typeFromSingleReturnExpression(declaration *FunctionLikeDeclaration, context SyntacticTypeNodeBuilderContext) *bool {
	var candidateExpr Expression
	if declaration != nil && !nodeIsMissing(declaration.Body) {
		if getFunctionFlags(declaration)&FunctionFlagsAsyncGenerator != 0 {
			return nil
		}

		body := declaration.Body
		if body != nil && isBlock(body) {
			forEachReturnStatement(body, func(s ReturnStatement) *true {
				if candidateExpr == nil {
					candidateExpr = s.Expression
				} else {
					candidateExpr = nil
					return true
				}
			})
		} else {
			candidateExpr = body
		}
	}
	if candidateExpr != nil {
		return stnb.typeFromExpression(candidateExpr, context)
	}
	return nil
}
