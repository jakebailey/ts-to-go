// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

type Binder struct {
	file                   SourceFile
	options                CompilerOptions
	languageVersion        ScriptTarget
	parent                 *Node
	container              Union[IsContainer, EntityNameExpression]
	thisParentContainer    Union[IsContainer, EntityNameExpression]
	blockScopeContainer    IsBlockScopedContainer
	lastContainer          HasLocals
	delayedTypeAliases     []Union[JSDocTypedefTag, JSDocCallbackTag, JSDocEnumTag]
	seenThisKeyword        bool
	jsDocImports           []JSDocImportTag
	currentFlow            FlowNode
	currentBreakTarget     *FlowLabel
	currentContinueTarget  *FlowLabel
	currentReturnTarget    *FlowLabel
	currentTrueTarget      *FlowLabel
	currentFalseTarget     *FlowLabel
	currentExceptionTarget *FlowLabel
	preSwitchCaseFlow      *FlowNode
	activeLabelList        *ActiveLabel
	hasExplicitReturn      bool
	hasFlowEffects         bool
	emitFlags              NodeFlags
	inStrictMode           bool
	inAssignmentPattern    bool
	symbolCount            number
	Symbol/* TODO(TS-TO-GO) TypeNode ConstructorType: new (flags: SymbolFlags, name: __String) => Symbol */ any
	classifiableNames       Set[string]
	unreachableFlow         FlowNode
	reportedUnreachableFlow FlowNode
	bindBinaryExpressionFlow/* TODO(TS-TO-GO) inferred type (node: BinaryExpression) => void */ any
}

/** @internal */

type ModuleInstanceState int32

const (
	ModuleInstanceStateNonInstantiated ModuleInstanceState = 0
	ModuleInstanceStateInstantiated    ModuleInstanceState = 1
	ModuleInstanceStateConstEnumOnly   ModuleInstanceState = 2
)

type ActiveLabel struct {
	next           *ActiveLabel
	name           string
	breakTarget    FlowLabel
	continueTarget *FlowLabel
	referenced     bool
}

/** @internal */

func getModuleInstanceState(node ModuleDeclaration, visited Map[number, *ModuleInstanceState]) ModuleInstanceState {
	if node.body != nil && !node.body.parent {
		// getModuleInstanceStateForAliasTarget needs to walk up the parent chain, so parent pointers must be set on this tree already
		setParent(node.body, node)
		setParentRecursive(node.body, false /*incremental*/)
	}
	if node.body != nil {
		return getModuleInstanceStateCached(node.body, visited)
	} else {
		return ModuleInstanceStateInstantiated
	}
}

func getModuleInstanceStateCached(node *Node, visited Map[number, *ModuleInstanceState] /*  = new Map<number, ModuleInstanceState | undefined>() */) ModuleInstanceState {
	nodeId := getNodeId(node)
	if visited.has(nodeId) {
		return visited.get(nodeId) || ModuleInstanceStateNonInstantiated
	}
	visited.set(nodeId, nil)
	result := getModuleInstanceStateWorker(node, visited)
	visited.set(nodeId, result)
	return result
}

func getModuleInstanceStateWorker(node *Node, visited Map[number, *ModuleInstanceState]) ModuleInstanceState {
	// A module is uninstantiated if it contains only
	switch node.kind {
	case SyntaxKindInterfaceDeclaration,
		SyntaxKindTypeAliasDeclaration:
		return ModuleInstanceStateNonInstantiated
		// 2. const enum declarations
	case SyntaxKindEnumDeclaration:
		if isEnumConst(node.AsEnumDeclaration()) {
			return ModuleInstanceStateConstEnumOnly
		}
		// 3. non-exported import declarations
	case SyntaxKindImportDeclaration,
		SyntaxKindImportEqualsDeclaration:
		if !(hasSyntacticModifier(node, ModifierFlagsExport)) {
			return ModuleInstanceStateNonInstantiated
		}
		// 4. Export alias declarations pointing at only uninstantiated modules or things uninstantiated modules contain
	case SyntaxKindExportDeclaration:
		exportDeclaration := node.AsExportDeclaration()
		if !(exportDeclaration.moduleSpecifier != nil) && exportDeclaration.exportClause != nil && exportDeclaration.exportClause.kind == SyntaxKindNamedExports {
			state := ModuleInstanceStateNonInstantiated
			for _, specifier := range exportDeclaration.exportClause.elements {
				specifierState := getModuleInstanceStateForAliasTarget(specifier, visited)
				if specifierState > state {
					state = specifierState
				}
				if state == ModuleInstanceStateInstantiated {
					return state
				}
			}
			return state
		}
		// 5. other uninstantiated module declarations.
	case SyntaxKindModuleBlock:
		state := ModuleInstanceStateNonInstantiated
		forEachChild(node, func(n *Node) *true {
			childState := getModuleInstanceStateCached(n, visited)
			switch childState {
			case ModuleInstanceStateNonInstantiated:
				// child is non-instantiated - continue searching
				return
			case ModuleInstanceStateConstEnumOnly:
				// child is const enum only - record state and continue searching
				state = ModuleInstanceStateConstEnumOnly
				return
			case ModuleInstanceStateInstantiated:
				// child is instantiated - record state and stop
				state = ModuleInstanceStateInstantiated
				return true
			default:
				Debug.assertNever(childState)
			}
		})
		return state
	case SyntaxKindModuleDeclaration:
		return getModuleInstanceState(node.AsModuleDeclaration(), visited)
	case SyntaxKindIdentifier:
		// Only jsdoc typedef definition can exist in jsdoc namespace, and it should
		// be considered the same as type alias
		if node.flags&NodeFlagsIdentifierIsInJSDocNamespace != 0 {
			return ModuleInstanceStateNonInstantiated
		}
	}
	return ModuleInstanceStateInstantiated
}

func getModuleInstanceStateForAliasTarget(specifier ExportSpecifier, visited Map[number, *ModuleInstanceState]) ModuleInstanceState {
	name := specifier.propertyName || specifier.name
	if name.kind != SyntaxKindIdentifier {
		return ModuleInstanceStateInstantiated
		// Skip for invalid syntax like this: export { "x" }
	}
	var p *Node = specifier.parent
	for p {
		if isBlock(p) || isModuleBlock(p) || isSourceFile(p) {
			statements := p.statements
			var found *ModuleInstanceState
			for _, statement := range statements {
				if nodeHasName(statement, name) {
					if !statement.parent {
						setParent(statement, p)
						setParentRecursive(statement, false /*incremental*/)
					}
					state := getModuleInstanceStateCached(statement, visited)
					if found == nil || state > found {
						found = state
					}
					if found == ModuleInstanceStateInstantiated {
						return found
					}
					if statement.kind == SyntaxKindImportEqualsDeclaration {
						// Treat re-exports of import aliases as instantiated,
						// since they're ambiguous. This is consistent with
						// `export import x = mod.x` being treated as instantiated:
						//   import x = mod.x;
						//   export { x };
						found = ModuleInstanceStateInstantiated
					}
				}
			}
			if found != nil {
				return found
			}
		}
		p = p.parent
	}
	return ModuleInstanceStateInstantiated
	// Couldn't locate, assume could refer to a value
}

/** @internal */

type ContainerFlags int32

const (
	// The current node is not a container, and no container manipulation should happen before
	// recursing into it.
	ContainerFlagsNone ContainerFlags = 0
	// The current node is a container.  It should be set as the current container (and block-
	// container) before recursing into it.  The current node does not have locals.  Examples:
	//
	//      Classes, ObjectLiterals, TypeLiterals, Interfaces...
	ContainerFlagsIsContainer ContainerFlags = 1 << 0
	// The current node is a block-scoped-container.  It should be set as the current block-
	// container before recursing into it.  Examples:
	//
	//      Blocks (when not parented by functions), Catch clauses, For/For-in/For-of statements...
	ContainerFlagsIsBlockScopedContainer ContainerFlags = 1 << 1
	// The current node is the container of a control flow path. The current control flow should
	// be saved and restored, and a new control flow initialized within the container.
	ContainerFlagsIsControlFlowContainer                           ContainerFlags = 1 << 2
	ContainerFlagsIsFunctionLike                                   ContainerFlags = 1 << 3
	ContainerFlagsIsFunctionExpression                             ContainerFlags = 1 << 4
	ContainerFlagsHasLocals                                        ContainerFlags = 1 << 5
	ContainerFlagsIsInterface                                      ContainerFlags = 1 << 6
	ContainerFlagsIsObjectLiteralOrClassExpressionMethodOrAccessor ContainerFlags = 1 << 7
)

/** @internal */

func createFlowNode(flags FlowFlags, node any, antecedent Union[FlowNode, []FlowNode, undefined]) FlowNode {
	return Debug.attachFlowNodeDebugInfo(FlowNode{
		flags:      flags,
		id:         0,
		node:       node,
		antecedent: antecedent,
	}.(FlowNode))
}

var binder = createBinder()

/** @internal */

func bindSourceFile(file SourceFile, options CompilerOptions) {
	performance.mark("beforeBind")
	binder(file, options)
	performance.mark("afterBind")
	performance.measure("Bind", "beforeBind", "afterBind")
}

func createBinder() func(file SourceFile, options CompilerOptions) {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	// Container one level up

	// state used by control flow analysis

	// state used for emit helpers

	// If this file is an external module, then it is automatically in strict-mode according to
	// ES6.  If it is not an external module, then we'll determine if it is in strict mode or
	// not depending on if we see "use strict" in certain places or if we hit a class/namespace
	// or if compiler options contain alwaysStrict.

	// If we are binding an assignment pattern, we will bind certain expressions differently.
	tc.inAssignmentPattern = false

	tc.symbolCount = 0

	tc.unreachableFlow = createFlowNode(FlowFlagsUnreachable, nil /*node*/, nil /*antecedent*/)
	tc.reportedUnreachableFlow = createFlowNode(FlowFlagsUnreachable, nil /*node*/, nil /*antecedent*/)
	tc.bindBinaryExpressionFlow = b.createBindBinaryExpressionFlow()
	/* eslint-enable no-var */

	return b.bindSourceFile
}

/**
 * Inside the binder, we may create a diagnostic for an as-yet unbound node (with potentially no parent pointers, implying no accessible source file)
 * If so, the node _must_ be in the current file (as that's the only way anything could have traversed to it to yield it as the error node)
 * This version of `createDiagnosticForNode` uses the binder's context to account for this, and always yields correct diagnostics even in these situations.
 */

func (b *Binder) createDiagnosticForNode(node *Node, message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
	return createDiagnosticForNodeInSourceFile(getSourceFileOfNode(node) || b.file, node, message, args...)
}

func (b *Binder) bindSourceFile(f SourceFile, opts CompilerOptions) {
	b.file = f
	b.options = opts
	b.languageVersion = getEmitScriptTarget(b.options)
	b.inStrictMode = b.bindInStrictMode(b.file, opts)
	b.classifiableNames = NewSet()
	b.symbolCount = 0

	b.Symbol = objectAllocator.getSymbolConstructor()

	// Attach debugging information if necessary
	Debug.attachFlowNodeDebugInfo(b.unreachableFlow)
	Debug.attachFlowNodeDebugInfo(b.reportedUnreachableFlow)

	if !(b.file.locals != nil) {
		tracing. /* ? */ push(tracing.Phase.Bind, "bindSourceFile", &Args{
			path: b.file.path,
		}, true /*separateBeginAndEnd*/)
		b.bind(b.file)
		tracing. /* ? */ pop()
		b.file.symbolCount = b.symbolCount
		b.file.classifiableNames = b.classifiableNames
		b.delayedBindJSDocTypedefTag()
		b.bindJSDocImports()
	}

	b.file = nil
	b.options = nil
	b.languageVersion = nil
	b.parent = nil
	b.container = nil
	b.thisParentContainer = nil
	b.blockScopeContainer = nil
	b.lastContainer = nil
	b.delayedTypeAliases = nil
	b.jsDocImports = nil
	b.seenThisKeyword = false
	b.currentFlow = nil
	b.currentBreakTarget = nil
	b.currentContinueTarget = nil
	b.currentReturnTarget = nil
	b.currentTrueTarget = nil
	b.currentFalseTarget = nil
	b.currentExceptionTarget = nil
	b.activeLabelList = nil
	b.hasExplicitReturn = false
	b.hasFlowEffects = false
	b.inAssignmentPattern = false
	b.emitFlags = NodeFlagsNone
}

func (b *Binder) bindInStrictMode(file SourceFile, opts CompilerOptions) bool {
	if getStrictOptionValue(opts, "alwaysStrict") && !b.file.isDeclarationFile {
		// bind in strict mode source files with alwaysStrict option
		return true
	} else {
		return b.file.externalModuleIndicator
	}
}

func (b *Binder) createSymbol(flags SymbolFlags, name string) *Symbol {
	b.symbolCount++
	return NewSymbol(flags, name)
}

func (b *Binder) addDeclarationToSymbol(symbol *Symbol, node Declaration, symbolFlags SymbolFlags) {
	symbol.flags |= symbolFlags

	node.symbol = symbol
	symbol.declarations = appendIfUnique(symbol.declarations, node)

	if symbolFlags&(SymbolFlagsClass|SymbolFlagsEnum|SymbolFlagsModule|SymbolFlagsVariable) != 0 && !(symbol.exports != nil) {
		symbol.exports = createSymbolTable()
	}

	if symbolFlags&(SymbolFlagsClass|SymbolFlagsInterface|SymbolFlagsTypeLiteral|SymbolFlagsObjectLiteral) != 0 && !(symbol.members != nil) {
		symbol.members = createSymbolTable()
	}

	// On merge of const enum module with class or function, reset const enum only flag (namespaces will already recalculate)
	if symbol.constEnumOnlyModule && (symbol.flags&(SymbolFlagsFunction|SymbolFlagsClass|SymbolFlagsRegularEnum) != 0) {
		symbol.constEnumOnlyModule = false
	}

	if symbolFlags&SymbolFlagsValue != 0 {
		setValueDeclaration(symbol, node)
	}
}

// Should not be called on a declaration with a computed property name,
// unless it is a well known Symbol.
func (b *Binder) getDeclarationName(node Declaration) *string {
	if node.kind == SyntaxKindExportAssignment {
		if (node.AsExportAssignment()).isExportEquals {
			return InternalSymbolNameExportEquals
		} else {
			return InternalSymbolNameDefault
		}
	}

	name := getNameOfDeclaration(node)
	if name != nil {
		if isAmbientModule(node) {
			moduleName := getTextOfIdentifierOrLiteral(name /* as Identifier | StringLiteral */)
			return (ifElse(isGlobalScopeAugmentation(node.AsModuleDeclaration()), "__global", __TEMPLATE__("\"", moduleName, "\""))).(string)
		}
		if name.kind == SyntaxKindComputedPropertyName {
			nameExpression := name.expression
			// treat computed property names where expression is string/numeric literal as just string/numeric literal
			if isStringOrNumericLiteralLike(nameExpression) {
				return escapeLeadingUnderscores(nameExpression.text)
			}
			if isSignedNumericLiteral(nameExpression) {
				return tokenToString(nameExpression.operator) + nameExpression.operand.text.(string)
			} else {
				Debug.fail("Only computed properties with literal names have declaration names")
			}
		}
		if isPrivateIdentifier(name) {
			// containingClass exists because private names only allowed inside classes
			containingClass := getContainingClass(node)
			if !(containingClass != nil) {
				// we can get here in cases where there is already a parse error.
				return nil
			}
			containingClassSymbol := containingClass.symbol
			return getSymbolNameForPrivateIdentifier(containingClassSymbol, name.escapedText)
		}
		if isJsxNamespacedName(name) {
			return getEscapedTextOfJsxNamespacedName(name)
		}
		if isPropertyNameLiteral(name) {
			return getEscapedTextOfIdentifierOrLiteral(name)
		} else {
			return nil
		}
	}
	switch node.kind {
	case SyntaxKindConstructor:
		return InternalSymbolNameConstructor
	case SyntaxKindFunctionType,
		SyntaxKindCallSignature,
		SyntaxKindJSDocSignature:
		return InternalSymbolNameCall
	case SyntaxKindConstructorType,
		SyntaxKindConstructSignature:
		return InternalSymbolNameNew
	case SyntaxKindIndexSignature:
		return InternalSymbolNameIndex
	case SyntaxKindExportDeclaration:
		return InternalSymbolNameExportStar
	case SyntaxKindSourceFile:
		// json file should behave as
		// module.exports = ...
		return InternalSymbolNameExportEquals
	case SyntaxKindBinaryExpression:
		if getAssignmentDeclarationKind(node.AsBinaryExpression()) == AssignmentDeclarationKindModuleExports {
			// module.exports = ...
			return InternalSymbolNameExportEquals
		}
		Debug.fail("Unknown binary declaration kind")
	case SyntaxKindJSDocFunctionType:
		if isJSDocConstructSignature(node) {
			return InternalSymbolNameNew
		} else {
			return InternalSymbolNameCall
		}
	case SyntaxKindParameter:
		// Parameters with names are handled at the top of this function.  Parameters
		// without names can only come from JSDocFunctionTypes.
		Debug.assert(node.parent.kind == SyntaxKindJSDocFunctionType, "Impossible parameter parent kind", func() string {
			return __TEMPLATE__("parent is: ", Debug.formatSyntaxKind(node.parent.kind), ", expected JSDocFunctionType")
		})
		functionType := node.parent.AsJSDocFunctionType()
		index := functionType.parameters.indexOf(node.AsParameterDeclaration())
		return "arg" + index.(string)
	}
}

func (b *Binder) getDisplayName(node Declaration) string {
	if isNamedDeclaration(node) {
		return declarationNameToString(node.name)
	} else {
		return unescapeLeadingUnderscores(Debug.checkDefined(b.getDeclarationName(node)))
	}
}

/**
 * Declares a Symbol for the node and adds it to symbols. Reports errors for conflicting identifier names.
 * @param symbolTable - The symbol table which node will be added to.
 * @param parent - node's parent declaration.
 * @param node - The declaration to be added to the symbol table
 * @param includes - The SymbolFlags that node has in addition to its declaration type (eg: export, ambient, etc.)
 * @param excludes - The flags which node cannot be declared alongside in a symbol table. Used to report forbidden declarations.
 */

func (b *Binder) declareSymbol(symbolTable SymbolTable, parent *Symbol, node Declaration, includes SymbolFlags, excludes SymbolFlags, isReplaceableByMethod bool, isComputedName bool) *Symbol {
	Debug.assert(isComputedName || !hasDynamicName(node))

	isDefaultExport := hasSyntacticModifier(node, ModifierFlagsDefault) || isExportSpecifier(node) && moduleExportNameIsDefault(node.name)

	// The exported symbol for an export default function/class node is always named "default"
	var name *string
	switch {
	case isComputedName:
		name = InternalSymbolNameComputed
	case isDefaultExport && b.parent != nil:
		name = InternalSymbolNameDefault
	default:
		name = b.getDeclarationName(node)
	}

	var symbol *Symbol
	if name == nil {
		symbol = b.createSymbol(SymbolFlagsNone, InternalSymbolNameMissing)
	} else {
		// Check and see if the symbol table already has a symbol with this name.  If not,
		// create a new symbol with this name and add it to the table.  Note that we don't
		// give the new symbol any flags *yet*.  This ensures that it will not conflict
		// with the 'excludes' flags we pass in.
		//
		// If we do get an existing symbol, see if it conflicts with the new symbol we're
		// creating.  For example, a 'var' symbol and a 'class' symbol will conflict within
		// the same symbol table.  If we have a conflict, report the issue on each
		// declaration we have for this symbol, and then create a new symbol for this
		// declaration.
		//
		// Note that when properties declared in Javascript constructors
		// (marked by isReplaceableByMethod) conflict with another symbol, the property loses.
		// Always. This allows the common Javascript pattern of overwriting a prototype method
		// with an bound instance method of the same type: `this.method = this.method.bind(this)`
		//
		// If we created a new symbol, either because we didn't have a symbol with this name
		// in the symbol table, or we conflicted with an existing symbol, then just add this
		// node as the sole declaration of the new symbol.
		//
		// Otherwise, we'll be merging into a compatible existing symbol (for example when
		// you have multiple 'vars' with the same name in the same container).  In this case
		// just add this node into the declarations list of the symbol.
		symbol = symbolTable.get(name)

		if includes&SymbolFlagsClassifiable != 0 {
			b.classifiableNames.add(name)
		}

		if !(symbol != nil) {
			symbolTable.set(name /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symbol = createSymbol(SymbolFlags.None, name) */, TODO)
			if isReplaceableByMethod {
				symbol.isReplaceableByMethod = true
			}
		} else if isReplaceableByMethod && !symbol.isReplaceableByMethod {
			// A symbol already exists, so don't add this as a declaration.
			return symbol
		} else if symbol.flags&excludes != 0 {
			if symbol.isReplaceableByMethod {
				// Javascript constructor-declared symbols can be discarded in favor of
				// prototype symbols like methods.
				symbolTable.set(name /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symbol = createSymbol(SymbolFlags.None, name) */, TODO)
			} else if !(includes&SymbolFlagsVariable != 0 && symbol.flags&SymbolFlagsAssignment != 0) {
				// Assignment declarations are allowed to merge with variables, no matter what other flags they have.
				if isNamedDeclaration(node) {
					setParent(node.name, node)
				}
				// Report errors every position with duplicate declaration
				// Report errors on previous encountered declarations
				var message any
				if symbol.flags&SymbolFlagsBlockScopedVariable != 0 {
					message = Diagnostics.Cannot_redeclare_block_scoped_variable_0
				} else {
					message = Diagnostics.Duplicate_identifier_0
				}
				messageNeedsName := true

				if symbol.flags&SymbolFlagsEnum != 0 || includes&SymbolFlagsEnum != 0 {
					message = Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
					messageNeedsName = false
				}

				multipleDefaultExports := false
				if length(symbol.declarations) != 0 {
					// If the current node is a default export of some sort, then check if
					// there are any other default exports that we need to error on.
					// We'll know whether we have other default exports depending on if `symbol` already has a declaration list set.
					if isDefaultExport {
						message = Diagnostics.A_module_cannot_have_multiple_default_exports
						messageNeedsName = false
						multipleDefaultExports = true
					} else {
						// This is to properly report an error in the case "export default { }" is after export default of class declaration or function declaration.
						// Error on multiple export default in the following case:
						// 1. multiple export default of class declaration or function declaration by checking NodeFlags.Default
						// 2. multiple export default of export assignment. This one doesn't have NodeFlags.Default on (as export default doesn't considered as modifiers)
						if symbol.declarations != nil && symbol.declarations.length != 0 && (node.kind == SyntaxKindExportAssignment && !(node.AsExportAssignment()).isExportEquals) {
							message = Diagnostics.A_module_cannot_have_multiple_default_exports
							messageNeedsName = false
							multipleDefaultExports = true
						}
					}
				}

				var relatedInformation []DiagnosticRelatedInformation = []never{}
				if isTypeAliasDeclaration(node) && nodeIsMissing(node.type_) && hasSyntacticModifier(node, ModifierFlagsExport) && symbol.flags&(SymbolFlagsAlias|SymbolFlagsType|SymbolFlagsNamespace) != 0 {
					// export type T; - may have meant export type { T }?
					relatedInformation.push(b.createDiagnosticForNode(node, Diagnostics.Did_you_mean_0, __TEMPLATE__("export type { ", unescapeLeadingUnderscores(node.name.escapedText), " }")))
				}

				declarationName := getNameOfDeclaration(node) || node
				forEach(symbol.declarations, func(declaration Declaration, index number) {
					decl := getNameOfDeclaration(declaration) || declaration
					var diag DiagnosticWithLocation
					if messageNeedsName {
						diag = b.createDiagnosticForNode(decl, message, b.getDisplayName(declaration))
					} else {
						diag = b.createDiagnosticForNode(decl, message)
					}
					b.file.bindDiagnostics.push(ifElse(multipleDefaultExports, addRelatedInfo(diag, b.createDiagnosticForNode(declarationName, ifElse(index == 0, Diagnostics.Another_export_default_is_here, Diagnostics.and_here))), diag))
					if multipleDefaultExports {
						relatedInformation.push(b.createDiagnosticForNode(decl, Diagnostics.The_first_export_default_is_here))
					}
				})

				var diag DiagnosticWithLocation
				if messageNeedsName {
					diag = b.createDiagnosticForNode(declarationName, message, b.getDisplayName(node))
				} else {
					diag = b.createDiagnosticForNode(declarationName, message)
				}
				b.file.bindDiagnostics.push(addRelatedInfo(diag, relatedInformation...))

				symbol = b.createSymbol(SymbolFlagsNone, name)
			}
		}
	}

	b.addDeclarationToSymbol(symbol, node, includes)
	if symbol.parent != nil {
		Debug.assert(symbol.parent == b.parent, "Existing symbol parent should match new one")
	} else {
		symbol.parent = b.parent
	}

	return symbol
}

func (b *Binder) declareModuleMember(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) *Symbol {
	hasExportModifier := getCombinedModifierFlags(node)&ModifierFlagsExport != 0 || b.jsdocTreatAsExported(node)
	if symbolFlags&SymbolFlagsAlias != 0 {
		if node.kind == SyntaxKindExportSpecifier || (node.kind == SyntaxKindImportEqualsDeclaration && hasExportModifier) {
			return b.declareSymbol(b.container.symbol.exports, b.container.symbol, node, symbolFlags, symbolExcludes)
		} else {
			Debug.assertNode(b.container, canHaveLocals)
			return b.declareSymbol(b.container.locals, nil /*parent*/, node, symbolFlags, symbolExcludes)
		}
	} else {
		// Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue flag,
		// and an associated export symbol with all the correct flags set on it. There are 2 main reasons:
		//
		//   1. We treat locals and exports of the same name as mutually exclusive within a container.
		//      That means the binder will issue a Duplicate Identifier error if you mix locals and exports
		//      with the same name in the same container.
		//      TODO: Make this a more specific error and decouple it from the exclusion logic.
		//   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,
		//      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way
		//      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.

		// NOTE: Nested ambient modules always should go to to 'locals' table to prevent their automatic merge
		//       during global merging in the checker. Why? The only case when ambient module is permitted inside another module is module augmentation
		//       and this case is specially handled. Module augmentations should only be merged with original module definition
		//       and should never be merged directly with other augmentation, and the latter case would be possible if automatic merge is allowed.
		if isJSDocTypeAlias(node) {
			Debug.assert(isInJSFile(node))
			// We shouldn't add symbols for JSDoc nodes if not in a JS file.
		}
		// We shouldn't add symbols for JSDoc nodes if not in a JS file.
		if !isAmbientModule(node) && (hasExportModifier || b.container.flags&NodeFlagsExportContext != 0) {
			if !canHaveLocals(b.container) || !(b.container.locals != nil) || (hasSyntacticModifier(node, ModifierFlagsDefault) && !b.getDeclarationName(node)) {
				return b.declareSymbol(b.container.symbol.exports, b.container.symbol, node, symbolFlags, symbolExcludes)
				// No local symbol for an unnamed default!
			}
			var exportKind /* TODO(TS-TO-GO) inferred type SymbolFlags.ExportValue | 0 */ any
			if symbolFlags&SymbolFlagsValue != 0 {
				exportKind = SymbolFlagsExportValue
			} else {
				exportKind = 0
			}
			local := b.declareSymbol(b.container.locals, nil /*parent*/, node, exportKind, symbolExcludes)
			local.exportSymbol = b.declareSymbol(b.container.symbol.exports, b.container.symbol, node, symbolFlags, symbolExcludes)
			node.localSymbol = local
			return local
		} else {
			Debug.assertNode(b.container, canHaveLocals)
			return b.declareSymbol(b.container.locals, nil /*parent*/, node, symbolFlags, symbolExcludes)
		}
	}
}

func (b *Binder) jsdocTreatAsExported(node *Node) bool {
	if node.parent && isModuleDeclaration(node) {
		node = node.parent
	}
	if !isJSDocTypeAlias(node) {
		return false
	}
	// jsdoc typedef handling is a bit of a doozy, but to summarize, treat the typedef as exported if:
	// 1. It has an explicit name (since by default typedefs are always directly exported, either at the top level or in a container), or
	if !isJSDocEnumTag(node) && node.fullName != nil {
		return true
	}
	// 2. The thing a nameless typedef pulls its name from is implicitly a direct export (either by assignment or actual export flag).
	declName := getNameOfDeclaration(node)
	if !(declName != nil) {
		return false
	}
	if isPropertyAccessEntityNameExpression(declName.parent) && b.isTopLevelNamespaceAssignment(declName.parent) {
		return true
	}
	if isDeclaration(declName.parent) && getCombinedModifierFlags(declName.parent)&ModifierFlagsExport != 0 {
		return true
	}
	// This could potentially be simplified by having `delayedBindJSDocTypedefTag` pass in an override for `hasExportModifier`, since it should
	// already have calculated and branched on most of this.
	return false
}

// All container nodes are kept on a linked list in declaration order. This list is used by
// the getLocalNameOfContainer function in the type checker to validate that the local name
// used for a container is unique.
func (b *Binder) bindContainer(node Mutable[HasContainerFlags], containerFlags ContainerFlags) {
	// Before we recurse into a node's children, we first save the existing parent, container
	// and block-container.  Then after we pop out of processing the children, we restore
	// these saved values.
	saveContainer := b.container
	saveThisParentContainer := b.thisParentContainer
	savedBlockScopeContainer := b.blockScopeContainer

	// Depending on what kind of node this is, we may have to adjust the current container
	// and block-container.   If the current node is a container, then it is automatically
	// considered the current block-container as well.  Also, for containers that we know
	// may contain locals, we eagerly initialize the .locals field. We do this because
	// it's highly likely that the .locals will be needed to place some child in (for example,
	// a parameter, or variable declaration).
	//
	// However, we do not proactively create the .locals for block-containers because it's
	// totally normal and common for block-containers to never actually have a block-scoped
	// variable in them.  We don't want to end up allocating an object for every 'block' we
	// run into when most of them won't be necessary.
	//
	// Finally, if this is a block-container, then we clear out any existing .locals object
	// it may contain within it.  This happens in incremental scenarios.  Because we can be
	// reusing a node from a previous compilation, that node may have had 'locals' created
	// for it.  We must clear this so we don't accidentally move any stale data forward from
	// a previous compilation.
	if containerFlags&ContainerFlagsIsContainer != 0 {
		if node.kind != SyntaxKindArrowFunction {
			b.thisParentContainer = b.container
		}
		b.container = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: blockScopeContainer = node as IsContainer */ TODO
		if containerFlags&ContainerFlagsHasLocals != 0 {
			(b.container.AsHasLocals()).locals = createSymbolTable()
			b.addToContainerChain(b.container.AsHasLocals())
		}
	} else if containerFlags&ContainerFlagsIsBlockScopedContainer != 0 {
		b.blockScopeContainer = node.AsIsBlockScopedContainer()
		if containerFlags&ContainerFlagsHasLocals != 0 {
			(b.blockScopeContainer.AsHasLocals()).locals = nil
		}
	}
	if containerFlags&ContainerFlagsIsControlFlowContainer != 0 {
		saveCurrentFlow := b.currentFlow
		saveBreakTarget := b.currentBreakTarget
		saveContinueTarget := b.currentContinueTarget
		saveReturnTarget := b.currentReturnTarget
		saveExceptionTarget := b.currentExceptionTarget
		saveActiveLabelList := b.activeLabelList
		saveHasExplicitReturn := b.hasExplicitReturn
		isImmediatelyInvoked := (containerFlags&ContainerFlagsIsFunctionExpression && !hasSyntacticModifier(node, ModifierFlagsAsync) && !((node.AsFunctionLikeDeclaration()).asteriskToken != nil) && getImmediatelyInvokedFunctionExpression(node) != nil) || node.kind == SyntaxKindClassStaticBlockDeclaration
		// A non-async, non-generator IIFE is considered part of the containing control flow. Return statements behave
		// similarly to break statements that exit to a label just past the statement body.
		if !isImmediatelyInvoked {
			b.currentFlow = createFlowNode(FlowFlagsStart, nil /*node*/, nil /*antecedent*/)
			if containerFlags&(ContainerFlagsIsFunctionExpression|ContainerFlagsIsObjectLiteralOrClassExpressionMethodOrAccessor) != 0 {
				b.currentFlow.node = node /* as FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration */
			}
		}
		// We create a return control flow graph for IIFEs and constructors. For constructors
		// we use the return control flow graph in strict property initialization checks.
		if isImmediatelyInvoked || node.kind == SyntaxKindConstructor || (isInJSFile(node) && (node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression)) {
			b.currentReturnTarget = b.createBranchLabel()
		} else {
			b.currentReturnTarget = nil
		}
		b.currentExceptionTarget = nil
		b.currentBreakTarget = nil
		b.currentContinueTarget = nil
		b.activeLabelList = nil
		b.hasExplicitReturn = false
		b.bindChildren(node)
		// Reset all reachability check related flags on node (for incremental scenarios)
		node.flags &^= NodeFlagsReachabilityAndEmitFlags
		if !(b.currentFlow.flags&FlowFlagsUnreachable != 0) && containerFlags&ContainerFlagsIsFunctionLike != 0 && nodeIsPresent((node /* as FunctionLikeDeclaration | ClassStaticBlockDeclaration */).body) {
			node.flags |= NodeFlagsHasImplicitReturn
			if b.hasExplicitReturn {
				node.flags |= NodeFlagsHasExplicitReturn
			}
			(node /* as FunctionLikeDeclaration | ClassStaticBlockDeclaration */).endFlowNode = b.currentFlow
		}
		if node.kind == SyntaxKindSourceFile {
			node.flags |= b.emitFlags
			(node.AsSourceFile()).endFlowNode = b.currentFlow
		}

		if b.currentReturnTarget != nil {
			b.addAntecedent(b.currentReturnTarget, b.currentFlow)
			b.currentFlow = b.finishFlowLabel(b.currentReturnTarget)
			if node.kind == SyntaxKindConstructor || node.kind == SyntaxKindClassStaticBlockDeclaration || (isInJSFile(node) && (node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression)) {
				(node /* as FunctionLikeDeclaration | ClassStaticBlockDeclaration */).returnFlowNode = b.currentFlow
			}
		}
		if !isImmediatelyInvoked {
			b.currentFlow = saveCurrentFlow
		}
		b.currentBreakTarget = saveBreakTarget
		b.currentContinueTarget = saveContinueTarget
		b.currentReturnTarget = saveReturnTarget
		b.currentExceptionTarget = saveExceptionTarget
		b.activeLabelList = saveActiveLabelList
		b.hasExplicitReturn = saveHasExplicitReturn
	} else if containerFlags&ContainerFlagsIsInterface != 0 {
		b.seenThisKeyword = false
		b.bindChildren(node)
		Debug.assertNotNode(node, isIdentifier)
		// ContainsThis cannot overlap with HasExtendedUnicodeEscape on Identifier
		if b.seenThisKeyword {
			node.flags = node.flags | NodeFlagsContainsThis
		} else {
			node.flags = node.flags & ^NodeFlagsContainsThis
		}
	} else {
		b.bindChildren(node)
	}

	b.container = saveContainer
	b.thisParentContainer = saveThisParentContainer
	b.blockScopeContainer = savedBlockScopeContainer
}

func (b *Binder) bindEachFunctionsFirst(nodes *NodeArray[*Node]) {
	b.bindEach(nodes, func(n *Node) {
		if n.kind == SyntaxKindFunctionDeclaration {
			return b.bind(n)
		} else {
			return nil
		}
	})
	b.bindEach(nodes, func(n *Node) {
		if n.kind != SyntaxKindFunctionDeclaration {
			return b.bind(n)
		} else {
			return nil
		}
	})
}

func (b *Binder) bindEach(nodes *NodeArray[*Node], bindFunction func(node *Node) /*  = bind */) {
	if nodes == nil {
		return
	}

	forEach(nodes, bindFunction)
}

func (b *Binder) bindEachChild(node *Node) {
	forEachChild(node, b.bind, b.bindEach)
}

func (b *Binder) bindChildren(node *Node) {
	saveInAssignmentPattern := b.inAssignmentPattern
	// Most nodes aren't valid in an assignment pattern, so we clear the value here
	// and set it before we descend into nodes that could actually be part of an assignment pattern.
	b.inAssignmentPattern = false
	if b.checkUnreachable(node) {
		b.bindEachChild(node)
		b.bindJSDoc(node)
		b.inAssignmentPattern = saveInAssignmentPattern
		return
	}
	if node.kind >= SyntaxKindFirstStatement && node.kind <= SyntaxKindLastStatement && (!b.options.allowUnreachableCode || node.kind == SyntaxKindReturnStatement) {
		(node.AsHasFlowNode()).flowNode = b.currentFlow
	}
	switch node.kind {
	case SyntaxKindWhileStatement:
		b.bindWhileStatement(node.AsWhileStatement())
	case SyntaxKindDoStatement:
		b.bindDoStatement(node.AsDoStatement())
	case SyntaxKindForStatement:
		b.bindForStatement(node.AsForStatement())
	case SyntaxKindForInStatement,
		SyntaxKindForOfStatement:
		b.bindForInOrForOfStatement(node.AsForInOrOfStatement())
	case SyntaxKindIfStatement:
		b.bindIfStatement(node.AsIfStatement())
	case SyntaxKindReturnStatement,
		SyntaxKindThrowStatement:
		b.bindReturnOrThrow(node /* as ReturnStatement | ThrowStatement */)
	case SyntaxKindBreakStatement,
		SyntaxKindContinueStatement:
		b.bindBreakOrContinueStatement(node.AsBreakOrContinueStatement())
	case SyntaxKindTryStatement:
		b.bindTryStatement(node.AsTryStatement())
	case SyntaxKindSwitchStatement:
		b.bindSwitchStatement(node.AsSwitchStatement())
	case SyntaxKindCaseBlock:
		b.bindCaseBlock(node.AsCaseBlock())
	case SyntaxKindCaseClause:
		b.bindCaseClause(node.AsCaseClause())
	case SyntaxKindExpressionStatement:
		b.bindExpressionStatement(node.AsExpressionStatement())
	case SyntaxKindLabeledStatement:
		b.bindLabeledStatement(node.AsLabeledStatement())
	case SyntaxKindPrefixUnaryExpression:
		b.bindPrefixUnaryExpressionFlow(node.AsPrefixUnaryExpression())
	case SyntaxKindPostfixUnaryExpression:
		b.bindPostfixUnaryExpressionFlow(node.AsPostfixUnaryExpression())
	case SyntaxKindBinaryExpression:
		if isDestructuringAssignment(node) {
			// Carry over whether we are in an assignment pattern to
			// binary expressions that could actually be an initializer
			b.inAssignmentPattern = saveInAssignmentPattern
			b.bindDestructuringAssignmentFlow(node)
			return
		}
		b.bindBinaryExpressionFlow(node.AsBinaryExpression())
	case SyntaxKindDeleteExpression:
		b.bindDeleteExpressionFlow(node.AsDeleteExpression())
	case SyntaxKindConditionalExpression:
		b.bindConditionalExpressionFlow(node.AsConditionalExpression())
	case SyntaxKindVariableDeclaration:
		b.bindVariableDeclarationFlow(node.AsVariableDeclaration())
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		b.bindAccessExpressionFlow(node.AsAccessExpression())
	case SyntaxKindCallExpression:
		b.bindCallExpressionFlow(node.AsCallExpression())
	case SyntaxKindNonNullExpression:
		b.bindNonNullExpressionFlow(node.AsNonNullExpression())
	case SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocEnumTag:
		b.bindJSDocTypeAlias(node /* as JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag */)
	case SyntaxKindJSDocImportTag:
		b.bindJSDocImportTag(node.AsJSDocImportTag())
		// In source files and blocks, bind functions first to match hoisting that occurs at runtime
	case SyntaxKindSourceFile:
		b.bindEachFunctionsFirst((node.AsSourceFile()).statements)
		b.bind((node.AsSourceFile()).endOfFileToken)
	case SyntaxKindBlock,
		SyntaxKindModuleBlock:
		b.bindEachFunctionsFirst((node.AsBlock()).statements)
	case SyntaxKindBindingElement:
		b.bindBindingElementFlow(node.AsBindingElement())
	case SyntaxKindParameter:
		b.bindParameterFlow(node.AsParameterDeclaration())
	case SyntaxKindObjectLiteralExpression,
		SyntaxKindArrayLiteralExpression,
		SyntaxKindPropertyAssignment,
		SyntaxKindSpreadElement:
		// Carry over whether we are in an assignment pattern of Object and Array literals
		// as well as their children that are valid assignment targets.
		b.inAssignmentPattern = saveInAssignmentPattern
		fallthrough
	default:
		b.bindEachChild(node)
	}
	b.bindJSDoc(node)
	b.inAssignmentPattern = saveInAssignmentPattern
}

func (b *Binder) isNarrowingExpression(expr Expression) bool {
	switch expr.kind {
	case SyntaxKindIdentifier,
		SyntaxKindThisKeyword:
		return true
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		return b.containsNarrowableReference(expr)
	case SyntaxKindCallExpression:
		return b.hasNarrowableArgument(expr.AsCallExpression())
	case SyntaxKindParenthesizedExpression:
		if isJSDocTypeAssertion(expr) {
			return false
		}
		fallthrough
	case SyntaxKindNonNullExpression:
		return b.isNarrowingExpression((expr /* as ParenthesizedExpression | NonNullExpression */).expression)
	case SyntaxKindBinaryExpression:
		return b.isNarrowingBinaryExpression(expr.AsBinaryExpression())
	case SyntaxKindPrefixUnaryExpression:
		return (expr.AsPrefixUnaryExpression()).operator == SyntaxKindExclamationToken && b.isNarrowingExpression((expr.AsPrefixUnaryExpression()).operand)
	case SyntaxKindTypeOfExpression:
		return b.isNarrowingExpression((expr.AsTypeOfExpression()).expression)
	}
	return false
}

func (b *Binder) isNarrowableReference(expr Expression) bool {
	switch expr.kind {
	case SyntaxKindIdentifier,
		SyntaxKindThisKeyword,
		SyntaxKindSuperKeyword,
		SyntaxKindMetaProperty:
		return true
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindParenthesizedExpression,
		SyntaxKindNonNullExpression:
		return b.isNarrowableReference((expr /* as PropertyAccessExpression | ParenthesizedExpression | NonNullExpression */).expression)
	case SyntaxKindElementAccessExpression:
		return (isStringOrNumericLiteralLike((expr.AsElementAccessExpression()).argumentExpression) || isEntityNameExpression((expr.AsElementAccessExpression()).argumentExpression)) && b.isNarrowableReference((expr.AsElementAccessExpression()).expression)
	case SyntaxKindBinaryExpression:
		return (expr.AsBinaryExpression()).operatorToken.kind == SyntaxKindCommaToken && b.isNarrowableReference((expr.AsBinaryExpression()).right) || isAssignmentOperator((expr.AsBinaryExpression()).operatorToken.kind) && isLeftHandSideExpression((expr.AsBinaryExpression()).left)
	}
	return false
}

func (b *Binder) containsNarrowableReference(expr Expression) bool {
	return b.isNarrowableReference(expr) || isOptionalChain(expr) && b.containsNarrowableReference(expr.expression)
}

func (b *Binder) hasNarrowableArgument(expr CallExpression) bool {
	if expr.arguments {
		for _, argument := range expr.arguments {
			if b.containsNarrowableReference(argument) {
				return true
			}
		}
	}
	if expr.expression.kind == SyntaxKindPropertyAccessExpression && b.containsNarrowableReference((expr.expression.AsPropertyAccessExpression()).expression) {
		return true
	}
	return false
}

func (b *Binder) isNarrowingTypeofOperands(expr1 Expression, expr2 Expression) bool {
	return isTypeOfExpression(expr1) && b.isNarrowableOperand(expr1.expression) && isStringLiteralLike(expr2)
}

func (b *Binder) isNarrowingBinaryExpression(expr BinaryExpression) bool {
	switch expr.operatorToken.kind {
	case SyntaxKindEqualsToken,
		SyntaxKindBarBarEqualsToken,
		SyntaxKindAmpersandAmpersandEqualsToken,
		SyntaxKindQuestionQuestionEqualsToken:
		return b.containsNarrowableReference(expr.left)
	case SyntaxKindEqualsEqualsToken,
		SyntaxKindExclamationEqualsToken,
		SyntaxKindEqualsEqualsEqualsToken,
		SyntaxKindExclamationEqualsEqualsToken:
		return b.isNarrowableOperand(expr.left) || b.isNarrowableOperand(expr.right) || b.isNarrowingTypeofOperands(expr.right, expr.left) || b.isNarrowingTypeofOperands(expr.left, expr.right) || (isBooleanLiteral(expr.right) && b.isNarrowingExpression(expr.left) || isBooleanLiteral(expr.left) && b.isNarrowingExpression(expr.right))
	case SyntaxKindInstanceOfKeyword:
		return b.isNarrowableOperand(expr.left)
	case SyntaxKindInKeyword:
		return b.isNarrowingExpression(expr.right)
	case SyntaxKindCommaToken:
		return b.isNarrowingExpression(expr.right)
	}
	return false
}

func (b *Binder) isNarrowableOperand(expr Expression) bool {
	switch expr.kind {
	case SyntaxKindParenthesizedExpression:
		return b.isNarrowableOperand((expr.AsParenthesizedExpression()).expression)
	case SyntaxKindBinaryExpression:
		switch (expr.AsBinaryExpression()).operatorToken.kind {
		case SyntaxKindEqualsToken:
			return b.isNarrowableOperand((expr.AsBinaryExpression()).left)
		case SyntaxKindCommaToken:
			return b.isNarrowableOperand((expr.AsBinaryExpression()).right)
		}
	}
	return b.containsNarrowableReference(expr)
}

func (b *Binder) createBranchLabel() FlowLabel {
	return createFlowNode(FlowFlagsBranchLabel, nil /*node*/, nil /*antecedent*/).(FlowLabel)
}

func (b *Binder) createLoopLabel() FlowLabel {
	return createFlowNode(FlowFlagsLoopLabel, nil /*node*/, nil /*antecedent*/).(FlowLabel)
}

func (b *Binder) createReduceLabel(target FlowLabel, antecedents []FlowNode, antecedent FlowNode) FlowReduceLabel {
	return createFlowNode(FlowFlagsReduceLabel, any{
		target:      target,
		antecedents: antecedents,
	}, antecedent).(FlowReduceLabel)
}

func (b *Binder) setFlowNodeReferenced(flow FlowNode) {
	// On first reference we set the Referenced flag, thereafter we set the Shared flag
	if flow.flags&FlowFlagsReferenced != 0 {
		flow.flags |= FlowFlagsShared
	} else {
		flow.flags |= FlowFlagsReferenced
	}
}

func (b *Binder) addAntecedent(label FlowLabel, antecedent FlowNode) {
	if !(antecedent.flags&FlowFlagsUnreachable != 0) && !contains(label.antecedent, antecedent) {
		(label.antecedent || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: label.antecedent = [] */ TODO)).push(antecedent)
		b.setFlowNodeReferenced(antecedent)
	}
}

func (b *Binder) createFlowCondition(flags Union[ /* TODO(TS-TO-GO) Node QualifiedName: FlowFlags.TrueCondition */ any /* TODO(TS-TO-GO) Node QualifiedName: FlowFlags.FalseCondition */, any], antecedent FlowNode, expression Expression) FlowNode {
	if antecedent.flags&FlowFlagsUnreachable != 0 {
		return antecedent
	}
	if !(expression != nil) {
		if flags&FlowFlagsTrueCondition != 0 {
			return antecedent
		} else {
			return b.unreachableFlow
		}
	}
	if (expression.kind == SyntaxKindTrueKeyword && flags&FlowFlagsFalseCondition != 0 || expression.kind == SyntaxKindFalseKeyword && flags&FlowFlagsTrueCondition != 0) && !isExpressionOfOptionalChainRoot(expression) && !isNullishCoalesce(expression.parent) {
		return b.unreachableFlow
	}
	if !b.isNarrowingExpression(expression) {
		return antecedent
	}
	b.setFlowNodeReferenced(antecedent)
	return createFlowNode(flags, expression, antecedent).(FlowCondition)
}

func (b *Binder) createFlowSwitchClause(antecedent FlowNode, switchStatement SwitchStatement, clauseStart number, clauseEnd number) FlowSwitchClause {
	b.setFlowNodeReferenced(antecedent)
	return createFlowNode(FlowFlagsSwitchClause, any{
		switchStatement: switchStatement,
		clauseStart:     clauseStart,
		clauseEnd:       clauseEnd,
	}, antecedent).(FlowSwitchClause)
}

func (b *Binder) createFlowMutation(flags Union[ /* TODO(TS-TO-GO) Node QualifiedName: FlowFlags.Assignment */ any /* TODO(TS-TO-GO) Node QualifiedName: FlowFlags.ArrayMutation */, any], antecedent FlowNode, node Union[Expression, VariableDeclaration, ArrayBindingElement]) /* TODO(TS-TO-GO) inferred type FlowAssignment | FlowArrayMutation */ any {
	b.setFlowNodeReferenced(antecedent)
	b.hasFlowEffects = true
	result := createFlowNode(flags, node, antecedent) /* as FlowAssignment | FlowArrayMutation */
	if b.currentExceptionTarget != nil {
		b.addAntecedent(b.currentExceptionTarget, result)
	}
	return result
}

func (b *Binder) createFlowCall(antecedent FlowNode, node CallExpression) FlowCall {
	b.setFlowNodeReferenced(antecedent)
	b.hasFlowEffects = true
	return createFlowNode(FlowFlagsCall, node, antecedent).(FlowCall)
}

func (b *Binder) finishFlowLabel(flow FlowLabel) FlowNode {
	antecedents := flow.antecedent
	if !(antecedents != nil) {
		return b.unreachableFlow
	}
	if antecedents.length == 1 {
		return antecedents[0]
	}
	return flow
}

func (b *Binder) isStatementCondition(node *Node) bool {
	parent := node.parent
	switch parent.kind {
	case SyntaxKindIfStatement,
		SyntaxKindWhileStatement,
		SyntaxKindDoStatement:
		return (parent /* as IfStatement | WhileStatement | DoStatement */).expression == node
	case SyntaxKindForStatement,
		SyntaxKindConditionalExpression:
		return (parent /* as ForStatement | ConditionalExpression */).condition == node
	}
	return false
}

func (b *Binder) isLogicalExpression(node *Node) bool {
	for true {
		if node.kind == SyntaxKindParenthesizedExpression {
			node = (node.AsParenthesizedExpression()).expression
		} else if node.kind == SyntaxKindPrefixUnaryExpression && (node.AsPrefixUnaryExpression()).operator == SyntaxKindExclamationToken {
			node = (node.AsPrefixUnaryExpression()).operand
		} else {
			return isLogicalOrCoalescingBinaryExpression(node)
		}
	}
}

func (b *Binder) isLogicalAssignmentExpression(node *Node) bool {
	return isLogicalOrCoalescingAssignmentExpression(skipParentheses(node))
}

func (b *Binder) isTopLevelLogicalExpression(node *Node) bool {
	for isParenthesizedExpression(node.parent) || isPrefixUnaryExpression(node.parent) && node.parent.operator == SyntaxKindExclamationToken {
		node = node.parent
	}
	return !b.isStatementCondition(node) && !b.isLogicalExpression(node.parent) && !(isOptionalChain(node.parent) && node.parent.expression == node)
}

func (b *Binder) doWithConditionalBranches(action func(value T), value T, trueTarget FlowLabel, falseTarget FlowLabel) {
	savedTrueTarget := b.currentTrueTarget
	savedFalseTarget := b.currentFalseTarget
	b.currentTrueTarget = trueTarget
	b.currentFalseTarget = falseTarget
	action(value)
	b.currentTrueTarget = savedTrueTarget
	b.currentFalseTarget = savedFalseTarget
}

func (b *Binder) bindCondition(node Expression, trueTarget FlowLabel, falseTarget FlowLabel) {
	b.doWithConditionalBranches(b.bind, node, trueTarget, falseTarget)
	if !(node != nil) || !b.isLogicalAssignmentExpression(node) && !b.isLogicalExpression(node) && !(isOptionalChain(node) && isOutermostOptionalChain(node)) {
		b.addAntecedent(trueTarget, b.createFlowCondition(FlowFlagsTrueCondition, b.currentFlow, node))
		b.addAntecedent(falseTarget, b.createFlowCondition(FlowFlagsFalseCondition, b.currentFlow, node))
	}
}

func (b *Binder) bindIterativeStatement(node Statement, breakTarget FlowLabel, continueTarget FlowLabel) {
	saveBreakTarget := b.currentBreakTarget
	saveContinueTarget := b.currentContinueTarget
	b.currentBreakTarget = breakTarget
	b.currentContinueTarget = continueTarget
	b.bind(node)
	b.currentBreakTarget = saveBreakTarget
	b.currentContinueTarget = saveContinueTarget
}

func (b *Binder) setContinueTarget(node *Node, target FlowLabel) FlowLabel {
	label := b.activeLabelList
	for label != nil && node.parent.kind == SyntaxKindLabeledStatement {
		label.continueTarget = target
		label = label.next
		node = node.parent
	}
	return target
}

func (b *Binder) bindWhileStatement(node WhileStatement) {
	preWhileLabel := b.setContinueTarget(node, b.createLoopLabel())
	preBodyLabel := b.createBranchLabel()
	postWhileLabel := b.createBranchLabel()
	b.addAntecedent(preWhileLabel, b.currentFlow)
	b.currentFlow = preWhileLabel
	b.bindCondition(node.expression, preBodyLabel, postWhileLabel)
	b.currentFlow = b.finishFlowLabel(preBodyLabel)
	b.bindIterativeStatement(node.statement, postWhileLabel, preWhileLabel)
	b.addAntecedent(preWhileLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(postWhileLabel)
}

func (b *Binder) bindDoStatement(node DoStatement) {
	preDoLabel := b.createLoopLabel()
	preConditionLabel := b.setContinueTarget(node, b.createBranchLabel())
	postDoLabel := b.createBranchLabel()
	b.addAntecedent(preDoLabel, b.currentFlow)
	b.currentFlow = preDoLabel
	b.bindIterativeStatement(node.statement, postDoLabel, preConditionLabel)
	b.addAntecedent(preConditionLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(preConditionLabel)
	b.bindCondition(node.expression, preDoLabel, postDoLabel)
	b.currentFlow = b.finishFlowLabel(postDoLabel)
}

func (b *Binder) bindForStatement(node ForStatement) {
	preLoopLabel := b.setContinueTarget(node, b.createLoopLabel())
	preBodyLabel := b.createBranchLabel()
	postLoopLabel := b.createBranchLabel()
	b.bind(node.initializer)
	b.addAntecedent(preLoopLabel, b.currentFlow)
	b.currentFlow = preLoopLabel
	b.bindCondition(node.condition, preBodyLabel, postLoopLabel)
	b.currentFlow = b.finishFlowLabel(preBodyLabel)
	b.bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel)
	b.bind(node.incrementor)
	b.addAntecedent(preLoopLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(postLoopLabel)
}

func (b *Binder) bindForInOrForOfStatement(node ForInOrOfStatement) {
	preLoopLabel := b.setContinueTarget(node, b.createLoopLabel())
	postLoopLabel := b.createBranchLabel()
	b.bind(node.expression)
	b.addAntecedent(preLoopLabel, b.currentFlow)
	b.currentFlow = preLoopLabel
	if node.kind == SyntaxKindForOfStatement {
		b.bind(node.awaitModifier)
	}
	b.addAntecedent(postLoopLabel, b.currentFlow)
	b.bind(node.initializer)
	if node.initializer.kind != SyntaxKindVariableDeclarationList {
		b.bindAssignmentTargetFlow(node.initializer)
	}
	b.bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel)
	b.addAntecedent(preLoopLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(postLoopLabel)
}

func (b *Binder) bindIfStatement(node IfStatement) {
	thenLabel := b.createBranchLabel()
	elseLabel := b.createBranchLabel()
	postIfLabel := b.createBranchLabel()
	b.bindCondition(node.expression, thenLabel, elseLabel)
	b.currentFlow = b.finishFlowLabel(thenLabel)
	b.bind(node.thenStatement)
	b.addAntecedent(postIfLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(elseLabel)
	b.bind(node.elseStatement)
	b.addAntecedent(postIfLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(postIfLabel)
}

func (b *Binder) bindReturnOrThrow(node Union[ReturnStatement, ThrowStatement]) {
	b.bind(node.expression)
	if node.kind == SyntaxKindReturnStatement {
		b.hasExplicitReturn = true
		if b.currentReturnTarget != nil {
			b.addAntecedent(b.currentReturnTarget, b.currentFlow)
		}
	}
	b.currentFlow = b.unreachableFlow
	b.hasFlowEffects = true
}

func (b *Binder) findActiveLabel(name string) *ActiveLabel {
	for label := b.activeLabelList; label != nil; label = label.next {
		if label.name == name {
			return label
		}
	}
	return nil
}

func (b *Binder) bindBreakOrContinueFlow(node BreakOrContinueStatement, breakTarget *FlowLabel, continueTarget *FlowLabel) {
	var flowLabel *FlowLabel
	if node.kind == SyntaxKindBreakStatement {
		flowLabel = breakTarget
	} else {
		flowLabel = continueTarget
	}
	if flowLabel != nil {
		b.addAntecedent(flowLabel, b.currentFlow)
		b.currentFlow = b.unreachableFlow
		b.hasFlowEffects = true
	}
}

func (b *Binder) bindBreakOrContinueStatement(node BreakOrContinueStatement) {
	b.bind(node.label)
	if node.label != nil {
		activeLabel := b.findActiveLabel(node.label.escapedText)
		if activeLabel != nil {
			activeLabel.referenced = true
			b.bindBreakOrContinueFlow(node, activeLabel.breakTarget, activeLabel.continueTarget)
		}
	} else {
		b.bindBreakOrContinueFlow(node, b.currentBreakTarget, b.currentContinueTarget)
	}
}

func (b *Binder) bindTryStatement(node TryStatement) {
	// We conservatively assume that *any* code in the try block can cause an exception, but we only need
	// to track code that causes mutations (because only mutations widen the possible control flow type of
	// a variable). The exceptionLabel is the target label for control flows that result from exceptions.
	// We add all mutation flow nodes as antecedents of this label such that we can analyze them as possible
	// antecedents of the start of catch or finally blocks. Furthermore, we add the current control flow to
	// represent exceptions that occur before any mutations.
	saveReturnTarget := b.currentReturnTarget
	saveExceptionTarget := b.currentExceptionTarget
	normalExitLabel := b.createBranchLabel()
	returnLabel := b.createBranchLabel()
	exceptionLabel := b.createBranchLabel()
	if node.finallyBlock != nil {
		b.currentReturnTarget = returnLabel
	}
	b.addAntecedent(exceptionLabel, b.currentFlow)
	b.currentExceptionTarget = exceptionLabel
	b.bind(node.tryBlock)
	b.addAntecedent(normalExitLabel, b.currentFlow)
	if node.catchClause != nil {
		// Start of catch clause is the target of exceptions from try block.
		b.currentFlow = b.finishFlowLabel(exceptionLabel)
		// The currentExceptionTarget now represents control flows from exceptions in the catch clause.
		// Effectively, in a try-catch-finally, if an exception occurs in the try block, the catch block
		// acts like a second try block.
		exceptionLabel = b.createBranchLabel()
		b.addAntecedent(exceptionLabel, b.currentFlow)
		b.currentExceptionTarget = exceptionLabel
		b.bind(node.catchClause)
		b.addAntecedent(normalExitLabel, b.currentFlow)
	}
	b.currentReturnTarget = saveReturnTarget
	b.currentExceptionTarget = saveExceptionTarget
	if node.finallyBlock != nil {
		// Possible ways control can reach the finally block:
		// 1) Normal completion of try block of a try-finally or try-catch-finally
		// 2) Normal completion of catch block (following exception in try block) of a try-catch-finally
		// 3) Return in try or catch block of a try-finally or try-catch-finally
		// 4) Exception in try block of a try-finally
		// 5) Exception in catch block of a try-catch-finally
		// When analyzing a control flow graph that starts inside a finally block we want to consider all
		// five possibilities above. However, when analyzing a control flow graph that starts outside (past)
		// the finally block, we only want to consider the first two (if we're past a finally block then it
		// must have completed normally). Likewise, when analyzing a control flow graph from return statements
		// in try or catch blocks in an IIFE, we only want to consider the third. To make this possible, we
		// inject a ReduceLabel node into the control flow graph. This node contains an alternate reduced
		// set of antecedents for the pre-finally label. As control flow analysis passes by a ReduceLabel
		// node, the pre-finally label is temporarily switched to the reduced antecedent set.
		finallyLabel := b.createBranchLabel()
		finallyLabel.antecedent = concatenate(concatenate(normalExitLabel.antecedent, exceptionLabel.antecedent), returnLabel.antecedent)
		b.currentFlow = finallyLabel
		b.bind(node.finallyBlock)
		if b.currentFlow.flags&FlowFlagsUnreachable != 0 {
			// If the end of the finally block is unreachable, the end of the entire try statement is unreachable.
			b.currentFlow = b.unreachableFlow
		} else {
			// If we have an IIFE return target and return statements in the try or catch blocks, add a control
			// flow that goes back through the finally block and back through only the return statements.
			if b.currentReturnTarget != nil && returnLabel.antecedent != nil {
				b.addAntecedent(b.currentReturnTarget, b.createReduceLabel(finallyLabel, returnLabel.antecedent, b.currentFlow))
			}
			// If we have an outer exception target (i.e. a containing try-finally or try-catch-finally), add a
			// control flow that goes back through the finally blok and back through each possible exception source.
			if b.currentExceptionTarget != nil && exceptionLabel.antecedent != nil {
				b.addAntecedent(b.currentExceptionTarget, b.createReduceLabel(finallyLabel, exceptionLabel.antecedent, b.currentFlow))
			}
			// If the end of the finally block is reachable, but the end of the try and catch blocks are not,
			// convert the current flow to unreachable. For example, 'try { return 1; } finally { ... }' should
			// result in an unreachable current control flow.
			if normalExitLabel.antecedent != nil {
				b.currentFlow = b.createReduceLabel(finallyLabel, normalExitLabel.antecedent, b.currentFlow)
			} else {
				b.currentFlow = b.unreachableFlow
			}
		}
	} else {
		b.currentFlow = b.finishFlowLabel(normalExitLabel)
	}
}

func (b *Binder) bindSwitchStatement(node SwitchStatement) {
	postSwitchLabel := b.createBranchLabel()
	b.bind(node.expression)
	saveBreakTarget := b.currentBreakTarget
	savePreSwitchCaseFlow := b.preSwitchCaseFlow
	b.currentBreakTarget = postSwitchLabel
	b.preSwitchCaseFlow = b.currentFlow
	b.bind(node.caseBlock)
	b.addAntecedent(postSwitchLabel, b.currentFlow)
	hasDefault := forEach(node.caseBlock.clauses, func(c /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
		return c.kind == SyntaxKindDefaultClause
	})
	// We mark a switch statement as possibly exhaustive if it has no default clause and if all
	// case clauses have unreachable end points (e.g. they all return). Note, we no longer need
	// this property in control flow analysis, it's there only for backwards compatibility.
	node.possiblyExhaustive = !hasDefault && !(postSwitchLabel.antecedent != nil)
	if !hasDefault {
		b.addAntecedent(postSwitchLabel, b.createFlowSwitchClause(b.preSwitchCaseFlow, node, 0, 0))
	}
	b.currentBreakTarget = saveBreakTarget
	b.preSwitchCaseFlow = savePreSwitchCaseFlow
	b.currentFlow = b.finishFlowLabel(postSwitchLabel)
}

func (b *Binder) bindCaseBlock(node CaseBlock) {
	clauses := node.clauses
	isNarrowingSwitch := node.parent.expression.kind == SyntaxKindTrueKeyword || b.isNarrowingExpression(node.parent.expression)
	var fallthroughFlow FlowNode = b.unreachableFlow

	for i := 0; i < clauses.length; i++ {
		clauseStart := i
		for !(clauses[i].statements.length != 0) && i+1 < clauses.length {
			if fallthroughFlow == b.unreachableFlow {
				b.currentFlow = b.preSwitchCaseFlow
			}
			b.bind(clauses[i])
			i++
		}
		preCaseLabel := b.createBranchLabel()
		b.addAntecedent(preCaseLabel, ifElse(isNarrowingSwitch, b.createFlowSwitchClause(b.preSwitchCaseFlow, node.parent, clauseStart, i+1), b.preSwitchCaseFlow))
		b.addAntecedent(preCaseLabel, fallthroughFlow)
		b.currentFlow = b.finishFlowLabel(preCaseLabel)
		clause := clauses[i]
		b.bind(clause)
		fallthroughFlow = b.currentFlow
		if !(b.currentFlow.flags&FlowFlagsUnreachable != 0) && i != clauses.length-1 && b.options.noFallthroughCasesInSwitch {
			clause.fallthroughFlowNode = b.currentFlow
		}
	}
}

func (b *Binder) bindCaseClause(node CaseClause) {
	saveCurrentFlow := b.currentFlow
	b.currentFlow = b.preSwitchCaseFlow
	b.bind(node.expression)
	b.currentFlow = saveCurrentFlow
	b.bindEach(node.statements)
}

func (b *Binder) bindExpressionStatement(node ExpressionStatement) {
	b.bind(node.expression)
	b.maybeBindExpressionFlowIfCall(node.expression)
}

func (b *Binder) maybeBindExpressionFlowIfCall(node Expression) {
	// A top level or comma expression call expression with a dotted function name and at least one argument
	// is potentially an assertion and is therefore included in the control flow.
	if node.kind == SyntaxKindCallExpression {
		call := node.AsCallExpression()
		if call.expression.kind != SyntaxKindSuperKeyword && isDottedName(call.expression) {
			b.currentFlow = b.createFlowCall(b.currentFlow, call)
		}
	}
}

func (b *Binder) bindLabeledStatement(node LabeledStatement) {
	postStatementLabel := b.createBranchLabel()
	b.activeLabelList = &ActiveLabel{
		next:           b.activeLabelList,
		name:           node.label.escapedText,
		breakTarget:    postStatementLabel,
		continueTarget: nil,
		referenced:     false,
	}
	b.bind(node.label)
	b.bind(node.statement)
	if !b.activeLabelList.referenced && !b.options.allowUnusedLabels {
		b.errorOrSuggestionOnNode(unusedLabelIsError(b.options), node.label, Diagnostics.Unused_label)
	}
	b.activeLabelList = b.activeLabelList.next
	b.addAntecedent(postStatementLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(postStatementLabel)
}

func (b *Binder) bindDestructuringTargetFlow(node Expression) {
	if node.kind == SyntaxKindBinaryExpression && (node.AsBinaryExpression()).operatorToken.kind == SyntaxKindEqualsToken {
		b.bindAssignmentTargetFlow((node.AsBinaryExpression()).left)
	} else {
		b.bindAssignmentTargetFlow(node)
	}
}

func (b *Binder) bindAssignmentTargetFlow(node Expression) {
	if b.isNarrowableReference(node) {
		b.currentFlow = b.createFlowMutation(FlowFlagsAssignment, b.currentFlow, node)
	} else if node.kind == SyntaxKindArrayLiteralExpression {
		for _, e := range (node.AsArrayLiteralExpression()).elements {
			if e.kind == SyntaxKindSpreadElement {
				b.bindAssignmentTargetFlow((e.AsSpreadElement()).expression)
			} else {
				b.bindDestructuringTargetFlow(e)
			}
		}
	} else if node.kind == SyntaxKindObjectLiteralExpression {
		for _, p := range (node.AsObjectLiteralExpression()).properties {
			if p.kind == SyntaxKindPropertyAssignment {
				b.bindDestructuringTargetFlow(p.initializer)
			} else if p.kind == SyntaxKindShorthandPropertyAssignment {
				b.bindAssignmentTargetFlow(p.name)
			} else if p.kind == SyntaxKindSpreadAssignment {
				b.bindAssignmentTargetFlow(p.expression)
			}
		}
	}
}

func (b *Binder) bindLogicalLikeExpression(node BinaryExpression, trueTarget FlowLabel, falseTarget FlowLabel) {
	preRightLabel := b.createBranchLabel()
	if node.operatorToken.kind == SyntaxKindAmpersandAmpersandToken || node.operatorToken.kind == SyntaxKindAmpersandAmpersandEqualsToken {
		b.bindCondition(node.left, preRightLabel, falseTarget)
	} else {
		b.bindCondition(node.left, trueTarget, preRightLabel)
	}
	b.currentFlow = b.finishFlowLabel(preRightLabel)
	b.bind(node.operatorToken)

	if isLogicalOrCoalescingAssignmentOperator(node.operatorToken.kind) {
		b.doWithConditionalBranches(b.bind, node.right, trueTarget, falseTarget)
		b.bindAssignmentTargetFlow(node.left)

		b.addAntecedent(trueTarget, b.createFlowCondition(FlowFlagsTrueCondition, b.currentFlow, node))
		b.addAntecedent(falseTarget, b.createFlowCondition(FlowFlagsFalseCondition, b.currentFlow, node))
	} else {
		b.bindCondition(node.right, trueTarget, falseTarget)
	}
}

func (b *Binder) bindPrefixUnaryExpressionFlow(node PrefixUnaryExpression) {
	if node.operator == SyntaxKindExclamationToken {
		saveTrueTarget := b.currentTrueTarget
		b.currentTrueTarget = b.currentFalseTarget
		b.currentFalseTarget = saveTrueTarget
		b.bindEachChild(node)
		b.currentFalseTarget = b.currentTrueTarget
		b.currentTrueTarget = saveTrueTarget
	} else {
		b.bindEachChild(node)
		if node.operator == SyntaxKindPlusPlusToken || node.operator == SyntaxKindMinusMinusToken {
			b.bindAssignmentTargetFlow(node.operand)
		}
	}
}

func (b *Binder) bindPostfixUnaryExpressionFlow(node PostfixUnaryExpression) {
	b.bindEachChild(node)
	if node.operator == SyntaxKindPlusPlusToken || node.operator == SyntaxKindMinusMinusToken {
		b.bindAssignmentTargetFlow(node.operand)
	}
}

func (b *Binder) bindDestructuringAssignmentFlow(node DestructuringAssignment) {
	if b.inAssignmentPattern {
		b.inAssignmentPattern = false
		b.bind(node.operatorToken)
		b.bind(node.right)
		b.inAssignmentPattern = true
		b.bind(node.left)
	} else {
		b.inAssignmentPattern = true
		b.bind(node.left)
		b.inAssignmentPattern = false
		b.bind(node.operatorToken)
		b.bind(node.right)
	}
	b.bindAssignmentTargetFlow(node.left)
}

func (b *Binder) createBindBinaryExpressionFlow() /* TODO(TS-TO-GO) inferred type (node: BinaryExpression) => void */ any {
	type WorkArea struct {
		stackIndex        number
		skip              bool
		inStrictModeStack []*bool
		parentStack       []*Node
	}

	return createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, nil /*foldState*/)

	onEnter := func(node BinaryExpression, state *WorkArea) WorkArea {
		if state != nil {
			state.stackIndex++
			// Emulate the work that `bind` does before reaching `bindChildren`. A normal call to
			// `bindBinaryExpressionFlow` will already have done this work.
			setParent(node, b.parent)
			saveInStrictMode := b.inStrictMode
			b.bindWorker(node)
			saveParent := b.parent
			b.parent = node
			state.skip = false
			state.inStrictModeStack[state.stackIndex] = saveInStrictMode
			state.parentStack[state.stackIndex] = saveParent
		} else {
			state = &WorkArea{
				stackIndex:        0,
				skip:              false,
				inStrictModeStack: []undefined{nil},
				parentStack:       []undefined{nil},
			}
		}
		// TODO: bindLogicalExpression is recursive - if we want to handle deeply nested `&&` expressions
		// we'll need to handle the `bindLogicalExpression` scenarios in this state machine, too
		// For now, though, since the common cases are chained `+`, leaving it recursive is fine
		operator := node.operatorToken.kind
		if isLogicalOrCoalescingBinaryOperator(operator) || isLogicalOrCoalescingAssignmentOperator(operator) {
			if b.isTopLevelLogicalExpression(node) {
				postExpressionLabel := b.createBranchLabel()
				saveCurrentFlow := b.currentFlow
				saveHasFlowEffects := b.hasFlowEffects
				b.hasFlowEffects = false
				b.bindLogicalLikeExpression(node, postExpressionLabel, postExpressionLabel)
				if b.hasFlowEffects {
					b.currentFlow = b.finishFlowLabel(postExpressionLabel)
				} else {
					b.currentFlow = saveCurrentFlow
				}
				b.hasFlowEffects = b.hasFlowEffects || saveHasFlowEffects
			} else {
				b.bindLogicalLikeExpression(node, b.currentTrueTarget, b.currentFalseTarget)
			}
			state.skip = true
		}
		return state
	}

	onLeft := func(left Expression, state WorkArea, node BinaryExpression) *BinaryExpression {
		if !state.skip {
			maybeBound := maybeBind(left)
			if node.operatorToken.kind == SyntaxKindCommaToken {
				b.maybeBindExpressionFlowIfCall(left)
			}
			return maybeBound
		}
	}

	onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, _node BinaryExpression) {
		if !state.skip {
			b.bind(operatorToken)
		}
	}

	onRight := func(right Expression, state WorkArea, node BinaryExpression) *BinaryExpression {
		if !state.skip {
			maybeBound := maybeBind(right)
			if node.operatorToken.kind == SyntaxKindCommaToken {
				b.maybeBindExpressionFlowIfCall(right)
			}
			return maybeBound
		}
	}

	onExit := func(node BinaryExpression, state WorkArea) {
		if !state.skip {
			operator := node.operatorToken.kind
			if isAssignmentOperator(operator) && !isAssignmentTarget(node) {
				b.bindAssignmentTargetFlow(node.left)
				if operator == SyntaxKindEqualsToken && node.left.kind == SyntaxKindElementAccessExpression {
					elementAccess := node.left.AsElementAccessExpression()
					if b.isNarrowableOperand(elementAccess.expression) {
						b.currentFlow = b.createFlowMutation(FlowFlagsArrayMutation, b.currentFlow, node)
					}
				}
			}
		}
		savedInStrictMode := state.inStrictModeStack[state.stackIndex]
		savedParent := state.parentStack[state.stackIndex]
		if savedInStrictMode != nil {
			b.inStrictMode = savedInStrictMode
		}
		if savedParent != nil {
			b.parent = savedParent
		}
		state.skip = false
		state.stackIndex--
	}

	maybeBind := func(node *Node) *BinaryExpression {
		if node && isBinaryExpression(node) && !isDestructuringAssignment(node) {
			return node
		}
		b.bind(node)
	}

}

func (b *Binder) bindDeleteExpressionFlow(node DeleteExpression) {
	b.bindEachChild(node)
	if node.expression.kind == SyntaxKindPropertyAccessExpression {
		b.bindAssignmentTargetFlow(node.expression)
	}
}

func (b *Binder) bindConditionalExpressionFlow(node ConditionalExpression) {
	trueLabel := b.createBranchLabel()
	falseLabel := b.createBranchLabel()
	postExpressionLabel := b.createBranchLabel()
	saveCurrentFlow := b.currentFlow
	saveHasFlowEffects := b.hasFlowEffects
	b.hasFlowEffects = false
	b.bindCondition(node.condition, trueLabel, falseLabel)
	b.currentFlow = b.finishFlowLabel(trueLabel)
	b.bind(node.questionToken)
	b.bind(node.whenTrue)
	b.addAntecedent(postExpressionLabel, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(falseLabel)
	b.bind(node.colonToken)
	b.bind(node.whenFalse)
	b.addAntecedent(postExpressionLabel, b.currentFlow)
	if b.hasFlowEffects {
		b.currentFlow = b.finishFlowLabel(postExpressionLabel)
	} else {
		b.currentFlow = saveCurrentFlow
	}
	b.hasFlowEffects = b.hasFlowEffects || saveHasFlowEffects
}

func (b *Binder) bindInitializedVariableFlow(node Union[VariableDeclaration, ArrayBindingElement]) {
	var name *BindingName
	if !isOmittedExpression(node) {
		name = node.name
	} else {
		name = nil
	}
	if isBindingPattern(name) {
		for _, child := range name.elements {
			b.bindInitializedVariableFlow(child)
		}
	} else {
		b.currentFlow = b.createFlowMutation(FlowFlagsAssignment, b.currentFlow, node)
	}
}

func (b *Binder) bindVariableDeclarationFlow(node VariableDeclaration) {
	b.bindEachChild(node)
	if node.initializer != nil || isForInOrOfStatement(node.parent.parent) {
		b.bindInitializedVariableFlow(node)
	}
}

func (b *Binder) bindBindingElementFlow(node BindingElement) {
	// When evaluating a binding pattern, the initializer is evaluated before the binding pattern, per:
	// - https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
	//   - `BindingElement: BindingPattern Initializer?`
	// - https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization
	//   - `BindingElement: BindingPattern Initializer?`
	b.bind(node.dotDotDotToken)
	b.bind(node.propertyName)
	b.bindInitializer(node.initializer)
	b.bind(node.name)
}

func (b *Binder) bindParameterFlow(node ParameterDeclaration) {
	b.bindEach(node.modifiers)
	b.bind(node.dotDotDotToken)
	b.bind(node.questionToken)
	b.bind(node.type_)
	b.bindInitializer(node.initializer)
	b.bind(node.name)
}

// a BindingElement/Parameter does not have side effects if initializers are not evaluated and used. (see GH#49759)
func (b *Binder) bindInitializer(node Expression) {
	if !(node != nil) {
		return
	}
	entryFlow := b.currentFlow
	b.bind(node)
	if entryFlow == b.unreachableFlow || entryFlow == b.currentFlow {
		return
	}
	exitFlow := b.createBranchLabel()
	b.addAntecedent(exitFlow, entryFlow)
	b.addAntecedent(exitFlow, b.currentFlow)
	b.currentFlow = b.finishFlowLabel(exitFlow)
}

func (b *Binder) bindJSDocTypeAlias(node Union[JSDocTypedefTag, JSDocCallbackTag, JSDocEnumTag]) {
	b.bind(node.tagName)
	if node.kind != SyntaxKindJSDocEnumTag && node.fullName != nil {
		// don't bind the type name yet; that's delayed until delayedBindJSDocTypedefTag
		setParent(node.fullName, node)
		setParentRecursive(node.fullName, false /*incremental*/)
	}
	if /* TODO(TS-TO-GO) Expression TypeOfExpression: typeof node.comment */ TODO != "string" {
		b.bindEach(node.comment)
	}
}

func (b *Binder) bindJSDocClassTag(node JSDocClassTag) {
	b.bindEachChild(node)
	host := getHostSignatureFromJSDoc(node)
	if host != nil && host.kind != SyntaxKindMethodDeclaration {
		b.addDeclarationToSymbol(host.symbol, host, SymbolFlagsClass)
	}
}

func (b *Binder) bindJSDocImportTag(node JSDocImportTag) {
	// don't bind the importClause yet; that's delayed until bindJSDocImports
	b.bind(node.tagName)
	b.bind(node.moduleSpecifier)
	b.bind(node.attributes)

	if /* TODO(TS-TO-GO) Expression TypeOfExpression: typeof node.comment */ TODO != "string" {
		b.bindEach(node.comment)
	}
}

func (b *Binder) bindOptionalExpression(node Expression, trueTarget FlowLabel, falseTarget FlowLabel) {
	b.doWithConditionalBranches(b.bind, node, trueTarget, falseTarget)
	if !isOptionalChain(node) || isOutermostOptionalChain(node) {
		b.addAntecedent(trueTarget, b.createFlowCondition(FlowFlagsTrueCondition, b.currentFlow, node))
		b.addAntecedent(falseTarget, b.createFlowCondition(FlowFlagsFalseCondition, b.currentFlow, node))
	}
}

func (b *Binder) bindOptionalChainRest(node OptionalChain) {
	switch node.kind {
	case SyntaxKindPropertyAccessExpression:
		b.bind(node.questionDotToken)
		b.bind(node.name)
	case SyntaxKindElementAccessExpression:
		b.bind(node.questionDotToken)
		b.bind(node.argumentExpression)
	case SyntaxKindCallExpression:
		b.bind(node.questionDotToken)
		b.bindEach(node.typeArguments)
		b.bindEach(node.arguments)
	}
}

func (b *Binder) bindOptionalChain(node OptionalChain, trueTarget FlowLabel, falseTarget FlowLabel) {
	// For an optional chain, we emulate the behavior of a logical expression:
	//
	// a?.b         -> a && a.b
	// a?.b.c       -> a && a.b.c
	// a?.b?.c      -> a && a.b && a.b.c
	// a?.[x = 1]   -> a && a[x = 1]
	//
	// To do this we descend through the chain until we reach the root of a chain (the expression with a `?.`)
	// and build it's CFA graph as if it were the first condition (`a && ...`). Then we bind the rest
	// of the node as part of the "true" branch, and continue to do so as we ascend back up to the outermost
	// chain node. We then treat the entire node as the right side of the expression.
	var preChainLabel *FlowLabel
	if isOptionalChainRoot(node) {
		preChainLabel = b.createBranchLabel()
	} else {
		preChainLabel = nil
	}
	b.bindOptionalExpression(node.expression, preChainLabel || trueTarget, falseTarget)
	if preChainLabel != nil {
		b.currentFlow = b.finishFlowLabel(preChainLabel)
	}
	b.doWithConditionalBranches(b.bindOptionalChainRest, node, trueTarget, falseTarget)
	if isOutermostOptionalChain(node) {
		b.addAntecedent(trueTarget, b.createFlowCondition(FlowFlagsTrueCondition, b.currentFlow, node))
		b.addAntecedent(falseTarget, b.createFlowCondition(FlowFlagsFalseCondition, b.currentFlow, node))
	}
}

func (b *Binder) bindOptionalChainFlow(node OptionalChain) {
	if b.isTopLevelLogicalExpression(node) {
		postExpressionLabel := b.createBranchLabel()
		saveCurrentFlow := b.currentFlow
		saveHasFlowEffects := b.hasFlowEffects
		b.bindOptionalChain(node, postExpressionLabel, postExpressionLabel)
		if b.hasFlowEffects {
			b.currentFlow = b.finishFlowLabel(postExpressionLabel)
		} else {
			b.currentFlow = saveCurrentFlow
		}
		b.hasFlowEffects = b.hasFlowEffects || saveHasFlowEffects
	} else {
		b.bindOptionalChain(node, b.currentTrueTarget, b.currentFalseTarget)
	}
}

func (b *Binder) bindNonNullExpressionFlow(node Union[NonNullExpression, NonNullChain]) {
	if isOptionalChain(node) {
		b.bindOptionalChainFlow(node)
	} else {
		b.bindEachChild(node)
	}
}

func (b *Binder) bindAccessExpressionFlow(node Union[AccessExpression, PropertyAccessChain, ElementAccessChain]) {
	if isOptionalChain(node) {
		b.bindOptionalChainFlow(node)
	} else {
		b.bindEachChild(node)
	}
}

func (b *Binder) bindCallExpressionFlow(node Union[CallExpression, CallChain]) {
	if isOptionalChain(node) {
		b.bindOptionalChainFlow(node)
	} else {
		// If the target of the call expression is a function expression or arrow function we have
		// an immediately invoked function expression (IIFE). Initialize the flowNode property to
		// the current control flow (which includes evaluation of the IIFE arguments).
		expr := skipParentheses(node.expression)
		if expr.kind == SyntaxKindFunctionExpression || expr.kind == SyntaxKindArrowFunction {
			b.bindEach(node.typeArguments)
			b.bindEach(node.arguments)
			b.bind(node.expression)
		} else {
			b.bindEachChild(node)
			if node.expression.kind == SyntaxKindSuperKeyword {
				b.currentFlow = b.createFlowCall(b.currentFlow, node)
			}
		}
	}
	if node.expression.kind == SyntaxKindPropertyAccessExpression {
		propertyAccess := node.expression.AsPropertyAccessExpression()
		if isIdentifier(propertyAccess.name) && b.isNarrowableOperand(propertyAccess.expression) && isPushOrUnshiftIdentifier(propertyAccess.name) {
			b.currentFlow = b.createFlowMutation(FlowFlagsArrayMutation, b.currentFlow, node)
		}
	}
}

func (b *Binder) addToContainerChain(next HasLocals) {
	if b.lastContainer {
		b.lastContainer.nextContainer = next
	}

	b.lastContainer = next
}

func (b *Binder) declareSymbolAndAddToSymbolTable(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) *Symbol {
	switch b.container.kind {
	case SyntaxKindModuleDeclaration:
		return b.declareModuleMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindSourceFile:
		return b.declareSourceFileMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindClassExpression,
		SyntaxKindClassDeclaration:
		return b.declareClassMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindEnumDeclaration:
		return b.declareSymbol(b.container.symbol.exports, b.container.symbol, node, symbolFlags, symbolExcludes)
	case SyntaxKindTypeLiteral,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindJsxAttributes:
		// Interface/Object-types always have their children added to the 'members' of
		// their container. They are only accessible through an instance of their
		// container, and are never in scope otherwise (even inside the body of the
		// object / type / interface declaring them). An exception is type parameters,
		// which are in scope without qualification (similar to 'locals').
		return b.declareSymbol(b.container.symbol.members, b.container.symbol, node, symbolFlags, symbolExcludes)
	case SyntaxKindFunctionType,
		SyntaxKindConstructorType,
		SyntaxKindCallSignature,
		SyntaxKindConstructSignature,
		SyntaxKindJSDocSignature,
		SyntaxKindIndexSignature,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindConstructor,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindJSDocFunctionType,
		SyntaxKindClassStaticBlockDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindMappedType:
		// All the children of these container types are never visible through another
		// symbol (i.e. through another symbol's 'exports' or 'members').  Instead,
		// they're only accessed 'lexically' (i.e. from code that exists underneath
		// their container in the tree). To accomplish this, we simply add their declared
		// symbol to the 'locals' of the container.  These symbols can then be found as
		// the type checker walks up the containers, checking them for matching names.
		if b.container.locals != nil {
			Debug.assertNode(b.container, canHaveLocals)
		}
		return b.declareSymbol(b.container.locals, nil /*parent*/, node, symbolFlags, symbolExcludes)
	}
}

func (b *Binder) declareClassMember(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) *Symbol {
	if isStatic(node) {
		return b.declareSymbol(b.container.symbol.exports, b.container.symbol, node, symbolFlags, symbolExcludes)
	} else {
		return b.declareSymbol(b.container.symbol.members, b.container.symbol, node, symbolFlags, symbolExcludes)
	}
}

func (b *Binder) declareSourceFileMember(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) *Symbol {
	if isExternalModule(b.file) {
		return b.declareModuleMember(node, symbolFlags, symbolExcludes)
	} else {
		return b.declareSymbol(b.file.locals, nil /*parent*/, node, symbolFlags, symbolExcludes)
	}
}

func (b *Binder) hasExportDeclarations(node Union[ModuleDeclaration, SourceFile]) bool {
	var body * /* TODO(TS-TO-GO) inferred type SourceFile | ModuleBlock */ any
	if isSourceFile(node) {
		body = node
	} else {
		body = tryCast(node.body, isModuleBlock)
	}
	return body != nil && body.statements.some(func(s Statement) bool {
		return isExportDeclaration(s) || isExportAssignment(s)
	})
}

func (b *Binder) setExportContextFlag(node Mutable[Union[ModuleDeclaration, SourceFile]]) {
	// A declaration source file or ambient module declaration that contains no export declarations (but possibly regular
	// declarations with export modifiers) is an export context in which declarations are implicitly exported.
	if node.flags&NodeFlagsAmbient != 0 && !b.hasExportDeclarations(node) {
		node.flags |= NodeFlagsExportContext
	} else {
		node.flags &^= NodeFlagsExportContext
	}
}

func (b *Binder) bindModuleDeclaration(node ModuleDeclaration) {
	b.setExportContextFlag(node)
	if isAmbientModule(node) {
		if hasSyntacticModifier(node, ModifierFlagsExport) {
			b.errorOnFirstToken(node, Diagnostics.export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible)
		}
		if isModuleAugmentationExternal(node) {
			b.declareModuleSymbol(node)
		} else {
			var pattern Union[string, Pattern, undefined]
			if node.name.kind == SyntaxKindStringLiteral {
				TODO_IDENTIFIER := node.name
				pattern = tryParsePattern(text)
				if pattern == nil {
					b.errorOnFirstToken(node.name, Diagnostics.Pattern_0_can_have_at_most_one_Asterisk_character, text)
				}
			}

			symbol := b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsValueModule, SymbolFlagsValueModuleExcludes)
			b.file.patternAmbientModules = append(b.file.patternAmbientModules, ifElse(pattern && !isString(pattern), &PatternAmbientModule{
				pattern: pattern,
				symbol:  symbol,
			}, nil))
		}
	} else {
		state := b.declareModuleSymbol(node)
		if state != ModuleInstanceStateNonInstantiated {
			TODO_IDENTIFIER := node
			// if module was already merged with some function, class or non-const enum, treat it as non-const-enum-only
			symbol.constEnumOnlyModule = (!(symbol.flags&(SymbolFlagsFunction|SymbolFlagsClass|SymbolFlagsRegularEnum) != 0)) && state == ModuleInstanceStateConstEnumOnly && symbol.constEnumOnlyModule != false
		}
	}
}

func (b *Binder) declareModuleSymbol(node ModuleDeclaration) ModuleInstanceState {
	state := getModuleInstanceState(node)
	instantiated := state != ModuleInstanceStateNonInstantiated
	b.declareSymbolAndAddToSymbolTable(node, ifElse(instantiated, SymbolFlagsValueModule, SymbolFlagsNamespaceModule), ifElse(instantiated, SymbolFlagsValueModuleExcludes, SymbolFlagsNamespaceModuleExcludes))
	return state
}

func (b *Binder) bindFunctionOrConstructorType(node Union[SignatureDeclaration, JSDocSignature]) {
	// For a given function symbol "<...>(...) => T" we want to generate a symbol identical
	// to the one we would get for: { <...>(...): T }
	//
	// We do that by making an anonymous type literal symbol, and then setting the function
	// symbol as its sole member. To the rest of the system, this symbol will be indistinguishable
	// from an actual type literal symbol you would have gotten had you used the long form.
	symbol := b.createSymbol(SymbolFlagsSignature, b.getDeclarationName(node))
	// TODO: GH#18217
	b.addDeclarationToSymbol(symbol, node, SymbolFlagsSignature)

	typeLiteralSymbol := b.createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
	b.addDeclarationToSymbol(typeLiteralSymbol, node, SymbolFlagsTypeLiteral)
	typeLiteralSymbol.members = createSymbolTable()
	typeLiteralSymbol.members.set(symbol.escapedName, symbol)
}

func (b *Binder) bindObjectLiteralExpression(node ObjectLiteralExpression) *Symbol {
	return b.bindAnonymousDeclaration(node, SymbolFlagsObjectLiteral, InternalSymbolNameObject)
}

func (b *Binder) bindJsxAttributes(node JsxAttributes) *Symbol {
	return b.bindAnonymousDeclaration(node, SymbolFlagsObjectLiteral, InternalSymbolNameJSXAttributes)
}

func (b *Binder) bindJsxAttribute(node JsxAttribute, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) *Symbol {
	return b.declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes)
}

func (b *Binder) bindAnonymousDeclaration(node Declaration, symbolFlags SymbolFlags, name string) *Symbol {
	symbol := b.createSymbol(symbolFlags, name)
	if symbolFlags&(SymbolFlagsEnumMember|SymbolFlagsClassMember) != 0 {
		symbol.parent = b.container.symbol
	}
	b.addDeclarationToSymbol(symbol, node, symbolFlags)
	return symbol
}

func (b *Binder) bindBlockScopedDeclaration(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) {
	switch b.blockScopeContainer.kind {
	case SyntaxKindModuleDeclaration:
		b.declareModuleMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindSourceFile:
		if isExternalOrCommonJsModule(b.container.AsSourceFile()) {
			b.declareModuleMember(node, symbolFlags, symbolExcludes)
			break
		}
		fallthrough
	default:
		Debug.assertNode(b.blockScopeContainer, canHaveLocals)
		if !(b.blockScopeContainer.locals != nil) {
			b.blockScopeContainer.locals = createSymbolTable()
			b.addToContainerChain(b.blockScopeContainer)
		}
		b.declareSymbol(b.blockScopeContainer.locals, nil /*parent*/, node, symbolFlags, symbolExcludes)
	}
}

func (b *Binder) delayedBindJSDocTypedefTag() undefined {
	if !b.delayedTypeAliases {
		return
	}
	saveContainer := b.container
	saveLastContainer := b.lastContainer
	saveBlockScopeContainer := b.blockScopeContainer
	saveParent := b.parent
	saveCurrentFlow := b.currentFlow
	for _, typeAlias := range b.delayedTypeAliases {
		host := typeAlias.parent.parent
		b.container = (getEnclosingContainer(host) /* as IsContainer | undefined */) || b.file
		b.blockScopeContainer = (getEnclosingBlockScopeContainer(host) /* as IsBlockScopedContainer | undefined */) || b.file
		b.currentFlow = createFlowNode(FlowFlagsStart, nil /*node*/, nil /*antecedent*/)
		b.parent = typeAlias
		b.bind(typeAlias.typeExpression)
		declName := getNameOfDeclaration(typeAlias)
		if (isJSDocEnumTag(typeAlias) || !(typeAlias.fullName != nil)) && declName != nil && isPropertyAccessEntityNameExpression(declName.parent) {
			// typedef anchored to an A.B.C assignment - we need to bind into B's namespace under name C
			isTopLevel := b.isTopLevelNamespaceAssignment(declName.parent)
			if isTopLevel {
				b.bindPotentiallyMissingNamespaces(b.file.symbol, declName.parent, isTopLevel, findAncestor(declName, func(d *Node) bool {
					return isPropertyAccessExpression(d) && d.name.escapedText == "prototype"
				}) != nil, false /*containerIsClass*/)
				oldContainer := b.container
				switch getAssignmentDeclarationPropertyAccessKind(declName.parent) {
				case AssignmentDeclarationKindExportsProperty,
					AssignmentDeclarationKindModuleExports:
					if !isExternalOrCommonJsModule(b.file) {
						b.container = nil
					} else {
						b.container = b.file
					}
				case AssignmentDeclarationKindThisProperty:
					b.container = declName.parent.expression
				case AssignmentDeclarationKindPrototypeProperty:
					b.container = (declName.parent.expression.AsPropertyAccessEntityNameExpression()).name
				case AssignmentDeclarationKindProperty:
					switch {
					case isExportsOrModuleExportsOrAlias(b.file, declName.parent.expression):
						b.container = b.file
					case isPropertyAccessExpression(declName.parent.expression):
						b.container = declName.parent.expression.name
					default:
						b.container = declName.parent.expression
					}
				case AssignmentDeclarationKindNone:
					return Debug.fail("Shouldn't have detected typedef or enum on non-assignment declaration")
				}
				if b.container {
					b.declareModuleMember(typeAlias, SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
				}
				b.container = oldContainer
			}
		} else if isJSDocEnumTag(typeAlias) || !(typeAlias.fullName != nil) || typeAlias.fullName.kind == SyntaxKindIdentifier {
			b.parent = typeAlias.parent
			b.bindBlockScopedDeclaration(typeAlias, SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
		} else {
			b.bind(typeAlias.fullName)
		}
	}
	b.container = saveContainer
	b.lastContainer = saveLastContainer
	b.blockScopeContainer = saveBlockScopeContainer
	b.parent = saveParent
	b.currentFlow = saveCurrentFlow
}

func (b *Binder) bindJSDocImports() {
	if b.jsDocImports == nil {
		return
	}

	saveContainer := b.container
	saveLastContainer := b.lastContainer
	saveBlockScopeContainer := b.blockScopeContainer
	saveParent := b.parent
	saveCurrentFlow := b.currentFlow

	for _, jsDocImportTag := range b.jsDocImports {
		host := getJSDocHost(jsDocImportTag)
		var enclosingContainer *IsContainer
		if host != nil {
			enclosingContainer = getEnclosingContainer(host) /* as IsContainer | undefined */
		} else {
			enclosingContainer = nil
		}
		var enclosingBlockScopeContainer *IsBlockScopedContainer
		if host != nil {
			enclosingBlockScopeContainer = getEnclosingBlockScopeContainer(host) /* as IsBlockScopedContainer | undefined */
		} else {
			enclosingBlockScopeContainer = nil
		}
		b.container = enclosingContainer || b.file
		b.blockScopeContainer = enclosingBlockScopeContainer || b.file
		b.currentFlow = createFlowNode(FlowFlagsStart, nil /*node*/, nil /*antecedent*/)
		b.parent = jsDocImportTag
		b.bind(jsDocImportTag.importClause)
	}

	b.container = saveContainer
	b.lastContainer = saveLastContainer
	b.blockScopeContainer = saveBlockScopeContainer
	b.parent = saveParent
	b.currentFlow = saveCurrentFlow
}

// The binder visits every node in the syntax tree so it is a convenient place to perform a single localized
// check for reserved words used as identifiers in strict mode code, as well as `yield` or `await` in
// [Yield] or [Await] contexts, respectively.
func (b *Binder) checkContextualIdentifier(node Identifier) {
	// Report error only if there are no parse errors in file
	if !(b.file.parseDiagnostics.length != 0) && !(node.flags&NodeFlagsAmbient != 0) && !(node.flags&NodeFlagsJSDoc != 0) && !isIdentifierName(node) {
		// strict mode identifiers
		originalKeywordKind := identifierToKeywordKind(node)
		if originalKeywordKind == nil {
			return
		}

		if b.inStrictMode && originalKeywordKind >= SyntaxKindFirstFutureReservedWord && originalKeywordKind <= SyntaxKindLastFutureReservedWord {
			b.file.bindDiagnostics.push(b.createDiagnosticForNode(node, b.getStrictModeIdentifierMessage(node), declarationNameToString(node)))
		} else if originalKeywordKind == SyntaxKindAwaitKeyword {
			if isExternalModule(b.file) && isInTopLevelContext(node) {
				b.file.bindDiagnostics.push(b.createDiagnosticForNode(node, Diagnostics.Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module, declarationNameToString(node)))
			} else if node.flags&NodeFlagsAwaitContext != 0 {
				b.file.bindDiagnostics.push(b.createDiagnosticForNode(node, Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, declarationNameToString(node)))
			}
		} else if originalKeywordKind == SyntaxKindYieldKeyword && node.flags&NodeFlagsYieldContext != 0 {
			b.file.bindDiagnostics.push(b.createDiagnosticForNode(node, Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, declarationNameToString(node)))
		}
	}
}

func (b *Binder) getStrictModeIdentifierMessage(node *Node) any {
	// Provide specialized messages to help the user understand why we think they're in
	// strict mode.
	if getContainingClass(node) != nil {
		return Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode
	}

	if b.file.externalModuleIndicator {
		return Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode
	}

	return Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode
}

// The binder visits every node, so this is a good place to check for
// the reserved private name (there is only one)
func (b *Binder) checkPrivateIdentifier(node PrivateIdentifier) {
	if node.escapedText == "#constructor" {
		// Report error only if there are no parse errors in file
		if !(b.file.parseDiagnostics.length != 0) {
			b.file.bindDiagnostics.push(b.createDiagnosticForNode(node, Diagnostics.constructor_is_a_reserved_word, declarationNameToString(node)))
		}
	}
}

func (b *Binder) checkStrictModeBinaryExpression(node BinaryExpression) {
	if b.inStrictMode && isLeftHandSideExpression(node.left) && isAssignmentOperator(node.operatorToken.kind) {
		// ECMA 262 (Annex C) The identifier eval or arguments may not appear as the LeftHandSideExpression of an
		// Assignment operator(11.13) or of a PostfixExpression(11.3)
		b.checkStrictModeEvalOrArguments(node, node.left.AsIdentifier())
	}
}

func (b *Binder) checkStrictModeCatchClause(node CatchClause) {
	// It is a SyntaxError if a TryStatement with a Catch occurs within strict code and the Identifier of the
	// Catch production is eval or arguments
	if b.inStrictMode && node.variableDeclaration != nil {
		b.checkStrictModeEvalOrArguments(node, node.variableDeclaration.name)
	}
}

func (b *Binder) checkStrictModeDeleteExpression(node DeleteExpression) {
	// Grammar checking
	if b.inStrictMode && node.expression.kind == SyntaxKindIdentifier {
		// When a delete operator occurs within strict mode code, a SyntaxError is thrown if its
		// UnaryExpression is a direct reference to a variable, function argument, or function name
		span := getErrorSpanForNode(b.file, node.expression)
		b.file.bindDiagnostics.push(createFileDiagnostic(b.file, span.start, span.length, Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode))
	}
}

func (b *Binder) isEvalOrArgumentsIdentifier(node *Node) bool {
	return isIdentifier(node) && (node.escapedText == "eval" || node.escapedText == "arguments")
}

func (b *Binder) checkStrictModeEvalOrArguments(contextNode *Node, name *Node) {
	if name != nil && name.kind == SyntaxKindIdentifier {
		identifier := name.AsIdentifier()
		if b.isEvalOrArgumentsIdentifier(identifier) {
			// We check first if the name is inside class declaration or class expression; if so give explicit message
			// otherwise report generic error message.
			span := getErrorSpanForNode(b.file, name)
			b.file.bindDiagnostics.push(createFileDiagnostic(b.file, span.start, span.length, b.getStrictModeEvalOrArgumentsMessage(contextNode), idText(identifier)))
		}
	}
}

func (b *Binder) getStrictModeEvalOrArgumentsMessage(node *Node) any {
	// Provide specialized messages to help the user understand why we think they're in
	// strict mode.
	if getContainingClass(node) != nil {
		return Diagnostics.Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode
	}

	if b.file.externalModuleIndicator {
		return Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode
	}

	return Diagnostics.Invalid_use_of_0_in_strict_mode
}

func (b *Binder) checkStrictModeFunctionName(node FunctionLikeDeclaration) {
	if b.inStrictMode && !(node.flags&NodeFlagsAmbient != 0) {
		// It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a strict mode FunctionDeclaration or FunctionExpression (13.1))
		b.checkStrictModeEvalOrArguments(node, node.name)
	}
}

func (b *Binder) getStrictModeBlockScopeFunctionDeclarationMessage(node *Node) any {
	// Provide specialized messages to help the user understand why we think they're in
	// strict mode.
	if getContainingClass(node) != nil {
		return Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Class_definitions_are_automatically_in_strict_mode
	}

	if b.file.externalModuleIndicator {
		return Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Modules_are_automatically_in_strict_mode
	}

	return Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5
}

func (b *Binder) checkStrictModeFunctionDeclaration(node FunctionDeclaration) {
	if b.languageVersion < ScriptTargetES2015 {
		// Report error if function is not top level function declaration
		if b.blockScopeContainer.kind != SyntaxKindSourceFile && b.blockScopeContainer.kind != SyntaxKindModuleDeclaration && !isFunctionLikeOrClassStaticBlockDeclaration(b.blockScopeContainer) {
			// We check first if the name is inside class declaration or class expression; if so give explicit message
			// otherwise report generic error message.
			errorSpan := getErrorSpanForNode(b.file, node)
			b.file.bindDiagnostics.push(createFileDiagnostic(b.file, errorSpan.start, errorSpan.length, b.getStrictModeBlockScopeFunctionDeclarationMessage(node)))
		}
	}
}

func (b *Binder) checkStrictModePostfixUnaryExpression(node PostfixUnaryExpression) {
	// Grammar checking
	// The identifier eval or arguments may not appear as the LeftHandSideExpression of an
	// Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression
	// operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator.
	if b.inStrictMode {
		b.checkStrictModeEvalOrArguments(node, node.operand.AsIdentifier())
	}
}

func (b *Binder) checkStrictModePrefixUnaryExpression(node PrefixUnaryExpression) {
	// Grammar checking
	if b.inStrictMode {
		if node.operator == SyntaxKindPlusPlusToken || node.operator == SyntaxKindMinusMinusToken {
			b.checkStrictModeEvalOrArguments(node, node.operand.AsIdentifier())
		}
	}
}

func (b *Binder) checkStrictModeWithStatement(node WithStatement) {
	// Grammar checking for withStatement
	if b.inStrictMode {
		b.errorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_strict_mode)
	}
}

func (b *Binder) checkStrictModeLabeledStatement(node LabeledStatement) {
	// Grammar checking for labeledStatement
	if b.inStrictMode && getEmitScriptTarget(b.options) >= ScriptTargetES2015 {
		if isDeclarationStatement(node.statement) || isVariableStatement(node.statement) {
			b.errorOnFirstToken(node.label, Diagnostics.A_label_is_not_allowed_here)
		}
	}
}

func (b *Binder) errorOnFirstToken(node *Node, message DiagnosticMessage, args DiagnosticArguments) {
	span := getSpanOfTokenAtPosition(b.file, node.pos)
	b.file.bindDiagnostics.push(createFileDiagnostic(b.file, span.start, span.length, message, args...))
}

func (b *Binder) errorOrSuggestionOnNode(isError bool, node *Node, message DiagnosticMessage) {
	b.errorOrSuggestionOnRange(isError, node, node, message)
}

func (b *Binder) errorOrSuggestionOnRange(isError bool, startNode *Node, endNode *Node, message DiagnosticMessage) {
	b.addErrorOrSuggestionDiagnostic(isError, TextRange{
		pos: getTokenPosOfNode(startNode, b.file),
		end: endNode.end,
	}, message)
}

func (b *Binder) addErrorOrSuggestionDiagnostic(isError bool, range_ TextRange, message DiagnosticMessage) {
	diag := createFileDiagnostic(b.file, range_.pos, range_.end-range_.pos, message)
	if isError {
		b.file.bindDiagnostics.push(diag)
	} else {
		b.file.bindSuggestionDiagnostics = append(b.file.bindSuggestionDiagnostics, DiagnosticWithLocation{
			/* TODO(TS-TO-GO) Node SpreadAssignment: ...diag */
			category: DiagnosticCategorySuggestion,
		})
	}
}

func (b *Binder) bind(node *Node) {
	if !(node != nil) {
		return
	}
	setParent(node, b.parent)
	if tracing != nil {
		(node.(TracingNode)).tracingPath = b.file.path
	}
	saveInStrictMode := b.inStrictMode

	// Even though in the AST the jsdoc @typedef node belongs to the current node,
	// its symbol might be in the same scope with the current node's symbol. Consider:
	//
	//     /** @typedef {string | number} MyType */
	//     function foo();
	//
	// Here the current node is "foo", which is a container, but the scope of "MyType" should
	// not be inside "foo". Therefore we always bind @typedef before bind the parent node,
	// and skip binding this tag later when binding all the other jsdoc tags.

	// First we bind declaration nodes to a symbol if possible. We'll both create a symbol
	// and then potentially add the symbol to an appropriate symbol table. Possible
	// destination symbol tables are:
	//
	//  1) The 'exports' table of the current container's symbol.
	//  2) The 'members' table of the current container's symbol.
	//  3) The 'locals' table of the current container.
	//
	// However, not all symbols will end up in any of these tables. 'Anonymous' symbols
	// (like TypeLiterals for example) will not be put in any table.
	b.bindWorker(node)
	// Then we recurse into the children of the node to bind them as well. For certain
	// symbols we do specialized work when we recurse. For example, we'll keep track of
	// the current 'container' node when it changes. This helps us know which symbol table
	// a local should go into for example. Since terminal nodes are known not to have
	// children, as an optimization we don't process those.
	if node.kind > SyntaxKindLastToken {
		saveParent := b.parent
		b.parent = node
		containerFlags := getContainerFlags(node)
		if containerFlags == ContainerFlagsNone {
			b.bindChildren(node)
		} else {
			b.bindContainer(node.AsHasContainerFlags(), containerFlags)
		}
		b.parent = saveParent
	} else {
		saveParent := b.parent
		if node.kind == SyntaxKindEndOfFileToken {
			b.parent = node
		}
		b.bindJSDoc(node)
		b.parent = saveParent
	}
	b.inStrictMode = saveInStrictMode
}

func (b *Binder) bindJSDoc(node *Node) {
	if hasJSDocNodes(node) {
		if isInJSFile(node) {
			for _, j := range node.jsDoc {
				b.bind(j)
			}
		} else {
			for _, j := range node.jsDoc {
				setParent(j, node)
				setParentRecursive(j, false /*incremental*/)
			}
		}
	}
}

func (b *Binder) updateStrictModeStatementList(statements NodeArray[Statement]) {
	if !b.inStrictMode {
		for _, statement := range statements {
			if !isPrologueDirective(statement) {
				return
			}

			if b.isUseStrictPrologueDirective(statement.AsExpressionStatement()) {
				b.inStrictMode = true
				return
			}
		}
	}
}

// / Should be called only on prologue directives (isPrologueDirective(node) should be true)
func (b *Binder) isUseStrictPrologueDirective(node ExpressionStatement) bool {
	nodeText := getSourceTextOfNodeFromSourceFile(b.file, node.expression)

	// Note: the node text must be exactly "use strict" or 'use strict'.  It is not ok for the
	// string to contain unicode escapes (as per ES5).
	return nodeText == "\"use strict\"" || nodeText == "'use strict'"
}

func (b *Binder) bindWorker(node *Node) /* TODO(TS-TO-GO) inferred type number | void | Symbol */ any {
	switch node.kind {
	case SyntaxKindIdentifier:
		// for typedef type names with namespaces, bind the new jsdoc type symbol here
		// because it requires all containing namespaces to be in effect, namely the
		// current "blockScopeContainer" needs to be set to its immediate namespace parent.
		if node.flags&NodeFlagsIdentifierIsInJSDocNamespace != 0 {
			parentNode := node.parent
			for parentNode && !isJSDocTypeAlias(parentNode) {
				parentNode = parentNode.parent
			}
			b.bindBlockScopedDeclaration(parentNode.AsDeclaration(), SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
			break
		}
		fallthrough
	case SyntaxKindThisKeyword:
		// TODO: Why use `isExpression` here? both Identifier and ThisKeyword are expressions.
		if b.currentFlow && (isExpression(node) || b.parent.kind == SyntaxKindShorthandPropertyAssignment) {
			(node /* as Identifier | ThisExpression */).flowNode = b.currentFlow
		}
		// TODO: a `ThisExpression` is not an Identifier, this cast is unsound
		return b.checkContextualIdentifier(node.AsIdentifier())
	case SyntaxKindQualifiedName:
		if b.currentFlow && isPartOfTypeQuery(node) {
			(node.AsQualifiedName()).flowNode = b.currentFlow
		}
	case SyntaxKindMetaProperty,
		SyntaxKindSuperKeyword:
		(node /* as MetaProperty | SuperExpression */).flowNode = b.currentFlow
	case SyntaxKindPrivateIdentifier:
		return b.checkPrivateIdentifier(node.AsPrivateIdentifier())
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		expr := node /* as PropertyAccessExpression | ElementAccessExpression */
		if b.currentFlow && b.isNarrowableReference(expr) {
			expr.flowNode = b.currentFlow
		}
		if isSpecialPropertyDeclaration(expr) {
			b.bindSpecialPropertyDeclaration(expr)
		}
		if isInJSFile(expr) && b.file.commonJsModuleIndicator != nil && isModuleExportsAccessExpression(expr) && !(lookupSymbolForName(b.blockScopeContainer, "module" /* as __String */) != nil) {
			b.declareSymbol(b.file.locals, nil /*parent*/, expr.expression, SymbolFlagsFunctionScopedVariable|SymbolFlagsModuleExports, SymbolFlagsFunctionScopedVariableExcludes)
		}
	case SyntaxKindBinaryExpression:
		specialKind := getAssignmentDeclarationKind(node.AsBinaryExpression())
		switch specialKind {
		case AssignmentDeclarationKindExportsProperty:
			b.bindExportsPropertyAssignment(node.AsBindableStaticPropertyAssignmentExpression())
		case AssignmentDeclarationKindModuleExports:
			b.bindModuleExportsAssignment(node.AsBindablePropertyAssignmentExpression())
		case AssignmentDeclarationKindPrototypeProperty:
			b.bindPrototypePropertyAssignment((node.AsBindableStaticPropertyAssignmentExpression()).left, node)
		case AssignmentDeclarationKindPrototype:
			b.bindPrototypeAssignment(node.AsBindableStaticPropertyAssignmentExpression())
		case AssignmentDeclarationKindThisProperty:
			b.bindThisPropertyAssignment(node.AsBindablePropertyAssignmentExpression())
		case AssignmentDeclarationKindProperty:
			expression := ((node.AsBinaryExpression()).left.AsAccessExpression()).expression
			if isInJSFile(node) && isIdentifier(expression) {
				symbol := lookupSymbolForName(b.blockScopeContainer, expression.escapedText)
				if isThisInitializedDeclaration(symbol. /* ? */ valueDeclaration) {
					b.bindThisPropertyAssignment(node.AsBindablePropertyAssignmentExpression())
					break
				}
			}
			b.bindSpecialPropertyAssignment(node.AsBindablePropertyAssignmentExpression())
		case AssignmentDeclarationKindNone:
			// Nothing to do
		default:
			Debug.fail("Unknown binary expression special property assignment kind")
		}
		return b.checkStrictModeBinaryExpression(node.AsBinaryExpression())
	case SyntaxKindCatchClause:
		return b.checkStrictModeCatchClause(node.AsCatchClause())
	case SyntaxKindDeleteExpression:
		return b.checkStrictModeDeleteExpression(node.AsDeleteExpression())
	case SyntaxKindPostfixUnaryExpression:
		return b.checkStrictModePostfixUnaryExpression(node.AsPostfixUnaryExpression())
	case SyntaxKindPrefixUnaryExpression:
		return b.checkStrictModePrefixUnaryExpression(node.AsPrefixUnaryExpression())
	case SyntaxKindWithStatement:
		return b.checkStrictModeWithStatement(node.AsWithStatement())
	case SyntaxKindLabeledStatement:
		return b.checkStrictModeLabeledStatement(node.AsLabeledStatement())
	case SyntaxKindThisType:
		b.seenThisKeyword = true
		return
	case SyntaxKindTypePredicate:
	case SyntaxKindTypeParameter:
		return b.bindTypeParameter(node.AsTypeParameterDeclaration())
	case SyntaxKindParameter:
		return b.bindParameter(node.AsParameterDeclaration())
	case SyntaxKindVariableDeclaration:
		return b.bindVariableDeclarationOrBindingElement(node.AsVariableDeclaration())
	case SyntaxKindBindingElement:
		(node.AsBindingElement()).flowNode = b.currentFlow
		return b.bindVariableDeclarationOrBindingElement(node.AsBindingElement())
	case SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature:
		return b.bindPropertyWorker(node /* as PropertyDeclaration | PropertySignature */)
	case SyntaxKindPropertyAssignment,
		SyntaxKindShorthandPropertyAssignment:
		return b.bindPropertyOrMethodOrAccessor(node.AsDeclaration(), SymbolFlagsProperty, SymbolFlagsPropertyExcludes)
	case SyntaxKindEnumMember:
		return b.bindPropertyOrMethodOrAccessor(node.AsDeclaration(), SymbolFlagsEnumMember, SymbolFlagsEnumMemberExcludes)
	case SyntaxKindCallSignature,
		SyntaxKindConstructSignature,
		SyntaxKindIndexSignature:
		return b.declareSymbolAndAddToSymbolTable(node.AsDeclaration(), SymbolFlagsSignature, SymbolFlagsNone)
	case SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature:
		// If this is an ObjectLiteralExpression method, then it sits in the same space
		// as other properties in the object literal.  So we use SymbolFlags.PropertyExcludes
		// so that it will conflict with any other object literal members with the same
		// name.
		return b.bindPropertyOrMethodOrAccessor(node.AsDeclaration(), SymbolFlagsMethod|(ifElse((node.AsMethodDeclaration()).questionToken != nil, SymbolFlagsOptional, SymbolFlagsNone)), ifElse(isObjectLiteralMethod(node), SymbolFlagsPropertyExcludes, SymbolFlagsMethodExcludes))
	case SyntaxKindFunctionDeclaration:
		return b.bindFunctionDeclaration(node.AsFunctionDeclaration())
	case SyntaxKindConstructor:
		return b.declareSymbolAndAddToSymbolTable(node.AsDeclaration(), SymbolFlagsConstructor, SymbolFlagsNone /*symbolExcludes:*/)
	case SyntaxKindGetAccessor:
		return b.bindPropertyOrMethodOrAccessor(node.AsDeclaration(), SymbolFlagsGetAccessor, SymbolFlagsGetAccessorExcludes)
	case SyntaxKindSetAccessor:
		return b.bindPropertyOrMethodOrAccessor(node.AsDeclaration(), SymbolFlagsSetAccessor, SymbolFlagsSetAccessorExcludes)
	case SyntaxKindFunctionType,
		SyntaxKindJSDocFunctionType,
		SyntaxKindJSDocSignature,
		SyntaxKindConstructorType:
		return b.bindFunctionOrConstructorType(node /* as SignatureDeclaration | JSDocSignature */)
	case SyntaxKindTypeLiteral,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindMappedType:
		return b.bindAnonymousTypeWorker(node /* as TypeLiteralNode | MappedTypeNode | JSDocTypeLiteral */)
	case SyntaxKindJSDocClassTag:
		return b.bindJSDocClassTag(node.AsJSDocClassTag())
	case SyntaxKindObjectLiteralExpression:
		return b.bindObjectLiteralExpression(node.AsObjectLiteralExpression())
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return b.bindFunctionExpression(node /* as FunctionExpression | ArrowFunction */)
	case SyntaxKindCallExpression:
		assignmentKind := getAssignmentDeclarationKind(node.AsCallExpression())
		switch assignmentKind {
		case AssignmentDeclarationKindObjectDefinePropertyValue:
			return b.bindObjectDefinePropertyAssignment(node.AsBindableObjectDefinePropertyCall())
		case AssignmentDeclarationKindObjectDefinePropertyExports:
			return b.bindObjectDefinePropertyExport(node.AsBindableObjectDefinePropertyCall())
		case AssignmentDeclarationKindObjectDefinePrototypeProperty:
			return b.bindObjectDefinePrototypeProperty(node.AsBindableObjectDefinePropertyCall())
		case AssignmentDeclarationKindNone:
		default:
			return Debug.fail("Unknown call expression assignment declaration kind")
		}
		if isInJSFile(node) {
			b.bindCallExpression(node.AsCallExpression())
		}

		// Members of classes, interfaces, and modules
	case SyntaxKindClassExpression,
		SyntaxKindClassDeclaration:
		// All classes are automatically in strict mode in ES6.
		b.inStrictMode = true
		return b.bindClassLikeDeclaration(node.AsClassLikeDeclaration())
	case SyntaxKindInterfaceDeclaration:
		return b.bindBlockScopedDeclaration(node.AsDeclaration(), SymbolFlagsInterface, SymbolFlagsInterfaceExcludes)
	case SyntaxKindTypeAliasDeclaration:
		return b.bindBlockScopedDeclaration(node.AsDeclaration(), SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
	case SyntaxKindEnumDeclaration:
		return b.bindEnumDeclaration(node.AsEnumDeclaration())
	case SyntaxKindModuleDeclaration:
		return b.bindModuleDeclaration(node.AsModuleDeclaration())
		// Jsx-attributes
	case SyntaxKindJsxAttributes:
		return b.bindJsxAttributes(node.AsJsxAttributes())
	case SyntaxKindJsxAttribute:
		return b.bindJsxAttribute(node.AsJsxAttribute(), SymbolFlagsProperty, SymbolFlagsPropertyExcludes)

		// Imports and exports
	case SyntaxKindImportEqualsDeclaration,
		SyntaxKindNamespaceImport,
		SyntaxKindImportSpecifier,
		SyntaxKindExportSpecifier:
		return b.declareSymbolAndAddToSymbolTable(node.AsDeclaration(), SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	case SyntaxKindNamespaceExportDeclaration:
		return b.bindNamespaceExportDeclaration(node.AsNamespaceExportDeclaration())
	case SyntaxKindImportClause:
		return b.bindImportClause(node.AsImportClause())
	case SyntaxKindExportDeclaration:
		return b.bindExportDeclaration(node.AsExportDeclaration())
	case SyntaxKindExportAssignment:
		return b.bindExportAssignment(node.AsExportAssignment())
	case SyntaxKindSourceFile:
		b.updateStrictModeStatementList((node.AsSourceFile()).statements)
		return b.bindSourceFileIfExternalModule()
	case SyntaxKindBlock:
		if !isFunctionLikeOrClassStaticBlockDeclaration(node.parent) {
			return
		}
		fallthrough
	case SyntaxKindModuleBlock:
		return b.updateStrictModeStatementList((node /* as Block | ModuleBlock */).statements)
	case SyntaxKindJSDocParameterTag:
		if node.parent.kind == SyntaxKindJSDocSignature {
			return b.bindParameter(node.AsJSDocParameterTag())
		}
		if node.parent.kind != SyntaxKindJSDocTypeLiteral {
			break
		}
		fallthrough
	case SyntaxKindJSDocPropertyTag:
		propTag := node.AsJSDocPropertyLikeTag()
		var flags number
		if propTag.isBracketed || propTag.typeExpression != nil && propTag.typeExpression.type_.kind == SyntaxKindJSDocOptionalType {
			flags = SymbolFlagsProperty | SymbolFlagsOptional
		} else {
			flags = SymbolFlagsProperty
		}
		return b.declareSymbolAndAddToSymbolTable(propTag, flags, SymbolFlagsPropertyExcludes)
	case SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocEnumTag:
		return (b.delayedTypeAliases || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: delayedTypeAliases = [] */ TODO)).push(node /* as JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag */)
	case SyntaxKindJSDocOverloadTag:
		return b.bind((node.AsJSDocOverloadTag()).typeExpression)
	case SyntaxKindJSDocImportTag:
		return (b.jsDocImports || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: jsDocImports = [] */ TODO)).push(node.AsJSDocImportTag())
	}
}

func (b *Binder) bindPropertyWorker(node Union[PropertyDeclaration, PropertySignature]) *Symbol {
	isAutoAccessor := isAutoAccessorPropertyDeclaration(node)
	var includes /* TODO(TS-TO-GO) inferred type SymbolFlags.Property | SymbolFlags.Accessor */ any
	if isAutoAccessor {
		includes = SymbolFlagsAccessor
	} else {
		includes = SymbolFlagsProperty
	}
	var excludes /* TODO(TS-TO-GO) inferred type SymbolFlags.None | SymbolFlags.AccessorExcludes */ any
	if isAutoAccessor {
		excludes = SymbolFlagsAccessorExcludes
	} else {
		excludes = SymbolFlagsPropertyExcludes
	}
	return b.bindPropertyOrMethodOrAccessor(node, includes|(ifElse(node.questionToken != nil, SymbolFlagsOptional, SymbolFlagsNone)), excludes)
}

func (b *Binder) bindAnonymousTypeWorker(node Union[TypeLiteralNode, MappedTypeNode, JSDocTypeLiteral]) *Symbol {
	return b.bindAnonymousDeclaration(node.AsDeclaration(), SymbolFlagsTypeLiteral, InternalSymbolNameType)
}

func (b *Binder) bindSourceFileIfExternalModule() {
	b.setExportContextFlag(b.file)
	if isExternalModule(b.file) {
		b.bindSourceFileAsExternalModule()
	} else if isJsonSourceFile(b.file) {
		b.bindSourceFileAsExternalModule()
		// Create symbol equivalent for the module.exports = {}
		originalSymbol := b.file.symbol
		b.declareSymbol(b.file.symbol.exports, b.file.symbol, b.file, SymbolFlagsProperty, SymbolFlagsAll)
		b.file.symbol = originalSymbol
	}
}

func (b *Binder) bindSourceFileAsExternalModule() {
	b.bindAnonymousDeclaration(b.file, SymbolFlagsValueModule, __TEMPLATE__("\"", removeFileExtension(b.file.fileName), "\"").(string))
}

func (b *Binder) bindExportAssignment(node ExportAssignment) {
	if !b.container.symbol || !(b.container.symbol.exports != nil) {
		// Incorrect export assignment in some sort of block construct
		b.bindAnonymousDeclaration(node, SymbolFlagsValue, b.getDeclarationName(node))
	} else {
		var flags /* TODO(TS-TO-GO) inferred type SymbolFlags.Property | SymbolFlags.Alias */ any
		if exportAssignmentIsAlias(node) {
			flags = SymbolFlagsAlias
		} else {
			flags = SymbolFlagsProperty
		}
		// If there is an `export default x;` alias declaration, can't `export default` anything else.
		// (In contrast, you can still have `export default function f() {}` and `export default interface I {}`.)
		symbol := b.declareSymbol(b.container.symbol.exports, b.container.symbol, node, flags, SymbolFlagsAll)

		if node.isExportEquals {
			// Will be an error later, since the module already has other exports. Just make sure this has a valueDeclaration set.
			setValueDeclaration(symbol, node)
		}
	}
}

func (b *Binder) bindNamespaceExportDeclaration(node NamespaceExportDeclaration) {
	if some(node.modifiers) {
		b.file.bindDiagnostics.push(b.createDiagnosticForNode(node, Diagnostics.Modifiers_cannot_appear_here))
	}
	var diag any
	switch {
	case !isSourceFile(node.parent):
		diag = Diagnostics.Global_module_exports_may_only_appear_at_top_level
	case !isExternalModule(node.parent):
		diag = Diagnostics.Global_module_exports_may_only_appear_in_module_files
	case !node.parent.isDeclarationFile:
		diag = Diagnostics.Global_module_exports_may_only_appear_in_declaration_files
	default:
		diag = nil
	}
	if diag {
		b.file.bindDiagnostics.push(b.createDiagnosticForNode(node, diag))
	} else {
		b.file.symbol.globalExports = b.file.symbol.globalExports || createSymbolTable()
		b.declareSymbol(b.file.symbol.globalExports, b.file.symbol, node, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	}
}

func (b *Binder) bindExportDeclaration(node ExportDeclaration) {
	if !b.container.symbol || !(b.container.symbol.exports != nil) {
		// Export * in some sort of block construct
		b.bindAnonymousDeclaration(node, SymbolFlagsExportStar, b.getDeclarationName(node))
	} else if !(node.exportClause != nil) {
		// All export * declarations are collected in an __export symbol
		b.declareSymbol(b.container.symbol.exports, b.container.symbol, node, SymbolFlagsExportStar, SymbolFlagsNone)
	} else if isNamespaceExport(node.exportClause) {
		// declareSymbol walks up parents to find name text, parent _must_ be set
		// but won't be set by the normal binder walk until `bindChildren` later on.
		setParent(node.exportClause, node)
		b.declareSymbol(b.container.symbol.exports, b.container.symbol, node.exportClause, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	}
}

func (b *Binder) bindImportClause(node ImportClause) {
	if node.name != nil {
		b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	}
}

func (b *Binder) setCommonJsModuleIndicator(node *Node) bool {
	if b.file.externalModuleIndicator && b.file.externalModuleIndicator != true {
		return false
	}
	if !(b.file.commonJsModuleIndicator != nil) {
		b.file.commonJsModuleIndicator = node
		if !b.file.externalModuleIndicator {
			b.bindSourceFileAsExternalModule()
		}
	}
	return true
}

func (b *Binder) bindObjectDefinePropertyExport(node BindableObjectDefinePropertyCall) {
	if !b.setCommonJsModuleIndicator(node) {
		return
	}
	symbol := b.forEachIdentifierInEntityName(node.arguments[0], nil /*parent*/, func(id Declaration, symbol *Symbol) *Symbol {
		if symbol != nil {
			b.addDeclarationToSymbol(symbol, id, SymbolFlagsModule|SymbolFlagsAssignment)
		}
		return symbol
	})
	if symbol != nil {
		flags := SymbolFlagsProperty | SymbolFlagsExportValue
		b.declareSymbol(symbol.exports, symbol, node, flags, SymbolFlagsNone)
	}
}

func (b *Binder) bindExportsPropertyAssignment(node BindableStaticPropertyAssignmentExpression) {
	// When we create a property via 'exports.foo = bar', the 'exports.foo' property access
	// expression is the declaration
	if !b.setCommonJsModuleIndicator(node) {
		return
	}
	symbol := b.forEachIdentifierInEntityName(node.left.expression, nil /*parent*/, func(id Declaration, symbol *Symbol) *Symbol {
		if symbol != nil {
			b.addDeclarationToSymbol(symbol, id, SymbolFlagsModule|SymbolFlagsAssignment)
		}
		return symbol
	})
	if symbol != nil {
		isAlias := isAliasableExpression(node.right) && (isExportsIdentifier(node.left.expression) || isModuleExportsAccessExpression(node.left.expression))
		var flags number
		if isAlias {
			flags = SymbolFlagsAlias
		} else {
			flags = SymbolFlagsProperty | SymbolFlagsExportValue
		}
		setParent(node.left, node)
		b.declareSymbol(symbol.exports, symbol, node.left, flags, SymbolFlagsNone)
	}
}

func (b *Binder) bindModuleExportsAssignment(node BindablePropertyAssignmentExpression) {
	// A common practice in node modules is to set 'export = module.exports = {}', this ensures that 'exports'
	// is still pointing to 'module.exports'.
	// We do not want to consider this as 'export=' since a module can have only one of these.
	// Similarly we do not want to treat 'module.exports = exports' as an 'export='.
	if !b.setCommonJsModuleIndicator(node) {
		return
	}
	assignedExpression := getRightMostAssignedExpression(node.right)
	if isEmptyObjectLiteral(assignedExpression) || b.container == b.file && isExportsOrModuleExportsOrAlias(b.file, assignedExpression) {
		return
	}

	if isObjectLiteralExpression(assignedExpression) && every(assignedExpression.properties, isShorthandPropertyAssignment) {
		forEach(assignedExpression.properties, b.bindExportAssignedObjectMemberAlias)
		return
	}

	// 'module.exports = expr' assignment
	var flags number
	if exportAssignmentIsAlias(node) {
		flags = SymbolFlagsAlias
	} else {
		flags = SymbolFlagsProperty | SymbolFlagsExportValue | SymbolFlagsValueModule
	}
	symbol := b.declareSymbol(b.file.symbol.exports, b.file.symbol, node, flags|SymbolFlagsAssignment, SymbolFlagsNone)
	setValueDeclaration(symbol, node)
}

func (b *Binder) bindExportAssignedObjectMemberAlias(node ShorthandPropertyAssignment) {
	b.declareSymbol(b.file.symbol.exports, b.file.symbol, node, SymbolFlagsAlias|SymbolFlagsAssignment, SymbolFlagsNone)
}

func (b *Binder) bindThisPropertyAssignment(node Union[BindablePropertyAssignmentExpression, PropertyAccessExpression, LiteralLikeElementAccessExpression]) {
	Debug.assert(isInJSFile(node))
	// private identifiers *must* be declared (even in JS files)
	hasPrivateIdentifier := (isBinaryExpression(node) && isPropertyAccessExpression(node.left) && isPrivateIdentifier(node.left.name)) || (isPropertyAccessExpression(node) && isPrivateIdentifier(node.name))
	if hasPrivateIdentifier {
		return
	}
	thisContainer := getThisContainer(node, false /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/)
	switch thisContainer.kind {
	case SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression:
		var constructorSymbol *Symbol = thisContainer.symbol
		// For `f.prototype.m = function() { this.x = 0; }`, `this.x = 0` should modify `f`'s members, not the function expression.
		if isBinaryExpression(thisContainer.parent) && thisContainer.parent.operatorToken.kind == SyntaxKindEqualsToken {
			l := thisContainer.parent.left
			if isBindableStaticAccessExpression(l) && isPrototypeAccess(l.expression) {
				constructorSymbol = b.lookupSymbolForPropertyAccess(l.expression.expression, b.thisParentContainer)
			}
		}

		if constructorSymbol != nil && constructorSymbol.valueDeclaration != nil {
			// Declare a 'member' if the container is an ES5 class or ES6 constructor
			constructorSymbol.members = constructorSymbol.members || createSymbolTable()
			// It's acceptable for multiple 'this' assignments of the same identifier to occur
			if hasDynamicName(node) {
				b.bindDynamicallyNamedThisPropertyAssignment(node, constructorSymbol, constructorSymbol.members)
			} else {
				b.declareSymbol(constructorSymbol.members, constructorSymbol, node, SymbolFlagsProperty|SymbolFlagsAssignment, SymbolFlagsPropertyExcludes & ^SymbolFlagsProperty)
			}
			b.addDeclarationToSymbol(constructorSymbol, constructorSymbol.valueDeclaration, SymbolFlagsClass)
		}
	case SyntaxKindConstructor,
		SyntaxKindPropertyDeclaration,
		SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindClassStaticBlockDeclaration:
		// this.foo assignment in a JavaScript class
		// Bind this property to the containing class
		containingClass := thisContainer.parent
		var symbolTable SymbolTable
		if isStatic(thisContainer) {
			symbolTable = containingClass.symbol.exports
		} else {
			symbolTable = containingClass.symbol.members
		}
		if hasDynamicName(node) {
			b.bindDynamicallyNamedThisPropertyAssignment(node, containingClass.symbol, symbolTable)
		} else {
			b.declareSymbol(symbolTable, containingClass.symbol, node, SymbolFlagsProperty|SymbolFlagsAssignment, SymbolFlagsNone, true /*isReplaceableByMethod*/)
		}
	case SyntaxKindSourceFile:
		// this.property = assignment in a source file -- declare symbol in exports for a module, in locals for a script
		if hasDynamicName(node) {
			break
		} else if thisContainer.commonJsModuleIndicator != nil {
			b.declareSymbol(thisContainer.symbol.exports, thisContainer.symbol, node, SymbolFlagsProperty|SymbolFlagsExportValue, SymbolFlagsNone)
		} else {
			b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsFunctionScopedVariableExcludes)
		}
		// Namespaces are not allowed in javascript files, so do nothing here
	case SyntaxKindModuleDeclaration:
	default:
		Debug.failBadSyntaxKind(thisContainer)
	}
}

func (b *Binder) bindDynamicallyNamedThisPropertyAssignment(node Union[BinaryExpression, DynamicNamedDeclaration], symbol *Symbol, symbolTable SymbolTable) {
	b.declareSymbol(symbolTable, symbol, node, SymbolFlagsProperty, SymbolFlagsNone, true /*isReplaceableByMethod*/, true /*isComputedName*/)
	b.addLateBoundAssignmentDeclarationToSymbol(node, symbol)
}

func (b *Binder) addLateBoundAssignmentDeclarationToSymbol(node Union[BinaryExpression, DynamicNamedDeclaration], symbol *Symbol) {
	if symbol != nil {
		(symbol.assignmentDeclarationMembers || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symbol.assignmentDeclarationMembers = new Map() */ TODO)).set(getNodeId(node), node)
	}
}

func (b *Binder) bindSpecialPropertyDeclaration(node Union[PropertyAccessExpression, LiteralLikeElementAccessExpression]) {
	if node.expression.kind == SyntaxKindThisKeyword {
		b.bindThisPropertyAssignment(node)
	} else if isBindableStaticAccessExpression(node) && node.parent.parent.kind == SyntaxKindSourceFile {
		if isPrototypeAccess(node.expression) {
			b.bindPrototypePropertyAssignment(node, node.parent)
		} else {
			b.bindStaticPropertyAssignment(node)
		}
	}
}

/** For `x.prototype = { p, ... }`, declare members p,... if `x` is function/class/{}, or not declared. */

func (b *Binder) bindPrototypeAssignment(node BindableStaticPropertyAssignmentExpression) {
	setParent(node.left, node)
	setParent(node.right, node)
	b.bindPropertyAssignment(node.left.expression, node.left, false /*isPrototypeProperty*/, true /*containerIsClass*/)
}

func (b *Binder) bindObjectDefinePrototypeProperty(node BindableObjectDefinePropertyCall) {
	namespaceSymbol := b.lookupSymbolForPropertyAccess((node.arguments[0].AsPropertyAccessExpression()).expression.AsEntityNameExpression())
	if namespaceSymbol != nil && namespaceSymbol.valueDeclaration != nil {
		// Ensure the namespace symbol becomes class-like
		b.addDeclarationToSymbol(namespaceSymbol, namespaceSymbol.valueDeclaration, SymbolFlagsClass)
	}
	b.bindPotentiallyNewExpandoMemberToNamespace(node, namespaceSymbol, true /*isPrototypeProperty*/)
}

/**
 * For `x.prototype.y = z`, declare a member `y` on `x` if `x` is a function or class, or not declared.
 * Note that jsdoc preceding an ExpressionStatement like `x.prototype.y;` is also treated as a declaration.
 */

func (b *Binder) bindPrototypePropertyAssignment(lhs BindableStaticAccessExpression, parent *Node) {
	// Look up the function in the local scope, since prototype assignments should
	// follow the function declaration
	classPrototype := lhs.expression.AsBindableStaticAccessExpression()
	constructorFunction := classPrototype.expression

	// Fix up parent pointers since we're going to use these nodes before we bind into them
	setParent(constructorFunction, classPrototype)
	setParent(classPrototype, lhs)
	setParent(lhs, b.parent)

	b.bindPropertyAssignment(constructorFunction, lhs, true /*isPrototypeProperty*/, true /*containerIsClass*/)
}

func (b *Binder) bindObjectDefinePropertyAssignment(node BindableObjectDefinePropertyCall) {
	namespaceSymbol := b.lookupSymbolForPropertyAccess(node.arguments[0])
	isToplevel := node.parent.parent.kind == SyntaxKindSourceFile
	namespaceSymbol = b.bindPotentiallyMissingNamespaces(namespaceSymbol, node.arguments[0], isToplevel, false /*isPrototypeProperty*/, false /*containerIsClass*/)
	b.bindPotentiallyNewExpandoMemberToNamespace(node, namespaceSymbol, false /*isPrototypeProperty*/)
}

func (b *Binder) bindSpecialPropertyAssignment(node BindablePropertyAssignmentExpression) {
	// Class declarations in Typescript do not allow property declarations
	parentSymbol := b.lookupSymbolForPropertyAccess(node.left.expression, b.blockScopeContainer) || b.lookupSymbolForPropertyAccess(node.left.expression, b.container)
	if !isInJSFile(node) && !isFunctionSymbol(parentSymbol) {
		return
	}
	rootExpr := getLeftmostAccessExpression(node.left)
	if isIdentifier(rootExpr) && lookupSymbolForName(b.container, rootExpr.escapedText). /* ? */ flags&SymbolFlagsAlias != 0 {
		return
	}
	// Fix up parent pointers since we're going to use these nodes before we bind into them
	setParent(node.left, node)
	setParent(node.right, node)
	if isIdentifier(node.left.expression) && b.container == b.file && isExportsOrModuleExportsOrAlias(b.file, node.left.expression) {
		// This can be an alias for the 'exports' or 'module.exports' names, e.g.
		//    var util = module.exports;
		//    util.property = function ...
		b.bindExportsPropertyAssignment(node.AsBindableStaticPropertyAssignmentExpression())
	} else if hasDynamicName(node) {
		b.bindAnonymousDeclaration(node, SymbolFlagsProperty|SymbolFlagsAssignment, InternalSymbolNameComputed)
		sym := b.bindPotentiallyMissingNamespaces(parentSymbol, node.left.expression, b.isTopLevelNamespaceAssignment(node.left), false /*isPrototypeProperty*/, false /*containerIsClass*/)
		b.addLateBoundAssignmentDeclarationToSymbol(node, sym)
	} else {
		b.bindStaticPropertyAssignment(cast(node.left, isBindableStaticNameExpression))
	}
}

/**
 * For nodes like `x.y = z`, declare a member 'y' on 'x' if x is a function (or IIFE) or class or {}, or not declared.
 * Also works for expression statements preceded by JSDoc, like / ** @type number * / x.y;
 */

func (b *Binder) bindStaticPropertyAssignment(node BindableStaticNameExpression) {
	Debug.assert(!isIdentifier(node))
	setParent(node.expression, node)
	b.bindPropertyAssignment(node.expression, node, false /*isPrototypeProperty*/, false /*containerIsClass*/)
}

func (b *Binder) bindPotentiallyMissingNamespaces(namespaceSymbol *Symbol, entityName BindableStaticNameExpression, isToplevel bool, isPrototypeProperty bool, containerIsClass bool) *Symbol {
	if namespaceSymbol. /* ? */ flags&SymbolFlagsAlias != 0 {
		return namespaceSymbol
	}
	if isToplevel && !isPrototypeProperty {
		// make symbols or add declarations for intermediate containers
		flags := SymbolFlagsModule | SymbolFlagsAssignment
		excludeFlags := SymbolFlagsValueModuleExcludes & ^SymbolFlagsAssignment
		namespaceSymbol = b.forEachIdentifierInEntityName(entityName, namespaceSymbol, func(id Declaration, symbol *Symbol, parent *Symbol) *Symbol {
			if symbol != nil {
				b.addDeclarationToSymbol(symbol, id, flags)
				return symbol
			} else {
				var table SymbolTable
				if parent != nil {
					table = parent.exports
				} else {
					table = b.file.jsGlobalAugmentations || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: file.jsGlobalAugmentations = createSymbolTable() */ TODO)
				}
				return b.declareSymbol(table, parent, id, flags, excludeFlags)
			}
		})
	}
	if containerIsClass && namespaceSymbol != nil && namespaceSymbol.valueDeclaration != nil {
		b.addDeclarationToSymbol(namespaceSymbol, namespaceSymbol.valueDeclaration, SymbolFlagsClass)
	}
	return namespaceSymbol
}

func (b *Binder) bindPotentiallyNewExpandoMemberToNamespace(declaration Union[BindableStaticAccessExpression, CallExpression], namespaceSymbol *Symbol, isPrototypeProperty bool) {
	if !(namespaceSymbol != nil) || !b.isExpandoSymbol(namespaceSymbol) {
		return
	}

	// Set up the members collection if it doesn't exist already
	var symbolTable SymbolTable
	if isPrototypeProperty {
		symbolTable = (namespaceSymbol.members || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: namespaceSymbol.members = createSymbolTable() */ TODO))
	} else {
		symbolTable = (namespaceSymbol.exports || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: namespaceSymbol.exports = createSymbolTable() */ TODO))
	}

	includes := SymbolFlagsNone
	excludes := SymbolFlagsNone
	// Method-like
	if isFunctionLikeDeclaration(getAssignedExpandoInitializer(declaration)) {
		includes = SymbolFlagsMethod
		excludes = SymbolFlagsMethodExcludes
	} else if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
		if some(declaration.arguments[2].properties, func(p /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) bool {
			id := getNameOfDeclaration(p)
			return id != nil && isIdentifier(id) && idText(id) == "set"
		}) {
			// We mix in `SymbolFLags.Property` so in the checker `getTypeOfVariableParameterOrProperty` is used for this
			// symbol, instead of `getTypeOfAccessor` (which will assert as there is no real accessor declaration)
			includes |= SymbolFlagsSetAccessor | SymbolFlagsProperty
			excludes |= SymbolFlagsSetAccessorExcludes
		}
		if some(declaration.arguments[2].properties, func(p /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) bool {
			id := getNameOfDeclaration(p)
			return id != nil && isIdentifier(id) && idText(id) == "get"
		}) {
			includes |= SymbolFlagsGetAccessor | SymbolFlagsProperty
			excludes |= SymbolFlagsGetAccessorExcludes
		}
	}

	if includes == SymbolFlagsNone {
		includes = SymbolFlagsProperty
		excludes = SymbolFlagsPropertyExcludes
	}

	b.declareSymbol(symbolTable, namespaceSymbol, declaration, includes|SymbolFlagsAssignment, excludes & ^SymbolFlagsAssignment)
}

func (b *Binder) isTopLevelNamespaceAssignment(propertyAccess BindableAccessExpression) bool {
	if isBinaryExpression(propertyAccess.parent) {
		return b.getParentOfBinaryExpression(propertyAccess.parent).parent.kind == SyntaxKindSourceFile
	} else {
		return propertyAccess.parent.parent.kind == SyntaxKindSourceFile
	}
}

func (b *Binder) bindPropertyAssignment(name BindableStaticNameExpression, propertyAccess BindableStaticAccessExpression, isPrototypeProperty bool, containerIsClass bool) {
	namespaceSymbol := b.lookupSymbolForPropertyAccess(name, b.blockScopeContainer) || b.lookupSymbolForPropertyAccess(name, b.container)
	isToplevel := b.isTopLevelNamespaceAssignment(propertyAccess)
	namespaceSymbol = b.bindPotentiallyMissingNamespaces(namespaceSymbol, propertyAccess.expression, isToplevel, isPrototypeProperty, containerIsClass)
	b.bindPotentiallyNewExpandoMemberToNamespace(propertyAccess, namespaceSymbol, isPrototypeProperty)
}

/**
 * Javascript expando values are:
 * - Functions
 * - classes
 * - namespaces
 * - variables initialized with function expressions
 * -                       with class expressions
 * -                       with empty object literals
 * -                       with non-empty object literals if assigned to the prototype property
 */

func (b *Binder) isExpandoSymbol(symbol *Symbol) bool {
	if symbol.flags&(SymbolFlagsFunction|SymbolFlagsClass|SymbolFlagsNamespaceModule) != 0 {
		return true
	}
	node := symbol.valueDeclaration
	if node != nil && isCallExpression(node) {
		return getAssignedExpandoInitializer(node) != nil
	}
	var init Expression
	switch {
	case !(node != nil):
		init = nil
	case isVariableDeclaration(node):
		init = node.initializer
	case isBinaryExpression(node):
		init = node.right
	case isPropertyAccessExpression(node) && isBinaryExpression(node.parent):
		init = node.parent.right
	default:
		init = nil
	}
	init = init && getRightMostAssignedExpression(init)
	if init != nil {
		isPrototypeAssignment := isPrototypeAccess(ifElse(isVariableDeclaration(node), node.name, ifElse(isBinaryExpression(node), node.left, node)))
		return getExpandoInitializer(ifElse(isBinaryExpression(init) && (init.operatorToken.kind == SyntaxKindBarBarToken || init.operatorToken.kind == SyntaxKindQuestionQuestionToken), init.right, init), isPrototypeAssignment) != nil
	}
	return false
}

func (b *Binder) getParentOfBinaryExpression(expr *Node) *Node {
	for isBinaryExpression(expr.parent) {
		expr = expr.parent
	}
	return expr.parent
}

func (b *Binder) lookupSymbolForPropertyAccess(node BindableStaticNameExpression, lookupContainer Union[IsContainer, IsBlockScopedContainer, EntityNameExpression] /*  = container */) *Symbol {
	if isIdentifier(node) {
		return lookupSymbolForName(lookupContainer, node.escapedText)
	} else {
		symbol := b.lookupSymbolForPropertyAccess(node.expression)
		return symbol && symbol.exports && symbol.exports.get(getElementOrPropertyAccessName(node))
	}
}

func (b *Binder) forEachIdentifierInEntityName(e BindableStaticNameExpression, parent *Symbol, action func(e Declaration, symbol *Symbol, parent *Symbol) *Symbol) *Symbol {
	if isExportsOrModuleExportsOrAlias(b.file, e) {
		return b.file.symbol
	} else if isIdentifier(e) {
		return action(e, b.lookupSymbolForPropertyAccess(e), b.parent)
	} else {
		s := b.forEachIdentifierInEntityName(e.expression, b.parent, action)
		name := getNameOrArgument(e)
		// unreachable
		if isPrivateIdentifier(name) {
			Debug.fail("unexpected PrivateIdentifier")
		}
		return action(name, s && s.exports && s.exports.get(getElementOrPropertyAccessName(e)), s)
	}
}

func (b *Binder) bindCallExpression(node CallExpression) {
	// We're only inspecting call expressions to detect CommonJS modules, so we can skip
	// this check if we've already seen the module indicator
	if !(b.file.commonJsModuleIndicator != nil) && isRequireCall(node, false /*requireStringLiteralLikeArgument*/) {
		b.setCommonJsModuleIndicator(node)
	}
}

func (b *Binder) bindClassLikeDeclaration(node ClassLikeDeclaration) {
	if node.kind == SyntaxKindClassDeclaration {
		b.bindBlockScopedDeclaration(node, SymbolFlagsClass, SymbolFlagsClassExcludes)
	} else {
		var bindingName string
		if node.name != nil {
			bindingName = node.name.escapedText
		} else {
			bindingName = InternalSymbolNameClass
		}
		b.bindAnonymousDeclaration(node, SymbolFlagsClass, bindingName)
		// Add name of class expression into the map for semantic classifier
		if node.name != nil {
			b.classifiableNames.add(node.name.escapedText)
		}
	}

	TODO_IDENTIFIER := node

	// TypeScript 1.0 spec (April 2014): 8.4
	// Every class automatically contains a static property member named 'prototype', the
	// type of which is an instantiation of the class type with type Any supplied as a type
	// argument for each type parameter. It is an error to explicitly declare a static
	// property member with the name 'prototype'.
	//
	// Note: we check for this here because this class may be merging into a module.  The
	// module might have an exported variable called 'prototype'.  We can't allow that as
	// that would clash with the built-in 'prototype' for the class.
	prototypeSymbol := b.createSymbol(SymbolFlagsProperty|SymbolFlagsPrototype, "prototype" /* as __String */)
	symbolExport := symbol.exports.get(prototypeSymbol.escapedName)
	if symbolExport != nil {
		if node.name != nil {
			setParent(node.name, node)
		}
		b.file.bindDiagnostics.push(b.createDiagnosticForNode(symbolExport.declarations[0], Diagnostics.Duplicate_identifier_0, symbolName(prototypeSymbol)))
	}
	symbol.exports.set(prototypeSymbol.escapedName, prototypeSymbol)
	prototypeSymbol.parent = symbol
}

func (b *Binder) bindEnumDeclaration(node EnumDeclaration) {
	if isEnumConst(node) {
		return b.bindBlockScopedDeclaration(node, SymbolFlagsConstEnum, SymbolFlagsConstEnumExcludes)
	} else {
		return b.bindBlockScopedDeclaration(node, SymbolFlagsRegularEnum, SymbolFlagsRegularEnumExcludes)
	}
}

func (b *Binder) bindVariableDeclarationOrBindingElement(node Union[VariableDeclaration, BindingElement]) {
	if b.inStrictMode {
		b.checkStrictModeEvalOrArguments(node, node.name)
	}

	if !isBindingPattern(node.name) {
		var possibleVariableDecl /* TODO(TS-TO-GO) inferred type VariableDeclaration | ParameterDeclaration | BindingElement */ any
		if node.kind == SyntaxKindVariableDeclaration {
			possibleVariableDecl = node
		} else {
			possibleVariableDecl = node.parent.parent
		}
		if isInJSFile(node) && isVariableDeclarationInitializedToBareOrAccessedRequire(possibleVariableDecl) && !(getJSDocTypeTag(node) != nil) && !(getCombinedModifierFlags(node)&ModifierFlagsExport != 0) {
			b.declareSymbolAndAddToSymbolTable(node.AsDeclaration(), SymbolFlagsAlias, SymbolFlagsAliasExcludes)
		} else if isBlockOrCatchScoped(node) {
			b.bindBlockScopedDeclaration(node, SymbolFlagsBlockScopedVariable, SymbolFlagsBlockScopedVariableExcludes)
		} else if isPartOfParameterDeclaration(node) {
			// It is safe to walk up parent chain to find whether the node is a destructuring parameter declaration
			// because its parent chain has already been set up, since parents are set before descending into children.
			//
			// If node is a binding element in parameter declaration, we need to use ParameterExcludes.
			// Using ParameterExcludes flag allows the compiler to report an error on duplicate identifiers in Parameter Declaration
			// For example:
			//      function foo([a,a]) {} // Duplicate Identifier error
			//      function bar(a,a) {}   // Duplicate Identifier error, parameter declaration in this case is handled in bindParameter
			//                             // which correctly set excluded symbols
			b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsParameterExcludes)
		} else {
			b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsFunctionScopedVariableExcludes)
		}
	}
}

func (b *Binder) bindParameter(node Union[ParameterDeclaration, JSDocParameterTag]) {
	if node.kind == SyntaxKindJSDocParameterTag && b.container.kind != SyntaxKindJSDocSignature {
		return
	}
	if b.inStrictMode && !(node.flags&NodeFlagsAmbient != 0) {
		// It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a
		// strict mode FunctionLikeDeclaration or FunctionExpression(13.1)
		b.checkStrictModeEvalOrArguments(node, node.name)
	}

	if isBindingPattern(node.name) {
		b.bindAnonymousDeclaration(node, SymbolFlagsFunctionScopedVariable, "__"+(node.AsParameterDeclaration()).parent.parameters.indexOf(node.AsParameterDeclaration()).(string))
	} else {
		b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsParameterExcludes)
	}

	// If this is a property-parameter, then also declare the property symbol into the
	// containing class.
	if isParameterPropertyDeclaration(node, node.parent) {
		classDeclaration := node.parent.parent
		b.declareSymbol(classDeclaration.symbol.members, classDeclaration.symbol, node, SymbolFlagsProperty|(ifElse(node.questionToken != nil, SymbolFlagsOptional, SymbolFlagsNone)), SymbolFlagsPropertyExcludes)
	}
}

func (b *Binder) bindFunctionDeclaration(node FunctionDeclaration) {
	if !b.file.isDeclarationFile && !(node.flags&NodeFlagsAmbient != 0) {
		if isAsyncFunction(node) {
			b.emitFlags |= NodeFlagsHasAsyncFunctions
		}
	}

	b.checkStrictModeFunctionName(node)
	if b.inStrictMode {
		b.checkStrictModeFunctionDeclaration(node)
		b.bindBlockScopedDeclaration(node, SymbolFlagsFunction, SymbolFlagsFunctionExcludes)
	} else {
		b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunction, SymbolFlagsFunctionExcludes)
	}
}

func (b *Binder) bindFunctionExpression(node Union[FunctionExpression, ArrowFunction]) *Symbol {
	if !b.file.isDeclarationFile && !(node.flags&NodeFlagsAmbient != 0) {
		if isAsyncFunction(node) {
			b.emitFlags |= NodeFlagsHasAsyncFunctions
		}
	}
	if b.currentFlow {
		node.flowNode = b.currentFlow
	}
	b.checkStrictModeFunctionName(node)
	var bindingName string
	if node.name != nil {
		bindingName = node.name.escapedText
	} else {
		bindingName = InternalSymbolNameFunction
	}
	return b.bindAnonymousDeclaration(node, SymbolFlagsFunction, bindingName)
}

func (b *Binder) bindPropertyOrMethodOrAccessor(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) *Symbol {
	if !b.file.isDeclarationFile && !(node.flags&NodeFlagsAmbient != 0) && isAsyncFunction(node) {
		b.emitFlags |= NodeFlagsHasAsyncFunctions
	}

	if b.currentFlow && isObjectLiteralOrClassExpressionMethodOrAccessor(node) {
		node.flowNode = b.currentFlow
	}

	if hasDynamicName(node) {
		return b.bindAnonymousDeclaration(node, symbolFlags, InternalSymbolNameComputed)
	} else {
		return b.declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes)
	}
}

func (b *Binder) getInferTypeContainer(node *Node) *ConditionalTypeNode {
	extendsType := findAncestor(node, func(n *Node) bool {
		return n.parent && isConditionalTypeNode(n.parent) && n.parent.extendsType == n
	})
	return extendsType && extendsType.parent.AsConditionalTypeNode()
}

func (b *Binder) bindTypeParameter(node TypeParameterDeclaration) {
	if isJSDocTemplateTag(node.parent) {
		var container *HasLocals = getEffectiveContainerForJSDocTemplateTag(node.parent)
		if container != nil {
			Debug.assertNode(container, canHaveLocals)
			if container.locals == nil {
				container.locals = createSymbolTable()
			}
			b.declareSymbol(container.locals, nil /*parent*/, node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
		} else {
			b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
		}
	} else if node.parent.kind == SyntaxKindInferType {
		var container *HasLocals = b.getInferTypeContainer(node.parent)
		if container != nil {
			Debug.assertNode(container, canHaveLocals)
			if container.locals == nil {
				container.locals = createSymbolTable()
			}
			b.declareSymbol(container.locals, nil /*parent*/, node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
		} else {
			b.bindAnonymousDeclaration(node, SymbolFlagsTypeParameter, b.getDeclarationName(node))
			// TODO: GH#18217
		}
	} else {
		b.declareSymbolAndAddToSymbolTable(node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
	}
}

// reachability checks

func (b *Binder) shouldReportErrorOnModuleDeclaration(node ModuleDeclaration) bool {
	instanceState := getModuleInstanceState(node)
	return instanceState == ModuleInstanceStateInstantiated || (instanceState == ModuleInstanceStateConstEnumOnly && shouldPreserveConstEnums(b.options))
}

func (b *Binder) checkUnreachable(node *Node) bool {
	if !(b.currentFlow.flags&FlowFlagsUnreachable != 0) {
		return false
	}
	if b.currentFlow == b.unreachableFlow {
		reportError := (isStatementButNotDeclaration(node) && node.kind != SyntaxKindEmptyStatement) || node.kind == SyntaxKindClassDeclaration || isEnumDeclarationWithPreservedEmit(node, b.options) || (node.kind == SyntaxKindModuleDeclaration && b.shouldReportErrorOnModuleDeclaration(node.AsModuleDeclaration()))

		if reportError {
			b.currentFlow = b.reportedUnreachableFlow

			if !b.options.allowUnreachableCode {
				// unreachable code is reported if
				// - user has explicitly asked about it AND
				// - statement is in not ambient context (statements in ambient context is already an error
				//   so we should not report extras) AND
				//   - node is not variable statement OR
				//   - node is block scoped variable statement OR
				//   - node is not block scoped variable statement and at least one variable declaration has initializer
				//   Rationale: we don't want to report errors on non-initialized var's since they are hoisted
				//   On the other side we do want to report errors on non-initialized 'lets' because of TDZ
				isError := unreachableCodeIsError(b.options) && !(node.flags&NodeFlagsAmbient != 0) && (!isVariableStatement(node) || getCombinedNodeFlags(node.declarationList)&NodeFlagsBlockScoped != 0 || node.declarationList.declarations.some(func(d VariableDeclaration) bool {
					return d.initializer != nil
				}))

				eachUnreachableRange(node, b.options, func(start *Node, end *Node) {
					return b.errorOrSuggestionOnRange(isError, start, end, Diagnostics.Unreachable_code_detected)
				})
			}
		}
	}
	return true
}

func isEnumDeclarationWithPreservedEmit(node *Node, options CompilerOptions) bool {
	return node.kind == SyntaxKindEnumDeclaration && (!isEnumConst(node.AsEnumDeclaration()) || shouldPreserveConstEnums(options))
}

func eachUnreachableRange(node *Node, options CompilerOptions, cb func(start *Node, last *Node)) {
	if isStatement(node) && isExecutableStatement(node) && isBlock(node.parent) {
		TODO_IDENTIFIER := node.parent
		slice := sliceAfter(statements, node)
		getRangesWhere(slice, isExecutableStatement, func(start number, afterEnd number) {
			return cb(slice[start], slice[afterEnd-1])
		})
	} else {
		cb(node, node)
	}

	// As opposed to a pure declaration like an `interface`
	isExecutableStatement := func(s Statement) bool {
		// Don't remove statements that can validly be used before they appear.
		return !isFunctionDeclaration(s) && !isPurelyTypeDeclaration(s) && !(isVariableStatement(s) && !(getCombinedNodeFlags(s)&(NodeFlagsBlockScoped) != 0) && s.declarationList.declarations.some(func(d VariableDeclaration) bool {
			return !(d.initializer != nil)
		}))
	}

	isPurelyTypeDeclaration := func(s Statement) bool {
		switch s.kind {
		case SyntaxKindInterfaceDeclaration,
			SyntaxKindTypeAliasDeclaration:
			return true
		case SyntaxKindModuleDeclaration:
			return getModuleInstanceState(s.AsModuleDeclaration()) != ModuleInstanceStateInstantiated
		case SyntaxKindEnumDeclaration:
			return !isEnumDeclarationWithPreservedEmit(s, options)
		default:
			return false
		}
	}

}

/** @internal */

func isExportsOrModuleExportsOrAlias(sourceFile SourceFile, node Expression) bool {
	i := 0
	q := createQueue()
	q.enqueue(node)
	for !q.isEmpty() && i < 100 {
		i++
		node = q.dequeue()
		if isExportsIdentifier(node) || isModuleExportsAccessExpression(node) {
			return true
		} else if isIdentifier(node) {
			symbol := lookupSymbolForName(sourceFile, node.escapedText)
			if symbol != nil && symbol.valueDeclaration != nil && isVariableDeclaration(symbol.valueDeclaration) && symbol.valueDeclaration.initializer != nil {
				init := symbol.valueDeclaration.initializer
				q.enqueue(init)
				if isAssignmentExpression(init, true /*excludeCompoundAssignment*/) {
					q.enqueue(init.left)
					q.enqueue(init.right)
				}
			}
		}
	}
	return false
}

/** @internal */

func getContainerFlags(node *Node) ContainerFlags {
	switch node.kind {
	case SyntaxKindClassExpression,
		SyntaxKindClassDeclaration,
		SyntaxKindEnumDeclaration,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindTypeLiteral,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindJsxAttributes:
		return ContainerFlagsIsContainer
	case SyntaxKindInterfaceDeclaration:
		return ContainerFlagsIsContainer | ContainerFlagsIsInterface
	case SyntaxKindModuleDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindMappedType,
		SyntaxKindIndexSignature:
		return ContainerFlagsIsContainer | ContainerFlagsHasLocals
	case SyntaxKindSourceFile:
		return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals
	case SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindMethodDeclaration:
		if isObjectLiteralOrClassExpressionMethodOrAccessor(node) {
			return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals | ContainerFlagsIsFunctionLike | ContainerFlagsIsObjectLiteralOrClassExpressionMethodOrAccessor
		}
		fallthrough
	case SyntaxKindConstructor,
		SyntaxKindFunctionDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindCallSignature,
		SyntaxKindJSDocSignature,
		SyntaxKindJSDocFunctionType,
		SyntaxKindFunctionType,
		SyntaxKindConstructSignature,
		SyntaxKindConstructorType,
		SyntaxKindClassStaticBlockDeclaration:
		return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals | ContainerFlagsIsFunctionLike
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals | ContainerFlagsIsFunctionLike | ContainerFlagsIsFunctionExpression
	case SyntaxKindModuleBlock:
		return ContainerFlagsIsControlFlowContainer
	case SyntaxKindPropertyDeclaration:
		if (node.AsPropertyDeclaration()).initializer != nil {
			return ContainerFlagsIsControlFlowContainer
		} else {
			return 0
		}
	case SyntaxKindCatchClause,
		SyntaxKindForStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement,
		SyntaxKindCaseBlock:
		return ContainerFlagsIsBlockScopedContainer | ContainerFlagsHasLocals
	case SyntaxKindBlock:
		// do not treat blocks directly inside a function as a block-scoped-container.
		// Locals that reside in this block should go to the function locals. Otherwise 'x'
		// would not appear to be a redeclaration of a block scoped local in the following
		// example:
		//
		//      function foo() {
		//          var x;
		//          let x;
		//      }
		//
		// If we placed 'var x' into the function locals and 'let x' into the locals of
		// the block, then there would be no collision.
		//
		// By not creating a new block-scoped-container here, we ensure that both 'var x'
		// and 'let x' go into the Function-container's locals, and we do get a collision
		// conflict.
		if isFunctionLike(node.parent) || isClassStaticBlockDeclaration(node.parent) {
			return ContainerFlagsNone
		} else {
			return ContainerFlagsIsBlockScopedContainer | ContainerFlagsHasLocals
		}
	}

	return ContainerFlagsNone
}

func lookupSymbolForName(container *Node, name string) *Symbol {
	local := tryCast(container, canHaveLocals). /* ? */ locals. /* ? */ get(name)
	if local != nil {
		return ifNotNilElse(local.exportSymbol, local)
	}
	if isSourceFile(container) && container.jsGlobalAugmentations != nil && container.jsGlobalAugmentations.has(name) {
		return container.jsGlobalAugmentations.get(name)
	}
	if canHaveSymbol(container) {
		return container.symbol. /* ? */ exports. /* ? */ get(name)
	}
}
