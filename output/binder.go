// Code generated by ts-to-go at 0e292c441a0e5f27e18803128b7dfb1155ac0f5a. DO NOT EDIT.

package output

func __COND__[C comparable, T any](cond C, a T, b T) T {
	var zero C
	if cond != zero {
		return a
	}
	return b
}

type Binder struct {
	file            SourceFile
	options         CompilerOptions
	languageVersion ScriptTarget
	parent          Node
	container/* TODO(TS-TO-GO) TypeNode UnionType: IsContainer | EntityNameExpression */ any
	thisParentContainer/* TODO(TS-TO-GO) TypeNode UnionType: IsContainer | EntityNameExpression */ any
	blockScopeContainer    IsBlockScopedContainer
	lastContainer          HasLocals
	delayedTypeAliases     [] /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag */ any
	seenThisKeyword        bool
	jsDocImports           []JSDocImportTag
	currentFlow            FlowNode
	currentBreakTarget     *FlowLabel
	currentContinueTarget  *FlowLabel
	currentReturnTarget    *FlowLabel
	currentTrueTarget      *FlowLabel
	currentFalseTarget     *FlowLabel
	currentExceptionTarget *FlowLabel
	preSwitchCaseFlow      *FlowNode
	activeLabelList        *ActiveLabel
	hasExplicitReturn      bool
	hasFlowEffects         bool
	emitFlags              NodeFlags
	inStrictMode           bool
	inAssignmentPattern    bool
	symbolCount            number
	Symbol/* TODO(TS-TO-GO) TypeNode ConstructorType: new (flags: SymbolFlags, name: __String) => Symbol */ any
	classifiableNames       Set[__String]
	unreachableFlow         FlowNode
	reportedUnreachableFlow FlowNode
	bindBinaryExpressionFlow/* TODO(TS-TO-GO) inferred type (node: BinaryExpression) => void */ any
}

/** @internal */

type ModuleInstanceState int32

const (
	ModuleInstanceStateNonInstantiated ModuleInstanceState = 0
	ModuleInstanceStateInstantiated    ModuleInstanceState = 1
	ModuleInstanceStateConstEnumOnly   ModuleInstanceState = 2
)

type ActiveLabel struct {
	next           *ActiveLabel
	name           __String
	breakTarget    FlowLabel
	continueTarget *FlowLabel
	referenced     bool
}

/** @internal */

func getModuleInstanceState(node ModuleDeclaration, visited Map[number, *ModuleInstanceState]) ModuleInstanceState {
	if node.body && !node.body.parent {
		// getModuleInstanceStateForAliasTarget needs to walk up the parent chain, so parent pointers must be set on this tree already
		setParent(node.body, node)
		setParentRecursive(node.body /*incremental*/, false)
	}
	if node.body {
		return getModuleInstanceStateCached(node.body, visited)
	} else {
		return ModuleInstanceStateInstantiated
	}
}

func getModuleInstanceStateCached(node Node, visited Map[number, *ModuleInstanceState] /*  = new Map<number, ModuleInstanceState | undefined>() */) ModuleInstanceState {
	nodeId := getNodeId(node)
	if visited.has(nodeId) {
		return visited.get(nodeId) || ModuleInstanceStateNonInstantiated
	}
	visited.set(nodeId, nil)
	result := getModuleInstanceStateWorker(node, visited)
	visited.set(nodeId, result)
	return result
}

func getModuleInstanceStateWorker(node Node, visited Map[number, *ModuleInstanceState]) ModuleInstanceState {
	// A module is uninstantiated if it contains only
	switch node.kind {
	case SyntaxKindInterfaceDeclaration,
		SyntaxKindTypeAliasDeclaration:
		return ModuleInstanceStateNonInstantiated
	case SyntaxKindEnumDeclaration:
		if isEnumConst(node /* as EnumDeclaration */) {
			return ModuleInstanceStateConstEnumOnly
		}
	case SyntaxKindImportDeclaration,
		SyntaxKindImportEqualsDeclaration:
		if !(hasSyntacticModifier(node, ModifierFlagsExport)) {
			return ModuleInstanceStateNonInstantiated
		}
	case SyntaxKindExportDeclaration:
		exportDeclaration := node /* as ExportDeclaration */
		if !exportDeclaration.moduleSpecifier && exportDeclaration.exportClause && exportDeclaration.exportClause.kind == SyntaxKindNamedExports {
			state := ModuleInstanceStateNonInstantiated
			for _, specifier := range exportDeclaration.exportClause.elements {
				specifierState := getModuleInstanceStateForAliasTarget(specifier, visited)
				if specifierState > state {
					state = specifierState
				}
				if state == ModuleInstanceStateInstantiated {
					return state
				}
			}
			return state
		}
	case SyntaxKindModuleBlock:
		state := ModuleInstanceStateNonInstantiated
		forEachChild(node, func(n Node) *true {
			childState := getModuleInstanceStateCached(n, visited)
			switch childState {
			case ModuleInstanceStateNonInstantiated:
				return
			case ModuleInstanceStateConstEnumOnly:
				state = ModuleInstanceStateConstEnumOnly
				return
			case ModuleInstanceStateInstantiated:
				state = ModuleInstanceStateInstantiated
				return true
			default:
				Debug.assertNever(childState)
			}
		})
		return state
		fallthrough
	case SyntaxKindModuleDeclaration:
		return getModuleInstanceState(node /* as ModuleDeclaration */, visited)
	case SyntaxKindIdentifier:
		if node.flags & NodeFlagsIdentifierIsInJSDocNamespace {
			return ModuleInstanceStateNonInstantiated
		}
	}
	return ModuleInstanceStateInstantiated
}

func getModuleInstanceStateForAliasTarget(specifier ExportSpecifier, visited Map[number, *ModuleInstanceState]) ModuleInstanceState {
	name := specifier.propertyName || specifier.name
	if name.kind != SyntaxKindIdentifier {
		return ModuleInstanceStateInstantiated
		// Skip for invalid syntax like this: export { "x" }
	}
	var p Node = specifier.parent
	for p {
		if isBlock(p) || isModuleBlock(p) || isSourceFile(p) {
			statements := p.statements
			var found *ModuleInstanceState
			for _, statement := range statements {
				if nodeHasName(statement, name) {
					if !statement.parent {
						setParent(statement, p)
						setParentRecursive(statement /*incremental*/, false)
					}
					state := getModuleInstanceStateCached(statement, visited)
					if found == nil || state > found {
						found = state
					}
					if found == ModuleInstanceStateInstantiated {
						return found
					}
					if statement.kind == SyntaxKindImportEqualsDeclaration {
						// Treat re-exports of import aliases as instantiated,
						// since they're ambiguous. This is consistent with
						// `export import x = mod.x` being treated as instantiated:
						//   import x = mod.x;
						//   export { x };
						found = ModuleInstanceStateInstantiated
					}
				}
			}
			if found != nil {
				return found
			}
		}
		p = p.parent
	}
	return ModuleInstanceStateInstantiated
	// Couldn't locate, assume could refer to a value
}

/** @internal */

type ContainerFlags int32

const (
	// The current node is not a container, and no container manipulation should happen before
	// recursing into it.
	ContainerFlagsNone ContainerFlags = 0
	// The current node is a container.  It should be set as the current container (and block-
	// container) before recursing into it.  The current node does not have locals.  Examples:
	//
	//      Classes, ObjectLiterals, TypeLiterals, Interfaces...
	ContainerFlagsIsContainer ContainerFlags = 1 << 0
	// The current node is a block-scoped-container.  It should be set as the current block-
	// container before recursing into it.  Examples:
	//
	//      Blocks (when not parented by functions), Catch clauses, For/For-in/For-of statements...
	ContainerFlagsIsBlockScopedContainer ContainerFlags = 1 << 1
	// The current node is the container of a control flow path. The current control flow should
	// be saved and restored, and a new control flow initialized within the container.
	ContainerFlagsIsControlFlowContainer                           ContainerFlags = 1 << 2
	ContainerFlagsIsFunctionLike                                   ContainerFlags = 1 << 3
	ContainerFlagsIsFunctionExpression                             ContainerFlags = 1 << 4
	ContainerFlagsHasLocals                                        ContainerFlags = 1 << 5
	ContainerFlagsIsInterface                                      ContainerFlags = 1 << 6
	ContainerFlagsIsObjectLiteralOrClassExpressionMethodOrAccessor ContainerFlags = 1 << 7
)

/** @internal */

func createFlowNode(flags FlowFlags, node any, antecedent /* TODO(TS-TO-GO) TypeNode UnionType: FlowNode | FlowNode[] | undefined */ any) FlowNode {
	return Debug.attachFlowNodeDebugInfo(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"flags":      flags,
		"id":         0,
		"node":       node,
		"antecedent": antecedent,
	} /* as FlowNode */)
}

var binder = createBinder()

/** @internal */

func bindSourceFile(file SourceFile, options CompilerOptions) {
	performance.mark("beforeBind")
	binder(file, options)
	performance.mark("afterBind")
	performance.measure("Bind", "beforeBind", "afterBind")
}

func createBinder() func(file SourceFile, options CompilerOptions) {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	// Container one level up

	// state used by control flow analysis

	// state used for emit helpers

	// If this file is an external module, then it is automatically in strict-mode according to
	// ES6.  If it is not an external module, then we'll determine if it is in strict mode or
	// not depending on if we see "use strict" in certain places or if we hit a class/namespace
	// or if compiler options contain alwaysStrict.

	// If we are binding an assignment pattern, we will bind certain expressions differently.
	tc.inAssignmentPattern = false

	tc.symbolCount = 0

	tc.unreachableFlow = createFlowNode(FlowFlagsUnreachable /*node*/, nil /*antecedent*/, nil)
	tc.reportedUnreachableFlow = createFlowNode(FlowFlagsUnreachable /*node*/, nil /*antecedent*/, nil)
	tc.bindBinaryExpressionFlow = binder.createBindBinaryExpressionFlow()
	/* eslint-enable no-var */

	return binder.bindSourceFile
}

/**
 * Inside the binder, we may create a diagnostic for an as-yet unbound node (with potentially no parent pointers, implying no accessible source file)
 * If so, the node _must_ be in the current file (as that's the only way anything could have traversed to it to yield it as the error node)
 * This version of `createDiagnosticForNode` uses the binder's context to account for this, and always yields correct diagnostics even in these situations.
 */

func (binder *Binder) createDiagnosticForNode(node Node, message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
	return createDiagnosticForNodeInSourceFile(getSourceFileOfNode(node) || binder.file, node, message, args...)
}

func (binder *Binder) bindSourceFile(f SourceFile, opts CompilerOptions) {
	binder.file = f
	binder.options = opts
	binder.languageVersion = getEmitScriptTarget(binder.options)
	binder.inStrictMode = binder.bindInStrictMode(binder.file, opts)
	binder.classifiableNames = NewSet()
	binder.symbolCount = 0

	binder.Symbol = objectAllocator.getSymbolConstructor()

	// Attach debugging information if necessary
	Debug.attachFlowNodeDebugInfo(binder.unreachableFlow)
	Debug.attachFlowNodeDebugInfo(binder.reportedUnreachableFlow)

	if !binder.file.locals {
		tracing. /* ? */ push(tracing.Phase.Bind, "bindSourceFile", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"path": binder.file.path,
		}, /*separateBeginAndEnd*/ true)
		binder.bind(binder.file)
		tracing. /* ? */ pop()
		binder.file.symbolCount = binder.symbolCount
		binder.file.classifiableNames = binder.classifiableNames
		binder.delayedBindJSDocTypedefTag()
		binder.bindJSDocImports()
	}

	binder.file = nil
	binder.options = nil
	binder.languageVersion = nil
	binder.parent = nil
	binder.container = nil
	binder.thisParentContainer = nil
	binder.blockScopeContainer = nil
	binder.lastContainer = nil
	binder.delayedTypeAliases = nil
	binder.jsDocImports = nil
	binder.seenThisKeyword = false
	binder.currentFlow = nil
	binder.currentBreakTarget = nil
	binder.currentContinueTarget = nil
	binder.currentReturnTarget = nil
	binder.currentTrueTarget = nil
	binder.currentFalseTarget = nil
	binder.currentExceptionTarget = nil
	binder.activeLabelList = nil
	binder.hasExplicitReturn = false
	binder.hasFlowEffects = false
	binder.inAssignmentPattern = false
	binder.emitFlags = NodeFlagsNone
}

func (binder *Binder) bindInStrictMode(file SourceFile, opts CompilerOptions) bool {
	if getStrictOptionValue(opts, "alwaysStrict") && !binder.file.isDeclarationFile {
		// bind in strict mode source files with alwaysStrict option
		return true
	} else {
		return !!binder.file.externalModuleIndicator
	}
}

func (binder *Binder) createSymbol(flags SymbolFlags, name __String) Symbol {
	binder.symbolCount++
	return NewSymbol(flags, name)
}

func (binder *Binder) addDeclarationToSymbol(symbol Symbol, node Declaration, symbolFlags SymbolFlags) {
	symbol.flags |= symbolFlags

	node.symbol = symbol
	symbol.declarations = appendIfUnique(symbol.declarations, node)

	if symbolFlags&(SymbolFlagsClass|SymbolFlagsEnum|SymbolFlagsModule|SymbolFlagsVariable) && !symbol.exports {
		symbol.exports = createSymbolTable()
	}

	if symbolFlags&(SymbolFlagsClass|SymbolFlagsInterface|SymbolFlagsTypeLiteral|SymbolFlagsObjectLiteral) && !symbol.members {
		symbol.members = createSymbolTable()
	}

	// On merge of const enum module with class or function, reset const enum only flag (namespaces will already recalculate)
	if symbol.constEnumOnlyModule && (symbol.flags & (SymbolFlagsFunction | SymbolFlagsClass | SymbolFlagsRegularEnum)) {
		symbol.constEnumOnlyModule = false
	}

	if symbolFlags & SymbolFlagsValue {
		setValueDeclaration(symbol, node)
	}
}

// Should not be called on a declaration with a computed property name,
// unless it is a well known Symbol.
func (binder *Binder) getDeclarationName(node Declaration) *__String {
	if node.kind == SyntaxKindExportAssignment {
		if (node /* as ExportAssignment */).isExportEquals {
			return InternalSymbolNameExportEquals
		} else {
			return InternalSymbolNameDefault
		}
	}

	name := getNameOfDeclaration(node)
	if name {
		if isAmbientModule(node) {
			moduleName := getTextOfIdentifierOrLiteral(name /* as Identifier | StringLiteral */)
			return (__COND__(isGlobalScopeAugmentation(node /* as ModuleDeclaration */), "__global", __TEMPLATE__("\"", moduleName, "\""))) /* as __String */
		}
		if name.kind == SyntaxKindComputedPropertyName {
			nameExpression := name.expression
			// treat computed property names where expression is string/numeric literal as just string/numeric literal
			if isStringOrNumericLiteralLike(nameExpression) {
				return escapeLeadingUnderscores(nameExpression.text)
			}
			if isSignedNumericLiteral(nameExpression) {
				return tokenToString(nameExpression.operator) + nameExpression.operand.text /* as __String */
			} else {
				Debug.fail("Only computed properties with literal names have declaration names")
			}
		}
		if isPrivateIdentifier(name) {
			// containingClass exists because private names only allowed inside classes
			containingClass := getContainingClass(node)
			if !containingClass {
				// we can get here in cases where there is already a parse error.
				return nil
			}
			containingClassSymbol := containingClass.symbol
			return getSymbolNameForPrivateIdentifier(containingClassSymbol, name.escapedText)
		}
		if isJsxNamespacedName(name) {
			return getEscapedTextOfJsxNamespacedName(name)
		}
		if isPropertyNameLiteral(name) {
			return getEscapedTextOfIdentifierOrLiteral(name)
		} else {
			return nil
		}
	}
	switch node.kind {
	case SyntaxKindConstructor:
		return InternalSymbolNameConstructor
	case SyntaxKindFunctionType,
		SyntaxKindCallSignature,
		SyntaxKindJSDocSignature:
		return InternalSymbolNameCall
	case SyntaxKindConstructorType,
		SyntaxKindConstructSignature:
		return InternalSymbolNameNew
	case SyntaxKindIndexSignature:
		return InternalSymbolNameIndex
	case SyntaxKindExportDeclaration:
		return InternalSymbolNameExportStar
	case SyntaxKindSourceFile:
		return InternalSymbolNameExportEquals
	case SyntaxKindBinaryExpression:
		if getAssignmentDeclarationKind(node /* as BinaryExpression */) == AssignmentDeclarationKindModuleExports {
			// module.exports = ...
			return InternalSymbolNameExportEquals
		}
		Debug.fail("Unknown binary declaration kind")
	case SyntaxKindJSDocFunctionType:
		return (__COND__(isJSDocConstructSignature(node), InternalSymbolNameNew, InternalSymbolNameCall))
	case SyntaxKindParameter:
		Debug.assert(node.parent.kind == SyntaxKindJSDocFunctionType, "Impossible parameter parent kind", func() string {
			return __TEMPLATE__("parent is: ", Debug.formatSyntaxKind(node.parent.kind), ", expected JSDocFunctionType")
		})
		functionType := node.parent /* as JSDocFunctionType */
		index := functionType.parameters.indexOf(node /* as ParameterDeclaration */)
		return "arg" + index /* as __String */
	}
}

func (binder *Binder) getDisplayName(node Declaration) string {
	if isNamedDeclaration(node) {
		return declarationNameToString(node.name)
	} else {
		return unescapeLeadingUnderscores(Debug.checkDefined(binder.getDeclarationName(node)))
	}
}

/**
 * Declares a Symbol for the node and adds it to symbols. Reports errors for conflicting identifier names.
 * @param symbolTable - The symbol table which node will be added to.
 * @param parent - node's parent declaration.
 * @param node - The declaration to be added to the symbol table
 * @param includes - The SymbolFlags that node has in addition to its declaration type (eg: export, ambient, etc.)
 * @param excludes - The flags which node cannot be declared alongside in a symbol table. Used to report forbidden declarations.
 */

func (binder *Binder) declareSymbol(symbolTable SymbolTable, parent Symbol, node Declaration, includes SymbolFlags, excludes SymbolFlags, isReplaceableByMethod bool, isComputedName bool) Symbol {
	Debug.assert(isComputedName || !hasDynamicName(node))

	isDefaultExport := hasSyntacticModifier(node, ModifierFlagsDefault) || isExportSpecifier(node) && moduleExportNameIsDefault(node.name)

	// The exported symbol for an export default function/class node is always named "default"
	var name *__String
	switch {
	case isComputedName:
		name = InternalSymbolNameComputed
	case isDefaultExport && binder.parent:
		name = InternalSymbolNameDefault
	default:
		name = binder.getDeclarationName(node)
	}

	var symbol Symbol
	if name == nil {
		symbol = binder.createSymbol(SymbolFlagsNone, InternalSymbolNameMissing)
	} else {
		// Check and see if the symbol table already has a symbol with this name.  If not,
		// create a new symbol with this name and add it to the table.  Note that we don't
		// give the new symbol any flags *yet*.  This ensures that it will not conflict
		// with the 'excludes' flags we pass in.
		//
		// If we do get an existing symbol, see if it conflicts with the new symbol we're
		// creating.  For example, a 'var' symbol and a 'class' symbol will conflict within
		// the same symbol table.  If we have a conflict, report the issue on each
		// declaration we have for this symbol, and then create a new symbol for this
		// declaration.
		//
		// Note that when properties declared in Javascript constructors
		// (marked by isReplaceableByMethod) conflict with another symbol, the property loses.
		// Always. This allows the common Javascript pattern of overwriting a prototype method
		// with an bound instance method of the same type: `this.method = this.method.bind(this)`
		//
		// If we created a new symbol, either because we didn't have a symbol with this name
		// in the symbol table, or we conflicted with an existing symbol, then just add this
		// node as the sole declaration of the new symbol.
		//
		// Otherwise, we'll be merging into a compatible existing symbol (for example when
		// you have multiple 'vars' with the same name in the same container).  In this case
		// just add this node into the declarations list of the symbol.
		symbol = symbolTable.get(name)

		if includes & SymbolFlagsClassifiable {
			binder.classifiableNames.add(name)
		}

		if !symbol {
			symbolTable.set(name /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symbol = createSymbol(SymbolFlags.None, name) */, TODO)
			if isReplaceableByMethod {
				symbol.isReplaceableByMethod = true
			}
		} else if isReplaceableByMethod && !symbol.isReplaceableByMethod {
			// A symbol already exists, so don't add this as a declaration.
			return symbol
		} else if symbol.flags & excludes {
			if symbol.isReplaceableByMethod {
				// Javascript constructor-declared symbols can be discarded in favor of
				// prototype symbols like methods.
				symbolTable.set(name /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symbol = createSymbol(SymbolFlags.None, name) */, TODO)
			} else if !(includes&SymbolFlagsVariable && symbol.flags&SymbolFlagsAssignment) {
				// Assignment declarations are allowed to merge with variables, no matter what other flags they have.
				if isNamedDeclaration(node) {
					setParent(node.name, node)
				}
				// Report errors every position with duplicate declaration
				// Report errors on previous encountered declarations
				var message DiagnosticMessage
				if symbol.flags & SymbolFlagsBlockScopedVariable {
					message = Diagnostics.Cannot_redeclare_block_scoped_variable_0
				} else {
					message = Diagnostics.Duplicate_identifier_0
				}
				messageNeedsName := true

				if symbol.flags&SymbolFlagsEnum || includes&SymbolFlagsEnum {
					message = Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
					messageNeedsName = false
				}

				multipleDefaultExports := false
				if length(symbol.declarations) {
					// If the current node is a default export of some sort, then check if
					// there are any other default exports that we need to error on.
					// We'll know whether we have other default exports depending on if `symbol` already has a declaration list set.
					if isDefaultExport {
						message = Diagnostics.A_module_cannot_have_multiple_default_exports
						messageNeedsName = false
						multipleDefaultExports = true
					} else {
						// This is to properly report an error in the case "export default { }" is after export default of class declaration or function declaration.
						// Error on multiple export default in the following case:
						// 1. multiple export default of class declaration or function declaration by checking NodeFlags.Default
						// 2. multiple export default of export assignment. This one doesn't have NodeFlags.Default on (as export default doesn't considered as modifiers)
						if symbol.declarations && symbol.declarations.length && (node.kind == SyntaxKindExportAssignment && !(node /* as ExportAssignment */).isExportEquals) {
							message = Diagnostics.A_module_cannot_have_multiple_default_exports
							messageNeedsName = false
							multipleDefaultExports = true
						}
					}
				}

				var relatedInformation []DiagnosticRelatedInformation = []never{}
				if isTypeAliasDeclaration(node) && nodeIsMissing(node.type_) && hasSyntacticModifier(node, ModifierFlagsExport) && symbol.flags&(SymbolFlagsAlias|SymbolFlagsType|SymbolFlagsNamespace) {
					// export type T; - may have meant export type { T }?
					relatedInformation.push(binder.createDiagnosticForNode(node, Diagnostics.Did_you_mean_0, __TEMPLATE__("export type { ", unescapeLeadingUnderscores(node.name.escapedText), " }")))
				}

				declarationName := getNameOfDeclaration(node) || node
				forEach(symbol.declarations, func(declaration Declaration, index number) {
					decl := getNameOfDeclaration(declaration) || declaration
					var diag DiagnosticWithLocation
					if messageNeedsName {
						diag = binder.createDiagnosticForNode(decl, message, binder.getDisplayName(declaration))
					} else {
						diag = binder.createDiagnosticForNode(decl, message)
					}
					binder.file.bindDiagnostics.push(__COND__(multipleDefaultExports, addRelatedInfo(diag, binder.createDiagnosticForNode(declarationName, __COND__(index == 0, Diagnostics.Another_export_default_is_here, Diagnostics.and_here))), diag))
					if multipleDefaultExports {
						relatedInformation.push(binder.createDiagnosticForNode(decl, Diagnostics.The_first_export_default_is_here))
					}
				})

				var diag DiagnosticWithLocation
				if messageNeedsName {
					diag = binder.createDiagnosticForNode(declarationName, message, binder.getDisplayName(node))
				} else {
					diag = binder.createDiagnosticForNode(declarationName, message)
				}
				binder.file.bindDiagnostics.push(addRelatedInfo(diag, relatedInformation...))

				symbol = binder.createSymbol(SymbolFlagsNone, name)
			}
		}
	}

	binder.addDeclarationToSymbol(symbol, node, includes)
	if symbol.parent {
		Debug.assert(symbol.parent == binder.parent, "Existing symbol parent should match new one")
	} else {
		symbol.parent = binder.parent
	}

	return symbol
}

func (binder *Binder) declareModuleMember(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) Symbol {
	hasExportModifier := !!(getCombinedModifierFlags(node) & ModifierFlagsExport) || binder.jsdocTreatAsExported(node)
	if symbolFlags & SymbolFlagsAlias {
		if node.kind == SyntaxKindExportSpecifier || (node.kind == SyntaxKindImportEqualsDeclaration && hasExportModifier) {
			return binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node, symbolFlags, symbolExcludes)
		} else {
			Debug.assertNode(binder.container, canHaveLocals)
			return binder.declareSymbol(binder.container.locals /*parent*/, nil, node, symbolFlags, symbolExcludes)
		}
	} else {
		// Exported module members are given 2 symbols: A local symbol that is classified with an ExportValue flag,
		// and an associated export symbol with all the correct flags set on it. There are 2 main reasons:
		//
		//   1. We treat locals and exports of the same name as mutually exclusive within a container.
		//      That means the binder will issue a Duplicate Identifier error if you mix locals and exports
		//      with the same name in the same container.
		//      TODO: Make this a more specific error and decouple it from the exclusion logic.
		//   2. When we checkIdentifier in the checker, we set its resolved symbol to the local symbol,
		//      but return the export symbol (by calling getExportSymbolOfValueSymbolIfExported). That way
		//      when the emitter comes back to it, it knows not to qualify the name if it was found in a containing scope.

		// NOTE: Nested ambient modules always should go to to 'locals' table to prevent their automatic merge
		//       during global merging in the checker. Why? The only case when ambient module is permitted inside another module is module augmentation
		//       and this case is specially handled. Module augmentations should only be merged with original module definition
		//       and should never be merged directly with other augmentation, and the latter case would be possible if automatic merge is allowed.
		if isJSDocTypeAlias(node) {
			Debug.assert(isInJSFile(node))
			// We shouldn't add symbols for JSDoc nodes if not in a JS file.
		}
		// We shouldn't add symbols for JSDoc nodes if not in a JS file.
		if !isAmbientModule(node) && (hasExportModifier || binder.container.flags&NodeFlagsExportContext) {
			if !canHaveLocals(binder.container) || !binder.container.locals || (hasSyntacticModifier(node, ModifierFlagsDefault) && !binder.getDeclarationName(node)) {
				return binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node, symbolFlags, symbolExcludes)
				// No local symbol for an unnamed default!
			}
			var exportKind /* TODO(TS-TO-GO) inferred type SymbolFlags.ExportValue | 0 */ any
			if symbolFlags & SymbolFlagsValue {
				exportKind = SymbolFlagsExportValue
			} else {
				exportKind = 0
			}
			local := binder.declareSymbol(binder.container.locals /*parent*/, nil, node, exportKind, symbolExcludes)
			local.exportSymbol = binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node, symbolFlags, symbolExcludes)
			node.localSymbol = local
			return local
		} else {
			Debug.assertNode(binder.container, canHaveLocals)
			return binder.declareSymbol(binder.container.locals /*parent*/, nil, node, symbolFlags, symbolExcludes)
		}
	}
}

func (binder *Binder) jsdocTreatAsExported(node Node) bool {
	if node.parent && isModuleDeclaration(node) {
		node = node.parent
	}
	if !isJSDocTypeAlias(node) {
		return false
	}
	// jsdoc typedef handling is a bit of a doozy, but to summarize, treat the typedef as exported if:
	// 1. It has an explicit name (since by default typedefs are always directly exported, either at the top level or in a container), or
	if !isJSDocEnumTag(node) && !!node.fullName {
		return true
	}
	// 2. The thing a nameless typedef pulls its name from is implicitly a direct export (either by assignment or actual export flag).
	declName := getNameOfDeclaration(node)
	if !declName {
		return false
	}
	if isPropertyAccessEntityNameExpression(declName.parent) && binder.isTopLevelNamespaceAssignment(declName.parent) {
		return true
	}
	if isDeclaration(declName.parent) && getCombinedModifierFlags(declName.parent)&ModifierFlagsExport {
		return true
	}
	// This could potentially be simplified by having `delayedBindJSDocTypedefTag` pass in an override for `hasExportModifier`, since it should
	// already have calculated and branched on most of this.
	return false
}

// All container nodes are kept on a linked list in declaration order. This list is used by
// the getLocalNameOfContainer function in the type checker to validate that the local name
// used for a container is unique.
func (binder *Binder) bindContainer(node Mutable[HasContainerFlags], containerFlags ContainerFlags) {
	// Before we recurse into a node's children, we first save the existing parent, container
	// and block-container.  Then after we pop out of processing the children, we restore
	// these saved values.
	saveContainer := binder.container
	saveThisParentContainer := binder.thisParentContainer
	savedBlockScopeContainer := binder.blockScopeContainer

	// Depending on what kind of node this is, we may have to adjust the current container
	// and block-container.   If the current node is a container, then it is automatically
	// considered the current block-container as well.  Also, for containers that we know
	// may contain locals, we eagerly initialize the .locals field. We do this because
	// it's highly likely that the .locals will be needed to place some child in (for example,
	// a parameter, or variable declaration).
	//
	// However, we do not proactively create the .locals for block-containers because it's
	// totally normal and common for block-containers to never actually have a block-scoped
	// variable in them.  We don't want to end up allocating an object for every 'block' we
	// run into when most of them won't be necessary.
	//
	// Finally, if this is a block-container, then we clear out any existing .locals object
	// it may contain within it.  This happens in incremental scenarios.  Because we can be
	// reusing a node from a previous compilation, that node may have had 'locals' created
	// for it.  We must clear this so we don't accidentally move any stale data forward from
	// a previous compilation.
	if containerFlags & ContainerFlagsIsContainer {
		if node.kind != SyntaxKindArrowFunction {
			binder.thisParentContainer = binder.container
		}
		binder.container = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: blockScopeContainer = node as IsContainer */ TODO
		if containerFlags & ContainerFlagsHasLocals {
			(binder.container /* as HasLocals */).locals = createSymbolTable()
			binder.addToContainerChain(binder.container /* as HasLocals */)
		}
	} else if containerFlags & ContainerFlagsIsBlockScopedContainer {
		binder.blockScopeContainer = node /* as IsBlockScopedContainer */
		if containerFlags & ContainerFlagsHasLocals {
			(binder.blockScopeContainer /* as HasLocals */).locals = nil
		}
	}
	if containerFlags & ContainerFlagsIsControlFlowContainer {
		saveCurrentFlow := binder.currentFlow
		saveBreakTarget := binder.currentBreakTarget
		saveContinueTarget := binder.currentContinueTarget
		saveReturnTarget := binder.currentReturnTarget
		saveExceptionTarget := binder.currentExceptionTarget
		saveActiveLabelList := binder.activeLabelList
		saveHasExplicitReturn := binder.hasExplicitReturn
		isImmediatelyInvoked := (containerFlags&ContainerFlagsIsFunctionExpression && !hasSyntacticModifier(node, ModifierFlagsAsync) && !(node /* as FunctionLikeDeclaration */).asteriskToken && !!getImmediatelyInvokedFunctionExpression(node)) || node.kind == SyntaxKindClassStaticBlockDeclaration
		// A non-async, non-generator IIFE is considered part of the containing control flow. Return statements behave
		// similarly to break statements that exit to a label just past the statement body.
		if !isImmediatelyInvoked {
			binder.currentFlow = createFlowNode(FlowFlagsStart /*node*/, nil /*antecedent*/, nil)
			if containerFlags & (ContainerFlagsIsFunctionExpression | ContainerFlagsIsObjectLiteralOrClassExpressionMethodOrAccessor) {
				binder.currentFlow.node = node /* as FunctionExpression | ArrowFunction | MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration */
			}
		}
		// We create a return control flow graph for IIFEs and constructors. For constructors
		// we use the return control flow graph in strict property initialization checks.
		if isImmediatelyInvoked || node.kind == SyntaxKindConstructor || (isInJSFile(node) && (node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression)) {
			binder.currentReturnTarget = binder.createBranchLabel()
		} else {
			binder.currentReturnTarget = nil
		}
		binder.currentExceptionTarget = nil
		binder.currentBreakTarget = nil
		binder.currentContinueTarget = nil
		binder.activeLabelList = nil
		binder.hasExplicitReturn = false
		binder.bindChildren(node)
		// Reset all reachability check related flags on node (for incremental scenarios)
		node.flags &= ~NodeFlagsReachabilityAndEmitFlags
		if !(binder.currentFlow.flags & FlowFlagsUnreachable) && containerFlags&ContainerFlagsIsFunctionLike && nodeIsPresent((node /* as FunctionLikeDeclaration | ClassStaticBlockDeclaration */).body) {
			node.flags |= NodeFlagsHasImplicitReturn
			if binder.hasExplicitReturn {
				node.flags |= NodeFlagsHasExplicitReturn
			}
			(node /* as FunctionLikeDeclaration | ClassStaticBlockDeclaration */).endFlowNode = binder.currentFlow
		}
		if node.kind == SyntaxKindSourceFile {
			node.flags |= binder.emitFlags
			(node /* as SourceFile */).endFlowNode = binder.currentFlow
		}

		if binder.currentReturnTarget {
			binder.addAntecedent(binder.currentReturnTarget, binder.currentFlow)
			binder.currentFlow = binder.finishFlowLabel(binder.currentReturnTarget)
			if node.kind == SyntaxKindConstructor || node.kind == SyntaxKindClassStaticBlockDeclaration || (isInJSFile(node) && (node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression)) {
				(node /* as FunctionLikeDeclaration | ClassStaticBlockDeclaration */).returnFlowNode = binder.currentFlow
			}
		}
		if !isImmediatelyInvoked {
			binder.currentFlow = saveCurrentFlow
		}
		binder.currentBreakTarget = saveBreakTarget
		binder.currentContinueTarget = saveContinueTarget
		binder.currentReturnTarget = saveReturnTarget
		binder.currentExceptionTarget = saveExceptionTarget
		binder.activeLabelList = saveActiveLabelList
		binder.hasExplicitReturn = saveHasExplicitReturn
	} else if containerFlags & ContainerFlagsIsInterface {
		binder.seenThisKeyword = false
		binder.bindChildren(node)
		Debug.assertNotNode(node, isIdentifier)
		// ContainsThis cannot overlap with HasExtendedUnicodeEscape on Identifier
		if binder.seenThisKeyword {
			node.flags = node.flags | NodeFlagsContainsThis
		} else {
			node.flags = node.flags & ~NodeFlagsContainsThis
		}
	} else {
		binder.bindChildren(node)
	}

	binder.container = saveContainer
	binder.thisParentContainer = saveThisParentContainer
	binder.blockScopeContainer = savedBlockScopeContainer
}

func (binder *Binder) bindEachFunctionsFirst(nodes *NodeArray[Node]) {
	binder.bindEach(nodes, func(n Node) {
		if n.kind == SyntaxKindFunctionDeclaration {
			return binder.bind(n)
		} else {
			return nil
		}
	})
	binder.bindEach(nodes, func(n Node) {
		if n.kind != SyntaxKindFunctionDeclaration {
			return binder.bind(n)
		} else {
			return nil
		}
	})
}

func (binder *Binder) bindEach(nodes *NodeArray[Node], bindFunction func(node Node) /*  = bind */) {
	if nodes == nil {
		return
	}

	forEach(nodes, bindFunction)
}

func (binder *Binder) bindEachChild(node Node) {
	forEachChild(node, binder.bind, binder.bindEach)
}

func (binder *Binder) bindChildren(node Node) {
	saveInAssignmentPattern := binder.inAssignmentPattern
	// Most nodes aren't valid in an assignment pattern, so we clear the value here
	// and set it before we descend into nodes that could actually be part of an assignment pattern.
	binder.inAssignmentPattern = false
	if binder.checkUnreachable(node) {
		binder.bindEachChild(node)
		binder.bindJSDoc(node)
		binder.inAssignmentPattern = saveInAssignmentPattern
		return
	}
	if node.kind >= SyntaxKindFirstStatement && node.kind <= SyntaxKindLastStatement && (!binder.options.allowUnreachableCode || node.kind == SyntaxKindReturnStatement) {
		(node /* as HasFlowNode */).flowNode = binder.currentFlow
	}
	switch node.kind {
	case SyntaxKindWhileStatement:
		binder.bindWhileStatement(node /* as WhileStatement */)
	case SyntaxKindDoStatement:
		binder.bindDoStatement(node /* as DoStatement */)
	case SyntaxKindForStatement:
		binder.bindForStatement(node /* as ForStatement */)
	case SyntaxKindForInStatement,
		SyntaxKindForOfStatement:
		binder.bindForInOrForOfStatement(node /* as ForInOrOfStatement */)
	case SyntaxKindIfStatement:
		binder.bindIfStatement(node /* as IfStatement */)
	case SyntaxKindReturnStatement,
		SyntaxKindThrowStatement:
		binder.bindReturnOrThrow(node /* as ReturnStatement | ThrowStatement */)
	case SyntaxKindBreakStatement,
		SyntaxKindContinueStatement:
		binder.bindBreakOrContinueStatement(node /* as BreakOrContinueStatement */)
	case SyntaxKindTryStatement:
		binder.bindTryStatement(node /* as TryStatement */)
	case SyntaxKindSwitchStatement:
		binder.bindSwitchStatement(node /* as SwitchStatement */)
	case SyntaxKindCaseBlock:
		binder.bindCaseBlock(node /* as CaseBlock */)
	case SyntaxKindCaseClause:
		binder.bindCaseClause(node /* as CaseClause */)
	case SyntaxKindExpressionStatement:
		binder.bindExpressionStatement(node /* as ExpressionStatement */)
	case SyntaxKindLabeledStatement:
		binder.bindLabeledStatement(node /* as LabeledStatement */)
	case SyntaxKindPrefixUnaryExpression:
		binder.bindPrefixUnaryExpressionFlow(node /* as PrefixUnaryExpression */)
	case SyntaxKindPostfixUnaryExpression:
		binder.bindPostfixUnaryExpressionFlow(node /* as PostfixUnaryExpression */)
	case SyntaxKindBinaryExpression:
		if isDestructuringAssignment(node) {
			// Carry over whether we are in an assignment pattern to
			// binary expressions that could actually be an initializer
			binder.inAssignmentPattern = saveInAssignmentPattern
			binder.bindDestructuringAssignmentFlow(node)
			return
		}
		binder.bindBinaryExpressionFlow(node /* as BinaryExpression */)
	case SyntaxKindDeleteExpression:
		binder.bindDeleteExpressionFlow(node /* as DeleteExpression */)
	case SyntaxKindConditionalExpression:
		binder.bindConditionalExpressionFlow(node /* as ConditionalExpression */)
	case SyntaxKindVariableDeclaration:
		binder.bindVariableDeclarationFlow(node /* as VariableDeclaration */)
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		binder.bindAccessExpressionFlow(node /* as AccessExpression */)
	case SyntaxKindCallExpression:
		binder.bindCallExpressionFlow(node /* as CallExpression */)
	case SyntaxKindNonNullExpression:
		binder.bindNonNullExpressionFlow(node /* as NonNullExpression */)
	case SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocEnumTag:
		binder.bindJSDocTypeAlias(node /* as JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag */)
	case SyntaxKindJSDocImportTag:
		binder.bindJSDocImportTag(node /* as JSDocImportTag */)
	case SyntaxKindSourceFile:
		binder.bindEachFunctionsFirst((node /* as SourceFile */).statements)
		binder.bind((node /* as SourceFile */).endOfFileToken)
		break
		fallthrough
	case SyntaxKindBlock,
		SyntaxKindModuleBlock:
		binder.bindEachFunctionsFirst((node /* as Block */).statements)
	case SyntaxKindBindingElement:
		binder.bindBindingElementFlow(node /* as BindingElement */)
	case SyntaxKindParameter:
		binder.bindParameterFlow(node /* as ParameterDeclaration */)
	case SyntaxKindObjectLiteralExpression,
		SyntaxKindArrayLiteralExpression,
		SyntaxKindPropertyAssignment,
		SyntaxKindSpreadElement:
		binder.inAssignmentPattern = saveInAssignmentPattern
		fallthrough
	default:
		binder.bindEachChild(node)
	}
	binder.bindJSDoc(node)
	binder.inAssignmentPattern = saveInAssignmentPattern
}

func (binder *Binder) isNarrowingExpression(expr Expression) bool {
	switch expr.kind {
	case SyntaxKindIdentifier,
		SyntaxKindThisKeyword:
		return true
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		return binder.containsNarrowableReference(expr)
	case SyntaxKindCallExpression:
		return binder.hasNarrowableArgument(expr /* as CallExpression */)
	case SyntaxKindParenthesizedExpression:
		if isJSDocTypeAssertion(expr) {
			return false
		}
		fallthrough
	case SyntaxKindNonNullExpression:
		return binder.isNarrowingExpression((expr /* as ParenthesizedExpression | NonNullExpression */).expression)
	case SyntaxKindBinaryExpression:
		return binder.isNarrowingBinaryExpression(expr /* as BinaryExpression */)
	case SyntaxKindPrefixUnaryExpression:
		return (expr /* as PrefixUnaryExpression */).operator == SyntaxKindExclamationToken && binder.isNarrowingExpression((expr /* as PrefixUnaryExpression */).operand)
	case SyntaxKindTypeOfExpression:
		return binder.isNarrowingExpression((expr /* as TypeOfExpression */).expression)
	}
	return false
}

func (binder *Binder) isNarrowableReference(expr Expression) bool {
	switch expr.kind {
	case SyntaxKindIdentifier,
		SyntaxKindThisKeyword,
		SyntaxKindSuperKeyword,
		SyntaxKindMetaProperty:
		return true
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindParenthesizedExpression,
		SyntaxKindNonNullExpression:
		return binder.isNarrowableReference((expr /* as PropertyAccessExpression | ParenthesizedExpression | NonNullExpression */).expression)
	case SyntaxKindElementAccessExpression:
		return (isStringOrNumericLiteralLike((expr /* as ElementAccessExpression */).argumentExpression) || isEntityNameExpression((expr /* as ElementAccessExpression */).argumentExpression)) && binder.isNarrowableReference((expr /* as ElementAccessExpression */).expression)
	case SyntaxKindBinaryExpression:
		return (expr /* as BinaryExpression */).operatorToken.kind == SyntaxKindCommaToken && binder.isNarrowableReference((expr /* as BinaryExpression */).right) || isAssignmentOperator((expr /* as BinaryExpression */).operatorToken.kind) && isLeftHandSideExpression((expr /* as BinaryExpression */).left)
	}
	return false
}

func (binder *Binder) containsNarrowableReference(expr Expression) bool {
	return binder.isNarrowableReference(expr) || isOptionalChain(expr) && binder.containsNarrowableReference(expr.expression)
}

func (binder *Binder) hasNarrowableArgument(expr CallExpression) bool {
	if expr.arguments {
		for _, argument := range expr.arguments {
			if binder.containsNarrowableReference(argument) {
				return true
			}
		}
	}
	if expr.expression.kind == SyntaxKindPropertyAccessExpression && binder.containsNarrowableReference((expr.expression /* as PropertyAccessExpression */).expression) {
		return true
	}
	return false
}

func (binder *Binder) isNarrowingTypeofOperands(expr1 Expression, expr2 Expression) bool {
	return isTypeOfExpression(expr1) && binder.isNarrowableOperand(expr1.expression) && isStringLiteralLike(expr2)
}

func (binder *Binder) isNarrowingBinaryExpression(expr BinaryExpression) bool {
	switch expr.operatorToken.kind {
	case SyntaxKindEqualsToken,
		SyntaxKindBarBarEqualsToken,
		SyntaxKindAmpersandAmpersandEqualsToken,
		SyntaxKindQuestionQuestionEqualsToken:
		return binder.containsNarrowableReference(expr.left)
	case SyntaxKindEqualsEqualsToken,
		SyntaxKindExclamationEqualsToken,
		SyntaxKindEqualsEqualsEqualsToken,
		SyntaxKindExclamationEqualsEqualsToken:
		return binder.isNarrowableOperand(expr.left) || binder.isNarrowableOperand(expr.right) || binder.isNarrowingTypeofOperands(expr.right, expr.left) || binder.isNarrowingTypeofOperands(expr.left, expr.right) || (isBooleanLiteral(expr.right) && binder.isNarrowingExpression(expr.left) || isBooleanLiteral(expr.left) && binder.isNarrowingExpression(expr.right))
	case SyntaxKindInstanceOfKeyword:
		return binder.isNarrowableOperand(expr.left)
	case SyntaxKindInKeyword:
		return binder.isNarrowingExpression(expr.right)
	case SyntaxKindCommaToken:
		return binder.isNarrowingExpression(expr.right)
	}
	return false
}

func (binder *Binder) isNarrowableOperand(expr Expression) bool {
	switch expr.kind {
	case SyntaxKindParenthesizedExpression:
		return binder.isNarrowableOperand((expr /* as ParenthesizedExpression */).expression)
	case SyntaxKindBinaryExpression:
		switch (expr /* as BinaryExpression */).operatorToken.kind {
		case SyntaxKindEqualsToken:
			return binder.isNarrowableOperand((expr /* as BinaryExpression */).left)
		case SyntaxKindCommaToken:
			return binder.isNarrowableOperand((expr /* as BinaryExpression */).right)
		}
	}
	return binder.containsNarrowableReference(expr)
}

func (binder *Binder) createBranchLabel() FlowLabel {
	return createFlowNode(FlowFlagsBranchLabel /*node*/, nil /*antecedent*/, nil) /* as FlowLabel */
}

func (binder *Binder) createLoopLabel() FlowLabel {
	return createFlowNode(FlowFlagsLoopLabel /*node*/, nil /*antecedent*/, nil) /* as FlowLabel */
}

func (binder *Binder) createReduceLabel(target FlowLabel, antecedents []FlowNode, antecedent FlowNode) FlowReduceLabel {
	return createFlowNode(FlowFlagsReduceLabel, map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"target":      target,
		"antecedents": antecedents,
	}, antecedent) /* as FlowReduceLabel */
}

func (binder *Binder) setFlowNodeReferenced(flow FlowNode) {
	// On first reference we set the Referenced flag, thereafter we set the Shared flag
	if flow.flags & FlowFlagsReferenced {
		flow.flags |= FlowFlagsShared
	} else {
		flow.flags |= FlowFlagsReferenced
	}
}

func (binder *Binder) addAntecedent(label FlowLabel, antecedent FlowNode) {
	if !(antecedent.flags & FlowFlagsUnreachable) && !contains(label.antecedent, antecedent) {
		(label.antecedent || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: label.antecedent = [] */ TODO)).push(antecedent)
		binder.setFlowNodeReferenced(antecedent)
	}
}

func (binder *Binder) createFlowCondition(flags /* TODO(TS-TO-GO) TypeNode UnionType: FlowFlags.TrueCondition | FlowFlags.FalseCondition */ any, antecedent FlowNode, expression Expression) FlowNode {
	if antecedent.flags & FlowFlagsUnreachable {
		return antecedent
	}
	if !expression {
		if flags & FlowFlagsTrueCondition {
			return antecedent
		} else {
			return binder.unreachableFlow
		}
	}
	if (expression.kind == SyntaxKindTrueKeyword && flags&FlowFlagsFalseCondition || expression.kind == SyntaxKindFalseKeyword && flags&FlowFlagsTrueCondition) && !isExpressionOfOptionalChainRoot(expression) && !isNullishCoalesce(expression.parent) {
		return binder.unreachableFlow
	}
	if !binder.isNarrowingExpression(expression) {
		return antecedent
	}
	binder.setFlowNodeReferenced(antecedent)
	return createFlowNode(flags, expression, antecedent) /* as FlowCondition */
}

func (binder *Binder) createFlowSwitchClause(antecedent FlowNode, switchStatement SwitchStatement, clauseStart number, clauseEnd number) FlowSwitchClause {
	binder.setFlowNodeReferenced(antecedent)
	return createFlowNode(FlowFlagsSwitchClause, map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"switchStatement": switchStatement,
		"clauseStart":     clauseStart,
		"clauseEnd":       clauseEnd,
	}, antecedent) /* as FlowSwitchClause */
}

func (binder *Binder) createFlowMutation(flags /* TODO(TS-TO-GO) TypeNode UnionType: FlowFlags.Assignment | FlowFlags.ArrayMutation */ any, antecedent FlowNode, node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | VariableDeclaration | ArrayBindingElement */ any) /* TODO(TS-TO-GO) inferred type FlowAssignment | FlowArrayMutation */ any {
	binder.setFlowNodeReferenced(antecedent)
	binder.hasFlowEffects = true
	result := createFlowNode(flags, node, antecedent) /* as FlowAssignment | FlowArrayMutation */
	if binder.currentExceptionTarget {
		binder.addAntecedent(binder.currentExceptionTarget, result)
	}
	return result
}

func (binder *Binder) createFlowCall(antecedent FlowNode, node CallExpression) FlowCall {
	binder.setFlowNodeReferenced(antecedent)
	binder.hasFlowEffects = true
	return createFlowNode(FlowFlagsCall, node, antecedent) /* as FlowCall */
}

func (binder *Binder) finishFlowLabel(flow FlowLabel) FlowNode {
	antecedents := flow.antecedent
	if !antecedents {
		return binder.unreachableFlow
	}
	if antecedents.length == 1 {
		return antecedents[0]
	}
	return flow
}

func (binder *Binder) isStatementCondition(node Node) bool {
	parent := node.parent
	switch parent.kind {
	case SyntaxKindIfStatement,
		SyntaxKindWhileStatement,
		SyntaxKindDoStatement:
		return (parent /* as IfStatement | WhileStatement | DoStatement */).expression == node
	case SyntaxKindForStatement,
		SyntaxKindConditionalExpression:
		return (parent /* as ForStatement | ConditionalExpression */).condition == node
	}
	return false
}

func (binder *Binder) isLogicalExpression(node Node) bool {
	for true {
		if node.kind == SyntaxKindParenthesizedExpression {
			node = (node /* as ParenthesizedExpression */).expression
		} else if node.kind == SyntaxKindPrefixUnaryExpression && (node /* as PrefixUnaryExpression */).operator == SyntaxKindExclamationToken {
			node = (node /* as PrefixUnaryExpression */).operand
		} else {
			return isLogicalOrCoalescingBinaryExpression(node)
		}
	}
}

func (binder *Binder) isLogicalAssignmentExpression(node Node) bool {
	return isLogicalOrCoalescingAssignmentExpression(skipParentheses(node))
}

func (binder *Binder) isTopLevelLogicalExpression(node Node) bool {
	for isParenthesizedExpression(node.parent) || isPrefixUnaryExpression(node.parent) && node.parent.operator == SyntaxKindExclamationToken {
		node = node.parent
	}
	return !binder.isStatementCondition(node) && !binder.isLogicalExpression(node.parent) && !(isOptionalChain(node.parent) && node.parent.expression == node)
}

func (binder *Binder) doWithConditionalBranches(action func(value T), value T, trueTarget FlowLabel, falseTarget FlowLabel) {
	savedTrueTarget := binder.currentTrueTarget
	savedFalseTarget := binder.currentFalseTarget
	binder.currentTrueTarget = trueTarget
	binder.currentFalseTarget = falseTarget
	action(value)
	binder.currentTrueTarget = savedTrueTarget
	binder.currentFalseTarget = savedFalseTarget
}

func (binder *Binder) bindCondition(node Expression, trueTarget FlowLabel, falseTarget FlowLabel) {
	binder.doWithConditionalBranches(binder.bind, node, trueTarget, falseTarget)
	if !node || !binder.isLogicalAssignmentExpression(node) && !binder.isLogicalExpression(node) && !(isOptionalChain(node) && isOutermostOptionalChain(node)) {
		binder.addAntecedent(trueTarget, binder.createFlowCondition(FlowFlagsTrueCondition, binder.currentFlow, node))
		binder.addAntecedent(falseTarget, binder.createFlowCondition(FlowFlagsFalseCondition, binder.currentFlow, node))
	}
}

func (binder *Binder) bindIterativeStatement(node Statement, breakTarget FlowLabel, continueTarget FlowLabel) {
	saveBreakTarget := binder.currentBreakTarget
	saveContinueTarget := binder.currentContinueTarget
	binder.currentBreakTarget = breakTarget
	binder.currentContinueTarget = continueTarget
	binder.bind(node)
	binder.currentBreakTarget = saveBreakTarget
	binder.currentContinueTarget = saveContinueTarget
}

func (binder *Binder) setContinueTarget(node Node, target FlowLabel) FlowLabel {
	label := binder.activeLabelList
	for label && node.parent.kind == SyntaxKindLabeledStatement {
		label.continueTarget = target
		label = label.next
		node = node.parent
	}
	return target
}

func (binder *Binder) bindWhileStatement(node WhileStatement) {
	preWhileLabel := binder.setContinueTarget(node, binder.createLoopLabel())
	preBodyLabel := binder.createBranchLabel()
	postWhileLabel := binder.createBranchLabel()
	binder.addAntecedent(preWhileLabel, binder.currentFlow)
	binder.currentFlow = preWhileLabel
	binder.bindCondition(node.expression, preBodyLabel, postWhileLabel)
	binder.currentFlow = binder.finishFlowLabel(preBodyLabel)
	binder.bindIterativeStatement(node.statement, postWhileLabel, preWhileLabel)
	binder.addAntecedent(preWhileLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(postWhileLabel)
}

func (binder *Binder) bindDoStatement(node DoStatement) {
	preDoLabel := binder.createLoopLabel()
	preConditionLabel := binder.setContinueTarget(node, binder.createBranchLabel())
	postDoLabel := binder.createBranchLabel()
	binder.addAntecedent(preDoLabel, binder.currentFlow)
	binder.currentFlow = preDoLabel
	binder.bindIterativeStatement(node.statement, postDoLabel, preConditionLabel)
	binder.addAntecedent(preConditionLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(preConditionLabel)
	binder.bindCondition(node.expression, preDoLabel, postDoLabel)
	binder.currentFlow = binder.finishFlowLabel(postDoLabel)
}

func (binder *Binder) bindForStatement(node ForStatement) {
	preLoopLabel := binder.setContinueTarget(node, binder.createLoopLabel())
	preBodyLabel := binder.createBranchLabel()
	postLoopLabel := binder.createBranchLabel()
	binder.bind(node.initializer)
	binder.addAntecedent(preLoopLabel, binder.currentFlow)
	binder.currentFlow = preLoopLabel
	binder.bindCondition(node.condition, preBodyLabel, postLoopLabel)
	binder.currentFlow = binder.finishFlowLabel(preBodyLabel)
	binder.bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel)
	binder.bind(node.incrementor)
	binder.addAntecedent(preLoopLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(postLoopLabel)
}

func (binder *Binder) bindForInOrForOfStatement(node ForInOrOfStatement) {
	preLoopLabel := binder.setContinueTarget(node, binder.createLoopLabel())
	postLoopLabel := binder.createBranchLabel()
	binder.bind(node.expression)
	binder.addAntecedent(preLoopLabel, binder.currentFlow)
	binder.currentFlow = preLoopLabel
	if node.kind == SyntaxKindForOfStatement {
		binder.bind(node.awaitModifier)
	}
	binder.addAntecedent(postLoopLabel, binder.currentFlow)
	binder.bind(node.initializer)
	if node.initializer.kind != SyntaxKindVariableDeclarationList {
		binder.bindAssignmentTargetFlow(node.initializer)
	}
	binder.bindIterativeStatement(node.statement, postLoopLabel, preLoopLabel)
	binder.addAntecedent(preLoopLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(postLoopLabel)
}

func (binder *Binder) bindIfStatement(node IfStatement) {
	thenLabel := binder.createBranchLabel()
	elseLabel := binder.createBranchLabel()
	postIfLabel := binder.createBranchLabel()
	binder.bindCondition(node.expression, thenLabel, elseLabel)
	binder.currentFlow = binder.finishFlowLabel(thenLabel)
	binder.bind(node.thenStatement)
	binder.addAntecedent(postIfLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(elseLabel)
	binder.bind(node.elseStatement)
	binder.addAntecedent(postIfLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(postIfLabel)
}

func (binder *Binder) bindReturnOrThrow(node /* TODO(TS-TO-GO) TypeNode UnionType: ReturnStatement | ThrowStatement */ any) {
	binder.bind(node.expression)
	if node.kind == SyntaxKindReturnStatement {
		binder.hasExplicitReturn = true
		if binder.currentReturnTarget {
			binder.addAntecedent(binder.currentReturnTarget, binder.currentFlow)
		}
	}
	binder.currentFlow = binder.unreachableFlow
	binder.hasFlowEffects = true
}

func (binder *Binder) findActiveLabel(name __String) *ActiveLabel {
	for label := binder.activeLabelList; label; label = label.next {
		if label.name == name {
			return label
		}
	}
	return nil
}

func (binder *Binder) bindBreakOrContinueFlow(node BreakOrContinueStatement, breakTarget *FlowLabel, continueTarget *FlowLabel) {
	var flowLabel *FlowLabel
	if node.kind == SyntaxKindBreakStatement {
		flowLabel = breakTarget
	} else {
		flowLabel = continueTarget
	}
	if flowLabel {
		binder.addAntecedent(flowLabel, binder.currentFlow)
		binder.currentFlow = binder.unreachableFlow
		binder.hasFlowEffects = true
	}
}

func (binder *Binder) bindBreakOrContinueStatement(node BreakOrContinueStatement) {
	binder.bind(node.label)
	if node.label {
		activeLabel := binder.findActiveLabel(node.label.escapedText)
		if activeLabel {
			activeLabel.referenced = true
			binder.bindBreakOrContinueFlow(node, activeLabel.breakTarget, activeLabel.continueTarget)
		}
	} else {
		binder.bindBreakOrContinueFlow(node, binder.currentBreakTarget, binder.currentContinueTarget)
	}
}

func (binder *Binder) bindTryStatement(node TryStatement) {
	// We conservatively assume that *any* code in the try block can cause an exception, but we only need
	// to track code that causes mutations (because only mutations widen the possible control flow type of
	// a variable). The exceptionLabel is the target label for control flows that result from exceptions.
	// We add all mutation flow nodes as antecedents of this label such that we can analyze them as possible
	// antecedents of the start of catch or finally blocks. Furthermore, we add the current control flow to
	// represent exceptions that occur before any mutations.
	saveReturnTarget := binder.currentReturnTarget
	saveExceptionTarget := binder.currentExceptionTarget
	normalExitLabel := binder.createBranchLabel()
	returnLabel := binder.createBranchLabel()
	exceptionLabel := binder.createBranchLabel()
	if node.finallyBlock {
		binder.currentReturnTarget = returnLabel
	}
	binder.addAntecedent(exceptionLabel, binder.currentFlow)
	binder.currentExceptionTarget = exceptionLabel
	binder.bind(node.tryBlock)
	binder.addAntecedent(normalExitLabel, binder.currentFlow)
	if node.catchClause {
		// Start of catch clause is the target of exceptions from try block.
		binder.currentFlow = binder.finishFlowLabel(exceptionLabel)
		// The currentExceptionTarget now represents control flows from exceptions in the catch clause.
		// Effectively, in a try-catch-finally, if an exception occurs in the try block, the catch block
		// acts like a second try block.
		exceptionLabel = binder.createBranchLabel()
		binder.addAntecedent(exceptionLabel, binder.currentFlow)
		binder.currentExceptionTarget = exceptionLabel
		binder.bind(node.catchClause)
		binder.addAntecedent(normalExitLabel, binder.currentFlow)
	}
	binder.currentReturnTarget = saveReturnTarget
	binder.currentExceptionTarget = saveExceptionTarget
	if node.finallyBlock {
		// Possible ways control can reach the finally block:
		// 1) Normal completion of try block of a try-finally or try-catch-finally
		// 2) Normal completion of catch block (following exception in try block) of a try-catch-finally
		// 3) Return in try or catch block of a try-finally or try-catch-finally
		// 4) Exception in try block of a try-finally
		// 5) Exception in catch block of a try-catch-finally
		// When analyzing a control flow graph that starts inside a finally block we want to consider all
		// five possibilities above. However, when analyzing a control flow graph that starts outside (past)
		// the finally block, we only want to consider the first two (if we're past a finally block then it
		// must have completed normally). Likewise, when analyzing a control flow graph from return statements
		// in try or catch blocks in an IIFE, we only want to consider the third. To make this possible, we
		// inject a ReduceLabel node into the control flow graph. This node contains an alternate reduced
		// set of antecedents for the pre-finally label. As control flow analysis passes by a ReduceLabel
		// node, the pre-finally label is temporarily switched to the reduced antecedent set.
		finallyLabel := binder.createBranchLabel()
		finallyLabel.antecedent = concatenate(concatenate(normalExitLabel.antecedent, exceptionLabel.antecedent), returnLabel.antecedent)
		binder.currentFlow = finallyLabel
		binder.bind(node.finallyBlock)
		if binder.currentFlow.flags & FlowFlagsUnreachable {
			// If the end of the finally block is unreachable, the end of the entire try statement is unreachable.
			binder.currentFlow = binder.unreachableFlow
		} else {
			// If we have an IIFE return target and return statements in the try or catch blocks, add a control
			// flow that goes back through the finally block and back through only the return statements.
			if binder.currentReturnTarget && returnLabel.antecedent {
				binder.addAntecedent(binder.currentReturnTarget, binder.createReduceLabel(finallyLabel, returnLabel.antecedent, binder.currentFlow))
			}
			// If we have an outer exception target (i.e. a containing try-finally or try-catch-finally), add a
			// control flow that goes back through the finally blok and back through each possible exception source.
			if binder.currentExceptionTarget && exceptionLabel.antecedent {
				binder.addAntecedent(binder.currentExceptionTarget, binder.createReduceLabel(finallyLabel, exceptionLabel.antecedent, binder.currentFlow))
			}
			// If the end of the finally block is reachable, but the end of the try and catch blocks are not,
			// convert the current flow to unreachable. For example, 'try { return 1; } finally { ... }' should
			// result in an unreachable current control flow.
			if normalExitLabel.antecedent {
				binder.currentFlow = binder.createReduceLabel(finallyLabel, normalExitLabel.antecedent, binder.currentFlow)
			} else {
				binder.currentFlow = binder.unreachableFlow
			}
		}
	} else {
		binder.currentFlow = binder.finishFlowLabel(normalExitLabel)
	}
}

func (binder *Binder) bindSwitchStatement(node SwitchStatement) {
	postSwitchLabel := binder.createBranchLabel()
	binder.bind(node.expression)
	saveBreakTarget := binder.currentBreakTarget
	savePreSwitchCaseFlow := binder.preSwitchCaseFlow
	binder.currentBreakTarget = postSwitchLabel
	binder.preSwitchCaseFlow = binder.currentFlow
	binder.bind(node.caseBlock)
	binder.addAntecedent(postSwitchLabel, binder.currentFlow)
	hasDefault := forEach(node.caseBlock.clauses, func(c /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
		return c.kind == SyntaxKindDefaultClause
	})
	// We mark a switch statement as possibly exhaustive if it has no default clause and if all
	// case clauses have unreachable end points (e.g. they all return). Note, we no longer need
	// this property in control flow analysis, it's there only for backwards compatibility.
	node.possiblyExhaustive = !hasDefault && !postSwitchLabel.antecedent
	if !hasDefault {
		binder.addAntecedent(postSwitchLabel, binder.createFlowSwitchClause(binder.preSwitchCaseFlow, node, 0, 0))
	}
	binder.currentBreakTarget = saveBreakTarget
	binder.preSwitchCaseFlow = savePreSwitchCaseFlow
	binder.currentFlow = binder.finishFlowLabel(postSwitchLabel)
}

func (binder *Binder) bindCaseBlock(node CaseBlock) {
	clauses := node.clauses
	isNarrowingSwitch := node.parent.expression.kind == SyntaxKindTrueKeyword || binder.isNarrowingExpression(node.parent.expression)
	var fallthroughFlow FlowNode = binder.unreachableFlow

	for i := 0; i < clauses.length; i++ {
		clauseStart := i
		for !clauses[i].statements.length && i+1 < clauses.length {
			if fallthroughFlow == binder.unreachableFlow {
				binder.currentFlow = binder.preSwitchCaseFlow
			}
			binder.bind(clauses[i])
			i++
		}
		preCaseLabel := binder.createBranchLabel()
		binder.addAntecedent(preCaseLabel, __COND__(isNarrowingSwitch, binder.createFlowSwitchClause(binder.preSwitchCaseFlow, node.parent, clauseStart, i+1), binder.preSwitchCaseFlow))
		binder.addAntecedent(preCaseLabel, fallthroughFlow)
		binder.currentFlow = binder.finishFlowLabel(preCaseLabel)
		clause := clauses[i]
		binder.bind(clause)
		fallthroughFlow = binder.currentFlow
		if !(binder.currentFlow.flags & FlowFlagsUnreachable) && i != clauses.length-1 && binder.options.noFallthroughCasesInSwitch {
			clause.fallthroughFlowNode = binder.currentFlow
		}
	}
}

func (binder *Binder) bindCaseClause(node CaseClause) {
	saveCurrentFlow := binder.currentFlow
	binder.currentFlow = binder.preSwitchCaseFlow
	binder.bind(node.expression)
	binder.currentFlow = saveCurrentFlow
	binder.bindEach(node.statements)
}

func (binder *Binder) bindExpressionStatement(node ExpressionStatement) {
	binder.bind(node.expression)
	binder.maybeBindExpressionFlowIfCall(node.expression)
}

func (binder *Binder) maybeBindExpressionFlowIfCall(node Expression) {
	// A top level or comma expression call expression with a dotted function name and at least one argument
	// is potentially an assertion and is therefore included in the control flow.
	if node.kind == SyntaxKindCallExpression {
		call := node /* as CallExpression */
		if call.expression.kind != SyntaxKindSuperKeyword && isDottedName(call.expression) {
			binder.currentFlow = binder.createFlowCall(binder.currentFlow, call)
		}
	}
}

func (binder *Binder) bindLabeledStatement(node LabeledStatement) {
	postStatementLabel := binder.createBranchLabel()
	binder.activeLabelList = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"next":           binder.activeLabelList,
		"name":           node.label.escapedText,
		"breakTarget":    postStatementLabel,
		"continueTarget": nil,
		"referenced":     false,
	}
	binder.bind(node.label)
	binder.bind(node.statement)
	if !binder.activeLabelList.referenced && !binder.options.allowUnusedLabels {
		binder.errorOrSuggestionOnNode(unusedLabelIsError(binder.options), node.label, Diagnostics.Unused_label)
	}
	binder.activeLabelList = binder.activeLabelList.next
	binder.addAntecedent(postStatementLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(postStatementLabel)
}

func (binder *Binder) bindDestructuringTargetFlow(node Expression) {
	if node.kind == SyntaxKindBinaryExpression && (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken {
		binder.bindAssignmentTargetFlow((node /* as BinaryExpression */).left)
	} else {
		binder.bindAssignmentTargetFlow(node)
	}
}

func (binder *Binder) bindAssignmentTargetFlow(node Expression) {
	if binder.isNarrowableReference(node) {
		binder.currentFlow = binder.createFlowMutation(FlowFlagsAssignment, binder.currentFlow, node)
	} else if node.kind == SyntaxKindArrayLiteralExpression {
		for _, e := range (node /* as ArrayLiteralExpression */).elements {
			if e.kind == SyntaxKindSpreadElement {
				binder.bindAssignmentTargetFlow((e /* as SpreadElement */).expression)
			} else {
				binder.bindDestructuringTargetFlow(e)
			}
		}
	} else if node.kind == SyntaxKindObjectLiteralExpression {
		for _, p := range (node /* as ObjectLiteralExpression */).properties {
			if p.kind == SyntaxKindPropertyAssignment {
				binder.bindDestructuringTargetFlow(p.initializer)
			} else if p.kind == SyntaxKindShorthandPropertyAssignment {
				binder.bindAssignmentTargetFlow(p.name)
			} else if p.kind == SyntaxKindSpreadAssignment {
				binder.bindAssignmentTargetFlow(p.expression)
			}
		}
	}
}

func (binder *Binder) bindLogicalLikeExpression(node BinaryExpression, trueTarget FlowLabel, falseTarget FlowLabel) {
	preRightLabel := binder.createBranchLabel()
	if node.operatorToken.kind == SyntaxKindAmpersandAmpersandToken || node.operatorToken.kind == SyntaxKindAmpersandAmpersandEqualsToken {
		binder.bindCondition(node.left, preRightLabel, falseTarget)
	} else {
		binder.bindCondition(node.left, trueTarget, preRightLabel)
	}
	binder.currentFlow = binder.finishFlowLabel(preRightLabel)
	binder.bind(node.operatorToken)

	if isLogicalOrCoalescingAssignmentOperator(node.operatorToken.kind) {
		binder.doWithConditionalBranches(binder.bind, node.right, trueTarget, falseTarget)
		binder.bindAssignmentTargetFlow(node.left)

		binder.addAntecedent(trueTarget, binder.createFlowCondition(FlowFlagsTrueCondition, binder.currentFlow, node))
		binder.addAntecedent(falseTarget, binder.createFlowCondition(FlowFlagsFalseCondition, binder.currentFlow, node))
	} else {
		binder.bindCondition(node.right, trueTarget, falseTarget)
	}
}

func (binder *Binder) bindPrefixUnaryExpressionFlow(node PrefixUnaryExpression) {
	if node.operator == SyntaxKindExclamationToken {
		saveTrueTarget := binder.currentTrueTarget
		binder.currentTrueTarget = binder.currentFalseTarget
		binder.currentFalseTarget = saveTrueTarget
		binder.bindEachChild(node)
		binder.currentFalseTarget = binder.currentTrueTarget
		binder.currentTrueTarget = saveTrueTarget
	} else {
		binder.bindEachChild(node)
		if node.operator == SyntaxKindPlusPlusToken || node.operator == SyntaxKindMinusMinusToken {
			binder.bindAssignmentTargetFlow(node.operand)
		}
	}
}

func (binder *Binder) bindPostfixUnaryExpressionFlow(node PostfixUnaryExpression) {
	binder.bindEachChild(node)
	if node.operator == SyntaxKindPlusPlusToken || node.operator == SyntaxKindMinusMinusToken {
		binder.bindAssignmentTargetFlow(node.operand)
	}
}

func (binder *Binder) bindDestructuringAssignmentFlow(node DestructuringAssignment) {
	if binder.inAssignmentPattern {
		binder.inAssignmentPattern = false
		binder.bind(node.operatorToken)
		binder.bind(node.right)
		binder.inAssignmentPattern = true
		binder.bind(node.left)
	} else {
		binder.inAssignmentPattern = true
		binder.bind(node.left)
		binder.inAssignmentPattern = false
		binder.bind(node.operatorToken)
		binder.bind(node.right)
	}
	binder.bindAssignmentTargetFlow(node.left)
}

func (binder *Binder) createBindBinaryExpressionFlow() /* TODO(TS-TO-GO) inferred type (node: BinaryExpression) => void */ any {
	type WorkArea struct {
		stackIndex        number
		skip              bool
		inStrictModeStack []*bool
		parentStack       []Node
	}

	return createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit /*foldState*/, nil)

	onEnter := func(node BinaryExpression, state *WorkArea) WorkArea {
		if state {
			state.stackIndex++
			// Emulate the work that `bind` does before reaching `bindChildren`. A normal call to
			// `bindBinaryExpressionFlow` will already have done this work.
			setParent(node, binder.parent)
			saveInStrictMode := binder.inStrictMode
			binder.bindWorker(node)
			saveParent := binder.parent
			binder.parent = node
			state.skip = false
			state.inStrictModeStack[state.stackIndex] = saveInStrictMode
			state.parentStack[state.stackIndex] = saveParent
		} else {
			state = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"stackIndex":        0,
				"skip":              false,
				"inStrictModeStack": []undefined{nil},
				"parentStack":       []undefined{nil},
			}
		}
		// TODO: bindLogicalExpression is recursive - if we want to handle deeply nested `&&` expressions
		// we'll need to handle the `bindLogicalExpression` scenarios in this state machine, too
		// For now, though, since the common cases are chained `+`, leaving it recursive is fine
		operator := node.operatorToken.kind
		if isLogicalOrCoalescingBinaryOperator(operator) || isLogicalOrCoalescingAssignmentOperator(operator) {
			if binder.isTopLevelLogicalExpression(node) {
				postExpressionLabel := binder.createBranchLabel()
				saveCurrentFlow := binder.currentFlow
				saveHasFlowEffects := binder.hasFlowEffects
				binder.hasFlowEffects = false
				binder.bindLogicalLikeExpression(node, postExpressionLabel, postExpressionLabel)
				if binder.hasFlowEffects {
					binder.currentFlow = binder.finishFlowLabel(postExpressionLabel)
				} else {
					binder.currentFlow = saveCurrentFlow
				}
				binder.hasFlowEffects = binder.hasFlowEffects || saveHasFlowEffects
			} else {
				binder.bindLogicalLikeExpression(node, binder.currentTrueTarget, binder.currentFalseTarget)
			}
			state.skip = true
		}
		return state
	}

	onLeft := func(left Expression, state WorkArea, node BinaryExpression) *BinaryExpression {
		if !state.skip {
			maybeBound := maybeBind(left)
			if node.operatorToken.kind == SyntaxKindCommaToken {
				binder.maybeBindExpressionFlowIfCall(left)
			}
			return maybeBound
		}
	}

	onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, _node BinaryExpression) {
		if !state.skip {
			binder.bind(operatorToken)
		}
	}

	onRight := func(right Expression, state WorkArea, node BinaryExpression) *BinaryExpression {
		if !state.skip {
			maybeBound := maybeBind(right)
			if node.operatorToken.kind == SyntaxKindCommaToken {
				binder.maybeBindExpressionFlowIfCall(right)
			}
			return maybeBound
		}
	}

	onExit := func(node BinaryExpression, state WorkArea) {
		if !state.skip {
			operator := node.operatorToken.kind
			if isAssignmentOperator(operator) && !isAssignmentTarget(node) {
				binder.bindAssignmentTargetFlow(node.left)
				if operator == SyntaxKindEqualsToken && node.left.kind == SyntaxKindElementAccessExpression {
					elementAccess := node.left /* as ElementAccessExpression */
					if binder.isNarrowableOperand(elementAccess.expression) {
						binder.currentFlow = binder.createFlowMutation(FlowFlagsArrayMutation, binder.currentFlow, node)
					}
				}
			}
		}
		savedInStrictMode := state.inStrictModeStack[state.stackIndex]
		savedParent := state.parentStack[state.stackIndex]
		if savedInStrictMode != nil {
			binder.inStrictMode = savedInStrictMode
		}
		if savedParent != nil {
			binder.parent = savedParent
		}
		state.skip = false
		state.stackIndex--
	}

	maybeBind := func(node Node) *BinaryExpression {
		if node && isBinaryExpression(node) && !isDestructuringAssignment(node) {
			return node
		}
		binder.bind(node)
	}

}

func (binder *Binder) bindDeleteExpressionFlow(node DeleteExpression) {
	binder.bindEachChild(node)
	if node.expression.kind == SyntaxKindPropertyAccessExpression {
		binder.bindAssignmentTargetFlow(node.expression)
	}
}

func (binder *Binder) bindConditionalExpressionFlow(node ConditionalExpression) {
	trueLabel := binder.createBranchLabel()
	falseLabel := binder.createBranchLabel()
	postExpressionLabel := binder.createBranchLabel()
	saveCurrentFlow := binder.currentFlow
	saveHasFlowEffects := binder.hasFlowEffects
	binder.hasFlowEffects = false
	binder.bindCondition(node.condition, trueLabel, falseLabel)
	binder.currentFlow = binder.finishFlowLabel(trueLabel)
	binder.bind(node.questionToken)
	binder.bind(node.whenTrue)
	binder.addAntecedent(postExpressionLabel, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(falseLabel)
	binder.bind(node.colonToken)
	binder.bind(node.whenFalse)
	binder.addAntecedent(postExpressionLabel, binder.currentFlow)
	if binder.hasFlowEffects {
		binder.currentFlow = binder.finishFlowLabel(postExpressionLabel)
	} else {
		binder.currentFlow = saveCurrentFlow
	}
	binder.hasFlowEffects = binder.hasFlowEffects || saveHasFlowEffects
}

func (binder *Binder) bindInitializedVariableFlow(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | ArrayBindingElement */ any) {
	var name *BindingName
	if !isOmittedExpression(node) {
		name = node.name
	} else {
		name = nil
	}
	if isBindingPattern(name) {
		for _, child := range name.elements {
			binder.bindInitializedVariableFlow(child)
		}
	} else {
		binder.currentFlow = binder.createFlowMutation(FlowFlagsAssignment, binder.currentFlow, node)
	}
}

func (binder *Binder) bindVariableDeclarationFlow(node VariableDeclaration) {
	binder.bindEachChild(node)
	if node.initializer || isForInOrOfStatement(node.parent.parent) {
		binder.bindInitializedVariableFlow(node)
	}
}

func (binder *Binder) bindBindingElementFlow(node BindingElement) {
	// When evaluating a binding pattern, the initializer is evaluated before the binding pattern, per:
	// - https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-iteratorbindinginitialization
	//   - `BindingElement: BindingPattern Initializer?`
	// - https://tc39.es/ecma262/#sec-runtime-semantics-keyedbindinginitialization
	//   - `BindingElement: BindingPattern Initializer?`
	binder.bind(node.dotDotDotToken)
	binder.bind(node.propertyName)
	binder.bindInitializer(node.initializer)
	binder.bind(node.name)
}

func (binder *Binder) bindParameterFlow(node ParameterDeclaration) {
	binder.bindEach(node.modifiers)
	binder.bind(node.dotDotDotToken)
	binder.bind(node.questionToken)
	binder.bind(node.type_)
	binder.bindInitializer(node.initializer)
	binder.bind(node.name)
}

// a BindingElement/Parameter does not have side effects if initializers are not evaluated and used. (see GH#49759)
func (binder *Binder) bindInitializer(node Expression) {
	if !node {
		return
	}
	entryFlow := binder.currentFlow
	binder.bind(node)
	if entryFlow == binder.unreachableFlow || entryFlow == binder.currentFlow {
		return
	}
	exitFlow := binder.createBranchLabel()
	binder.addAntecedent(exitFlow, entryFlow)
	binder.addAntecedent(exitFlow, binder.currentFlow)
	binder.currentFlow = binder.finishFlowLabel(exitFlow)
}

func (binder *Binder) bindJSDocTypeAlias(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag */ any) {
	binder.bind(node.tagName)
	if node.kind != SyntaxKindJSDocEnumTag && node.fullName {
		// don't bind the type name yet; that's delayed until delayedBindJSDocTypedefTag
		setParent(node.fullName, node)
		setParentRecursive(node.fullName /*incremental*/, false)
	}
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO != "string" {
		binder.bindEach(node.comment)
	}
}

func (binder *Binder) bindJSDocClassTag(node JSDocClassTag) {
	binder.bindEachChild(node)
	host := getHostSignatureFromJSDoc(node)
	if host && host.kind != SyntaxKindMethodDeclaration {
		binder.addDeclarationToSymbol(host.symbol, host, SymbolFlagsClass)
	}
}

func (binder *Binder) bindJSDocImportTag(node JSDocImportTag) {
	// don't bind the importClause yet; that's delayed until bindJSDocImports
	binder.bind(node.tagName)
	binder.bind(node.moduleSpecifier)
	binder.bind(node.attributes)

	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO != "string" {
		binder.bindEach(node.comment)
	}
}

func (binder *Binder) bindOptionalExpression(node Expression, trueTarget FlowLabel, falseTarget FlowLabel) {
	binder.doWithConditionalBranches(binder.bind, node, trueTarget, falseTarget)
	if !isOptionalChain(node) || isOutermostOptionalChain(node) {
		binder.addAntecedent(trueTarget, binder.createFlowCondition(FlowFlagsTrueCondition, binder.currentFlow, node))
		binder.addAntecedent(falseTarget, binder.createFlowCondition(FlowFlagsFalseCondition, binder.currentFlow, node))
	}
}

func (binder *Binder) bindOptionalChainRest(node OptionalChain) {
	switch node.kind {
	case SyntaxKindPropertyAccessExpression:
		binder.bind(node.questionDotToken)
		binder.bind(node.name)
	case SyntaxKindElementAccessExpression:
		binder.bind(node.questionDotToken)
		binder.bind(node.argumentExpression)
	case SyntaxKindCallExpression:
		binder.bind(node.questionDotToken)
		binder.bindEach(node.typeArguments)
		binder.bindEach(node.arguments)
	}
}

func (binder *Binder) bindOptionalChain(node OptionalChain, trueTarget FlowLabel, falseTarget FlowLabel) {
	// For an optional chain, we emulate the behavior of a logical expression:
	//
	// a?.b         -> a && a.b
	// a?.b.c       -> a && a.b.c
	// a?.b?.c      -> a && a.b && a.b.c
	// a?.[x = 1]   -> a && a[x = 1]
	//
	// To do this we descend through the chain until we reach the root of a chain (the expression with a `?.`)
	// and build it's CFA graph as if it were the first condition (`a && ...`). Then we bind the rest
	// of the node as part of the "true" branch, and continue to do so as we ascend back up to the outermost
	// chain node. We then treat the entire node as the right side of the expression.
	var preChainLabel *FlowLabel
	if isOptionalChainRoot(node) {
		preChainLabel = binder.createBranchLabel()
	} else {
		preChainLabel = nil
	}
	binder.bindOptionalExpression(node.expression, preChainLabel || trueTarget, falseTarget)
	if preChainLabel {
		binder.currentFlow = binder.finishFlowLabel(preChainLabel)
	}
	binder.doWithConditionalBranches(binder.bindOptionalChainRest, node, trueTarget, falseTarget)
	if isOutermostOptionalChain(node) {
		binder.addAntecedent(trueTarget, binder.createFlowCondition(FlowFlagsTrueCondition, binder.currentFlow, node))
		binder.addAntecedent(falseTarget, binder.createFlowCondition(FlowFlagsFalseCondition, binder.currentFlow, node))
	}
}

func (binder *Binder) bindOptionalChainFlow(node OptionalChain) {
	if binder.isTopLevelLogicalExpression(node) {
		postExpressionLabel := binder.createBranchLabel()
		saveCurrentFlow := binder.currentFlow
		saveHasFlowEffects := binder.hasFlowEffects
		binder.bindOptionalChain(node, postExpressionLabel, postExpressionLabel)
		if binder.hasFlowEffects {
			binder.currentFlow = binder.finishFlowLabel(postExpressionLabel)
		} else {
			binder.currentFlow = saveCurrentFlow
		}
		binder.hasFlowEffects = binder.hasFlowEffects || saveHasFlowEffects
	} else {
		binder.bindOptionalChain(node, binder.currentTrueTarget, binder.currentFalseTarget)
	}
}

func (binder *Binder) bindNonNullExpressionFlow(node /* TODO(TS-TO-GO) TypeNode UnionType: NonNullExpression | NonNullChain */ any) {
	if isOptionalChain(node) {
		binder.bindOptionalChainFlow(node)
	} else {
		binder.bindEachChild(node)
	}
}

func (binder *Binder) bindAccessExpressionFlow(node /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | PropertyAccessChain | ElementAccessChain */ any) {
	if isOptionalChain(node) {
		binder.bindOptionalChainFlow(node)
	} else {
		binder.bindEachChild(node)
	}
}

func (binder *Binder) bindCallExpressionFlow(node /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | CallChain */ any) {
	if isOptionalChain(node) {
		binder.bindOptionalChainFlow(node)
	} else {
		// If the target of the call expression is a function expression or arrow function we have
		// an immediately invoked function expression (IIFE). Initialize the flowNode property to
		// the current control flow (which includes evaluation of the IIFE arguments).
		expr := skipParentheses(node.expression)
		if expr.kind == SyntaxKindFunctionExpression || expr.kind == SyntaxKindArrowFunction {
			binder.bindEach(node.typeArguments)
			binder.bindEach(node.arguments)
			binder.bind(node.expression)
		} else {
			binder.bindEachChild(node)
			if node.expression.kind == SyntaxKindSuperKeyword {
				binder.currentFlow = binder.createFlowCall(binder.currentFlow, node)
			}
		}
	}
	if node.expression.kind == SyntaxKindPropertyAccessExpression {
		propertyAccess := node.expression /* as PropertyAccessExpression */
		if isIdentifier(propertyAccess.name) && binder.isNarrowableOperand(propertyAccess.expression) && isPushOrUnshiftIdentifier(propertyAccess.name) {
			binder.currentFlow = binder.createFlowMutation(FlowFlagsArrayMutation, binder.currentFlow, node)
		}
	}
}

func (binder *Binder) addToContainerChain(next HasLocals) {
	if binder.lastContainer {
		binder.lastContainer.nextContainer = next
	}

	binder.lastContainer = next
}

func (binder *Binder) declareSymbolAndAddToSymbolTable(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) Symbol {
	switch binder.container.kind {
	case SyntaxKindModuleDeclaration:
		return binder.declareModuleMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindSourceFile:
		return binder.declareSourceFileMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindClassExpression,
		SyntaxKindClassDeclaration:
		return binder.declareClassMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindEnumDeclaration:
		return binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node, symbolFlags, symbolExcludes)
	case SyntaxKindTypeLiteral,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindJsxAttributes:
		return binder.declareSymbol(binder.container.symbol.members, binder.container.symbol, node, symbolFlags, symbolExcludes)
	case SyntaxKindFunctionType,
		SyntaxKindConstructorType,
		SyntaxKindCallSignature,
		SyntaxKindConstructSignature,
		SyntaxKindJSDocSignature,
		SyntaxKindIndexSignature,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindConstructor,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindJSDocFunctionType,
		SyntaxKindClassStaticBlockDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindMappedType:
		if binder.container.locals {
			Debug.assertNode(binder.container, canHaveLocals)
		}
		return binder.declareSymbol(binder.container.locals /*parent*/, nil, node, symbolFlags, symbolExcludes)
	}
}

func (binder *Binder) declareClassMember(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) Symbol {
	if isStatic(node) {
		return binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node, symbolFlags, symbolExcludes)
	} else {
		return binder.declareSymbol(binder.container.symbol.members, binder.container.symbol, node, symbolFlags, symbolExcludes)
	}
}

func (binder *Binder) declareSourceFileMember(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) Symbol {
	if isExternalModule(binder.file) {
		return binder.declareModuleMember(node, symbolFlags, symbolExcludes)
	} else {
		return binder.declareSymbol(binder.file.locals /*parent*/, nil, node, symbolFlags, symbolExcludes)
	}
}

func (binder *Binder) hasExportDeclarations(node /* TODO(TS-TO-GO) TypeNode UnionType: ModuleDeclaration | SourceFile */ any) bool {
	var body * /* TODO(TS-TO-GO) inferred type SourceFile | ModuleBlock */ any
	if isSourceFile(node) {
		body = node
	} else {
		body = tryCast(node.body, isModuleBlock)
	}
	return !!body && body.statements.some(func(s Statement) bool {
		return isExportDeclaration(s) || isExportAssignment(s)
	})
}

func (binder *Binder) setExportContextFlag(node Mutable[ /* TODO(TS-TO-GO) TypeNode UnionType: ModuleDeclaration | SourceFile */ any]) {
	// A declaration source file or ambient module declaration that contains no export declarations (but possibly regular
	// declarations with export modifiers) is an export context in which declarations are implicitly exported.
	if node.flags&NodeFlagsAmbient && !binder.hasExportDeclarations(node) {
		node.flags |= NodeFlagsExportContext
	} else {
		node.flags &= ~NodeFlagsExportContext
	}
}

func (binder *Binder) bindModuleDeclaration(node ModuleDeclaration) {
	binder.setExportContextFlag(node)
	if isAmbientModule(node) {
		if hasSyntacticModifier(node, ModifierFlagsExport) {
			binder.errorOnFirstToken(node, Diagnostics.export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible)
		}
		if isModuleAugmentationExternal(node) {
			binder.declareModuleSymbol(node)
		} else {
			var pattern /* TODO(TS-TO-GO) TypeNode UnionType: string | Pattern | undefined */ any
			if node.name.kind == SyntaxKindStringLiteral {
				TODO_IDENTIFIER := node.name
				pattern = tryParsePattern(text)
				if pattern == nil {
					binder.errorOnFirstToken(node.name, Diagnostics.Pattern_0_can_have_at_most_one_Asterisk_character, text)
				}
			}

			symbol := binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsValueModule, SymbolFlagsValueModuleExcludes)
			binder.file.patternAmbientModules = append(binder.file.patternAmbientModules, __COND__(pattern && !isString(pattern), map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"pattern": pattern,
				"symbol":  symbol,
			}, nil))
		}
	} else {
		state := binder.declareModuleSymbol(node)
		if state != ModuleInstanceStateNonInstantiated {
			TODO_IDENTIFIER := node
			// if module was already merged with some function, class or non-const enum, treat it as non-const-enum-only
			symbol.constEnumOnlyModule = (!(symbol.flags & (SymbolFlagsFunction | SymbolFlagsClass | SymbolFlagsRegularEnum))) && state == ModuleInstanceStateConstEnumOnly && symbol.constEnumOnlyModule != false
		}
	}
}

func (binder *Binder) declareModuleSymbol(node ModuleDeclaration) ModuleInstanceState {
	state := getModuleInstanceState(node)
	instantiated := state != ModuleInstanceStateNonInstantiated
	binder.declareSymbolAndAddToSymbolTable(node, __COND__(instantiated, SymbolFlagsValueModule, SymbolFlagsNamespaceModule), __COND__(instantiated, SymbolFlagsValueModuleExcludes, SymbolFlagsNamespaceModuleExcludes))
	return state
}

func (binder *Binder) bindFunctionOrConstructorType(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) {
	// For a given function symbol "<...>(...) => T" we want to generate a symbol identical
	// to the one we would get for: { <...>(...): T }
	//
	// We do that by making an anonymous type literal symbol, and then setting the function
	// symbol as its sole member. To the rest of the system, this symbol will be indistinguishable
	// from an actual type literal symbol you would have gotten had you used the long form.
	symbol := binder.createSymbol(SymbolFlagsSignature, binder.getDeclarationName(node))
	// TODO: GH#18217
	binder.addDeclarationToSymbol(symbol, node, SymbolFlagsSignature)

	typeLiteralSymbol := binder.createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
	binder.addDeclarationToSymbol(typeLiteralSymbol, node, SymbolFlagsTypeLiteral)
	typeLiteralSymbol.members = createSymbolTable()
	typeLiteralSymbol.members.set(symbol.escapedName, symbol)
}

func (binder *Binder) bindObjectLiteralExpression(node ObjectLiteralExpression) Symbol {
	return binder.bindAnonymousDeclaration(node, SymbolFlagsObjectLiteral, InternalSymbolNameObject)
}

func (binder *Binder) bindJsxAttributes(node JsxAttributes) Symbol {
	return binder.bindAnonymousDeclaration(node, SymbolFlagsObjectLiteral, InternalSymbolNameJSXAttributes)
}

func (binder *Binder) bindJsxAttribute(node JsxAttribute, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) Symbol {
	return binder.declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes)
}

func (binder *Binder) bindAnonymousDeclaration(node Declaration, symbolFlags SymbolFlags, name __String) Symbol {
	symbol := binder.createSymbol(symbolFlags, name)
	if symbolFlags & (SymbolFlagsEnumMember | SymbolFlagsClassMember) {
		symbol.parent = binder.container.symbol
	}
	binder.addDeclarationToSymbol(symbol, node, symbolFlags)
	return symbol
}

func (binder *Binder) bindBlockScopedDeclaration(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) {
	switch binder.blockScopeContainer.kind {
	case SyntaxKindModuleDeclaration:
		binder.declareModuleMember(node, symbolFlags, symbolExcludes)
	case SyntaxKindSourceFile:
		if isExternalOrCommonJsModule(binder.container /* as SourceFile */) {
			binder.declareModuleMember(node, symbolFlags, symbolExcludes)
			break
		}
		fallthrough
	default:
		Debug.assertNode(binder.blockScopeContainer, canHaveLocals)
		if !binder.blockScopeContainer.locals {
			binder.blockScopeContainer.locals = createSymbolTable()
			binder.addToContainerChain(binder.blockScopeContainer)
		}
		binder.declareSymbol(binder.blockScopeContainer.locals /*parent*/, nil, node, symbolFlags, symbolExcludes)
	}
}

func (binder *Binder) delayedBindJSDocTypedefTag() undefined {
	if !binder.delayedTypeAliases {
		return
	}
	saveContainer := binder.container
	saveLastContainer := binder.lastContainer
	saveBlockScopeContainer := binder.blockScopeContainer
	saveParent := binder.parent
	saveCurrentFlow := binder.currentFlow
	for _, typeAlias := range binder.delayedTypeAliases {
		host := typeAlias.parent.parent
		binder.container = (getEnclosingContainer(host) /* as IsContainer | undefined */) || binder.file
		binder.blockScopeContainer = (getEnclosingBlockScopeContainer(host) /* as IsBlockScopedContainer | undefined */) || binder.file
		binder.currentFlow = createFlowNode(FlowFlagsStart /*node*/, nil /*antecedent*/, nil)
		binder.parent = typeAlias
		binder.bind(typeAlias.typeExpression)
		declName := getNameOfDeclaration(typeAlias)
		if (isJSDocEnumTag(typeAlias) || !typeAlias.fullName) && declName && isPropertyAccessEntityNameExpression(declName.parent) {
			// typedef anchored to an A.B.C assignment - we need to bind into B's namespace under name C
			isTopLevel := binder.isTopLevelNamespaceAssignment(declName.parent)
			if isTopLevel {
				binder.bindPotentiallyMissingNamespaces(binder.file.symbol, declName.parent, isTopLevel, !!findAncestor(declName, func(d Node) bool {
					return isPropertyAccessExpression(d) && d.name.escapedText == "prototype"
				}), /*containerIsClass*/ false)
				oldContainer := binder.container
				switch getAssignmentDeclarationPropertyAccessKind(declName.parent) {
				case AssignmentDeclarationKindExportsProperty,
					AssignmentDeclarationKindModuleExports:
					if !isExternalOrCommonJsModule(binder.file) {
						binder.container = nil
					} else {
						binder.container = binder.file
					}
				case AssignmentDeclarationKindThisProperty:
					binder.container = declName.parent.expression
				case AssignmentDeclarationKindPrototypeProperty:
					binder.container = (declName.parent.expression /* as PropertyAccessEntityNameExpression */).name
				case AssignmentDeclarationKindProperty:
					switch {
					case isExportsOrModuleExportsOrAlias(binder.file, declName.parent.expression):
						binder.container = binder.file
					case isPropertyAccessExpression(declName.parent.expression):
						binder.container = declName.parent.expression.name
					default:
						binder.container = declName.parent.expression
					}
				case AssignmentDeclarationKindNone:
					return Debug.fail("Shouldn't have detected typedef or enum on non-assignment declaration")
				}
				if binder.container {
					binder.declareModuleMember(typeAlias, SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
				}
				binder.container = oldContainer
			}
		} else if isJSDocEnumTag(typeAlias) || !typeAlias.fullName || typeAlias.fullName.kind == SyntaxKindIdentifier {
			binder.parent = typeAlias.parent
			binder.bindBlockScopedDeclaration(typeAlias, SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
		} else {
			binder.bind(typeAlias.fullName)
		}
	}
	binder.container = saveContainer
	binder.lastContainer = saveLastContainer
	binder.blockScopeContainer = saveBlockScopeContainer
	binder.parent = saveParent
	binder.currentFlow = saveCurrentFlow
}

func (binder *Binder) bindJSDocImports() {
	if binder.jsDocImports == nil {
		return
	}

	saveContainer := binder.container
	saveLastContainer := binder.lastContainer
	saveBlockScopeContainer := binder.blockScopeContainer
	saveParent := binder.parent
	saveCurrentFlow := binder.currentFlow

	for _, jsDocImportTag := range binder.jsDocImports {
		host := getJSDocHost(jsDocImportTag)
		var enclosingContainer *IsContainer
		if host {
			enclosingContainer = getEnclosingContainer(host) /* as IsContainer | undefined */
		} else {
			enclosingContainer = nil
		}
		var enclosingBlockScopeContainer *IsBlockScopedContainer
		if host {
			enclosingBlockScopeContainer = getEnclosingBlockScopeContainer(host) /* as IsBlockScopedContainer | undefined */
		} else {
			enclosingBlockScopeContainer = nil
		}
		binder.container = enclosingContainer || binder.file
		binder.blockScopeContainer = enclosingBlockScopeContainer || binder.file
		binder.currentFlow = createFlowNode(FlowFlagsStart /*node*/, nil /*antecedent*/, nil)
		binder.parent = jsDocImportTag
		binder.bind(jsDocImportTag.importClause)
	}

	binder.container = saveContainer
	binder.lastContainer = saveLastContainer
	binder.blockScopeContainer = saveBlockScopeContainer
	binder.parent = saveParent
	binder.currentFlow = saveCurrentFlow
}

// The binder visits every node in the syntax tree so it is a convenient place to perform a single localized
// check for reserved words used as identifiers in strict mode code, as well as `yield` or `await` in
// [Yield] or [Await] contexts, respectively.
func (binder *Binder) checkContextualIdentifier(node Identifier) {
	// Report error only if there are no parse errors in file
	if !binder.file.parseDiagnostics.length && !(node.flags & NodeFlagsAmbient) && !(node.flags & NodeFlagsJSDoc) && !isIdentifierName(node) {
		// strict mode identifiers
		originalKeywordKind := identifierToKeywordKind(node)
		if originalKeywordKind == nil {
			return
		}

		if binder.inStrictMode && originalKeywordKind >= SyntaxKindFirstFutureReservedWord && originalKeywordKind <= SyntaxKindLastFutureReservedWord {
			binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(node, binder.getStrictModeIdentifierMessage(node), declarationNameToString(node)))
		} else if originalKeywordKind == SyntaxKindAwaitKeyword {
			if isExternalModule(binder.file) && isInTopLevelContext(node) {
				binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(node, Diagnostics.Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module, declarationNameToString(node)))
			} else if node.flags & NodeFlagsAwaitContext {
				binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(node, Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, declarationNameToString(node)))
			}
		} else if originalKeywordKind == SyntaxKindYieldKeyword && node.flags&NodeFlagsYieldContext {
			binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(node, Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here, declarationNameToString(node)))
		}
	}
}

func (binder *Binder) getStrictModeIdentifierMessage(node Node) DiagnosticMessage {
	// Provide specialized messages to help the user understand why we think they're in
	// strict mode.
	if getContainingClass(node) {
		return Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode
	}

	if binder.file.externalModuleIndicator {
		return Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode
	}

	return Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode
}

// The binder visits every node, so this is a good place to check for
// the reserved private name (there is only one)
func (binder *Binder) checkPrivateIdentifier(node PrivateIdentifier) {
	if node.escapedText == "#constructor" {
		// Report error only if there are no parse errors in file
		if !binder.file.parseDiagnostics.length {
			binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(node, Diagnostics.constructor_is_a_reserved_word, declarationNameToString(node)))
		}
	}
}

func (binder *Binder) checkStrictModeBinaryExpression(node BinaryExpression) {
	if binder.inStrictMode && isLeftHandSideExpression(node.left) && isAssignmentOperator(node.operatorToken.kind) {
		// ECMA 262 (Annex C) The identifier eval or arguments may not appear as the LeftHandSideExpression of an
		// Assignment operator(11.13) or of a PostfixExpression(11.3)
		binder.checkStrictModeEvalOrArguments(node, node.left /* as Identifier */)
	}
}

func (binder *Binder) checkStrictModeCatchClause(node CatchClause) {
	// It is a SyntaxError if a TryStatement with a Catch occurs within strict code and the Identifier of the
	// Catch production is eval or arguments
	if binder.inStrictMode && node.variableDeclaration {
		binder.checkStrictModeEvalOrArguments(node, node.variableDeclaration.name)
	}
}

func (binder *Binder) checkStrictModeDeleteExpression(node DeleteExpression) {
	// Grammar checking
	if binder.inStrictMode && node.expression.kind == SyntaxKindIdentifier {
		// When a delete operator occurs within strict mode code, a SyntaxError is thrown if its
		// UnaryExpression is a direct reference to a variable, function argument, or function name
		span := getErrorSpanForNode(binder.file, node.expression)
		binder.file.bindDiagnostics.push(createFileDiagnostic(binder.file, span.start, span.length, Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode))
	}
}

func (binder *Binder) isEvalOrArgumentsIdentifier(node Node) bool {
	return isIdentifier(node) && (node.escapedText == "eval" || node.escapedText == "arguments")
}

func (binder *Binder) checkStrictModeEvalOrArguments(contextNode Node, name Node) {
	if name && name.kind == SyntaxKindIdentifier {
		identifier := name /* as Identifier */
		if binder.isEvalOrArgumentsIdentifier(identifier) {
			// We check first if the name is inside class declaration or class expression; if so give explicit message
			// otherwise report generic error message.
			span := getErrorSpanForNode(binder.file, name)
			binder.file.bindDiagnostics.push(createFileDiagnostic(binder.file, span.start, span.length, binder.getStrictModeEvalOrArgumentsMessage(contextNode), idText(identifier)))
		}
	}
}

func (binder *Binder) getStrictModeEvalOrArgumentsMessage(node Node) DiagnosticMessage {
	// Provide specialized messages to help the user understand why we think they're in
	// strict mode.
	if getContainingClass(node) {
		return Diagnostics.Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode
	}

	if binder.file.externalModuleIndicator {
		return Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode
	}

	return Diagnostics.Invalid_use_of_0_in_strict_mode
}

func (binder *Binder) checkStrictModeFunctionName(node FunctionLikeDeclaration) {
	if binder.inStrictMode && !(node.flags & NodeFlagsAmbient) {
		// It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a strict mode FunctionDeclaration or FunctionExpression (13.1))
		binder.checkStrictModeEvalOrArguments(node, node.name)
	}
}

func (binder *Binder) getStrictModeBlockScopeFunctionDeclarationMessage(node Node) DiagnosticMessage {
	// Provide specialized messages to help the user understand why we think they're in
	// strict mode.
	if getContainingClass(node) {
		return Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Class_definitions_are_automatically_in_strict_mode
	}

	if binder.file.externalModuleIndicator {
		return Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5_Modules_are_automatically_in_strict_mode
	}

	return Diagnostics.Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES5
}

func (binder *Binder) checkStrictModeFunctionDeclaration(node FunctionDeclaration) {
	if binder.languageVersion < ScriptTargetES2015 {
		// Report error if function is not top level function declaration
		if binder.blockScopeContainer.kind != SyntaxKindSourceFile && binder.blockScopeContainer.kind != SyntaxKindModuleDeclaration && !isFunctionLikeOrClassStaticBlockDeclaration(binder.blockScopeContainer) {
			// We check first if the name is inside class declaration or class expression; if so give explicit message
			// otherwise report generic error message.
			errorSpan := getErrorSpanForNode(binder.file, node)
			binder.file.bindDiagnostics.push(createFileDiagnostic(binder.file, errorSpan.start, errorSpan.length, binder.getStrictModeBlockScopeFunctionDeclarationMessage(node)))
		}
	}
}

func (binder *Binder) checkStrictModePostfixUnaryExpression(node PostfixUnaryExpression) {
	// Grammar checking
	// The identifier eval or arguments may not appear as the LeftHandSideExpression of an
	// Assignment operator(11.13) or of a PostfixExpression(11.3) or as the UnaryExpression
	// operated upon by a Prefix Increment(11.4.4) or a Prefix Decrement(11.4.5) operator.
	if binder.inStrictMode {
		binder.checkStrictModeEvalOrArguments(node, node.operand /* as Identifier */)
	}
}

func (binder *Binder) checkStrictModePrefixUnaryExpression(node PrefixUnaryExpression) {
	// Grammar checking
	if binder.inStrictMode {
		if node.operator == SyntaxKindPlusPlusToken || node.operator == SyntaxKindMinusMinusToken {
			binder.checkStrictModeEvalOrArguments(node, node.operand /* as Identifier */)
		}
	}
}

func (binder *Binder) checkStrictModeWithStatement(node WithStatement) {
	// Grammar checking for withStatement
	if binder.inStrictMode {
		binder.errorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_strict_mode)
	}
}

func (binder *Binder) checkStrictModeLabeledStatement(node LabeledStatement) {
	// Grammar checking for labeledStatement
	if binder.inStrictMode && getEmitScriptTarget(binder.options) >= ScriptTargetES2015 {
		if isDeclarationStatement(node.statement) || isVariableStatement(node.statement) {
			binder.errorOnFirstToken(node.label, Diagnostics.A_label_is_not_allowed_here)
		}
	}
}

func (binder *Binder) errorOnFirstToken(node Node, message DiagnosticMessage, args DiagnosticArguments) {
	span := getSpanOfTokenAtPosition(binder.file, node.pos)
	binder.file.bindDiagnostics.push(createFileDiagnostic(binder.file, span.start, span.length, message, args...))
}

func (binder *Binder) errorOrSuggestionOnNode(isError bool, node Node, message DiagnosticMessage) {
	binder.errorOrSuggestionOnRange(isError, node, node, message)
}

func (binder *Binder) errorOrSuggestionOnRange(isError bool, startNode Node, endNode Node, message DiagnosticMessage) {
	binder.addErrorOrSuggestionDiagnostic(isError, map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"pos": getTokenPosOfNode(startNode, binder.file),
		"end": endNode.end,
	}, message)
}

func (binder *Binder) addErrorOrSuggestionDiagnostic(isError bool, range_ TextRange, message DiagnosticMessage) {
	diag := createFileDiagnostic(binder.file, range_.pos, range_.end-range_.pos, message)
	if isError {
		binder.file.bindDiagnostics.push(diag)
	} else {
		binder.file.bindSuggestionDiagnostics = append(binder.file.bindSuggestionDiagnostics, map[any]any{ /* TODO(TS-TO-GO): was object literal */
			/* TODO(TS-TO-GO) Node SpreadAssignment: ...diag */
			"category": DiagnosticCategorySuggestion,
		})
	}
}

func (binder *Binder) bind(node Node) {
	if !node {
		return
	}
	setParent(node, binder.parent)
	if tracing {
		(node /* as TracingNode */).tracingPath = binder.file.path
	}
	saveInStrictMode := binder.inStrictMode

	// Even though in the AST the jsdoc @typedef node belongs to the current node,
	// its symbol might be in the same scope with the current node's symbol. Consider:
	//
	//     /** @typedef {string | number} MyType */
	//     function foo();
	//
	// Here the current node is "foo", which is a container, but the scope of "MyType" should
	// not be inside "foo". Therefore we always bind @typedef before bind the parent node,
	// and skip binding this tag later when binding all the other jsdoc tags.

	// First we bind declaration nodes to a symbol if possible. We'll both create a symbol
	// and then potentially add the symbol to an appropriate symbol table. Possible
	// destination symbol tables are:
	//
	//  1) The 'exports' table of the current container's symbol.
	//  2) The 'members' table of the current container's symbol.
	//  3) The 'locals' table of the current container.
	//
	// However, not all symbols will end up in any of these tables. 'Anonymous' symbols
	// (like TypeLiterals for example) will not be put in any table.
	binder.bindWorker(node)
	// Then we recurse into the children of the node to bind them as well. For certain
	// symbols we do specialized work when we recurse. For example, we'll keep track of
	// the current 'container' node when it changes. This helps us know which symbol table
	// a local should go into for example. Since terminal nodes are known not to have
	// children, as an optimization we don't process those.
	if node.kind > SyntaxKindLastToken {
		saveParent := binder.parent
		binder.parent = node
		containerFlags := getContainerFlags(node)
		if containerFlags == ContainerFlagsNone {
			binder.bindChildren(node)
		} else {
			binder.bindContainer(node /* as HasContainerFlags */, containerFlags)
		}
		binder.parent = saveParent
	} else {
		saveParent := binder.parent
		if node.kind == SyntaxKindEndOfFileToken {
			binder.parent = node
		}
		binder.bindJSDoc(node)
		binder.parent = saveParent
	}
	binder.inStrictMode = saveInStrictMode
}

func (binder *Binder) bindJSDoc(node Node) {
	if hasJSDocNodes(node) {
		if isInJSFile(node) {
			for _, j := range node.jsDoc {
				binder.bind(j)
			}
		} else {
			for _, j := range node.jsDoc {
				setParent(j, node)
				setParentRecursive(j /*incremental*/, false)
			}
		}
	}
}

func (binder *Binder) updateStrictModeStatementList(statements NodeArray[Statement]) {
	if !binder.inStrictMode {
		for _, statement := range statements {
			if !isPrologueDirective(statement) {
				return
			}

			if binder.isUseStrictPrologueDirective(statement /* as ExpressionStatement */) {
				binder.inStrictMode = true
				return
			}
		}
	}
}

// / Should be called only on prologue directives (isPrologueDirective(node) should be true)
func (binder *Binder) isUseStrictPrologueDirective(node ExpressionStatement) bool {
	nodeText := getSourceTextOfNodeFromSourceFile(binder.file, node.expression)

	// Note: the node text must be exactly "use strict" or 'use strict'.  It is not ok for the
	// string to contain unicode escapes (as per ES5).
	return nodeText == "\"use strict\"" || nodeText == "'use strict'"
}

func (binder *Binder) bindWorker(node Node) /* TODO(TS-TO-GO) inferred type number | void | Symbol */ any {
	switch node.kind {
	case SyntaxKindIdentifier:
		if node.flags & NodeFlagsIdentifierIsInJSDocNamespace {
			parentNode := node.parent
			for parentNode && !isJSDocTypeAlias(parentNode) {
				parentNode = parentNode.parent
			}
			binder.bindBlockScopedDeclaration(parentNode /* as Declaration */, SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
			break
		}
		fallthrough
	case SyntaxKindThisKeyword:
		if binder.currentFlow && (isExpression(node) || binder.parent.kind == SyntaxKindShorthandPropertyAssignment) {
			(node /* as Identifier | ThisExpression */).flowNode = binder.currentFlow
		}
		return binder.checkContextualIdentifier(node /* as Identifier */)
	case SyntaxKindQualifiedName:
		if binder.currentFlow && isPartOfTypeQuery(node) {
			(node /* as QualifiedName */).flowNode = binder.currentFlow
		}
	case SyntaxKindMetaProperty,
		SyntaxKindSuperKeyword:
		(node /* as MetaProperty | SuperExpression */).flowNode = binder.currentFlow
	case SyntaxKindPrivateIdentifier:
		return binder.checkPrivateIdentifier(node /* as PrivateIdentifier */)
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		expr := node /* as PropertyAccessExpression | ElementAccessExpression */
		if binder.currentFlow && binder.isNarrowableReference(expr) {
			expr.flowNode = binder.currentFlow
		}
		if isSpecialPropertyDeclaration(expr) {
			binder.bindSpecialPropertyDeclaration(expr)
		}
		if isInJSFile(expr) && binder.file.commonJsModuleIndicator && isModuleExportsAccessExpression(expr) && !lookupSymbolForName(binder.blockScopeContainer, "module" /* as __String */) {
			binder.declareSymbol(binder.file.locals /*parent*/, nil, expr.expression, SymbolFlagsFunctionScopedVariable|SymbolFlagsModuleExports, SymbolFlagsFunctionScopedVariableExcludes)
		}
	case SyntaxKindBinaryExpression:
		specialKind := getAssignmentDeclarationKind(node /* as BinaryExpression */)
		switch specialKind {
		case AssignmentDeclarationKindExportsProperty:
			binder.bindExportsPropertyAssignment(node /* as BindableStaticPropertyAssignmentExpression */)
		case AssignmentDeclarationKindModuleExports:
			binder.bindModuleExportsAssignment(node /* as BindablePropertyAssignmentExpression */)
		case AssignmentDeclarationKindPrototypeProperty:
			binder.bindPrototypePropertyAssignment((node /* as BindableStaticPropertyAssignmentExpression */).left, node)
		case AssignmentDeclarationKindPrototype:
			binder.bindPrototypeAssignment(node /* as BindableStaticPropertyAssignmentExpression */)
		case AssignmentDeclarationKindThisProperty:
			binder.bindThisPropertyAssignment(node /* as BindablePropertyAssignmentExpression */)
		case AssignmentDeclarationKindProperty:
			expression := ((node /* as BinaryExpression */).left /* as AccessExpression */).expression
			if isInJSFile(node) && isIdentifier(expression) {
				symbol := lookupSymbolForName(binder.blockScopeContainer, expression.escapedText)
				if isThisInitializedDeclaration(symbol. /* ? */ valueDeclaration) {
					binder.bindThisPropertyAssignment(node /* as BindablePropertyAssignmentExpression */)
					break
				}
			}
			binder.bindSpecialPropertyAssignment(node /* as BindablePropertyAssignmentExpression */)
		case AssignmentDeclarationKindNone:
		default:
			Debug.fail("Unknown binary expression special property assignment kind")
		}
		return binder.checkStrictModeBinaryExpression(node /* as BinaryExpression */)
	case SyntaxKindCatchClause:
		return binder.checkStrictModeCatchClause(node /* as CatchClause */)
	case SyntaxKindDeleteExpression:
		return binder.checkStrictModeDeleteExpression(node /* as DeleteExpression */)
	case SyntaxKindPostfixUnaryExpression:
		return binder.checkStrictModePostfixUnaryExpression(node /* as PostfixUnaryExpression */)
	case SyntaxKindPrefixUnaryExpression:
		return binder.checkStrictModePrefixUnaryExpression(node /* as PrefixUnaryExpression */)
	case SyntaxKindWithStatement:
		return binder.checkStrictModeWithStatement(node /* as WithStatement */)
	case SyntaxKindLabeledStatement:
		return binder.checkStrictModeLabeledStatement(node /* as LabeledStatement */)
	case SyntaxKindThisType:
		binder.seenThisKeyword = true
		return
	case SyntaxKindTypePredicate:
	case SyntaxKindTypeParameter:
		return binder.bindTypeParameter(node /* as TypeParameterDeclaration */)
	case SyntaxKindParameter:
		return binder.bindParameter(node /* as ParameterDeclaration */)
	case SyntaxKindVariableDeclaration:
		return binder.bindVariableDeclarationOrBindingElement(node /* as VariableDeclaration */)
	case SyntaxKindBindingElement:
		(node /* as BindingElement */).flowNode = binder.currentFlow
		return binder.bindVariableDeclarationOrBindingElement(node /* as BindingElement */)
	case SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature:
		return binder.bindPropertyWorker(node /* as PropertyDeclaration | PropertySignature */)
	case SyntaxKindPropertyAssignment,
		SyntaxKindShorthandPropertyAssignment:
		return binder.bindPropertyOrMethodOrAccessor(node /* as Declaration */, SymbolFlagsProperty, SymbolFlagsPropertyExcludes)
	case SyntaxKindEnumMember:
		return binder.bindPropertyOrMethodOrAccessor(node /* as Declaration */, SymbolFlagsEnumMember, SymbolFlagsEnumMemberExcludes)
	case SyntaxKindCallSignature,
		SyntaxKindConstructSignature,
		SyntaxKindIndexSignature:
		return binder.declareSymbolAndAddToSymbolTable(node /* as Declaration */, SymbolFlagsSignature, SymbolFlagsNone)
	case SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature:
		return binder.bindPropertyOrMethodOrAccessor(node /* as Declaration */, SymbolFlagsMethod|(__COND__((node /* as MethodDeclaration */).questionToken, SymbolFlagsOptional, SymbolFlagsNone)), __COND__(isObjectLiteralMethod(node), SymbolFlagsPropertyExcludes, SymbolFlagsMethodExcludes))
	case SyntaxKindFunctionDeclaration:
		return binder.bindFunctionDeclaration(node /* as FunctionDeclaration */)
	case SyntaxKindConstructor:
		return binder.declareSymbolAndAddToSymbolTable(node /* as Declaration */, SymbolFlagsConstructor /*symbolExcludes:*/, SymbolFlagsNone)
	case SyntaxKindGetAccessor:
		return binder.bindPropertyOrMethodOrAccessor(node /* as Declaration */, SymbolFlagsGetAccessor, SymbolFlagsGetAccessorExcludes)
	case SyntaxKindSetAccessor:
		return binder.bindPropertyOrMethodOrAccessor(node /* as Declaration */, SymbolFlagsSetAccessor, SymbolFlagsSetAccessorExcludes)
	case SyntaxKindFunctionType,
		SyntaxKindJSDocFunctionType,
		SyntaxKindJSDocSignature,
		SyntaxKindConstructorType:
		return binder.bindFunctionOrConstructorType(node /* as SignatureDeclaration | JSDocSignature */)
	case SyntaxKindTypeLiteral,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindMappedType:
		return binder.bindAnonymousTypeWorker(node /* as TypeLiteralNode | MappedTypeNode | JSDocTypeLiteral */)
	case SyntaxKindJSDocClassTag:
		return binder.bindJSDocClassTag(node /* as JSDocClassTag */)
	case SyntaxKindObjectLiteralExpression:
		return binder.bindObjectLiteralExpression(node /* as ObjectLiteralExpression */)
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return binder.bindFunctionExpression(node /* as FunctionExpression | ArrowFunction */)
	case SyntaxKindCallExpression:
		assignmentKind := getAssignmentDeclarationKind(node /* as CallExpression */)
		switch assignmentKind {
		case AssignmentDeclarationKindObjectDefinePropertyValue:
			return binder.bindObjectDefinePropertyAssignment(node /* as BindableObjectDefinePropertyCall */)
		case AssignmentDeclarationKindObjectDefinePropertyExports:
			return binder.bindObjectDefinePropertyExport(node /* as BindableObjectDefinePropertyCall */)
		case AssignmentDeclarationKindObjectDefinePrototypeProperty:
			return binder.bindObjectDefinePrototypeProperty(node /* as BindableObjectDefinePropertyCall */)
		case AssignmentDeclarationKindNone:
		default:
			return Debug.fail("Unknown call expression assignment declaration kind")
		}
		if isInJSFile(node) {
			binder.bindCallExpression(node /* as CallExpression */)
		}
	case SyntaxKindClassExpression,
		SyntaxKindClassDeclaration:
		binder.inStrictMode = true
		return binder.bindClassLikeDeclaration(node /* as ClassLikeDeclaration */)
	case SyntaxKindInterfaceDeclaration:
		return binder.bindBlockScopedDeclaration(node /* as Declaration */, SymbolFlagsInterface, SymbolFlagsInterfaceExcludes)
	case SyntaxKindTypeAliasDeclaration:
		return binder.bindBlockScopedDeclaration(node /* as Declaration */, SymbolFlagsTypeAlias, SymbolFlagsTypeAliasExcludes)
	case SyntaxKindEnumDeclaration:
		return binder.bindEnumDeclaration(node /* as EnumDeclaration */)
	case SyntaxKindModuleDeclaration:
		return binder.bindModuleDeclaration(node /* as ModuleDeclaration */)
	case SyntaxKindJsxAttributes:
		return binder.bindJsxAttributes(node /* as JsxAttributes */)
	case SyntaxKindJsxAttribute:
		return binder.bindJsxAttribute(node /* as JsxAttribute */, SymbolFlagsProperty, SymbolFlagsPropertyExcludes)
	case SyntaxKindImportEqualsDeclaration,
		SyntaxKindNamespaceImport,
		SyntaxKindImportSpecifier,
		SyntaxKindExportSpecifier:
		return binder.declareSymbolAndAddToSymbolTable(node /* as Declaration */, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	case SyntaxKindNamespaceExportDeclaration:
		return binder.bindNamespaceExportDeclaration(node /* as NamespaceExportDeclaration */)
	case SyntaxKindImportClause:
		return binder.bindImportClause(node /* as ImportClause */)
	case SyntaxKindExportDeclaration:
		return binder.bindExportDeclaration(node /* as ExportDeclaration */)
	case SyntaxKindExportAssignment:
		return binder.bindExportAssignment(node /* as ExportAssignment */)
	case SyntaxKindSourceFile:
		binder.updateStrictModeStatementList((node /* as SourceFile */).statements)
		return binder.bindSourceFileIfExternalModule()
	case SyntaxKindBlock:
		if !isFunctionLikeOrClassStaticBlockDeclaration(node.parent) {
			return
		}
		fallthrough
	case SyntaxKindModuleBlock:
		return binder.updateStrictModeStatementList((node /* as Block | ModuleBlock */).statements)
	case SyntaxKindJSDocParameterTag:
		if node.parent.kind == SyntaxKindJSDocSignature {
			return binder.bindParameter(node /* as JSDocParameterTag */)
		}
		if node.parent.kind != SyntaxKindJSDocTypeLiteral {
			break
		}
		fallthrough
	case SyntaxKindJSDocPropertyTag:
		propTag := node /* as JSDocPropertyLikeTag */
		var flags number
		if propTag.isBracketed || propTag.typeExpression && propTag.typeExpression.type_.kind == SyntaxKindJSDocOptionalType {
			flags = SymbolFlagsProperty | SymbolFlagsOptional
		} else {
			flags = SymbolFlagsProperty
		}
		return binder.declareSymbolAndAddToSymbolTable(propTag, flags, SymbolFlagsPropertyExcludes)
	case SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocEnumTag:
		return (binder.delayedTypeAliases || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: delayedTypeAliases = [] */ TODO)).push(node /* as JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag */)
	case SyntaxKindJSDocOverloadTag:
		return binder.bind((node /* as JSDocOverloadTag */).typeExpression)
	case SyntaxKindJSDocImportTag:
		return (binder.jsDocImports || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: jsDocImports = [] */ TODO)).push(node /* as JSDocImportTag */)
	}
}

func (binder *Binder) bindPropertyWorker(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | PropertySignature */ any) Symbol {
	isAutoAccessor := isAutoAccessorPropertyDeclaration(node)
	var includes /* TODO(TS-TO-GO) inferred type SymbolFlags.Property | SymbolFlags.Accessor */ any
	if isAutoAccessor {
		includes = SymbolFlagsAccessor
	} else {
		includes = SymbolFlagsProperty
	}
	var excludes /* TODO(TS-TO-GO) inferred type SymbolFlags.None | SymbolFlags.AccessorExcludes */ any
	if isAutoAccessor {
		excludes = SymbolFlagsAccessorExcludes
	} else {
		excludes = SymbolFlagsPropertyExcludes
	}
	return binder.bindPropertyOrMethodOrAccessor(node, includes|(__COND__(node.questionToken, SymbolFlagsOptional, SymbolFlagsNone)), excludes)
}

func (binder *Binder) bindAnonymousTypeWorker(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeLiteralNode | MappedTypeNode | JSDocTypeLiteral */ any) Symbol {
	return binder.bindAnonymousDeclaration(node /* as Declaration */, SymbolFlagsTypeLiteral, InternalSymbolNameType)
}

func (binder *Binder) bindSourceFileIfExternalModule() {
	binder.setExportContextFlag(binder.file)
	if isExternalModule(binder.file) {
		binder.bindSourceFileAsExternalModule()
	} else if isJsonSourceFile(binder.file) {
		binder.bindSourceFileAsExternalModule()
		// Create symbol equivalent for the module.exports = {}
		originalSymbol := binder.file.symbol
		binder.declareSymbol(binder.file.symbol.exports, binder.file.symbol, binder.file, SymbolFlagsProperty, SymbolFlagsAll)
		binder.file.symbol = originalSymbol
	}
}

func (binder *Binder) bindSourceFileAsExternalModule() {
	binder.bindAnonymousDeclaration(binder.file, SymbolFlagsValueModule, __TEMPLATE__("\"", removeFileExtension(binder.file.fileName), "\"") /* as __String */)
}

func (binder *Binder) bindExportAssignment(node ExportAssignment) {
	if !binder.container.symbol || !binder.container.symbol.exports {
		// Incorrect export assignment in some sort of block construct
		binder.bindAnonymousDeclaration(node, SymbolFlagsValue, binder.getDeclarationName(node))
	} else {
		var flags /* TODO(TS-TO-GO) inferred type SymbolFlags.Property | SymbolFlags.Alias */ any
		if exportAssignmentIsAlias(node) {
			flags = SymbolFlagsAlias
		} else {
			flags = SymbolFlagsProperty
		}
		// If there is an `export default x;` alias declaration, can't `export default` anything else.
		// (In contrast, you can still have `export default function f() {}` and `export default interface I {}`.)
		symbol := binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node, flags, SymbolFlagsAll)

		if node.isExportEquals {
			// Will be an error later, since the module already has other exports. Just make sure this has a valueDeclaration set.
			setValueDeclaration(symbol, node)
		}
	}
}

func (binder *Binder) bindNamespaceExportDeclaration(node NamespaceExportDeclaration) {
	if some(node.modifiers) {
		binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(node, Diagnostics.Modifiers_cannot_appear_here))
	}
	var diag *DiagnosticMessage
	switch {
	case !isSourceFile(node.parent):
		diag = Diagnostics.Global_module_exports_may_only_appear_at_top_level
	case !isExternalModule(node.parent):
		diag = Diagnostics.Global_module_exports_may_only_appear_in_module_files
	case !node.parent.isDeclarationFile:
		diag = Diagnostics.Global_module_exports_may_only_appear_in_declaration_files
	default:
		diag = nil
	}
	if diag {
		binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(node, diag))
	} else {
		binder.file.symbol.globalExports = binder.file.symbol.globalExports || createSymbolTable()
		binder.declareSymbol(binder.file.symbol.globalExports, binder.file.symbol, node, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	}
}

func (binder *Binder) bindExportDeclaration(node ExportDeclaration) {
	if !binder.container.symbol || !binder.container.symbol.exports {
		// Export * in some sort of block construct
		binder.bindAnonymousDeclaration(node, SymbolFlagsExportStar, binder.getDeclarationName(node))
	} else if !node.exportClause {
		// All export * declarations are collected in an __export symbol
		binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node, SymbolFlagsExportStar, SymbolFlagsNone)
	} else if isNamespaceExport(node.exportClause) {
		// declareSymbol walks up parents to find name text, parent _must_ be set
		// but won't be set by the normal binder walk until `bindChildren` later on.
		setParent(node.exportClause, node)
		binder.declareSymbol(binder.container.symbol.exports, binder.container.symbol, node.exportClause, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	}
}

func (binder *Binder) bindImportClause(node ImportClause) {
	if node.name {
		binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
	}
}

func (binder *Binder) setCommonJsModuleIndicator(node Node) bool {
	if binder.file.externalModuleIndicator && binder.file.externalModuleIndicator != true {
		return false
	}
	if !binder.file.commonJsModuleIndicator {
		binder.file.commonJsModuleIndicator = node
		if !binder.file.externalModuleIndicator {
			binder.bindSourceFileAsExternalModule()
		}
	}
	return true
}

func (binder *Binder) bindObjectDefinePropertyExport(node BindableObjectDefinePropertyCall) {
	if !binder.setCommonJsModuleIndicator(node) {
		return
	}
	symbol := binder.forEachIdentifierInEntityName(node.arguments[0] /*parent*/, nil, func(id Declaration, symbol Symbol) Symbol {
		if symbol {
			binder.addDeclarationToSymbol(symbol, id, SymbolFlagsModule|SymbolFlagsAssignment)
		}
		return symbol
	})
	if symbol {
		flags := SymbolFlagsProperty | SymbolFlagsExportValue
		binder.declareSymbol(symbol.exports, symbol, node, flags, SymbolFlagsNone)
	}
}

func (binder *Binder) bindExportsPropertyAssignment(node BindableStaticPropertyAssignmentExpression) {
	// When we create a property via 'exports.foo = bar', the 'exports.foo' property access
	// expression is the declaration
	if !binder.setCommonJsModuleIndicator(node) {
		return
	}
	symbol := binder.forEachIdentifierInEntityName(node.left.expression /*parent*/, nil, func(id Declaration, symbol Symbol) Symbol {
		if symbol {
			binder.addDeclarationToSymbol(symbol, id, SymbolFlagsModule|SymbolFlagsAssignment)
		}
		return symbol
	})
	if symbol {
		isAlias := isAliasableExpression(node.right) && (isExportsIdentifier(node.left.expression) || isModuleExportsAccessExpression(node.left.expression))
		var flags number
		if isAlias {
			flags = SymbolFlagsAlias
		} else {
			flags = SymbolFlagsProperty | SymbolFlagsExportValue
		}
		setParent(node.left, node)
		binder.declareSymbol(symbol.exports, symbol, node.left, flags, SymbolFlagsNone)
	}
}

func (binder *Binder) bindModuleExportsAssignment(node BindablePropertyAssignmentExpression) {
	// A common practice in node modules is to set 'export = module.exports = {}', this ensures that 'exports'
	// is still pointing to 'module.exports'.
	// We do not want to consider this as 'export=' since a module can have only one of these.
	// Similarly we do not want to treat 'module.exports = exports' as an 'export='.
	if !binder.setCommonJsModuleIndicator(node) {
		return
	}
	assignedExpression := getRightMostAssignedExpression(node.right)
	if isEmptyObjectLiteral(assignedExpression) || binder.container == binder.file && isExportsOrModuleExportsOrAlias(binder.file, assignedExpression) {
		return
	}

	if isObjectLiteralExpression(assignedExpression) && every(assignedExpression.properties, isShorthandPropertyAssignment) {
		forEach(assignedExpression.properties, binder.bindExportAssignedObjectMemberAlias)
		return
	}

	// 'module.exports = expr' assignment
	var flags number
	if exportAssignmentIsAlias(node) {
		flags = SymbolFlagsAlias
	} else {
		flags = SymbolFlagsProperty | SymbolFlagsExportValue | SymbolFlagsValueModule
	}
	symbol := binder.declareSymbol(binder.file.symbol.exports, binder.file.symbol, node, flags|SymbolFlagsAssignment, SymbolFlagsNone)
	setValueDeclaration(symbol, node)
}

func (binder *Binder) bindExportAssignedObjectMemberAlias(node ShorthandPropertyAssignment) {
	binder.declareSymbol(binder.file.symbol.exports, binder.file.symbol, node, SymbolFlagsAlias|SymbolFlagsAssignment, SymbolFlagsNone)
}

func (binder *Binder) bindThisPropertyAssignment(node /* TODO(TS-TO-GO) TypeNode UnionType: BindablePropertyAssignmentExpression | PropertyAccessExpression | LiteralLikeElementAccessExpression */ any) {
	Debug.assert(isInJSFile(node))
	// private identifiers *must* be declared (even in JS files)
	hasPrivateIdentifier := (isBinaryExpression(node) && isPropertyAccessExpression(node.left) && isPrivateIdentifier(node.left.name)) || (isPropertyAccessExpression(node) && isPrivateIdentifier(node.name))
	if hasPrivateIdentifier {
		return
	}
	thisContainer := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
	switch thisContainer.kind {
	case SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression:
		var constructorSymbol Symbol = thisContainer.symbol
		if isBinaryExpression(thisContainer.parent) && thisContainer.parent.operatorToken.kind == SyntaxKindEqualsToken {
			l := thisContainer.parent.left
			if isBindableStaticAccessExpression(l) && isPrototypeAccess(l.expression) {
				constructorSymbol = binder.lookupSymbolForPropertyAccess(l.expression.expression, binder.thisParentContainer)
			}
		}

		if constructorSymbol && constructorSymbol.valueDeclaration {
			// Declare a 'member' if the container is an ES5 class or ES6 constructor
			constructorSymbol.members = constructorSymbol.members || createSymbolTable()
			// It's acceptable for multiple 'this' assignments of the same identifier to occur
			if hasDynamicName(node) {
				binder.bindDynamicallyNamedThisPropertyAssignment(node, constructorSymbol, constructorSymbol.members)
			} else {
				binder.declareSymbol(constructorSymbol.members, constructorSymbol, node, SymbolFlagsProperty|SymbolFlagsAssignment, SymbolFlagsPropertyExcludes&~SymbolFlagsProperty)
			}
			binder.addDeclarationToSymbol(constructorSymbol, constructorSymbol.valueDeclaration, SymbolFlagsClass)
		}
	case SyntaxKindConstructor,
		SyntaxKindPropertyDeclaration,
		SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindClassStaticBlockDeclaration:
		containingClass := thisContainer.parent
		var symbolTable SymbolTable
		if isStatic(thisContainer) {
			symbolTable = containingClass.symbol.exports
		} else {
			symbolTable = containingClass.symbol.members
		}
		if hasDynamicName(node) {
			binder.bindDynamicallyNamedThisPropertyAssignment(node, containingClass.symbol, symbolTable)
		} else {
			binder.declareSymbol(symbolTable, containingClass.symbol, node, SymbolFlagsProperty|SymbolFlagsAssignment, SymbolFlagsNone /*isReplaceableByMethod*/, true)
		}
	case SyntaxKindSourceFile:
		if hasDynamicName(node) {
			break
		} else if thisContainer.commonJsModuleIndicator {
			binder.declareSymbol(thisContainer.symbol.exports, thisContainer.symbol, node, SymbolFlagsProperty|SymbolFlagsExportValue, SymbolFlagsNone)
		} else {
			binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsFunctionScopedVariableExcludes)
		}
	case SyntaxKindModuleDeclaration:
	default:
		Debug.failBadSyntaxKind(thisContainer)
	}
}

func (binder *Binder) bindDynamicallyNamedThisPropertyAssignment(node /* TODO(TS-TO-GO) TypeNode UnionType: BinaryExpression | DynamicNamedDeclaration */ any, symbol Symbol, symbolTable SymbolTable) {
	binder.declareSymbol(symbolTable, symbol, node, SymbolFlagsProperty, SymbolFlagsNone /*isReplaceableByMethod*/, true /*isComputedName*/, true)
	binder.addLateBoundAssignmentDeclarationToSymbol(node, symbol)
}

func (binder *Binder) addLateBoundAssignmentDeclarationToSymbol(node /* TODO(TS-TO-GO) TypeNode UnionType: BinaryExpression | DynamicNamedDeclaration */ any, symbol Symbol) {
	if symbol {
		(symbol.assignmentDeclarationMembers || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symbol.assignmentDeclarationMembers = new Map() */ TODO)).set(getNodeId(node), node)
	}
}

func (binder *Binder) bindSpecialPropertyDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | LiteralLikeElementAccessExpression */ any) {
	if node.expression.kind == SyntaxKindThisKeyword {
		binder.bindThisPropertyAssignment(node)
	} else if isBindableStaticAccessExpression(node) && node.parent.parent.kind == SyntaxKindSourceFile {
		if isPrototypeAccess(node.expression) {
			binder.bindPrototypePropertyAssignment(node, node.parent)
		} else {
			binder.bindStaticPropertyAssignment(node)
		}
	}
}

/** For `x.prototype = { p, ... }`, declare members p,... if `x` is function/class/{}, or not declared. */

func (binder *Binder) bindPrototypeAssignment(node BindableStaticPropertyAssignmentExpression) {
	setParent(node.left, node)
	setParent(node.right, node)
	binder.bindPropertyAssignment(node.left.expression, node.left /*isPrototypeProperty*/, false /*containerIsClass*/, true)
}

func (binder *Binder) bindObjectDefinePrototypeProperty(node BindableObjectDefinePropertyCall) {
	namespaceSymbol := binder.lookupSymbolForPropertyAccess((node.arguments[0] /* as PropertyAccessExpression */).expression /* as EntityNameExpression */)
	if namespaceSymbol && namespaceSymbol.valueDeclaration {
		// Ensure the namespace symbol becomes class-like
		binder.addDeclarationToSymbol(namespaceSymbol, namespaceSymbol.valueDeclaration, SymbolFlagsClass)
	}
	binder.bindPotentiallyNewExpandoMemberToNamespace(node, namespaceSymbol /*isPrototypeProperty*/, true)
}

/**
 * For `x.prototype.y = z`, declare a member `y` on `x` if `x` is a function or class, or not declared.
 * Note that jsdoc preceding an ExpressionStatement like `x.prototype.y;` is also treated as a declaration.
 */

func (binder *Binder) bindPrototypePropertyAssignment(lhs BindableStaticAccessExpression, parent Node) {
	// Look up the function in the local scope, since prototype assignments should
	// follow the function declaration
	classPrototype := lhs.expression /* as BindableStaticAccessExpression */
	constructorFunction := classPrototype.expression

	// Fix up parent pointers since we're going to use these nodes before we bind into them
	setParent(constructorFunction, classPrototype)
	setParent(classPrototype, lhs)
	setParent(lhs, binder.parent)

	binder.bindPropertyAssignment(constructorFunction, lhs /*isPrototypeProperty*/, true /*containerIsClass*/, true)
}

func (binder *Binder) bindObjectDefinePropertyAssignment(node BindableObjectDefinePropertyCall) {
	namespaceSymbol := binder.lookupSymbolForPropertyAccess(node.arguments[0])
	isToplevel := node.parent.parent.kind == SyntaxKindSourceFile
	namespaceSymbol = binder.bindPotentiallyMissingNamespaces(namespaceSymbol, node.arguments[0], isToplevel /*isPrototypeProperty*/, false /*containerIsClass*/, false)
	binder.bindPotentiallyNewExpandoMemberToNamespace(node, namespaceSymbol /*isPrototypeProperty*/, false)
}

func (binder *Binder) bindSpecialPropertyAssignment(node BindablePropertyAssignmentExpression) {
	// Class declarations in Typescript do not allow property declarations
	parentSymbol := binder.lookupSymbolForPropertyAccess(node.left.expression, binder.blockScopeContainer) || binder.lookupSymbolForPropertyAccess(node.left.expression, binder.container)
	if !isInJSFile(node) && !isFunctionSymbol(parentSymbol) {
		return
	}
	rootExpr := getLeftmostAccessExpression(node.left)
	if isIdentifier(rootExpr) && lookupSymbolForName(binder.container, rootExpr.escapedText). /* ? */ flags&SymbolFlagsAlias {
		return
	}
	// Fix up parent pointers since we're going to use these nodes before we bind into them
	setParent(node.left, node)
	setParent(node.right, node)
	if isIdentifier(node.left.expression) && binder.container == binder.file && isExportsOrModuleExportsOrAlias(binder.file, node.left.expression) {
		// This can be an alias for the 'exports' or 'module.exports' names, e.g.
		//    var util = module.exports;
		//    util.property = function ...
		binder.bindExportsPropertyAssignment(node /* as BindableStaticPropertyAssignmentExpression */)
	} else if hasDynamicName(node) {
		binder.bindAnonymousDeclaration(node, SymbolFlagsProperty|SymbolFlagsAssignment, InternalSymbolNameComputed)
		sym := binder.bindPotentiallyMissingNamespaces(parentSymbol, node.left.expression, binder.isTopLevelNamespaceAssignment(node.left) /*isPrototypeProperty*/, false /*containerIsClass*/, false)
		binder.addLateBoundAssignmentDeclarationToSymbol(node, sym)
	} else {
		binder.bindStaticPropertyAssignment(cast(node.left, isBindableStaticNameExpression))
	}
}

/**
 * For nodes like `x.y = z`, declare a member 'y' on 'x' if x is a function (or IIFE) or class or {}, or not declared.
 * Also works for expression statements preceded by JSDoc, like / ** @type number * / x.y;
 */

func (binder *Binder) bindStaticPropertyAssignment(node BindableStaticNameExpression) {
	Debug.assert(!isIdentifier(node))
	setParent(node.expression, node)
	binder.bindPropertyAssignment(node.expression, node /*isPrototypeProperty*/, false /*containerIsClass*/, false)
}

func (binder *Binder) bindPotentiallyMissingNamespaces(namespaceSymbol Symbol, entityName BindableStaticNameExpression, isToplevel bool, isPrototypeProperty bool, containerIsClass bool) Symbol {
	if namespaceSymbol. /* ? */ flags & SymbolFlagsAlias {
		return namespaceSymbol
	}
	if isToplevel && !isPrototypeProperty {
		// make symbols or add declarations for intermediate containers
		flags := SymbolFlagsModule | SymbolFlagsAssignment
		excludeFlags := SymbolFlagsValueModuleExcludes & ~SymbolFlagsAssignment
		namespaceSymbol = binder.forEachIdentifierInEntityName(entityName, namespaceSymbol, func(id Declaration, symbol Symbol, parent Symbol) Symbol {
			if symbol {
				binder.addDeclarationToSymbol(symbol, id, flags)
				return symbol
			} else {
				var table SymbolTable
				if parent {
					table = parent.exports
				} else {
					table = binder.file.jsGlobalAugmentations || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: file.jsGlobalAugmentations = createSymbolTable() */ TODO)
				}
				return binder.declareSymbol(table, parent, id, flags, excludeFlags)
			}
		})
	}
	if containerIsClass && namespaceSymbol && namespaceSymbol.valueDeclaration {
		binder.addDeclarationToSymbol(namespaceSymbol, namespaceSymbol.valueDeclaration, SymbolFlagsClass)
	}
	return namespaceSymbol
}

func (binder *Binder) bindPotentiallyNewExpandoMemberToNamespace(declaration /* TODO(TS-TO-GO) TypeNode UnionType: BindableStaticAccessExpression | CallExpression */ any, namespaceSymbol Symbol, isPrototypeProperty bool) {
	if !namespaceSymbol || !binder.isExpandoSymbol(namespaceSymbol) {
		return
	}

	// Set up the members collection if it doesn't exist already
	var symbolTable SymbolTable
	if isPrototypeProperty {
		symbolTable = (namespaceSymbol.members || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: namespaceSymbol.members = createSymbolTable() */ TODO))
	} else {
		symbolTable = (namespaceSymbol.exports || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: namespaceSymbol.exports = createSymbolTable() */ TODO))
	}

	includes := SymbolFlagsNone
	excludes := SymbolFlagsNone
	// Method-like
	if isFunctionLikeDeclaration(getAssignedExpandoInitializer(declaration)) {
		includes = SymbolFlagsMethod
		excludes = SymbolFlagsMethodExcludes
	} else if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
		if some(declaration.arguments[2].properties, func(p /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) bool {
			id := getNameOfDeclaration(p)
			return !!id && isIdentifier(id) && idText(id) == "set"
		}) {
			// We mix in `SymbolFLags.Property` so in the checker `getTypeOfVariableParameterOrProperty` is used for this
			// symbol, instead of `getTypeOfAccessor` (which will assert as there is no real accessor declaration)
			includes |= SymbolFlagsSetAccessor | SymbolFlagsProperty
			excludes |= SymbolFlagsSetAccessorExcludes
		}
		if some(declaration.arguments[2].properties, func(p /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) bool {
			id := getNameOfDeclaration(p)
			return !!id && isIdentifier(id) && idText(id) == "get"
		}) {
			includes |= SymbolFlagsGetAccessor | SymbolFlagsProperty
			excludes |= SymbolFlagsGetAccessorExcludes
		}
	}

	if includes == SymbolFlagsNone {
		includes = SymbolFlagsProperty
		excludes = SymbolFlagsPropertyExcludes
	}

	binder.declareSymbol(symbolTable, namespaceSymbol, declaration, includes|SymbolFlagsAssignment, excludes&~SymbolFlagsAssignment)
}

func (binder *Binder) isTopLevelNamespaceAssignment(propertyAccess BindableAccessExpression) bool {
	if isBinaryExpression(propertyAccess.parent) {
		return binder.getParentOfBinaryExpression(propertyAccess.parent).parent.kind == SyntaxKindSourceFile
	} else {
		return propertyAccess.parent.parent.kind == SyntaxKindSourceFile
	}
}

func (binder *Binder) bindPropertyAssignment(name BindableStaticNameExpression, propertyAccess BindableStaticAccessExpression, isPrototypeProperty bool, containerIsClass bool) {
	namespaceSymbol := binder.lookupSymbolForPropertyAccess(name, binder.blockScopeContainer) || binder.lookupSymbolForPropertyAccess(name, binder.container)
	isToplevel := binder.isTopLevelNamespaceAssignment(propertyAccess)
	namespaceSymbol = binder.bindPotentiallyMissingNamespaces(namespaceSymbol, propertyAccess.expression, isToplevel, isPrototypeProperty, containerIsClass)
	binder.bindPotentiallyNewExpandoMemberToNamespace(propertyAccess, namespaceSymbol, isPrototypeProperty)
}

/**
 * Javascript expando values are:
 * - Functions
 * - classes
 * - namespaces
 * - variables initialized with function expressions
 * -                       with class expressions
 * -                       with empty object literals
 * -                       with non-empty object literals if assigned to the prototype property
 */

func (binder *Binder) isExpandoSymbol(symbol Symbol) bool {
	if symbol.flags & (SymbolFlagsFunction | SymbolFlagsClass | SymbolFlagsNamespaceModule) {
		return true
	}
	node := symbol.valueDeclaration
	if node && isCallExpression(node) {
		return !!getAssignedExpandoInitializer(node)
	}
	var init Expression
	switch {
	case !node:
		init = nil
	case isVariableDeclaration(node):
		init = node.initializer
	case isBinaryExpression(node):
		init = node.right
	case isPropertyAccessExpression(node) && isBinaryExpression(node.parent):
		init = node.parent.right
	default:
		init = nil
	}
	init = init && getRightMostAssignedExpression(init)
	if init {
		isPrototypeAssignment := isPrototypeAccess(__COND__(isVariableDeclaration(node), node.name, __COND__(isBinaryExpression(node), node.left, node)))
		return !!getExpandoInitializer(__COND__(isBinaryExpression(init) && (init.operatorToken.kind == SyntaxKindBarBarToken || init.operatorToken.kind == SyntaxKindQuestionQuestionToken), init.right, init), isPrototypeAssignment)
	}
	return false
}

func (binder *Binder) getParentOfBinaryExpression(expr Node) Node {
	for isBinaryExpression(expr.parent) {
		expr = expr.parent
	}
	return expr.parent
}

func (binder *Binder) lookupSymbolForPropertyAccess(node BindableStaticNameExpression, lookupContainer /* TODO(TS-TO-GO) TypeNode UnionType: IsContainer | IsBlockScopedContainer | EntityNameExpression */ any /*  = container */) Symbol {
	if isIdentifier(node) {
		return lookupSymbolForName(lookupContainer, node.escapedText)
	} else {
		symbol := binder.lookupSymbolForPropertyAccess(node.expression)
		return symbol && symbol.exports && symbol.exports.get(getElementOrPropertyAccessName(node))
	}
}

func (binder *Binder) forEachIdentifierInEntityName(e BindableStaticNameExpression, parent Symbol, action func(e Declaration, symbol Symbol, parent Symbol) Symbol) Symbol {
	if isExportsOrModuleExportsOrAlias(binder.file, e) {
		return binder.file.symbol
	} else if isIdentifier(e) {
		return action(e, binder.lookupSymbolForPropertyAccess(e), binder.parent)
	} else {
		s := binder.forEachIdentifierInEntityName(e.expression, binder.parent, action)
		name := getNameOrArgument(e)
		// unreachable
		if isPrivateIdentifier(name) {
			Debug.fail("unexpected PrivateIdentifier")
		}
		return action(name, s && s.exports && s.exports.get(getElementOrPropertyAccessName(e)), s)
	}
}

func (binder *Binder) bindCallExpression(node CallExpression) {
	// We're only inspecting call expressions to detect CommonJS modules, so we can skip
	// this check if we've already seen the module indicator
	if !binder.file.commonJsModuleIndicator && isRequireCall(node /*requireStringLiteralLikeArgument*/, false) {
		binder.setCommonJsModuleIndicator(node)
	}
}

func (binder *Binder) bindClassLikeDeclaration(node ClassLikeDeclaration) {
	if node.kind == SyntaxKindClassDeclaration {
		binder.bindBlockScopedDeclaration(node, SymbolFlagsClass, SymbolFlagsClassExcludes)
	} else {
		var bindingName __String
		if node.name {
			bindingName = node.name.escapedText
		} else {
			bindingName = InternalSymbolNameClass
		}
		binder.bindAnonymousDeclaration(node, SymbolFlagsClass, bindingName)
		// Add name of class expression into the map for semantic classifier
		if node.name {
			binder.classifiableNames.add(node.name.escapedText)
		}
	}

	TODO_IDENTIFIER := node

	// TypeScript 1.0 spec (April 2014): 8.4
	// Every class automatically contains a static property member named 'prototype', the
	// type of which is an instantiation of the class type with type Any supplied as a type
	// argument for each type parameter. It is an error to explicitly declare a static
	// property member with the name 'prototype'.
	//
	// Note: we check for this here because this class may be merging into a module.  The
	// module might have an exported variable called 'prototype'.  We can't allow that as
	// that would clash with the built-in 'prototype' for the class.
	prototypeSymbol := binder.createSymbol(SymbolFlagsProperty|SymbolFlagsPrototype, "prototype" /* as __String */)
	symbolExport := symbol.exports.get(prototypeSymbol.escapedName)
	if symbolExport {
		if node.name {
			setParent(node.name, node)
		}
		binder.file.bindDiagnostics.push(binder.createDiagnosticForNode(symbolExport.declarations[0], Diagnostics.Duplicate_identifier_0, symbolName(prototypeSymbol)))
	}
	symbol.exports.set(prototypeSymbol.escapedName, prototypeSymbol)
	prototypeSymbol.parent = symbol
}

func (binder *Binder) bindEnumDeclaration(node EnumDeclaration) {
	if isEnumConst(node) {
		return binder.bindBlockScopedDeclaration(node, SymbolFlagsConstEnum, SymbolFlagsConstEnumExcludes)
	} else {
		return binder.bindBlockScopedDeclaration(node, SymbolFlagsRegularEnum, SymbolFlagsRegularEnumExcludes)
	}
}

func (binder *Binder) bindVariableDeclarationOrBindingElement(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement */ any) {
	if binder.inStrictMode {
		binder.checkStrictModeEvalOrArguments(node, node.name)
	}

	if !isBindingPattern(node.name) {
		var possibleVariableDecl /* TODO(TS-TO-GO) inferred type VariableDeclaration | ParameterDeclaration | BindingElement */ any
		if node.kind == SyntaxKindVariableDeclaration {
			possibleVariableDecl = node
		} else {
			possibleVariableDecl = node.parent.parent
		}
		if isInJSFile(node) && isVariableDeclarationInitializedToBareOrAccessedRequire(possibleVariableDecl) && !getJSDocTypeTag(node) && !(getCombinedModifierFlags(node) & ModifierFlagsExport) {
			binder.declareSymbolAndAddToSymbolTable(node /* as Declaration */, SymbolFlagsAlias, SymbolFlagsAliasExcludes)
		} else if isBlockOrCatchScoped(node) {
			binder.bindBlockScopedDeclaration(node, SymbolFlagsBlockScopedVariable, SymbolFlagsBlockScopedVariableExcludes)
		} else if isPartOfParameterDeclaration(node) {
			// It is safe to walk up parent chain to find whether the node is a destructuring parameter declaration
			// because its parent chain has already been set up, since parents are set before descending into children.
			//
			// If node is a binding element in parameter declaration, we need to use ParameterExcludes.
			// Using ParameterExcludes flag allows the compiler to report an error on duplicate identifiers in Parameter Declaration
			// For example:
			//      function foo([a,a]) {} // Duplicate Identifier error
			//      function bar(a,a) {}   // Duplicate Identifier error, parameter declaration in this case is handled in bindParameter
			//                             // which correctly set excluded symbols
			binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsParameterExcludes)
		} else {
			binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsFunctionScopedVariableExcludes)
		}
	}
}

func (binder *Binder) bindParameter(node /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any) {
	if node.kind == SyntaxKindJSDocParameterTag && binder.container.kind != SyntaxKindJSDocSignature {
		return
	}
	if binder.inStrictMode && !(node.flags & NodeFlagsAmbient) {
		// It is a SyntaxError if the identifier eval or arguments appears within a FormalParameterList of a
		// strict mode FunctionLikeDeclaration or FunctionExpression(13.1)
		binder.checkStrictModeEvalOrArguments(node, node.name)
	}

	if isBindingPattern(node.name) {
		binder.bindAnonymousDeclaration(node, SymbolFlagsFunctionScopedVariable, "__"+(node /* as ParameterDeclaration */).parent.parameters.indexOf(node /* as ParameterDeclaration */) /* as __String */)
	} else {
		binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunctionScopedVariable, SymbolFlagsParameterExcludes)
	}

	// If this is a property-parameter, then also declare the property symbol into the
	// containing class.
	if isParameterPropertyDeclaration(node, node.parent) {
		classDeclaration := node.parent.parent
		binder.declareSymbol(classDeclaration.symbol.members, classDeclaration.symbol, node, SymbolFlagsProperty|(__COND__(node.questionToken, SymbolFlagsOptional, SymbolFlagsNone)), SymbolFlagsPropertyExcludes)
	}
}

func (binder *Binder) bindFunctionDeclaration(node FunctionDeclaration) {
	if !binder.file.isDeclarationFile && !(node.flags & NodeFlagsAmbient) {
		if isAsyncFunction(node) {
			binder.emitFlags |= NodeFlagsHasAsyncFunctions
		}
	}

	binder.checkStrictModeFunctionName(node)
	if binder.inStrictMode {
		binder.checkStrictModeFunctionDeclaration(node)
		binder.bindBlockScopedDeclaration(node, SymbolFlagsFunction, SymbolFlagsFunctionExcludes)
	} else {
		binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsFunction, SymbolFlagsFunctionExcludes)
	}
}

func (binder *Binder) bindFunctionExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionExpression | ArrowFunction */ any) Symbol {
	if !binder.file.isDeclarationFile && !(node.flags & NodeFlagsAmbient) {
		if isAsyncFunction(node) {
			binder.emitFlags |= NodeFlagsHasAsyncFunctions
		}
	}
	if binder.currentFlow {
		node.flowNode = binder.currentFlow
	}
	binder.checkStrictModeFunctionName(node)
	var bindingName __String
	if node.name {
		bindingName = node.name.escapedText
	} else {
		bindingName = InternalSymbolNameFunction
	}
	return binder.bindAnonymousDeclaration(node, SymbolFlagsFunction, bindingName)
}

func (binder *Binder) bindPropertyOrMethodOrAccessor(node Declaration, symbolFlags SymbolFlags, symbolExcludes SymbolFlags) Symbol {
	if !binder.file.isDeclarationFile && !(node.flags & NodeFlagsAmbient) && isAsyncFunction(node) {
		binder.emitFlags |= NodeFlagsHasAsyncFunctions
	}

	if binder.currentFlow && isObjectLiteralOrClassExpressionMethodOrAccessor(node) {
		node.flowNode = binder.currentFlow
	}

	if hasDynamicName(node) {
		return binder.bindAnonymousDeclaration(node, symbolFlags, InternalSymbolNameComputed)
	} else {
		return binder.declareSymbolAndAddToSymbolTable(node, symbolFlags, symbolExcludes)
	}
}

func (binder *Binder) getInferTypeContainer(node Node) *ConditionalTypeNode {
	extendsType := findAncestor(node, func(n Node) bool {
		return n.parent && isConditionalTypeNode(n.parent) && n.parent.extendsType == n
	})
	return extendsType && extendsType.parent /* as ConditionalTypeNode */
}

func (binder *Binder) bindTypeParameter(node TypeParameterDeclaration) {
	if isJSDocTemplateTag(node.parent) {
		var container *HasLocals = getEffectiveContainerForJSDocTemplateTag(node.parent)
		if container {
			Debug.assertNode(container, canHaveLocals)
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: container.locals ??= createSymbolTable() */ TODO
			binder.declareSymbol(container.locals /*parent*/, nil, node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
		} else {
			binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
		}
	} else if node.parent.kind == SyntaxKindInferType {
		var container *HasLocals = binder.getInferTypeContainer(node.parent)
		if container {
			Debug.assertNode(container, canHaveLocals)
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: container.locals ??= createSymbolTable() */ TODO
			binder.declareSymbol(container.locals /*parent*/, nil, node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
		} else {
			binder.bindAnonymousDeclaration(node, SymbolFlagsTypeParameter, binder.getDeclarationName(node))
			// TODO: GH#18217
		}
	} else {
		binder.declareSymbolAndAddToSymbolTable(node, SymbolFlagsTypeParameter, SymbolFlagsTypeParameterExcludes)
	}
}

// reachability checks

func (binder *Binder) shouldReportErrorOnModuleDeclaration(node ModuleDeclaration) bool {
	instanceState := getModuleInstanceState(node)
	return instanceState == ModuleInstanceStateInstantiated || (instanceState == ModuleInstanceStateConstEnumOnly && shouldPreserveConstEnums(binder.options))
}

func (binder *Binder) checkUnreachable(node Node) bool {
	if !(binder.currentFlow.flags & FlowFlagsUnreachable) {
		return false
	}
	if binder.currentFlow == binder.unreachableFlow {
		reportError := (isStatementButNotDeclaration(node) && node.kind != SyntaxKindEmptyStatement) || node.kind == SyntaxKindClassDeclaration || isEnumDeclarationWithPreservedEmit(node, binder.options) || (node.kind == SyntaxKindModuleDeclaration && binder.shouldReportErrorOnModuleDeclaration(node /* as ModuleDeclaration */))

		if reportError {
			binder.currentFlow = binder.reportedUnreachableFlow

			if !binder.options.allowUnreachableCode {
				// unreachable code is reported if
				// - user has explicitly asked about it AND
				// - statement is in not ambient context (statements in ambient context is already an error
				//   so we should not report extras) AND
				//   - node is not variable statement OR
				//   - node is block scoped variable statement OR
				//   - node is not block scoped variable statement and at least one variable declaration has initializer
				//   Rationale: we don't want to report errors on non-initialized var's since they are hoisted
				//   On the other side we do want to report errors on non-initialized 'lets' because of TDZ
				isError := unreachableCodeIsError(binder.options) && !(node.flags & NodeFlagsAmbient) && (!isVariableStatement(node) || !!(getCombinedNodeFlags(node.declarationList) & NodeFlagsBlockScoped) || node.declarationList.declarations.some(func(d VariableDeclaration) bool {
					return !!d.initializer
				}))

				eachUnreachableRange(node, binder.options, func(start Node, end Node) {
					return binder.errorOrSuggestionOnRange(isError, start, end, Diagnostics.Unreachable_code_detected)
				})
			}
		}
	}
	return true
}

func isEnumDeclarationWithPreservedEmit(node Node, options CompilerOptions) bool {
	return node.kind == SyntaxKindEnumDeclaration && (!isEnumConst(node /* as EnumDeclaration */) || shouldPreserveConstEnums(options))
}

func eachUnreachableRange(node Node, options CompilerOptions, cb func(start Node, last Node)) {
	if isStatement(node) && isExecutableStatement(node) && isBlock(node.parent) {
		TODO_IDENTIFIER := node.parent
		slice := sliceAfter(statements, node)
		getRangesWhere(slice, isExecutableStatement, func(start number, afterEnd number) {
			return cb(slice[start], slice[afterEnd-1])
		})
	} else {
		cb(node, node)
	}

	// As opposed to a pure declaration like an `interface`
	isExecutableStatement := func(s Statement) bool {
		// Don't remove statements that can validly be used before they appear.
		return !isFunctionDeclaration(s) && !isPurelyTypeDeclaration(s) && !(isVariableStatement(s) && !(getCombinedNodeFlags(s) & (NodeFlagsBlockScoped)) && s.declarationList.declarations.some(func(d VariableDeclaration) bool {
			return !d.initializer
		}))
	}

	isPurelyTypeDeclaration := func(s Statement) bool {
		switch s.kind {
		case SyntaxKindInterfaceDeclaration,
			SyntaxKindTypeAliasDeclaration:
			return true
		case SyntaxKindModuleDeclaration:
			return getModuleInstanceState(s /* as ModuleDeclaration */) != ModuleInstanceStateInstantiated
		case SyntaxKindEnumDeclaration:
			return !isEnumDeclarationWithPreservedEmit(s, options)
		default:
			return false
		}
	}

}

/** @internal */

func isExportsOrModuleExportsOrAlias(sourceFile SourceFile, node Expression) bool {
	i := 0
	q := createQueue()
	q.enqueue(node)
	for !q.isEmpty() && i < 100 {
		i++
		node = q.dequeue()
		if isExportsIdentifier(node) || isModuleExportsAccessExpression(node) {
			return true
		} else if isIdentifier(node) {
			symbol := lookupSymbolForName(sourceFile, node.escapedText)
			if !!symbol && !!symbol.valueDeclaration && isVariableDeclaration(symbol.valueDeclaration) && !!symbol.valueDeclaration.initializer {
				init := symbol.valueDeclaration.initializer
				q.enqueue(init)
				if isAssignmentExpression(init /*excludeCompoundAssignment*/, true) {
					q.enqueue(init.left)
					q.enqueue(init.right)
				}
			}
		}
	}
	return false
}

/** @internal */

func getContainerFlags(node Node) ContainerFlags {
	switch node.kind {
	case SyntaxKindClassExpression,
		SyntaxKindClassDeclaration,
		SyntaxKindEnumDeclaration,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindTypeLiteral,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindJsxAttributes:
		return ContainerFlagsIsContainer
	case SyntaxKindInterfaceDeclaration:
		return ContainerFlagsIsContainer | ContainerFlagsIsInterface
	case SyntaxKindModuleDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindMappedType,
		SyntaxKindIndexSignature:
		return ContainerFlagsIsContainer | ContainerFlagsHasLocals
	case SyntaxKindSourceFile:
		return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals
	case SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindMethodDeclaration:
		if isObjectLiteralOrClassExpressionMethodOrAccessor(node) {
			return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals | ContainerFlagsIsFunctionLike | ContainerFlagsIsObjectLiteralOrClassExpressionMethodOrAccessor
		}
		fallthrough
	case SyntaxKindConstructor,
		SyntaxKindFunctionDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindCallSignature,
		SyntaxKindJSDocSignature,
		SyntaxKindJSDocFunctionType,
		SyntaxKindFunctionType,
		SyntaxKindConstructSignature,
		SyntaxKindConstructorType,
		SyntaxKindClassStaticBlockDeclaration:
		return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals | ContainerFlagsIsFunctionLike
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return ContainerFlagsIsContainer | ContainerFlagsIsControlFlowContainer | ContainerFlagsHasLocals | ContainerFlagsIsFunctionLike | ContainerFlagsIsFunctionExpression
	case SyntaxKindModuleBlock:
		return ContainerFlagsIsControlFlowContainer
	case SyntaxKindPropertyDeclaration:
		if (node /* as PropertyDeclaration */).initializer {
			return ContainerFlagsIsControlFlowContainer
		} else {
			return 0
		}
	case SyntaxKindCatchClause,
		SyntaxKindForStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement,
		SyntaxKindCaseBlock:
		return ContainerFlagsIsBlockScopedContainer | ContainerFlagsHasLocals
	case SyntaxKindBlock:
		if isFunctionLike(node.parent) || isClassStaticBlockDeclaration(node.parent) {
			return ContainerFlagsNone
		} else {
			return ContainerFlagsIsBlockScopedContainer | ContainerFlagsHasLocals
		}
	}

	return ContainerFlagsNone
}

func lookupSymbolForName(container Node, name __String) Symbol {
	local := tryCast(container, canHaveLocals). /* ? */ locals. /* ? */ get(name)
	if local {
		return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: local.exportSymbol ?? local */ TODO
	}
	if isSourceFile(container) && container.jsGlobalAugmentations && container.jsGlobalAugmentations.has(name) {
		return container.jsGlobalAugmentations.get(name)
	}
	if canHaveSymbol(container) {
		return container.symbol. /* ? */ exports. /* ? */ get(name)
	}
}
