// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

func findConfigFile(searchPath string, fileExists func(fileName string) bool, configName string /*  = "tsconfig.json" */) *string {
	return forEachAncestorDirectory(searchPath, func(ancestor string) *string {
		fileName := combinePaths(ancestor, configName)
		if fileExists(fileName) {
			return fileName
		} else {
			return nil
		}
	})
}

func resolveTripleslashReference(moduleName string, containingFile string) string {
	basePath := getDirectoryPath(containingFile)
	var referencedFileName string
	if isRootedDiskPath(moduleName) {
		referencedFileName = moduleName
	} else {
		referencedFileName = combinePaths(basePath, moduleName)
	}
	return normalizePath(referencedFileName)
}

/** @internal */

func computeCommonSourceDirectoryOfFilenames(fileNames []string, currentDirectory string, getCanonicalFileName GetCanonicalFileName) string {
	var commonPathComponents *[]string
	failed := forEach(fileNames, func(sourceFile string) *true {
		// Each file contributes into common source file path
		sourcePathComponents := getNormalizedPathComponents(sourceFile, currentDirectory)
		sourcePathComponents.pop()
		// The base file name is not part of the common directory path

		if !commonPathComponents {
			// first file
			commonPathComponents = sourcePathComponents
			return
		}

		n := min(commonPathComponents.length, sourcePathComponents.length)
		for i := 0; i < n; i++ {
			if getCanonicalFileName(commonPathComponents[i]) != getCanonicalFileName(sourcePathComponents[i]) {
				if i == 0 {
					// Failed to find any common path component
					return true
				}

				// New common path found that is 0 -> i-1
				commonPathComponents.length = i
				break
			}
		}

		// If the sourcePathComponents was shorter than the commonPathComponents, truncate to the sourcePathComponents
		if sourcePathComponents.length < commonPathComponents.length {
			commonPathComponents.length = sourcePathComponents.length
		}
	})

	// A common path can not be found when paths span multiple drives on windows, for example
	if failed {
		return ""
	}

	if !commonPathComponents {
		return currentDirectory
	}

	return getPathFromPathComponents(commonPathComponents)
}

func createCompilerHost(options CompilerOptions, setParentNodes bool) CompilerHost {
	return createCompilerHostWorker(options, setParentNodes)
}

/** @internal */

func createGetSourceFile(readFile /* TODO(TS-TO-GO) TypeNode IndexedAccessType: ProgramHost<any>["readFile"] */ any, setParentNodes *bool) /* TODO(TS-TO-GO) TypeNode IndexedAccessType: CompilerHost["getSourceFile"] */ any {
	return func(fileName string, languageVersionOrOptions /* TODO(TS-TO-GO) inferred type ScriptTarget | CreateSourceFileOptions */ any, onError * /* TODO(TS-TO-GO) inferred type ((message: string) => void) */ any) *SourceFile {
		var text *string
		{ // try
			performance.mark("beforeIORead")
			text = readFile(fileName)
			performance.mark("afterIORead")
			performance.measure("I/O Read", "beforeIORead", "afterIORead")
		}
		{ // catch e
			if onError {
				onError(e.message)
			}
			text = ""
		}
		if text != nil {
			return createSourceFile(fileName, text, languageVersionOrOptions, setParentNodes)
		} else {
			return nil
		}
	}
}

/** @internal */

func createWriteFileMeasuringIO(actualWriteFile func(path string, data string, writeByteOrderMark bool), createDirectory func(path string), directoryExists func(path string) bool) /* TODO(TS-TO-GO) TypeNode IndexedAccessType: CompilerHost["writeFile"] */ any {
	return func(fileName string, data string, writeByteOrderMark bool, onError * /* TODO(TS-TO-GO) inferred type ((message: string) => void) */ any) {
		{ // try
			performance.mark("beforeIOWrite")

			// NOTE: If patchWriteFileEnsuringDirectory has been called,
			// the system.writeFile will do its own directory creation and
			// the ensureDirectoriesExist call will always be redundant.
			writeFileEnsuringDirectories(fileName, data, writeByteOrderMark, actualWriteFile, createDirectory, directoryExists)

			performance.mark("afterIOWrite")
			performance.measure("I/O Write", "beforeIOWrite", "afterIOWrite")
		}
		{ // catch e
			if onError {
				onError(e.message)
			}
		}
	}
}

/** @internal */

func createCompilerHostWorker(options CompilerOptions, setParentNodes bool, system System /*  = sys */) CompilerHost {
	existingDirectories := NewMap[string, bool]()
	getCanonicalFileName := createGetCanonicalFileName(system.useCaseSensitiveFileNames)
	directoryExists := func(directoryPath string) bool {
		if existingDirectories.has(directoryPath) {
			return true
		}
		if (compilerHost.directoryExists || system.directoryExists)(directoryPath) {
			existingDirectories.set(directoryPath, true)
			return true
		}
		return false
	}

	getDefaultLibLocation := func() string {
		return getDirectoryPath(normalizePath(system.getExecutingFilePath()))
	}

	newLine := getNewLineCharacter(options)
	realpath := system.realpath && (func(path string) string {
		return system.realpath(path)
	})
	var compilerHost CompilerHost = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getSourceFile": createGetSourceFile(func(fileName string) *string {
			return compilerHost.readFile(fileName)
		}, setParentNodes),
		"getDefaultLibLocation": getDefaultLibLocation,
		"getDefaultLibFileName": func(options CompilerOptions) string {
			return combinePaths(getDefaultLibLocation(), getDefaultLibFileName(options))
		},
		"writeFile": createWriteFileMeasuringIO(func(path string, data string, writeByteOrderMark bool) {
			return system.writeFile(path, data, writeByteOrderMark)
		}, func(path string) {
			return (compilerHost.createDirectory || system.createDirectory)(path)
		}, func(path string) bool {
			return directoryExists(path)
		}),
		"getCurrentDirectory": memoize(func() string {
			return system.getCurrentDirectory()
		}),
		"useCaseSensitiveFileNames": func() bool {
			return system.useCaseSensitiveFileNames
		},
		"getCanonicalFileName": getCanonicalFileName,
		"getNewLine": func() string {
			return newLine
		},
		"fileExists": func(fileName string) bool {
			return system.fileExists(fileName)
		},
		"readFile": func(fileName string) *string {
			return system.readFile(fileName)
		},
		"trace": func(s string) {
			return system.write(s + newLine)
		},
		"directoryExists": func(directoryName string) bool {
			return system.directoryExists(directoryName)
		},
		"getEnvironmentVariable": func(name string) string {
			if system.getEnvironmentVariable {
				return system.getEnvironmentVariable(name)
			} else {
				return ""
			}
		},
		"getDirectories": func(path string) []string {
			return system.getDirectories(path)
		},
		"realpath": realpath,
		"readDirectory": func(path string, extensions []string, include *[]string, exclude []string, depth *number) []string {
			return system.readDirectory(path, extensions, include, exclude, depth)
		},
		"createDirectory": func(d string) {
			return system.createDirectory(d)
		},
		"createHash": maybeBind(system, system.createHash),
	}
	return compilerHost
}

/** @internal */

type CompilerHostLikeForCache struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface CompilerHostLikeForCache { fileExists(fileName: string): boolean; readFile(fileName: string, encoding?: string): string | undefined; directoryExists?(directory: string): boolean; createDirectory?(directory: string): void; writeFile?: WriteFileCallback; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface CompilerHostLikeForCache { fileExists(fileName: string): boolean; readFile(fileName: string, encoding?: string): string | undefined; directoryExists?(directory: string): boolean; createDirectory?(directory: string): void; writeFile?: WriteFileCallback; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface CompilerHostLikeForCache { fileExists(fileName: string): boolean; readFile(fileName: string, encoding?: string): string | undefined; directoryExists?(directory: string): boolean; createDirectory?(directory: string): void; writeFile?: WriteFileCallback; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface CompilerHostLikeForCache { fileExists(fileName: string): boolean; readFile(fileName: string, encoding?: string): string | undefined; directoryExists?(directory: string): boolean; createDirectory?(directory: string): void; writeFile?: WriteFileCallback; } */ writeFile WriteFileCallback
}

/** @internal */

type CompilerHostLikeWithCache struct {
	originalReadFile        func(fileName string, encoding string) *string
	originalFileExists      func(fileName string) bool
	originalDirectoryExists *func(directory string) bool
	originalCreateDirectory *func(directory string)
	originalWriteFile       *WriteFileCallback
	getSourceFileWithCache  *func(fileName string, languageVersionOrOptions /* TODO(TS-TO-GO) TypeNode UnionType: ScriptTarget | CreateSourceFileOptions */ any, onError func(message string), shouldCreateNewSourceFile bool) *SourceFile
	readFileWithCache       func(fileName string) *string
}

/** @internal */

func changeCompilerHostLikeToUseCache(host CompilerHostLikeForCache, toPath func(fileName string) Path, getSourceFile /* TODO(TS-TO-GO) TypeNode IndexedAccessType: CompilerHost["getSourceFile"] */ any) CompilerHostLikeWithCache {
	originalReadFile := host.readFile
	originalFileExists := host.fileExists
	originalDirectoryExists := host.directoryExists
	originalCreateDirectory := host.createDirectory
	originalWriteFile := host.writeFile
	readFileCache := NewMap[Path /* TODO(TS-TO-GO) TypeNode UnionType: string | false */, any]()
	fileExistsCache := NewMap[Path, bool]()
	directoryExistsCache := NewMap[Path, bool]()
	sourceFileCache := NewMap[ResolutionMode, Map[Path, SourceFile]]()

	readFileWithCache := func(fileName string) *string {
		key := toPath(fileName)
		value := readFileCache.get(key)
		if value != nil {
			if value != false {
				return value
			} else {
				return nil
			}
		}
		return setReadFileCache(key, fileName)
	}
	setReadFileCache := func(key Path, fileName string) any {
		newValue := originalReadFile.call(host, fileName)
		readFileCache.set(key, ifElse(newValue != nil, newValue, false))
		return newValue
	}
	host.readFile = func(fileName string) any {
		key := toPath(fileName)
		value := readFileCache.get(key)
		if value != nil {
			if value != false {
				return value
			} else {
				return nil
			}
			// could be .d.ts from output
		}
		// Cache json or buildInfo
		if !fileExtensionIs(fileName, ExtensionJson) && !isBuildInfoFile(fileName) {
			return originalReadFile.call(host, fileName)
		}

		return setReadFileCache(key, fileName)
	}

	var getSourceFileWithCache * /* TODO(TS-TO-GO) TypeNode IndexedAccessType: CompilerHost["getSourceFile"] */ any
	if getSourceFile {
		getSourceFileWithCache = func(fileName string, languageVersionOrOptions /* TODO(TS-TO-GO) inferred type ScriptTarget | CreateSourceFileOptions */ any, onError * /* TODO(TS-TO-GO) inferred type ((message: string) => void) */ any, shouldCreateNewSourceFile *bool) *SourceFile {
			key := toPath(fileName)
			var impliedNodeFormat ResolutionMode
			if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof languageVersionOrOptions */ TODO == "object" {
				impliedNodeFormat = languageVersionOrOptions.impliedNodeFormat
			} else {
				impliedNodeFormat = nil
			}
			forImpliedNodeFormat := sourceFileCache.get(impliedNodeFormat)
			value := forImpliedNodeFormat. /* ? */ get(key)
			if value {
				return value
			}

			sourceFile := getSourceFile(fileName, languageVersionOrOptions, onError, shouldCreateNewSourceFile)
			if sourceFile && (isDeclarationFileName(fileName) || fileExtensionIs(fileName, ExtensionJson)) {
				sourceFileCache.set(impliedNodeFormat, (forImpliedNodeFormat || NewMap()).set(key, sourceFile))
			}
			return sourceFile
		}
	} else {
		getSourceFileWithCache = nil
	}

	// fileExists for any kind of extension
	host.fileExists = func(fileName string) any {
		key := toPath(fileName)
		value := fileExistsCache.get(key)
		if value != nil {
			return value
		}
		newValue := originalFileExists.call(host, fileName)
		fileExistsCache.set(key, !!newValue)
		return newValue
	}
	if originalWriteFile {
		host.writeFile = func(fileName string, data string, rest /* TODO(TS-TO-GO) inferred type [writeByteOrderMark: boolean, onError?: ((message: string) => void) | undefined, sourceFiles?: readonly SourceFile[] | undefined, data?: WriteFileCallbackData | undefined] */ any) {
			key := toPath(fileName)
			fileExistsCache.delete(key)

			value := readFileCache.get(key)
			if value != nil && value != data {
				readFileCache.delete(key)
				sourceFileCache.forEach(func(map_ Map[Path, SourceFile]) bool {
					return map_.delete(key)
				})
			} else if getSourceFileWithCache {
				sourceFileCache.forEach(func(map_ Map[Path, SourceFile]) {
					sourceFile := map_.get(key)
					if sourceFile && sourceFile.text != data {
						map_.delete(key)
					}
				})
			}
			originalWriteFile.call(host, fileName, data, rest...)
		}
	}

	// directoryExists
	if originalDirectoryExists {
		host.directoryExists = func(directory string) any {
			key := toPath(directory)
			value := directoryExistsCache.get(key)
			if value != nil {
				return value
			}
			newValue := originalDirectoryExists.call(host, directory)
			directoryExistsCache.set(key, !!newValue)
			return newValue
		}

		if originalCreateDirectory {
			host.createDirectory = func(directory string) {
				key := toPath(directory)
				directoryExistsCache.delete(key)
				originalCreateDirectory.call(host, directory)
			}
		}
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"originalReadFile":        originalReadFile,
		"originalFileExists":      originalFileExists,
		"originalDirectoryExists": originalDirectoryExists,
		"originalCreateDirectory": originalCreateDirectory,
		"originalWriteFile":       originalWriteFile,
		"getSourceFileWithCache":  getSourceFileWithCache,
		"readFileWithCache":       readFileWithCache,
	}
}

/* OVERLOAD: export function getPreEmitDiagnostics(program: Program, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[]; */
/** @internal */
/* OVERLOAD: export function getPreEmitDiagnostics(program: BuilderProgram, sourceFile?: SourceFile, cancellationToken?: CancellationToken): readonly Diagnostic[]; */
// eslint-disable-line @typescript-eslint/unified-signatures
func getPreEmitDiagnostics(program /* TODO(TS-TO-GO) TypeNode UnionType: Program | BuilderProgram */ any, sourceFile SourceFile, cancellationToken CancellationToken) []Diagnostic {
	var diagnostics *[]Diagnostic
	diagnostics = addRange(diagnostics, program.getConfigFileParsingDiagnostics())
	diagnostics = addRange(diagnostics, program.getOptionsDiagnostics(cancellationToken))
	diagnostics = addRange(diagnostics, program.getSyntacticDiagnostics(sourceFile, cancellationToken))
	diagnostics = addRange(diagnostics, program.getGlobalDiagnostics(cancellationToken))
	diagnostics = addRange(diagnostics, program.getSemanticDiagnostics(sourceFile, cancellationToken))

	if getEmitDeclarations(program.getCompilerOptions()) {
		diagnostics = addRange(diagnostics, program.getDeclarationDiagnostics(sourceFile, cancellationToken))
	}

	return sortAndDeduplicateDiagnostics(diagnostics || emptyArray)
}

type FormatDiagnosticsHost struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface FormatDiagnosticsHost { getCurrentDirectory(): string; getCanonicalFileName(fileName: string): string; getNewLine(): string; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface FormatDiagnosticsHost { getCurrentDirectory(): string; getCanonicalFileName(fileName: string): string; getNewLine(): string; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface FormatDiagnosticsHost { getCurrentDirectory(): string; getCanonicalFileName(fileName: string): string; getNewLine(): string; } */
}

func formatDiagnostics(diagnostics []Diagnostic, host FormatDiagnosticsHost) string {
	output := ""

	for _, diagnostic := range diagnostics {
		output += formatDiagnostic(diagnostic, host)
	}
	return output
}

func formatDiagnostic(diagnostic Diagnostic, host FormatDiagnosticsHost) string {
	errorMessage := __TEMPLATE__(diagnosticCategoryName(diagnostic), " TS", diagnostic.code, ": ", flattenDiagnosticMessageText(diagnostic.messageText, host.getNewLine()), host.getNewLine())

	if diagnostic.file {
		TODO_IDENTIFIER := getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start)
		// TODO: GH#18217
		fileName := diagnostic.file.fileName
		relativeFileName := convertToRelativePath(fileName, host.getCurrentDirectory(), func(fileName string) string {
			return host.getCanonicalFileName(fileName)
		})
		return __TEMPLATE__(relativeFileName, "(", line+1, ",", character+1, "): ") + errorMessage
	}

	return errorMessage
}

/** @internal */

type ForegroundColorEscapeSequences string

const (
	ForegroundColorEscapeSequencesGrey   ForegroundColorEscapeSequences = "\u001b[90m"
	ForegroundColorEscapeSequencesRed    ForegroundColorEscapeSequences = "\u001b[91m"
	ForegroundColorEscapeSequencesYellow ForegroundColorEscapeSequences = "\u001b[93m"
	ForegroundColorEscapeSequencesBlue   ForegroundColorEscapeSequences = "\u001b[94m"
	ForegroundColorEscapeSequencesCyan   ForegroundColorEscapeSequences = "\u001b[96m"
)

var gutterStyleSequence = "\u001b[7m"
var gutterSeparator = " "
var resetEscapeSequence = "\u001b[0m"
var ellipsis = "..."
var halfIndent = "  "
var indent = "    "

func getCategoryFormat(category DiagnosticCategory) ForegroundColorEscapeSequences {
	switch category {
	case DiagnosticCategoryError:
		return ForegroundColorEscapeSequencesRed
	case DiagnosticCategoryWarning:
		return ForegroundColorEscapeSequencesYellow
	case DiagnosticCategorySuggestion:
		return Debug.fail("Should never get an Info diagnostic on the command line.")
	case DiagnosticCategoryMessage:
		return ForegroundColorEscapeSequencesBlue
	}
}

/** @internal */

func formatColorAndReset(text string, formatStyle string) string {
	return formatStyle + text + resetEscapeSequence
}

func formatCodeSpan(file SourceFile, start number, length number, indent string, squiggleColor ForegroundColorEscapeSequences, host FormatDiagnosticsHost) string {
	TODO_IDENTIFIER := getLineAndCharacterOfPosition(file, start)
	TODO_IDENTIFIER := getLineAndCharacterOfPosition(file, start+length)
	lastLineInFile := getLineAndCharacterOfPosition(file, file.text.length).line

	hasMoreThanFiveLines := (lastLine - firstLine) >= 4
	gutterWidth := (lastLine + 1 + "").length
	if hasMoreThanFiveLines {
		gutterWidth = max(ellipsis.length, gutterWidth)
	}

	context := ""
	for i := firstLine; i <= lastLine; i++ {
		context += host.getNewLine()
		// If the error spans over 5 lines, we'll only show the first 2 and last 2 lines,
		// so we'll skip ahead to the second-to-last line.
		if hasMoreThanFiveLines && firstLine+1 < i && i < lastLine-1 {
			context += indent + formatColorAndReset(ellipsis.padStart(gutterWidth), gutterStyleSequence) + gutterSeparator + host.getNewLine()
			i = lastLine - 1
		}

		lineStart := getPositionOfLineAndCharacter(file, i, 0)
		var lineEnd number
		if i < lastLineInFile {
			lineEnd = getPositionOfLineAndCharacter(file, i+1, 0)
		} else {
			lineEnd = file.text.length
		}
		lineContent := file.text.slice(lineStart, lineEnd)
		lineContent = lineContent.trimEnd()
		// trim from end
		lineContent = lineContent.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\t/g */ TODO, " ")

		// Output the gutter and the actual contents of the line.
		context += indent + formatColorAndReset((i+1+"").padStart(gutterWidth), gutterStyleSequence) + gutterSeparator
		context += lineContent + host.getNewLine()

		// Output the gutter and the error span for the line using tildes.
		context += indent + formatColorAndReset(PAD_START("", gutterWidth), gutterStyleSequence) + gutterSeparator
		context += squiggleColor
		if i == firstLine {
			// If we're on the last line, then limit it to the last character of the last line.
			// Otherwise, we'll just squiggle the rest of the line, giving 'slice' no end position.
			var lastCharForLine *number
			if i == lastLine {
				lastCharForLine = lastLineChar
			} else {
				lastCharForLine = nil
			}

			context += lineContent.slice(0, firstLineChar).replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\S/g */ TODO, " ")
			context += lineContent.slice(firstLineChar, lastCharForLine).replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /./g */ TODO, "~")
		} else if i == lastLine {
			context += lineContent.slice(0, lastLineChar).replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /./g */ TODO, "~")
		} else {
			// Squiggle the entire line.
			context += lineContent.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /./g */ TODO, "~")
		}
		context += resetEscapeSequence
	}
	return context
}

/** @internal */

func formatLocation(file SourceFile, start number, host FormatDiagnosticsHost, color /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof formatColorAndReset */ any /*  = formatColorAndReset */) string {
	TODO_IDENTIFIER := getLineAndCharacterOfPosition(file, start)
	// TODO: GH#18217
	var relativeFileName string
	if host {
		relativeFileName = convertToRelativePath(file.fileName, host.getCurrentDirectory(), func(fileName string) string {
			return host.getCanonicalFileName(fileName)
		})
	} else {
		relativeFileName = file.fileName
	}

	output := ""
	output += color(relativeFileName, ForegroundColorEscapeSequencesCyan)
	output += ":"
	output += color(__TEMPLATE__(firstLine+1), ForegroundColorEscapeSequencesYellow)
	output += ":"
	output += color(__TEMPLATE__(firstLineChar+1), ForegroundColorEscapeSequencesYellow)
	return output
}

func formatDiagnosticsWithColorAndContext(diagnostics []Diagnostic, host FormatDiagnosticsHost) string {
	output := ""
	for _, diagnostic := range diagnostics {
		if diagnostic.file {
			TODO_IDENTIFIER := diagnostic
			output += formatLocation(file, start, host)
			// TODO: GH#18217
			output += " - "
		}

		output += formatColorAndReset(diagnosticCategoryName(diagnostic), getCategoryFormat(diagnostic.category))
		output += formatColorAndReset(__TEMPLATE__(" TS", diagnostic.code, ": "), ForegroundColorEscapeSequencesGrey)
		output += flattenDiagnosticMessageText(diagnostic.messageText, host.getNewLine())

		if diagnostic.file && diagnostic.code != Diagnostics.File_appears_to_be_binary.code {
			output += host.getNewLine()
			output += formatCodeSpan(diagnostic.file, diagnostic.start, diagnostic.length, "", getCategoryFormat(diagnostic.category), host)
			// TODO: GH#18217
		}
		if diagnostic.relatedInformation {
			output += host.getNewLine()
			for _, TODO_IDENTIFIER := range diagnostic.relatedInformation {
				if file {
					output += host.getNewLine()
					output += halfIndent + formatLocation(file, start, host)
					// TODO: GH#18217
					output += formatCodeSpan(file, start, length, indent, ForegroundColorEscapeSequencesCyan, host)
					// TODO: GH#18217
				}
				output += host.getNewLine()
				output += indent + flattenDiagnosticMessageText(messageText, host.getNewLine())
			}
		}
		output += host.getNewLine()
	}
	return output
}

func flattenDiagnosticMessageText(diag /* TODO(TS-TO-GO) TypeNode UnionType: string | DiagnosticMessageChain | undefined */ any, newLine string, indent number /*  = 0 */) string {
	if isString(diag) {
		return diag
	} else if diag == nil {
		return ""
	}
	result := ""
	if indent {
		result += newLine

		for i := 0; i < indent; i++ {
			result += "  "
		}
	}
	result += diag.messageText
	indent++
	if diag.next {
		for _, kid := range diag.next {
			result += flattenDiagnosticMessageText(kid, newLine, indent)
		}
	}
	return result
}

/**
 * Subset of a SourceFile used to calculate index-based resolutions
 * This includes some internal fields, so unless you have very good reason,
 * (and are willing to use some less stable internals) you should probably just pass a SourceFile.
 *
 * @internal
 */

type SourceFileImportsList struct {
	imports/* TODO(TS-TO-GO) TypeNode IndexedAccessType: SourceFile["imports"] */ any
	moduleAugmentations/* TODO(TS-TO-GO) TypeNode IndexedAccessType: SourceFile["moduleAugmentations"] */ any
	impliedNodeFormat ResolutionMode
	fileName          string
	packageJsonScope/* TODO(TS-TO-GO) TypeNode IndexedAccessType: SourceFile["packageJsonScope"] */ any
}

/**
 * Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly
 * provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.
 */

func getModeForFileReference(ref /* TODO(TS-TO-GO) TypeNode UnionType: FileReference | string */ any, containingFileMode ResolutionMode) ResolutionMode {
	return (ifElse(isString(ref), containingFileMode, ref.resolutionMode)) || containingFileMode
}

/**
 * Use `program.getModeForResolutionAtIndex`, which retrieves the correct `compilerOptions`, instead of this function whenever possible.
 * Calculates the final resolution mode for an import at some index within a file's `imports` list. This is the resolution mode
 * explicitly provided via import attributes, if present, or the syntax the usage would have if emitted to JavaScript. In
 * `--module node16` or `nodenext`, this may depend on the file's `impliedNodeFormat`. In `--module preserve`, it depends only on the
 * input syntax of the reference. In other `module` modes, when overriding import attributes are not provided, this function returns
 * `undefined`, as the result would have no impact on module resolution, emit, or type checking.
 * @param file File to fetch the resolution mode within
 * @param index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations
 * @param compilerOptions The compiler options for the program that owns the file. If the file belongs to a referenced project, the compiler options
 * should be the options of the referenced project, not the referencing project.
 */

/* OVERLOAD: export function getModeForResolutionAtIndex(file: SourceFile, index: number, compilerOptions: CompilerOptions): ResolutionMode; */
/** @internal @knipignore */
// eslint-disable-next-line @typescript-eslint/unified-signatures

/* OVERLOAD: export function getModeForResolutionAtIndex(file: SourceFileImportsList, index: number, compilerOptions: CompilerOptions): ResolutionMode; */
func getModeForResolutionAtIndex(file SourceFileImportsList, index number, compilerOptions CompilerOptions) ResolutionMode {
	// we ensure all elements of file.imports and file.moduleAugmentations have the relevant parent pointers set during program setup,
	// so it's safe to use them even pre-bind
	return getModeForUsageLocationWorker(file, getModuleNameStringLiteralAt(file, index), compilerOptions)
}

/** @internal */

func isExclusivelyTypeOnlyImportOrExport(decl /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) bool {
	if isExportDeclaration(decl) {
		return decl.isTypeOnly
	}
	if decl.importClause. /* ? */ isTypeOnly {
		return true
	}
	return false
}

/**
 * Use `program.getModeForUsageLocation`, which retrieves the correct `compilerOptions`, instead of this function whenever possible.
 * Calculates the final resolution mode for a given module reference node. This function only returns a result when module resolution
 * settings allow differing resolution between ESM imports and CJS requires, or when a mode is explicitly provided via import attributes,
 * which cause an `import` or `require` condition to be used during resolution regardless of module resolution settings. In absence of
 * overriding attributes, and in modes that support differing resolution, the result indicates the syntax the usage would emit to JavaScript.
 * Some examples:
 *
 * ```ts
 * // tsc foo.mts --module nodenext
 * import {} from "mod";
 * // Result: ESNext - the import emits as ESM due to `impliedNodeFormat` set by .mts file extension
 *
 * // tsc foo.cts --module nodenext
 * import {} from "mod";
 * // Result: CommonJS - the import emits as CJS due to `impliedNodeFormat` set by .cts file extension
 *
 * // tsc foo.ts --module preserve --moduleResolution bundler
 * import {} from "mod";
 * // Result: ESNext - the import emits as ESM due to `--module preserve` and `--moduleResolution bundler`
 * // supports conditional imports/exports
 *
 * // tsc foo.ts --module preserve --moduleResolution node10
 * import {} from "mod";
 * // Result: undefined - the import emits as ESM due to `--module preserve`, but `--moduleResolution node10`
 * // does not support conditional imports/exports
 *
 * // tsc foo.ts --module commonjs --moduleResolution node10
 * import type {} from "mod" with { "resolution-mode": "import" };
 * // Result: ESNext - conditional imports/exports always supported with "resolution-mode" attribute
 * ```
 *
 * @param file The file the import or import-like reference is contained within
 * @param usage The module reference string
 * @param compilerOptions The compiler options for the program that owns the file. If the file belongs to a referenced project, the compiler options
 * should be the options of the referenced project, not the referencing project.
 * @returns The final resolution mode of the import
 */

func getModeForUsageLocation(file SourceFile, usage StringLiteralLike, compilerOptions CompilerOptions) ResolutionMode {
	return getModeForUsageLocationWorker(file, usage, compilerOptions)
}

func getModeForUsageLocationWorker(file Pick[SourceFile /* TODO(TS-TO-GO) TypeNode UnionType: "fileName" | "impliedNodeFormat" | "packageJsonScope" */, any], usage StringLiteralLike, compilerOptions CompilerOptions) ResolutionMode {
	if isImportDeclaration(usage.parent) || isExportDeclaration(usage.parent) || isJSDocImportTag(usage.parent) {
		isTypeOnly := isExclusivelyTypeOnlyImportOrExport(usage.parent)
		if isTypeOnly {
			override := getResolutionModeOverride(usage.parent.attributes)
			if override {
				return override
			}
		}
	}
	if usage.parent.parent && isImportTypeNode(usage.parent.parent) {
		override := getResolutionModeOverride(usage.parent.parent.attributes)
		if override {
			return override
		}
	}

	if compilerOptions && importSyntaxAffectsModuleResolution(compilerOptions) {
		return getEmitSyntaxForUsageLocationWorker(file, usage, compilerOptions)
	}
}

func getEmitSyntaxForUsageLocationWorker(file Pick[SourceFile /* TODO(TS-TO-GO) TypeNode UnionType: "fileName" | "impliedNodeFormat" | "packageJsonScope" */, any], usage StringLiteralLike, compilerOptions CompilerOptions) ResolutionMode {
	if !compilerOptions {
		// This should always be provided, but we try to fail somewhat
		// gracefully to allow projects like ts-node time to update.
		return nil
	}
	exprParentParent := walkUpParenthesizedExpressions(usage.parent). /* ? */ parent
	if exprParentParent && isImportEqualsDeclaration(exprParentParent) || isRequireCall(usage.parent /*requireStringLiteralLikeArgument*/, false) {
		return ModuleKindCommonJS
	}
	if isImportCall(walkUpParenthesizedExpressions(usage.parent)) {
		if shouldTransformImportCallWorker(file, compilerOptions) {
			return ModuleKindCommonJS
		} else {
			return ModuleKindESNext
		}
	}
	// If we're in --module preserve on an input file, we know that an import
	// is an import. But if this is a declaration file, we'd prefer to use the
	// impliedNodeFormat. Since we want things to be consistent between the two,
	// we need to issue errors when the user writes ESM syntax in a definitely-CJS
	// file, until/unless declaration emit can indicate a true ESM import. On the
	// other hand, writing CJS syntax in a definitely-ESM file is fine, since declaration
	// emit preserves the CJS syntax.
	fileEmitMode := getEmitModuleFormatOfFileWorker(file, compilerOptions)
	switch {
	case fileEmitMode == ModuleKindCommonJS:
		return ModuleKindCommonJS
	case emitModuleKindIsNonNodeESM(fileEmitMode) || fileEmitMode == ModuleKindPreserve:
		return ModuleKindESNext
	default:
		return nil
	}
}

/** @internal */

func getResolutionModeOverride(node *ImportAttributes, grammarErrorOnNode func(node *Node, diagnostic DiagnosticMessage)) *ResolutionMode {
	if !node {
		return nil
	}
	if length(node.elements) != 1 {
		grammarErrorOnNode(node, ifElse(node.token == SyntaxKindWithKeyword, Diagnostics.Type_import_attributes_should_have_exactly_one_key_resolution_mode_with_value_import_or_require, Diagnostics.Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require))
		return nil
	}
	elem := node.elements[0]
	if !isStringLiteralLike(elem.name) {
		return nil
	}
	if elem.name.text != "resolution-mode" {
		grammarErrorOnNode(elem.name, ifElse(node.token == SyntaxKindWithKeyword, Diagnostics.resolution_mode_is_the_only_valid_key_for_type_import_attributes, Diagnostics.resolution_mode_is_the_only_valid_key_for_type_import_assertions))
		return nil
	}
	if !isStringLiteralLike(elem.value) {
		return nil
	}
	if elem.value.text != "import" && elem.value.text != "require" {
		grammarErrorOnNode(elem.value, Diagnostics.resolution_mode_should_be_either_require_or_import)
		return nil
	}
	if elem.value.text == "import" {
		return ModuleKindESNext
	} else {
		return ModuleKindCommonJS
	}
}

var emptyResolution /* TODO(TS-TO-GO) TypeNode IntersectionType: ResolvedModuleWithFailedLookupLocations & ResolvedTypeReferenceDirectiveWithFailedLookupLocations */ any = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"resolvedModule":                 nil,
	"resolvedTypeReferenceDirective": nil,
}

/** @internal */

type ResolutionWithResolvedFileName struct {
	resolvedFileName *string
	packageId        PackageId
}

/** @internal */

type ResolutionNameAndModeGetter[Entry any, SourceFile any] struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ResolutionNameAndModeGetter<Entry, SourceFile> { getName(entry: Entry): string; getMode(entry: Entry, file: SourceFile, compilerOptions: CompilerOptions): ResolutionMode; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ResolutionNameAndModeGetter<Entry, SourceFile> { getName(entry: Entry): string; getMode(entry: Entry, file: SourceFile, compilerOptions: CompilerOptions): ResolutionMode; } */
}

/** @internal */

type ResolutionLoader[Entry any, Resolution any, SourceFile any] struct {
	nameAndMode ResolutionNameAndModeGetter[Entry, SourceFile]
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ResolutionLoader<Entry, Resolution, SourceFile> { nameAndMode: ResolutionNameAndModeGetter<Entry, SourceFile>; resolve(name: string, mode: ResolutionMode): Resolution; } */
}

func getModuleResolutionName(literal StringLiteralLike) string {
	return literal.text
}

/** @internal */

var moduleResolutionNameAndModeGetter ResolutionNameAndModeGetter[StringLiteralLike, SourceFile] = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"getName": getModuleResolutionName,
	"getMode": func(entry StringLiteralLike, file SourceFile, compilerOptions CompilerOptions) ResolutionMode {
		return getModeForUsageLocation(file, entry, compilerOptions)
	},
}

/** @internal */

func createModuleResolutionLoader(containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, host ModuleResolutionHost, cache *ModuleResolutionCache) ResolutionLoader[StringLiteralLike, ResolvedModuleWithFailedLookupLocations, SourceFile] {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"nameAndMode": moduleResolutionNameAndModeGetter,
		"resolve": func(moduleName string, resolutionMode ResolutionMode) ResolvedModuleWithFailedLookupLocations {
			return resolveModuleName(moduleName, containingFile, options, host, cache, redirectedReference, resolutionMode)
		},
	}
}

func getTypeReferenceResolutionName(entry T) string {
	if !isString(entry) {
		return entry.fileName
	} else {
		return entry
	}
}

var typeReferenceResolutionNameAndModeGetter ResolutionNameAndModeGetter[ /* TODO(TS-TO-GO) TypeNode UnionType: FileReference | string */ any, *SourceFile] = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"getName": getTypeReferenceResolutionName,
	"getMode": func(entry /* TODO(TS-TO-GO) inferred type string | FileReference */ any, file *SourceFile, compilerOptions CompilerOptions) ResolutionMode {
		return getModeForFileReference(entry, file && getDefaultResolutionModeForFileWorker(file, compilerOptions))
	},
}

/** @internal */

func createTypeReferenceResolutionLoader(containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, host ModuleResolutionHost, cache *TypeReferenceDirectiveResolutionCache) ResolutionLoader[T, ResolvedTypeReferenceDirectiveWithFailedLookupLocations, *SourceFile] {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"nameAndMode": typeReferenceResolutionNameAndModeGetter,
		"resolve": func(typeRef string, resoluionMode ResolutionMode) ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
			return resolveTypeReferenceDirective(typeRef, containingFile, options, host, redirectedReference, cache, resoluionMode)
		},
	}
}

/** @internal */

func loadWithModeAwareCache(entries []Entry, containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, containingSourceFile SourceFile, host ModuleResolutionHost, resolutionCache *ResolutionCache, createLoader func(containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, host ModuleResolutionHost, resolutionCache *ResolutionCache) ResolutionLoader[Entry, Resolution, SourceFile]) []Resolution {
	if entries.length == 0 {
		return emptyArray
	}
	var resolutions []Resolution = []never{}
	cache := NewMap[ModeAwareCacheKey, Resolution]()
	loader := createLoader(containingFile, redirectedReference, options, host, resolutionCache)
	for _, entry := range entries {
		name := loader.nameAndMode.getName(entry)
		mode := loader.nameAndMode.getMode(entry, containingSourceFile, redirectedReference. /* ? */ commandLine.options || options)
		key := createModeAwareCacheKey(name, mode)
		result := cache.get(key)
		if !result {
			cache.set(key /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = loader.resolve(name, mode) */, TODO)
		}
		resolutions.push(result)
	}
	return resolutions
}

/** @internal */

func forEachResolvedProjectReference(resolvedProjectReferences *[]*ResolvedProjectReference, cb func(resolvedProjectReference ResolvedProjectReference, parent *ResolvedProjectReference) *T) *T {
	return forEachProjectReference(nil, resolvedProjectReferences, func(resolvedRef *ResolvedProjectReference, parent *ResolvedProjectReference) *T {
		return resolvedRef && cb(resolvedRef, parent)
	})
}

func forEachProjectReference(projectReferences *[]ProjectReference, resolvedProjectReferences *[]*ResolvedProjectReference, cbResolvedRef func(resolvedRef *ResolvedProjectReference, parent *ResolvedProjectReference, index number) *T, cbRef func(projectReferences *[]ProjectReference, parent *ResolvedProjectReference) *T) *T {
	var seenResolvedRefs *Set[Path]
	return worker(projectReferences, resolvedProjectReferences /*parent*/, nil)

	worker := func(projectReferences *[]ProjectReference, resolvedProjectReferences *[]*ResolvedProjectReference, parent *ResolvedProjectReference) *T {
		// Visit project references first
		if cbRef {
			result := cbRef(projectReferences, parent)
			if result {
				return result
			}
		}
		var skipChildren *Set[ResolvedProjectReference]
		return forEach(resolvedProjectReferences, func(resolvedRef *ResolvedProjectReference, index number) *T {
			if resolvedRef && seenResolvedRefs. /* ? */ has(resolvedRef.sourceFile.path) {
				( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: skipChildren ??= new Set() */ TODO).add(resolvedRef)
				// ignore recursives
				return nil
			}
			result := cbResolvedRef(resolvedRef, parent, index)
			if result || !resolvedRef {
				return result
			}
			( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: seenResolvedRefs ||= new Set() */ TODO).add(resolvedRef.sourceFile.path)
		}) || forEach(resolvedProjectReferences, func(resolvedRef *ResolvedProjectReference) *T {
			if resolvedRef && !skipChildren. /* ? */ has(resolvedRef) {
				return worker(resolvedRef.commandLine.projectReferences, resolvedRef.references, resolvedRef)
			} else {
				return nil
			}
		})
	}

}

/** @internal */

var inferredTypesContainingFile = "__inferred type names__.ts"

/** @internal */

func getInferredLibraryNameResolveFrom(options CompilerOptions, currentDirectory string, libFileName string) string {
	var containingDirectory string
	if options.configFilePath {
		containingDirectory = getDirectoryPath(options.configFilePath)
	} else {
		containingDirectory = currentDirectory
	}
	return combinePaths(containingDirectory, __TEMPLATE__("__lib_node_modules_lookup_", libFileName, "__.ts"))
}

/** @internal */

func getLibraryNameFromLibFileName(libFileName string) string {
	// Support resolving to lib.dom.d.ts -> @typescript/lib-dom, and
	//                      lib.dom.iterable.d.ts -> @typescript/lib-dom/iterable
	//                      lib.es2015.symbol.wellknown.d.ts -> @typescript/lib-es2015/symbol-wellknown
	components := libFileName.split(".")
	path := components[1]
	i := 2
	for components[i] && components[i] != "d" {
		path += (ifElse(i == 2, "/", "-")) + components[i]
		i++
	}
	return "@typescript/lib-" + path
}

func getLibNameFromLibReference(libReference FileReference) string {
	return toFileNameLowerCase(libReference.fileName)
}

func getLibFileNameFromLibReference(libReference FileReference) *string {
	libName := getLibNameFromLibReference(libReference)
	return libMap.get(libName)
}

/** @internal */

func isReferencedFile(reason *FileIncludeReason) bool {
	switch reason. /* ? */ kind {
	case FileIncludeKindImport,
		FileIncludeKindReferenceFile,
		FileIncludeKindTypeReferenceDirective,
		FileIncludeKindLibReferenceDirective:
		return true
	default:
		return false
	}
}

/** @internal */

type ReferenceFileLocation struct {
	file      SourceFile
	pos       number
	end       number
	packageId *PackageId
}

/** @internal */

type SyntheticReferenceFileLocation struct {
	file      SourceFile
	packageId *PackageId
	text      string
}

/** @internal */

func isReferenceFileLocation(location /* TODO(TS-TO-GO) TypeNode UnionType: ReferenceFileLocation | SyntheticReferenceFileLocation */ any) bool {
	return (location.(ReferenceFileLocation)).pos != nil
}

/** @internal */

func getReferencedFileLocation(program Program, ref ReferencedFile) /* TODO(TS-TO-GO) TypeNode UnionType: ReferenceFileLocation | SyntheticReferenceFileLocation */ any {
	file := Debug.checkDefined(program.getSourceFileByPath(ref.file))
	TODO_IDENTIFIER := ref
	var pos *number
	var end *number
	var packageId *PackageId
	switch kind {
	case FileIncludeKindImport:
		importLiteral := getModuleNameStringLiteralAt(file, index)
		packageId = program.getResolvedModuleFromModuleSpecifier(importLiteral, file). /* ? */ resolvedModule. /* ? */ packageId
		if importLiteral.pos == -1 {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"file":      file,
				"packageId": packageId,
				"text":      importLiteral.text,
			}
		}
		pos = skipTrivia(file.text, importLiteral.pos)
		end = importLiteral.end
	case FileIncludeKindReferenceFile:
		( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: { pos, end } = file.referencedFiles[index] */ TODO)
	case FileIncludeKindTypeReferenceDirective:
		( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: { pos, end } = file.typeReferenceDirectives[index] */ TODO)
		packageId = program.getResolvedTypeReferenceDirectiveFromTypeReferenceDirective(file.typeReferenceDirectives[index], file). /* ? */ resolvedTypeReferenceDirective. /* ? */ packageId
	case FileIncludeKindLibReferenceDirective:
		( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: { pos, end } = file.libReferenceDirectives[index] */ TODO)
	default:
		return Debug.assertNever(kind)
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":      file,
		"pos":       pos,
		"end":       end,
		"packageId": packageId,
	}
}

/**
 * Determines if program structure is upto date or needs to be recreated
 *
 * @internal
 */

func isProgramUptoDate(program *Program, rootFileNames []string, newOptions CompilerOptions, getSourceVersion func(path Path, fileName string) *string, fileExists func(fileName string) bool, hasInvalidatedResolutions HasInvalidatedResolutions, hasInvalidatedLibResolutions HasInvalidatedLibResolutions, hasChangedAutomaticTypeDirectiveNames *HasChangedAutomaticTypeDirectiveNames, getParsedCommandLine func(fileName string) *ParsedCommandLine, projectReferences *[]ProjectReference) bool {
	// If we haven't created a program yet or have changed automatic type directives, then it is not up-to-date
	if !program || hasChangedAutomaticTypeDirectiveNames() {
		return false
	}

	// If root file names don't match
	if !arrayIsEqualTo(program.getRootFileNames(), rootFileNames) {
		return false
	}

	var seenResolvedRefs *[]ResolvedProjectReference

	// If project references don't match
	if !arrayIsEqualTo(program.getProjectReferences(), projectReferences, projectReferenceUptoDate) {
		return false
	}

	// If any file is not up-to-date, then the whole program is not up-to-date
	if program.getSourceFiles().some(sourceFileNotUptoDate) {
		return false
	}

	// If any of the missing file paths are now created
	missingPaths := program.getMissingFilePaths()
	if missingPaths && forEachEntry(missingPaths, fileExists) {
		return false
	}

	currentOptions := program.getCompilerOptions()
	// If the compilation settings do no match, then the program is not up-to-date
	if !compareDataObjects(currentOptions, newOptions) {
		return false
	}

	// If library resolution is invalidated, then the program is not up-to-date
	if program.resolvedLibReferences && forEachEntry(program.resolvedLibReferences, func(_value /* TODO(TS-TO-GO) inferred type LibResolution<ResolvedModuleWithFailedLookupLocations> */ any, libFileName string) bool {
		return hasInvalidatedLibResolutions(libFileName)
	}) {
		return false
	}

	// If everything matches but the text of config file is changed,
	// error locations can change for program options, so update the program
	if currentOptions.configFile && newOptions.configFile {
		return currentOptions.configFile.text == newOptions.configFile.text
	}

	return true

	sourceFileNotUptoDate := func(sourceFile SourceFile) bool {
		return !sourceFileVersionUptoDate(sourceFile) || hasInvalidatedResolutions(sourceFile.path)
	}

	sourceFileVersionUptoDate := func(sourceFile SourceFile) bool {
		return sourceFile.version == getSourceVersion(sourceFile.resolvedPath, sourceFile.fileName)
	}

	projectReferenceUptoDate := func(oldRef ProjectReference, newRef ProjectReference, index number) bool {
		return projectReferenceIsEqualTo(oldRef, newRef) && resolvedProjectReferenceUptoDate(program.getResolvedProjectReferences()[index], oldRef)
	}

	resolvedProjectReferenceUptoDate := func(oldResolvedRef *ResolvedProjectReference, oldRef ProjectReference) bool {
		if oldResolvedRef {
			// Assume true
			if contains(seenResolvedRefs, oldResolvedRef) {
				return true
			}

			refPath := resolveProjectReferencePath(oldRef)
			newParsedCommandLine := getParsedCommandLine(refPath)

			// Check if config file exists
			if !newParsedCommandLine {
				return false
			}

			// If change in source file
			if oldResolvedRef.commandLine.options.configFile != newParsedCommandLine.options.configFile {
				return false
			}

			// check file names
			if !arrayIsEqualTo(oldResolvedRef.commandLine.fileNames, newParsedCommandLine.fileNames) {
				return false
			}

			// Add to seen before checking the referenced paths of this config file
			(seenResolvedRefs || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: seenResolvedRefs = [] */ TODO)).push(oldResolvedRef)

			// If child project references are upto date, this project reference is uptodate
			return !forEach(oldResolvedRef.references, func(childResolvedRef *ResolvedProjectReference, index number) bool {
				return !resolvedProjectReferenceUptoDate(childResolvedRef, oldResolvedRef.commandLine.projectReferences[index])
			})
		}

		// In old program, not able to resolve project reference path,
		// so if config file doesnt exist, it is uptodate.
		refPath := resolveProjectReferencePath(oldRef)
		return !getParsedCommandLine(refPath)
	}

}

func getConfigFileParsingDiagnostics(configFileParseResult ParsedCommandLine) []Diagnostic {
	if configFileParseResult.options.configFile {
		return []Diagnostic{ /* TODO(TS-TO-GO) Node SpreadElement: ...configFileParseResult.options.configFile.parseDiagnostics */ /* TODO(TS-TO-GO) Node SpreadElement: ...configFileParseResult.errors */ }
	} else {
		return configFileParseResult.errors
	}
}

/**
 * A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the
 * `options` parameter.
 *
 * @param fileName The file name to check the format of (it need not exist on disk)
 * @param [packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often
 * @param host The ModuleResolutionHost which can perform the filesystem lookups for package json data
 * @param options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`
 * @returns `undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format
 */

func getImpliedNodeFormatForFile(fileName string, packageJsonInfoCache *PackageJsonInfoCache, host ModuleResolutionHost, options CompilerOptions) ResolutionMode {
	result := getImpliedNodeFormatForFileWorker(fileName, packageJsonInfoCache, host, options)
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result */ TODO == "object" {
		return result.impliedNodeFormat
	} else {
		return result
	}
}

/** @internal */

func getImpliedNodeFormatForFileWorker(fileName string, packageJsonInfoCache *PackageJsonInfoCache, host ModuleResolutionHost, options CompilerOptions) /* TODO(TS-TO-GO) TypeNode UnionType: ResolutionMode | Partial<CreateSourceFileOptions> | undefined */ any {
	moduleResolution := getEmitModuleResolutionKind(options)
	shouldLookupFromPackageJson := ModuleResolutionKindNode16 <= moduleResolution && moduleResolution <= ModuleResolutionKindNodeNext || pathContainsNodeModules(fileName)
	switch {
	case fileExtensionIsOneOf(fileName, []Extension{ExtensionDmts, ExtensionMts, ExtensionMjs}):
		return ModuleKindESNext
	case fileExtensionIsOneOf(fileName, []Extension{ExtensionDcts, ExtensionCts, ExtensionCjs}):
		return ModuleKindCommonJS
	case shouldLookupFromPackageJson && fileExtensionIsOneOf(fileName, []Extension{ExtensionDts, ExtensionTs, ExtensionTsx, ExtensionJs, ExtensionJsx}):
		return lookupFromPackageJson()
	default:
		return nil
	}
	// other extensions, like `json` or `tsbuildinfo`, are set as `undefined` here but they should never be fed through the transformer pipeline

	lookupFromPackageJson := func() Partial[CreateSourceFileOptions] {
		state := getTemporaryModuleResolutionState(packageJsonInfoCache, host, options)
		var packageJsonLocations []string = []never{}
		state.failedLookupLocations = packageJsonLocations
		state.affectingLocations = packageJsonLocations
		packageJsonScope := getPackageScopeForPath(getDirectoryPath(fileName), state)
		var impliedNodeFormat /* TODO(TS-TO-GO) inferred type ModuleKind.CommonJS | ModuleKind.ESNext */ any
		if packageJsonScope. /* ? */ contents.packageJsonContent.type_ == "module" {
			impliedNodeFormat = ModuleKindESNext
		} else {
			impliedNodeFormat = ModuleKindCommonJS
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"impliedNodeFormat":    impliedNodeFormat,
			"packageJsonLocations": packageJsonLocations,
			"packageJsonScope":     packageJsonScope,
		}
	}

}

var plainJSErrors = NewSet[number]([]any{Diagnostics.Cannot_redeclare_block_scoped_variable_0.code, Diagnostics.A_module_cannot_have_multiple_default_exports.code, Diagnostics.Another_export_default_is_here.code, Diagnostics.The_first_export_default_is_here.code, Diagnostics.Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module.code, Diagnostics.Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode.code, Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here.code, Diagnostics.constructor_is_a_reserved_word.code, Diagnostics.delete_cannot_be_called_on_an_identifier_in_strict_mode.code, Diagnostics.Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode.code, Diagnostics.Invalid_use_of_0_Modules_are_automatically_in_strict_mode.code, Diagnostics.Invalid_use_of_0_in_strict_mode.code, Diagnostics.A_label_is_not_allowed_here.code, Diagnostics.with_statements_are_not_allowed_in_strict_mode.code, Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement.code, Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement.code, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name.code, Diagnostics.A_class_member_cannot_have_the_0_keyword.code, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name.code, Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement.code, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement.code, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement.code, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement.code, Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration.code, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context.code, Diagnostics.A_destructuring_declaration_must_have_an_initializer.code, Diagnostics.A_get_accessor_cannot_have_parameters.code, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern.code, Diagnostics.A_rest_element_cannot_have_a_property_name.code, Diagnostics.A_rest_element_cannot_have_an_initializer.code, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern.code, Diagnostics.A_rest_parameter_cannot_have_an_initializer.code, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list.code, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma.code, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block.code, Diagnostics.A_set_accessor_cannot_have_rest_parameter.code, Diagnostics.A_set_accessor_must_have_exactly_one_parameter.code, Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module.code, Diagnostics.An_export_declaration_cannot_have_modifiers.code, Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module.code, Diagnostics.An_import_declaration_cannot_have_modifiers.code, Diagnostics.An_object_member_cannot_be_declared_optional.code, Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element.code, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable.code, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause.code, Diagnostics.Catch_clause_variable_cannot_have_an_initializer.code, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator.code, Diagnostics.Classes_can_only_extend_a_single_class.code, Diagnostics.Classes_may_not_have_a_field_named_constructor.code, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern.code, Diagnostics.Duplicate_label_0.code, Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments.code, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block.code, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression.code, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name.code, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array.code, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names.code, Diagnostics.Jump_target_cannot_cross_function_boundary.code, Diagnostics.Line_terminator_not_permitted_before_arrow.code, Diagnostics.Modifiers_cannot_appear_here.code, Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement.code, Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement.code, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies.code, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression.code, Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier.code, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain.code, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async.code, Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer.code, Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer.code, Diagnostics.Trailing_comma_not_allowed.code, Diagnostics.Variable_declaration_list_cannot_be_empty.code, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses.code, Diagnostics._0_expected.code, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2.code, Diagnostics._0_list_cannot_be_empty.code, Diagnostics._0_modifier_already_seen.code, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration.code, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element.code, Diagnostics._0_modifier_cannot_appear_on_a_parameter.code, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind.code, Diagnostics._0_modifier_cannot_be_used_here.code, Diagnostics._0_modifier_must_precede_1_modifier.code, Diagnostics._0_declarations_can_only_be_declared_inside_a_block.code, Diagnostics._0_declarations_must_be_initialized.code, Diagnostics.extends_clause_already_seen.code, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations.code, Diagnostics.Class_constructor_may_not_be_a_generator.code, Diagnostics.Class_constructor_may_not_be_an_accessor.code, Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules.code, Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules.code, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class.code, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value.code})

type LazyProgramDiagnosticExplainingFile struct {
	file       SourceFile
	diagnostic DiagnosticMessage
	args       DiagnosticArguments
}
type FileReasonToChainCache struct {
	fileIncludeReasonDetails *DiagnosticMessageChain
	redirectInfo             *[]DiagnosticMessageChain
	details                  []DiagnosticMessageChain
}

/**
 * Determine if source file needs to be re-created even if its text hasn't changed
 */

func shouldProgramCreateNewSourceFiles(program *Program, newOptions CompilerOptions) bool {
	if !program {
		return false
	}
	// If any compiler options change, we can't reuse old source file even if version match
	// The change in options like these could result in change in syntax tree or `sourceFile.bindDiagnostics`.
	return optionsHaveChanges(program.getCompilerOptions(), newOptions, sourceFileAffectingCompilerOptions)
}

func createCreateProgramOptions(rootNames []string, options CompilerOptions, host CompilerHost, oldProgram Program, configFileParsingDiagnostics []Diagnostic, typeScriptVersion string) CreateProgramOptions {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"rootNames":                    rootNames,
		"options":                      options,
		"host":                         host,
		"oldProgram":                   oldProgram,
		"configFileParsingDiagnostics": configFileParsingDiagnostics,
		"typeScriptVersion":            typeScriptVersion,
	}
}

/**
 * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
 * that represent a compilation unit.
 *
 * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
 * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
 *
 * @param createProgramOptions - The options for creating a program.
 * @returns A 'Program' object.
 */

/* OVERLOAD: export function createProgram(createProgramOptions: CreateProgramOptions): Program; */
/**
 * Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'
 * that represent a compilation unit.
 *
 * Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and
 * triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.
 *
 * @param rootNames - A set of root files.
 * @param options - The compiler options which should be used.
 * @param host - The host interacts with the underlying file system.
 * @param oldProgram - Reuses an old program structure.
 * @param configFileParsingDiagnostics - error during config file parsing
 * @returns A 'Program' object.
 */

/* OVERLOAD: export function createProgram(rootNames: readonly string[], options: CompilerOptions, host?: CompilerHost, oldProgram?: Program, configFileParsingDiagnostics?: readonly Diagnostic[]): Program; */
func createProgram(rootNamesOrOptions /* TODO(TS-TO-GO) TypeNode UnionType: readonly string[] | CreateProgramOptions */ any, _options CompilerOptions, _host CompilerHost, _oldProgram Program, _configFileParsingDiagnostics []Diagnostic) Program {
	var createProgramOptions CreateProgramOptions
	if isArray(rootNamesOrOptions) {
		createProgramOptions = createCreateProgramOptions(rootNamesOrOptions, _options, _host, _oldProgram, _configFileParsingDiagnostics)
	} else {
		createProgramOptions = rootNamesOrOptions
	}
	// TODO: GH#18217
	TODO_IDENTIFIER := createProgramOptions
	TODO_IDENTIFIER := createProgramOptions
	for _, option := range commandLineOptionOfCustomType {
		if hasProperty(options, option.name) {
			if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof options[option.name] */ TODO == "string" {
				/* TODO(TS-TO-GO) Node ThrowStatement: throw new Error(`${option.name} is a string value; tsconfig JSON must be parsed with parseJsonSourceFileConfigFileContent or getParsedCommandLineOfConfigFile before passing to createProgram`); */
			}
		}
	}

	reportInvalidIgnoreDeprecations := memoize(func() {
		return createOptionValueDiagnostic("ignoreDeprecations", Diagnostics.Invalid_value_for_ignoreDeprecations)
	})

	var processingDefaultLibFiles *[]SourceFile
	var processingOtherFiles *[]SourceFile
	var files []SourceFile
	var symlinks *SymlinkCache
	var commonSourceDirectory string
	var typeChecker TypeChecker
	var classifiableNames Set[string]
	fileReasons := createMultiMap()
	var filesWithReferencesProcessed *Set[Path]
	var fileReasonsToChain *Map[Path, FileReasonToChainCache]
	var reasonToRelatedInfo *Map[FileIncludeReason /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticWithLocation | false */, any]
	var cachedBindAndCheckDiagnosticsForFile *Map[Path, []Diagnostic]
	var cachedDeclarationDiagnosticsForFile *Map[Path, []DiagnosticWithLocation]

	var fileProcessingDiagnostics *[]FilePreprocessingDiagnostics
	var automaticTypeDirectiveNames *[]string
	var automaticTypeDirectiveResolutions ModeAwareCache[ResolvedTypeReferenceDirectiveWithFailedLookupLocations]

	var resolvedLibReferences *Map[string, LibResolution]
	var resolvedLibProcessing *Map[string, LibResolution]

	var resolvedModules *Map[Path, ModeAwareCache[ResolvedModuleWithFailedLookupLocations]]
	var resolvedModulesProcessing *Map[Path, []ResolvedModuleWithFailedLookupLocations]
	var resolvedTypeReferenceDirectiveNames *Map[Path, ModeAwareCache[ResolvedTypeReferenceDirectiveWithFailedLookupLocations]]
	var resolvedTypeReferenceDirectiveNamesProcessing *Map[Path, []ResolvedTypeReferenceDirectiveWithFailedLookupLocations]

	var packageMap *Map[string, bool]

	// The below settings are to track if a .js file should be add to the program if loaded via searching under node_modules.
	// This works as imported modules are discovered recursively in a depth first manner, specifically:
	// - For each root file, findSourceFile is called.
	// - This calls processImportedModules for each module imported in the source file.
	// - This calls resolveModuleNames, and then calls findSourceFile for each resolved module.
	// As all these operations happen - and are nested - within the createProgram call, they close over the below variables.
	// The current resolution depth is tracked by incrementing/decrementing as the depth first search progresses.
	var maxNodeModuleJsDepth number
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof options.maxNodeModuleJsDepth */ TODO == "number" {
		maxNodeModuleJsDepth = options.maxNodeModuleJsDepth
	} else {
		maxNodeModuleJsDepth = 0
	}
	currentNodeModulesDepth := 0

	// If a module has some of its imports skipped due to being at the depth limit under node_modules, then track
	// this, as it may be imported at a shallower depth later, and then it will need its skipped imports processed.
	modulesWithElidedImports := NewMap[string, bool]()

	// Track source files that are source files found by searching under node_modules, as these shouldn't be compiled.
	sourceFilesFoundSearchingNodeModules := NewMap[string, bool]()

	tracing. /* ? */ push(tracing.Phase.Program, "createProgram", map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"configFilePath": options.configFilePath,
		"rootDir":        options.rootDir,
	}, /*separateBeginAndEnd*/ true)
	performance.mark("beforeProgram")

	host := createProgramOptions.host || createCompilerHost(options)
	configParsingHost := parseConfigHostFromCompilerHostLike(host)

	skipDefaultLib := options.noLib
	getDefaultLibraryFileName := memoize(func() string {
		return host.getDefaultLibFileName(options)
	})
	var defaultLibraryPath string
	if host.getDefaultLibLocation {
		defaultLibraryPath = host.getDefaultLibLocation()
	} else {
		defaultLibraryPath = getDirectoryPath(getDefaultLibraryFileName())
	}
	/**
	 * Diagnostics for the program
	 * Only add diagnostics directly if it always would be done irrespective of program structure reuse.
	 * Otherwise fileProcessingDiagnostics is correct locations so that the diagnostics can be reported in all structure use scenarios
	 */

	programDiagnostics := createDiagnosticCollection()
	var lazyProgramDiagnosticExplainingFile *[]LazyProgramDiagnosticExplainingFile = []never{}
	currentDirectory := host.getCurrentDirectory()
	supportedExtensions := getSupportedExtensions(options)
	supportedExtensionsWithJsonIfResolveJsonModule := getSupportedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions)

	// Map storing if there is emit blocking diagnostics for given input
	hasEmitBlockingDiagnostics := NewMap[string, bool]()
	var _compilerOptionsObjectLiteralSyntax /* TODO(TS-TO-GO) TypeNode UnionType: ObjectLiteralExpression | false | undefined */ any
	var _compilerOptionsPropertySyntax /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAssignment | false | undefined */ any

	var moduleResolutionCache *ModuleResolutionCache
	var actualResolveModuleNamesWorker func(moduleNames []StringLiteralLike, containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, containingSourceFile SourceFile, reusedNames *[]StringLiteralLike) []ResolvedModuleWithFailedLookupLocations
	hasInvalidatedResolutions := host.hasInvalidatedResolutions || returnFalse
	if host.resolveModuleNameLiterals {
		actualResolveModuleNamesWorker = host.resolveModuleNameLiterals.bind(host)
		moduleResolutionCache = host.getModuleResolutionCache()
	} else if host.resolveModuleNames {
		actualResolveModuleNamesWorker = func(moduleNames []StringLiteralLike, containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, containingSourceFile SourceFile, reusedNames *[]StringLiteralLike) [] /* TODO(TS-TO-GO) inferred type ((ResolvedModuleWithFailedLookupLocations & ResolvedTypeReferenceDirectiveWithFailedLookupLocations) | { resolvedModule: ResolvedModuleFull; }) */ any {
			return host.resolveModuleNames(moduleNames.map_(getModuleResolutionName), containingFile, reusedNames. /* ? */ map_(getModuleResolutionName), redirectedReference, options, containingSourceFile).map_(func(resolved *ResolvedModule) /* TODO(TS-TO-GO) inferred type (ResolvedModuleWithFailedLookupLocations & ResolvedTypeReferenceDirectiveWithFailedLookupLocations) | { resolvedModule: ResolvedModuleFull; } */ any {
				switch {
				case resolved:
					if (resolved.(ResolvedModuleFull)).extension != nil {
						return map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"resolvedModule": resolved.(ResolvedModuleFull),
						}
					} else {
						return map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"resolvedModule": map[any]any{ /* TODO(TS-TO-GO): was object literal */
								/* TODO(TS-TO-GO) Node SpreadAssignment: ...resolved */
								"extension": extensionFromPath(resolved.resolvedFileName),
							},
						}
					}
				default:
					return emptyResolution
				}
			})
		}
		moduleResolutionCache = host.getModuleResolutionCache()
	} else {
		moduleResolutionCache = createModuleResolutionCache(currentDirectory, getCanonicalFileName, options)
		actualResolveModuleNamesWorker = func(moduleNames []StringLiteralLike, containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, containingSourceFile SourceFile) []ResolvedModuleWithFailedLookupLocations {
			return loadWithModeAwareCache(moduleNames, containingFile, redirectedReference, options, containingSourceFile, host, moduleResolutionCache, createModuleResolutionLoader)
		}
	}

	var actualResolveTypeReferenceDirectiveNamesWorker func(typeDirectiveNames []T, containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, containingSourceFile *SourceFile, reusedNames *[]T) []ResolvedTypeReferenceDirectiveWithFailedLookupLocations
	if host.resolveTypeReferenceDirectiveReferences {
		actualResolveTypeReferenceDirectiveNamesWorker = host.resolveTypeReferenceDirectiveReferences.bind(host)
	} else if host.resolveTypeReferenceDirectives {
		actualResolveTypeReferenceDirectiveNamesWorker = func(typeDirectiveNames []T, containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, containingSourceFile *SourceFile) [] /* TODO(TS-TO-GO) inferred type { resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined; } */ any {
			return host.resolveTypeReferenceDirectives(typeDirectiveNames.map_(getTypeReferenceResolutionName), containingFile, redirectedReference, options, containingSourceFile. /* ? */ impliedNodeFormat).map_(func(resolvedTypeReferenceDirective *ResolvedTypeReferenceDirective) /* TODO(TS-TO-GO) inferred type { resolvedTypeReferenceDirective: ResolvedTypeReferenceDirective | undefined; } */ any {
				return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"resolvedTypeReferenceDirective": resolvedTypeReferenceDirective,
				})
			})
		}
	} else {
		typeReferenceDirectiveResolutionCache := createTypeReferenceDirectiveResolutionCache(currentDirectory, getCanonicalFileName, nil, moduleResolutionCache. /* ? */ getPackageJsonInfoCache(), moduleResolutionCache. /* ? */ optionsToRedirectsKey)
		actualResolveTypeReferenceDirectiveNamesWorker = func(typeDirectiveNames []T, containingFile string, redirectedReference *ResolvedProjectReference, options CompilerOptions, containingSourceFile *SourceFile) []ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
			return loadWithModeAwareCache(typeDirectiveNames, containingFile, redirectedReference, options, containingSourceFile, host, typeReferenceDirectiveResolutionCache, createTypeReferenceResolutionLoader)
		}
	}

	hasInvalidatedLibResolutions := host.hasInvalidatedLibResolutions || returnFalse
	var actualResolveLibrary func(libraryName string, resolveFrom string, options CompilerOptions, libFileName string) ResolvedModuleWithFailedLookupLocations
	if host.resolveLibrary {
		actualResolveLibrary = host.resolveLibrary.bind(host)
	} else {
		libraryResolutionCache := createModuleResolutionCache(currentDirectory, getCanonicalFileName, options, moduleResolutionCache. /* ? */ getPackageJsonInfoCache())
		actualResolveLibrary = func(libraryName string, resolveFrom string, options CompilerOptions) ResolvedModuleWithFailedLookupLocations {
			return resolveLibrary(libraryName, resolveFrom, options, host, libraryResolutionCache)
		}
	}

	// Map from a stringified PackageId to the source file with that id.
	// Only one source file may have a given packageId. Others become redirects (see createRedirectSourceFile).
	// `packageIdToSourceFile` is only used while building the program, while `sourceFileToPackageName` and `isSourceFileTargetOfRedirect` are kept around.
	packageIdToSourceFile := NewMap[string, SourceFile]()
	// Maps from a SourceFile's `.path` to the name of the package it was imported with.
	sourceFileToPackageName := NewMap[Path, string]()
	// Key is a file name. Value is the (non-empty, or undefined) list of files that redirect to it.
	redirectTargetsMap := createMultiMap()
	var usesUriStyleNodeCoreModules *bool
	/**
	 * map with
	 * - SourceFile if present
	 * - false if sourceFile missing for source of project reference redirect
	 * - undefined otherwise
	 */

	filesByName := NewMap[Path /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | false | undefined */, any]()
	missingFileNames := NewMap[Path, string]()
	// stores 'filename -> file association' ignoring case
	// used to track cases when two file names differ only in casing
	var filesByNameIgnoreCase *Map[string, SourceFile]
	if host.useCaseSensitiveFileNames() {
		filesByNameIgnoreCase = NewMap[string, SourceFile]()
	} else {
		filesByNameIgnoreCase = nil
	}

	// A parallel array to projectReferences storing the results of reading in the referenced tsconfig files
	var resolvedProjectReferences *[]*ResolvedProjectReference
	var projectReferenceRedirects *Map[Path /* TODO(TS-TO-GO) TypeNode UnionType: ResolvedProjectReference | false */, any]
	var mapFromFileToProjectReferenceRedirects *Map[Path, Path]
	var mapFromToProjectReferenceRedirectSource *Map[Path, SourceOfProjectReferenceRedirect]

	useSourceOfProjectReferenceRedirect := !!host.useSourceOfProjectReferenceRedirect() && !options.disableSourceOfProjectReferenceRedirect
	TODO_IDENTIFIER := updateHostForUseSourceOfProjectReferenceRedirect(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"compilerHost":                        host,
		"getSymlinkCache":                     getSymlinkCache,
		"useSourceOfProjectReferenceRedirect": useSourceOfProjectReferenceRedirect,
		"toPath":                              toPath,
		"getResolvedProjectReferences":        getResolvedProjectReferences,
		"getSourceOfProjectReferenceRedirect": getSourceOfProjectReferenceRedirect,
		"forEachResolvedProjectReference":     forEachResolvedProjectReference,
	})
	readFile := host.readFile.bind(host) /* as typeof host.readFile */

	tracing. /* ? */ push(tracing.Phase.Program, "shouldProgramCreateNewSourceFiles", map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"hasOldProgram": !!oldProgram,
	})
	shouldCreateNewSourceFile := shouldProgramCreateNewSourceFiles(oldProgram, options)
	tracing. /* ? */ pop()
	// We set `structuralIsReused` to `undefined` because `tryReuseStructureFromOldProgram` calls `tryReuseStructureFromOldProgram` which checks
	// `structuralIsReused`, which would be a TDZ violation if it was not set in advance to `undefined`.
	var structureIsReused StructureIsReused
	tracing. /* ? */ push(tracing.Phase.Program, "tryReuseStructureFromOldProgram", map[any]any{ /* TODO(TS-TO-GO): was object literal */
	})
	structureIsReused = tryReuseStructureFromOldProgram()
	tracing. /* ? */ pop()
	if structureIsReused != StructureIsReusedCompletely {
		processingDefaultLibFiles = []never{}
		processingOtherFiles = []never{}

		if projectReferences {
			if !resolvedProjectReferences {
				resolvedProjectReferences = projectReferences.map_(parseProjectReferenceConfigFile)
			}
			if rootNames.length {
				resolvedProjectReferences. /* ? */ forEach(func(parsedRef *ResolvedProjectReference, index number) {
					if !parsedRef {
						return
					}
					out := parsedRef.commandLine.options.outFile
					if useSourceOfProjectReferenceRedirect {
						if out || getEmitModuleKind(parsedRef.commandLine.options) == ModuleKindNone {
							for _, fileName := range parsedRef.commandLine.fileNames {
								processProjectReferenceFile(fileName, map[any]any{ /* TODO(TS-TO-GO): was object literal */
									"kind":  FileIncludeKindSourceFromProjectReference,
									"index": index,
								})
							}
						}
					} else {
						if out {
							processProjectReferenceFile(changeExtension(out, ".d.ts"), map[any]any{ /* TODO(TS-TO-GO): was object literal */
								"kind":  FileIncludeKindOutputFromProjectReference,
								"index": index,
							})
						} else if getEmitModuleKind(parsedRef.commandLine.options) == ModuleKindNone {
							getCommonSourceDirectory := memoize(func() string {
								return getCommonSourceDirectoryOfConfig(parsedRef.commandLine, !host.useCaseSensitiveFileNames())
							})
							for _, fileName := range parsedRef.commandLine.fileNames {
								if !isDeclarationFileName(fileName) && !fileExtensionIs(fileName, ExtensionJson) {
									processProjectReferenceFile(getOutputDeclarationFileName(fileName, parsedRef.commandLine, !host.useCaseSensitiveFileNames(), getCommonSourceDirectory), map[any]any{ /* TODO(TS-TO-GO): was object literal */
										"kind":  FileIncludeKindOutputFromProjectReference,
										"index": index,
									})
								}
							}
						}
					}
				})
			}
		}

		tracing. /* ? */ push(tracing.Phase.Program, "processRootFiles", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"count": rootNames.length,
		})
		forEach(rootNames, func(name string, index number) {
			return processRootFile(name /*isDefaultLib*/, false /*ignoreNoDefaultLib*/, false, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"kind":  FileIncludeKindRootFile,
				"index": index,
			})
		})
		tracing. /* ? */ pop()

		// load type declarations specified via 'types' argument or implicitly from types/ and node_modules/@types folders
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: automaticTypeDirectiveNames ??= rootNames.length ? getAutomaticTypeDirectiveNames(options, host) : emptyArray */
		TODO
		automaticTypeDirectiveResolutions = createModeAwareCache()
		if automaticTypeDirectiveNames.length {
			tracing. /* ? */ push(tracing.Phase.Program, "processTypeReferences", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"count": automaticTypeDirectiveNames.length,
			})
			// This containingFilename needs to match with the one used in managed-side
			var containingDirectory string
			if options.configFilePath {
				containingDirectory = getDirectoryPath(options.configFilePath)
			} else {
				containingDirectory = currentDirectory
			}
			containingFilename := combinePaths(containingDirectory, inferredTypesContainingFile)
			resolutions := resolveTypeReferenceDirectiveNamesReusingOldState(automaticTypeDirectiveNames, containingFilename)
			for i := 0; i < automaticTypeDirectiveNames.length; i++ {
				// under node16/nodenext module resolution, load `types`/ata include names as cjs resolution results by passing an `undefined` mode
				automaticTypeDirectiveResolutions.set(automaticTypeDirectiveNames[i] /*mode*/, nil, resolutions[i])
				processTypeReferenceDirective(automaticTypeDirectiveNames[i], nil, resolutions[i], map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"kind":          FileIncludeKindAutomaticTypeDirectiveFile,
					"typeReference": automaticTypeDirectiveNames[i],
					"packageId":     resolutions[i]. /* ? */ resolvedTypeReferenceDirective. /* ? */ packageId,
				})
			}
			tracing. /* ? */ pop()
		}

		// Do not process the default library if:
		//  - The '--noLib' flag is used.
		//  - A 'no-default-lib' reference comment is encountered in
		//      processing the root files.
		if rootNames.length && !skipDefaultLib {
			// If '--lib' is not specified, include default library file according to '--target'
			// otherwise, using options specified in '--lib' instead of '--target' default library file
			defaultLibraryFileName := getDefaultLibraryFileName()
			if !options.lib && defaultLibraryFileName {
				processRootFile(defaultLibraryFileName /*isDefaultLib*/, true /*ignoreNoDefaultLib*/, false, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"kind": FileIncludeKindLibFile,
				})
			} else {
				forEach(options.lib, func(libFileName string, index number) {
					processRootFile(pathForLibFile(libFileName) /*isDefaultLib*/, true /*ignoreNoDefaultLib*/, false, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"kind":  FileIncludeKindLibFile,
						"index": index,
					})
				})
			}
		}

		files = toSorted(processingDefaultLibFiles, compareDefaultLibFiles).concat(processingOtherFiles)
		processingDefaultLibFiles = nil
		processingOtherFiles = nil
		filesWithReferencesProcessed = nil
	}

	// Release any files we have acquired in the old program but are
	// not part of the new program.
	if oldProgram && host.onReleaseOldSourceFile {
		oldSourceFiles := oldProgram.getSourceFiles()
		for _, oldSourceFile := range oldSourceFiles {
			newFile := getSourceFileByPath(oldSourceFile.resolvedPath)
			if shouldCreateNewSourceFile || !newFile || newFile.impliedNodeFormat != oldSourceFile.impliedNodeFormat || (oldSourceFile.resolvedPath == oldSourceFile.path && newFile.resolvedPath != oldSourceFile.path) {
				host.onReleaseOldSourceFile(oldSourceFile, oldProgram.getCompilerOptions(), !!getSourceFileByPath(oldSourceFile.path), newFile)
			}
		}
		if !host.getParsedCommandLine {
			oldProgram.forEachResolvedProjectReference(func(resolvedProjectReference ResolvedProjectReference) {
				if !getResolvedProjectReferenceByPath(resolvedProjectReference.sourceFile.path) {
					host.onReleaseOldSourceFile(resolvedProjectReference.sourceFile, oldProgram.getCompilerOptions() /*hasSourceFileByPath*/, false /*newSourceFileByResolvedPath*/, nil)
				}
			})
		}
	}

	// Release commandlines that new program does not use
	if oldProgram && host.onReleaseParsedCommandLine {
		forEachProjectReference(oldProgram.getProjectReferences(), oldProgram.getResolvedProjectReferences(), func(oldResolvedRef *ResolvedProjectReference, parent *ResolvedProjectReference, index number) {
			oldReference := parent. /* ? */ commandLine.projectReferences[index] || oldProgram.getProjectReferences()[index]
			oldRefPath := resolveProjectReferencePath(oldReference)
			if !projectReferenceRedirects. /* ? */ has(toPath(oldRefPath)) {
				host.onReleaseParsedCommandLine(oldRefPath, oldResolvedRef, oldProgram.getCompilerOptions())
			}
		})
	}

	// unconditionally set oldProgram to undefined to prevent it from being captured in closure
	oldProgram = nil
	resolvedLibProcessing = nil
	resolvedModulesProcessing = nil
	resolvedTypeReferenceDirectiveNamesProcessing = nil

	var program Program = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getRootFileNames": func() []string {
			return rootNames
		},
		"getSourceFile":       getSourceFile,
		"getSourceFileByPath": getSourceFileByPath,
		"getSourceFiles": func() []SourceFile {
			return files
		},
		"getMissingFilePaths": func() Map[Path, string] {
			return missingFileNames
		},
		"getModuleResolutionCache": func() *ModuleResolutionCache {
			return moduleResolutionCache
		},
		"getFilesByNameMap": func() Map[Path, * /* TODO(TS-TO-GO) inferred type false | SourceFile */ any] {
			return filesByName
		},
		"getCompilerOptions": func() CompilerOptions {
			return options
		},
		"getSyntacticDiagnostics":      getSyntacticDiagnostics,
		"getOptionsDiagnostics":        getOptionsDiagnostics,
		"getGlobalDiagnostics":         getGlobalDiagnostics,
		"getSemanticDiagnostics":       getSemanticDiagnostics,
		"getCachedSemanticDiagnostics": getCachedSemanticDiagnostics,
		"getSuggestionDiagnostics":     getSuggestionDiagnostics,
		"getDeclarationDiagnostics":    getDeclarationDiagnostics,
		"getBindAndCheckDiagnostics":   getBindAndCheckDiagnostics,
		"getProgramDiagnostics":        getProgramDiagnostics,
		"getTypeChecker":               getTypeChecker,
		"getClassifiableNames":         getClassifiableNames,
		"getCommonSourceDirectory":     getCommonSourceDirectory,
		"emit":                         emit,
		"getCurrentDirectory": func() string {
			return currentDirectory
		},
		"getNodeCount": func() number {
			return getTypeChecker().getNodeCount()
		},
		"getIdentifierCount": func() number {
			return getTypeChecker().getIdentifierCount()
		},
		"getSymbolCount": func() number {
			return getTypeChecker().getSymbolCount()
		},
		"getTypeCount": func() number {
			return getTypeChecker().getTypeCount()
		},
		"getInstantiationCount": func() number {
			return getTypeChecker().getInstantiationCount()
		},
		"getRelationCacheSizes": func() /* TODO(TS-TO-GO) inferred type { assignable: number; identity: number; subtype: number; strictSubtype: number; } */ any {
			return getTypeChecker().getRelationCacheSizes()
		},
		"getFileProcessingDiagnostics": func() *[]FilePreprocessingDiagnostics {
			return fileProcessingDiagnostics
		},
		"getAutomaticTypeDirectiveNames": func() []string {
			return automaticTypeDirectiveNames
		},
		"getAutomaticTypeDirectiveResolutions": func() /* TODO(TS-TO-GO) inferred type ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations> */ any {
			return automaticTypeDirectiveResolutions
		},
		"isSourceFileFromExternalLibrary":                             isSourceFileFromExternalLibrary,
		"isSourceFileDefaultLibrary":                                  isSourceFileDefaultLibrary,
		"getModeForUsageLocation":                                     getModeForUsageLocation,
		"getEmitSyntaxForUsageLocation":                               getEmitSyntaxForUsageLocation,
		"getModeForResolutionAtIndex":                                 getModeForResolutionAtIndex,
		"getSourceFileFromReference":                                  getSourceFileFromReference,
		"getLibFileFromReference":                                     getLibFileFromReference,
		"sourceFileToPackageName":                                     sourceFileToPackageName,
		"redirectTargetsMap":                                          redirectTargetsMap,
		"usesUriStyleNodeCoreModules":                                 usesUriStyleNodeCoreModules,
		"resolvedModules":                                             resolvedModules,
		"resolvedTypeReferenceDirectiveNames":                         resolvedTypeReferenceDirectiveNames,
		"resolvedLibReferences":                                       resolvedLibReferences,
		"getResolvedModule":                                           getResolvedModule,
		"getResolvedModuleFromModuleSpecifier":                        getResolvedModuleFromModuleSpecifier,
		"getResolvedTypeReferenceDirective":                           getResolvedTypeReferenceDirective,
		"getResolvedTypeReferenceDirectiveFromTypeReferenceDirective": getResolvedTypeReferenceDirectiveFromTypeReferenceDirective,
		"forEachResolvedModule":                                       forEachResolvedModule,
		"forEachResolvedTypeReferenceDirective":                       forEachResolvedTypeReferenceDirective,
		"getCurrentPackagesMap": func() *Map[string, bool] {
			return packageMap
		},
		"typesPackageExists":                                   typesPackageExists,
		"packageBundlesTypes":                                  packageBundlesTypes,
		"isEmittedFile":                                        isEmittedFile,
		"getConfigFileParsingDiagnostics":                      getConfigFileParsingDiagnostics,
		"getProjectReferences":                                 getProjectReferences,
		"getResolvedProjectReferences":                         getResolvedProjectReferences,
		"getProjectReferenceRedirect":                          getProjectReferenceRedirect,
		"getResolvedProjectReferenceToRedirect":                getResolvedProjectReferenceToRedirect,
		"getResolvedProjectReferenceByPath":                    getResolvedProjectReferenceByPath,
		"forEachResolvedProjectReference":                      forEachResolvedProjectReference,
		"isSourceOfProjectReferenceRedirect":                   isSourceOfProjectReferenceRedirect,
		"getRedirectReferenceForResolutionFromSourceOfProject": getRedirectReferenceForResolutionFromSourceOfProject,
		"getCompilerOptionsForFile":                            getCompilerOptionsForFile,
		"getDefaultResolutionModeForFile":                      getDefaultResolutionModeForFile,
		"getEmitModuleFormatOfFile":                            getEmitModuleFormatOfFile,
		"getImpliedNodeFormatForEmit":                          getImpliedNodeFormatForEmit,
		"shouldTransformImportCall":                            shouldTransformImportCall,
		"emitBuildInfo":                                        emitBuildInfo,
		"fileExists":                                           fileExists,
		"readFile":                                             readFile,
		"directoryExists":                                      directoryExists,
		"getSymlinkCache":                                      getSymlinkCache,
		"realpath":                                             host.realpath. /* ? */ bind(host),
		"useCaseSensitiveFileNames": func() bool {
			return host.useCaseSensitiveFileNames()
		},
		"getCanonicalFileName": getCanonicalFileName,
		"getFileIncludeReasons": func() /* TODO(TS-TO-GO) inferred type MultiMap<Path, FileIncludeReason> */ any {
			return fileReasons
		},
		"structureIsReused":             structureIsReused,
		"writeFile":                     writeFile,
		"getGlobalTypingsCacheLocation": maybeBind(host, host.getGlobalTypingsCacheLocation),
	}

	onProgramCreateComplete()

	verifyCompilerOptions()
	performance.mark("afterProgram")
	performance.measure("Program", "beforeProgram", "afterProgram")
	tracing. /* ? */ pop()

	return program

	updateAndGetProgramDiagnostics := func() DiagnosticCollection {
		if lazyProgramDiagnosticExplainingFile {
			// Add file processingDiagnostics
			fileProcessingDiagnostics. /* ? */ forEach(func(diagnostic FilePreprocessingDiagnostics) {
				switch diagnostic.kind {
				case FilePreprocessingDiagnosticsKindFilePreprocessingFileExplainingDiagnostic:
					return programDiagnostics.add(createDiagnosticExplainingFile(diagnostic.file && getSourceFileByPath(diagnostic.file), diagnostic.fileProcessingReason, diagnostic.diagnostic, diagnostic.args || emptyArray))
				case FilePreprocessingDiagnosticsKindFilePreprocessingLibReferenceDiagnostic:
					return programDiagnostics.add(filePreprocessingLibreferenceDiagnostic(diagnostic))
				case FilePreprocessingDiagnosticsKindResolutionDiagnostics:
					return diagnostic.diagnostics.forEach(func(d Diagnostic) {
						return programDiagnostics.add(d)
					})
				default:
					Debug.assertNever(diagnostic)
				}
			})
			lazyProgramDiagnosticExplainingFile.forEach(func(TODO_IDENTIFIER LazyProgramDiagnosticExplainingFile) {
				return programDiagnostics.add(createDiagnosticExplainingFile(file /*fileProcessingReason*/, nil, diagnostic, args))
			})
			lazyProgramDiagnosticExplainingFile = nil
			fileReasonsToChain = nil
			reasonToRelatedInfo = nil
		}
		return programDiagnostics
	}

	filePreprocessingLibreferenceDiagnostic := func(TODO_IDENTIFIER FilePreprocessingLibReferenceDiagnostic) DiagnosticWithLocation {
		TODO_IDENTIFIER := getReferencedFileLocation(program, reason).(ReferenceFileLocation)
		libReference := file.libReferenceDirectives[reason.index]
		libName := getLibNameFromLibReference(libReference)
		unqualifiedLibName := removeSuffix(removePrefix(libName, "lib."), ".d.ts")
		suggestion := getSpellingSuggestion(unqualifiedLibName, libs, identity)
		return createFileDiagnostic(file, Debug.checkDefined(pos), Debug.checkDefined(end)-pos, ifElse(suggestion, Diagnostics.Cannot_find_lib_definition_for_0_Did_you_mean_1, Diagnostics.Cannot_find_lib_definition_for_0), libName, suggestion)
	}

	getResolvedModule := func(file SourceFile, moduleName string, mode ResolutionMode) *ResolvedModuleWithFailedLookupLocations {
		return resolvedModules. /* ? */ get(file.path). /* ? */ get(moduleName, mode)
	}

	getResolvedModuleFromModuleSpecifier := func(moduleSpecifier StringLiteralLike, sourceFile SourceFile) *ResolvedModuleWithFailedLookupLocations {
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: sourceFile ??= getSourceFileOfNode(moduleSpecifier) */ TODO
		Debug.assertIsDefined(sourceFile, "`moduleSpecifier` must have a `SourceFile` ancestor. Use `program.getResolvedModule` instead to provide the containing file and resolution mode.")
		return getResolvedModule(sourceFile, moduleSpecifier.text, getModeForUsageLocation(sourceFile, moduleSpecifier))
	}

	getResolvedTypeReferenceDirective := func(file SourceFile, typeDirectiveName string, mode ResolutionMode) *ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
		return resolvedTypeReferenceDirectiveNames. /* ? */ get(file.path). /* ? */ get(typeDirectiveName, mode)
	}

	getResolvedTypeReferenceDirectiveFromTypeReferenceDirective := func(typeRef FileReference, sourceFile SourceFile) *ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
		return getResolvedTypeReferenceDirective(sourceFile, typeRef.fileName, getModeForTypeReferenceDirectiveInFile(typeRef, sourceFile))
	}

	forEachResolvedModule := func(callback func(resolution ResolvedModuleWithFailedLookupLocations, moduleName string, mode ResolutionMode, filePath Path), file SourceFile) {
		forEachResolution(resolvedModules, callback, file)
	}

	forEachResolvedTypeReferenceDirective := func(callback func(resolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName string, mode ResolutionMode, filePath Path), file SourceFile) {
		forEachResolution(resolvedTypeReferenceDirectiveNames, callback, file)
	}

	forEachResolution := func(resolutionCache *Map[Path, ModeAwareCache[T]], callback func(resolution T, moduleName string, mode ResolutionMode, filePath Path), file *SourceFile) {
		if file {
			resolutionCache. /* ? */ get(file.path). /* ? */ forEach(func(resolution T, name string, mode ResolutionMode) {
				return callback(resolution, name, mode, file.path)
			})
		} else {
			resolutionCache. /* ? */ forEach(func(resolutions /* TODO(TS-TO-GO) inferred type ModeAwareCache<T> */ any, filePath Path) {
				return resolutions.forEach(func(resolution T, name string, mode ResolutionMode) {
					return callback(resolution, name, mode, filePath)
				})
			})
		}
	}

	getPackagesMap := func() Map[string, bool] {
		if packageMap {
			return packageMap
		}
		packageMap = NewMap()
		// A package name maps to true when we detect it has .d.ts files.
		// This is useful as an approximation of whether a package bundles its own types.
		// Note: we only look at files already found by module resolution,
		// so there may be files we did not consider.
		forEachResolvedModule(func(TODO_IDENTIFIER ResolvedModuleWithFailedLookupLocations) {
			if resolvedModule. /* ? */ packageId {
				packageMap.set(resolvedModule.packageId.name, resolvedModule.extension == ExtensionDts || !!packageMap.get(resolvedModule.packageId.name))
			}
		})
		return packageMap
	}

	typesPackageExists := func(packageName string) bool {
		return getPackagesMap().has(getTypesPackageName(packageName))
	}

	packageBundlesTypes := func(packageName string) bool {
		return !!getPackagesMap().get(packageName)
	}

	addResolutionDiagnostics := func(resolution /* TODO(TS-TO-GO) TypeNode UnionType: ResolvedModuleWithFailedLookupLocations | ResolvedTypeReferenceDirectiveWithFailedLookupLocations */ any) {
		if !resolution.resolutionDiagnostics. /* ? */ length {
			return
		}
		( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: fileProcessingDiagnostics ??= [] */ TODO).push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":        FilePreprocessingDiagnosticsKindResolutionDiagnostics,
			"diagnostics": resolution.resolutionDiagnostics,
		})
	}

	addResolutionDiagnosticsFromResolutionOrCache := func(containingFile SourceFile, name string, resolution ResolvedModuleWithFailedLookupLocations, mode ResolutionMode) {
		// diagnostics directly from the resolution
		if host.resolveModuleNameLiterals || !host.resolveModuleNames {
			return addResolutionDiagnostics(resolution)
		}
		if !moduleResolutionCache || isExternalModuleNameRelative(name) {
			return
		}
		containingFileName := getNormalizedAbsolutePath(containingFile.originalFileName, currentDirectory)
		containingDir := getDirectoryPath(containingFileName)
		redirectedReference := getRedirectReferenceForResolution(containingFile)
		// only nonrelative names hit the cache, and, at least as of right now, only nonrelative names can issue diagnostics
		// (Since diagnostics are only issued via import or export map lookup)
		// This may totally change if/when the issue of output paths not mapping to input files is fixed in a broader context
		// When it is, how we extract diagnostics from the module name resolver will have the be refined - the current cache
		// APIs wrapping the underlying resolver make it almost impossible to smuggle the diagnostics out in a generalized way
		fromCache := moduleResolutionCache.getFromNonRelativeNameCache(name, mode, containingDir, redirectedReference)
		if fromCache {
			addResolutionDiagnostics(fromCache)
		}
	}

	resolveModuleNamesWorker := func(moduleNames []StringLiteralLike, containingFile SourceFile, reusedNames *[]StringLiteralLike) []ResolvedModuleWithFailedLookupLocations {
		containingFileName := getNormalizedAbsolutePath(containingFile.originalFileName, currentDirectory)
		redirectedReference := getRedirectReferenceForResolution(containingFile)
		tracing. /* ? */ push(tracing.Phase.Program, "resolveModuleNamesWorker", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"containingFileName": containingFileName,
		})
		performance.mark("beforeResolveModule")
		result := actualResolveModuleNamesWorker(moduleNames, containingFileName, redirectedReference, options, containingFile, reusedNames)
		performance.mark("afterResolveModule")
		performance.measure("ResolveModule", "beforeResolveModule", "afterResolveModule")
		tracing. /* ? */ pop()
		return result
	}

	resolveTypeReferenceDirectiveNamesWorker := func(typeDirectiveNames []T, containingFile /* TODO(TS-TO-GO) TypeNode UnionType: string | SourceFile */ any, reusedNames *[]T) []ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
		var containingSourceFile *SourceFile
		if !isString(containingFile) {
			containingSourceFile = containingFile
		} else {
			containingSourceFile = nil
		}
		var containingFileName string
		if !isString(containingFile) {
			containingFileName = getNormalizedAbsolutePath(containingFile.originalFileName, currentDirectory)
		} else {
			containingFileName = containingFile
		}
		redirectedReference := containingSourceFile && getRedirectReferenceForResolution(containingSourceFile)
		tracing. /* ? */ push(tracing.Phase.Program, "resolveTypeReferenceDirectiveNamesWorker", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"containingFileName": containingFileName,
		})
		performance.mark("beforeResolveTypeReference")
		result := actualResolveTypeReferenceDirectiveNamesWorker(typeDirectiveNames, containingFileName, redirectedReference, options, containingSourceFile, reusedNames)
		performance.mark("afterResolveTypeReference")
		performance.measure("ResolveTypeReference", "beforeResolveTypeReference", "afterResolveTypeReference")
		tracing. /* ? */ pop()
		return result
	}

	getRedirectReferenceForResolution := func(file SourceFile) *ResolvedProjectReference {
		redirect := getResolvedProjectReferenceToRedirect(file.originalFileName)
		if redirect || !isDeclarationFileName(file.originalFileName) {
			return redirect
		}

		// The originalFileName could not be actual source file name if file found was d.ts from referecned project
		// So in this case try to look up if this is output from referenced project, if it is use the redirected project in that case
		resultFromDts := getRedirectReferenceForResolutionFromSourceOfProject(file.path)
		if resultFromDts {
			return resultFromDts
		}

		// If preserveSymlinks is true, module resolution wont jump the symlink
		// but the resolved real path may be the .d.ts from project reference
		// Note:: Currently we try the real path only if the
		// file is from node_modules to avoid having to run real path on all file paths
		if !host.realpath || !options.preserveSymlinks || !file.originalFileName.includes(nodeModulesPathPart) {
			return nil
		}
		realDeclarationPath := toPath(host.realpath(file.originalFileName))
		if realDeclarationPath == file.path {
			return nil
		} else {
			return getRedirectReferenceForResolutionFromSourceOfProject(realDeclarationPath)
		}
	}

	getRedirectReferenceForResolutionFromSourceOfProject := func(filePath Path) *ResolvedProjectReference {
		source := getSourceOfProjectReferenceRedirect(filePath)
		if isString(source) {
			return getResolvedProjectReferenceToRedirect(source)
		}
		if !source {
			return nil
		}
		// Output of .d.ts file so return resolved ref that matches the out file name
		return forEachResolvedProjectReference(func(resolvedRef ResolvedProjectReference) *ResolvedProjectReference {
			out := resolvedRef.commandLine.options.outFile
			if !out {
				return nil
			}
			if toPath(out) == filePath {
				return resolvedRef
			} else {
				return nil
			}
		})
	}

	compareDefaultLibFiles := func(a SourceFile, b SourceFile) Comparison {
		return compareValues(getDefaultLibFilePriority(a), getDefaultLibFilePriority(b))
	}

	getDefaultLibFilePriority := func(a SourceFile) number {
		if containsPath(defaultLibraryPath, a.fileName /*ignoreCase*/, false) {
			basename := getBaseFileName(a.fileName)
			if basename == "lib.d.ts" || basename == "lib.es6.d.ts" {
				return 0
			}
			name := removeSuffix(removePrefix(basename, "lib."), ".d.ts")
			index := libs.indexOf(name)
			if index != -1 {
				return index + 1
			}
		}
		return libs.length + 2
	}

	toPath := func(fileName string) Path {
		return ts_toPath(fileName, currentDirectory, getCanonicalFileName)
	}

	getCommonSourceDirectory := func() string {
		if commonSourceDirectory == nil {
			emittedFiles := filter(files, func(file SourceFile) bool {
				return sourceFileMayBeEmitted(file, program)
			})
			commonSourceDirectory = ts_getCommonSourceDirectory(options, func() []string {
				return mapDefined(emittedFiles, func(file SourceFile) *string {
					if file.isDeclarationFile {
						return nil
					} else {
						return file.fileName
					}
				})
			}, currentDirectory, getCanonicalFileName, func(commonSourceDirectory string) bool {
				return checkSourceFilesBelongToPath(emittedFiles, commonSourceDirectory)
			})
		}
		return commonSourceDirectory
	}

	getClassifiableNames := func() Set[string] {
		if !classifiableNames {
			// Initialize a checker so that all our files are bound.
			getTypeChecker()
			classifiableNames = NewSet()

			for _, sourceFile := range files {
				sourceFile.classifiableNames. /* ? */ forEach(func(value string) Set[string] {
					return classifiableNames.add(value)
				})
			}
		}

		return classifiableNames
	}

	resolveModuleNamesReusingOldState := func(moduleNames []StringLiteralLike, containingFile SourceFile) []ResolvedModuleWithFailedLookupLocations {
		return resolveNamesReusingOldState(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"entries":              moduleNames,
			"containingFile":       containingFile,
			"containingSourceFile": containingFile,
			"redirectedReference":  getRedirectReferenceForResolution(containingFile),
			"nameAndModeGetter":    moduleResolutionNameAndModeGetter,
			"resolutionWorker":     resolveModuleNamesWorker,
			"getResolutionFromOldProgram": func(name string, mode ResolutionMode) *ResolvedModuleWithFailedLookupLocations {
				return oldProgram. /* ? */ getResolvedModule(containingFile, name, mode)
			},
			"getResolved": getResolvedModuleFromResolution,
			"canReuseResolutionsInFile": func() bool {
				return containingFile == oldProgram. /* ? */ getSourceFile(containingFile.fileName) && !hasInvalidatedResolutions(containingFile.path)
			},
			"resolveToOwnAmbientModule": true,
		})
	}

	/* OVERLOAD: function resolveTypeReferenceDirectiveNamesReusingOldState(typeDirectiveNames: readonly FileReference[], containingFile: SourceFile): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[]; */
	/* OVERLOAD: function resolveTypeReferenceDirectiveNamesReusingOldState(typeDirectiveNames: readonly string[], containingFile: string): readonly ResolvedTypeReferenceDirectiveWithFailedLookupLocations[]; */
	resolveTypeReferenceDirectiveNamesReusingOldState := func(typeDirectiveNames []T, containingFile /* TODO(TS-TO-GO) TypeNode UnionType: string | SourceFile */ any) []ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
		var containingSourceFile *SourceFile
		if !isString(containingFile) {
			containingSourceFile = containingFile
		} else {
			containingSourceFile = nil
		}
		return resolveNamesReusingOldState(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"entries":              typeDirectiveNames,
			"containingFile":       containingFile,
			"containingSourceFile": containingSourceFile,
			"redirectedReference":  containingSourceFile && getRedirectReferenceForResolution(containingSourceFile),
			"nameAndModeGetter":    typeReferenceResolutionNameAndModeGetter,
			"resolutionWorker":     resolveTypeReferenceDirectiveNamesWorker,
			"getResolutionFromOldProgram": func(name string, mode ResolutionMode) *ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
				if containingSourceFile {
					return oldProgram. /* ? */ getResolvedTypeReferenceDirective(containingSourceFile, name, mode)
				} else {
					return oldProgram. /* ? */ getAutomaticTypeDirectiveResolutions(). /* ? */ get(name, mode)
				}
			},
			"getResolved": getResolvedTypeReferenceDirectiveFromResolution,
			"canReuseResolutionsInFile": func() bool {
				if containingSourceFile {
					return containingSourceFile == oldProgram. /* ? */ getSourceFile(containingSourceFile.fileName) && !hasInvalidatedResolutions(containingSourceFile.path)
				} else {
					return !hasInvalidatedResolutions(toPath(containingFile /* as string */))
				}
			},
		})
	}

	type ResolveNamesReusingOldStateInput[Entry any, SourceFileOrString any, SourceFileOrUndefined *SourceFile, Resolution any] struct {
		entries                     []Entry
		containingFile              SourceFileOrString
		containingSourceFile        SourceFileOrUndefined
		redirectedReference         *ResolvedProjectReference
		nameAndModeGetter           ResolutionNameAndModeGetter[Entry, SourceFileOrUndefined]
		resolutionWorker            func(entries []Entry, containingFile SourceFileOrString, reusedNames *[]Entry) []Resolution
		getResolutionFromOldProgram func(name string, mode ResolutionMode) *Resolution
		getResolved                 func(oldResolution Resolution) *ResolutionWithResolvedFileName
		canReuseResolutionsInFile   func() bool
		resolveToOwnAmbientModule/* TODO(TS-TO-GO) TypeNode LiteralType: true */ any
	}

	resolveNamesReusingOldState := func(TODO_IDENTIFIER ResolveNamesReusingOldStateInput[Entry, SourceFileOrString, SourceFileOrUndefined, Resolution]) []Resolution {
		if !entries.length {
			return emptyArray
		}
		if structureIsReused == StructureIsReusedNot && (!resolveToOwnAmbientModule || !containingSourceFile.ambientModuleNames.length) {
			// If the old program state does not permit reusing resolutions and `file` does not contain locally defined ambient modules,
			// the best we can do is fallback to the default logic.
			return resolutionWorker(entries, containingFile, nil)
		}
		/** An ordered list of module names for which we cannot recover the resolution. */

		var unknownEntries *[]Entry
		var unknownEntryIndices *[]number
		var result *[]Resolution
		var reusedNames *[]Entry
		reuseResolutions := canReuseResolutionsInFile()
		for i := 0; i < entries.length; i++ {
			entry := entries[i]
			if reuseResolutions {
				name := nameAndModeGetter.getName(entry)
				mode := nameAndModeGetter.getMode(entry, containingSourceFile /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: redirectedReference?.commandLine.options ?? options */, TODO)
				oldResolution := getResolutionFromOldProgram(name, mode)
				oldResolved := oldResolution && getResolved(oldResolution)
				if oldResolved {
					if isTraceEnabled(options, host) {
						trace(host, ifElse(resolutionWorker == resolveModuleNamesWorker /* as unknown */, ifElse(oldResolved.packageId, Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3, Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2), ifElse(oldResolved.packageId, Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3, Diagnostics.Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2)), name, ifElse(containingSourceFile, getNormalizedAbsolutePath(containingSourceFile.originalFileName, currentDirectory), containingFile), oldResolved.resolvedFileName, oldResolved.packageId && packageIdToString(oldResolved.packageId))
					}
					( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: result ??= new Array(entries.length) */ TODO)[i] = oldResolution
					( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: reusedNames ??= [] */ TODO).push(entry)
					continue
				}
			}
			if resolveToOwnAmbientModule {
				name := nameAndModeGetter.getName(entry)
				// We know moduleName resolves to an ambient module provided that moduleName:
				// - is in the list of ambient modules locally declared in the current source file.
				if contains(containingSourceFile.ambientModuleNames, name) {
					if isTraceEnabled(options, host) {
						trace(host, Diagnostics.Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1, name, getNormalizedAbsolutePath(containingSourceFile.originalFileName, currentDirectory))
					}
					( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: result ??= new Array(entries.length) */ TODO)[i] = emptyResolution
					continue
				}
			}

			// Resolution failed in the old program, or resolved to an ambient module for which we can't reuse the result.
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: unknownEntries ??= [] */ TODO).push(entry)
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: unknownEntryIndices ??= [] */ TODO).push(i)
		}

		if !unknownEntries {
			return result
		}
		resolutions := resolutionWorker(unknownEntries, containingFile, reusedNames)
		if !result {
			return resolutions
		}
		resolutions.forEach(func(resolution Resolution, index number) Resolution {
			return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result[unknownEntryIndices![index]] = resolution */ TODO
		})
		return result
	}

	canReuseProjectReferences := func() bool {
		return !forEachProjectReference(oldProgram.getProjectReferences(), oldProgram.getResolvedProjectReferences(), func(oldResolvedRef *ResolvedProjectReference, parent *ResolvedProjectReference, index number) bool {
			newRef := (ifElse(parent, parent.commandLine.projectReferences, projectReferences))[index]
			newResolvedRef := parseProjectReferenceConfigFile(newRef)
			if oldResolvedRef {
				// Resolved project reference has gone missing or changed
				return !newResolvedRef || newResolvedRef.sourceFile != oldResolvedRef.sourceFile || !arrayIsEqualTo(oldResolvedRef.commandLine.fileNames, newResolvedRef.commandLine.fileNames)
			} else {
				// A previously-unresolved reference may be resolved now
				return newResolvedRef != nil
			}
		}, func(oldProjectReferences *[]ProjectReference, parent *ResolvedProjectReference) bool {
			// If array of references is changed, we cant resue old program
			var newReferences *[]ProjectReference
			if parent {
				newReferences = getResolvedProjectReferenceByPath(parent.sourceFile.path).commandLine.projectReferences
			} else {
				newReferences = projectReferences
			}
			return !arrayIsEqualTo(oldProjectReferences, newReferences, projectReferenceIsEqualTo)
		})
	}

	tryReuseStructureFromOldProgram := func() StructureIsReused {
		if !oldProgram {
			return StructureIsReusedNot
		}

		// check properties that can affect structure of the program or module resolution strategy
		// if any of these properties has changed - structure cannot be reused
		oldOptions := oldProgram.getCompilerOptions()
		if changesAffectModuleResolution(oldOptions, options) {
			return StructureIsReusedNot
		}

		// there is an old program, check if we can reuse its structure
		oldRootNames := oldProgram.getRootFileNames()
		if !arrayIsEqualTo(oldRootNames, rootNames) {
			return StructureIsReusedNot
		}

		// Check if any referenced project tsconfig files are different
		if !canReuseProjectReferences() {
			return StructureIsReusedNot
		}
		if projectReferences {
			resolvedProjectReferences = projectReferences.map_(parseProjectReferenceConfigFile)
		}

		// check if program source files has changed in the way that can affect structure of the program
		var newSourceFiles []SourceFile = []never{}
		var modifiedSourceFiles []SourceFile = []never{}
		structureIsReused = StructureIsReusedCompletely

		// If the missing file paths are now present, it can change the progam structure,
		// and hence cant reuse the structure.
		// This is same as how we dont reuse the structure if one of the file from old program is now missing
		if forEachEntry(oldProgram.getMissingFilePaths(), func(missingFileName string) bool {
			return host.fileExists(missingFileName)
		}) {
			return StructureIsReusedNot
		}

		oldSourceFiles := oldProgram.getSourceFiles()
		type SeenPackageName int32
		const (
			SeenPackageNameExists SeenPackageName = iota
			SeenPackageNameModified
		)
		seenPackageNames := NewMap[string, SeenPackageName]()

		for _, oldSourceFile := range oldSourceFiles {
			sourceFileOptions := getCreateSourceFileOptions(oldSourceFile.fileName, moduleResolutionCache, host, options)
			var newSourceFile *SourceFile
			if host.getSourceFileByPath {
				newSourceFile = host.getSourceFileByPath(oldSourceFile.fileName, oldSourceFile.resolvedPath, sourceFileOptions /*onError*/, nil, shouldCreateNewSourceFile)
			} else {
				newSourceFile = host.getSourceFile(oldSourceFile.fileName, sourceFileOptions /*onError*/, nil, shouldCreateNewSourceFile)
			}
			// TODO: GH#18217

			if !newSourceFile {
				return StructureIsReusedNot
			}
			if sourceFileOptions.packageJsonLocations. /* ? */ length {
				newSourceFile.packageJsonLocations = sourceFileOptions.packageJsonLocations
			} else {
				newSourceFile.packageJsonLocations = nil
			}
			newSourceFile.packageJsonScope = sourceFileOptions.packageJsonScope

			Debug.assert(!newSourceFile.redirectInfo, "Host should not return a redirect source file from `getSourceFile`")

			var fileChanged bool
			if oldSourceFile.redirectInfo {
				// We got `newSourceFile` by path, so it is actually for the unredirected file.
				// This lets us know if the unredirected file has changed. If it has we should break the redirect.
				if newSourceFile != oldSourceFile.redirectInfo.unredirected {
					// Underlying file has changed. Might not redirect anymore. Must rebuild program.
					return StructureIsReusedNot
				}
				fileChanged = false
				newSourceFile = oldSourceFile
				// Use the redirect.
			} else if oldProgram.redirectTargetsMap.has(oldSourceFile.path) {
				// If a redirected-to source file changes, the redirect may be broken.
				if newSourceFile != oldSourceFile {
					return StructureIsReusedNot
				}
				fileChanged = false
			} else {
				fileChanged = newSourceFile != oldSourceFile
			}

			// Since the project references havent changed, its right to set originalFileName and resolvedPath here
			newSourceFile.path = oldSourceFile.path
			newSourceFile.originalFileName = oldSourceFile.originalFileName
			newSourceFile.resolvedPath = oldSourceFile.resolvedPath
			newSourceFile.fileName = oldSourceFile.fileName

			packageName := oldProgram.sourceFileToPackageName.get(oldSourceFile.path)
			if packageName != nil {
				// If there are 2 different source files for the same package name and at least one of them changes,
				// they might become redirects. So we must rebuild the program.
				prevKind := seenPackageNames.get(packageName)
				var newKind SeenPackageName
				if fileChanged {
					newKind = SeenPackageNameModified
				} else {
					newKind = SeenPackageNameExists
				}
				if (prevKind != nil && newKind == SeenPackageNameModified) || prevKind == SeenPackageNameModified {
					return StructureIsReusedNot
				}
				seenPackageNames.set(packageName, newKind)
			}

			if fileChanged {
				if oldSourceFile.impliedNodeFormat != newSourceFile.impliedNodeFormat {
					structureIsReused = StructureIsReusedSafeModules
				} else if !arrayIsEqualTo(oldSourceFile.libReferenceDirectives, newSourceFile.libReferenceDirectives, fileReferenceIsEqualTo) {
					// 'lib' references has changed. Matches behavior in changesAffectModuleResolution
					structureIsReused = StructureIsReusedSafeModules
				} else if oldSourceFile.hasNoDefaultLib != newSourceFile.hasNoDefaultLib {
					// value of no-default-lib has changed
					// this will affect if default library is injected into the list of files
					structureIsReused = StructureIsReusedSafeModules
				} else if !arrayIsEqualTo(oldSourceFile.referencedFiles, newSourceFile.referencedFiles, fileReferenceIsEqualTo) {
					// tripleslash references has changed
					structureIsReused = StructureIsReusedSafeModules
				} else {
					// check imports and module augmentations
					collectExternalModuleReferences(newSourceFile)
					if !arrayIsEqualTo(oldSourceFile.imports, newSourceFile.imports, moduleNameIsEqualTo) {
						// imports has changed
						structureIsReused = StructureIsReusedSafeModules
					} else if !arrayIsEqualTo(oldSourceFile.moduleAugmentations, newSourceFile.moduleAugmentations, moduleNameIsEqualTo) {
						// moduleAugmentations has changed
						structureIsReused = StructureIsReusedSafeModules
					} else if (oldSourceFile.flags & NodeFlagsPermanentlySetIncrementalFlags) != (newSourceFile.flags & NodeFlagsPermanentlySetIncrementalFlags) {
						// dynamicImport has changed
						structureIsReused = StructureIsReusedSafeModules
					} else if !arrayIsEqualTo(oldSourceFile.typeReferenceDirectives, newSourceFile.typeReferenceDirectives, fileReferenceIsEqualTo) {
						// 'types' references has changed
						structureIsReused = StructureIsReusedSafeModules
					}
				}

				// tentatively approve the file
				modifiedSourceFiles.push(newSourceFile)
			} else if hasInvalidatedResolutions(oldSourceFile.path) {
				// 'module/types' references could have changed
				structureIsReused = StructureIsReusedSafeModules

				// add file to the modified list so that we will resolve it later
				modifiedSourceFiles.push(newSourceFile)
			}

			// if file has passed all checks it should be safe to reuse it
			newSourceFiles.push(newSourceFile)
		}

		if structureIsReused != StructureIsReusedCompletely {
			return structureIsReused
		}

		// try to verify results of module resolution
		for _, newSourceFile := range modifiedSourceFiles {
			moduleNames := getModuleNames(newSourceFile)
			resolutions := resolveModuleNamesReusingOldState(moduleNames, newSourceFile)
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: resolvedModulesProcessing ??= new Map() */ TODO).set(newSourceFile.path, resolutions)
			optionsForFile := getCompilerOptionsForFile(newSourceFile)
			// ensure that module resolution results are still correct
			resolutionsChanged := hasChangesInResolutions(moduleNames, resolutions, func(name StringLiteralLike) *ResolvedModuleWithFailedLookupLocations {
				return oldProgram.getResolvedModule(newSourceFile, name.text, getModeForUsageLocationWorker(newSourceFile, name, optionsForFile))
			}, moduleResolutionIsEqualTo)
			if resolutionsChanged {
				structureIsReused = StructureIsReusedSafeModules
			}
			typesReferenceDirectives := newSourceFile.typeReferenceDirectives
			typeReferenceResolutions := resolveTypeReferenceDirectiveNamesReusingOldState(typesReferenceDirectives, newSourceFile)
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: resolvedTypeReferenceDirectiveNamesProcessing ??= new Map() */ TODO).set(newSourceFile.path, typeReferenceResolutions)
			// ensure that types resolutions are still correct
			typeReferenceResolutionsChanged := hasChangesInResolutions(typesReferenceDirectives, typeReferenceResolutions, func(name FileReference) *ResolvedTypeReferenceDirectiveWithFailedLookupLocations {
				return oldProgram.getResolvedTypeReferenceDirective(newSourceFile, getTypeReferenceResolutionName(name), getModeForTypeReferenceDirectiveInFile(name, newSourceFile))
			}, typeDirectiveIsEqualTo)
			if typeReferenceResolutionsChanged {
				structureIsReused = StructureIsReusedSafeModules
			}
		}

		if structureIsReused != StructureIsReusedCompletely {
			return structureIsReused
		}

		if changesAffectingProgramStructure(oldOptions, options) {
			return StructureIsReusedSafeModules
		}

		if oldProgram.resolvedLibReferences && forEachEntry(oldProgram.resolvedLibReferences, func(resolution /* TODO(TS-TO-GO) inferred type LibResolution<ResolvedModuleWithFailedLookupLocations> */ any, libFileName string) bool {
			return pathForLibFileWorker(libFileName).actual != resolution.actual
		}) {
			return StructureIsReusedSafeModules
		}

		if host.hasChangedAutomaticTypeDirectiveNames {
			if host.hasChangedAutomaticTypeDirectiveNames() {
				return StructureIsReusedSafeModules
			}
		} else {
			automaticTypeDirectiveNames = getAutomaticTypeDirectiveNames(options, host)
			if !arrayIsEqualTo(oldProgram.getAutomaticTypeDirectiveNames(), automaticTypeDirectiveNames) {
				return StructureIsReusedSafeModules
			}
		}
		missingFileNames = oldProgram.getMissingFilePaths()

		// update fileName -> file mapping
		Debug.assert(newSourceFiles.length == oldProgram.getSourceFiles().length)
		for _, newSourceFile := range newSourceFiles {
			filesByName.set(newSourceFile.path, newSourceFile)
		}
		oldFilesByNameMap := oldProgram.getFilesByNameMap()
		oldFilesByNameMap.forEach(func(oldFile * /* TODO(TS-TO-GO) inferred type false | SourceFile */ any, path Path) {
			if !oldFile {
				filesByName.set(path, oldFile)
				return
			}
			if oldFile.path == path {
				// Set the file as found during node modules search if it was found that way in old progra,
				if oldProgram.isSourceFileFromExternalLibrary(oldFile) {
					sourceFilesFoundSearchingNodeModules.set(oldFile.path, true)
				}
				return
			}
			filesByName.set(path, filesByName.get(oldFile.path))
		})

		files = newSourceFiles
		fileReasons = oldProgram.getFileIncludeReasons()
		fileProcessingDiagnostics = oldProgram.getFileProcessingDiagnostics()
		automaticTypeDirectiveNames = oldProgram.getAutomaticTypeDirectiveNames()
		automaticTypeDirectiveResolutions = oldProgram.getAutomaticTypeDirectiveResolutions()

		sourceFileToPackageName = oldProgram.sourceFileToPackageName
		redirectTargetsMap = oldProgram.redirectTargetsMap
		usesUriStyleNodeCoreModules = oldProgram.usesUriStyleNodeCoreModules
		resolvedModules = oldProgram.resolvedModules
		resolvedTypeReferenceDirectiveNames = oldProgram.resolvedTypeReferenceDirectiveNames
		resolvedLibReferences = oldProgram.resolvedLibReferences
		packageMap = oldProgram.getCurrentPackagesMap()

		return StructureIsReusedCompletely
	}

	getEmitHost := func(writeFileCallback WriteFileCallback) EmitHost {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"getCanonicalFileName":     getCanonicalFileName,
			"getCommonSourceDirectory": program.getCommonSourceDirectory,
			"getCompilerOptions":       program.getCompilerOptions,
			"getCurrentDirectory": func() string {
				return currentDirectory
			},
			"getSourceFile":                         program.getSourceFile,
			"getSourceFileByPath":                   program.getSourceFileByPath,
			"getSourceFiles":                        program.getSourceFiles,
			"isSourceFileFromExternalLibrary":       isSourceFileFromExternalLibrary,
			"getResolvedProjectReferenceToRedirect": getResolvedProjectReferenceToRedirect,
			"getProjectReferenceRedirect":           getProjectReferenceRedirect,
			"isSourceOfProjectReferenceRedirect":    isSourceOfProjectReferenceRedirect,
			"getSymlinkCache":                       getSymlinkCache,
			"writeFile":                             writeFileCallback || writeFile,
			"isEmitBlocked":                         isEmitBlocked,
			"shouldTransformImportCall":             shouldTransformImportCall,
			"getEmitModuleFormatOfFile":             getEmitModuleFormatOfFile,
			"getDefaultResolutionModeForFile":       getDefaultResolutionModeForFile,
			"getModeForResolutionAtIndex":           getModeForResolutionAtIndex,
			"readFile": func(f string) *string {
				return host.readFile(f)
			},
			"fileExists": func(f string) bool {
				// Use local caches
				path := toPath(f)
				if getSourceFileByPath(path) {
					return true
				}
				if missingFileNames.has(path) {
					return false
				}
				// Before falling back to the host
				return host.fileExists(f)
			},
			"realpath": maybeBind(host, host.realpath),
			"useCaseSensitiveFileNames": func() bool {
				return host.useCaseSensitiveFileNames()
			},
			"getBuildInfo": func() *BuildInfo {
				return program.getBuildInfo()
			},
			"getSourceFileFromReference": func(file SourceFile, ref FileReference) *SourceFile {
				return program.getSourceFileFromReference(file, ref)
			},
			"redirectTargetsMap":    redirectTargetsMap,
			"getFileIncludeReasons": program.getFileIncludeReasons,
			"createHash":            maybeBind(host, host.createHash),
			"getModuleResolutionCache": func() *ModuleResolutionCache {
				return program.getModuleResolutionCache()
			},
			"trace":                         maybeBind(host, host.trace),
			"getGlobalTypingsCacheLocation": program.getGlobalTypingsCacheLocation,
		}
	}

	writeFile := func(fileName string, text string, writeByteOrderMark bool, onError func(message string), sourceFiles []SourceFile, data WriteFileCallbackData) {
		host.writeFile(fileName, text, writeByteOrderMark, onError, sourceFiles, data)
	}

	emitBuildInfo := func(writeFileCallback WriteFileCallback) EmitResult {
		tracing. /* ? */ push(tracing.Phase.Emit, "emitBuildInfo", map[any]any{ /* TODO(TS-TO-GO): was object literal */
		}, /*separateBeginAndEnd*/ true)
		performance.mark("beforeEmit")
		emitResult := emitFiles(notImplementedResolver, getEmitHost(writeFileCallback), nil, noTransformers, false, true)

		performance.mark("afterEmit")
		performance.measure("Emit", "beforeEmit", "afterEmit")
		tracing. /* ? */ pop()
		return emitResult
	}

	getResolvedProjectReferences := func() *[] /* TODO(TS-TO-GO) inferred type (ResolvedProjectReference | undefined) */ any {
		return resolvedProjectReferences
	}

	getProjectReferences := func() *[]ProjectReference {
		return projectReferences
	}

	isSourceFileFromExternalLibrary := func(file SourceFile) bool {
		return !!sourceFilesFoundSearchingNodeModules.get(file.path)
	}

	isSourceFileDefaultLibrary := func(file SourceFile) bool {
		if !file.isDeclarationFile {
			return false
		}

		if file.hasNoDefaultLib {
			return true
		}

		if options.noLib {
			return false
		}

		// If '--lib' is not specified, include default library file according to '--target'
		// otherwise, using options specified in '--lib' instead of '--target' default library file
		var equalityComparer /* TODO(TS-TO-GO) inferred type typeof equateStringsCaseSensitive */ any
		if host.useCaseSensitiveFileNames() {
			equalityComparer = equateStringsCaseSensitive
		} else {
			equalityComparer = equateStringsCaseInsensitive
		}
		if !options.lib {
			return equalityComparer(file.fileName, getDefaultLibraryFileName())
		} else {
			return some(options.lib, func(libFileName string) bool {
				// We might not have resolved lib if one of the root file included contained no-default-lib = true
				resolvedLib := resolvedLibReferences.get(libFileName)
				return !!resolvedLib && equalityComparer(file.fileName, resolvedLib.actual)
			})
		}
	}

	getTypeChecker := func() TypeChecker {
		return typeChecker || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: typeChecker = createTypeChecker(program) */ TODO)
	}

	emit := func(sourceFile SourceFile, writeFileCallback WriteFileCallback, cancellationToken CancellationToken, emitOnly /* TODO(TS-TO-GO) TypeNode UnionType: boolean | EmitOnly */ any, transformers CustomTransformers, forceDtsEmit bool, skipBuildInfo bool) EmitResult {
		tracing. /* ? */ push(tracing.Phase.Emit, "emit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"path": sourceFile. /* ? */ path,
		}, /*separateBeginAndEnd*/ true)
		result := runWithCancellationToken(func() EmitResult {
			return emitWorker(program, sourceFile, writeFileCallback, cancellationToken, emitOnly, transformers, forceDtsEmit, skipBuildInfo)
		})
		tracing. /* ? */ pop()
		return result
	}

	isEmitBlocked := func(emitFileName string) bool {
		return hasEmitBlockingDiagnostics.has(toPath(emitFileName))
	}

	emitWorker := func(program Program, sourceFile *SourceFile, writeFileCallback *WriteFileCallback, cancellationToken CancellationToken, emitOnly /* TODO(TS-TO-GO) TypeNode UnionType: boolean | EmitOnly | undefined */ any, customTransformers *CustomTransformers, forceDtsEmit *bool, skipBuildInfo *bool) EmitResult {
		if !forceDtsEmit {
			result := handleNoEmitOptions(program, sourceFile, writeFileCallback, cancellationToken)
			if result {
				return result
			}
		}

		// Create the emit resolver outside of the "emitTime" tracking code below.  That way
		// any cost associated with it (like type checking) are appropriate associated with
		// the type-checking counter.
		//
		// If the -out option is specified, we should not pass the source file to getEmitResolver.
		// This is because in the -out scenario all files need to be emitted, and therefore all
		// files need to be type checked. And the way to specify that all files need to be type
		// checked is to not pass the file to getEmitResolver.
		typeChecker := getTypeChecker()
		emitResolver := typeChecker.getEmitResolver(ifElse(options.outFile, nil, sourceFile), cancellationToken, emitResolverSkipsTypeChecking(emitOnly, forceDtsEmit))

		performance.mark("beforeEmit")

		emitResult := typeChecker.runWithCancellationToken(cancellationToken, func() EmitResult {
			return emitFiles(emitResolver, getEmitHost(writeFileCallback), sourceFile, getTransformers(options, customTransformers, emitOnly), emitOnly, false, forceDtsEmit, skipBuildInfo)
		})

		performance.mark("afterEmit")
		performance.measure("Emit", "beforeEmit", "afterEmit")
		return emitResult
	}

	getSourceFile := func(fileName string) *SourceFile {
		return getSourceFileByPath(toPath(fileName))
	}

	getSourceFileByPath := func(path Path) *SourceFile {
		return filesByName.get(path) || nil
	}

	getDiagnosticsHelper := func(sourceFile *SourceFile, getDiagnostics func(sourceFile SourceFile, cancellationToken CancellationToken) []T, cancellationToken CancellationToken) []T {
		if sourceFile {
			return sortAndDeduplicateDiagnostics(getDiagnostics(sourceFile, cancellationToken))
		}
		return sortAndDeduplicateDiagnostics(flatMap(program.getSourceFiles(), func(sourceFile SourceFile) []T {
			if cancellationToken {
				cancellationToken.throwIfCancellationRequested()
			}
			return getDiagnostics(sourceFile, cancellationToken)
		}))
	}

	getSyntacticDiagnostics := func(sourceFile SourceFile, cancellationToken CancellationToken) []DiagnosticWithLocation {
		return getDiagnosticsHelper(sourceFile, getSyntacticDiagnosticsForFile, cancellationToken)
	}

	getSemanticDiagnostics := func(sourceFile SourceFile, cancellationToken CancellationToken, nodesToCheck []*Node) []Diagnostic {
		return getDiagnosticsHelper(sourceFile, func(sourceFile SourceFile, cancellationToken CancellationToken) []Diagnostic {
			return getSemanticDiagnosticsForFile(sourceFile, cancellationToken, nodesToCheck)
		}, cancellationToken)
	}

	getCachedSemanticDiagnostics := func(sourceFile SourceFile) *[]Diagnostic {
		return cachedBindAndCheckDiagnosticsForFile. /* ? */ get(sourceFile.path)
	}

	getBindAndCheckDiagnostics := func(sourceFile SourceFile, cancellationToken CancellationToken) []Diagnostic {
		return getBindAndCheckDiagnosticsForFile(sourceFile, cancellationToken /*nodesToCheck*/, nil)
	}

	getProgramDiagnostics := func(sourceFile SourceFile) []Diagnostic {
		if skipTypeChecking(sourceFile, options, program) {
			return emptyArray
		}

		programDiagnosticsInFile := updateAndGetProgramDiagnostics().getDiagnostics(sourceFile.fileName)
		if !sourceFile.commentDirectives. /* ? */ length {
			return programDiagnosticsInFile
		}

		return getDiagnosticsWithPrecedingDirectives(sourceFile, sourceFile.commentDirectives, programDiagnosticsInFile).diagnostics
	}

	getDeclarationDiagnostics := func(sourceFile SourceFile, cancellationToken CancellationToken) []DiagnosticWithLocation {
		return getDiagnosticsHelper(sourceFile, getDeclarationDiagnosticsForFile, cancellationToken)
	}

	getSyntacticDiagnosticsForFile := func(sourceFile SourceFile) []DiagnosticWithLocation {
		// For JavaScript files, we report semantic errors for using TypeScript-only
		// constructs from within a JavaScript file as syntactic errors.
		if isSourceFileJS(sourceFile) {
			if !sourceFile.additionalSyntacticDiagnostics {
				sourceFile.additionalSyntacticDiagnostics = getJSSyntacticDiagnosticsForFile(sourceFile)
			}
			return concatenate(sourceFile.additionalSyntacticDiagnostics, sourceFile.parseDiagnostics)
		}
		return sourceFile.parseDiagnostics
	}

	runWithCancellationToken := func(func_ func() T) T {
		{ // try
			return func_()
		}
		{ // catch e
			if /* TODO(TS-TO-GO) InstanceOfKeyword BinaryExpression: e instanceof OperationCanceledException */ TODO {
				// We were canceled while performing the operation.  Because our type checker
				// might be a bad state, we need to throw it away.
				typeChecker = nil
			}

			/* TODO(TS-TO-GO) Node ThrowStatement: throw e; */
		}
	}

	getSemanticDiagnosticsForFile := func(sourceFile SourceFile, cancellationToken CancellationToken, nodesToCheck *[]*Node) []Diagnostic {
		return concatenate(filterSemanticDiagnostics(getBindAndCheckDiagnosticsForFile(sourceFile, cancellationToken, nodesToCheck), options), getProgramDiagnostics(sourceFile))
	}

	getBindAndCheckDiagnosticsForFile := func(sourceFile SourceFile, cancellationToken CancellationToken, nodesToCheck *[]*Node) []Diagnostic {
		if nodesToCheck {
			return getBindAndCheckDiagnosticsForFileNoCache(sourceFile, cancellationToken, nodesToCheck)
		}
		result := cachedBindAndCheckDiagnosticsForFile. /* ? */ get(sourceFile.path)
		if !result {
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: cachedBindAndCheckDiagnosticsForFile ??= new Map() */ TODO).set(sourceFile.path /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = getBindAndCheckDiagnosticsForFileNoCache(sourceFile, cancellationToken) */, TODO)
		}
		return result
	}

	getBindAndCheckDiagnosticsForFileNoCache := func(sourceFile SourceFile, cancellationToken CancellationToken, nodesToCheck []*Node) []Diagnostic {
		return runWithCancellationToken(func() []Diagnostic {
			if skipTypeChecking(sourceFile, options, program) {
				return emptyArray
			}

			typeChecker := getTypeChecker()

			Debug.assert(!!sourceFile.bindDiagnostics)

			isJs := sourceFile.scriptKind == ScriptKindJS || sourceFile.scriptKind == ScriptKindJSX
			isPlainJs := isPlainJsFile(sourceFile, options.checkJs)
			isCheckJs := isJs && isCheckJsEnabledForFile(sourceFile, options)

			bindDiagnostics := sourceFile.bindDiagnostics
			checkDiagnostics := typeChecker.getDiagnostics(sourceFile, cancellationToken, nodesToCheck)
			if isPlainJs {
				bindDiagnostics = filter(bindDiagnostics, func(d DiagnosticWithLocation) bool {
					return plainJSErrors.has(d.code)
				})
				checkDiagnostics = filter(checkDiagnostics, func(d Diagnostic) bool {
					return plainJSErrors.has(d.code)
				})
			}
			// skip ts-expect-error errors in plain JS files, and skip JSDoc errors except in checked JS
			return getMergedBindAndCheckDiagnostics(sourceFile, !isPlainJs, !!nodesToCheck, bindDiagnostics, checkDiagnostics, ifElse(isCheckJs, sourceFile.jsDocDiagnostics, nil))
		})
	}

	getMergedBindAndCheckDiagnostics := func(sourceFile SourceFile, includeBindAndCheckDiagnostics bool, partialCheck bool, allDiagnostics []*[]Diagnostic) []Diagnostic {
		flatDiagnostics := flatten(allDiagnostics)
		if !includeBindAndCheckDiagnostics || !sourceFile.commentDirectives. /* ? */ length {
			return flatDiagnostics
		}

		TODO_IDENTIFIER := getDiagnosticsWithPrecedingDirectives(sourceFile, sourceFile.commentDirectives, flatDiagnostics)

		// When doing a partial check, we can't be sure a directive is unused.
		if partialCheck {
			return diagnostics
		}

		for _, errorExpectation := range directives.getUnusedExpectations() {
			diagnostics.push(createDiagnosticForRange(sourceFile, errorExpectation.range_, Diagnostics.Unused_ts_expect_error_directive))
		}

		return diagnostics
	}

	/**
	 * Creates a map of comment directives along with the diagnostics immediately preceded by one of them.
	 * Comments that match to any of those diagnostics are marked as used.
	 */

	getDiagnosticsWithPrecedingDirectives := func(sourceFile SourceFile, commentDirectives []CommentDirective, flatDiagnostics []Diagnostic) /* TODO(TS-TO-GO) inferred type { diagnostics: Diagnostic[]; directives: CommentDirectivesMap; } */ any {
		// Diagnostics are only reported if there is no comment directive preceding them
		// This will modify the directives map by marking "used" ones with a corresponding diagnostic
		directives := createCommentDirectivesMap(sourceFile, commentDirectives)
		diagnostics := flatDiagnostics.filter(func(diagnostic Diagnostic) bool {
			return markPrecedingCommentDirectiveLine(diagnostic, directives) == -1
		})

		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"diagnostics": diagnostics,
			"directives":  directives,
		}
	}

	getSuggestionDiagnostics := func(sourceFile SourceFile, cancellationToken CancellationToken) []DiagnosticWithLocation {
		return runWithCancellationToken(func() []DiagnosticWithLocation {
			return getTypeChecker().getSuggestionDiagnostics(sourceFile, cancellationToken)
		})
	}

	/**
	 * @returns The line index marked as preceding the diagnostic, or -1 if none was.
	 */

	markPrecedingCommentDirectiveLine := func(diagnostic Diagnostic, directives CommentDirectivesMap) number {
		TODO_IDENTIFIER := diagnostic
		if !file {
			return -1
		}

		// Start out with the line just before the text
		lineStarts := getLineStarts(file)
		line := computeLineAndCharacterOfPosition(lineStarts, start).line - 1
		// TODO: GH#18217
		for line >= 0 {
			// As soon as that line is known to have a comment directive, use that
			if directives.markUsed(line) {
				return line
			}

			// Stop searching if the line is not empty and not a comment
			lineText := file.text.slice(lineStarts[line], lineStarts[line+1]).trim()
			if lineText != "" && !regexp.MustParse(`^\s*\/\/.*$`).test(lineText) {
				return -1
			}

			line--
		}

		return -1
	}

	getJSSyntacticDiagnosticsForFile := func(sourceFile SourceFile) []DiagnosticWithLocation {
		return runWithCancellationToken(func() []DiagnosticWithLocation {
			var diagnostics []DiagnosticWithLocation = []never{}
			walk(sourceFile, sourceFile)
			forEachChildRecursively(sourceFile, walk, walkArray)

			return diagnostics

			walk := func(node *Node, parent *Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
				// Return directly from the case if the given node doesnt want to visit each child
				// Otherwise break to visit each child

				switch parent.kind {
				case SyntaxKindParameter,
					SyntaxKindPropertyDeclaration,
					SyntaxKindMethodDeclaration:
					if (parent /* as ParameterDeclaration | PropertyDeclaration | MethodDeclaration */).questionToken == node {
						diagnostics.push(createDiagnosticForNode(node, Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, "?"))
						return "skip"
					}
					fallthrough
				case SyntaxKindMethodSignature,
					SyntaxKindConstructor,
					SyntaxKindGetAccessor,
					SyntaxKindSetAccessor,
					SyntaxKindFunctionExpression,
					SyntaxKindFunctionDeclaration,
					SyntaxKindArrowFunction,
					SyntaxKindVariableDeclaration:
					// type annotation
					if (parent /* as FunctionLikeDeclaration | VariableDeclaration | ParameterDeclaration | PropertyDeclaration */).type_ == node {
						diagnostics.push(createDiagnosticForNode(node, Diagnostics.Type_annotations_can_only_be_used_in_TypeScript_files))
						return "skip"
					}
				}

				switch node.kind {
				case SyntaxKindImportClause:
					if (node.AsImportClause()).isTypeOnly {
						diagnostics.push(createDiagnosticForNode(parent, Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, "import type"))
						return "skip"
					}
				case SyntaxKindExportDeclaration:
					if (node.AsExportDeclaration()).isTypeOnly {
						diagnostics.push(createDiagnosticForNode(node, Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, "export type"))
						return "skip"
					}
				case SyntaxKindImportSpecifier,
					SyntaxKindExportSpecifier:
					if (node.AsImportOrExportSpecifier()).isTypeOnly {
						diagnostics.push(createDiagnosticForNode(node, Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, ifElse(isImportSpecifier(node), "import...type", "export...type")))
						return "skip"
					}
				case SyntaxKindImportEqualsDeclaration:
					diagnostics.push(createDiagnosticForNode(node, Diagnostics.import_can_only_be_used_in_TypeScript_files))
					return "skip"
				case SyntaxKindExportAssignment:
					if (node.AsExportAssignment()).isExportEquals {
						diagnostics.push(createDiagnosticForNode(node, Diagnostics.export_can_only_be_used_in_TypeScript_files))
						return "skip"
					}
				case SyntaxKindHeritageClause:
					heritageClause := node.AsHeritageClause()
					if heritageClause.token == SyntaxKindImplementsKeyword {
						diagnostics.push(createDiagnosticForNode(node, Diagnostics.implements_clauses_can_only_be_used_in_TypeScript_files))
						return "skip"
					}
				case SyntaxKindInterfaceDeclaration:
					interfaceKeyword := tokenToString(SyntaxKindInterfaceKeyword)
					Debug.assertIsDefined(interfaceKeyword)
					diagnostics.push(createDiagnosticForNode(node, Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, interfaceKeyword))
					return "skip"
				case SyntaxKindModuleDeclaration:
					var moduleKeyword string
					if node.flags & NodeFlagsNamespace {
						moduleKeyword = tokenToString(SyntaxKindNamespaceKeyword)
					} else {
						moduleKeyword = tokenToString(SyntaxKindModuleKeyword)
					}
					Debug.assertIsDefined(moduleKeyword)
					diagnostics.push(createDiagnosticForNode(node, Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, moduleKeyword))
					return "skip"
				case SyntaxKindTypeAliasDeclaration:
					diagnostics.push(createDiagnosticForNode(node, Diagnostics.Type_aliases_can_only_be_used_in_TypeScript_files))
					return "skip"
				case SyntaxKindConstructor,
					SyntaxKindMethodDeclaration,
					SyntaxKindFunctionDeclaration:
					if !(node.AsFunctionLikeDeclaration()).body {
						diagnostics.push(createDiagnosticForNode(node, Diagnostics.Signature_declarations_can_only_be_used_in_TypeScript_files))
						return "skip"
					}
					return
				case SyntaxKindEnumDeclaration:
					enumKeyword := Debug.checkDefined(tokenToString(SyntaxKindEnumKeyword))
					diagnostics.push(createDiagnosticForNode(node, Diagnostics._0_declarations_can_only_be_used_in_TypeScript_files, enumKeyword))
					return "skip"
				case SyntaxKindNonNullExpression:
					diagnostics.push(createDiagnosticForNode(node, Diagnostics.Non_null_assertions_can_only_be_used_in_TypeScript_files))
					return "skip"
				case SyntaxKindAsExpression:
					diagnostics.push(createDiagnosticForNode((node.AsAsExpression()).type_, Diagnostics.Type_assertion_expressions_can_only_be_used_in_TypeScript_files))
					return "skip"
				case SyntaxKindSatisfiesExpression:
					diagnostics.push(createDiagnosticForNode((node.AsSatisfiesExpression()).type_, Diagnostics.Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files))
					return "skip"
				case SyntaxKindTypeAssertionExpression:
					Debug.fail()
					// Won't parse these in a JS file anyway, as they are interpreted as JSX.
				}
			}

			walkArray := func(nodes NodeArray[*Node], parent *Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
				if canHaveIllegalDecorators(parent) {
					decorator := find(parent.modifiers, isDecorator)
					if decorator {
						// report illegal decorator
						diagnostics.push(createDiagnosticForNode(decorator, Diagnostics.Decorators_are_not_valid_here))
					}
				} else if canHaveDecorators(parent) && parent.modifiers {
					decoratorIndex := findIndex(parent.modifiers, isDecorator)
					if decoratorIndex >= 0 {
						if isParameter(parent) && !options.experimentalDecorators {
							// report illegall decorator on parameter
							diagnostics.push(createDiagnosticForNode(parent.modifiers[decoratorIndex], Diagnostics.Decorators_are_not_valid_here))
						} else if isClassDeclaration(parent) {
							exportIndex := findIndex(parent.modifiers, isExportModifier)
							if exportIndex >= 0 {
								defaultIndex := findIndex(parent.modifiers, isDefaultModifier)
								if decoratorIndex > exportIndex && defaultIndex >= 0 && decoratorIndex < defaultIndex {
									// report illegal decorator between `export` and `default`
									diagnostics.push(createDiagnosticForNode(parent.modifiers[decoratorIndex], Diagnostics.Decorators_are_not_valid_here))
								} else if exportIndex >= 0 && decoratorIndex < exportIndex {
									trailingDecoratorIndex := findIndex(parent.modifiers, isDecorator, exportIndex)
									if trailingDecoratorIndex >= 0 {
										diagnostics.push(addRelatedInfo(createDiagnosticForNode(parent.modifiers[trailingDecoratorIndex], Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export), createDiagnosticForNode(parent.modifiers[decoratorIndex], Diagnostics.Decorator_used_before_export_here)))
									}
								}
							}
						}
					}
				}

				switch parent.kind {
				case SyntaxKindClassDeclaration,
					SyntaxKindClassExpression,
					SyntaxKindMethodDeclaration,
					SyntaxKindConstructor,
					SyntaxKindGetAccessor,
					SyntaxKindSetAccessor,
					SyntaxKindFunctionExpression,
					SyntaxKindFunctionDeclaration,
					SyntaxKindArrowFunction:
					// Check type parameters
					if nodes == (parent.AsDeclarationWithTypeParameterChildren()).typeParameters {
						diagnostics.push(createDiagnosticForNodeArray(nodes, Diagnostics.Type_parameter_declarations_can_only_be_used_in_TypeScript_files))
						return "skip"
					}
					fallthrough
				case SyntaxKindVariableStatement:
					// Check modifiers
					if nodes == (parent.AsVariableStatement()).modifiers {
						checkModifiers((parent.AsVariableStatement()).modifiers, parent.kind == SyntaxKindVariableStatement)
						return "skip"
					}
				case SyntaxKindPropertyDeclaration:
					// Check modifiers of property declaration
					if nodes == (parent.AsPropertyDeclaration()).modifiers {
						for _, modifier := range nodes.(NodeArray[ModifierLike]) {
							if isModifier(modifier) && modifier.kind != SyntaxKindStaticKeyword && modifier.kind != SyntaxKindAccessorKeyword {
								diagnostics.push(createDiagnosticForNode(modifier, Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, tokenToString(modifier.kind)))
							}
						}
						return "skip"
					}
				case SyntaxKindParameter:
					// Check modifiers of parameter declaration
					if nodes == (parent.AsParameterDeclaration()).modifiers && some(nodes, isModifier) {
						diagnostics.push(createDiagnosticForNodeArray(nodes, Diagnostics.Parameter_modifiers_can_only_be_used_in_TypeScript_files))
						return "skip"
					}
				case SyntaxKindCallExpression,
					SyntaxKindNewExpression,
					SyntaxKindExpressionWithTypeArguments,
					SyntaxKindJsxSelfClosingElement,
					SyntaxKindJsxOpeningElement,
					SyntaxKindTaggedTemplateExpression:
					// Check type arguments
					if nodes == (parent.AsNodeWithTypeArguments()).typeArguments {
						diagnostics.push(createDiagnosticForNodeArray(nodes, Diagnostics.Type_arguments_can_only_be_used_in_TypeScript_files))
						return "skip"
					}
				}
			}

			checkModifiers := func(modifiers NodeArray[ModifierLike], isConstValid bool) {
				for _, modifier := range modifiers {
					switch modifier.kind {
					case SyntaxKindConstKeyword:
						if isConstValid {
							continue
						}
						// to report error,
						fallthrough
					case SyntaxKindPublicKeyword,
						SyntaxKindPrivateKeyword,
						SyntaxKindProtectedKeyword,
						SyntaxKindReadonlyKeyword,
						SyntaxKindDeclareKeyword,
						SyntaxKindAbstractKeyword,
						SyntaxKindOverrideKeyword,
						SyntaxKindInKeyword,
						SyntaxKindOutKeyword:
						diagnostics.push(createDiagnosticForNode(modifier, Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, tokenToString(modifier.kind)))

						// These are all legal modifiers.
					case SyntaxKindStaticKeyword:
					case SyntaxKindExportKeyword:
					case SyntaxKindDefaultKeyword:
					case SyntaxKindAccessorKeyword:
					}
				}
			}

			createDiagnosticForNodeArray := func(nodes NodeArray[*Node], message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
				start := nodes.pos
				return createFileDiagnostic(sourceFile, start, nodes.end-start, message, args...)
			}

			// Since these are syntactic diagnostics, parent might not have been set
			// this means the sourceFile cannot be infered from the node
			createDiagnosticForNode := func(node *Node, message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
				return createDiagnosticForNodeInSourceFile(sourceFile, node, message, args...)
			}

		})
	}

	getDeclarationDiagnosticsWorker := func(sourceFile SourceFile, cancellationToken CancellationToken) []DiagnosticWithLocation {
		result := cachedDeclarationDiagnosticsForFile. /* ? */ get(sourceFile.path)
		if !result {
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: cachedDeclarationDiagnosticsForFile ??= new Map() */ TODO).set(sourceFile.path /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = getDeclarationDiagnosticsForFileNoCache(sourceFile, cancellationToken) */, TODO)
		}
		return result
	}

	getDeclarationDiagnosticsForFileNoCache := func(sourceFile SourceFile, cancellationToken CancellationToken) []DiagnosticWithLocation {
		return runWithCancellationToken(func() []DiagnosticWithLocation {
			resolver := getTypeChecker().getEmitResolver(sourceFile, cancellationToken)
			// Don't actually write any files since we're just getting diagnostics.
			return ts_getDeclarationDiagnostics(getEmitHost(noop), resolver, sourceFile) || emptyArray
		})
	}

	getDeclarationDiagnosticsForFile := func(sourceFile SourceFile, cancellationToken CancellationToken) []DiagnosticWithLocation {
		if sourceFile.isDeclarationFile {
			return emptyArray
		} else {
			return getDeclarationDiagnosticsWorker(sourceFile, cancellationToken)
		}
	}

	getOptionsDiagnostics := func() SortedReadonlyArray[Diagnostic] {
		return sortAndDeduplicateDiagnostics(concatenate(updateAndGetProgramDiagnostics().getGlobalDiagnostics(), getOptionsDiagnosticsOfConfigFile()))
	}

	getOptionsDiagnosticsOfConfigFile := func() []DiagnosticWithLocation {
		if !options.configFile {
			return emptyArray
		}
		diagnostics := updateAndGetProgramDiagnostics().getDiagnostics(options.configFile.fileName)
		forEachResolvedProjectReference(func(resolvedRef ResolvedProjectReference) {
			diagnostics = concatenate(diagnostics, updateAndGetProgramDiagnostics().getDiagnostics(resolvedRef.sourceFile.fileName))
		})
		return diagnostics
	}

	getGlobalDiagnostics := func() SortedReadonlyArray[Diagnostic] {
		if rootNames.length {
			return sortAndDeduplicateDiagnostics(getTypeChecker().getGlobalDiagnostics().slice())
		} else {
			return emptyArray. /* as any */ (SortedReadonlyArray[Diagnostic])
		}
	}

	getConfigFileParsingDiagnostics := func() []Diagnostic {
		return configFileParsingDiagnostics || emptyArray
	}

	processRootFile := func(fileName string, isDefaultLib bool, ignoreNoDefaultLib bool, reason FileIncludeReason) {
		processSourceFile(normalizePath(fileName), isDefaultLib, ignoreNoDefaultLib /*packageId*/, nil, reason)
	}

	fileReferenceIsEqualTo := func(a FileReference, b FileReference) bool {
		return a.fileName == b.fileName
	}

	moduleNameIsEqualTo := func(a /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteralLike | Identifier */ any, b /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteralLike | Identifier */ any) bool {
		if a.kind == SyntaxKindIdentifier {
			return b.kind == SyntaxKindIdentifier && a.escapedText == b.escapedText
		} else {
			return b.kind == SyntaxKindStringLiteral && a.text == b.text
		}
	}

	createSyntheticImport := func(text string, file SourceFile) StringLiteral {
		externalHelpersModuleReference := factory.createStringLiteral(text)
		importDecl := factory.createImportDeclaration(nil /*importClause*/, nil, externalHelpersModuleReference)
		addInternalEmitFlags(importDecl, InternalEmitFlagsNeverApplyImportHelper)
		setParent(externalHelpersModuleReference, importDecl)
		setParent(importDecl, file)
		// explicitly unset the synthesized flag on these declarations so the checker API will answer questions about them
		// (which is required to build the dependency graph for incremental emit)
		(externalHelpersModuleReference.(Mutable[*Node])).flags &^= NodeFlagsSynthesized
		(importDecl.(Mutable[*Node])).flags &^= NodeFlagsSynthesized
		return externalHelpersModuleReference
	}

	collectExternalModuleReferences := func(file SourceFile) {
		if file.imports {
			return
		}

		isJavaScriptFile := isSourceFileJS(file)
		isExternalModuleFile := isExternalModule(file)

		// file.imports may not be undefined if there exists dynamic import
		var imports *[]StringLiteralLike
		var moduleAugmentations *[] /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteral | Identifier */ any
		var ambientModules *[]string

		// If we are importing helpers, we need to add a synthetic reference to resolve the
		// helpers library. (A JavaScript file without `externalModuleIndicator` set might be
		// a CommonJS module; `commonJsModuleIndicator` doesn't get set until the binder has
		// run. We synthesize a helpers import for it just in case; it will never be used if
		// the binder doesn't find and set a `commonJsModuleIndicator`.)
		if isJavaScriptFile || (!file.isDeclarationFile && (getIsolatedModules(options) || isExternalModule(file))) {
			if options.importHelpers {
				// synthesize 'import "tslib"' declaration
				imports = []StringLiteral{createSyntheticImport(externalHelpersModuleNameText, file)}
			}
			jsxImport := getJSXRuntimeImport(getJSXImplicitImportBase(options, file), options)
			if jsxImport {
				// synthesize `import "base/jsx-runtime"` declaration
				( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: imports ||= [] */ TODO).push(createSyntheticImport(jsxImport, file))
			}
		}

		for _, node := range file.statements {
			collectModuleReferences(node /*inAmbientModule*/, false)
		}

		if (file.flags & NodeFlagsPossiblyContainsDynamicImport) || isJavaScriptFile {
			collectDynamicImportOrRequireOrJsDocImportCalls(file)
		}

		file.imports = imports || emptyArray
		file.moduleAugmentations = moduleAugmentations || emptyArray
		file.ambientModuleNames = ambientModules || emptyArray

		return

		collectModuleReferences := func(node Statement, inAmbientModule bool) {
			if isAnyImportOrReExport(node) {
				moduleNameExpr := getExternalModuleName(node)
				// TypeScript 1.0 spec (April 2014): 12.1.6
				// An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference other external modules
				// only through top - level external module names. Relative external module names are not permitted.
				if moduleNameExpr && isStringLiteral(moduleNameExpr) && moduleNameExpr.text && (!inAmbientModule || !isExternalModuleNameRelative(moduleNameExpr.text)) {
					setParentRecursive(node /*incremental*/, false)
					// we need parent data on imports before the program is fully bound, so we ensure it's set here
					imports = append(imports, moduleNameExpr)
					if !usesUriStyleNodeCoreModules && currentNodeModulesDepth == 0 && !file.isDeclarationFile {
						if startsWith(moduleNameExpr.text, "node:") && !exclusivelyPrefixedNodeCoreModules.has(moduleNameExpr.text) {
							// Presence of `node:` prefix takes precedence over unprefixed node core modules
							usesUriStyleNodeCoreModules = true
						} else if usesUriStyleNodeCoreModules == nil && unprefixedNodeCoreModules.has(moduleNameExpr.text) {
							// Avoid `unprefixedNodeCoreModules.has` for every import
							usesUriStyleNodeCoreModules = false
						}
					}
				}
			} else if isModuleDeclaration(node) {
				if isAmbientModule(node) && (inAmbientModule || hasSyntacticModifier(node, ModifierFlagsAmbient) || file.isDeclarationFile) {
					(node.name.(Mutable[*Node])).parent = node
					nameText := getTextOfIdentifierOrLiteral(node.name)
					// Ambient module declarations can be interpreted as augmentations for some existing external modules.
					// This will happen in two cases:
					// - if current file is external module then module augmentation is a ambient module declaration defined in the top level scope
					// - if current file is not external module then module augmentation is an ambient module declaration with non-relative module name
					//   immediately nested in top level ambient module declaration .
					if isExternalModuleFile || (inAmbientModule && !isExternalModuleNameRelative(nameText)) {
						(moduleAugmentations || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: moduleAugmentations = [] */ TODO)).push(node.name)
					} else if !inAmbientModule {
						if file.isDeclarationFile {
							// for global .d.ts files record name of ambient module
							(ambientModules || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: ambientModules = [] */ TODO)).push(nameText)
						}
						// An AmbientExternalModuleDeclaration declares an external module.
						// This type of declaration is permitted only in the global module.
						// The StringLiteral must specify a top - level external module name.
						// Relative external module names are not permitted

						// NOTE: body of ambient module is always a module block, if it exists
						body := (node.AsModuleDeclaration()).body.AsModuleBlock()
						if body {
							for _, statement := range body.statements {
								collectModuleReferences(statement /*inAmbientModule*/, true)
							}
						}
					}
				}
			}
		}

		collectDynamicImportOrRequireOrJsDocImportCalls := func(file SourceFile) {
			r := /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /import|require/g */ TODO
			for r.exec(file.text) != /* TODO(TS-TO-GO) Node NullKeyword: null */ TODO {
				node := getNodeAtPosition(file, r.lastIndex)
				if isJavaScriptFile && isRequireCall(node /*requireStringLiteralLikeArgument*/, true) {
					setParentRecursive(node /*incremental*/, false)
					// we need parent data on imports before the program is fully bound, so we ensure it's set here
					imports = append(imports, node.arguments[0])
				} else if isImportCall(node) && node.arguments.length >= 1 && isStringLiteralLike(node.arguments[0]) {
					setParentRecursive(node /*incremental*/, false)
					// we need parent data on imports before the program is fully bound, so we ensure it's set here
					imports = append(imports, node.arguments[0])
				} else if isLiteralImportTypeNode(node) {
					setParentRecursive(node /*incremental*/, false)
					// we need parent data on imports before the program is fully bound, so we ensure it's set here
					imports = append(imports, node.argument.literal)
				} else if isJavaScriptFile && isJSDocImportTag(node) {
					moduleNameExpr := getExternalModuleName(node)
					if moduleNameExpr && isStringLiteral(moduleNameExpr) && moduleNameExpr.text {
						setParentRecursive(node /*incremental*/, false)
						imports = append(imports, moduleNameExpr)
					}
				}
			}
		}

		/** Returns a token if position is in [start-of-leading-trivia, end), includes JSDoc only in JS files */

		getNodeAtPosition := func(sourceFile SourceFile, position number) *Node {
			var current *Node = sourceFile
			getContainingChild := func(child *Node) *Node {
				if child.pos <= position && (position < child.end || (position == child.end && (child.kind == SyntaxKindEndOfFileToken))) {
					return child
				}
			}
			for true {
				child := isJavaScriptFile && hasJSDocNodes(current) && forEach(current.jsDoc, getContainingChild) || forEachChild(current, getContainingChild)
				if !child {
					return current
				}
				current = child
			}
		}

	}

	getLibFileFromReference := func(ref FileReference) *SourceFile {
		libFileName := getLibFileNameFromLibReference(ref)
		actualFileName := libFileName && resolvedLibReferences. /* ? */ get(libFileName). /* ? */ actual
		if actualFileName != nil {
			return getSourceFile(actualFileName)
		} else {
			return nil
		}
	}

	/** This should have similar behavior to 'processSourceFile' without diagnostics or mutation. */

	getSourceFileFromReference := func(referencingFile SourceFile, ref FileReference) *SourceFile {
		return getSourceFileFromReferenceWorker(resolveTripleslashReference(ref.fileName, referencingFile.fileName), getSourceFile)
	}

	getSourceFileFromReferenceWorker := func(fileName string, getSourceFile func(fileName string) *SourceFile, fail func(diagnostic DiagnosticMessage, argument []string), reason FileIncludeReason) *SourceFile {
		if hasExtension(fileName) {
			canonicalFileName := host.getCanonicalFileName(fileName)
			if !options.allowNonTsExtensions && !forEach(flatten(supportedExtensionsWithJsonIfResolveJsonModule), func(extension Extension) bool {
				return fileExtensionIs(canonicalFileName, extension)
			}) {
				if fail {
					if hasJSFileExtension(canonicalFileName) {
						fail(Diagnostics.File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option, fileName)
					} else {
						fail(Diagnostics.File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1, fileName, "'"+flatten(supportedExtensions).join("', '")+"'")
					}
				}
				return nil
			}

			sourceFile := getSourceFile(fileName)
			if fail {
				if !sourceFile {
					redirect := getProjectReferenceRedirect(fileName)
					if redirect {
						fail(Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, fileName)
					} else {
						fail(Diagnostics.File_0_not_found, fileName)
					}
				} else if isReferencedFile(reason) && canonicalFileName == host.getCanonicalFileName(getSourceFileByPath(reason.file).fileName) {
					fail(Diagnostics.A_file_cannot_have_a_reference_to_itself)
				}
			}
			return sourceFile
		} else {
			sourceFileNoExtension := options.allowNonTsExtensions && getSourceFile(fileName)
			if sourceFileNoExtension {
				return sourceFileNoExtension
			}

			if fail && options.allowNonTsExtensions {
				fail(Diagnostics.File_0_not_found, fileName)
				return nil
			}

			// Only try adding extensions from the first supported group (which should be .ts/.tsx/.d.ts)
			sourceFileWithAddedExtension := forEach(supportedExtensions[0], func(extension Extension) *SourceFile {
				return getSourceFile(fileName + extension)
			})
			if fail && !sourceFileWithAddedExtension {
				fail(Diagnostics.Could_not_resolve_the_path_0_with_the_extensions_Colon_1, fileName, "'"+flatten(supportedExtensions).join("', '")+"'")
			}
			return sourceFileWithAddedExtension
		}
	}

	/** This has side effects through `findSourceFile`. */

	processSourceFile := func(fileName string, isDefaultLib bool, ignoreNoDefaultLib bool, packageId *PackageId, reason FileIncludeReason) {
		getSourceFileFromReferenceWorker(fileName, func(fileName string) *SourceFile {
			return findSourceFile(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId)
		}, func(diagnostic DiagnosticMessage, args []string) {
			return addFilePreprocessingFileExplainingDiagnostic(nil, reason, diagnostic, args)
		}, reason)
	}

	processProjectReferenceFile := func(fileName string, reason ProjectReferenceFile) {
		return processSourceFile(fileName /*isDefaultLib*/, false /*ignoreNoDefaultLib*/, false /*packageId*/, nil, reason)
	}

	reportFileNamesDifferOnlyInCasingError := func(fileName string, existingFile SourceFile, reason FileIncludeReason) {
		hasExistingReasonToReportErrorOn := !isReferencedFile(reason) && some(fileReasons.get(existingFile.path), isReferencedFile)
		if hasExistingReasonToReportErrorOn {
			addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, Diagnostics.Already_included_file_name_0_differs_from_file_name_1_only_in_casing, []string{existingFile.fileName, fileName})
		} else {
			addFilePreprocessingFileExplainingDiagnostic(existingFile, reason, Diagnostics.File_name_0_differs_from_already_included_file_name_1_only_in_casing, []string{fileName, existingFile.fileName})
		}
	}

	createRedirectedSourceFile := func(redirectTarget SourceFile, unredirected SourceFile, fileName string, path Path, resolvedPath Path, originalFileName string, sourceFileOptions CreateSourceFileOptions) SourceFile {
		redirect := parseNodeFactory.createRedirectedSourceFile(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"redirectTarget": redirectTarget,
			"unredirected":   unredirected,
		})
		redirect.fileName = fileName
		redirect.path = path
		redirect.resolvedPath = resolvedPath
		redirect.originalFileName = originalFileName
		if sourceFileOptions.packageJsonLocations. /* ? */ length {
			redirect.packageJsonLocations = sourceFileOptions.packageJsonLocations
		} else {
			redirect.packageJsonLocations = nil
		}
		redirect.packageJsonScope = sourceFileOptions.packageJsonScope
		sourceFilesFoundSearchingNodeModules.set(path, currentNodeModulesDepth > 0)
		return redirect
	}

	// Get source file from normalized fileName
	findSourceFile := func(fileName string, isDefaultLib bool, ignoreNoDefaultLib bool, reason FileIncludeReason, packageId *PackageId) *SourceFile {
		tracing. /* ? */ push(tracing.Phase.Program, "findSourceFile", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"fileName":        fileName,
			"isDefaultLib":    isDefaultLib || nil,
			"fileIncludeKind": (FileIncludeKind /* as any */)[reason.kind],
		})
		result := findSourceFileWorker(fileName, isDefaultLib, ignoreNoDefaultLib, reason, packageId)
		tracing. /* ? */ pop()
		return result
	}

	getCreateSourceFileOptions := func(fileName string, moduleResolutionCache *ModuleResolutionCache, host CompilerHost, options CompilerOptions) CreateSourceFileOptions {
		// It's a _little odd_ that we can't set `impliedNodeFormat` until the program step - but it's the first and only time we have a resolution cache
		// and a freshly made source file node on hand at the same time, and we need both to set the field. Persisting the resolution cache all the way
		// to the check and emit steps would be bad - so we much prefer detecting and storing the format information on the source file node upfront.
		result := getImpliedNodeFormatForFileWorker(getNormalizedAbsolutePath(fileName, currentDirectory), moduleResolutionCache. /* ? */ getPackageJsonInfoCache(), host, options)
		languageVersion := getEmitScriptTarget(options)
		setExternalModuleIndicator := getSetExternalModuleIndicator(options)
		if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result */ TODO == "object" {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				/* TODO(TS-TO-GO) Node SpreadAssignment: ...result */
				"languageVersion":            languageVersion,
				"setExternalModuleIndicator": setExternalModuleIndicator,
				"jsDocParsingMode":           host.jsDocParsingMode,
			}
		} else {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"languageVersion":            languageVersion,
				"impliedNodeFormat":          result,
				"setExternalModuleIndicator": setExternalModuleIndicator,
				"jsDocParsingMode":           host.jsDocParsingMode,
			}
		}
	}

	findSourceFileWorker := func(fileName string, isDefaultLib bool, ignoreNoDefaultLib bool, reason FileIncludeReason, packageId *PackageId) *SourceFile {
		path := toPath(fileName)
		if useSourceOfProjectReferenceRedirect {
			source := getSourceOfProjectReferenceRedirect(path)
			// If preserveSymlinks is true, module resolution wont jump the symlink
			// but the resolved real path may be the .d.ts from project reference
			// Note:: Currently we try the real path only if the
			// file is from node_modules to avoid having to run real path on all file paths
			if !source && host.realpath && options.preserveSymlinks && isDeclarationFileName(fileName) && fileName.includes(nodeModulesPathPart) {
				realPath := toPath(host.realpath(fileName))
				if realPath != path {
					source = getSourceOfProjectReferenceRedirect(realPath)
				}
			}
			if source {
				var file *SourceFile
				if isString(source) {
					file = findSourceFile(source, isDefaultLib, ignoreNoDefaultLib, reason, packageId)
				} else {
					file = nil
				}
				if file {
					addFileToFilesByName(file, path, fileName /*redirectedPath*/, nil)
				}
				return file
			}
		}
		originalFileName := fileName
		if filesByName.has(path) {
			file := filesByName.get(path)
			addedReason := addFileIncludeReason(file || nil, reason /*checkExisting*/, true)
			// try to check if we've already seen this file but with a different casing in path
			// NOTE: this only makes sense for case-insensitive file systems, and only on files which are not redirected
			if file && addedReason && !(options.forceConsistentCasingInFileNames == false) {
				checkedName := file.fileName
				isRedirect := toPath(checkedName) != toPath(fileName)
				if isRedirect {
					fileName = getProjectReferenceRedirect(fileName) || fileName
				}
				// Check if it differs only in drive letters its ok to ignore that error:
				checkedAbsolutePath := getNormalizedAbsolutePathWithoutRoot(checkedName, currentDirectory)
				inputAbsolutePath := getNormalizedAbsolutePathWithoutRoot(fileName, currentDirectory)
				if checkedAbsolutePath != inputAbsolutePath {
					reportFileNamesDifferOnlyInCasingError(fileName, file, reason)
				}
			}

			// If the file was previously found via a node_modules search, but is now being processed as a root file,
			// then everything it sucks in may also be marked incorrectly, and needs to be checked again.
			if file && sourceFilesFoundSearchingNodeModules.get(file.path) && currentNodeModulesDepth == 0 {
				sourceFilesFoundSearchingNodeModules.set(file.path, false)
				if !options.noResolve {
					processReferencedFiles(file, isDefaultLib)
					processTypeReferenceDirectives(file)
				}
				if !options.noLib {
					processLibReferenceDirectives(file)
				}

				modulesWithElidedImports.set(file.path, false)
				processImportedModules(file)
			} else if file && modulesWithElidedImports.get(file.path) {
				if currentNodeModulesDepth < maxNodeModuleJsDepth {
					modulesWithElidedImports.set(file.path, false)
					processImportedModules(file)
				}
			}

			return file || nil
		}

		var redirectedPath *Path
		if !useSourceOfProjectReferenceRedirect {
			redirectProject := getProjectReferenceRedirectProject(fileName)
			if redirectProject {
				if redirectProject.commandLine.options.outFile {
					// Shouldnt create many to 1 mapping file in --out scenario
					return nil
				}
				redirect := getProjectReferenceOutputName(redirectProject, fileName)
				fileName = redirect
				// Once we start redirecting to a file, we can potentially come back to it
				// via a back-reference from another file in the .d.ts folder. If that happens we'll
				// end up trying to add it to the program *again* because we were tracking it via its
				// original (un-redirected) name. So we have to map both the original path and the redirected path
				// to the source file we're about to find/create
				redirectedPath = toPath(redirect)
			}
		}

		// We haven't looked for this file, do so now and cache result
		sourceFileOptions := getCreateSourceFileOptions(fileName, moduleResolutionCache, host, options)
		file := host.getSourceFile(fileName, sourceFileOptions, func(hostErrorMessage string) {
			return addFilePreprocessingFileExplainingDiagnostic(nil, reason, Diagnostics.Cannot_read_file_0_Colon_1, []string{fileName, hostErrorMessage})
		}, shouldCreateNewSourceFile)

		if packageId {
			packageIdKey := packageIdToString(packageId)
			fileFromPackageId := packageIdToSourceFile.get(packageIdKey)
			if fileFromPackageId {
				// Some other SourceFile already exists with this package name and version.
				// Instead of creating a duplicate, just redirect to the existing one.
				dupFile := createRedirectedSourceFile(fileFromPackageId, file, fileName, path, toPath(fileName), originalFileName, sourceFileOptions)
				redirectTargetsMap.add(fileFromPackageId.path, fileName)
				addFileToFilesByName(dupFile, path, fileName, redirectedPath)
				addFileIncludeReason(dupFile, reason /*checkExisting*/, false)
				sourceFileToPackageName.set(path, packageIdToPackageName(packageId))
				processingOtherFiles.push(dupFile)
				return dupFile
			} else if file {
				// This is the first source file to have this packageId.
				packageIdToSourceFile.set(packageIdKey, file)
				sourceFileToPackageName.set(path, packageIdToPackageName(packageId))
			}
		}
		addFileToFilesByName(file, path, fileName, redirectedPath)

		if file {
			sourceFilesFoundSearchingNodeModules.set(path, currentNodeModulesDepth > 0)
			file.fileName = fileName
			// Ensure that source file has same name as what we were looking for
			file.path = path
			file.resolvedPath = toPath(fileName)
			file.originalFileName = originalFileName
			if sourceFileOptions.packageJsonLocations. /* ? */ length {
				file.packageJsonLocations = sourceFileOptions.packageJsonLocations
			} else {
				file.packageJsonLocations = nil
			}
			file.packageJsonScope = sourceFileOptions.packageJsonScope
			addFileIncludeReason(file, reason /*checkExisting*/, false)

			if host.useCaseSensitiveFileNames() {
				pathLowerCase := toFileNameLowerCase(path)
				// for case-sensitive file systems check if we've already seen some file with similar filename ignoring case
				existingFile := filesByNameIgnoreCase.get(pathLowerCase)
				if existingFile {
					reportFileNamesDifferOnlyInCasingError(fileName, existingFile, reason)
				} else {
					filesByNameIgnoreCase.set(pathLowerCase, file)
				}
			}

			skipDefaultLib = skipDefaultLib || (file.hasNoDefaultLib && !ignoreNoDefaultLib)

			if !options.noResolve {
				processReferencedFiles(file, isDefaultLib)
				processTypeReferenceDirectives(file)
			}
			if !options.noLib {
				processLibReferenceDirectives(file)
			}

			// always process imported modules to record module name resolutions
			processImportedModules(file)

			if isDefaultLib {
				processingDefaultLibFiles.push(file)
			} else {
				processingOtherFiles.push(file)
			}
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: filesWithReferencesProcessed ??= new Set() */ TODO).add(file.path)
		}
		return file
	}

	addFileIncludeReason := func(file *SourceFile, reason FileIncludeReason, checkExisting bool) bool {
		if file && (!checkExisting || !isReferencedFile(reason) || !filesWithReferencesProcessed. /* ? */ has(reason.file)) {
			fileReasons.add(file.path, reason)
			return true
		}
		return false
	}

	addFileToFilesByName := func(file *SourceFile, path Path, fileName string, redirectedPath *Path) {
		if redirectedPath {
			updateFilesByNameMap(fileName, redirectedPath, file)
			updateFilesByNameMap(fileName, path, file || false)
		} else {
			updateFilesByNameMap(fileName, path, file)
		}
	}

	updateFilesByNameMap := func(fileName string, path Path, file /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | false | undefined */ any) {
		filesByName.set(path, file)
		if file != nil {
			missingFileNames.delete(path)
		} else {
			missingFileNames.set(path, fileName)
		}
	}

	getProjectReferenceRedirect := func(fileName string) *string {
		referencedProject := getProjectReferenceRedirectProject(fileName)
		return referencedProject && getProjectReferenceOutputName(referencedProject, fileName)
	}

	getProjectReferenceRedirectProject := func(fileName string) *ResolvedProjectReference {
		// Ignore dts or any json files
		if !resolvedProjectReferences || !resolvedProjectReferences.length || isDeclarationFileName(fileName) || fileExtensionIs(fileName, ExtensionJson) {
			return nil
		}

		// If this file is produced by a referenced project, we need to rewrite it to
		// look in the output folder of the referenced project rather than the input
		return getResolvedProjectReferenceToRedirect(fileName)
	}

	getProjectReferenceOutputName := func(referencedProject ResolvedProjectReference, fileName string) string {
		out := referencedProject.commandLine.options.outFile
		if out {
			return changeExtension(out, ExtensionDts)
		} else {
			return getOutputDeclarationFileName(fileName, referencedProject.commandLine, !host.useCaseSensitiveFileNames())
		}
	}

	/**
	 * Get the referenced project if the file is input file from that reference project
	 */

	getResolvedProjectReferenceToRedirect := func(fileName string) *ResolvedProjectReference {
		if mapFromFileToProjectReferenceRedirects == nil {
			mapFromFileToProjectReferenceRedirects = NewMap()
			forEachResolvedProjectReference(func(referencedProject ResolvedProjectReference) {
				// not input file from the referenced project, ignore
				if toPath(options.configFilePath) != referencedProject.sourceFile.path {
					referencedProject.commandLine.fileNames.forEach(func(f string) Map[Path, Path] {
						return mapFromFileToProjectReferenceRedirects.set(toPath(f), referencedProject.sourceFile.path)
					})
				}
			})
		}

		referencedProjectPath := mapFromFileToProjectReferenceRedirects.get(toPath(fileName))
		return referencedProjectPath && getResolvedProjectReferenceByPath(referencedProjectPath)
	}

	forEachResolvedProjectReference := func(cb func(resolvedProjectReference ResolvedProjectReference) *T) *T {
		return ts_forEachResolvedProjectReference(resolvedProjectReferences, cb)
	}

	getSourceOfProjectReferenceRedirect := func(path Path) *SourceOfProjectReferenceRedirect {
		if !isDeclarationFileName(path) {
			return nil
		}
		if mapFromToProjectReferenceRedirectSource == nil {
			mapFromToProjectReferenceRedirectSource = NewMap()
			forEachResolvedProjectReference(func(resolvedRef ResolvedProjectReference) {
				out := resolvedRef.commandLine.options.outFile
				if out {
					// Dont know which source file it means so return true?
					outputDts := changeExtension(out, ExtensionDts)
					mapFromToProjectReferenceRedirectSource.set(toPath(outputDts), true)
				} else {
					getCommonSourceDirectory := memoize(func() string {
						return getCommonSourceDirectoryOfConfig(resolvedRef.commandLine, !host.useCaseSensitiveFileNames())
					})
					forEach(resolvedRef.commandLine.fileNames, func(fileName string) {
						if !isDeclarationFileName(fileName) && !fileExtensionIs(fileName, ExtensionJson) {
							outputDts := getOutputDeclarationFileName(fileName, resolvedRef.commandLine, !host.useCaseSensitiveFileNames(), getCommonSourceDirectory)
							mapFromToProjectReferenceRedirectSource.set(toPath(outputDts), fileName)
						}
					})
				}
			})
		}
		return mapFromToProjectReferenceRedirectSource.get(path)
	}

	isSourceOfProjectReferenceRedirect := func(fileName string) bool {
		return useSourceOfProjectReferenceRedirect && !!getResolvedProjectReferenceToRedirect(fileName)
	}

	getResolvedProjectReferenceByPath := func(projectReferencePath Path) *ResolvedProjectReference {
		if !projectReferenceRedirects {
			return nil
		}

		return projectReferenceRedirects.get(projectReferencePath) || nil
	}

	processReferencedFiles := func(file SourceFile, isDefaultLib bool) {
		forEach(file.referencedFiles, func(ref FileReference, index number) {
			processSourceFile(resolveTripleslashReference(ref.fileName, file.fileName), isDefaultLib, false, nil, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"kind":  FileIncludeKindReferenceFile,
				"file":  file.path,
				"index": index,
			})
		})
	}

	processTypeReferenceDirectives := func(file SourceFile) {
		typeDirectives := file.typeReferenceDirectives
		if !typeDirectives.length {
			return
		}

		resolutions := resolvedTypeReferenceDirectiveNamesProcessing. /* ? */ get(file.path) || resolveTypeReferenceDirectiveNamesReusingOldState(typeDirectives, file)
		resolutionsInFile := createModeAwareCache()
		( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: resolvedTypeReferenceDirectiveNames ??= new Map() */ TODO).set(file.path, resolutionsInFile)
		for index := 0; index < typeDirectives.length; index++ {
			ref := file.typeReferenceDirectives[index]
			resolvedTypeReferenceDirective := resolutions[index]
			// store resolved type directive on the file
			fileName := ref.fileName
			mode := getModeForTypeReferenceDirectiveInFile(ref, file)
			resolutionsInFile.set(fileName, mode, resolvedTypeReferenceDirective)
			processTypeReferenceDirective(fileName, mode, resolvedTypeReferenceDirective, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"kind":  FileIncludeKindTypeReferenceDirective,
				"file":  file.path,
				"index": index,
			})
		}
	}

	getCompilerOptionsForFile := func(file SourceFile) CompilerOptions {
		return getRedirectReferenceForResolution(file). /* ? */ commandLine.options || options
	}

	processTypeReferenceDirective := func(typeReferenceDirective string, mode ResolutionMode, resolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations, reason FileIncludeReason) {
		tracing. /* ? */ push(tracing.Phase.Program, "processTypeReferenceDirective", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"directive":   typeReferenceDirective,
			"hasResolved": !!resolution.resolvedTypeReferenceDirective,
			"refKind":     reason.kind,
			"refPath":     ifElse(isReferencedFile(reason), reason.file, nil),
		})
		processTypeReferenceDirectiveWorker(typeReferenceDirective, mode, resolution, reason)
		tracing. /* ? */ pop()
	}

	processTypeReferenceDirectiveWorker := func(typeReferenceDirective string, mode ResolutionMode, resolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations, reason FileIncludeReason) {
		addResolutionDiagnostics(resolution)
		TODO_IDENTIFIER := resolution
		if resolvedTypeReferenceDirective {
			if resolvedTypeReferenceDirective.isExternalLibraryImport {
				currentNodeModulesDepth++
			}

			// resolved from the primary path
			processSourceFile(resolvedTypeReferenceDirective.resolvedFileName /*isDefaultLib*/, false /*ignoreNoDefaultLib*/, false, resolvedTypeReferenceDirective.packageId, reason)
			// TODO: GH#18217

			if resolvedTypeReferenceDirective.isExternalLibraryImport {
				currentNodeModulesDepth--
			}
		} else {
			addFilePreprocessingFileExplainingDiagnostic(nil, reason, Diagnostics.Cannot_find_type_definition_file_for_0, []string{typeReferenceDirective})
		}
	}

	pathForLibFile := func(libFileName string) string {
		existing := resolvedLibReferences. /* ? */ get(libFileName)
		if existing {
			return existing.actual
		}
		result := pathForLibFileWorker(libFileName)
		( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: resolvedLibReferences ??= new Map() */ TODO).set(libFileName, result)
		return result.actual
	}

	pathForLibFileWorker := func(libFileName string) LibResolution {
		existing := resolvedLibProcessing. /* ? */ get(libFileName)
		if existing {
			return existing
		}

		if structureIsReused != StructureIsReusedNot && oldProgram && !hasInvalidatedLibResolutions(libFileName) {
			oldResolution := oldProgram.resolvedLibReferences. /* ? */ get(libFileName)
			if oldResolution {
				if oldResolution.resolution && isTraceEnabled(options, host) {
					libraryName := getLibraryNameFromLibFileName(libFileName)
					resolveFrom := getInferredLibraryNameResolveFrom(options, currentDirectory, libFileName)
					trace(host, ifElse(oldResolution.resolution.resolvedModule, ifElse(oldResolution.resolution.resolvedModule.packageId, Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3, Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2), Diagnostics.Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved), libraryName, getNormalizedAbsolutePath(resolveFrom, currentDirectory), oldResolution.resolution.resolvedModule. /* ? */ resolvedFileName, oldResolution.resolution.resolvedModule. /* ? */ packageId && packageIdToString(oldResolution.resolution.resolvedModule.packageId))
				}
				( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: resolvedLibProcessing ??= new Map() */ TODO).set(libFileName, oldResolution)
				return oldResolution
			}
		}

		libraryName := getLibraryNameFromLibFileName(libFileName)
		resolveFrom := getInferredLibraryNameResolveFrom(options, currentDirectory, libFileName)
		tracing. /* ? */ push(tracing.Phase.Program, "resolveLibrary", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"resolveFrom": resolveFrom,
		})
		performance.mark("beforeResolveLibrary")
		resolution := actualResolveLibrary(libraryName, resolveFrom, options, libFileName)
		performance.mark("afterResolveLibrary")
		performance.measure("ResolveLibrary", "beforeResolveLibrary", "afterResolveLibrary")
		tracing. /* ? */ pop()
		var result LibResolution = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"resolution": resolution,
			"actual":     ifElse(resolution.resolvedModule, resolution.resolvedModule.resolvedFileName, combinePaths(defaultLibraryPath, libFileName)),
		}
		( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: resolvedLibProcessing ??= new Map() */ TODO).set(libFileName, result)
		return result
	}

	processLibReferenceDirectives := func(file SourceFile) {
		forEach(file.libReferenceDirectives, func(libReference FileReference, index number) {
			libFileName := getLibFileNameFromLibReference(libReference)
			if libFileName {
				// we ignore any 'no-default-lib' reference set on this file.
				processRootFile(pathForLibFile(libFileName) /*isDefaultLib*/, true /*ignoreNoDefaultLib*/, true, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"kind":  FileIncludeKindLibReferenceDirective,
					"file":  file.path,
					"index": index,
				})
			} else {
				( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: fileProcessingDiagnostics ||= [] */ TODO).push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"kind": FilePreprocessingDiagnosticsKindFilePreprocessingLibReferenceDiagnostic,
					"reason": map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"kind":  FileIncludeKindLibReferenceDirective,
						"file":  file.path,
						"index": index,
					},
				})
			}
		})
	}

	getCanonicalFileName := func(fileName string) string {
		return host.getCanonicalFileName(fileName)
	}

	processImportedModules := func(file SourceFile) {
		collectExternalModuleReferences(file)
		if file.imports.length || file.moduleAugmentations.length {
			// Because global augmentation doesn't have string literal name, we can check for global augmentation as such.
			moduleNames := getModuleNames(file)
			resolutions := resolvedModulesProcessing. /* ? */ get(file.path) || resolveModuleNamesReusingOldState(moduleNames, file)
			Debug.assert(resolutions.length == moduleNames.length)
			optionsForFile := getCompilerOptionsForFile(file)
			resolutionsInFile := createModeAwareCache()
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: resolvedModules ??= new Map() */ TODO).set(file.path, resolutionsInFile)
			for index := 0; index < moduleNames.length; index++ {
				resolution := resolutions[index].resolvedModule
				moduleName := moduleNames[index].text
				mode := getModeForUsageLocationWorker(file, moduleNames[index], optionsForFile)
				resolutionsInFile.set(moduleName, mode, resolutions[index])
				addResolutionDiagnosticsFromResolutionOrCache(file, moduleName, resolutions[index], mode)

				if !resolution {
					continue
				}

				isFromNodeModulesSearch := resolution.isExternalLibraryImport
				// If this is js file source of project reference, dont treat it as js file but as d.ts
				isJsFile := !resolutionExtensionIsTSOrJson(resolution.extension) && !getProjectReferenceRedirectProject(resolution.resolvedFileName)
				isJsFileFromNodeModules := isFromNodeModulesSearch && isJsFile && (!resolution.originalPath || pathContainsNodeModules(resolution.resolvedFileName))
				resolvedFileName := resolution.resolvedFileName

				if isFromNodeModulesSearch {
					currentNodeModulesDepth++
				}

				// add file to program only if:
				// - resolution was successful
				// - noResolve is falsy
				// - module name comes from the list of imports
				// - it's not a top level JavaScript module that exceeded the search max
				elideImport := isJsFileFromNodeModules && currentNodeModulesDepth > maxNodeModuleJsDepth
				// Don't add the file if it has a bad extension (e.g. 'tsx' if we don't have '--allowJs')
				// This may still end up being an untyped module -- the file won't be included but imports will be allowed.
				shouldAddFile := resolvedFileName && !getResolutionDiagnostic(optionsForFile, resolution, file) && !optionsForFile.noResolve && index < file.imports.length && !elideImport && !(isJsFile && !getAllowJSCompilerOption(optionsForFile)) && (isInJSFile(file.imports[index]) || !(file.imports[index].flags & NodeFlagsJSDoc))

				if elideImport {
					modulesWithElidedImports.set(file.path, true)
				} else if shouldAddFile {
					findSourceFile(resolvedFileName, false, false, map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"kind":  FileIncludeKindImport,
						"file":  file.path,
						"index": index,
					}, resolution.packageId)
				}

				if isFromNodeModulesSearch {
					currentNodeModulesDepth--
				}
			}
		}
	}

	checkSourceFilesBelongToPath := func(sourceFiles []SourceFile, rootDirectory string) bool {
		allFilesBelongToPath := true
		absoluteRootDirectoryPath := host.getCanonicalFileName(getNormalizedAbsolutePath(rootDirectory, currentDirectory))
		for _, sourceFile := range sourceFiles {
			if !sourceFile.isDeclarationFile {
				absoluteSourceFilePath := host.getCanonicalFileName(getNormalizedAbsolutePath(sourceFile.fileName, currentDirectory))
				if absoluteSourceFilePath.indexOf(absoluteRootDirectoryPath) != 0 {
					addLazyProgramDiagnosticExplainingFile(sourceFile, Diagnostics.File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files, []string{sourceFile.fileName, rootDirectory})
					allFilesBelongToPath = false
				}
			}
		}

		return allFilesBelongToPath
	}

	parseProjectReferenceConfigFile := func(ref ProjectReference) *ResolvedProjectReference {
		if !projectReferenceRedirects {
			projectReferenceRedirects = NewMap()
		}

		// The actual filename (i.e. add "/tsconfig.json" if necessary)
		refPath := resolveProjectReferencePath(ref)
		sourceFilePath := toPath(refPath)
		fromCache := projectReferenceRedirects.get(sourceFilePath)
		if fromCache != nil {
			return fromCache || nil
		}

		var commandLine *ParsedCommandLine
		var sourceFile *JsonSourceFile
		if host.getParsedCommandLine {
			commandLine = host.getParsedCommandLine(refPath)
			if !commandLine {
				addFileToFilesByName(nil, sourceFilePath, refPath /*redirectedPath*/, nil)
				projectReferenceRedirects.set(sourceFilePath, false)
				return nil
			}
			sourceFile = Debug.checkDefined(commandLine.options.configFile)
			Debug.assert(!sourceFile.path || sourceFile.path == sourceFilePath)
			addFileToFilesByName(sourceFile, sourceFilePath, refPath /*redirectedPath*/, nil)
		} else {
			// An absolute path pointing to the containing directory of the config file
			basePath := getNormalizedAbsolutePath(getDirectoryPath(refPath), currentDirectory)
			sourceFile = host.getSourceFile(refPath, ScriptTargetJSON) /* as JsonSourceFile | undefined */
			addFileToFilesByName(sourceFile, sourceFilePath, refPath /*redirectedPath*/, nil)
			if sourceFile == nil {
				projectReferenceRedirects.set(sourceFilePath, false)
				return nil
			}
			commandLine = parseJsonSourceFileConfigFileContent(sourceFile, configParsingHost, basePath /*existingOptions*/, nil, refPath)
		}
		sourceFile.fileName = refPath
		sourceFile.path = sourceFilePath
		sourceFile.resolvedPath = sourceFilePath
		sourceFile.originalFileName = refPath

		var resolvedRef ResolvedProjectReference = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"commandLine": commandLine,
			"sourceFile":  sourceFile,
		}
		projectReferenceRedirects.set(sourceFilePath, resolvedRef)
		if commandLine.projectReferences {
			resolvedRef.references = commandLine.projectReferences.map_(parseProjectReferenceConfigFile)
		}
		return resolvedRef
	}

	verifyCompilerOptions := func() {
		if options.strictPropertyInitialization && !getStrictOptionValue(options, "strictNullChecks") {
			createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "strictPropertyInitialization", "strictNullChecks")
		}
		if options.exactOptionalPropertyTypes && !getStrictOptionValue(options, "strictNullChecks") {
			createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "exactOptionalPropertyTypes", "strictNullChecks")
		}

		if options.isolatedModules || options.verbatimModuleSyntax {
			if options.outFile {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_with_option_1, "outFile", ifElse(options.verbatimModuleSyntax, "verbatimModuleSyntax", "isolatedModules"))
			}
		}

		if options.isolatedDeclarations {
			if getAllowJSCompilerOption(options) {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_with_option_1, "allowJs", "isolatedDeclarations")
			}
			if !getEmitDeclarations(options) {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "isolatedDeclarations", "declaration", "composite")
			}
		}

		if options.inlineSourceMap {
			if options.sourceMap {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_with_option_1, "sourceMap", "inlineSourceMap")
			}
			if options.mapRoot {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_with_option_1, "mapRoot", "inlineSourceMap")
			}
		}

		if options.composite {
			if options.declaration == false {
				createDiagnosticForOptionName(Diagnostics.Composite_projects_may_not_disable_declaration_emit, "declaration")
			}
			if options.incremental == false {
				createDiagnosticForOptionName(Diagnostics.Composite_projects_may_not_disable_incremental_compilation, "declaration")
			}
		}

		outputFile := options.outFile
		if !options.tsBuildInfoFile && options.incremental && !outputFile && !options.configFilePath {
			programDiagnostics.add(createCompilerDiagnostic(Diagnostics.Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified))
		}

		verifyDeprecatedCompilerOptions()
		verifyProjectReferences()

		// List of collected files is complete; validate exhautiveness if this is a project with a file list
		if options.composite {
			rootPaths := NewSet(rootNames.map_(toPath))
			for _, file := range files {
				// Ignore file that is not emitted
				if sourceFileMayBeEmitted(file, program) && !rootPaths.has(file.path) {
					addLazyProgramDiagnosticExplainingFile(file, Diagnostics.File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern, []string{file.fileName, options.configFilePath || ""})
				}
			}
		}

		if options.paths {
			/* TODO(TS-TO-GO) Node ForInStatement: for (const key in options.paths) { if (!hasProperty(options.paths, key)) { continue; } if (!hasZeroOrOneAsteriskCharacter(key)) { createDiagnosticForOptionPaths(/*onKey* / true, key, Diagnostics.Pattern_0_can_have_at_most_one_Asterisk_character, key); } if (isArray(options.paths[key])) { const len = options.paths[key].length; if (len === 0) { createDiagnosticForOptionPaths(/*onKey* / false, key, Diagnostics.Substitutions_for_pattern_0_shouldn_t_be_an_empty_array, key); } for (let i = 0; i < len; i++) { const subst = options.paths[key][i]; const typeOfSubst = typeof subst; if (typeOfSubst === "string") { if (!hasZeroOrOneAsteriskCharacter(subst)) { createDiagnosticForOptionPathKeyValue(key, i, Diagnostics.Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character, subst, key); } if (!options.baseUrl && !pathIsRelative(subst) && !pathIsAbsolute(subst)) { createDiagnosticForOptionPathKeyValue(key, i, Diagnostics.Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash); } } else { createDiagnosticForOptionPathKeyValue(key, i, Diagnostics.Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2, subst, key, typeOfSubst); } } } else { createDiagnosticForOptionPaths(/*onKey* / false, key, Diagnostics.Substitutions_for_pattern_0_should_be_an_array, key); } } */
		}

		if !options.sourceMap && !options.inlineSourceMap {
			if options.inlineSources {
				createDiagnosticForOptionName(Diagnostics.Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided, "inlineSources")
			}
			if options.sourceRoot {
				createDiagnosticForOptionName(Diagnostics.Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided, "sourceRoot")
			}
		}

		if options.mapRoot && !(options.sourceMap || options.declarationMap) {
			// Error to specify --mapRoot without --sourcemap
			createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "mapRoot", "sourceMap", "declarationMap")
		}

		if options.declarationDir {
			if !getEmitDeclarations(options) {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "declarationDir", "declaration", "composite")
			}
			if outputFile {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_with_option_1, "declarationDir", "outFile")
			}
		}

		if options.declarationMap && !getEmitDeclarations(options) {
			createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "declarationMap", "declaration", "composite")
		}

		if options.lib && options.noLib {
			createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_with_option_1, "lib", "noLib")
		}

		languageVersion := getEmitScriptTarget(options)

		firstNonAmbientExternalModuleSourceFile := find(files, func(f SourceFile) bool {
			return isExternalModule(f) && !f.isDeclarationFile
		})
		if options.isolatedModules || options.verbatimModuleSyntax {
			if options.module == ModuleKindNone && languageVersion < ScriptTargetES2015 && options.isolatedModules {
				createDiagnosticForOptionName(Diagnostics.Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher, "isolatedModules", "target")
			}

			if options.preserveConstEnums == false {
				createDiagnosticForOptionName(Diagnostics.Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled, ifElse(options.verbatimModuleSyntax, "verbatimModuleSyntax", "isolatedModules"), "preserveConstEnums")
			}
		} else if firstNonAmbientExternalModuleSourceFile && languageVersion < ScriptTargetES2015 && options.module == ModuleKindNone {
			// We cannot use createDiagnosticFromNode because nodes do not have parents yet
			span := getErrorSpanForNode(firstNonAmbientExternalModuleSourceFile, ifElse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof firstNonAmbientExternalModuleSourceFile.externalModuleIndicator */ TODO == "boolean", firstNonAmbientExternalModuleSourceFile, firstNonAmbientExternalModuleSourceFile.externalModuleIndicator))
			programDiagnostics.add(createFileDiagnostic(firstNonAmbientExternalModuleSourceFile, span.start, span.length, Diagnostics.Cannot_use_imports_exports_or_module_augmentations_when_module_is_none))
		}

		// Cannot specify module gen that isn't amd or system with --out
		if outputFile && !options.emitDeclarationOnly {
			if options.module && !(options.module == ModuleKindAMD || options.module == ModuleKindSystem) {
				createDiagnosticForOptionName(Diagnostics.Only_amd_and_system_modules_are_supported_alongside_0, "outFile", "module")
			} else if options.module == nil && firstNonAmbientExternalModuleSourceFile {
				span := getErrorSpanForNode(firstNonAmbientExternalModuleSourceFile, ifElse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof firstNonAmbientExternalModuleSourceFile.externalModuleIndicator */ TODO == "boolean", firstNonAmbientExternalModuleSourceFile, firstNonAmbientExternalModuleSourceFile.externalModuleIndicator))
				programDiagnostics.add(createFileDiagnostic(firstNonAmbientExternalModuleSourceFile, span.start, span.length, Diagnostics.Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system, "outFile"))
			}
		}

		if getResolveJsonModule(options) {
			if getEmitModuleResolutionKind(options) == ModuleResolutionKindClassic {
				createDiagnosticForOptionName(Diagnostics.Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic, "resolveJsonModule")
			} else if !hasJsonModuleEmitEnabled(options) {
				createDiagnosticForOptionName(Diagnostics.Option_resolveJsonModule_cannot_be_specified_when_module_is_set_to_none_system_or_umd, "resolveJsonModule", "module")
			}
		}

		// there has to be common source directory if user specified --outdir || --rootDir || --sourceRoot
		// if user specified --mapRoot, there needs to be common source directory if there would be multiple files being emitted
		if options.outDir || options.rootDir || options.sourceRoot || options.mapRoot || (getEmitDeclarations(options) && options.declarationDir) {
			// Precalculate and cache the common source directory
			dir := getCommonSourceDirectory()

			// If we failed to find a good common directory, but outDir is specified and at least one of our files is on a windows drive/URL/other resource, add a failure
			if options.outDir && dir == "" && files.some(func(file SourceFile) bool {
				return getRootLength(file.fileName) > 1
			}) {
				createDiagnosticForOptionName(Diagnostics.Cannot_find_the_common_subdirectory_path_for_the_input_files, "outDir")
			}
		}

		if options.checkJs && !getAllowJSCompilerOption(options) {
			createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "checkJs", "allowJs")
		}

		if options.emitDeclarationOnly {
			if !getEmitDeclarations(options) {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1_or_option_2, "emitDeclarationOnly", "declaration", "composite")
			}
		}

		if options.emitDecoratorMetadata && !options.experimentalDecorators {
			createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "emitDecoratorMetadata", "experimentalDecorators")
		}

		if options.jsxFactory {
			if options.reactNamespace {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_with_option_1, "reactNamespace", "jsxFactory")
			}
			if options.jsx == JsxEmitReactJSX || options.jsx == JsxEmitReactJSXDev {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxFactory", inverseJsxOptionMap.get(""+options.jsx))
			}
			if !parseIsolatedEntityName(options.jsxFactory, languageVersion) {
				createOptionValueDiagnostic("jsxFactory", Diagnostics.Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name, options.jsxFactory)
			}
		} else if options.reactNamespace && !isIdentifierText(options.reactNamespace, languageVersion) {
			createOptionValueDiagnostic("reactNamespace", Diagnostics.Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier, options.reactNamespace)
		}

		if options.jsxFragmentFactory {
			if !options.jsxFactory {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_without_specifying_option_1, "jsxFragmentFactory", "jsxFactory")
			}
			if options.jsx == JsxEmitReactJSX || options.jsx == JsxEmitReactJSXDev {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxFragmentFactory", inverseJsxOptionMap.get(""+options.jsx))
			}
			if !parseIsolatedEntityName(options.jsxFragmentFactory, languageVersion) {
				createOptionValueDiagnostic("jsxFragmentFactory", Diagnostics.Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name, options.jsxFragmentFactory)
			}
		}

		if options.reactNamespace {
			if options.jsx == JsxEmitReactJSX || options.jsx == JsxEmitReactJSXDev {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "reactNamespace", inverseJsxOptionMap.get(""+options.jsx))
			}
		}

		if options.jsxImportSource {
			if options.jsx == JsxEmitReact {
				createDiagnosticForOptionName(Diagnostics.Option_0_cannot_be_specified_when_option_jsx_is_1, "jsxImportSource", inverseJsxOptionMap.get(""+options.jsx))
			}
		}

		moduleKind := getEmitModuleKind(options)
		if options.verbatimModuleSyntax {
			if moduleKind == ModuleKindAMD || moduleKind == ModuleKindUMD || moduleKind == ModuleKindSystem {
				createDiagnosticForOptionName(Diagnostics.Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System, "verbatimModuleSyntax")
			}
		}

		if options.allowImportingTsExtensions && !(options.noEmit || options.emitDeclarationOnly) {
			createOptionValueDiagnostic("allowImportingTsExtensions", Diagnostics.Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set)
		}

		moduleResolution := getEmitModuleResolutionKind(options)
		if options.resolvePackageJsonExports && !moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution) {
			createDiagnosticForOptionName(Diagnostics.Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler, "resolvePackageJsonExports")
		}
		if options.resolvePackageJsonImports && !moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution) {
			createDiagnosticForOptionName(Diagnostics.Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler, "resolvePackageJsonImports")
		}
		if options.customConditions && !moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution) {
			createDiagnosticForOptionName(Diagnostics.Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler, "customConditions")
		}

		if moduleResolution == ModuleResolutionKindBundler && !emitModuleKindIsNonNodeESM(moduleKind) && moduleKind != ModuleKindPreserve {
			createOptionValueDiagnostic("moduleResolution", Diagnostics.Option_0_can_only_be_used_when_module_is_set_to_preserve_or_to_es2015_or_later, "bundler")
		}

		if ModuleKind[moduleKind] && (ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext) && !(ModuleResolutionKindNode16 <= moduleResolution && moduleResolution <= ModuleResolutionKindNodeNext) {
			moduleKindName := ModuleKind[moduleKind]
			createOptionValueDiagnostic("moduleResolution", Diagnostics.Option_moduleResolution_must_be_set_to_0_or_left_unspecified_when_option_module_is_set_to_1, moduleKindName, moduleKindName)
		} else if ModuleResolutionKind[moduleResolution] && (ModuleResolutionKindNode16 <= moduleResolution && moduleResolution <= ModuleResolutionKindNodeNext) && !(ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext) {
			moduleResolutionName := ModuleResolutionKind[moduleResolution]
			createOptionValueDiagnostic("module", Diagnostics.Option_module_must_be_set_to_0_when_option_moduleResolution_is_set_to_1, moduleResolutionName, moduleResolutionName)
		}

		// If the emit is enabled make sure that every output file is unique and not overwriting any of the input files
		if !options.noEmit && !options.suppressOutputPathCheck {
			emitHost := getEmitHost()
			emitFilesSeen := NewSet[string]()
			forEachEmittedFile(emitHost, func(emitFileNames EmitFileNames) {
				if !options.emitDeclarationOnly {
					verifyEmitFilePath(emitFileNames.jsFilePath, emitFilesSeen)
				}
				verifyEmitFilePath(emitFileNames.declarationFilePath, emitFilesSeen)
			})
		}

		// Verify that all the emit files are unique and don't overwrite input files
		verifyEmitFilePath := func(emitFileName *string, emitFilesSeen Set[string]) {
			if emitFileName {
				emitFilePath := toPath(emitFileName)
				// Report error if the output overwrites input file
				if filesByName.has(emitFilePath) {
					var chain *DiagnosticMessageChain
					if !options.configFilePath {
						// The program is from either an inferred project or an external project
						chain = chainDiagnosticMessages(nil, Diagnostics.Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig)
					}
					chain = chainDiagnosticMessages(chain, Diagnostics.Cannot_write_file_0_because_it_would_overwrite_input_file, emitFileName)
					blockEmittingOfFile(emitFileName, createCompilerDiagnosticFromMessageChain(chain))
				}

				var emitFileKey string
				if !host.useCaseSensitiveFileNames() {
					emitFileKey = toFileNameLowerCase(emitFilePath)
				} else {
					emitFileKey = emitFilePath
				}
				// Report error if multiple files write into same file
				if emitFilesSeen.has(emitFileKey) {
					// Already seen the same emit file - report error
					blockEmittingOfFile(emitFileName, createCompilerDiagnostic(Diagnostics.Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files, emitFileName))
				} else {
					emitFilesSeen.add(emitFileKey)
				}
			}
		}

	}

	getIgnoreDeprecationsVersion := func() Version {
		ignoreDeprecations := options.ignoreDeprecations
		if ignoreDeprecations {
			// While we could do Version.tryParse here to support any version,
			// for now, only allow "5.0". We aren't planning on deprecating anything
			// until 6.0.
			if ignoreDeprecations == "5.0" {
				return NewVersion(ignoreDeprecations)
			}
			reportInvalidIgnoreDeprecations()
		}
		return Version.zero
	}

	checkDeprecations := func(deprecatedIn string, removedIn string, createDiagnostic func(name string, value *string, useInstead *string, message DiagnosticMessage, args DiagnosticArguments), fn func(createDeprecatedDiagnostic func(name string, value string, useInstead string))) {
		deprecatedInVersion := NewVersion(deprecatedIn)
		removedInVersion := NewVersion(removedIn)
		typescriptVersion := NewVersion(typeScriptVersion || versionMajorMinor)
		ignoreDeprecationsVersion := getIgnoreDeprecationsVersion()

		mustBeRemoved := !(removedInVersion.compareTo(typescriptVersion) == ComparisonGreaterThan)
		canBeSilenced := !mustBeRemoved && ignoreDeprecationsVersion.compareTo(deprecatedInVersion) == ComparisonLessThan

		if mustBeRemoved || canBeSilenced {
			fn(func(name string, value *string, useInstead *string) {
				if mustBeRemoved {
					if value == nil {
						createDiagnostic(name, value, useInstead, Diagnostics.Option_0_has_been_removed_Please_remove_it_from_your_configuration, name)
					} else {
						createDiagnostic(name, value, useInstead, Diagnostics.Option_0_1_has_been_removed_Please_remove_it_from_your_configuration, name, value)
					}
				} else {
					if value == nil {
						createDiagnostic(name, value, useInstead, Diagnostics.Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprecations_Colon_2_to_silence_this_error, name, removedIn, deprecatedIn)
					} else {
						createDiagnostic(name, value, useInstead, Diagnostics.Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDeprecations_Colon_3_to_silence_this_error, name, value, removedIn, deprecatedIn)
					}
				}
			})
		}
	}

	verifyDeprecatedCompilerOptions := func() {
		createDiagnostic := func(name string, value *string, useInstead *string, message DiagnosticMessage, args DiagnosticArguments) {
			if useInstead {
				details := chainDiagnosticMessages(nil, Diagnostics.Use_0_instead, useInstead)
				chain := chainDiagnosticMessages(details, message, args...)
				createDiagnosticForOption(!value, name /*option2*/, nil, chain)
			} else {
				createDiagnosticForOption(!value, name /*option2*/, nil, message, args...)
			}
		}

		checkDeprecations("5.0", "5.5", createDiagnostic, func(createDeprecatedDiagnostic /* TODO(TS-TO-GO) inferred type (name: string, value?: string, useInstead?: string) => void */ any) {
			if options.target == ScriptTargetES3 {
				createDeprecatedDiagnostic("target", "ES3")
			}
			if options.noImplicitUseStrict {
				createDeprecatedDiagnostic("noImplicitUseStrict")
			}
			if options.keyofStringsOnly {
				createDeprecatedDiagnostic("keyofStringsOnly")
			}
			if options.suppressExcessPropertyErrors {
				createDeprecatedDiagnostic("suppressExcessPropertyErrors")
			}
			if options.suppressImplicitAnyIndexErrors {
				createDeprecatedDiagnostic("suppressImplicitAnyIndexErrors")
			}
			if options.noStrictGenericChecks {
				createDeprecatedDiagnostic("noStrictGenericChecks")
			}
			if options.charset {
				createDeprecatedDiagnostic("charset")
			}
			if options.out {
				createDeprecatedDiagnostic("out" /*value*/, nil, "outFile")
			}
			if options.importsNotUsedAsValues {
				createDeprecatedDiagnostic("importsNotUsedAsValues" /*value*/, nil, "verbatimModuleSyntax")
			}
			if options.preserveValueImports {
				createDeprecatedDiagnostic("preserveValueImports" /*value*/, nil, "verbatimModuleSyntax")
			}
		})
	}

	verifyDeprecatedProjectReference := func(ref ProjectReference, parentFile *JsonSourceFile, index number) {
		createDiagnostic := func(_name string, _value *string, _useInstead *string, message DiagnosticMessage, args DiagnosticArguments) {
			createDiagnosticForReference(parentFile, index, message, args...)
		}

		checkDeprecations("5.0", "5.5", createDiagnostic, func(createDeprecatedDiagnostic /* TODO(TS-TO-GO) inferred type (name: string, value?: string, useInstead?: string) => void */ any) {
			if ref.prepend {
				createDeprecatedDiagnostic("prepend")
			}
		})
	}

	createDiagnosticExplainingFile := func(file *SourceFile, fileProcessingReason *FileIncludeReason, diagnostic DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		var seenReasons *Set[FileIncludeReason]
		reasons := file && fileReasons.get(file.path)
		var fileIncludeReasons *[]DiagnosticMessageChain
		var relatedInfo *[]DiagnosticWithLocation
		var locationReason *ReferencedFile
		if isReferencedFile(fileProcessingReason) {
			locationReason = fileProcessingReason
		} else {
			locationReason = nil
		}
		var fileIncludeReasonDetails *DiagnosticMessageChain
		var redirectInfo *[]DiagnosticMessageChain
		cachedChain := file && fileReasonsToChain. /* ? */ get(file.path)
		var chain *DiagnosticMessageChain
		if cachedChain {
			if cachedChain.fileIncludeReasonDetails {
				seenReasons = NewSet(reasons)
				reasons. /* ? */ forEach(populateRelatedInfo)
			} else {
				reasons. /* ? */ forEach(processReason)
			}
			redirectInfo = cachedChain.redirectInfo
		} else {
			reasons. /* ? */ forEach(processReason)
			redirectInfo = file && explainIfFileIsRedirectAndImpliedFormat(file, getCompilerOptionsForFile(file))
		}

		if fileProcessingReason {
			processReason(fileProcessingReason)
		}
		processedExtraReason := seenReasons. /* ? */ size != reasons. /* ? */ length

		// If we have location and there is only one reason file is in which is the location, dont add details for file include
		if locationReason && seenReasons. /* ? */ size == 1 {
			seenReasons = nil
		}

		if seenReasons && cachedChain {
			if cachedChain.details && !processedExtraReason {
				chain = chainDiagnosticMessages(cachedChain.details, diagnostic, args || emptyArray...)
			} else if cachedChain.fileIncludeReasonDetails {
				if !processedExtraReason {
					if !cachedFileIncludeDetailsHasProcessedExtraReason() {
						fileIncludeReasonDetails = cachedChain.fileIncludeReasonDetails
					} else {
						fileIncludeReasons = cachedChain.fileIncludeReasonDetails.next.slice(0, reasons.length)
					}
				} else {
					if !cachedFileIncludeDetailsHasProcessedExtraReason() {
						fileIncludeReasons = []DiagnosticMessageChain{ /* TODO(TS-TO-GO) Node SpreadElement: ...cachedChain.fileIncludeReasonDetails.next! */ fileIncludeReasons[0]}
					} else {
						fileIncludeReasons = append(cachedChain.fileIncludeReasonDetails.next.slice(0, reasons.length), fileIncludeReasons[0])
					}
				}
			}
		}

		if !chain {
			if !fileIncludeReasonDetails {
				fileIncludeReasonDetails = seenReasons && chainDiagnosticMessages(fileIncludeReasons, Diagnostics.The_file_is_in_the_program_because_Colon)
			}
			chain = chainDiagnosticMessages(ifElse(redirectInfo, ifElse(fileIncludeReasonDetails, []DiagnosticMessageChain{fileIncludeReasonDetails /* TODO(TS-TO-GO) Node SpreadElement: ...redirectInfo */}, redirectInfo), fileIncludeReasonDetails), diagnostic, args || emptyArray...)
		}

		// This is chain's next contains:
		//   - File is in program because:
		//      - Files reasons listed
		//      - extra reason if its not already processed - this happens in case sensitive file system where files differ in casing and we are giving reasons for two files so reason is not in file's reason
		//     fyi above whole secton is ommited if we have single reason and we are reporting at that reason's location
		//   - redirect and additional information about file
		// So cache result if we havent ommited file include reasons
		if file {
			if cachedChain {
				// Cache new fileIncludeDetails if we have update
				// Or if we had cached with more details than the reasons
				if !cachedChain.fileIncludeReasonDetails || (!processedExtraReason && fileIncludeReasonDetails) {
					cachedChain.fileIncludeReasonDetails = fileIncludeReasonDetails
				}
			} else {
				( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: fileReasonsToChain ??= new Map() */ TODO).set(file.path /* TODO(TS-TO-GO) EqualsToken BinaryExpression: cachedChain = { fileIncludeReasonDetails, redirectInfo } */, TODO)
			}
			// If we didnt compute extra file include reason , cache the details to use directly
			if !cachedChain.details && !processedExtraReason {
				cachedChain.details = chain.next
			}
		}

		location := locationReason && getReferencedFileLocation(program, locationReason)
		if location && isReferenceFileLocation(location) {
			return createFileDiagnosticFromMessageChain(location.file, location.pos, location.end-location.pos, chain, relatedInfo)
		} else {
			return createCompilerDiagnosticFromMessageChain(chain, relatedInfo)
		}

		processReason := func(reason FileIncludeReason) {
			if seenReasons. /* ? */ has(reason) {
				return
			}
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: seenReasons ??= new Set() */ TODO).add(reason)
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: fileIncludeReasons ??= [] */ TODO).push(fileIncludeReasonToDiagnostics(program, reason))
			populateRelatedInfo(reason)
		}

		populateRelatedInfo := func(reason FileIncludeReason) {
			if !locationReason && isReferencedFile(reason) {
				// Report error at first reference file or file currently in processing and dont report in related information
				locationReason = reason
			} else if locationReason != reason {
				relatedInfo = append(relatedInfo, getFileIncludeReasonToRelatedInformation(reason))
			}
		}

		cachedFileIncludeDetailsHasProcessedExtraReason := func() bool {
			return cachedChain.fileIncludeReasonDetails.next. /* ? */ length != reasons. /* ? */ length
		}

	}

	addFilePreprocessingFileExplainingDiagnostic := func(file *SourceFile, fileProcessingReason FileIncludeReason, diagnostic DiagnosticMessage, args DiagnosticArguments) {
		( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: fileProcessingDiagnostics ||= [] */ TODO).push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"kind":                 FilePreprocessingDiagnosticsKindFilePreprocessingFileExplainingDiagnostic,
			"file":                 file && file.path,
			"fileProcessingReason": fileProcessingReason,
			"diagnostic":           diagnostic,
			"args":                 args,
		})
	}

	addLazyProgramDiagnosticExplainingFile := func(file SourceFile, diagnostic DiagnosticMessage, args DiagnosticArguments) {
		lazyProgramDiagnosticExplainingFile.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"file":       file,
			"diagnostic": diagnostic,
			"args":       args,
		})
	}

	getFileIncludeReasonToRelatedInformation := func(reason FileIncludeReason) *DiagnosticWithLocation {
		relatedInfo := reasonToRelatedInfo. /* ? */ get(reason)
		if relatedInfo == nil {
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: reasonToRelatedInfo ??= new Map() */ TODO).set(reason /* TODO(TS-TO-GO) EqualsToken BinaryExpression: relatedInfo = fileIncludeReasonToRelatedInformation(reason) ?? false */, TODO)
		}
		return relatedInfo || nil
	}

	fileIncludeReasonToRelatedInformation := func(reason FileIncludeReason) *DiagnosticWithLocation {
		if isReferencedFile(reason) {
			referenceLocation := getReferencedFileLocation(program, reason)
			var message DiagnosticMessage
			switch reason.kind {
			case FileIncludeKindImport:
				message = Diagnostics.File_is_included_via_import_here
			case FileIncludeKindReferenceFile:
				message = Diagnostics.File_is_included_via_reference_here
			case FileIncludeKindTypeReferenceDirective:
				message = Diagnostics.File_is_included_via_type_library_reference_here
			case FileIncludeKindLibReferenceDirective:
				message = Diagnostics.File_is_included_via_library_reference_here
			default:
				Debug.assertNever(reason)
			}
			if isReferenceFileLocation(referenceLocation) {
				return createFileDiagnostic(referenceLocation.file, referenceLocation.pos, referenceLocation.end-referenceLocation.pos, message)
			} else {
				return nil
			}
		}

		if !options.configFile {
			return nil
		}
		var configFileNode *Node
		var message DiagnosticMessage
		switch reason.kind {
		case FileIncludeKindRootFile:
			if !options.configFile.configFileSpecs {
				return nil
			}
			fileName := getNormalizedAbsolutePath(rootNames[reason.index], currentDirectory)
			matchedByFiles := getMatchedFileSpec(program, fileName)
			if matchedByFiles {
				configFileNode = getTsConfigPropArrayElementValue(options.configFile, "files", matchedByFiles)
				message = Diagnostics.File_is_matched_by_files_list_specified_here
				break
			}
			matchedByInclude := getMatchedIncludeSpec(program, fileName)
			// Could be additional files specified as roots
			if !matchedByInclude || !isString(matchedByInclude) {
				return nil
			}
			configFileNode = getTsConfigPropArrayElementValue(options.configFile, "include", matchedByInclude)
			message = Diagnostics.File_is_matched_by_include_pattern_specified_here
		case FileIncludeKindSourceFromProjectReference,
			FileIncludeKindOutputFromProjectReference:
			referencedResolvedRef := Debug.checkDefined(resolvedProjectReferences[reason.index])
			referenceInfo := forEachProjectReference(projectReferences, resolvedProjectReferences, func(resolvedRef *ResolvedProjectReference, parent *ResolvedProjectReference, index number) * /* TODO(TS-TO-GO) inferred type { sourceFile: SourceFile; index: number; } */ any {
				if resolvedRef == referencedResolvedRef {
					return map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"sourceFile": parent. /* ? */ sourceFile || options.configFile,
						"index":      index,
					}
				} else {
					return nil
				}
			})
			if !referenceInfo {
				return nil
			}
			TODO_IDENTIFIER := referenceInfo
			referencesSyntax := forEachTsConfigPropArray(sourceFile.AsTsConfigSourceFile(), "references", func(property PropertyAssignment) *ArrayLiteralExpression {
				if isArrayLiteralExpression(property.initializer) {
					return property.initializer
				} else {
					return nil
				}
			})
			if referencesSyntax && referencesSyntax.elements.length > index {
				return createDiagnosticForNodeInSourceFile(sourceFile, referencesSyntax.elements[index], ifElse(reason.kind == FileIncludeKindOutputFromProjectReference, Diagnostics.File_is_output_from_referenced_project_specified_here, Diagnostics.File_is_source_from_referenced_project_specified_here))
			} else {
				return nil
			}
		case FileIncludeKindAutomaticTypeDirectiveFile:
			if !options.types {
				return nil
			}
			configFileNode = getOptionsSyntaxByArrayElementValue("types", reason.typeReference)
			message = Diagnostics.File_is_entry_point_of_type_library_specified_here
		case FileIncludeKindLibFile:
			if reason.index != nil {
				configFileNode = getOptionsSyntaxByArrayElementValue("lib", options.lib[reason.index])
				message = Diagnostics.File_is_library_specified_here
				break
			}
			target := getNameOfScriptTarget(getEmitScriptTarget(options))
			if target {
				configFileNode = getOptionsSyntaxByValue("target", target)
			} else {
				configFileNode = nil
			}
			message = Diagnostics.File_is_default_library_for_target_specified_here
		default:
			Debug.assertNever(reason)
		}
		return configFileNode && createDiagnosticForNodeInSourceFile(options.configFile, configFileNode, message)
	}

	verifyProjectReferences := func() {
		var buildInfoPath *string
		if !options.suppressOutputPathCheck {
			buildInfoPath = getTsBuildInfoEmitOutputFilePath(options)
		} else {
			buildInfoPath = nil
		}
		forEachProjectReference(projectReferences, resolvedProjectReferences, func(resolvedRef *ResolvedProjectReference, parent *ResolvedProjectReference, index number) {
			ref := (ifElse(parent, parent.commandLine.projectReferences, projectReferences))[index]
			parentFile := parent && parent.sourceFile.AsJsonSourceFile()
			verifyDeprecatedProjectReference(ref, parentFile, index)
			if !resolvedRef {
				createDiagnosticForReference(parentFile, index, Diagnostics.File_0_not_found, ref.path)
				return
			}
			options := resolvedRef.commandLine.options
			if !options.composite || options.noEmit {
				// ok to not have composite if the current program is container only
				var inputs []string
				if parent {
					inputs = parent.commandLine.fileNames
				} else {
					inputs = rootNames
				}
				if inputs.length {
					if !options.composite {
						createDiagnosticForReference(parentFile, index, Diagnostics.Referenced_project_0_must_have_setting_composite_Colon_true, ref.path)
					}
					if options.noEmit {
						createDiagnosticForReference(parentFile, index, Diagnostics.Referenced_project_0_may_not_disable_emit, ref.path)
					}
				}
			}
			if !parent && buildInfoPath && buildInfoPath == getTsBuildInfoEmitOutputFilePath(options) {
				createDiagnosticForReference(parentFile, index, Diagnostics.Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1, buildInfoPath, ref.path)
				hasEmitBlockingDiagnostics.set(toPath(buildInfoPath), true)
			}
		})
	}

	createDiagnosticForOptionPathKeyValue := func(key string, valueIndex number, message DiagnosticMessage, args DiagnosticArguments) {
		needCompilerDiagnostic := true
		forEachOptionPathsSyntax(func(pathProp PropertyAssignment) {
			if isObjectLiteralExpression(pathProp.initializer) {
				forEachPropertyAssignment(pathProp.initializer, key, func(keyProps PropertyAssignment) {
					initializer := keyProps.initializer
					if isArrayLiteralExpression(initializer) && initializer.elements.length > valueIndex {
						programDiagnostics.add(createDiagnosticForNodeInSourceFile(options.configFile, initializer.elements[valueIndex], message, args...))
						needCompilerDiagnostic = false
					}
				})
			}
		})
		if needCompilerDiagnostic {
			createCompilerOptionsDiagnostic(message, args...)
		}
	}

	createDiagnosticForOptionPaths := func(onKey bool, key string, message DiagnosticMessage, args DiagnosticArguments) {
		needCompilerDiagnostic := true
		forEachOptionPathsSyntax(func(pathProp PropertyAssignment) {
			if isObjectLiteralExpression(pathProp.initializer) && createOptionDiagnosticInObjectLiteralSyntax(pathProp.initializer, onKey, key, nil, message, args...) {
				needCompilerDiagnostic = false
			}
		})
		if needCompilerDiagnostic {
			createCompilerOptionsDiagnostic(message, args...)
		}
	}

	forEachOptionsSyntaxByName := func(name string, callback func(prop PropertyAssignment) *T) *T {
		return forEachPropertyAssignment(getCompilerOptionsObjectLiteralSyntax(), name, callback)
	}

	forEachOptionPathsSyntax := func(callback func(prop PropertyAssignment) *T) *T {
		return forEachOptionsSyntaxByName("paths", callback)
	}

	getOptionsSyntaxByValue := func(name string, value string) *StringLiteral {
		return forEachOptionsSyntaxByName(name, func(property PropertyAssignment) *StringLiteral {
			if isStringLiteral(property.initializer) && property.initializer.text == value {
				return property.initializer
			} else {
				return nil
			}
		})
	}

	getOptionsSyntaxByArrayElementValue := func(name string, value string) *StringLiteral {
		compilerOptionsObjectLiteralSyntax := getCompilerOptionsObjectLiteralSyntax()
		return compilerOptionsObjectLiteralSyntax && getPropertyArrayElementValue(compilerOptionsObjectLiteralSyntax, name, value)
	}

	createDiagnosticForOptionName := func(message DiagnosticMessage, option1 string, option2 string, option3 string) {
		// TODO(jakebailey): this code makes assumptions about the format of the diagnostic messages.
		createDiagnosticForOption(true, option1, option2, message, option1, option2, option3)
	}

	createOptionValueDiagnostic := func(option1 string, message DiagnosticMessage, args DiagnosticArguments) {
		createDiagnosticForOption(false, option1 /*option2*/, nil, message, args...)
	}

	createDiagnosticForReference := func(sourceFile *JsonSourceFile, index number, message DiagnosticMessage, args DiagnosticArguments) {
		referencesSyntax := forEachTsConfigPropArray(sourceFile || options.configFile, "references", func(property PropertyAssignment) *ArrayLiteralExpression {
			if isArrayLiteralExpression(property.initializer) {
				return property.initializer
			} else {
				return nil
			}
		})
		if referencesSyntax && referencesSyntax.elements.length > index {
			programDiagnostics.add(createDiagnosticForNodeInSourceFile(sourceFile || options.configFile, referencesSyntax.elements[index], message, args...))
		} else {
			programDiagnostics.add(createCompilerDiagnostic(message, args...))
		}
	}

	/* OVERLOAD: function createDiagnosticForOption(onKey: boolean, option1: string, option2: string | undefined, message: DiagnosticMessageChain): void; */
	/* OVERLOAD: function createDiagnosticForOption(onKey: boolean, option1: string, option2: string | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): void; */
	createDiagnosticForOption := func(onKey bool, option1 string, option2 *string, message /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
		compilerOptionsObjectLiteralSyntax := getCompilerOptionsObjectLiteralSyntax()
		needCompilerDiagnostic := !compilerOptionsObjectLiteralSyntax || !createOptionDiagnosticInObjectLiteralSyntax(compilerOptionsObjectLiteralSyntax, onKey, option1, option2, message, args...)

		if needCompilerDiagnostic {
			createCompilerOptionsDiagnostic(message, args...)
		}
	}

	/* OVERLOAD: function createCompilerOptionsDiagnostic(message: DiagnosticMessageChain): void; */
	/* OVERLOAD: function createCompilerOptionsDiagnostic(message: DiagnosticMessage, ...args: DiagnosticArguments): void; */
	/* OVERLOAD: function createCompilerOptionsDiagnostic(message: DiagnosticMessage | DiagnosticMessageChain, ...args: DiagnosticArguments): void; */
	createCompilerOptionsDiagnostic := func(message /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
		compilerOptionsProperty := getCompilerOptionsPropertySyntax()
		if compilerOptionsProperty {
			// eslint-disable-next-line local/no-in-operator
			if /* TODO(TS-TO-GO) InKeyword BinaryExpression: "messageText" in message */ TODO {
				programDiagnostics.add(createDiagnosticForNodeFromMessageChain(options.configFile, compilerOptionsProperty.name, message))
			} else {
				programDiagnostics.add(createDiagnosticForNodeInSourceFile(options.configFile, compilerOptionsProperty.name, message, args...))
			}
		} else if /* TODO(TS-TO-GO) InKeyword BinaryExpression: "messageText" in message */ TODO {
			programDiagnostics.add(createCompilerDiagnosticFromMessageChain(message))
		} else {
			programDiagnostics.add(createCompilerDiagnostic(message, args...))
		}
	}

	getCompilerOptionsObjectLiteralSyntax := func() *ObjectLiteralExpression {
		if _compilerOptionsObjectLiteralSyntax == nil {
			compilerOptionsProperty := getCompilerOptionsPropertySyntax()
			if compilerOptionsProperty {
				_compilerOptionsObjectLiteralSyntax = tryCast(compilerOptionsProperty.initializer, isObjectLiteralExpression) || false
			} else {
				_compilerOptionsObjectLiteralSyntax = false
			}
		}
		return _compilerOptionsObjectLiteralSyntax || nil
	}

	getCompilerOptionsPropertySyntax := func() *PropertyAssignment {
		if _compilerOptionsPropertySyntax == nil {
			_compilerOptionsPropertySyntax = forEachPropertyAssignment(getTsConfigObjectLiteralExpression(options.configFile), "compilerOptions", identity) || false
		}
		return _compilerOptionsPropertySyntax || nil
	}

	/* OVERLOAD: function createOptionDiagnosticInObjectLiteralSyntax(objectLiteral: ObjectLiteralExpression, onKey: boolean, key1: string, key2: string | undefined, messageChain: DiagnosticMessageChain): boolean; */
	/* OVERLOAD: function createOptionDiagnosticInObjectLiteralSyntax(objectLiteral: ObjectLiteralExpression, onKey: boolean, key1: string, key2: string | undefined, message: DiagnosticMessage, ...args: DiagnosticArguments): boolean; */
	/* OVERLOAD: function createOptionDiagnosticInObjectLiteralSyntax(objectLiteral: ObjectLiteralExpression, onKey: boolean, key1: string, key2: string | undefined, message: DiagnosticMessage | DiagnosticMessageChain, ...args: DiagnosticArguments): boolean; */
	createOptionDiagnosticInObjectLiteralSyntax := func(objectLiteral ObjectLiteralExpression, onKey bool, key1 string, key2 *string, message /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) bool {
		needsCompilerDiagnostic := false
		forEachPropertyAssignment(objectLiteral, key1, func(prop PropertyAssignment) {
			// eslint-disable-next-line local/no-in-operator
			if /* TODO(TS-TO-GO) InKeyword BinaryExpression: "messageText" in message */ TODO {
				programDiagnostics.add(createDiagnosticForNodeFromMessageChain(options.configFile, ifElse(onKey, prop.name, prop.initializer), message))
			} else {
				programDiagnostics.add(createDiagnosticForNodeInSourceFile(options.configFile, ifElse(onKey, prop.name, prop.initializer), message, args...))
			}
			needsCompilerDiagnostic = true
		}, key2)
		return needsCompilerDiagnostic
	}

	blockEmittingOfFile := func(emitFileName string, diag Diagnostic) {
		hasEmitBlockingDiagnostics.set(toPath(emitFileName), true)
		programDiagnostics.add(diag)
	}

	isEmittedFile := func(file string) bool {
		if options.noEmit {
			return false
		}

		// If this is source file, its not emitted file
		filePath := toPath(file)
		if getSourceFileByPath(filePath) {
			return false
		}

		// If options have --outFile or --out just check that
		out := options.outFile
		if out {
			return isSameFile(filePath, out) || isSameFile(filePath, removeFileExtension(out)+ExtensionDts)
		}

		// If declarationDir is specified, return if its a file in that directory
		if options.declarationDir && containsPath(options.declarationDir, filePath, currentDirectory, !host.useCaseSensitiveFileNames()) {
			return true
		}

		// If --outDir, check if file is in that directory
		if options.outDir {
			return containsPath(options.outDir, filePath, currentDirectory, !host.useCaseSensitiveFileNames())
		}

		if fileExtensionIsOneOf(filePath, supportedJSExtensionsFlat) || isDeclarationFileName(filePath) {
			// Otherwise just check if sourceFile with the name exists
			filePathWithoutExtension := removeFileExtension(filePath)
			return !!getSourceFileByPath((filePathWithoutExtension + ExtensionTs).(Path)) || !!getSourceFileByPath((filePathWithoutExtension + ExtensionTsx).(Path))
		}
		return false
	}

	isSameFile := func(file1 string, file2 string) bool {
		return comparePaths(file1, file2, currentDirectory, !host.useCaseSensitiveFileNames()) == ComparisonEqualTo
	}

	getSymlinkCache := func() SymlinkCache {
		if host.getSymlinkCache {
			return host.getSymlinkCache()
		}
		if !symlinks {
			symlinks = createSymlinkCache(currentDirectory, getCanonicalFileName)
		}
		if files && !symlinks.hasProcessedResolutions() {
			symlinks.setSymlinksFromResolutions(forEachResolvedModule, forEachResolvedTypeReferenceDirective, automaticTypeDirectiveResolutions)
		}
		return symlinks
	}

	getModeForUsageLocation := func(file SourceFile, usage StringLiteralLike) ResolutionMode {
		return getModeForUsageLocationWorker(file, usage, getCompilerOptionsForFile(file))
	}

	getEmitSyntaxForUsageLocation := func(file SourceFile, usage StringLiteralLike) ResolutionMode {
		return getEmitSyntaxForUsageLocationWorker(file, usage, getCompilerOptionsForFile(file))
	}

	getModeForResolutionAtIndex := func(file SourceFile, index number) ResolutionMode {
		return getModeForUsageLocation(file, getModuleNameStringLiteralAt(file, index))
	}

	getDefaultResolutionModeForFile := func(sourceFile SourceFile) ResolutionMode {
		return getDefaultResolutionModeForFileWorker(sourceFile, getCompilerOptionsForFile(sourceFile))
	}

	getImpliedNodeFormatForEmit := func(sourceFile SourceFile) ResolutionMode {
		return getImpliedNodeFormatForEmitWorker(sourceFile, getCompilerOptionsForFile(sourceFile))
	}

	getEmitModuleFormatOfFile := func(sourceFile SourceFile) ModuleKind {
		return getEmitModuleFormatOfFileWorker(sourceFile, getCompilerOptionsForFile(sourceFile))
	}

	shouldTransformImportCall := func(sourceFile SourceFile) bool {
		return shouldTransformImportCallWorker(sourceFile, getCompilerOptionsForFile(sourceFile))
	}

	getModeForTypeReferenceDirectiveInFile := func(ref FileReference, sourceFile SourceFile) ResolutionMode {
		return ref.resolutionMode || getDefaultResolutionModeForFile(sourceFile)
	}

}

func shouldTransformImportCallWorker(sourceFile Pick[SourceFile /* TODO(TS-TO-GO) TypeNode UnionType: "fileName" | "impliedNodeFormat" | "packageJsonScope" */, any], options CompilerOptions) bool {
	moduleKind := getEmitModuleKind(options)
	if ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext || moduleKind == ModuleKindPreserve {
		return false
	}
	return getEmitModuleFormatOfFileWorker(sourceFile, options) < ModuleKindES2015
}

/** @internal Prefer `program.getEmitModuleFormatOfFile` when possible. */

func getEmitModuleFormatOfFileWorker(sourceFile Pick[SourceFile /* TODO(TS-TO-GO) TypeNode UnionType: "fileName" | "impliedNodeFormat" | "packageJsonScope" */, any], options CompilerOptions) ModuleKind {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getImpliedNodeFormatForEmitWorker(sourceFile, options) ?? getEmitModuleKind(options) */ TODO
}

/** @internal Prefer `program.getImpliedNodeFormatForEmit` when possible. */

func getImpliedNodeFormatForEmitWorker(sourceFile Pick[SourceFile /* TODO(TS-TO-GO) TypeNode UnionType: "fileName" | "impliedNodeFormat" | "packageJsonScope" */, any], options CompilerOptions) ResolutionMode {
	moduleKind := getEmitModuleKind(options)
	if ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
		return sourceFile.impliedNodeFormat
	}
	if sourceFile.impliedNodeFormat == ModuleKindCommonJS && (sourceFile.packageJsonScope. /* ? */ contents.packageJsonContent.type_ == "commonjs" || fileExtensionIsOneOf(sourceFile.fileName, []Extension{ExtensionCjs, ExtensionCts})) {
		return ModuleKindCommonJS
	}
	if sourceFile.impliedNodeFormat == ModuleKindESNext && (sourceFile.packageJsonScope. /* ? */ contents.packageJsonContent.type_ == "module" || fileExtensionIsOneOf(sourceFile.fileName, []Extension{ExtensionMjs, ExtensionMts})) {
		return ModuleKindESNext
	}
	return nil
}

/** @internal Prefer `program.getDefaultResolutionModeForFile` when possible. */

func getDefaultResolutionModeForFileWorker(sourceFile Pick[SourceFile /* TODO(TS-TO-GO) TypeNode UnionType: "fileName" | "impliedNodeFormat" | "packageJsonScope" */, any], options CompilerOptions) ResolutionMode {
	if importSyntaxAffectsModuleResolution(options) {
		return getImpliedNodeFormatForEmitWorker(sourceFile, options)
	} else {
		return nil
	}
}

type HostForUseSourceOfProjectReferenceRedirect struct {
	compilerHost                        CompilerHost
	getSymlinkCache                     func() SymlinkCache
	useSourceOfProjectReferenceRedirect bool
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: interface HostForUseSourceOfProjectReferenceRedirect { compilerHost: CompilerHost; getSymlinkCache: () => SymlinkCache; useSourceOfProjectReferenceRedirect: boolean; toPath(fileName: string): Path; getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined; getSourceOfProjectReferenceRedirect(path: Path): SourceOfProjectReferenceRedirect | undefined; forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: interface HostForUseSourceOfProjectReferenceRedirect { compilerHost: CompilerHost; getSymlinkCache: () => SymlinkCache; useSourceOfProjectReferenceRedirect: boolean; toPath(fileName: string): Path; getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined; getSourceOfProjectReferenceRedirect(path: Path): SourceOfProjectReferenceRedirect | undefined; forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: interface HostForUseSourceOfProjectReferenceRedirect { compilerHost: CompilerHost; getSymlinkCache: () => SymlinkCache; useSourceOfProjectReferenceRedirect: boolean; toPath(fileName: string): Path; getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined; getSourceOfProjectReferenceRedirect(path: Path): SourceOfProjectReferenceRedirect | undefined; forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: interface HostForUseSourceOfProjectReferenceRedirect { compilerHost: CompilerHost; getSymlinkCache: () => SymlinkCache; useSourceOfProjectReferenceRedirect: boolean; toPath(fileName: string): Path; getResolvedProjectReferences(): readonly (ResolvedProjectReference | undefined)[] | undefined; getSourceOfProjectReferenceRedirect(path: Path): SourceOfProjectReferenceRedirect | undefined; forEachResolvedProjectReference<T>(cb: (resolvedProjectReference: ResolvedProjectReference) => T | undefined): T | undefined; } */
}

func updateHostForUseSourceOfProjectReferenceRedirect(host HostForUseSourceOfProjectReferenceRedirect) /* TODO(TS-TO-GO) inferred type { onProgramCreateComplete: typeof noop; fileExists: (file: string) => boolean; directoryExists?: undefined; } | { onProgramCreateComplete: () => void; fileExists: (file: string) => boolean; directoryExists: ((path: string) => boolean) | undefined; } */ any {
	var setOfDeclarationDirectories *Set[Path]
	originalFileExists := host.compilerHost.fileExists
	originalDirectoryExists := host.compilerHost.directoryExists
	originalGetDirectories := host.compilerHost.getDirectories
	originalRealpath := host.compilerHost.realpath

	if !host.useSourceOfProjectReferenceRedirect {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"onProgramCreateComplete": noop,
			"fileExists":              fileExists,
		}
	}

	host.compilerHost.fileExists = fileExists

	var directoryExists TODO
	if originalDirectoryExists {
		// This implementation of directoryExists checks if the directory being requested is
		// directory of .d.ts file for the referenced Project.
		// If it is it returns true irrespective of whether that directory exists on host
		directoryExists = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: host.compilerHost.directoryExists = path => { if (originalDirectoryExists.call(host.compilerHost, path)) { handleDirectoryCouldBeSymlink(path); return true; } if (!host.getResolvedProjectReferences()) return false; if (!setOfDeclarationDirectories) { setOfDeclarationDirectories = new Set(); host.forEachResolvedProjectReference(ref => { const out = ref.commandLine.options.outFile; if (out) { setOfDeclarationDirectories!.add(getDirectoryPath(host.toPath(out))); } else { // Set declaration's in different locations only, if they are next to source the directory present doesnt change const declarationDir = ref.commandLine.options.declarationDir || ref.commandLine.options.outDir; if (declarationDir) { setOfDeclarationDirectories!.add(host.toPath(declarationDir)); } } }); } return fileOrDirectoryExistsUsingSource(path, /*isFile* / false); } */ TODO
	}

	if originalGetDirectories {
		// Call getDirectories only if directory actually present on the host
		// This is needed to ensure that we arent getting directories that we fake about presence for
		host.compilerHost.getDirectories = func(path string) any {
			if !host.getResolvedProjectReferences() || (originalDirectoryExists && originalDirectoryExists.call(host.compilerHost, path)) {
				return originalGetDirectories.call(host.compilerHost, path)
			} else {
				return []never{}
			}
		}
	}

	// This is something we keep for life time of the host
	if originalRealpath {
		host.compilerHost.realpath = func(s string) any {
			return host.getSymlinkCache().getSymlinkedFiles(). /* ? */ get(host.toPath(s)) || originalRealpath.call(host.compilerHost, s)
		}
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"onProgramCreateComplete": onProgramCreateComplete,
		"fileExists":              fileExists,
		"directoryExists":         directoryExists,
	}

	onProgramCreateComplete := func() {
		host.compilerHost.fileExists = originalFileExists
		host.compilerHost.directoryExists = originalDirectoryExists
		host.compilerHost.getDirectories = originalGetDirectories
		// DO not revert realpath as it could be used later
	}

	// This implementation of fileExists checks if the file being requested is
	// .d.ts file for the referenced Project.
	// If it is it returns true irrespective of whether that file exists on host
	fileExists := func(file string) bool {
		if originalFileExists.call(host.compilerHost, file) {
			return true
		}
		if !host.getResolvedProjectReferences() {
			return false
		}
		if !isDeclarationFileName(file) {
			return false
		}

		// Project references go to source file instead of .d.ts file
		return fileOrDirectoryExistsUsingSource(file /*isFile*/, true)
	}

	fileExistsIfProjectReferenceDts := func(file string) *bool {
		source := host.getSourceOfProjectReferenceRedirect(host.toPath(file))
		switch {
		case source != nil:
			if isString(source) {
				return originalFileExists.call(host.compilerHost, source) /* as boolean */
			} else {
				return true
			}
		default:
			return nil
		}
	}

	directoryExistsIfProjectReferenceDeclDir := func(dir string) *bool {
		dirPath := host.toPath(dir)
		dirPathWithTrailingDirectorySeparator := __TEMPLATE__(dirPath, directorySeparator)
		return forEachKey(setOfDeclarationDirectories, func(declDirPath Path) bool {
			return dirPath == declDirPath || startsWith(declDirPath, dirPathWithTrailingDirectorySeparator) || startsWith(dirPath, __TEMPLATE__(declDirPath, "/"))
		})
	}

	handleDirectoryCouldBeSymlink := func(directory string) {
		if !host.getResolvedProjectReferences() || containsIgnoredPath(directory) {
			return
		}

		// Because we already watch node_modules, handle symlinks in there
		if !originalRealpath || !directory.includes(nodeModulesPathPart) {
			return
		}
		symlinkCache := host.getSymlinkCache()
		directoryPath := ensureTrailingDirectorySeparator(host.toPath(directory))
		if symlinkCache.getSymlinkedDirectories(). /* ? */ has(directoryPath) {
			return
		}

		real := normalizePath(originalRealpath.call(host.compilerHost, directory))
		var realPath Path
		if real == directory || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: realPath = ensureTrailingDirectorySeparator(host.toPath(real)) */ TODO) == directoryPath {
			// not symlinked
			symlinkCache.setSymlinkedDirectory(directoryPath, false)
			return
		}

		symlinkCache.setSymlinkedDirectory(directory, map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"real":     ensureTrailingDirectorySeparator(real),
			"realPath": realPath,
		})
	}

	fileOrDirectoryExistsUsingSource := func(fileOrDirectory string, isFile bool) bool {
		var fileOrDirectoryExistsUsingSource * /* TODO(TS-TO-GO) inferred type (file: string) => boolean */ any
		if isFile {
			fileOrDirectoryExistsUsingSource = func(file string) *bool {
				return fileExistsIfProjectReferenceDts(file)
			}
		} else {
			fileOrDirectoryExistsUsingSource = func(dir string) *bool {
				return directoryExistsIfProjectReferenceDeclDir(dir)
			}
		}
		// Check current directory or file
		result := fileOrDirectoryExistsUsingSource(fileOrDirectory)
		if result != nil {
			return result
		}

		symlinkCache := host.getSymlinkCache()
		symlinkedDirectories := symlinkCache.getSymlinkedDirectories()
		if !symlinkedDirectories {
			return false
		}
		fileOrDirectoryPath := host.toPath(fileOrDirectory)
		if !fileOrDirectoryPath.includes(nodeModulesPathPart) {
			return false
		}
		if isFile && symlinkCache.getSymlinkedFiles(). /* ? */ has(fileOrDirectoryPath) {
			return true
		}

		// If it contains node_modules check if its one of the symlinked path we know of
		return firstDefinedIterator(symlinkedDirectories.entries(), func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [Path, false | SymlinkedDirectory] */ any) *bool {
			if !symlinkedDirectory || !startsWith(fileOrDirectoryPath, directoryPath) {
				return nil
			}
			result := fileOrDirectoryExistsUsingSource(fileOrDirectoryPath.replace(directoryPath, symlinkedDirectory.realPath))
			if isFile && result {
				// Store the real path for the file'
				absolutePath := getNormalizedAbsolutePath(fileOrDirectory, host.compilerHost.getCurrentDirectory())
				symlinkCache.setSymlinkedFile(fileOrDirectoryPath, __TEMPLATE__(symlinkedDirectory.real, absolutePath.replace(NewRegExp(directoryPath, "i"), "")))
			}
			return result
		}) || false
	}

}

/** @internal */

var emitSkippedWithNoDiagnostics EmitResult = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"diagnostics":  emptyArray,
	"sourceMaps":   nil,
	"emittedFiles": nil,
	"emitSkipped":  true,
}

/** @internal */

func handleNoEmitOptions(program /* TODO(TS-TO-GO) TypeNode UnionType: Program | T */ any, sourceFile *SourceFile, writeFile *WriteFileCallback, cancellationToken CancellationToken) *EmitResult {
	options := program.getCompilerOptions()
	if options.noEmit {
		if sourceFile {
			return emitSkippedWithNoDiagnostics
		} else {
			return program.emitBuildInfo(writeFile, cancellationToken)
		}
	}

	// If the noEmitOnError flag is set, then check if we have any errors so far.  If so,
	// immediately bail out.  Note that we pass 'undefined' for 'sourceFile' so that we
	// get any preEmit diagnostics, not just the ones
	if !options.noEmitOnError {
		return nil
	}
	var diagnostics []Diagnostic = []Diagnostic{ /* TODO(TS-TO-GO) Node SpreadElement: ...program.getOptionsDiagnostics(cancellationToken) */ /* TODO(TS-TO-GO) Node SpreadElement: ...program.getSyntacticDiagnostics(sourceFile, cancellationToken) */ /* TODO(TS-TO-GO) Node SpreadElement: ...program.getGlobalDiagnostics(cancellationToken) */ /* TODO(TS-TO-GO) Node SpreadElement: ...program.getSemanticDiagnostics(sourceFile, cancellationToken) */ }

	if diagnostics.length == 0 && getEmitDeclarations(program.getCompilerOptions()) {
		diagnostics = program.getDeclarationDiagnostics(nil, cancellationToken)
	}

	if !diagnostics.length {
		return nil
	}
	var emittedFiles *[]string
	if !sourceFile {
		emitResult := program.emitBuildInfo(writeFile, cancellationToken)
		if emitResult.diagnostics {
			diagnostics = []Diagnostic{ /* TODO(TS-TO-GO) Node SpreadElement: ...diagnostics */ /* TODO(TS-TO-GO) Node SpreadElement: ...emitResult.diagnostics */ }
		}
		emittedFiles = emitResult.emittedFiles
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"diagnostics":  diagnostics,
		"sourceMaps":   nil,
		"emittedFiles": emittedFiles,
		"emitSkipped":  true,
	}
}

/** @internal */

func filterSemanticDiagnostics(diagnostic []Diagnostic, option CompilerOptions) []Diagnostic {
	return filter(diagnostic, func(d Diagnostic) bool {
		return !d.skippedOn || !option[d.skippedOn]
	})
}

/** @internal */

func parseConfigHostFromCompilerHostLike(host /* TODO(TS-TO-GO) TypeNode IntersectionType: (CompilerHost | ProgramHost<T>) & { onUnRecoverableConfigFileDiagnostic?: DiagnosticReporter; } */ any, directoryStructureHost DirectoryStructureHost /*  = host */) ParseConfigFileHost {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"fileExists": func(f string) bool {
			return directoryStructureHost.fileExists(f)
		},
		"readDirectory": func(root string, extensions []string, excludes *[]string, includes []string, depth *number) []string {
			Debug.assertIsDefined(directoryStructureHost.readDirectory, "'CompilerHost.readDirectory' must be implemented to correctly process 'projectReferences'")
			return directoryStructureHost.readDirectory(root, extensions, excludes, includes, depth)
		},
		"readFile": func(f string) *string {
			return directoryStructureHost.readFile(f)
		},
		"directoryExists":           maybeBind(directoryStructureHost, directoryStructureHost.directoryExists),
		"getDirectories":            maybeBind(directoryStructureHost, directoryStructureHost.getDirectories),
		"realpath":                  maybeBind(directoryStructureHost, directoryStructureHost.realpath),
		"useCaseSensitiveFileNames": host.useCaseSensitiveFileNames(),
		"getCurrentDirectory": func() string {
			return host.getCurrentDirectory()
		},
		"onUnRecoverableConfigFileDiagnostic": host.onUnRecoverableConfigFileDiagnostic || returnUndefined,
		"trace": ifElse(host.trace, func(s string) {
			return host.trace(s)
		}, nil),
	}
}

/**
 * Returns the target config filename of a project reference.
 * Note: The file might not exist.
 */

func resolveProjectReferencePath(ref ProjectReference) ResolvedConfigFileName {
	return resolveConfigFileProjectName(ref.path)
}

/**
 * Returns a DiagnosticMessage if we won't include a resolved module due to its extension.
 * The DiagnosticMessage's parameters are the imported module name, and the filename it resolved to.
 * This returns a diagnostic even if the module will be an untyped module.
 *
 * @internal
 */

func getResolutionDiagnostic(options CompilerOptions, TODO_IDENTIFIER ResolvedModuleFull, TODO_IDENTIFIER /* TODO(TS-TO-GO) TypeNode TypeLiteral: { isDeclarationFile: SourceFile["isDeclarationFile"]; } */ any) *DiagnosticMessage {
	switch extension {
	case ExtensionTs,
		ExtensionDts,
		ExtensionMts,
		ExtensionDmts,
		ExtensionCts,
		ExtensionDcts:
		// These are always allowed.
		return nil
	case ExtensionTsx:
		return needJsx()
	case ExtensionJsx:
		return needJsx() || needAllowJs()
	case ExtensionJs,
		ExtensionMjs,
		ExtensionCjs:
		return needAllowJs()
	case ExtensionJson:
		return needResolveJsonModule()
	default:
		return needAllowArbitraryExtensions()
	}

	needJsx := func() any {
		if options.jsx {
			return nil
		} else {
			return Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set
		}
	}

	needAllowJs := func() any {
		if getAllowJSCompilerOption(options) || !getStrictOptionValue(options, "noImplicitAny") {
			return nil
		} else {
			return Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type
		}
	}

	needResolveJsonModule := func() any {
		if getResolveJsonModule(options) {
			return nil
		} else {
			return Diagnostics.Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used
		}
	}

	needAllowArbitraryExtensions := func() any {
		// But don't report the allowArbitraryExtensions error from declaration files (no reason to report it, since the import doesn't have a runtime component)
		if isDeclarationFile || options.allowArbitraryExtensions {
			return nil
		} else {
			return Diagnostics.Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set
		}
	}

}

func getModuleNames(TODO_IDENTIFIER SourceFile) []StringLiteralLike {
	res := imports.map_(func(i StringLiteralLike) StringLiteralLike {
		return i
	})
	for _, aug := range moduleAugmentations {
		if aug.kind == SyntaxKindStringLiteral {
			res.push(aug)
		}
		// Do nothing if it's an Identifier; we don't need to do module resolution for `declare global`.
	}
	return res
}

/** @internal */

func getModuleNameStringLiteralAt(TODO_IDENTIFIER SourceFileImportsList, index number) StringLiteralLike {
	if index < imports.length {
		return imports[index]
	}
	augIndex := imports.length
	for _, aug := range moduleAugmentations {
		if aug.kind == SyntaxKindStringLiteral {
			if index == augIndex {
				return aug
			}
			augIndex++
		}
		// Do nothing if it's an Identifier; we don't need to do module resolution for `declare global`.
	}
	Debug.fail("should never ask for module name at index higher than possible module name")
}
