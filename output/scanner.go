// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

func __COND__[C comparable, T any](cond C, a T, b T) T {
	var zero C
	if cond != zero {
		return a
	}
	return b
}

type Scanner struct {
	text                      string
	pos                       number
	end                       number
	fullStartPos              number
	tokenStart                number
	token                     SyntaxKind
	tokenValue                string
	tokenFlags                TokenFlags
	commentDirectives         *[]CommentDirective
	skipJsDocLeadingAsterisks number
	scriptKind                ScriptKind
	jsDocParsingMode          JSDocParsingMode
	scanner                   Scanner
}

type ErrorCallback func(message DiagnosticMessage, length number, arg0 any)

/** @internal */

func tokenIsIdentifierOrKeyword(token SyntaxKind) bool {
	return token >= SyntaxKindIdentifier
}

/** @internal */

func tokenIsIdentifierOrKeywordOrGreaterThan(token SyntaxKind) bool {
	return token == SyntaxKindGreaterThanToken || tokenIsIdentifierOrKeyword(token)
}

type Scanner struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface Scanner { /** @deprecated use {@link getTokenFullStart} * / getStartPos(): number; getToken(): SyntaxKind; getTokenFullStart(): number; getTokenStart(): number; getTokenEnd(): number; /** @deprecated use {@link getTokenEnd} * / getTextPos(): number; /** @deprecated use {@link getTokenStart} * / getTokenPos(): number; getTokenText(): string; getTokenValue(): string; hasUnicodeEscape(): boolean; hasExtendedUnicodeEscape(): boolean; hasPrecedingLineBreak(): boolean; /** @internal * / hasPrecedingJSDocComment(): boolean; /** @internal * / hasPrecedingJSDocLeadingAsterisks(): boolean; isIdentifier(): boolean; isReservedWord(): boolean; isUnterminated(): boolean; /** @internal * / getNumericLiteralFlags(): TokenFlags; /** @internal * / getCommentDirectives(): CommentDirective[] | undefined; /** @internal * / getTokenFlags(): TokenFlags; reScanGreaterToken(): SyntaxKind; reScanSlashToken(): SyntaxKind; /** @internal * / reScanSlashToken(reportErrors?: boolean): SyntaxKind; // eslint-disable-line @typescript-eslint/unified-signatures reScanAsteriskEqualsToken(): SyntaxKind; reScanTemplateToken(isTaggedTemplate: boolean): SyntaxKind; /** @deprecated use {@link reScanTemplateToken}(false) * / reScanTemplateHeadOrNoSubstitutionTemplate(): SyntaxKind; scanJsxIdentifier(): SyntaxKind; scanJsxAttributeValue(): SyntaxKind; reScanJsxAttributeValue(): SyntaxKind; reScanJsxToken(allowMultilineJsxText?: boolean): JsxTokenSyntaxKind; reScanLessThanToken(): SyntaxKind; reScanHashToken(): SyntaxKind; reScanQuestionToken(): SyntaxKind; reScanInvalidIdentifier(): SyntaxKind; scanJsxToken(): JsxTokenSyntaxKind; scanJsDocToken(): JSDocSyntaxKind; /** @internal * / scanJSDocCommentTextToken(inBackticks: boolean): JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken; scan(): SyntaxKind; getText(): string; /** @internal * / clearCommentDirectives(): void; // Sets the text for the scanner to scan.  An optional subrange starting point and length // can be provided to have the scanner only scan a portion of the text. setText(text: string | undefined, start?: number, length?: number): void; setOnError(onError: ErrorCallback | undefined): void; setScriptTarget(scriptTarget: ScriptTarget): void; setLanguageVariant(variant: LanguageVariant): void; setScriptKind(scriptKind: ScriptKind): void; setJSDocParsingMode(kind: JSDocParsingMode): void; /** @deprecated use {@link resetTokenState} * / setTextPos(textPos: number): void; resetTokenState(pos: number): void; /** @internal * / setSkipJsDocLeadingAsterisks(skip: boolean): void; // Invokes the provided callback then unconditionally restores the scanner to the state it // was in immediately prior to invoking the callback.  The result of invoking the callback // is returned from this function. lookAhead<T>(callback: () => T): T; // Invokes the callback with the scanner set to scan the specified range. When the callback // returns, the scanner is restored to the state it was in before scanRange was called. scanRange<T>(start: number, length: number, callback: () => T): T; // Invokes the provided callback.  If the callback returns something falsy, then it restores // the scanner to the state it was in immediately prior to invoking the callback.  If the // callback returns something truthy, then the scanner state is not rolled back.  The result // of invoking the callback is returned from this function. tryScan<T>(callback: () => T): T; } */
}

/** @internal */

var textToKeywordObj MapLike[KeywordSyntaxKind] = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"abstract":        SyntaxKindAbstractKeyword,
	"accessor":        SyntaxKindAccessorKeyword,
	"any":             SyntaxKindAnyKeyword,
	"as":              SyntaxKindAsKeyword,
	"asserts":         SyntaxKindAssertsKeyword,
	"assert":          SyntaxKindAssertKeyword,
	"bigint":          SyntaxKindBigIntKeyword,
	"boolean":         SyntaxKindBooleanKeyword,
	"break_":          SyntaxKindBreakKeyword,
	"case_":           SyntaxKindCaseKeyword,
	"catch":           SyntaxKindCatchKeyword,
	"class":           SyntaxKindClassKeyword,
	"continue_":       SyntaxKindContinueKeyword,
	"const_":          SyntaxKindConstKeyword,
	"TODO_IDENTIFIER": SyntaxKindConstructorKeyword,
	"debugger":        SyntaxKindDebuggerKeyword,
	"declare":         SyntaxKindDeclareKeyword,
	"default_":        SyntaxKindDefaultKeyword,
	"delete":          SyntaxKindDeleteKeyword,
	"do":              SyntaxKindDoKeyword,
	"else_":           SyntaxKindElseKeyword,
	"enum":            SyntaxKindEnumKeyword,
	"export":          SyntaxKindExportKeyword,
	"extends":         SyntaxKindExtendsKeyword,
	"false":           SyntaxKindFalseKeyword,
	"finally":         SyntaxKindFinallyKeyword,
	"for_":            SyntaxKindForKeyword,
	"from":            SyntaxKindFromKeyword,
	"function":        SyntaxKindFunctionKeyword,
	"get":             SyntaxKindGetKeyword,
	"if_":             SyntaxKindIfKeyword,
	"implements":      SyntaxKindImplementsKeyword,
	"import_":         SyntaxKindImportKeyword,
	"in":              SyntaxKindInKeyword,
	"infer":           SyntaxKindInferKeyword,
	"instanceof":      SyntaxKindInstanceOfKeyword,
	"interface_":      SyntaxKindInterfaceKeyword,
	"intrinsic":       SyntaxKindIntrinsicKeyword,
	"is":              SyntaxKindIsKeyword,
	"keyof":           SyntaxKindKeyOfKeyword,
	"let":             SyntaxKindLetKeyword,
	"module":          SyntaxKindModuleKeyword,
	"namespace":       SyntaxKindNamespaceKeyword,
	"never":           SyntaxKindNeverKeyword,
	"new":             SyntaxKindNewKeyword,
	"null":            SyntaxKindNullKeyword,
	"number":          SyntaxKindNumberKeyword,
	"object":          SyntaxKindObjectKeyword,
	"package_":        SyntaxKindPackageKeyword,
	"private":         SyntaxKindPrivateKeyword,
	"protected":       SyntaxKindProtectedKeyword,
	"public":          SyntaxKindPublicKeyword,
	"override":        SyntaxKindOverrideKeyword,
	"out":             SyntaxKindOutKeyword,
	"readonly":        SyntaxKindReadonlyKeyword,
	"require":         SyntaxKindRequireKeyword,
	"global":          SyntaxKindGlobalKeyword,
	"return_":         SyntaxKindReturnKeyword,
	"satisfies":       SyntaxKindSatisfiesKeyword,
	"set":             SyntaxKindSetKeyword,
	"static":          SyntaxKindStaticKeyword,
	"string":          SyntaxKindStringKeyword,
	"super":           SyntaxKindSuperKeyword,
	"switch_":         SyntaxKindSwitchKeyword,
	"symbol":          SyntaxKindSymbolKeyword,
	"this":            SyntaxKindThisKeyword,
	"throw":           SyntaxKindThrowKeyword,
	"true":            SyntaxKindTrueKeyword,
	"try":             SyntaxKindTryKeyword,
	"type_":           SyntaxKindTypeKeyword,
	"typeof":          SyntaxKindTypeOfKeyword,
	"undefined":       SyntaxKindUndefinedKeyword,
	"unique":          SyntaxKindUniqueKeyword,
	"unknown":         SyntaxKindUnknownKeyword,
	"using":           SyntaxKindUsingKeyword,
	"var_":            SyntaxKindVarKeyword,
	"void":            SyntaxKindVoidKeyword,
	"while":           SyntaxKindWhileKeyword,
	"with":            SyntaxKindWithKeyword,
	"yield":           SyntaxKindYieldKeyword,
	"async":           SyntaxKindAsyncKeyword,
	"await":           SyntaxKindAwaitKeyword,
	"of":              SyntaxKindOfKeyword,
}

var textToKeyword = NewMap(Object.entries(textToKeywordObj))

var textToToken = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	/* TODO(TS-TO-GO) Node SpreadAssignment: ...textToKeywordObj */
	"TODO_IDENTIFIER": SyntaxKindOpenBraceToken,
	"TODO_IDENTIFIER": SyntaxKindCloseBraceToken,
	"TODO_IDENTIFIER": SyntaxKindOpenParenToken,
	"TODO_IDENTIFIER": SyntaxKindCloseParenToken,
	"TODO_IDENTIFIER": SyntaxKindOpenBracketToken,
	"TODO_IDENTIFIER": SyntaxKindCloseBracketToken,
	"TODO_IDENTIFIER": SyntaxKindDotToken,
	"TODO_IDENTIFIER": SyntaxKindDotDotDotToken,
	"TODO_IDENTIFIER": SyntaxKindSemicolonToken,
	"TODO_IDENTIFIER": SyntaxKindCommaToken,
	"TODO_IDENTIFIER": SyntaxKindLessThanToken,
	"TODO_IDENTIFIER": SyntaxKindGreaterThanToken,
	"TODO_IDENTIFIER": SyntaxKindLessThanEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindGreaterThanEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindEqualsEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindExclamationEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindEqualsEqualsEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindExclamationEqualsEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindEqualsGreaterThanToken,
	"TODO_IDENTIFIER": SyntaxKindPlusToken,
	"TODO_IDENTIFIER": SyntaxKindMinusToken,
	"TODO_IDENTIFIER": SyntaxKindAsteriskAsteriskToken,
	"TODO_IDENTIFIER": SyntaxKindAsteriskToken,
	"TODO_IDENTIFIER": SyntaxKindSlashToken,
	"TODO_IDENTIFIER": SyntaxKindPercentToken,
	"TODO_IDENTIFIER": SyntaxKindPlusPlusToken,
	"TODO_IDENTIFIER": SyntaxKindMinusMinusToken,
	"TODO_IDENTIFIER": SyntaxKindLessThanLessThanToken,
	"TODO_IDENTIFIER": SyntaxKindLessThanSlashToken,
	"TODO_IDENTIFIER": SyntaxKindGreaterThanGreaterThanToken,
	"TODO_IDENTIFIER": SyntaxKindGreaterThanGreaterThanGreaterThanToken,
	"TODO_IDENTIFIER": SyntaxKindAmpersandToken,
	"TODO_IDENTIFIER": SyntaxKindBarToken,
	"TODO_IDENTIFIER": SyntaxKindCaretToken,
	"TODO_IDENTIFIER": SyntaxKindExclamationToken,
	"TODO_IDENTIFIER": SyntaxKindTildeToken,
	"TODO_IDENTIFIER": SyntaxKindAmpersandAmpersandToken,
	"TODO_IDENTIFIER": SyntaxKindBarBarToken,
	"TODO_IDENTIFIER": SyntaxKindQuestionToken,
	"TODO_IDENTIFIER": SyntaxKindQuestionQuestionToken,
	"TODO_IDENTIFIER": SyntaxKindQuestionDotToken,
	"TODO_IDENTIFIER": SyntaxKindColonToken,
	"TODO_IDENTIFIER": SyntaxKindEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindPlusEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindMinusEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindAsteriskEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindAsteriskAsteriskEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindSlashEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindPercentEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindLessThanLessThanEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindGreaterThanGreaterThanEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindAmpersandEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindBarEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindCaretEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindBarBarEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindAmpersandAmpersandEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindQuestionQuestionEqualsToken,
	"TODO_IDENTIFIER": SyntaxKindAtToken,
	"TODO_IDENTIFIER": SyntaxKindHashToken,
	"TODO_IDENTIFIER": SyntaxKindBacktickToken,
}))

var charCodeToRegExpFlag = NewMap[CharacterCodes, RegularExpressionFlags]([] /* TODO(TS-TO-GO) inferred type [CharacterCodes.d, RegularExpressionFlags.HasIndices] | [CharacterCodes.g, RegularExpressionFlags.Global] | [CharacterCodes.i, RegularExpressionFlags.IgnoreCase] | [CharacterCodes.m, RegularExpressionFlags.Multiline] | [CharacterCodes.s, RegularExpressionFlags.DotAll] | [CharacterCodes.u, RegularExpressionFlags.Unicode] | [CharacterCodes.v, RegularExpressionFlags.UnicodeSets] | [CharacterCodes.y, RegularExpressionFlags.Sticky] */ any{[]any{CharacterCodesd, RegularExpressionFlagsHasIndices}, []any{CharacterCodesg, RegularExpressionFlagsGlobal}, []any{CharacterCodesi, RegularExpressionFlagsIgnoreCase}, []any{CharacterCodesm, RegularExpressionFlagsMultiline}, []any{CharacterCodess, RegularExpressionFlagsDotAll}, []any{CharacterCodesu, RegularExpressionFlagsUnicode}, []any{CharacterCodesv, RegularExpressionFlagsUnicodeSets}, []any{CharacterCodesy, RegularExpressionFlagsSticky}})

var regExpFlagToFirstAvailableLanguageVersion = NewMap[RegularExpressionFlags /* TODO(TS-TO-GO) TypeNode IndexedAccessType: typeof LanguageFeatureMinimumTarget[LanugageFeatures] */, any]([] /* TODO(TS-TO-GO) inferred type [RegularExpressionFlags.HasIndices, ScriptTarget] | [RegularExpressionFlags.DotAll, ScriptTarget] | [RegularExpressionFlags.Unicode, ScriptTarget] | [RegularExpressionFlags.UnicodeSets, ScriptTarget] | [RegularExpressionFlags.Sticky, ScriptTarget] */ any{[]any{RegularExpressionFlagsHasIndices, LanguageFeatureMinimumTarget.RegularExpressionFlagsHasIndices}, []any{RegularExpressionFlagsDotAll, LanguageFeatureMinimumTarget.RegularExpressionFlagsDotAll}, []any{RegularExpressionFlagsUnicode, LanguageFeatureMinimumTarget.RegularExpressionFlagsUnicode}, []any{RegularExpressionFlagsUnicodeSets, LanguageFeatureMinimumTarget.RegularExpressionFlagsUnicodeSets}, []any{RegularExpressionFlagsSticky, LanguageFeatureMinimumTarget.RegularExpressionFlagsSticky}})

/*
   As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
   IdentifierStart ::
       Can contain Unicode 6.2 categories:
       Uppercase letter (Lu),
       Lowercase letter (Ll),
       Titlecase letter (Lt),
       Modifier letter (Lm),
       Other letter (Lo), or
       Letter number (Nl).
   IdentifierPart ::
       Can contain IdentifierStart + Unicode 6.2 categories:
       Non-spacing mark (Mn),
       Combining spacing mark (Mc),
       Decimal number (Nd),
       Connector punctuation (Pc),
       <ZWNJ>, or
       <ZWJ>.

   Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
   http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
*/
// dprint-ignore
var unicodeES5IdentifierStart = []number{170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500}

// dprint-ignore
var unicodeES5IdentifierPart = []number{170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500}

/**
 * Generated by scripts/regenerate-unicode-identifier-parts.mjs on node v22.1.0 with unicode 15.1
 * based on http://www.unicode.org/reports/tr31/ and https://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords
 * unicodeESNextIdentifierStart corresponds to the ID_Start and Other_ID_Start property, and
 * unicodeESNextIdentifierPart corresponds to ID_Continue, Other_ID_Continue, plus ID_Start and Other_ID_Start
 */
// dprint-ignore

var unicodeESNextIdentifierStart = []number{65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2160, 2183, 2185, 2190, 2208, 2249, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3165, 3165, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3293, 3294, 3296, 3297, 3313, 3314, 3332, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5905, 5919, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6988, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12443, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69248, 69289, 69296, 69297, 69376, 69404, 69415, 69415, 69424, 69445, 69488, 69505, 69552, 69572, 69600, 69622, 69635, 69687, 69745, 69746, 69749, 69749, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69959, 69959, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70207, 70208, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70753, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71488, 71494, 71680, 71723, 71840, 71903, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71983, 71999, 71999, 72001, 72001, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73474, 73474, 73476, 73488, 73490, 73523, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78895, 78913, 78918, 82944, 83526, 92160, 92728, 92736, 92766, 92784, 92862, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 122624, 122654, 122661, 122666, 122928, 122989, 123136, 123180, 123191, 123197, 123214, 123214, 123536, 123565, 123584, 123627, 124112, 124139, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 191472, 192093, 194560, 195101, 196608, 201546, 201552, 205743}

// dprint-ignore
var unicodeESNextIdentifierPart = []number{48, 57, 65, 90, 95, 95, 97, 122, 170, 170, 181, 181, 183, 183, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2160, 2183, 2185, 2190, 2200, 2273, 2275, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2901, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3132, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3165, 3165, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3293, 3294, 3296, 3299, 3302, 3311, 3313, 3315, 3328, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3457, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3790, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4969, 4977, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5909, 5919, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6159, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6847, 6862, 6912, 6988, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12447, 12449, 12543, 12549, 12591, 12593, 12686, 12704, 12735, 12784, 12799, 13312, 19903, 19968, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42954, 42960, 42961, 42963, 42963, 42965, 42969, 42994, 43047, 43052, 43052, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43881, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 66928, 66938, 66940, 66954, 66956, 66962, 66964, 66965, 66967, 66977, 66979, 66993, 66995, 67001, 67003, 67004, 67072, 67382, 67392, 67413, 67424, 67431, 67456, 67461, 67463, 67504, 67506, 67514, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69248, 69289, 69291, 69292, 69296, 69297, 69373, 69404, 69415, 69415, 69424, 69456, 69488, 69509, 69552, 69572, 69600, 69622, 69632, 69702, 69734, 69749, 69759, 69818, 69826, 69826, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69959, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70094, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70209, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70753, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71488, 71494, 71680, 71738, 71840, 71913, 71935, 71942, 71945, 71945, 71948, 71955, 71957, 71958, 71960, 71989, 71991, 71992, 71995, 72003, 72016, 72025, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72368, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73472, 73488, 73490, 73530, 73534, 73538, 73552, 73561, 73648, 73648, 73728, 74649, 74752, 74862, 74880, 75075, 77712, 77808, 77824, 78895, 78912, 78933, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92784, 92862, 92864, 92873, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94180, 94192, 94193, 94208, 100343, 100352, 101589, 101632, 101640, 110576, 110579, 110581, 110587, 110589, 110590, 110592, 110882, 110898, 110898, 110928, 110930, 110933, 110933, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 118528, 118573, 118576, 118598, 119141, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122624, 122654, 122661, 122666, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 122928, 122989, 123023, 123023, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123536, 123566, 123584, 123641, 124112, 124153, 124896, 124902, 124904, 124907, 124909, 124910, 124912, 124926, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 130032, 130041, 131072, 173791, 173824, 177977, 177984, 178205, 178208, 183969, 183984, 191456, 191472, 192093, 194560, 195101, 196608, 201546, 201552, 205743, 917760, 917999}

/**
 * Test for whether a single line comment with leading whitespace trimmed's text contains a directive.
 */

var commentDirectiveRegExSingleLine = regexp.MustParse(`^\/\/\/?\s*@(ts-expect-error|ts-ignore)`)

/**
 * Test for whether a multi-line comment with leading whitespace trimmed's last line contains a directive.
 */

var commentDirectiveRegExMultiLine = regexp.MustParse(`^(?:\/|\*)*\s*@(ts-expect-error|ts-ignore)`)

var jsDocSeeOrLink = regexp.MustParse(`(?i:@(?:see|link))`)

func lookupInUnicodeMap(code number, map_ []number) bool {
	// Bail out quickly if it couldn't possibly be in the map.
	if code < map_[0] {
		return false
	}

	// Perform binary search in one of the Unicode range maps
	lo := 0
	var hi number = map_.length
	var mid number

	for lo+1 < hi {
		mid = lo + (hi-lo)/2
		// mid has to be even to catch a range's beginning
		mid -= mid % 2
		if map_[mid] <= code && code <= map_[mid+1] {
			return true
		}

		if code < map_[mid] {
			hi = mid
		} else {
			lo = mid + 2
		}
	}

	return false
}

/** @internal */

func isUnicodeIdentifierStart(code number, languageVersion *ScriptTarget) bool {
	if languageVersion >= ScriptTargetES2015 {
		return lookupInUnicodeMap(code, unicodeESNextIdentifierStart)
	} else {
		return lookupInUnicodeMap(code, unicodeES5IdentifierStart)
	}
}

func isUnicodeIdentifierPart(code number, languageVersion *ScriptTarget) bool {
	if languageVersion >= ScriptTargetES2015 {
		return lookupInUnicodeMap(code, unicodeESNextIdentifierPart)
	} else {
		return lookupInUnicodeMap(code, unicodeES5IdentifierPart)
	}
}

func makeReverseMap(source Map[T, number]) []T {
	var result []T = []never{}
	source.forEach(func(value number, name T) {
		result[value] = name
	})
	return result
}

var tokenStrings = makeReverseMap(textToToken)

/** @internal */

/* OVERLOAD: export function tokenToString(t: PunctuationOrKeywordSyntaxKind): string; */
/* OVERLOAD: export function tokenToString(t: SyntaxKind): string | undefined; */
func tokenToString(t SyntaxKind) *string {
	return tokenStrings[t]
}

/** @internal */

func stringToToken(s string) *SyntaxKind {
	return textToToken.get(s)
}

var regExpFlagCharCodes = makeReverseMap(charCodeToRegExpFlag)

/** @internal @knipignore */

func regularExpressionFlagToCharacterCode(f RegularExpressionFlags) *CharacterCodes {
	return regExpFlagCharCodes[f]
}

/** @internal @knipignore */

func characterCodeToRegularExpressionFlag(ch CharacterCodes) *RegularExpressionFlags {
	return charCodeToRegExpFlag.get(ch)
}

/** @internal */

func computeLineStarts(text string) []number {
	var result []number = []never{}
	pos := 0
	lineStart := 0
	for pos < text.length {
		ch := text.charCodeAt(pos)
		pos++
		switch ch {
		case CharacterCodescarriageReturn:
			if text.charCodeAt(pos) == CharacterCodeslineFeed {
				pos++
			}
			fallthrough
		case CharacterCodeslineFeed:
			result.push(lineStart)
			lineStart = pos
		default:
			if ch > CharacterCodesmaxAsciiCharacter && isLineBreak(ch) {
				result.push(lineStart)
				lineStart = pos
			}
		}
	}
	result.push(lineStart)
	return result
}

/* OVERLOAD: export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number): number; */
/** @internal */

/* OVERLOAD: export function getPositionOfLineAndCharacter(sourceFile: SourceFileLike, line: number, character: number, allowEdits?: true): number; */
// eslint-disable-line @typescript-eslint/unified-signatures
func getPositionOfLineAndCharacter(sourceFile SourceFileLike, line number, character number, allowEdits /* TODO(TS-TO-GO) TypeNode LiteralType: true */ any) number {
	if sourceFile.getPositionOfLineAndCharacter {
		return sourceFile.getPositionOfLineAndCharacter(line, character, allowEdits)
	} else {
		return computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character, sourceFile.text, allowEdits)
	}
}

/** @internal */

func computePositionOfLineAndCharacter(lineStarts []number, line number, character number, debugText string, allowEdits /* TODO(TS-TO-GO) TypeNode LiteralType: true */ any) number {
	if line < 0 || line >= lineStarts.length {
		if allowEdits {
			// Clamp line to nearest allowable value
			switch {
			case line < 0:
				line = 0
			case line >= lineStarts.length:
				line = lineStarts.length - 1
			default:
				line = line
			}
		} else {
			Debug.fail(__TEMPLATE__("Bad line number. Line: ", line, ", lineStarts.length: ", lineStarts.length, " , line map is correct? ", __COND__(debugText != nil, arrayIsEqualTo(lineStarts, computeLineStarts(debugText)), "unknown")))
		}
	}

	res := lineStarts[line] + character
	if allowEdits {
		// Clamp to nearest allowable values to allow the underlying to be edited without crashing (accuracy is lost, instead)
		// TODO: Somehow track edits between file as it was during the creation of sourcemap we have and the current file and
		// apply them to the computed position to improve accuracy
		switch {
		case res > lineStarts[line+1]:
			return lineStarts[line+1]
		case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof debugText */ TODO == "string" && res > debugText.length:
			return debugText.length
		default:
			return res
		}
	}
	if line < lineStarts.length-1 {
		Debug.assert(res < lineStarts[line+1])
	} else if debugText != nil {
		Debug.assert(res <= debugText.length)
		// Allow single character overflow for trailing newline
	}
	return res
}

/** @internal */

func getLineStarts(sourceFile SourceFileLike) []number {
	return sourceFile.lineMap || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: sourceFile.lineMap = computeLineStarts(sourceFile.text) */ TODO)
}

/** @internal */

func computeLineAndCharacterOfPosition(lineStarts []number, position number) LineAndCharacter {
	lineNumber := computeLineOfPosition(lineStarts, position)
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"line":      lineNumber,
		"character": position - lineStarts[lineNumber],
	}
}

/**
 * @internal
 * We assume the first line starts at position 0 and 'position' is non-negative.
 */

func computeLineOfPosition(lineStarts []number, position number, lowerBound number) number {
	lineNumber := binarySearch(lineStarts, position, identity, compareValues, lowerBound)
	if lineNumber < 0 {
		// If the actual position was not found,
		// the binary search returns the 2's-complement of the next line start
		// e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
		// then the search will return -2.
		//
		// We want the index of the previous line start, so we subtract 1.
		// Review 2's-complement if this is confusing.
		lineNumber = ~lineNumber - 1
		Debug.assert(lineNumber != -1, "position cannot precede the beginning of the file")
	}
	return lineNumber
}

/** @internal */

func getLinesBetweenPositions(sourceFile SourceFileLike, pos1 number, pos2 number) number {
	if pos1 == pos2 {
		return 0
	}
	lineStarts := getLineStarts(sourceFile)
	lower := Math.min(pos1, pos2)
	isNegative := lower == pos2
	var upper number
	if isNegative {
		upper = pos1
	} else {
		upper = pos2
	}
	lowerLine := computeLineOfPosition(lineStarts, lower)
	upperLine := computeLineOfPosition(lineStarts, upper, lowerLine)
	if isNegative {
		return lowerLine - upperLine
	} else {
		return upperLine - lowerLine
	}
}

func getLineAndCharacterOfPosition(sourceFile SourceFileLike, position number) LineAndCharacter {
	return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position)
}

func isWhiteSpaceLike(ch number) bool {
	return isWhiteSpaceSingleLine(ch) || isLineBreak(ch)
}

/** Does not include line breaks. For that, see isWhiteSpaceLike. */

func isWhiteSpaceSingleLine(ch number) bool {
	// Note: nextLine is in the Zs space, and should be considered to be a whitespace.
	// It is explicitly not a line-break as it isn't in the exact set specified by EcmaScript.
	return ch == CharacterCodesspace || ch == CharacterCodestab || ch == CharacterCodesverticalTab || ch == CharacterCodesformFeed || ch == CharacterCodesnonBreakingSpace || ch == CharacterCodesnextLine || ch == CharacterCodesogham || ch >= CharacterCodesenQuad && ch <= CharacterCodeszeroWidthSpace || ch == CharacterCodesnarrowNoBreakSpace || ch == CharacterCodesmathematicalSpace || ch == CharacterCodesideographicSpace || ch == CharacterCodesbyteOrderMark
}

func isLineBreak(ch number) bool {
	// ES5 7.3:
	// The ECMAScript line terminator characters are listed in Table 3.
	//     Table 3: Line Terminator Characters
	//     Code Unit Value     Name                    Formal Name
	//     \u000A              Line Feed               <LF>
	//     \u000D              Carriage Return         <CR>
	//     \u2028              Line separator          <LS>
	//     \u2029              Paragraph separator     <PS>
	// Only the characters in Table 3 are treated as line terminators. Other new line or line
	// breaking characters are treated as white space but not as line terminators.

	return ch == CharacterCodeslineFeed || ch == CharacterCodescarriageReturn || ch == CharacterCodeslineSeparator || ch == CharacterCodesparagraphSeparator
}

func isDigit(ch number) bool {
	return ch >= CharacterCodes_0 && ch <= CharacterCodes_9
}

func isHexDigit(ch number) bool {
	return isDigit(ch) || ch >= CharacterCodesA && ch <= CharacterCodesF || ch >= CharacterCodesa && ch <= CharacterCodesf
}

func isASCIILetter(ch number) bool {
	return ch >= CharacterCodesA && ch <= CharacterCodesZ || ch >= CharacterCodesa && ch <= CharacterCodesz
}

// Section 6.1.4
func isWordCharacter(ch number) bool {
	return isASCIILetter(ch) || isDigit(ch) || ch == CharacterCodes_
}

func isOctalDigit(ch number) bool {
	return ch >= CharacterCodes_0 && ch <= CharacterCodes_7
}

func couldStartTrivia(text string, pos number) bool {
	// Keep in sync with skipTrivia
	ch := text.charCodeAt(pos)
	switch ch {
	case CharacterCodescarriageReturn,
		CharacterCodeslineFeed,
		CharacterCodestab,
		CharacterCodesverticalTab,
		CharacterCodesformFeed,
		CharacterCodesspace,
		CharacterCodesslash,
		CharacterCodeslessThan,
		CharacterCodesbar,
		CharacterCodesequals,
		CharacterCodesgreaterThan:
		return true
	case CharacterCodeshash:
		return pos == 0
	default:
		return ch > CharacterCodesmaxAsciiCharacter
	}
}

/** @internal */

func skipTrivia(text string, pos number, stopAfterLineBreak bool, stopAtComments bool, inJSDoc bool) number {
	if positionIsSynthesized(pos) {
		return pos
	}

	canConsumeStar := false
	// Keep in sync with couldStartTrivia
	for true {
		ch := text.charCodeAt(pos)
		switch ch {
		case CharacterCodescarriageReturn:
			if text.charCodeAt(pos+1) == CharacterCodeslineFeed {
				pos++
			}
			fallthrough
		case CharacterCodeslineFeed:
			pos++
			if stopAfterLineBreak {
				return pos
			}
			canConsumeStar = !!inJSDoc
			continue
			fallthrough
		case CharacterCodestab,
			CharacterCodesverticalTab,
			CharacterCodesformFeed,
			CharacterCodesspace:
			pos++
			continue
			fallthrough
		case CharacterCodesslash:
			if stopAtComments {
				break
			}
			if text.charCodeAt(pos+1) == CharacterCodesslash {
				pos += 2
				for pos < text.length {
					if isLineBreak(text.charCodeAt(pos)) {
						break
					}
					pos++
				}
				canConsumeStar = false
				continue
			}
			if text.charCodeAt(pos+1) == CharacterCodesasterisk {
				pos += 2
				for pos < text.length {
					if text.charCodeAt(pos) == CharacterCodesasterisk && text.charCodeAt(pos+1) == CharacterCodesslash {
						pos += 2
						break
					}
					pos++
				}
				canConsumeStar = false
				continue
			}
		case CharacterCodeslessThan,
			CharacterCodesbar,
			CharacterCodesequals,
			CharacterCodesgreaterThan:
			if isConflictMarkerTrivia(text, pos) {
				pos = scanConflictMarkerTrivia(text, pos)
				canConsumeStar = false
				continue
			}
		case CharacterCodeshash:
			if pos == 0 && isShebangTrivia(text, pos) {
				pos = scanShebangTrivia(text, pos)
				canConsumeStar = false
				continue
			}
		case CharacterCodesasterisk:
			if canConsumeStar {
				pos++
				canConsumeStar = false
				continue
			}
		default:
			if ch > CharacterCodesmaxAsciiCharacter && (isWhiteSpaceLike(ch)) {
				pos++
				continue
			}
		}
		return pos
	}
}

// All conflict markers consist of the same character repeated seven times.  If it is
// a <<<<<<< or >>>>>>> marker then it is also followed by a space.
var mergeConflictMarkerLength = len("<<<<<<<")

func isConflictMarkerTrivia(text string, pos number) bool {
	Debug.assert(pos >= 0)

	// Conflict markers must be at the start of a line.
	if pos == 0 || isLineBreak(text.charCodeAt(pos-1)) {
		ch := text.charCodeAt(pos)

		if (pos + mergeConflictMarkerLength) < text.length {
			for i := 0; i < mergeConflictMarkerLength; i++ {
				if text.charCodeAt(pos+i) != ch {
					return false
				}
			}

			return ch == CharacterCodesequals || text.charCodeAt(pos+mergeConflictMarkerLength) == CharacterCodesspace
		}
	}

	return false
}

func scanConflictMarkerTrivia(text string, pos number, error func(diag DiagnosticMessage, pos number, len number)) number {
	if error {
		error(Diagnostics.Merge_conflict_marker_encountered, pos, mergeConflictMarkerLength)
	}

	ch := text.charCodeAt(pos)
	len := text.length

	if ch == CharacterCodeslessThan || ch == CharacterCodesgreaterThan {
		for pos < len && !isLineBreak(text.charCodeAt(pos)) {
			pos++
		}
	} else {
		Debug.assert(ch == CharacterCodesbar || ch == CharacterCodesequals)
		// Consume everything from the start of a ||||||| or ======= marker to the start
		// of the next ======= or >>>>>>> marker.
		for pos < len {
			currentChar := text.charCodeAt(pos)
			if (currentChar == CharacterCodesequals || currentChar == CharacterCodesgreaterThan) && currentChar != ch && isConflictMarkerTrivia(text, pos) {
				break
			}

			pos++
		}
	}

	return pos
}

var shebangTriviaRegex = regexp.MustParse(`^#!.*`)

func isShebangTrivia(text string, pos number) bool {
	// Shebangs check must only be done at the start of the file
	Debug.assert(pos == 0)
	return shebangTriviaRegex.test(text)
}

func scanShebangTrivia(text string, pos number) number {
	shebang := shebangTriviaRegex.exec(text)[0]
	pos = pos + shebang.length
	return pos
}

/**
 * Invokes a callback for each comment range following the provided position.
 *
 * Single-line comment ranges include the leading double-slash characters but not the ending
 * line break. Multi-line comment ranges include the leading slash-asterisk and trailing
 * asterisk-slash characters.
 *
 * @param reduce If true, accumulates the result of calling the callback in a fashion similar
 *      to reduceLeft. If false, iteration stops when the callback returns a truthy value.
 * @param text The source text to scan.
 * @param pos The position at which to start scanning.
 * @param trailing If false, whitespace is skipped until the first line break and comments
 *      between that location and the next token are returned. If true, comments occurring
 *      between the given position and the next line break are returned.
 * @param cb The callback to execute as each comment range is encountered.
 * @param state A state value to pass to each iteration of the callback.
 * @param initial An initial value to pass when accumulating results (when "reduce" is true).
 * @returns If "reduce" is true, the accumulated value. If "reduce" is false, the first truthy
 *      return value of the callback.
 */

func iterateCommentRanges(reduce bool, text string, pos number, trailing bool, cb func(pos number, end number, kind CommentKind, hasTrailingNewLine bool, state T, memo *U) U, state T, initial U) *U {
	var pendingPos number
	var pendingEnd number
	var pendingKind CommentKind
	var pendingHasTrailingNewLine bool
	hasPendingCommentRange := false
	collecting := trailing
	accumulator := initial
	if pos == 0 {
		collecting = true
		shebang := getShebang(text)
		if shebang {
			pos = shebang.length
		}
	}
scan:
	for pos >= 0 && pos < text.length {
		ch := text.charCodeAt(pos)
		switch ch {
		case CharacterCodescarriageReturn:
			if text.charCodeAt(pos+1) == CharacterCodeslineFeed {
				pos++
			}
			fallthrough
		case CharacterCodeslineFeed:
			pos++
			if trailing {
				break scan
			}

			collecting = true
			if hasPendingCommentRange {
				pendingHasTrailingNewLine = true
			}

			continue
			fallthrough
		case CharacterCodestab,
			CharacterCodesverticalTab,
			CharacterCodesformFeed,
			CharacterCodesspace:
			pos++
			continue
			fallthrough
		case CharacterCodesslash:
			nextChar := text.charCodeAt(pos + 1)
			hasTrailingNewLine := false
			if nextChar == CharacterCodesslash || nextChar == CharacterCodesasterisk {
				var kind /* TODO(TS-TO-GO) inferred type SyntaxKind.SingleLineCommentTrivia | SyntaxKind.MultiLineCommentTrivia */ any
				if nextChar == CharacterCodesslash {
					kind = SyntaxKindSingleLineCommentTrivia
				} else {
					kind = SyntaxKindMultiLineCommentTrivia
				}
				startPos := pos
				pos += 2
				if nextChar == CharacterCodesslash {
					for pos < text.length {
						if isLineBreak(text.charCodeAt(pos)) {
							hasTrailingNewLine = true
							break
						}
						pos++
					}
				} else {
					for pos < text.length {
						if text.charCodeAt(pos) == CharacterCodesasterisk && text.charCodeAt(pos+1) == CharacterCodesslash {
							pos += 2
							break
						}
						pos++
					}
				}

				if collecting {
					if hasPendingCommentRange {
						accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator)
						if !reduce && accumulator {
							// If we are not reducing and we have a truthy result, return it.
							return accumulator
						}
					}

					pendingPos = startPos
					pendingEnd = pos
					pendingKind = kind
					pendingHasTrailingNewLine = hasTrailingNewLine
					hasPendingCommentRange = true
				}

				continue
			}
		default:
			if ch > CharacterCodesmaxAsciiCharacter && (isWhiteSpaceLike(ch)) {
				if hasPendingCommentRange && isLineBreak(ch) {
					pendingHasTrailingNewLine = true
				}
				pos++
				continue
			}
		}
	}

	if hasPendingCommentRange {
		accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator)
	}

	return accumulator
}

/* OVERLOAD: export function forEachLeadingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined; */
/* OVERLOAD: export function forEachLeadingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined; */
func forEachLeadingCommentRange(text string, pos number, cb func(pos number, end number, kind CommentKind, hasTrailingNewLine bool, state T) U, state T) *U {
	return iterateCommentRanges(false, text, pos /*trailing*/, false, cb, state)
}

/* OVERLOAD: export function forEachTrailingCommentRange<U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean) => U): U | undefined; */
/* OVERLOAD: export function forEachTrailingCommentRange<T, U>(text: string, pos: number, cb: (pos: number, end: number, kind: CommentKind, hasTrailingNewLine: boolean, state: T) => U, state: T): U | undefined; */
func forEachTrailingCommentRange(text string, pos number, cb func(pos number, end number, kind CommentKind, hasTrailingNewLine bool, state T) U, state T) *U {
	return iterateCommentRanges(false, text, pos /*trailing*/, true, cb, state)
}

func reduceEachLeadingCommentRange(text string, pos number, cb func(pos number, end number, kind CommentKind, hasTrailingNewLine bool, state T) U, state T, initial U) *U {
	return iterateCommentRanges(true, text, pos /*trailing*/, false, cb, state, initial)
}

func reduceEachTrailingCommentRange(text string, pos number, cb func(pos number, end number, kind CommentKind, hasTrailingNewLine bool, state T) U, state T, initial U) *U {
	return iterateCommentRanges(true, text, pos /*trailing*/, true, cb, state, initial)
}

func appendCommentRange(pos number, end number, kind CommentKind, hasTrailingNewLine bool, _state any, comments []CommentRange /*  = [] */) []CommentRange {
	comments.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind":               kind,
		"pos":                pos,
		"end":                end,
		"hasTrailingNewLine": hasTrailingNewLine,
	})
	return comments
}

func getLeadingCommentRanges(text string, pos number) *[]CommentRange {
	return reduceEachLeadingCommentRange(text, pos, appendCommentRange /*state*/, nil /*initial*/, nil)
}

func getTrailingCommentRanges(text string, pos number) *[]CommentRange {
	return reduceEachTrailingCommentRange(text, pos, appendCommentRange /*state*/, nil /*initial*/, nil)
}

/** Optionally, get the shebang */

func getShebang(text string) *string {
	match := shebangTriviaRegex.exec(text)
	if match {
		return match[0]
	}
}

func isIdentifierStart(ch number, languageVersion *ScriptTarget) bool {
	return isASCIILetter(ch) || ch == CharacterCodes_DOLLAR_ || ch == CharacterCodes_ || ch > CharacterCodesmaxAsciiCharacter && isUnicodeIdentifierStart(ch, languageVersion)
}

func isIdentifierPart(ch number, languageVersion *ScriptTarget, identifierVariant LanguageVariant) bool {
	return isWordCharacter(ch) || ch == CharacterCodes_DOLLAR_ || (__COND__(identifierVariant == LanguageVariantJSX, (ch == CharacterCodesminus || ch == CharacterCodescolon), false)) || ch > CharacterCodesmaxAsciiCharacter && isUnicodeIdentifierPart(ch, languageVersion)
}

/** @internal */

func isIdentifierText(name string, languageVersion *ScriptTarget, identifierVariant LanguageVariant) bool {
	ch := codePointAt(name, 0)
	if !isIdentifierStart(ch, languageVersion) {
		return false
	}

	for i := charSize(ch); i < name.length; i += charSize(ch) {
		if !isIdentifierPart( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: ch = codePointAt(name, i) */ TODO, languageVersion, identifierVariant) {
			return false
		}
	}

	return true
}

type EscapeSequenceScanningFlags int32

const (
	EscapeSequenceScanningFlagsString                     EscapeSequenceScanningFlags = 1 << 0
	EscapeSequenceScanningFlagsReportErrors               EscapeSequenceScanningFlags = 1 << 1
	EscapeSequenceScanningFlagsRegularExpression          EscapeSequenceScanningFlags = 1 << 2
	EscapeSequenceScanningFlagsAnnexB                     EscapeSequenceScanningFlags = 1 << 3
	EscapeSequenceScanningFlagsAnyUnicodeMode             EscapeSequenceScanningFlags = 1 << 4
	EscapeSequenceScanningFlagsAtomEscape                 EscapeSequenceScanningFlags = 1 << 5
	EscapeSequenceScanningFlagsReportInvalidEscapeErrors  EscapeSequenceScanningFlags = EscapeSequenceScanningFlagsRegularExpression | EscapeSequenceScanningFlagsReportErrors
	EscapeSequenceScanningFlagsAllowExtendedUnicodeEscape EscapeSequenceScanningFlags = EscapeSequenceScanningFlagsString | EscapeSequenceScanningFlagsAnyUnicodeMode
)

type ClassSetExpressionType int32

const (
	ClassSetExpressionTypeUnknown ClassSetExpressionType = iota
	ClassSetExpressionTypeClassUnion
	ClassSetExpressionTypeClassIntersection
	ClassSetExpressionTypeClassSubtraction
)

// Creates a scanner over a (possibly unspecified) range of a piece of text.
func createScanner(languageVersion ScriptTarget, skipTrivia bool, languageVariant LanguageVariant /*  = LanguageVariant.Standard */, textInitial string, onError ErrorCallback, start number, length number) Scanner {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	tc.text = textInitial

	// Current position (end position of text of current token)

	// end of text

	// Start position of whitespace before current token

	// Start position of text of current token

	tc.skipJsDocLeadingAsterisks = 0

	tc.scriptKind = ScriptKindUnknown
	tc.jsDocParsingMode = JSDocParsingModeParseAll

	scanner.setText(scanner.text, start, length)

	tc.scanner = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getTokenFullStart": func() number {
			return scanner.fullStartPos
		},
		"getStartPos": func() number {
			return scanner.fullStartPos
		},
		"getTokenEnd": func() number {
			return scanner.pos
		},
		"getTextPos": func() number {
			return scanner.pos
		},
		"getToken": func() SyntaxKind {
			return scanner.token
		},
		"getTokenStart": func() number {
			return scanner.tokenStart
		},
		"getTokenPos": func() number {
			return scanner.tokenStart
		},
		"getTokenText": func() string {
			return scanner.text.substring(scanner.tokenStart, scanner.pos)
		},
		"getTokenValue": func() string {
			return scanner.tokenValue
		},
		"hasUnicodeEscape": func() bool {
			return (scanner.tokenFlags & TokenFlagsUnicodeEscape) != 0
		},
		"hasExtendedUnicodeEscape": func() bool {
			return (scanner.tokenFlags & TokenFlagsExtendedUnicodeEscape) != 0
		},
		"hasPrecedingLineBreak": func() bool {
			return (scanner.tokenFlags & TokenFlagsPrecedingLineBreak) != 0
		},
		"hasPrecedingJSDocComment": func() bool {
			return (scanner.tokenFlags & TokenFlagsPrecedingJSDocComment) != 0
		},
		"hasPrecedingJSDocLeadingAsterisks": func() bool {
			return (scanner.tokenFlags & TokenFlagsPrecedingJSDocLeadingAsterisks) != 0
		},
		"isIdentifier": func() bool {
			return scanner.token == SyntaxKindIdentifier || scanner.token > SyntaxKindLastReservedWord
		},
		"isReservedWord": func() bool {
			return scanner.token >= SyntaxKindFirstReservedWord && scanner.token <= SyntaxKindLastReservedWord
		},
		"isUnterminated": func() bool {
			return (scanner.tokenFlags & TokenFlagsUnterminated) != 0
		},
		"getCommentDirectives": func() *[]CommentDirective {
			return scanner.commentDirectives
		},
		"getNumericLiteralFlags": func() number {
			return scanner.tokenFlags & TokenFlagsNumericLiteralFlags
		},
		"getTokenFlags": func() TokenFlags {
			return scanner.tokenFlags
		},
		"reScanGreaterToken":                         reScanGreaterToken,
		"reScanAsteriskEqualsToken":                  reScanAsteriskEqualsToken,
		"reScanSlashToken":                           reScanSlashToken,
		"reScanTemplateToken":                        reScanTemplateToken,
		"reScanTemplateHeadOrNoSubstitutionTemplate": reScanTemplateHeadOrNoSubstitutionTemplate,
		"scanJsxIdentifier":                          scanJsxIdentifier,
		"scanJsxAttributeValue":                      scanJsxAttributeValue,
		"reScanJsxAttributeValue":                    reScanJsxAttributeValue,
		"reScanJsxToken":                             reScanJsxToken,
		"reScanLessThanToken":                        reScanLessThanToken,
		"reScanHashToken":                            reScanHashToken,
		"reScanQuestionToken":                        reScanQuestionToken,
		"reScanInvalidIdentifier":                    reScanInvalidIdentifier,
		"scanJsxToken":                               scanJsxToken,
		"scanJsDocToken":                             scanJsDocToken,
		"scanJSDocCommentTextToken":                  scanJSDocCommentTextToken,
		"scan":                                       scan,
		"getText":                                    getText,
		"clearCommentDirectives":                     clearCommentDirectives,
		"setText":                                    setText,
		"setScriptTarget":                            setScriptTarget,
		"setLanguageVariant":                         setLanguageVariant,
		"setScriptKind":                              setScriptKind,
		"setJSDocParsingMode":                        setJSDocParsingMode,
		"setOnError":                                 setOnError,
		"resetTokenState":                            resetTokenState,
		"setTextPos":                                 scanner.resetTokenState,
		"setSkipJsDocLeadingAsterisks":               setSkipJsDocLeadingAsterisks,
		"tryScan":                                    tryScan,
		"lookAhead":                                  lookAhead,
		"scanRange":                                  scanRange,
	}
	/* eslint-enable no-var */

	if Debug.isDebugging {
		Object.defineProperty(scanner.scanner, "__debugShowCurrentPositionInText", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"get": func() string {
				text := scanner.scanner.getText()
				return text.slice(0, scanner.scanner.getTokenFullStart()) + "" + text.slice(scanner.scanner.getTokenFullStart())
			},
		})
	}

	return scanner.scanner
}

/**
 * Returns the code point for the character at the given position within `text`. This
 * should only be used when pos is guaranteed to be within the bounds of `text` as this
 * function does not perform bounds checks.
 */

func (scanner *Scanner) codePointUnchecked(pos number) number {
	return codePointAt(scanner.text, scanner.pos)
}

/**
 * Returns the code point for the character at the given position within `text`. If
 * `pos` is outside the bounds set for `text`, `CharacterCodes.EOF` is returned instead.
 */

func (scanner *Scanner) codePointChecked(pos number) number {
	if scanner.pos >= 0 && scanner.pos < scanner.end {
		return scanner.codePointUnchecked(scanner.pos)
	} else {
		return CharacterCodesEOF
	}
}

/**
 * Returns the char code for the character at the given position within `text`. This
 * should only be used when pos is guaranteed to be within the bounds of `text` as this
 * function does not perform bounds checks.
 */

func (scanner *Scanner) charCodeUnchecked(pos number) number {
	return scanner.text.charCodeAt(scanner.pos)
}

/**
 * Returns the char code for the character at the given position within `text`. If
 * `pos` is outside the bounds set for `text`, `CharacterCodes.EOF` is returned instead.
 */

func (scanner *Scanner) charCodeChecked(pos number) number {
	if scanner.pos >= 0 && scanner.pos < scanner.end {
		return scanner.charCodeUnchecked(scanner.pos)
	} else {
		return CharacterCodesEOF
	}
}

/* OVERLOAD: function error(message: DiagnosticMessage): void; */
/* OVERLOAD: function error(message: DiagnosticMessage, errPos: number, length: number, arg0?: any): void; */
func (scanner *Scanner) error(message DiagnosticMessage, errPos number /*  = pos */, length number, arg0 any) {
	if onError {
		oldPos := scanner.pos
		scanner.pos = errPos
		onError(message, length || 0, arg0)
		scanner.pos = oldPos
	}
}

func (scanner *Scanner) scanNumberFragment() string {
	start := scanner.pos
	allowSeparator := false
	isPreviousTokenSeparator := false
	result := ""
	for true {
		ch := scanner.charCodeUnchecked(scanner.pos)
		if ch == CharacterCodes_ {
			scanner.tokenFlags |= TokenFlagsContainsSeparator
			if allowSeparator {
				allowSeparator = false
				isPreviousTokenSeparator = true
				result += scanner.text.substring(start, scanner.pos)
			} else {
				scanner.tokenFlags |= TokenFlagsContainsInvalidSeparator
				if isPreviousTokenSeparator {
					scanner.error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, scanner.pos, 1)
				} else {
					scanner.error(Diagnostics.Numeric_separators_are_not_allowed_here, scanner.pos, 1)
				}
			}
			scanner.pos++
			start = scanner.pos
			continue
		}
		if isDigit(ch) {
			allowSeparator = true
			isPreviousTokenSeparator = false
			scanner.pos++
			continue
		}
		break
	}
	if scanner.charCodeUnchecked(scanner.pos-1) == CharacterCodes_ {
		scanner.tokenFlags |= TokenFlagsContainsInvalidSeparator
		scanner.error(Diagnostics.Numeric_separators_are_not_allowed_here, scanner.pos-1, 1)
	}
	return result + scanner.text.substring(start, scanner.pos)
}

// Extract from Section 12.9.3
// NumericLiteral ::=
//
//	| DecimalLiteral
//	| DecimalBigIntegerLiteral
//	| NonDecimalIntegerLiteral 'n'?
//	| LegacyOctalIntegerLiteral
//
// DecimalBigIntegerLiteral ::=
//
//	| '0n'
//	| [1-9] DecimalDigits? 'n'
//	| [1-9] '_' DecimalDigits 'n'
//
// DecimalLiteral ::=
//
//	| DecimalIntegerLiteral '.' DecimalDigits? ExponentPart?
//	| '.' DecimalDigits ExponentPart?
//	| DecimalIntegerLiteral ExponentPart?
//
// DecimalIntegerLiteral ::=
//
//	| '0'
//	| [1-9] '_'? DecimalDigits
//	| NonOctalDecimalIntegerLiteral
//
// LegacyOctalIntegerLiteral ::= '0' [0-7]+
// NonOctalDecimalIntegerLiteral ::= '0' [0-7]* [89] [0-9]*
func (scanner *Scanner) scanNumber() SyntaxKind {
	start := scanner.pos
	var mainFragment string
	if scanner.charCodeUnchecked(scanner.pos) == CharacterCodes_0 {
		scanner.pos++
		if scanner.charCodeUnchecked(scanner.pos) == CharacterCodes_ {
			scanner.tokenFlags |= TokenFlagsContainsSeparator | TokenFlagsContainsInvalidSeparator
			scanner.error(Diagnostics.Numeric_separators_are_not_allowed_here, scanner.pos, 1)
			// treat it as a normal number literal
			scanner.pos--
			mainFragment = scanner.scanNumberFragment()
		} else if !scanner.scanDigits() {
			// NonOctalDecimalIntegerLiteral, emit error later
			// Separators in decimal and exponent parts are still allowed according to the spec
			scanner.tokenFlags |= TokenFlagsContainsLeadingZero
			mainFragment = "" + +scanner.tokenValue
		} else if !scanner.tokenValue {
			// a single zero
			mainFragment = "0"
		} else {
			// LegacyOctalIntegerLiteral
			scanner.tokenValue = "" + parseInt(scanner.tokenValue, 8)
			scanner.tokenFlags |= TokenFlagsOctal
			withMinus := scanner.token == SyntaxKindMinusToken
			literal := (__COND__(withMinus, "-", "")) + "0o" + (+scanner.tokenValue).toString(8)
			if withMinus {
				start--
			}
			scanner.error(Diagnostics.Octal_literals_are_not_allowed_Use_the_syntax_0, start, scanner.pos-start, literal)
			return SyntaxKindNumericLiteral
		}
	} else {
		mainFragment = scanner.scanNumberFragment()
	}
	var decimalFragment *string
	var scientificFragment *string
	if scanner.charCodeUnchecked(scanner.pos) == CharacterCodesdot {
		scanner.pos++
		decimalFragment = scanner.scanNumberFragment()
	}
	end := scanner.pos
	if scanner.charCodeUnchecked(scanner.pos) == CharacterCodesE || scanner.charCodeUnchecked(scanner.pos) == CharacterCodese {
		scanner.pos++
		scanner.tokenFlags |= TokenFlagsScientific
		if scanner.charCodeUnchecked(scanner.pos) == CharacterCodesplus || scanner.charCodeUnchecked(scanner.pos) == CharacterCodesminus {
			scanner.pos++
		}
		preNumericPart := scanner.pos
		finalFragment := scanner.scanNumberFragment()
		if !finalFragment {
			scanner.error(Diagnostics.Digit_expected)
		} else {
			scientificFragment = scanner.text.substring(end, preNumericPart) + finalFragment
			end = scanner.pos
		}
	}
	var result string
	if scanner.tokenFlags & TokenFlagsContainsSeparator {
		result = mainFragment
		if decimalFragment {
			result += "." + decimalFragment
		}
		if scientificFragment {
			result += scientificFragment
		}
	} else {
		result = scanner.text.substring(start, end)
		// No need to use all the fragments; no _ removal needed
	}

	if scanner.tokenFlags & TokenFlagsContainsLeadingZero {
		scanner.error(Diagnostics.Decimals_with_leading_zeros_are_not_allowed, start, end-start)
		// if a literal has a leading zero, it must not be bigint
		scanner.tokenValue = "" + +result
		return SyntaxKindNumericLiteral
	}

	if decimalFragment != nil || scanner.tokenFlags&TokenFlagsScientific {
		scanner.checkForIdentifierStartAfterNumericLiteral(start, decimalFragment == nil && !!(scanner.tokenFlags&TokenFlagsScientific))
		// if value is not an integer, it can be safely coerced to a number
		scanner.tokenValue = "" + +result
		return SyntaxKindNumericLiteral
	} else {
		scanner.tokenValue = result
		type_ := scanner.checkBigIntSuffix()
		// if value is an integer, check whether it is a bigint
		scanner.checkForIdentifierStartAfterNumericLiteral(start)
		return type_
	}
}

func (scanner *Scanner) checkForIdentifierStartAfterNumericLiteral(numericStart number, isScientific bool) {
	if !isIdentifierStart(scanner.codePointUnchecked(scanner.pos), languageVersion) {
		return
	}

	identifierStart := scanner.pos
	TODO_IDENTIFIER := scanner.scanIdentifierParts()

	if length == 1 && scanner.text[identifierStart] == "n" {
		if isScientific {
			scanner.error(Diagnostics.A_bigint_literal_cannot_use_exponential_notation, numericStart, identifierStart-numericStart+1)
		} else {
			scanner.error(Diagnostics.A_bigint_literal_must_be_an_integer, numericStart, identifierStart-numericStart+1)
		}
	} else {
		scanner.error(Diagnostics.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal, identifierStart, length)
		scanner.pos = identifierStart
	}
}

func (scanner *Scanner) scanDigits() bool {
	start := scanner.pos
	isOctal := true
	for isDigit(scanner.charCodeChecked(scanner.pos)) {
		if !isOctalDigit(scanner.charCodeUnchecked(scanner.pos)) {
			isOctal = false
		}
		scanner.pos++
	}
	scanner.tokenValue = scanner.text.substring(start, scanner.pos)
	return isOctal
}

/**
 * Scans the given number of hexadecimal digits in the text,
 * returning -1 if the given number is unavailable.
 */

func (scanner *Scanner) scanExactNumberOfHexDigits(count number, canHaveSeparators bool) number {
	valueString := scanner.scanHexDigits(count /*scanAsManyAsPossible*/, false, canHaveSeparators)
	if valueString {
		return parseInt(valueString, 16)
	} else {
		return -1
	}
}

/**
 * Scans as many hexadecimal digits as are available in the text,
 * returning "" if the given number of digits was unavailable.
 */

func (scanner *Scanner) scanMinimumNumberOfHexDigits(count number, canHaveSeparators bool) string {
	return scanner.scanHexDigits(count /*scanAsManyAsPossible*/, true, canHaveSeparators)
}

func (scanner *Scanner) scanHexDigits(minCount number, scanAsManyAsPossible bool, canHaveSeparators bool) string {
	var valueChars []number = []never{}
	allowSeparator := false
	isPreviousTokenSeparator := false
	for valueChars.length < minCount || scanAsManyAsPossible {
		ch := scanner.charCodeUnchecked(scanner.pos)
		if canHaveSeparators && ch == CharacterCodes_ {
			scanner.tokenFlags |= TokenFlagsContainsSeparator
			if allowSeparator {
				allowSeparator = false
				isPreviousTokenSeparator = true
			} else if isPreviousTokenSeparator {
				scanner.error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, scanner.pos, 1)
			} else {
				scanner.error(Diagnostics.Numeric_separators_are_not_allowed_here, scanner.pos, 1)
			}
			scanner.pos++
			continue
		}
		allowSeparator = canHaveSeparators
		if ch >= CharacterCodesA && ch <= CharacterCodesF {
			ch += CharacterCodesa - CharacterCodesA
			// standardize hex literals to lowercase
		} else if !((ch >= CharacterCodes_0 && ch <= CharacterCodes_9) || (ch >= CharacterCodesa && ch <= CharacterCodesf)) {
			break
		}
		valueChars.push(ch)
		scanner.pos++
		isPreviousTokenSeparator = false
	}
	if valueChars.length < minCount {
		valueChars = []never{}
	}
	if scanner.charCodeUnchecked(scanner.pos-1) == CharacterCodes_ {
		scanner.error(Diagnostics.Numeric_separators_are_not_allowed_here, scanner.pos-1, 1)
	}
	return String.fromCharCode(valueChars...)
}

func (scanner *Scanner) scanString(jsxAttributeString bool /*  = false */) string {
	quote := scanner.charCodeUnchecked(scanner.pos)
	scanner.pos++
	result := ""
	start := scanner.pos
	for true {
		if scanner.pos >= scanner.end {
			result += scanner.text.substring(start, scanner.pos)
			scanner.tokenFlags |= TokenFlagsUnterminated
			scanner.error(Diagnostics.Unterminated_string_literal)
			break
		}
		ch := scanner.charCodeUnchecked(scanner.pos)
		if ch == quote {
			result += scanner.text.substring(start, scanner.pos)
			scanner.pos++
			break
		}
		if ch == CharacterCodesbackslash && !jsxAttributeString {
			result += scanner.text.substring(start, scanner.pos)
			result += scanner.scanEscapeSequence(EscapeSequenceScanningFlagsString | EscapeSequenceScanningFlagsReportErrors)
			start = scanner.pos
			continue
		}

		if (ch == CharacterCodeslineFeed || ch == CharacterCodescarriageReturn) && !jsxAttributeString {
			result += scanner.text.substring(start, scanner.pos)
			scanner.tokenFlags |= TokenFlagsUnterminated
			scanner.error(Diagnostics.Unterminated_string_literal)
			break
		}
		scanner.pos++
	}
	return result
}

/**
 * Sets the current 'tokenValue' and returns a NoSubstitutionTemplateLiteral or
 * a literal component of a TemplateExpression.
 */

func (scanner *Scanner) scanTemplateAndSetTokenValue(shouldEmitInvalidEscapeError bool) SyntaxKind {
	startedWithBacktick := scanner.charCodeUnchecked(scanner.pos) == CharacterCodesbacktick

	scanner.pos++
	start := scanner.pos
	contents := ""
	var resultingToken SyntaxKind

	for true {
		if scanner.pos >= scanner.end {
			contents += scanner.text.substring(start, scanner.pos)
			scanner.tokenFlags |= TokenFlagsUnterminated
			scanner.error(Diagnostics.Unterminated_template_literal)
			if startedWithBacktick {
				resultingToken = SyntaxKindNoSubstitutionTemplateLiteral
			} else {
				resultingToken = SyntaxKindTemplateTail
			}
			break
		}

		currChar := scanner.charCodeUnchecked(scanner.pos)

		// '`'
		if currChar == CharacterCodesbacktick {
			contents += scanner.text.substring(start, scanner.pos)
			scanner.pos++
			if startedWithBacktick {
				resultingToken = SyntaxKindNoSubstitutionTemplateLiteral
			} else {
				resultingToken = SyntaxKindTemplateTail
			}
			break
		}

		// '${'
		if currChar == CharacterCodes_DOLLAR_ && scanner.pos+1 < scanner.end && scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesopenBrace {
			contents += scanner.text.substring(start, scanner.pos)
			scanner.pos += 2
			if startedWithBacktick {
				resultingToken = SyntaxKindTemplateHead
			} else {
				resultingToken = SyntaxKindTemplateMiddle
			}
			break
		}

		// Escape character
		if currChar == CharacterCodesbackslash {
			contents += scanner.text.substring(start, scanner.pos)
			contents += scanner.scanEscapeSequence(EscapeSequenceScanningFlagsString | (__COND__(shouldEmitInvalidEscapeError, EscapeSequenceScanningFlagsReportErrors, 0)))
			start = scanner.pos
			continue
		}

		// Speculated ECMAScript 6 Spec 11.8.6.1:
		// <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for Template Values
		if currChar == CharacterCodescarriageReturn {
			contents += scanner.text.substring(start, scanner.pos)
			scanner.pos++

			if scanner.pos < scanner.end && scanner.charCodeUnchecked(scanner.pos) == CharacterCodeslineFeed {
				scanner.pos++
			}

			contents += "\n"
			start = scanner.pos
			continue
		}

		scanner.pos++
	}

	Debug.assert(resultingToken != nil)

	scanner.tokenValue = contents
	return resultingToken
}

// Extract from Section A.1
// EscapeSequence ::=
//
//	| CharacterEscapeSequence
//	| 0 (?![0-9])
//	| LegacyOctalEscapeSequence
//	| NonOctalDecimalEscapeSequence
//	| HexEscapeSequence
//	| UnicodeEscapeSequence
//
// LegacyOctalEscapeSequence ::=
//
//	| '0' (?=[89])
//	| [1-7] (?![0-7])
//	| [0-3] [0-7] [0-7]?
//	| [4-7] [0-7]
//
// NonOctalDecimalEscapeSequence ::= [89]
func (scanner *Scanner) scanEscapeSequence(flags EscapeSequenceScanningFlags) string {
	start := scanner.pos
	scanner.pos++
	if scanner.pos >= scanner.end {
		scanner.error(Diagnostics.Unexpected_end_of_text)
		return ""
	}
	ch := scanner.charCodeUnchecked(scanner.pos)
	scanner.pos++
	switch ch {
	case CharacterCodes_0:
		if scanner.pos >= scanner.end || !isDigit(scanner.charCodeUnchecked(scanner.pos)) {
			return "\u0000"
		}
		fallthrough
	case CharacterCodes_1,
		CharacterCodes_2,
		CharacterCodes_3:
		if scanner.pos < scanner.end && isOctalDigit(scanner.charCodeUnchecked(scanner.pos)) {
			scanner.pos++
		}
		fallthrough
	case CharacterCodes_4,
		CharacterCodes_5,
		CharacterCodes_6,
		CharacterCodes_7:
		if scanner.pos < scanner.end && isOctalDigit(scanner.charCodeUnchecked(scanner.pos)) {
			scanner.pos++
		}
		scanner.tokenFlags |= TokenFlagsContainsInvalidEscape
		if flags & EscapeSequenceScanningFlagsReportInvalidEscapeErrors {
			code := parseInt(scanner.text.substring(start+1, scanner.pos), 8)
			if flags&EscapeSequenceScanningFlagsRegularExpression && !(flags & EscapeSequenceScanningFlagsAtomEscape) && ch != CharacterCodes_0 {
				scanner.error(Diagnostics.Octal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class_If_this_was_intended_as_an_escape_sequence_use_the_syntax_0_instead, start, scanner.pos-start, "\\x"+code.toString(16).padStart(2, "0"))
			} else {
				scanner.error(Diagnostics.Octal_escape_sequences_are_not_allowed_Use_the_syntax_0, start, scanner.pos-start, "\\x"+code.toString(16).padStart(2, "0"))
			}
			return String.fromCharCode(code)
		}
		return scanner.text.substring(start, scanner.pos)
	case CharacterCodes_8,
		CharacterCodes_9:
		scanner.tokenFlags |= TokenFlagsContainsInvalidEscape
		if flags & EscapeSequenceScanningFlagsReportInvalidEscapeErrors {
			if flags&EscapeSequenceScanningFlagsRegularExpression && !(flags & EscapeSequenceScanningFlagsAtomEscape) {
				scanner.error(Diagnostics.Decimal_escape_sequences_and_backreferences_are_not_allowed_in_a_character_class, start, scanner.pos-start)
			} else {
				scanner.error(Diagnostics.Escape_sequence_0_is_not_allowed, start, scanner.pos-start, scanner.text.substring(start, scanner.pos))
			}
			return String.fromCharCode(ch)
		}
		return scanner.text.substring(start, scanner.pos)
	case CharacterCodesb:
		return "\b"
	case CharacterCodest:
		return "\t"
	case CharacterCodesn:
		return "\n"
	case CharacterCodesv:
		return "\u000b"
	case CharacterCodesf:
		return "\f"
	case CharacterCodesr:
		return "\r"
	case CharacterCodessingleQuote:
		return "'"
	case CharacterCodesdoubleQuote:
		return "\""
	case CharacterCodesu:
		if scanner.pos < scanner.end && scanner.charCodeUnchecked(scanner.pos) == CharacterCodesopenBrace {
			// '\u{DDDDDD}'
			scanner.pos -= 2
			result := scanner.scanExtendedUnicodeEscape(!!(flags & EscapeSequenceScanningFlagsReportInvalidEscapeErrors))
			if !(flags & EscapeSequenceScanningFlagsAllowExtendedUnicodeEscape) {
				scanner.tokenFlags |= TokenFlagsContainsInvalidEscape
				if flags & EscapeSequenceScanningFlagsReportInvalidEscapeErrors {
					scanner.error(Diagnostics.Unicode_escape_sequences_are_only_available_when_the_Unicode_u_flag_or_the_Unicode_Sets_v_flag_is_set, start, scanner.pos-start)
				}
			}
			return result
		}
		for ; scanner.pos < start+6; scanner.pos++ {
			if !(scanner.pos < scanner.end && isHexDigit(scanner.charCodeUnchecked(scanner.pos))) {
				scanner.tokenFlags |= TokenFlagsContainsInvalidEscape
				if flags & EscapeSequenceScanningFlagsReportInvalidEscapeErrors {
					scanner.error(Diagnostics.Hexadecimal_digit_expected)
				}
				return scanner.text.substring(start, scanner.pos)
			}
		}
		scanner.tokenFlags |= TokenFlagsUnicodeEscape
		escapedValue := parseInt(scanner.text.substring(start+2, scanner.pos), 16)
		escapedValueString := String.fromCharCode(escapedValue)
		if flags&EscapeSequenceScanningFlagsAnyUnicodeMode && escapedValue >= 0xD800 && escapedValue <= 0xDBFF && scanner.pos+6 < scanner.end && scanner.text.substring(scanner.pos, scanner.pos+2) == "\\u" && scanner.charCodeUnchecked(scanner.pos+2) != CharacterCodesopenBrace {
			// For regular expressions in any Unicode mode, \u HexLeadSurrogate \u HexTrailSurrogate is treated as a single character
			// for the purpose of determining whether a character class range is out of order
			// https://tc39.es/ecma262/#prod-RegExpUnicodeEscapeSequence
			nextStart := scanner.pos
			nextPos := scanner.pos + 2
			for ; nextPos < nextStart+6; nextPos++ {
				if !isHexDigit(scanner.charCodeUnchecked(nextPos)) {
					// leave the error to the next call
					return escapedValueString
				}
			}
			nextEscapedValue := parseInt(scanner.text.substring(nextStart+2, nextPos), 16)
			if nextEscapedValue >= 0xDC00 && nextEscapedValue <= 0xDFFF {
				scanner.pos = nextPos
				return escapedValueString + String.fromCharCode(nextEscapedValue)
			}
		}
		return escapedValueString
	case CharacterCodesx:
		for ; scanner.pos < start+4; scanner.pos++ {
			if !(scanner.pos < scanner.end && isHexDigit(scanner.charCodeUnchecked(scanner.pos))) {
				scanner.tokenFlags |= TokenFlagsContainsInvalidEscape
				if flags & EscapeSequenceScanningFlagsReportInvalidEscapeErrors {
					scanner.error(Diagnostics.Hexadecimal_digit_expected)
				}
				return scanner.text.substring(start, scanner.pos)
			}
		}
		scanner.tokenFlags |= TokenFlagsHexEscape
		return String.fromCharCode(parseInt(scanner.text.substring(start+2, scanner.pos), 16))
	case CharacterCodescarriageReturn:
		if scanner.pos < scanner.end && scanner.charCodeUnchecked(scanner.pos) == CharacterCodeslineFeed {
			scanner.pos++
		}
		fallthrough
	case CharacterCodeslineFeed,
		CharacterCodeslineSeparator,
		CharacterCodesparagraphSeparator:
		return ""
	default:
		if flags&EscapeSequenceScanningFlagsAnyUnicodeMode || flags&EscapeSequenceScanningFlagsRegularExpression && !(flags&EscapeSequenceScanningFlagsAnnexB) && isIdentifierPart(ch, languageVersion) {
			scanner.error(Diagnostics.This_character_cannot_be_escaped_in_a_regular_expression, scanner.pos-2, 2)
		}
		return String.fromCharCode(ch)
	}
}

func (scanner *Scanner) scanExtendedUnicodeEscape(shouldEmitInvalidEscapeError bool) string {
	start := scanner.pos
	scanner.pos += 3
	escapedStart := scanner.pos
	escapedValueString := scanner.scanMinimumNumberOfHexDigits(1 /*canHaveSeparators*/, false)
	var escapedValue number
	if escapedValueString {
		escapedValue = parseInt(escapedValueString, 16)
	} else {
		escapedValue = -1
	}
	isInvalidExtendedEscape := false

	// Validate the value of the digit
	if escapedValue < 0 {
		if shouldEmitInvalidEscapeError {
			scanner.error(Diagnostics.Hexadecimal_digit_expected)
		}
		isInvalidExtendedEscape = true
	} else if escapedValue > 0x10FFFF {
		if shouldEmitInvalidEscapeError {
			scanner.error(Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive, escapedStart, scanner.pos-escapedStart)
		}
		isInvalidExtendedEscape = true
	}

	if scanner.pos >= scanner.end {
		if shouldEmitInvalidEscapeError {
			scanner.error(Diagnostics.Unexpected_end_of_text)
		}
		isInvalidExtendedEscape = true
	} else if scanner.charCodeUnchecked(scanner.pos) == CharacterCodescloseBrace {
		// Only swallow the following character up if it's a '}'.
		scanner.pos++
	} else {
		if shouldEmitInvalidEscapeError {
			scanner.error(Diagnostics.Unterminated_Unicode_escape_sequence)
		}
		isInvalidExtendedEscape = true
	}

	if isInvalidExtendedEscape {
		scanner.tokenFlags |= TokenFlagsContainsInvalidEscape
		return scanner.text.substring(start, scanner.pos)
	}

	scanner.tokenFlags |= TokenFlagsExtendedUnicodeEscape
	return utf16EncodeAsString(escapedValue)
}

// Current character is known to be a backslash. Check for Unicode escape of the form '\uXXXX'
// and return code point value if valid Unicode escape is found. Otherwise return -1.
func (scanner *Scanner) peekUnicodeEscape() number {
	if scanner.pos+5 < scanner.end && scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesu {
		start := scanner.pos
		scanner.pos += 2
		value := scanner.scanExactNumberOfHexDigits(4 /*canHaveSeparators*/, false)
		scanner.pos = start
		return value
	}
	return -1
}

func (scanner *Scanner) peekExtendedUnicodeEscape() number {
	if scanner.codePointUnchecked(scanner.pos+1) == CharacterCodesu && scanner.codePointUnchecked(scanner.pos+2) == CharacterCodesopenBrace {
		start := scanner.pos
		scanner.pos += 3
		escapedValueString := scanner.scanMinimumNumberOfHexDigits(1 /*canHaveSeparators*/, false)
		var escapedValue number
		if escapedValueString {
			escapedValue = parseInt(escapedValueString, 16)
		} else {
			escapedValue = -1
		}
		scanner.pos = start
		return escapedValue
	}
	return -1
}

func (scanner *Scanner) scanIdentifierParts() string {
	result := ""
	start := scanner.pos
	for scanner.pos < scanner.end {
		ch := scanner.codePointUnchecked(scanner.pos)
		if isIdentifierPart(ch, languageVersion) {
			scanner.pos += charSize(ch)
		} else if ch == CharacterCodesbackslash {
			ch = scanner.peekExtendedUnicodeEscape()
			if ch >= 0 && isIdentifierPart(ch, languageVersion) {
				result += scanner.scanExtendedUnicodeEscape(true)
				start = scanner.pos
				continue
			}
			ch = scanner.peekUnicodeEscape()
			if !(ch >= 0 && isIdentifierPart(ch, languageVersion)) {
				break
			}
			scanner.tokenFlags |= TokenFlagsUnicodeEscape
			result += scanner.text.substring(start, scanner.pos)
			result += utf16EncodeAsString(ch)
			// Valid Unicode escape is always six characters
			scanner.pos += 6
			start = scanner.pos
		} else {
			break
		}
	}
	result += scanner.text.substring(start, scanner.pos)
	return result
}

func (scanner *Scanner) getIdentifierToken() /* TODO(TS-TO-GO) TypeNode UnionType: SyntaxKind.Identifier | KeywordSyntaxKind */ any {
	// Reserved words are between 2 and 12 characters long and start with a lowercase letter
	len := scanner.tokenValue.length
	if len >= 2 && len <= 12 {
		ch := scanner.tokenValue.charCodeAt(0)
		if ch >= CharacterCodesa && ch <= CharacterCodesz {
			keyword := textToKeyword.get(scanner.tokenValue)
			if keyword != nil {
				scanner.token = keyword
				return scanner.token
			}
		}
	}
	scanner.token = SyntaxKindIdentifier
	return scanner.token
}

func (scanner *Scanner) scanBinaryOrOctalDigits(base /* TODO(TS-TO-GO) TypeNode UnionType: 2 | 8 */ any) string {
	value := ""
	// For counting number of digits; Valid binaryIntegerLiteral must have at least one binary digit following B or b.
	// Similarly valid octalIntegerLiteral must have at least one octal digit following o or O.
	separatorAllowed := false
	isPreviousTokenSeparator := false
	for true {
		ch := scanner.charCodeUnchecked(scanner.pos)
		// Numeric separators are allowed anywhere within a numeric literal, except not at the beginning, or following another separator
		if ch == CharacterCodes_ {
			scanner.tokenFlags |= TokenFlagsContainsSeparator
			if separatorAllowed {
				separatorAllowed = false
				isPreviousTokenSeparator = true
			} else if isPreviousTokenSeparator {
				scanner.error(Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, scanner.pos, 1)
			} else {
				scanner.error(Diagnostics.Numeric_separators_are_not_allowed_here, scanner.pos, 1)
			}
			scanner.pos++
			continue
		}
		separatorAllowed = true
		if !isDigit(ch) || ch-CharacterCodes_0 >= base {
			break
		}
		value += scanner.text[scanner.pos]
		scanner.pos++
		isPreviousTokenSeparator = false
	}
	if scanner.charCodeUnchecked(scanner.pos-1) == CharacterCodes_ {
		// Literal ends with underscore - not allowed
		scanner.error(Diagnostics.Numeric_separators_are_not_allowed_here, scanner.pos-1, 1)
	}
	return value
}

func (scanner *Scanner) checkBigIntSuffix() SyntaxKind {
	if scanner.charCodeUnchecked(scanner.pos) == CharacterCodesn {
		scanner.tokenValue += "n"
		// Use base 10 instead of base 2 or base 8 for shorter literals
		if scanner.tokenFlags & TokenFlagsBinaryOrOctalSpecifier {
			scanner.tokenValue = parsePseudoBigInt(scanner.tokenValue) + "n"
		}
		scanner.pos++
		return SyntaxKindBigIntLiteral
	} else {
		// Number() may not support 0b or 0o, so use parseInt() instead
		var numericValue number
		switch {
		case scanner.tokenFlags & TokenFlagsBinarySpecifier:
			numericValue = parseInt(scanner.tokenValue.slice(2), 2)
		case scanner.tokenFlags & TokenFlagsOctalSpecifier:
			numericValue = parseInt(scanner.tokenValue.slice(2), 8)
		default:
			numericValue = +scanner.tokenValue
		}
		scanner.tokenValue = "" + numericValue
		return SyntaxKindNumericLiteral
	}
}

func (scanner *Scanner) scan() SyntaxKind {
	scanner.fullStartPos = scanner.pos
	scanner.tokenFlags = TokenFlagsNone
	for true {
		scanner.tokenStart = scanner.pos
		if scanner.pos >= scanner.end {
			scanner.token = SyntaxKindEndOfFileToken
			return scanner.token
		}

		ch := scanner.codePointUnchecked(scanner.pos)
		if scanner.pos == 0 {
			// Special handling for shebang
			if ch == CharacterCodeshash && isShebangTrivia(scanner.text, scanner.pos) {
				scanner.pos = scanShebangTrivia(scanner.text, scanner.pos)
				if skipTrivia {
					continue
				} else {
					scanner.token = SyntaxKindShebangTrivia
					return scanner.token
				}
			}
		}

		switch ch {
		case CharacterCodeslineFeed,
			CharacterCodescarriageReturn:
			scanner.tokenFlags |= TokenFlagsPrecedingLineBreak
			if skipTrivia {
				scanner.pos++
				continue
			} else {
				if ch == CharacterCodescarriageReturn && scanner.pos+1 < scanner.end && scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodeslineFeed {
					// consume both CR and LF
					scanner.pos += 2
				} else {
					scanner.pos++
				}
				scanner.token = SyntaxKindNewLineTrivia
				return scanner.token
			}
			fallthrough
		case CharacterCodestab,
			CharacterCodesverticalTab,
			CharacterCodesformFeed,
			CharacterCodesspace,
			CharacterCodesnonBreakingSpace,
			CharacterCodesogham,
			CharacterCodesenQuad,
			CharacterCodesemQuad,
			CharacterCodesenSpace,
			CharacterCodesemSpace,
			CharacterCodesthreePerEmSpace,
			CharacterCodesfourPerEmSpace,
			CharacterCodessixPerEmSpace,
			CharacterCodesfigureSpace,
			CharacterCodespunctuationSpace,
			CharacterCodesthinSpace,
			CharacterCodeshairSpace,
			CharacterCodeszeroWidthSpace,
			CharacterCodesnarrowNoBreakSpace,
			CharacterCodesmathematicalSpace,
			CharacterCodesideographicSpace,
			CharacterCodesbyteOrderMark:
			if skipTrivia {
				scanner.pos++
				continue
			} else {
				for scanner.pos < scanner.end && isWhiteSpaceSingleLine(scanner.charCodeUnchecked(scanner.pos)) {
					scanner.pos++
				}
				scanner.token = SyntaxKindWhitespaceTrivia
				return scanner.token
			}
			fallthrough
		case CharacterCodesexclamation:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.ExclamationEqualsEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.ExclamationEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindExclamationToken
			return scanner.token
		case CharacterCodesdoubleQuote,
			CharacterCodessingleQuote:
			scanner.tokenValue = scanner.scanString()
			scanner.token = SyntaxKindStringLiteral
			return scanner.token
		case CharacterCodesbacktick:
			scanner.token = scanner.scanTemplateAndSetTokenValue(false)
			return scanner.token
		case CharacterCodespercent:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.PercentEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindPercentToken
			return scanner.token
		case CharacterCodesampersand:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesampersand {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.AmpersandAmpersandEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.AmpersandAmpersandToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.AmpersandEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindAmpersandToken
			return scanner.token
		case CharacterCodesopenParen:
			scanner.pos++
			scanner.token = SyntaxKindOpenParenToken
			return scanner.token
		case CharacterCodescloseParen:
			scanner.pos++
			scanner.token = SyntaxKindCloseParenToken
			return scanner.token
		case CharacterCodesasterisk:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.AsteriskEqualsToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesasterisk {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.AsteriskAsteriskEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.AsteriskAsteriskToken */ TODO
			}
			scanner.pos++
			if scanner.skipJsDocLeadingAsterisks && (scanner.tokenFlags&TokenFlagsPrecedingJSDocLeadingAsterisks) == 0 && (scanner.tokenFlags & TokenFlagsPrecedingLineBreak) {
				// decoration at the start of a JSDoc comment line
				scanner.tokenFlags |= TokenFlagsPrecedingJSDocLeadingAsterisks
				continue
			}
			scanner.token = SyntaxKindAsteriskToken
			return scanner.token
		case CharacterCodesplus:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesplus {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.PlusPlusToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.PlusEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindPlusToken
			return scanner.token
		case CharacterCodescomma:
			scanner.pos++
			scanner.token = SyntaxKindCommaToken
			return scanner.token
		case CharacterCodesminus:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesminus {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.MinusMinusToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.MinusEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindMinusToken
			return scanner.token
		case CharacterCodesdot:
			if isDigit(scanner.charCodeUnchecked(scanner.pos + 1)) {
				scanner.scanNumber()
				scanner.token = SyntaxKindNumericLiteral
				return scanner.token
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesdot && scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesdot {
				scanner.pos += 3
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.DotDotDotToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindDotToken
			return scanner.token
		case CharacterCodesslash:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesslash {
				scanner.pos += 2

				for scanner.pos < scanner.end {
					if isLineBreak(scanner.charCodeUnchecked(scanner.pos)) {
						break
					}
					scanner.pos++
				}

				scanner.commentDirectives = scanner.appendIfCommentDirective(scanner.commentDirectives, scanner.text.slice(scanner.tokenStart, scanner.pos), commentDirectiveRegExSingleLine, scanner.tokenStart)

				if skipTrivia {
					continue
				} else {
					scanner.token = SyntaxKindSingleLineCommentTrivia
					return scanner.token
				}
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesasterisk {
				scanner.pos += 2
				isJSDoc := scanner.charCodeUnchecked(scanner.pos) == CharacterCodesasterisk && scanner.charCodeUnchecked(scanner.pos+1) != CharacterCodesslash

				commentClosed := false
				lastLineStart := scanner.tokenStart
				for scanner.pos < scanner.end {
					ch := scanner.charCodeUnchecked(scanner.pos)

					if ch == CharacterCodesasterisk && scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesslash {
						scanner.pos += 2
						commentClosed = true
						break
					}

					scanner.pos++

					if isLineBreak(ch) {
						lastLineStart = scanner.pos
						scanner.tokenFlags |= TokenFlagsPrecedingLineBreak
					}
				}

				if isJSDoc && scanner.shouldParseJSDoc() {
					scanner.tokenFlags |= TokenFlagsPrecedingJSDocComment
				}

				scanner.commentDirectives = scanner.appendIfCommentDirective(scanner.commentDirectives, scanner.text.slice(lastLineStart, scanner.pos), commentDirectiveRegExMultiLine, lastLineStart)

				if !commentClosed {
					scanner.error(Diagnostics.Asterisk_Slash_expected)
				}

				if skipTrivia {
					continue
				} else {
					if !commentClosed {
						scanner.tokenFlags |= TokenFlagsUnterminated
					}
					scanner.token = SyntaxKindMultiLineCommentTrivia
					return scanner.token
				}
			}

			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.SlashEqualsToken */ TODO
			}

			scanner.pos++
			scanner.token = SyntaxKindSlashToken
			return scanner.token
		case CharacterCodes_0:
			if scanner.pos+2 < scanner.end && (scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesX || scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesx) {
				scanner.pos += 2
				scanner.tokenValue = scanner.scanMinimumNumberOfHexDigits(1 /*canHaveSeparators*/, true)
				if !scanner.tokenValue {
					scanner.error(Diagnostics.Hexadecimal_digit_expected)
					scanner.tokenValue = "0"
				}
				scanner.tokenValue = "0x" + scanner.tokenValue
				scanner.tokenFlags |= TokenFlagsHexSpecifier
				scanner.token = scanner.checkBigIntSuffix()
				return scanner.token
			} else if scanner.pos+2 < scanner.end && (scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesB || scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesb) {
				scanner.pos += 2
				scanner.tokenValue = scanner.scanBinaryOrOctalDigits(2)
				if !scanner.tokenValue {
					scanner.error(Diagnostics.Binary_digit_expected)
					scanner.tokenValue = "0"
				}
				scanner.tokenValue = "0b" + scanner.tokenValue
				scanner.tokenFlags |= TokenFlagsBinarySpecifier
				scanner.token = scanner.checkBigIntSuffix()
				return scanner.token
			} else if scanner.pos+2 < scanner.end && (scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesO || scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodeso) {
				scanner.pos += 2
				scanner.tokenValue = scanner.scanBinaryOrOctalDigits(8)
				if !scanner.tokenValue {
					scanner.error(Diagnostics.Octal_digit_expected)
					scanner.tokenValue = "0"
				}
				scanner.tokenValue = "0o" + scanner.tokenValue
				scanner.tokenFlags |= TokenFlagsOctalSpecifier
				scanner.token = scanner.checkBigIntSuffix()
				return scanner.token
			}
			fallthrough
		case CharacterCodes_1,
			CharacterCodes_2,
			CharacterCodes_3,
			CharacterCodes_4,
			CharacterCodes_5,
			CharacterCodes_6,
			CharacterCodes_7,
			CharacterCodes_8,
			CharacterCodes_9:
			scanner.token = scanner.scanNumber()
			return scanner.token
		case CharacterCodescolon:
			scanner.pos++
			scanner.token = SyntaxKindColonToken
			return scanner.token
		case CharacterCodessemicolon:
			scanner.pos++
			scanner.token = SyntaxKindSemicolonToken
			return scanner.token
		case CharacterCodeslessThan:
			if isConflictMarkerTrivia(scanner.text, scanner.pos) {
				scanner.pos = scanConflictMarkerTrivia(scanner.text, scanner.pos, scanner.error)
				if skipTrivia {
					continue
				} else {
					scanner.token = SyntaxKindConflictMarkerTrivia
					return scanner.token
				}
			}

			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodeslessThan {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.LessThanLessThanEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.LessThanLessThanToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.LessThanEqualsToken */ TODO
			}
			if languageVariant == LanguageVariantJSX && scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesslash && scanner.charCodeUnchecked(scanner.pos+2) != CharacterCodesasterisk {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.LessThanSlashToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindLessThanToken
			return scanner.token
		case CharacterCodesequals:
			if isConflictMarkerTrivia(scanner.text, scanner.pos) {
				scanner.pos = scanConflictMarkerTrivia(scanner.text, scanner.pos, scanner.error)
				if skipTrivia {
					continue
				} else {
					scanner.token = SyntaxKindConflictMarkerTrivia
					return scanner.token
				}
			}

			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.EqualsEqualsEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.EqualsEqualsToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesgreaterThan {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.EqualsGreaterThanToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindEqualsToken
			return scanner.token
		case CharacterCodesgreaterThan:
			if isConflictMarkerTrivia(scanner.text, scanner.pos) {
				scanner.pos = scanConflictMarkerTrivia(scanner.text, scanner.pos, scanner.error)
				if skipTrivia {
					continue
				} else {
					scanner.token = SyntaxKindConflictMarkerTrivia
					return scanner.token
				}
			}

			scanner.pos++
			scanner.token = SyntaxKindGreaterThanToken
			return scanner.token
		case CharacterCodesquestion:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesdot && !isDigit(scanner.charCodeUnchecked(scanner.pos+2)) {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.QuestionDotToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesquestion {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.QuestionQuestionEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.QuestionQuestionToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindQuestionToken
			return scanner.token
		case CharacterCodesopenBracket:
			scanner.pos++
			scanner.token = SyntaxKindOpenBracketToken
			return scanner.token
		case CharacterCodescloseBracket:
			scanner.pos++
			scanner.token = SyntaxKindCloseBracketToken
			return scanner.token
		case CharacterCodescaret:
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.CaretEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindCaretToken
			return scanner.token
		case CharacterCodesopenBrace:
			scanner.pos++
			scanner.token = SyntaxKindOpenBraceToken
			return scanner.token
		case CharacterCodesbar:
			if isConflictMarkerTrivia(scanner.text, scanner.pos) {
				scanner.pos = scanConflictMarkerTrivia(scanner.text, scanner.pos, scanner.error)
				if skipTrivia {
					continue
				} else {
					scanner.token = SyntaxKindConflictMarkerTrivia
					return scanner.token
				}
			}

			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesbar {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.BarBarEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.BarBarToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.BarEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindBarToken
			return scanner.token
		case CharacterCodescloseBrace:
			scanner.pos++
			scanner.token = SyntaxKindCloseBraceToken
			return scanner.token
		case CharacterCodestilde:
			scanner.pos++
			scanner.token = SyntaxKindTildeToken
			return scanner.token
		case CharacterCodesat:
			scanner.pos++
			scanner.token = SyntaxKindAtToken
			return scanner.token
		case CharacterCodesbackslash:
			extendedCookedChar := scanner.peekExtendedUnicodeEscape()
			if extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion) {
				scanner.tokenValue = scanner.scanExtendedUnicodeEscape(true) + scanner.scanIdentifierParts()
				scanner.token = scanner.getIdentifierToken()
				return scanner.token
			}

			cookedChar := scanner.peekUnicodeEscape()
			if cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion) {
				scanner.pos += 6
				scanner.tokenFlags |= TokenFlagsUnicodeEscape
				scanner.tokenValue = String.fromCharCode(cookedChar) + scanner.scanIdentifierParts()
				scanner.token = scanner.getIdentifierToken()
				return scanner.token
			}

			scanner.error(Diagnostics.Invalid_character)
			scanner.pos++
			scanner.token = SyntaxKindUnknown
			return scanner.token
		case CharacterCodeshash:
			if scanner.pos != 0 && scanner.text[scanner.pos+1] == "!" {
				scanner.error(Diagnostics.can_only_be_used_at_the_start_of_a_file, scanner.pos, 2)
				scanner.pos++
				scanner.token = SyntaxKindUnknown
				return scanner.token
			}

			charAfterHash := scanner.codePointUnchecked(scanner.pos + 1)
			if charAfterHash == CharacterCodesbackslash {
				scanner.pos++
				extendedCookedChar := scanner.peekExtendedUnicodeEscape()
				if extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion) {
					scanner.tokenValue = "#" + scanner.scanExtendedUnicodeEscape(true) + scanner.scanIdentifierParts()
					scanner.token = SyntaxKindPrivateIdentifier
					return scanner.token
				}

				cookedChar := scanner.peekUnicodeEscape()
				if cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion) {
					scanner.pos += 6
					scanner.tokenFlags |= TokenFlagsUnicodeEscape
					scanner.tokenValue = "#" + String.fromCharCode(cookedChar) + scanner.scanIdentifierParts()
					scanner.token = SyntaxKindPrivateIdentifier
					return scanner.token
				}
				scanner.pos--
			}

			if isIdentifierStart(charAfterHash, languageVersion) {
				scanner.pos++
				// We're relying on scanIdentifier's behavior and adjusting the token kind after the fact.
				// Notably absent from this block is the fact that calling a function named "scanIdentifier",
				// but identifiers don't include '#', and that function doesn't deal with it at all.
				// This works because 'scanIdentifier' tries to reuse source characters and builds up substrings;
				// however, it starts at the 'tokenPos' which includes the '#', and will "accidentally" prepend the '#' for us.
				scanner.scanIdentifier(charAfterHash, languageVersion)
			} else {
				scanner.tokenValue = "#"
				scanner.error(Diagnostics.Invalid_character /* TODO(TS-TO-GO) Node PostfixUnaryExpression: pos++ */, TODO, charSize(ch))
			}
			scanner.token = SyntaxKindPrivateIdentifier
			return scanner.token
		case CharacterCodesreplacementCharacter:
			scanner.error(Diagnostics.File_appears_to_be_binary, 0, 0)
			scanner.pos = scanner.end
			scanner.token = SyntaxKindNonTextFileMarkerTrivia
			return scanner.token
		default:
			identifierKind := scanner.scanIdentifier(ch, languageVersion)
			if identifierKind {
				scanner.token = identifierKind
				return scanner.token
			} else if isWhiteSpaceSingleLine(ch) {
				scanner.pos += charSize(ch)
				continue
			} else if isLineBreak(ch) {
				scanner.tokenFlags |= TokenFlagsPrecedingLineBreak
				scanner.pos += charSize(ch)
				continue
			}
			size := charSize(ch)
			scanner.error(Diagnostics.Invalid_character, scanner.pos, size)
			scanner.pos += size
			scanner.token = SyntaxKindUnknown
			return scanner.token
		}
	}
}

func (scanner *Scanner) shouldParseJSDoc() bool {
	switch scanner.jsDocParsingMode {
	case JSDocParsingModeParseAll:
		return true
	case JSDocParsingModeParseNone:
		return false
	}

	if scanner.scriptKind != ScriptKindTS && scanner.scriptKind != ScriptKindTSX {
		// If outside of TS, we need JSDoc to get any type info.
		return true
	}

	if scanner.jsDocParsingMode == JSDocParsingModeParseForTypeInfo {
		// If we're in TS, but we don't need to produce reliable errors,
		// we don't need to parse to find @see or @link.
		return false
	}

	return jsDocSeeOrLink.test(scanner.text.slice(scanner.fullStartPos, scanner.pos))
}

func (scanner *Scanner) reScanInvalidIdentifier() SyntaxKind {
	Debug.assert(scanner.token == SyntaxKindUnknown, "'reScanInvalidIdentifier' should only be called when the current token is 'SyntaxKind.Unknown'.")
	scanner.pos = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: tokenStart = fullStartPos */ TODO
	scanner.tokenFlags = 0
	ch := scanner.codePointUnchecked(scanner.pos)
	identifierKind := scanner.scanIdentifier(ch, ScriptTargetESNext)
	if identifierKind {
		scanner.token = identifierKind
		return scanner.token
	}
	scanner.pos += charSize(ch)
	return scanner.token
	// Still `SyntaxKind.Unknown`
}

func (scanner *Scanner) scanIdentifier(startCharacter number, languageVersion ScriptTarget) * /* TODO(TS-TO-GO) inferred type SyntaxKind.Identifier | KeywordSyntaxKind */ any {
	ch := startCharacter
	if isIdentifierStart(ch, languageVersion) {
		scanner.pos += charSize(ch)
		for scanner.pos < scanner.end && isIdentifierPart( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: ch = codePointUnchecked(pos) */ TODO, languageVersion) {
			scanner.pos += charSize(ch)
		}
		scanner.tokenValue = scanner.text.substring(scanner.tokenStart, scanner.pos)
		if ch == CharacterCodesbackslash {
			scanner.tokenValue += scanner.scanIdentifierParts()
		}
		return scanner.getIdentifierToken()
	}
}

func (scanner *Scanner) reScanGreaterToken() SyntaxKind {
	if scanner.token == SyntaxKindGreaterThanToken {
		if scanner.charCodeUnchecked(scanner.pos) == CharacterCodesgreaterThan {
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesgreaterThan {
				if scanner.charCodeUnchecked(scanner.pos+2) == CharacterCodesequals {
					scanner.pos += 3
					return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */ TODO
				}
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.GreaterThanGreaterThanGreaterThanToken */ TODO
			}
			if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesequals {
				scanner.pos += 2
				return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: token = SyntaxKind.GreaterThanGreaterThanEqualsToken */ TODO
			}
			scanner.pos++
			scanner.token = SyntaxKindGreaterThanGreaterThanToken
			return scanner.token
		}
		if scanner.charCodeUnchecked(scanner.pos) == CharacterCodesequals {
			scanner.pos++
			scanner.token = SyntaxKindGreaterThanEqualsToken
			return scanner.token
		}
	}
	return scanner.token
}

func (scanner *Scanner) reScanAsteriskEqualsToken() SyntaxKind {
	Debug.assert(scanner.token == SyntaxKindAsteriskEqualsToken, "'reScanAsteriskEqualsToken' should only be called on a '*='")
	scanner.pos = scanner.tokenStart + 1
	scanner.token = SyntaxKindEqualsToken
	return scanner.token
}

func (scanner *Scanner) reScanSlashToken(reportErrors bool) SyntaxKind {
	if scanner.token == SyntaxKindSlashToken || scanner.token == SyntaxKindSlashEqualsToken {
		// Quickly get to the end of regex such that we know the flags
		startOfRegExpBody := scanner.tokenStart + 1
		scanner.pos = startOfRegExpBody
		inEscape := false
		namedCaptureGroups := false
		// Although nested character classes are allowed in Unicode Sets mode,
		// an unescaped slash is nevertheless invalid even in a character class in any Unicode mode.
		// This is indicated by Section 12.9.5 Regular Expression Literals of the specification,
		// where nested character classes are not considered at all. (A `[` RegularExpressionClassChar
		// does nothing in a RegularExpressionClass, and a `]` always closes the class.)
		// Additionally, parsing nested character classes will misinterpret regexes like `/[[]/`
		// as unterminated, consuming characters beyond the slash. (This even applies to `/[[]/v`,
		// which should be parsed as a well-terminated regex with an incomplete character class.)
		// Thus we must not handle nested character classes in the first pass.
		inCharacterClass := false
		for true {
			// If we reach the end of a file, or hit a newline, then this is an unterminated
			// regex.  Report error and return what we have so far.
			ch := scanner.charCodeChecked(scanner.pos)
			if ch == CharacterCodesEOF || isLineBreak(ch) {
				scanner.tokenFlags |= TokenFlagsUnterminated
				break
			}

			if inEscape {
				// Parsing an escape character;
				// reset the flag and just advance to the next char.
				inEscape = false
			} else if ch == CharacterCodesslash && !inCharacterClass {
				// A slash within a character class is permissible,
				// but in general it signals the end of the regexp literal.
				break
			} else if ch == CharacterCodesopenBracket {
				inCharacterClass = true
			} else if ch == CharacterCodesbackslash {
				inEscape = true
			} else if ch == CharacterCodescloseBracket {
				inCharacterClass = false
			} else if !inCharacterClass && ch == CharacterCodesopenParen && scanner.charCodeChecked(scanner.pos+1) == CharacterCodesquestion && scanner.charCodeChecked(scanner.pos+2) == CharacterCodeslessThan && scanner.charCodeChecked(scanner.pos+3) != CharacterCodesequals && scanner.charCodeChecked(scanner.pos+3) != CharacterCodesexclamation {
				namedCaptureGroups = true
			}
			scanner.pos++
		}
		endOfRegExpBody := scanner.pos
		if scanner.tokenFlags & TokenFlagsUnterminated {
			// Search for the nearest unbalanced bracket for better recovery. Since the expression is
			// invalid anyways, we take nested square brackets into consideration for the best guess.
			scanner.pos = startOfRegExpBody
			inEscape = false
			characterClassDepth := 0
			inDecimalQuantifier := false
			groupDepth := 0
			for scanner.pos < endOfRegExpBody {
				ch := scanner.charCodeUnchecked(scanner.pos)
				if inEscape {
					inEscape = false
				} else if ch == CharacterCodesbackslash {
					inEscape = true
				} else if ch == CharacterCodesopenBracket {
					characterClassDepth++
				} else if ch == CharacterCodescloseBracket && characterClassDepth {
					characterClassDepth--
				} else if !characterClassDepth {
					if ch == CharacterCodesopenBrace {
						inDecimalQuantifier = true
					} else if ch == CharacterCodescloseBrace && inDecimalQuantifier {
						inDecimalQuantifier = false
					} else if !inDecimalQuantifier {
						if ch == CharacterCodesopenParen {
							groupDepth++
						} else if ch == CharacterCodescloseParen && groupDepth {
							groupDepth--
						} else if ch == CharacterCodescloseParen || ch == CharacterCodescloseBracket || ch == CharacterCodescloseBrace {
							// We encountered an unbalanced bracket outside a character class. Treat this position as the end of regex.
							break
						}
					}
				}
				scanner.pos++
			}
			// Whitespaces and semicolons at the end are not likely to be part of the regex
			for isWhiteSpaceLike(scanner.charCodeChecked(scanner.pos-1)) || scanner.charCodeChecked(scanner.pos-1) == CharacterCodessemicolon {
				scanner.pos--
			}
			scanner.error(Diagnostics.Unterminated_regular_expression_literal, scanner.tokenStart, scanner.pos-scanner.tokenStart)
		} else {
			// Consume the slash character
			scanner.pos++
			regExpFlags := RegularExpressionFlagsNone
			for true {
				ch := scanner.codePointChecked(scanner.pos)
				if ch == CharacterCodesEOF || !isIdentifierPart(ch, languageVersion) {
					break
				}
				size := charSize(ch)
				if reportErrors {
					flag := characterCodeToRegularExpressionFlag(ch)
					if flag == nil {
						scanner.error(Diagnostics.Unknown_regular_expression_flag, scanner.pos, size)
					} else if regExpFlags & flag {
						scanner.error(Diagnostics.Duplicate_regular_expression_flag, scanner.pos, size)
					} else if ((regExpFlags | flag) & RegularExpressionFlagsAnyUnicodeMode) == RegularExpressionFlagsAnyUnicodeMode {
						scanner.error(Diagnostics.The_Unicode_u_flag_and_the_Unicode_Sets_v_flag_cannot_be_set_simultaneously, scanner.pos, size)
					} else {
						regExpFlags |= flag
						scanner.checkRegularExpressionFlagAvailability(flag, size)
					}
				}
				scanner.pos += size
			}
			if reportErrors {
				scanner.scanRange(startOfRegExpBody, endOfRegExpBody-startOfRegExpBody, func() {
					scanner.scanRegularExpressionWorker(regExpFlags /*annexB*/, true, namedCaptureGroups)
				})
			}
		}
		scanner.tokenValue = scanner.text.substring(scanner.tokenStart, scanner.pos)
		scanner.token = SyntaxKindRegularExpressionLiteral
	}
	return scanner.token
}

func (scanner *Scanner) scanRegularExpressionWorker(regExpFlags RegularExpressionFlags, annexB bool, namedCaptureGroups bool) {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */

	unicodeSetsMode := !!(regExpFlags & RegularExpressionFlagsUnicodeSets)
	/** Grammar parameter */

	anyUnicodeMode := !!(regExpFlags & RegularExpressionFlagsAnyUnicodeMode)

	// Regular expressions are checked more strictly when either in 'u' or 'v' mode, or
	// when not using the looser interpretation of the syntax from ECMA-262 Annex B.
	anyUnicodeModeOrNonAnnexB := anyUnicodeMode || !annexB
	/** @see {scanClassSetExpression} */

	mayContainStrings := false
	/** The number of all (named and unnamed) capturing groups defined in the regex. */

	numberOfCapturingGroups := 0
	/** All named capturing groups defined in the regex. */

	var groupSpecifiers *Set[string]
	/** All references to named capturing groups in the regex. */

	var groupNameReferences *[] /* TODO(TS-TO-GO) TypeNode IntersectionType: TextRange & { name: string; } */ any
	/** All numeric backreferences within the regex. */

	var decimalEscapes *[] /* TODO(TS-TO-GO) TypeNode IntersectionType: TextRange & { value: number; } */ any
	/** A stack of scopes for named capturing groups. @see {scanGroupName} */

	var namedCapturingGroupsScopeStack []*Set[string] = []never{}
	var topNamedCapturingGroupsScope *Set[string]
	/* eslint-enable no-var */
	// Disjunction ::= Alternative ('|' Alternative)*
	scanDisjunction := func(isInGroup bool) {
		for true {
			namedCapturingGroupsScopeStack.push(topNamedCapturingGroupsScope)
			topNamedCapturingGroupsScope = nil
			scanAlternative(isInGroup)
			topNamedCapturingGroupsScope = namedCapturingGroupsScopeStack.pop()
			if scanner.charCodeChecked(scanner.pos) != CharacterCodesbar {
				return
			}
			scanner.pos++
		}
	}

	// Alternative ::= Term*
	// Term ::=
	//     | Assertion
	//     | Atom Quantifier?
	// Assertion ::=
	//     | '^'
	//     | '$'
	//     | '\b'
	//     | '\B'
	//     | '(?=' Disjunction ')'
	//     | '(?!' Disjunction ')'
	//     | '(?<=' Disjunction ')'
	//     | '(?<!' Disjunction ')'
	// Quantifier ::= QuantifierPrefix '?'?
	// QuantifierPrefix ::=
	//     | '*'
	//     | '+'
	//     | '?'
	//     | '{' DecimalDigits (',' DecimalDigits?)? '}'
	// Atom ::=
	//     | PatternCharacter
	//     | '.'
	//     | '\' AtomEscape
	//     | CharacterClass
	//     | '(?<' RegExpIdentifierName '>' Disjunction ')'
	//     | '(?' RegularExpressionFlags ('-' RegularExpressionFlags)? ':' Disjunction ')'
	// CharacterClass ::= unicodeMode
	//     ? '[' ClassRanges ']'
	//     : '[' ClassSetExpression ']'
	scanAlternative := func(isInGroup bool) {
		isPreviousTermQuantifiable := false
		for true {
			start := scanner.pos
			ch := scanner.charCodeChecked(scanner.pos)
			switch ch {
			case CharacterCodesEOF:
				return
			case CharacterCodescaret,
				CharacterCodes_DOLLAR_:
				scanner.pos++
				isPreviousTermQuantifiable = false
			case CharacterCodesbackslash:
				scanner.pos++
				switch scanner.charCodeChecked(scanner.pos) {
				case CharacterCodesb,
					CharacterCodesB:
					scanner.pos++
					isPreviousTermQuantifiable = false
				default:
					scanAtomEscape()
					isPreviousTermQuantifiable = true
				}
			case CharacterCodesopenParen:
				scanner.pos++
				if scanner.charCodeChecked(scanner.pos) == CharacterCodesquestion {
					scanner.pos++
					switch scanner.charCodeChecked(scanner.pos) {
					case CharacterCodesequals,
						CharacterCodesexclamation:
						scanner.pos++
						isPreviousTermQuantifiable = !anyUnicodeModeOrNonAnnexB
					case CharacterCodeslessThan:
						groupNameStart := scanner.pos
						scanner.pos++
						switch scanner.charCodeChecked(scanner.pos) {
						case CharacterCodesequals,
							CharacterCodesexclamation:
							scanner.pos++
							isPreviousTermQuantifiable = false
						default:
							scanGroupName(false)
							scanExpectedChar(CharacterCodesgreaterThan)
							if languageVersion < ScriptTargetES2018 {
								scanner.error(Diagnostics.Named_capturing_groups_are_only_available_when_targeting_ES2018_or_later, groupNameStart, scanner.pos-groupNameStart)
							}
							numberOfCapturingGroups++
							isPreviousTermQuantifiable = true
						}
					default:
						start := scanner.pos
						setFlags := scanPatternModifiers(RegularExpressionFlagsNone)
						if scanner.charCodeChecked(scanner.pos) == CharacterCodesminus {
							scanner.pos++
							scanPatternModifiers(setFlags)
							if scanner.pos == start+1 {
								scanner.error(Diagnostics.Subpattern_flags_must_be_present_when_there_is_a_minus_sign, start, scanner.pos-start)
							}
						}
						scanExpectedChar(CharacterCodescolon)
						isPreviousTermQuantifiable = true
					}
				} else {
					numberOfCapturingGroups++
					isPreviousTermQuantifiable = true
				}
				scanDisjunction(true)
				scanExpectedChar(CharacterCodescloseParen)
			case CharacterCodesopenBrace:
				scanner.pos++
				digitsStart := scanner.pos
				scanner.scanDigits()
				min := scanner.tokenValue
				if !anyUnicodeModeOrNonAnnexB && !min {
					isPreviousTermQuantifiable = true
					break
				}
				if scanner.charCodeChecked(scanner.pos) == CharacterCodescomma {
					scanner.pos++
					scanner.scanDigits()
					max := scanner.tokenValue
					if !min {
						if max || scanner.charCodeChecked(scanner.pos) == CharacterCodescloseBrace {
							scanner.error(Diagnostics.Incomplete_quantifier_Digit_expected, digitsStart, 0)
						} else {
							scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, start, 1, String.fromCharCode(ch))
							isPreviousTermQuantifiable = true
							break
						}
					} else if max && Number.parseInt(min) > Number.parseInt(max) && (anyUnicodeModeOrNonAnnexB || scanner.charCodeChecked(scanner.pos) == CharacterCodescloseBrace) {
						scanner.error(Diagnostics.Numbers_out_of_order_in_quantifier, digitsStart, scanner.pos-digitsStart)
					}
				} else if !min {
					if anyUnicodeModeOrNonAnnexB {
						scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, start, 1, String.fromCharCode(ch))
					}
					isPreviousTermQuantifiable = true
					break
				}
				if scanner.charCodeChecked(scanner.pos) != CharacterCodescloseBrace {
					if anyUnicodeModeOrNonAnnexB {
						scanner.error(Diagnostics._0_expected, scanner.pos, 0, String.fromCharCode(CharacterCodescloseBrace))
						scanner.pos--
					} else {
						isPreviousTermQuantifiable = true
						break
					}
				}
				fallthrough
			case CharacterCodesasterisk,
				CharacterCodesplus,
				CharacterCodesquestion:
				scanner.pos++
				if scanner.charCodeChecked(scanner.pos) == CharacterCodesquestion {
					// Non-greedy
					scanner.pos++
				}
				if !isPreviousTermQuantifiable {
					scanner.error(Diagnostics.There_is_nothing_available_for_repetition, start, scanner.pos-start)
				}
				isPreviousTermQuantifiable = false
			case CharacterCodesdot:
				scanner.pos++
				isPreviousTermQuantifiable = true
			case CharacterCodesopenBracket:
				scanner.pos++
				if unicodeSetsMode {
					scanClassSetExpression()
				} else {
					scanClassRanges()
				}
				scanExpectedChar(CharacterCodescloseBracket)
				isPreviousTermQuantifiable = true
			case CharacterCodescloseParen:
				if isInGroup {
					return
				}
				fallthrough
			case CharacterCodescloseBracket,
				CharacterCodescloseBrace:
				if anyUnicodeModeOrNonAnnexB || ch == CharacterCodescloseParen {
					scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, scanner.pos, 1, String.fromCharCode(ch))
				}
				scanner.pos++
				isPreviousTermQuantifiable = true
			case CharacterCodesslash,
				CharacterCodesbar:
				return
			default:
				scanSourceCharacter()
				isPreviousTermQuantifiable = true
			}
		}
	}

	scanPatternModifiers := func(currFlags RegularExpressionFlags) RegularExpressionFlags {
		for true {
			ch := scanner.codePointChecked(scanner.pos)
			if ch == CharacterCodesEOF || !isIdentifierPart(ch, languageVersion) {
				break
			}
			size := charSize(ch)
			flag := characterCodeToRegularExpressionFlag(ch)
			if flag == nil {
				scanner.error(Diagnostics.Unknown_regular_expression_flag, scanner.pos, size)
			} else if currFlags & flag {
				scanner.error(Diagnostics.Duplicate_regular_expression_flag, scanner.pos, size)
			} else if !(flag & RegularExpressionFlagsModifiers) {
				scanner.error(Diagnostics.This_regular_expression_flag_cannot_be_toggled_within_a_subpattern, scanner.pos, size)
			} else {
				currFlags |= flag
				scanner.checkRegularExpressionFlagAvailability(flag, size)
			}
			scanner.pos += size
		}
		return currFlags
	}

	// AtomEscape ::=
	//     | DecimalEscape
	//     | CharacterClassEscape
	//     | CharacterEscape
	//     | 'k<' RegExpIdentifierName '>'
	scanAtomEscape := func() {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodesbackslash)
		switch scanner.charCodeChecked(scanner.pos) {
		case CharacterCodesk:
			scanner.pos++
			if scanner.charCodeChecked(scanner.pos) == CharacterCodeslessThan {
				scanner.pos++
				scanGroupName(true)
				scanExpectedChar(CharacterCodesgreaterThan)
			} else if anyUnicodeModeOrNonAnnexB || namedCaptureGroups {
				scanner.error(Diagnostics.k_must_be_followed_by_a_capturing_group_name_enclosed_in_angle_brackets, scanner.pos-2, 2)
			}
		case CharacterCodesq:
			if unicodeSetsMode {
				scanner.pos++
				scanner.error(Diagnostics.q_is_only_available_inside_character_class, scanner.pos-2, 2)
				break
			}
			fallthrough
		default:
			Debug.assert(scanCharacterClassEscape() || scanDecimalEscape() || scanCharacterEscape(true))
		}
	}

	// DecimalEscape ::= [1-9] [0-9]*
	scanDecimalEscape := func() bool {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodesbackslash)
		ch := scanner.charCodeChecked(scanner.pos)
		if ch >= CharacterCodes_1 && ch <= CharacterCodes_9 {
			start := scanner.pos
			scanner.scanDigits()
			decimalEscapes = append(decimalEscapes, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"pos":   start,
				"end":   scanner.pos,
				"value": +scanner.tokenValue,
			})
			return true
		}
		return false
	}

	// CharacterEscape ::=
	//     | `c` ControlLetter
	//     | IdentityEscape
	//     | (Other sequences handled by `scanEscapeSequence`)
	// IdentityEscape ::=
	//     | '^' | '$' | '/' | '\' | '.' | '*' | '+' | '?' | '(' | ')' | '[' | ']' | '{' | '}' | '|'
	//     | [~UnicodeMode] (any other non-identifier characters)
	scanCharacterEscape := func(atomEscape bool) string {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodesbackslash)
		ch := scanner.charCodeChecked(scanner.pos)
		switch ch {
		case CharacterCodesEOF:
			scanner.error(Diagnostics.Undetermined_character_escape, scanner.pos-1, 1)
			return "\\"
		case CharacterCodesc:
			scanner.pos++
			ch = scanner.charCodeChecked(scanner.pos)
			if isASCIILetter(ch) {
				scanner.pos++
				return String.fromCharCode(ch & 0x1f)
			}
			if anyUnicodeModeOrNonAnnexB {
				scanner.error(Diagnostics.c_must_be_followed_by_an_ASCII_letter, scanner.pos-2, 2)
			} else if atomEscape {
				// Annex B treats
				//
				//  ExtendedAtom : `\` [lookahead = `c`]
				//
				// as the single character `\` when `c` isn't followed by a valid control character
				scanner.pos--
				return "\\"
			}
			return String.fromCharCode(ch)
		case CharacterCodescaret,
			CharacterCodes_DOLLAR_,
			CharacterCodesslash,
			CharacterCodesbackslash,
			CharacterCodesdot,
			CharacterCodesasterisk,
			CharacterCodesplus,
			CharacterCodesquestion,
			CharacterCodesopenParen,
			CharacterCodescloseParen,
			CharacterCodesopenBracket,
			CharacterCodescloseBracket,
			CharacterCodesopenBrace,
			CharacterCodescloseBrace,
			CharacterCodesbar:
			scanner.pos++
			return String.fromCharCode(ch)
		default:
			scanner.pos--
			return scanner.scanEscapeSequence(EscapeSequenceScanningFlagsRegularExpression | (__COND__(annexB, EscapeSequenceScanningFlagsAnnexB, 0)) | (__COND__(anyUnicodeMode, EscapeSequenceScanningFlagsAnyUnicodeMode, 0)) | (__COND__(atomEscape, EscapeSequenceScanningFlagsAtomEscape, 0)))
		}
	}

	scanGroupName := func(isReference bool) {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodeslessThan)
		scanner.tokenStart = scanner.pos
		scanner.scanIdentifier(scanner.codePointChecked(scanner.pos), languageVersion)
		if scanner.pos == scanner.tokenStart {
			scanner.error(Diagnostics.Expected_a_capturing_group_name)
		} else if isReference {
			groupNameReferences = append(groupNameReferences, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"pos":  scanner.tokenStart,
				"end":  scanner.pos,
				"name": scanner.tokenValue,
			})
		} else if topNamedCapturingGroupsScope. /* ? */ has(scanner.tokenValue) || namedCapturingGroupsScopeStack.some(func(group *Set[string]) *bool {
			return group. /* ? */ has(scanner.tokenValue)
		}) {
			scanner.error(Diagnostics.Named_capturing_groups_with_the_same_name_must_be_mutually_exclusive_to_each_other, scanner.tokenStart, scanner.pos-scanner.tokenStart)
		} else {
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: topNamedCapturingGroupsScope ??= new Set() */ TODO
			topNamedCapturingGroupsScope.add(scanner.tokenValue)
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: groupSpecifiers ??= new Set() */ TODO
			groupSpecifiers.add(scanner.tokenValue)
		}
	}

	isClassContentExit := func(ch number) bool {
		return ch == CharacterCodescloseBracket || ch == CharacterCodesEOF || scanner.pos >= scanner.end
	}

	// ClassRanges ::= '^'? (ClassAtom ('-' ClassAtom)?)*
	scanClassRanges := func() {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodesopenBracket)
		if scanner.charCodeChecked(scanner.pos) == CharacterCodescaret {
			// character complement
			scanner.pos++
		}
		for true {
			ch := scanner.charCodeChecked(scanner.pos)
			if isClassContentExit(ch) {
				return
			}
			minStart := scanner.pos
			minCharacter := scanClassAtom()
			if scanner.charCodeChecked(scanner.pos) == CharacterCodesminus {
				scanner.pos++
				ch := scanner.charCodeChecked(scanner.pos)
				if isClassContentExit(ch) {
					return
				}
				if !minCharacter && anyUnicodeModeOrNonAnnexB {
					scanner.error(Diagnostics.A_character_class_range_must_not_be_bounded_by_another_character_class, minStart, scanner.pos-1-minStart)
				}
				maxStart := scanner.pos
				maxCharacter := scanClassAtom()
				if !maxCharacter && anyUnicodeModeOrNonAnnexB {
					scanner.error(Diagnostics.A_character_class_range_must_not_be_bounded_by_another_character_class, maxStart, scanner.pos-maxStart)
					continue
				}
				if !minCharacter {
					continue
				}
				minCharacterValue := codePointAt(minCharacter, 0)
				maxCharacterValue := codePointAt(maxCharacter, 0)
				if minCharacter.length == charSize(minCharacterValue) && maxCharacter.length == charSize(maxCharacterValue) && minCharacterValue > maxCharacterValue {
					scanner.error(Diagnostics.Range_out_of_order_in_character_class, minStart, scanner.pos-minStart)
				}
			}
		}
	}

	// Static Semantics: MayContainStrings
	//     ClassUnion: ClassSetOperands.some(ClassSetOperand => ClassSetOperand.MayContainStrings)
	//     ClassIntersection: ClassSetOperands.every(ClassSetOperand => ClassSetOperand.MayContainStrings)
	//     ClassSubtraction: ClassSetOperands[0].MayContainStrings
	//     ClassSetOperand:
	//         || ClassStringDisjunctionContents.MayContainStrings
	//         || CharacterClassEscape.UnicodePropertyValueExpression.LoneUnicodePropertyNameOrValue.MayContainStrings
	//     ClassStringDisjunctionContents: ClassStrings.some(ClassString => ClassString.ClassSetCharacters.length !== 1)
	//     LoneUnicodePropertyNameOrValue: isBinaryUnicodePropertyOfStrings(LoneUnicodePropertyNameOrValue)

	// ClassSetExpression ::= '^'? (ClassUnion | ClassIntersection | ClassSubtraction)
	// ClassUnion ::= (ClassSetRange | ClassSetOperand)*
	// ClassIntersection ::= ClassSetOperand ('&&' ClassSetOperand)+
	// ClassSubtraction ::= ClassSetOperand ('--' ClassSetOperand)+
	// ClassSetRange ::= ClassSetCharacter '-' ClassSetCharacter
	scanClassSetExpression := func() {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodesopenBracket)
		isCharacterComplement := false
		if scanner.charCodeChecked(scanner.pos) == CharacterCodescaret {
			scanner.pos++
			isCharacterComplement = true
		}
		expressionMayContainStrings := false
		ch := scanner.charCodeChecked(scanner.pos)
		if isClassContentExit(ch) {
			return
		}
		start := scanner.pos
		var operand string
		switch scanner.text.slice(scanner.pos, scanner.pos+2) {
		case "--",
			"&&":
			scanner.error(Diagnostics.Expected_a_class_set_operand)
			mayContainStrings = false
		default:
			operand = scanClassSetOperand()
		}
		switch scanner.charCodeChecked(scanner.pos) {
		case CharacterCodesminus:
			if scanner.charCodeChecked(scanner.pos+1) == CharacterCodesminus {
				if isCharacterComplement && mayContainStrings {
					scanner.error(Diagnostics.Anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_character_class, start, scanner.pos-start)
				}
				expressionMayContainStrings = mayContainStrings
				scanClassSetSubExpression(ClassSetExpressionTypeClassSubtraction)
				mayContainStrings = !isCharacterComplement && expressionMayContainStrings
				return
			}
		case CharacterCodesampersand:
			if scanner.charCodeChecked(scanner.pos+1) == CharacterCodesampersand {
				scanClassSetSubExpression(ClassSetExpressionTypeClassIntersection)
				if isCharacterComplement && mayContainStrings {
					scanner.error(Diagnostics.Anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_character_class, start, scanner.pos-start)
				}
				expressionMayContainStrings = mayContainStrings
				mayContainStrings = !isCharacterComplement && expressionMayContainStrings
				return
			} else {
				scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, scanner.pos, 1, String.fromCharCode(ch))
			}
		default:
			if isCharacterComplement && mayContainStrings {
				scanner.error(Diagnostics.Anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_character_class, start, scanner.pos-start)
			}
			expressionMayContainStrings = mayContainStrings
		}
		for true {
			ch = scanner.charCodeChecked(scanner.pos)
			if ch == CharacterCodesEOF {
				break
			}
			switch ch {
			case CharacterCodesminus:
				scanner.pos++
				ch = scanner.charCodeChecked(scanner.pos)
				if isClassContentExit(ch) {
					mayContainStrings = !isCharacterComplement && expressionMayContainStrings
					return
				}
				if ch == CharacterCodesminus {
					scanner.pos++
					scanner.error(Diagnostics.Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead, scanner.pos-2, 2)
					start = scanner.pos - 2
					operand = scanner.text.slice(start, scanner.pos)
					continue
				} else {
					if !operand {
						scanner.error(Diagnostics.A_character_class_range_must_not_be_bounded_by_another_character_class, start, scanner.pos-1-start)
					}
					secondStart := scanner.pos
					secondOperand := scanClassSetOperand()
					if isCharacterComplement && mayContainStrings {
						scanner.error(Diagnostics.Anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_character_class, secondStart, scanner.pos-secondStart)
					}
					expressionMayContainStrings = expressionMayContainStrings || mayContainStrings
					if !secondOperand {
						scanner.error(Diagnostics.A_character_class_range_must_not_be_bounded_by_another_character_class, secondStart, scanner.pos-secondStart)
						break
					}
					if !operand {
						break
					}
					minCharacterValue := codePointAt(operand, 0)
					maxCharacterValue := codePointAt(secondOperand, 0)
					if operand.length == charSize(minCharacterValue) && secondOperand.length == charSize(maxCharacterValue) && minCharacterValue > maxCharacterValue {
						scanner.error(Diagnostics.Range_out_of_order_in_character_class, start, scanner.pos-start)
					}
				}
			case CharacterCodesampersand:
				start = scanner.pos
				scanner.pos++
				if scanner.charCodeChecked(scanner.pos) == CharacterCodesampersand {
					scanner.pos++
					scanner.error(Diagnostics.Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead, scanner.pos-2, 2)
					if scanner.charCodeChecked(scanner.pos) == CharacterCodesampersand {
						scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, scanner.pos, 1, String.fromCharCode(ch))
						scanner.pos++
					}
				} else {
					scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, scanner.pos-1, 1, String.fromCharCode(ch))
				}
				operand = scanner.text.slice(start, scanner.pos)
				continue
			}
			if isClassContentExit(scanner.charCodeChecked(scanner.pos)) {
				break
			}
			start = scanner.pos
			switch scanner.text.slice(scanner.pos, scanner.pos+2) {
			case "--",
				"&&":
				scanner.error(Diagnostics.Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead, scanner.pos, 2)
				scanner.pos += 2
				operand = scanner.text.slice(start, scanner.pos)
			default:
				operand = scanClassSetOperand()
			}
		}
		mayContainStrings = !isCharacterComplement && expressionMayContainStrings
	}

	scanClassSetSubExpression := func(expressionType ClassSetExpressionType) {
		expressionMayContainStrings := mayContainStrings
		for true {
			ch := scanner.charCodeChecked(scanner.pos)
			if isClassContentExit(ch) {
				break
			}
			// Provide user-friendly diagnostic messages
			switch ch {
			case CharacterCodesminus:
				scanner.pos++
				if scanner.charCodeChecked(scanner.pos) == CharacterCodesminus {
					scanner.pos++
					if expressionType != ClassSetExpressionTypeClassSubtraction {
						scanner.error(Diagnostics.Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead, scanner.pos-2, 2)
					}
				} else {
					scanner.error(Diagnostics.Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead, scanner.pos-1, 1)
				}
			case CharacterCodesampersand:
				scanner.pos++
				if scanner.charCodeChecked(scanner.pos) == CharacterCodesampersand {
					scanner.pos++
					if expressionType != ClassSetExpressionTypeClassIntersection {
						scanner.error(Diagnostics.Operators_must_not_be_mixed_within_a_character_class_Wrap_it_in_a_nested_class_instead, scanner.pos-2, 2)
					}
					if scanner.charCodeChecked(scanner.pos) == CharacterCodesampersand {
						scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, scanner.pos, 1, String.fromCharCode(ch))
						scanner.pos++
					}
				} else {
					scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, scanner.pos-1, 1, String.fromCharCode(ch))
				}
			default:
				switch expressionType {
				case ClassSetExpressionTypeClassSubtraction:
					scanner.error(Diagnostics._0_expected, scanner.pos, 0, "--")
				case ClassSetExpressionTypeClassIntersection:
					scanner.error(Diagnostics._0_expected, scanner.pos, 0, "&&")
				default:
				}
			}
			ch = scanner.charCodeChecked(scanner.pos)
			if isClassContentExit(ch) {
				scanner.error(Diagnostics.Expected_a_class_set_operand)
				break
			}
			scanClassSetOperand()
			// Used only if expressionType is Intersection
			/* TODO(TS-TO-GO) AmpersandAmpersandEqualsToken BinaryExpression: expressionMayContainStrings &&= mayContainStrings */
			TODO
		}
		mayContainStrings = expressionMayContainStrings
	}

	// ClassSetOperand ::=
	//     | '[' ClassSetExpression ']'
	//     | '\' CharacterClassEscape
	//     | '\q{' ClassStringDisjunctionContents '}'
	//     | ClassSetCharacter
	scanClassSetOperand := func() string {
		mayContainStrings = false
		switch scanner.charCodeChecked(scanner.pos) {
		case CharacterCodesEOF:
			return ""
		case CharacterCodesopenBracket:
			scanner.pos++
			scanClassSetExpression()
			scanExpectedChar(CharacterCodescloseBracket)
			return ""
		case CharacterCodesbackslash:
			scanner.pos++
			if scanCharacterClassEscape() {
				return ""
			} else if scanner.charCodeChecked(scanner.pos) == CharacterCodesq {
				scanner.pos++
				if scanner.charCodeChecked(scanner.pos) == CharacterCodesopenBrace {
					scanner.pos++
					scanClassStringDisjunctionContents()
					scanExpectedChar(CharacterCodescloseBrace)
					return ""
				} else {
					scanner.error(Diagnostics.q_must_be_followed_by_string_alternatives_enclosed_in_braces, scanner.pos-2, 2)
					return "q"
				}
			}
			scanner.pos--
			fallthrough
		default:
			return scanClassSetCharacter()
		}
	}

	// ClassStringDisjunctionContents ::= ClassSetCharacter* ('|' ClassSetCharacter*)*
	scanClassStringDisjunctionContents := func() {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodesopenBrace)
		characterCount := 0
		for true {
			ch := scanner.charCodeChecked(scanner.pos)
			switch ch {
			case CharacterCodesEOF:
				return
			case CharacterCodescloseBrace:
				if characterCount != 1 {
					mayContainStrings = true
				}
				return
			case CharacterCodesbar:
				if characterCount != 1 {
					mayContainStrings = true
				}
				scanner.pos++
				start = scanner.pos
				characterCount = 0
			default:
				scanClassSetCharacter()
				characterCount++
			}
		}
	}

	// ClassSetCharacter ::=
	//     | SourceCharacter -- ClassSetSyntaxCharacter -- ClassSetReservedDoublePunctuator
	//     | '\' (CharacterEscape | ClassSetReservedPunctuator | 'b')
	scanClassSetCharacter := func() string {
		ch := scanner.charCodeChecked(scanner.pos)
		if ch == CharacterCodesEOF {
			// no need to report an error, the initial scan will already have reported that the RegExp is unterminated.
			return ""
		}
		if ch == CharacterCodesbackslash {
			scanner.pos++
			ch := scanner.charCodeChecked(scanner.pos)
			switch ch {
			case CharacterCodesb:
				scanner.pos++
				return "\b"
			case CharacterCodesampersand,
				CharacterCodesminus,
				CharacterCodesexclamation,
				CharacterCodeshash,
				CharacterCodespercent,
				CharacterCodescomma,
				CharacterCodescolon,
				CharacterCodessemicolon,
				CharacterCodeslessThan,
				CharacterCodesequals,
				CharacterCodesgreaterThan,
				CharacterCodesat,
				CharacterCodesbacktick,
				CharacterCodestilde:
				scanner.pos++
				return String.fromCharCode(ch)
			default:
				return scanCharacterEscape(false)
			}
		} else if ch == scanner.charCodeChecked(scanner.pos+1) {
			switch ch {
			case CharacterCodesampersand,
				CharacterCodesexclamation,
				CharacterCodeshash,
				CharacterCodespercent,
				CharacterCodesasterisk,
				CharacterCodesplus,
				CharacterCodescomma,
				CharacterCodesdot,
				CharacterCodescolon,
				CharacterCodessemicolon,
				CharacterCodeslessThan,
				CharacterCodesequals,
				CharacterCodesgreaterThan,
				CharacterCodesquestion,
				CharacterCodesat,
				CharacterCodesbacktick,
				CharacterCodestilde:
				scanner.error(Diagnostics.A_character_class_must_not_contain_a_reserved_double_punctuator_Did_you_mean_to_escape_it_with_backslash, scanner.pos, 2)
				scanner.pos += 2
				return scanner.text.substring(scanner.pos-2, scanner.pos)
			}
		}
		switch ch {
		case CharacterCodesslash,
			CharacterCodesopenParen,
			CharacterCodescloseParen,
			CharacterCodesopenBracket,
			CharacterCodescloseBracket,
			CharacterCodesopenBrace,
			CharacterCodescloseBrace,
			CharacterCodesminus,
			CharacterCodesbar:
			scanner.error(Diagnostics.Unexpected_0_Did_you_mean_to_escape_it_with_backslash, scanner.pos, 1, String.fromCharCode(ch))
			scanner.pos++
			return String.fromCharCode(ch)
		}
		return scanSourceCharacter()
	}

	// ClassAtom ::=
	//     | SourceCharacter but not one of '\' or ']'
	//     | '\' ClassEscape
	// ClassEscape ::=
	//     | 'b'
	//     | '-'
	//     | CharacterClassEscape
	//     | CharacterEscape
	scanClassAtom := func() string {
		if scanner.charCodeChecked(scanner.pos) == CharacterCodesbackslash {
			scanner.pos++
			ch := scanner.charCodeChecked(scanner.pos)
			switch ch {
			case CharacterCodesb:
				scanner.pos++
				return "\b"
			case CharacterCodesminus:
				scanner.pos++
				return String.fromCharCode(ch)
			default:
				if scanCharacterClassEscape() {
					return ""
				}
				return scanCharacterEscape(false)
			}
		} else {
			return scanSourceCharacter()
		}
	}

	// CharacterClassEscape ::=
	//     | 'd' | 'D' | 's' | 'S' | 'w' | 'W'
	//     | [+UnicodeMode] ('P' | 'p') '{' UnicodePropertyValueExpression '}'
	scanCharacterClassEscape := func() bool {
		Debug.assertEqual(scanner.charCodeUnchecked(scanner.pos-1), CharacterCodesbackslash)
		isCharacterComplement := false
		start := scanner.pos - 1
		ch := scanner.charCodeChecked(scanner.pos)
		switch ch {
		case CharacterCodesd,
			CharacterCodesD,
			CharacterCodess,
			CharacterCodesS,
			CharacterCodesw,
			CharacterCodesW:
			scanner.pos++
			return true
		case CharacterCodesP:
			isCharacterComplement = true
			fallthrough
		case CharacterCodesp:
			scanner.pos++
			if scanner.charCodeChecked(scanner.pos) == CharacterCodesopenBrace {
				scanner.pos++
				propertyNameOrValueStart := scanner.pos
				propertyNameOrValue := scanWordCharacters()
				if scanner.charCodeChecked(scanner.pos) == CharacterCodesequals {
					propertyName := nonBinaryUnicodeProperties.get(propertyNameOrValue)
					if scanner.pos == propertyNameOrValueStart {
						scanner.error(Diagnostics.Expected_a_Unicode_property_name)
					} else if propertyName == nil {
						scanner.error(Diagnostics.Unknown_Unicode_property_name, propertyNameOrValueStart, scanner.pos-propertyNameOrValueStart)
						suggestion := getSpellingSuggestion(propertyNameOrValue, nonBinaryUnicodeProperties.keys(), identity)
						if suggestion {
							scanner.error(Diagnostics.Did_you_mean_0, propertyNameOrValueStart, scanner.pos-propertyNameOrValueStart, suggestion)
						}
					}
					scanner.pos++
					propertyValueStart := scanner.pos
					propertyValue := scanWordCharacters()
					if scanner.pos == propertyValueStart {
						scanner.error(Diagnostics.Expected_a_Unicode_property_value)
					} else if propertyName != nil && !valuesOfNonBinaryUnicodeProperties[propertyName].has(propertyValue) {
						scanner.error(Diagnostics.Unknown_Unicode_property_value, propertyValueStart, scanner.pos-propertyValueStart)
						suggestion := getSpellingSuggestion(propertyValue, valuesOfNonBinaryUnicodeProperties[propertyName], identity)
						if suggestion {
							scanner.error(Diagnostics.Did_you_mean_0, propertyValueStart, scanner.pos-propertyValueStart, suggestion)
						}
					}
				} else {
					if scanner.pos == propertyNameOrValueStart {
						scanner.error(Diagnostics.Expected_a_Unicode_property_name_or_value)
					} else if binaryUnicodePropertiesOfStrings.has(propertyNameOrValue) {
						if !unicodeSetsMode {
							scanner.error(Diagnostics.Any_Unicode_property_that_would_possibly_match_more_than_a_single_character_is_only_available_when_the_Unicode_Sets_v_flag_is_set, propertyNameOrValueStart, scanner.pos-propertyNameOrValueStart)
						} else if isCharacterComplement {
							scanner.error(Diagnostics.Anything_that_would_possibly_match_more_than_a_single_character_is_invalid_inside_a_negated_character_class, propertyNameOrValueStart, scanner.pos-propertyNameOrValueStart)
						} else {
							mayContainStrings = true
						}
					} else if !valuesOfNonBinaryUnicodeProperties.General_Category.has(propertyNameOrValue) && !binaryUnicodeProperties.has(propertyNameOrValue) {
						scanner.error(Diagnostics.Unknown_Unicode_property_name_or_value, propertyNameOrValueStart, scanner.pos-propertyNameOrValueStart)
						suggestion := getSpellingSuggestion(propertyNameOrValue, []string{ /* TODO(TS-TO-GO) Node SpreadElement: ...valuesOfNonBinaryUnicodeProperties.General_Category */ /* TODO(TS-TO-GO) Node SpreadElement: ...binaryUnicodeProperties */ /* TODO(TS-TO-GO) Node SpreadElement: ...binaryUnicodePropertiesOfStrings */ }, identity)
						if suggestion {
							scanner.error(Diagnostics.Did_you_mean_0, propertyNameOrValueStart, scanner.pos-propertyNameOrValueStart, suggestion)
						}
					}
				}
				scanExpectedChar(CharacterCodescloseBrace)
				if !anyUnicodeMode {
					scanner.error(Diagnostics.Unicode_property_value_expressions_are_only_available_when_the_Unicode_u_flag_or_the_Unicode_Sets_v_flag_is_set, start, scanner.pos-start)
				}
			} else if anyUnicodeModeOrNonAnnexB {
				scanner.error(Diagnostics._0_must_be_followed_by_a_Unicode_property_value_expression_enclosed_in_braces, scanner.pos-2, 2, String.fromCharCode(ch))
			} else {
				scanner.pos--
				return false
			}
			return true
		}
		return false
	}

	scanWordCharacters := func() string {
		value := ""
		for true {
			ch := scanner.charCodeChecked(scanner.pos)
			if ch == CharacterCodesEOF || !isWordCharacter(ch) {
				break
			}
			value += String.fromCharCode(ch)
			scanner.pos++
		}
		return value
	}

	scanSourceCharacter := func() string {
		var size /* TODO(TS-TO-GO) inferred type 0 | 1 | 2 */ any
		if anyUnicodeMode {
			size = charSize(scanner.codePointChecked(scanner.pos))
		} else {
			size = 1
		}
		scanner.pos += size
		if size > 0 {
			return scanner.text.substring(scanner.pos-size, scanner.pos)
		} else {
			return ""
		}
	}

	scanExpectedChar := func(ch CharacterCodes) {
		if scanner.charCodeChecked(scanner.pos) == ch {
			scanner.pos++
		} else {
			scanner.error(Diagnostics._0_expected, scanner.pos, 0, String.fromCharCode(ch))
		}
	}

	scanDisjunction(false)

	forEach(groupNameReferences, func(reference /* TODO(TS-TO-GO) inferred type TextRange & { name: string; } */ any) {
		if !groupSpecifiers. /* ? */ has(reference.name) {
			scanner.error(Diagnostics.There_is_no_capturing_group_named_0_in_this_regular_expression, reference.pos, reference.end-reference.pos, reference.name)
			if groupSpecifiers {
				suggestion := getSpellingSuggestion(reference.name, groupSpecifiers, identity)
				if suggestion {
					scanner.error(Diagnostics.Did_you_mean_0, reference.pos, reference.end-reference.pos, suggestion)
				}
			}
		}
	})
	forEach(decimalEscapes, func(escape /* TODO(TS-TO-GO) inferred type TextRange & { value: number; } */ any) {
		// Although a DecimalEscape with a value greater than the number of capturing groups
		// is treated as either a LegacyOctalEscapeSequence or an IdentityEscape in Annex B,
		// an error is nevertheless reported since it's most likely a mistake.
		if escape.value > numberOfCapturingGroups {
			if numberOfCapturingGroups {
				scanner.error(Diagnostics.This_backreference_refers_to_a_group_that_does_not_exist_There_are_only_0_capturing_groups_in_this_regular_expression, escape.pos, escape.end-escape.pos, numberOfCapturingGroups)
			} else {
				scanner.error(Diagnostics.This_backreference_refers_to_a_group_that_does_not_exist_There_are_no_capturing_groups_in_this_regular_expression, escape.pos, escape.end-escape.pos)
			}
		}
	})
}

func (scanner *Scanner) checkRegularExpressionFlagAvailability(flag RegularExpressionFlags, size number) {
	availableFrom := regExpFlagToFirstAvailableLanguageVersion.get(flag)
	if availableFrom && languageVersion < availableFrom {
		scanner.error(Diagnostics.This_regular_expression_flag_is_only_available_when_targeting_0_or_later, scanner.pos, size, getNameOfScriptTarget(availableFrom))
	}
}

func (scanner *Scanner) appendIfCommentDirective(commentDirectives *[]CommentDirective, text string, commentDirectiveRegEx RegExp, lineStart number) *[]CommentDirective {
	type_ := scanner.getDirectiveFromComment(scanner.text.trimStart(), commentDirectiveRegEx)
	if type_ == nil {
		return scanner.commentDirectives
	}

	return append(scanner.commentDirectives, map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"range_": map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"pos": lineStart,
			"end": scanner.pos,
		},
		"type_": type_,
	})
}

func (scanner *Scanner) getDirectiveFromComment(text string, commentDirectiveRegEx RegExp) *CommentDirectiveType {
	match := commentDirectiveRegEx.exec(scanner.text)
	if !match {
		return nil
	}

	switch match[1] {
	case "ts-expect-error":
		return CommentDirectiveTypeExpectError
	case "ts-ignore":
		return CommentDirectiveTypeIgnore
	}

	return nil
}

/**
 * Unconditionally back up and scan a template expression portion.
 */

func (scanner *Scanner) reScanTemplateToken(isTaggedTemplate bool) SyntaxKind {
	scanner.pos = scanner.tokenStart
	scanner.token = scanner.scanTemplateAndSetTokenValue(!isTaggedTemplate)
	return scanner.token
}

func (scanner *Scanner) reScanTemplateHeadOrNoSubstitutionTemplate() SyntaxKind {
	scanner.pos = scanner.tokenStart
	scanner.token = scanner.scanTemplateAndSetTokenValue(true)
	return scanner.token
}

func (scanner *Scanner) reScanJsxToken(allowMultilineJsxText bool /*  = true */) JsxTokenSyntaxKind {
	scanner.pos = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: tokenStart = fullStartPos */ TODO
	scanner.token = scanner.scanJsxToken(allowMultilineJsxText)
	return scanner.token
}

func (scanner *Scanner) reScanLessThanToken() SyntaxKind {
	if scanner.token == SyntaxKindLessThanLessThanToken {
		scanner.pos = scanner.tokenStart + 1
		scanner.token = SyntaxKindLessThanToken
		return scanner.token
	}
	return scanner.token
}

func (scanner *Scanner) reScanHashToken() SyntaxKind {
	if scanner.token == SyntaxKindPrivateIdentifier {
		scanner.pos = scanner.tokenStart + 1
		scanner.token = SyntaxKindHashToken
		return scanner.token
	}
	return scanner.token
}

func (scanner *Scanner) reScanQuestionToken() SyntaxKind {
	Debug.assert(scanner.token == SyntaxKindQuestionQuestionToken, "'reScanQuestionToken' should only be called on a '??'")
	scanner.pos = scanner.tokenStart + 1
	scanner.token = SyntaxKindQuestionToken
	return scanner.token
}

func (scanner *Scanner) scanJsxToken(allowMultilineJsxText bool /*  = true */) JsxTokenSyntaxKind {
	scanner.fullStartPos = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: tokenStart = pos */ TODO

	if scanner.pos >= scanner.end {
		scanner.token = SyntaxKindEndOfFileToken
		return scanner.token
	}

	char := scanner.charCodeUnchecked(scanner.pos)
	if char == CharacterCodeslessThan {
		if scanner.charCodeUnchecked(scanner.pos+1) == CharacterCodesslash {
			scanner.pos += 2
			scanner.token = SyntaxKindLessThanSlashToken
			return scanner.token
		}
		scanner.pos++
		scanner.token = SyntaxKindLessThanToken
		return scanner.token
	}

	if char == CharacterCodesopenBrace {
		scanner.pos++
		scanner.token = SyntaxKindOpenBraceToken
		return scanner.token
	}

	// First non-whitespace character on this line.
	firstNonWhitespace := 0

	// These initial values are special because the first line is:
	// firstNonWhitespace = 0 to indicate that we want leading whitespace,

	for scanner.pos < scanner.end {
		char = scanner.charCodeUnchecked(scanner.pos)
		if char == CharacterCodesopenBrace {
			break
		}
		if char == CharacterCodeslessThan {
			if isConflictMarkerTrivia(scanner.text, scanner.pos) {
				scanner.pos = scanConflictMarkerTrivia(scanner.text, scanner.pos, scanner.error)
				scanner.token = SyntaxKindConflictMarkerTrivia
				return scanner.token
			}
			break
		}
		if char == CharacterCodesgreaterThan {
			scanner.error(Diagnostics.Unexpected_token_Did_you_mean_or_gt, scanner.pos, 1)
		}
		if char == CharacterCodescloseBrace {
			scanner.error(Diagnostics.Unexpected_token_Did_you_mean_or_rbrace, scanner.pos, 1)
		}

		// FirstNonWhitespace is 0, then we only see whitespaces so far. If we see a linebreak, we want to ignore that whitespaces.
		// i.e (- : whitespace)
		//      <div>----
		//      </div> becomes <div></div>
		//
		//      <div>----</div> becomes <div>----</div>
		if isLineBreak(char) && firstNonWhitespace == 0 {
			firstNonWhitespace = -1
		} else if !allowMultilineJsxText && isLineBreak(char) && firstNonWhitespace > 0 {
			// Stop JsxText on each line during formatting. This allows the formatter to
			// indent each line correctly.
			break
		} else if !isWhiteSpaceLike(char) {
			firstNonWhitespace = scanner.pos
		}

		scanner.pos++
	}

	scanner.tokenValue = scanner.text.substring(scanner.fullStartPos, scanner.pos)

	if firstNonWhitespace == -1 {
		return SyntaxKindJsxTextAllWhiteSpaces
	} else {
		return SyntaxKindJsxText
	}
}

// Scans a JSX identifier; these differ from normal identifiers in that
// they allow dashes
func (scanner *Scanner) scanJsxIdentifier() SyntaxKind {
	if tokenIsIdentifierOrKeyword(scanner.token) {
		// An identifier or keyword has already been parsed - check for a `-` or a single instance of `:` and then append it and
		// everything after it to the token
		// Do note that this means that `scanJsxIdentifier` effectively _mutates_ the visible token without advancing to a new token
		// Any caller should be expecting this behavior and should only read the pos or token value after calling it.
		for scanner.pos < scanner.end {
			ch := scanner.charCodeUnchecked(scanner.pos)
			if ch == CharacterCodesminus {
				scanner.tokenValue += "-"
				scanner.pos++
				continue
			}
			oldPos := scanner.pos
			scanner.tokenValue += scanner.scanIdentifierParts()
			// reuse `scanIdentifierParts` so unicode escapes are handled
			if scanner.pos == oldPos {
				break
			}
		}
		return scanner.getIdentifierToken()
	}
	return scanner.token
}

func (scanner *Scanner) scanJsxAttributeValue() SyntaxKind {
	scanner.fullStartPos = scanner.pos

	switch scanner.charCodeUnchecked(scanner.pos) {
	case CharacterCodesdoubleQuote,
		CharacterCodessingleQuote:
		scanner.tokenValue = scanner.scanString(true)
		scanner.token = SyntaxKindStringLiteral
		return scanner.token
	default:
		return scanner.scan()
	}
}

func (scanner *Scanner) reScanJsxAttributeValue() SyntaxKind {
	scanner.pos = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: tokenStart = fullStartPos */ TODO
	return scanner.scanJsxAttributeValue()
}

func (scanner *Scanner) scanJSDocCommentTextToken(inBackticks bool) /* TODO(TS-TO-GO) TypeNode UnionType: JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken */ any {
	scanner.fullStartPos = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: tokenStart = pos */ TODO
	scanner.tokenFlags = TokenFlagsNone
	if scanner.pos >= scanner.end {
		scanner.token = SyntaxKindEndOfFileToken
		return scanner.token
	}
	for ch := scanner.charCodeUnchecked(scanner.pos); scanner.pos < scanner.end && (!isLineBreak(ch) && ch != CharacterCodesbacktick); ch = scanner.codePointUnchecked( /* TODO(TS-TO-GO) Node PrefixUnaryExpression: ++pos */ TODO) {
		if !inBackticks {
			if ch == CharacterCodesopenBrace {
				break
			} else if ch == CharacterCodesat && scanner.pos-1 >= 0 && isWhiteSpaceSingleLine(scanner.charCodeUnchecked(scanner.pos-1)) && !(scanner.pos+1 < scanner.end && isWhiteSpaceLike(scanner.charCodeUnchecked(scanner.pos+1))) {
				// @ doesn't start a new tag inside ``, and elsewhere, only after whitespace and before non-whitespace
				break
			}
		}
	}
	if scanner.pos == scanner.tokenStart {
		return scanner.scanJsDocToken()
	}
	scanner.tokenValue = scanner.text.substring(scanner.tokenStart, scanner.pos)
	scanner.token = SyntaxKindJSDocCommentTextToken
	return scanner.token
}

func (scanner *Scanner) scanJsDocToken() JSDocSyntaxKind {
	scanner.fullStartPos = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: tokenStart = pos */ TODO
	scanner.tokenFlags = TokenFlagsNone
	if scanner.pos >= scanner.end {
		scanner.token = SyntaxKindEndOfFileToken
		return scanner.token
	}

	ch := scanner.codePointUnchecked(scanner.pos)
	scanner.pos += charSize(ch)
	switch ch {
	case CharacterCodestab,
		CharacterCodesverticalTab,
		CharacterCodesformFeed,
		CharacterCodesspace:
		for scanner.pos < scanner.end && isWhiteSpaceSingleLine(scanner.charCodeUnchecked(scanner.pos)) {
			scanner.pos++
		}
		scanner.token = SyntaxKindWhitespaceTrivia
		return scanner.token
	case CharacterCodesat:
		scanner.token = SyntaxKindAtToken
		return scanner.token
	case CharacterCodescarriageReturn:
		if scanner.charCodeUnchecked(scanner.pos) == CharacterCodeslineFeed {
			scanner.pos++
		}
		fallthrough
	case CharacterCodeslineFeed:
		scanner.tokenFlags |= TokenFlagsPrecedingLineBreak
		scanner.token = SyntaxKindNewLineTrivia
		return scanner.token
	case CharacterCodesasterisk:
		scanner.token = SyntaxKindAsteriskToken
		return scanner.token
	case CharacterCodesopenBrace:
		scanner.token = SyntaxKindOpenBraceToken
		return scanner.token
	case CharacterCodescloseBrace:
		scanner.token = SyntaxKindCloseBraceToken
		return scanner.token
	case CharacterCodesopenBracket:
		scanner.token = SyntaxKindOpenBracketToken
		return scanner.token
	case CharacterCodescloseBracket:
		scanner.token = SyntaxKindCloseBracketToken
		return scanner.token
	case CharacterCodesopenParen:
		scanner.token = SyntaxKindOpenParenToken
		return scanner.token
	case CharacterCodescloseParen:
		scanner.token = SyntaxKindCloseParenToken
		return scanner.token
	case CharacterCodeslessThan:
		scanner.token = SyntaxKindLessThanToken
		return scanner.token
	case CharacterCodesgreaterThan:
		scanner.token = SyntaxKindGreaterThanToken
		return scanner.token
	case CharacterCodesequals:
		scanner.token = SyntaxKindEqualsToken
		return scanner.token
	case CharacterCodescomma:
		scanner.token = SyntaxKindCommaToken
		return scanner.token
	case CharacterCodesdot:
		scanner.token = SyntaxKindDotToken
		return scanner.token
	case CharacterCodesbacktick:
		scanner.token = SyntaxKindBacktickToken
		return scanner.token
	case CharacterCodeshash:
		scanner.token = SyntaxKindHashToken
		return scanner.token
	case CharacterCodesbackslash:
		scanner.pos--
		extendedCookedChar := scanner.peekExtendedUnicodeEscape()
		if extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion) {
			scanner.tokenValue = scanner.scanExtendedUnicodeEscape(true) + scanner.scanIdentifierParts()
			scanner.token = scanner.getIdentifierToken()
			return scanner.token
		}

		cookedChar := scanner.peekUnicodeEscape()
		if cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion) {
			scanner.pos += 6
			scanner.tokenFlags |= TokenFlagsUnicodeEscape
			scanner.tokenValue = String.fromCharCode(cookedChar) + scanner.scanIdentifierParts()
			scanner.token = scanner.getIdentifierToken()
			return scanner.token
		}
		scanner.pos++
		scanner.token = SyntaxKindUnknown
		return scanner.token
	}

	if isIdentifierStart(ch, languageVersion) {
		char := ch
		for scanner.pos < scanner.end && isIdentifierPart( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: char = codePointUnchecked(pos) */ TODO, languageVersion) || char == CharacterCodesminus {
			scanner.pos += charSize(char)
		}
		scanner.tokenValue = scanner.text.substring(scanner.tokenStart, scanner.pos)
		if char == CharacterCodesbackslash {
			scanner.tokenValue += scanner.scanIdentifierParts()
		}
		scanner.token = scanner.getIdentifierToken()
		return scanner.token
	} else {
		scanner.token = SyntaxKindUnknown
		return scanner.token
	}
}

func (scanner *Scanner) speculationHelper(callback func() T, isLookahead bool) T {
	savePos := scanner.pos
	saveStartPos := scanner.fullStartPos
	saveTokenPos := scanner.tokenStart
	saveToken := scanner.token
	saveTokenValue := scanner.tokenValue
	saveTokenFlags := scanner.tokenFlags
	result := callback()

	// If our callback returned something 'falsy' or we're just looking ahead,
	// then unconditionally restore us to where we were.
	if !result || isLookahead {
		scanner.pos = savePos
		scanner.fullStartPos = saveStartPos
		scanner.tokenStart = saveTokenPos
		scanner.token = saveToken
		scanner.tokenValue = saveTokenValue
		scanner.tokenFlags = saveTokenFlags
	}
	return result
}

func (scanner *Scanner) scanRange(start number, length number, callback func() T) T {
	saveEnd := scanner.end
	savePos := scanner.pos
	saveStartPos := scanner.fullStartPos
	saveTokenPos := scanner.tokenStart
	saveToken := scanner.token
	saveTokenValue := scanner.tokenValue
	saveTokenFlags := scanner.tokenFlags
	saveErrorExpectations := scanner.commentDirectives

	scanner.setText(scanner.text, start, length)
	result := callback()

	scanner.end = saveEnd
	scanner.pos = savePos
	scanner.fullStartPos = saveStartPos
	scanner.tokenStart = saveTokenPos
	scanner.token = saveToken
	scanner.tokenValue = saveTokenValue
	scanner.tokenFlags = saveTokenFlags
	scanner.commentDirectives = saveErrorExpectations

	return result
}

func (scanner *Scanner) lookAhead(callback func() T) T {
	return scanner.speculationHelper(callback /*isLookahead*/, true)
}

func (scanner *Scanner) tryScan(callback func() T) T {
	return scanner.speculationHelper(callback /*isLookahead*/, false)
}

func (scanner *Scanner) getText() string {
	return scanner.text
}

func (scanner *Scanner) clearCommentDirectives() {
	scanner.commentDirectives = nil
}

func (scanner *Scanner) setText(newText *string, start *number, length *number) {
	scanner.text = newText || ""
	if length == nil {
		scanner.end = scanner.text.length
	} else {
		scanner.end = start + length
	}
	scanner.resetTokenState(start || 0)
}

func (scanner *Scanner) setOnError(errorCallback *ErrorCallback) {
	onError = errorCallback
}

func (scanner *Scanner) setScriptTarget(scriptTarget ScriptTarget) {
	languageVersion = scriptTarget
}

func (scanner *Scanner) setLanguageVariant(variant LanguageVariant) {
	languageVariant = variant
}

func (scanner *Scanner) setScriptKind(kind ScriptKind) {
	scanner.scriptKind = kind
}

func (scanner *Scanner) setJSDocParsingMode(kind JSDocParsingMode) {
	scanner.jsDocParsingMode = kind
}

func (scanner *Scanner) resetTokenState(position number) {
	Debug.assert(position >= 0)
	scanner.pos = position
	scanner.fullStartPos = position
	scanner.tokenStart = position
	scanner.token = SyntaxKindUnknown
	scanner.tokenValue = nil
	scanner.tokenFlags = TokenFlagsNone
}

func (scanner *Scanner) setSkipJsDocLeadingAsterisks(skip bool) {
	if skip {
		scanner.skipJsDocLeadingAsterisks += 1
	} else {
		scanner.skipJsDocLeadingAsterisks += -1
	}
}

func codePointAt(s string, i number) number {
	// TODO(jakebailey): this is wrong and should have ?? 0; but all users are okay with it
	return s.codePointAt(i)
}

func charSize(ch number) /* TODO(TS-TO-GO) inferred type 0 | 1 | 2 */ any {
	if ch >= 0x10000 {
		return 2
	}
	if ch == CharacterCodesEOF {
		return 0
	}
	return 1
}

// Derived from the 10.1.1 UTF16Encoding of the ES6 Spec.
func utf16EncodeAsStringFallback(codePoint number) string {
	Debug.assert(0x0 <= codePoint && codePoint <= 0x10FFFF)

	if codePoint <= 65535 {
		return String.fromCharCode(codePoint)
	}

	codeUnit1 := Math.floor((codePoint-65536)/1024) + 0xD800
	codeUnit2 := ((codePoint - 65536) % 1024) + 0xDC00

	return String.fromCharCode(codeUnit1, codeUnit2)
}

var utf16EncodeAsStringWorker func(codePoint number) string = __COND__((String /* as any */).fromCodePoint, func(codePoint number) any {
	return (String /* as any */).fromCodePoint(codePoint)
}, utf16EncodeAsStringFallback)

/** @internal */

func utf16EncodeAsString(codePoint number) string {
	return utf16EncodeAsStringWorker(codePoint)
}

// Table 66: Non-binary Unicode property aliases and their canonical property names
// https://tc39.es/ecma262/#table-nonbinary-unicode-properties
// dprint-ignore
var nonBinaryUnicodeProperties = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"General_Category":  "General_Category",
	"gc":                "General_Category",
	"Script":            "Script",
	"sc":                "Script",
	"Script_Extensions": "Script_Extensions",
	"scx":               "Script_Extensions",
}.(const_)))

// Table 67: Binary Unicode property aliases and their canonical property names
// https://tc39.es/ecma262/#table-binary-unicode-properties
// dprint-ignore
var binaryUnicodeProperties = NewSet([]string{"ASCII", "ASCII_Hex_Digit", "AHex", "Alphabetic", "Alpha", "Any", "Assigned", "Bidi_Control", "Bidi_C", "Bidi_Mirrored", "Bidi_M", "Case_Ignorable", "CI", "Cased", "Changes_When_Casefolded", "CWCF", "Changes_When_Casemapped", "CWCM", "Changes_When_Lowercased", "CWL", "Changes_When_NFKC_Casefolded", "CWKCF", "Changes_When_Titlecased", "CWT", "Changes_When_Uppercased", "CWU", "Dash", "Default_Ignorable_Code_Point", "DI", "Deprecated", "Dep", "Diacritic", "Dia", "Emoji", "Emoji_Component", "EComp", "Emoji_Modifier", "EMod", "Emoji_Modifier_Base", "EBase", "Emoji_Presentation", "EPres", "Extended_Pictographic", "ExtPict", "Extender", "Ext", "Grapheme_Base", "Gr_Base", "Grapheme_Extend", "Gr_Ext", "Hex_Digit", "Hex", "IDS_Binary_Operator", "IDSB", "IDS_Trinary_Operator", "IDST", "ID_Continue", "IDC", "ID_Start", "IDS", "Ideographic", "Ideo", "Join_Control", "Join_C", "Logical_Order_Exception", "LOE", "Lowercase", "Lower", "Math", "Noncharacter_Code_Point", "NChar", "Pattern_Syntax", "Pat_Syn", "Pattern_White_Space", "Pat_WS", "Quotation_Mark", "QMark", "Radical", "Regional_Indicator", "RI", "Sentence_Terminal", "STerm", "Soft_Dotted", "SD", "Terminal_Punctuation", "Term", "Unified_Ideograph", "UIdeo", "Uppercase", "Upper", "Variation_Selector", "VS", "White_Space", "space", "XID_Continue", "XIDC", "XID_Start", "XIDS"})

// Table 68: Binary Unicode properties of strings
// https://tc39.es/ecma262/#table-binary-unicode-properties-of-strings
// dprint-ignore
var binaryUnicodePropertiesOfStrings = NewSet([]string{"Basic_Emoji", "Emoji_Keycap_Sequence", "RGI_Emoji_Modifier_Sequence", "RGI_Emoji_Flag_Sequence", "RGI_Emoji_Tag_Sequence", "RGI_Emoji_ZWJ_Sequence", "RGI_Emoji"})

// Unicode 15.1
// dprint-ignore
var valuesOfNonBinaryUnicodeProperties = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"General_Category":  NewSet([]string{"C", "Other", "Cc", "Control", "cntrl", "Cf", "Format", "Cn", "Unassigned", "Co", "Private_Use", "Cs", "Surrogate", "L", "Letter", "LC", "Cased_Letter", "Ll", "Lowercase_Letter", "Lm", "Modifier_Letter", "Lo", "Other_Letter", "Lt", "Titlecase_Letter", "Lu", "Uppercase_Letter", "M", "Mark", "Combining_Mark", "Mc", "Spacing_Mark", "Me", "Enclosing_Mark", "Mn", "Nonspacing_Mark", "N", "Number", "Nd", "Decimal_Number", "digit", "Nl", "Letter_Number", "No", "Other_Number", "P", "Punctuation", "punct", "Pc", "Connector_Punctuation", "Pd", "Dash_Punctuation", "Pe", "Close_Punctuation", "Pf", "Final_Punctuation", "Pi", "Initial_Punctuation", "Po", "Other_Punctuation", "Ps", "Open_Punctuation", "S", "Symbol", "Sc", "Currency_Symbol", "Sk", "Modifier_Symbol", "Sm", "Math_Symbol", "So", "Other_Symbol", "Z", "Separator", "Zl", "Line_Separator", "Zp", "Paragraph_Separator", "Zs", "Space_Separator"}),
	"Script":            NewSet([]string{"Adlm", "Adlam", "Aghb", "Caucasian_Albanian", "Ahom", "Arab", "Arabic", "Armi", "Imperial_Aramaic", "Armn", "Armenian", "Avst", "Avestan", "Bali", "Balinese", "Bamu", "Bamum", "Bass", "Bassa_Vah", "Batk", "Batak", "Beng", "Bengali", "Bhks", "Bhaiksuki", "Bopo", "Bopomofo", "Brah", "Brahmi", "Brai", "Braille", "Bugi", "Buginese", "Buhd", "Buhid", "Cakm", "Chakma", "Cans", "Canadian_Aboriginal", "Cari", "Carian", "Cham", "Cher", "Cherokee", "Chrs", "Chorasmian", "Copt", "Coptic", "Qaac", "Cpmn", "Cypro_Minoan", "Cprt", "Cypriot", "Cyrl", "Cyrillic", "Deva", "Devanagari", "Diak", "Dives_Akuru", "Dogr", "Dogra", "Dsrt", "Deseret", "Dupl", "Duployan", "Egyp", "Egyptian_Hieroglyphs", "Elba", "Elbasan", "Elym", "Elymaic", "Ethi", "Ethiopic", "Geor", "Georgian", "Glag", "Glagolitic", "Gong", "Gunjala_Gondi", "Gonm", "Masaram_Gondi", "Goth", "Gothic", "Gran", "Grantha", "Grek", "Greek", "Gujr", "Gujarati", "Guru", "Gurmukhi", "Hang", "Hangul", "Hani", "Han", "Hano", "Hanunoo", "Hatr", "Hatran", "Hebr", "Hebrew", "Hira", "Hiragana", "Hluw", "Anatolian_Hieroglyphs", "Hmng", "Pahawh_Hmong", "Hmnp", "Nyiakeng_Puachue_Hmong", "Hrkt", "Katakana_Or_Hiragana", "Hung", "Old_Hungarian", "Ital", "Old_Italic", "Java", "Javanese", "Kali", "Kayah_Li", "Kana", "Katakana", "Kawi", "Khar", "Kharoshthi", "Khmr", "Khmer", "Khoj", "Khojki", "Kits", "Khitan_Small_Script", "Knda", "Kannada", "Kthi", "Kaithi", "Lana", "Tai_Tham", "Laoo", "Lao", "Latn", "Latin", "Lepc", "Lepcha", "Limb", "Limbu", "Lina", "Linear_A", "Linb", "Linear_B", "Lisu", "Lyci", "Lycian", "Lydi", "Lydian", "Mahj", "Mahajani", "Maka", "Makasar", "Mand", "Mandaic", "Mani", "Manichaean", "Marc", "Marchen", "Medf", "Medefaidrin", "Mend", "Mende_Kikakui", "Merc", "Meroitic_Cursive", "Mero", "Meroitic_Hieroglyphs", "Mlym", "Malayalam", "Modi", "Mong", "Mongolian", "Mroo", "Mro", "Mtei", "Meetei_Mayek", "Mult", "Multani", "Mymr", "Myanmar", "Nagm", "Nag_Mundari", "Nand", "Nandinagari", "Narb", "Old_North_Arabian", "Nbat", "Nabataean", "Newa", "Nkoo", "Nko", "Nshu", "Nushu", "Ogam", "Ogham", "Olck", "Ol_Chiki", "Orkh", "Old_Turkic", "Orya", "Oriya", "Osge", "Osage", "Osma", "Osmanya", "Ougr", "Old_Uyghur", "Palm", "Palmyrene", "Pauc", "Pau_Cin_Hau", "Perm", "Old_Permic", "Phag", "Phags_Pa", "Phli", "Inscriptional_Pahlavi", "Phlp", "Psalter_Pahlavi", "Phnx", "Phoenician", "Plrd", "Miao", "Prti", "Inscriptional_Parthian", "Rjng", "Rejang", "Rohg", "Hanifi_Rohingya", "Runr", "Runic", "Samr", "Samaritan", "Sarb", "Old_South_Arabian", "Saur", "Saurashtra", "Sgnw", "SignWriting", "Shaw", "Shavian", "Shrd", "Sharada", "Sidd", "Siddham", "Sind", "Khudawadi", "Sinh", "Sinhala", "Sogd", "Sogdian", "Sogo", "Old_Sogdian", "Sora", "Sora_Sompeng", "Soyo", "Soyombo", "Sund", "Sundanese", "Sylo", "Syloti_Nagri", "Syrc", "Syriac", "Tagb", "Tagbanwa", "Takr", "Takri", "Tale", "Tai_Le", "Talu", "New_Tai_Lue", "Taml", "Tamil", "Tang", "Tangut", "Tavt", "Tai_Viet", "Telu", "Telugu", "Tfng", "Tifinagh", "Tglg", "Tagalog", "Thaa", "Thaana", "Thai", "Tibt", "Tibetan", "Tirh", "Tirhuta", "Tnsa", "Tangsa", "Toto", "Ugar", "Ugaritic", "Vaii", "Vai", "Vith", "Vithkuqi", "Wara", "Warang_Citi", "Wcho", "Wancho", "Xpeo", "Old_Persian", "Xsux", "Cuneiform", "Yezi", "Yezidi", "Yiii", "Yi", "Zanb", "Zanabazar_Square", "Zinh", "Inherited", "Qaai", "Zyyy", "Common", "Zzzz", "Unknown"}),
	"Script_Extensions": nil.(Set[string]),
}

// The Script_Extensions property of a character contains one or more Script values. See https://www.unicode.org/reports/tr24/#Script_Extensions
// Here since each Unicode property value expression only allows a single value, its values can be considered the same as those of the Script property.
/* TODO(TS-TO-GO) Node ExpressionStatement: valuesOfNonBinaryUnicodeProperties.Script_Extensions = valuesOfNonBinaryUnicodeProperties.Script; */
