// Code generated by ts-to-go at 52eaa7b02fdeaa8969f88c7f5c0b252f5f0bd147. DO NOT EDIT.

package output

func __COND__[C comparable, T any](cond C, a T, b T) T {
	var zero C
	if cond != zero {
		return a
	}
	return b
}

/** @internal */

var resolvingEmptyArray []never = []never{}

/** @internal */

var externalHelpersModuleNameText = "tslib"

/** @internal */

var defaultMaximumTruncationLength = 160

/** @internal */

var noTruncationMaximumTruncationLength = 1_000_000

/** @internal */

func getDeclarationOfKind(symbol Symbol, kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: T["kind"] */ any) *T {
	declarations := symbol.declarations
	if declarations {
		for _, declaration := range declarations {
			if declaration.kind == kind {
				return declaration /* as T */
			}
		}
	}

	return nil
}

/** @internal */

func getDeclarationsOfKind(symbol Symbol, kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: T["kind"] */ any) []T {
	return filter(symbol.declarations || emptyArray, func(d Declaration) bool {
		return d.kind == kind
	}) /* as T[] */
}

/** @internal */

func createSymbolTable(symbols []Symbol) SymbolTable {
	result := NewMap[__String, Symbol]()
	if symbols {
		for _, symbol := range symbols {
			result.set(symbol.escapedName, symbol)
		}
	}
	return result
}

/** @internal */

func isTransientSymbol(symbol Symbol) /* TODO(TS-TO-GO) TypeNode TypePredicate: symbol is TransientSymbol */ any {
	return (symbol.flags & SymbolFlagsTransient) != 0
}

/**
 * True if the symbol is for an external module, as opposed to a namespace.
 *
 * @internal
 */

func isExternalModuleSymbol(moduleSymbol Symbol) bool {
	return !!(moduleSymbol.flags & SymbolFlagsModule) && (moduleSymbol.escapedName /* as string */).charCodeAt(0) == CharacterCodesdoubleQuote
}

var stringWriter = createSingleLineStringWriter()

func createSingleLineStringWriter() EmitTextWriter {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	str := ""
	/* eslint-enable no-var */
	var writeText func(text string) = func(text string) string {
		return /* TODO(TS-TO-GO) PlusEqualsToken BinaryExpression: str += text */ TODO
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getText": func() string {
			return str
		},
		"write":              writeText,
		"rawWrite":           writeText,
		"writeKeyword":       writeText,
		"writeOperator":      writeText,
		"writePunctuation":   writeText,
		"writeSpace":         writeText,
		"writeStringLiteral": writeText,
		"writeLiteral":       writeText,
		"writeParameter":     writeText,
		"writeProperty":      writeText,
		"writeSymbol": func(s string, _ Symbol) {
			return writeText(s)
		},
		"writeTrailingSemicolon": writeText,
		"writeComment":           writeText,
		"getTextPos": func() number {
			return str.length
		},
		"getLine": func() number {
			return 0
		},
		"getColumn": func() number {
			return 0
		},
		"getIndent": func() number {
			return 0
		},
		"isAtStartOfLine": func() false {
			return false
		},
		"hasTrailingComment": func() false {
			return false
		},
		"hasTrailingWhitespace": func() bool {
			return !!str.length && isWhiteSpaceLike(str.charCodeAt(str.length-1))
		},
		// Completely ignore indentation for string writers.  And map newlines to
		// a single space.
		"writeLine": func() string {
			return /* TODO(TS-TO-GO) PlusEqualsToken BinaryExpression: str += " " */ TODO
		},
		"increaseIndent": noop,
		"decreaseIndent": noop,
		"clear": func() string {
			return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: str = "" */ TODO
		},
	}
}

/** @internal */

func changesAffectModuleResolution(oldOptions CompilerOptions, newOptions CompilerOptions) bool {
	return oldOptions.configFilePath != newOptions.configFilePath || optionsHaveModuleResolutionChanges(oldOptions, newOptions)
}

func optionsHaveModuleResolutionChanges(oldOptions CompilerOptions, newOptions CompilerOptions) bool {
	return optionsHaveChanges(oldOptions, newOptions, moduleResolutionOptionDeclarations)
}

/** @internal */

func changesAffectingProgramStructure(oldOptions CompilerOptions, newOptions CompilerOptions) bool {
	return optionsHaveChanges(oldOptions, newOptions, optionsAffectingProgramStructure)
}

/** @internal */

func optionsHaveChanges(oldOptions CompilerOptions, newOptions CompilerOptions, optionDeclarations []CommandLineOption) bool {
	return oldOptions != newOptions && optionDeclarations.some(func(o CommandLineOption) bool {
		return !isJsonEqual(getCompilerOptionValue(oldOptions, o), getCompilerOptionValue(newOptions, o))
	})
}

/** @internal */

func forEachAncestor(node Node, callback func(n Node) /* TODO(TS-TO-GO) TypeNode UnionType: T | undefined | "quit" */ any) *T {
	for true {
		res := callback(node)
		if res == "quit" {
			return nil
		}
		if res != nil {
			return res
		}
		if isSourceFile(node) {
			return nil
		}
		node = node.parent
	}
}

/**
 * Calls `callback` for each entry in the map, returning the first truthy result.
 * Use `map.forEach` instead for normal iteration.
 *
 * @internal
 */

func forEachEntry(map_ ReadonlyMap[K, V], callback func(value V, key K) *U) *U {
	iterator := map_.entries()
	for _, TODO_IDENTIFIER := range iterator {
		result := callback(value, key)
		if result {
			return result
		}
	}
	return nil
}

/**
 * `forEachEntry` for just keys.
 *
 * @internal
 */

func forEachKey(map_ ReadonlyCollection[K], callback func(key K) *T) *T {
	iterator := map_.keys()
	for _, key := range iterator {
		result := callback(key)
		if result {
			return result
		}
	}
	return nil
}

/**
 * Copy entries from `source` to `target`.
 *
 * @internal
 */

func copyEntries(source ReadonlyMap[K, V], target Map[K, V]) {
	source.forEach(func(value V, key K) {
		target.set(key, value)
	})
}

/** @internal */

func usingSingleLineStringWriter(action func(writer EmitTextWriter)) string {
	oldString := stringWriter.getText()
	{ // try
		action(stringWriter)
		return stringWriter.getText()
	}
	{ // finally
		stringWriter.clear()
		stringWriter.writeKeyword(oldString)
	}
}

/** @internal */

func getFullWidth(node Node) number {
	return node.end - node.pos
}

/** @internal */

func projectReferenceIsEqualTo(oldRef ProjectReference, newRef ProjectReference) bool {
	return oldRef.path == newRef.path && !oldRef.prepend == !newRef.prepend && !oldRef.circular == !newRef.circular
}

/** @internal */

func moduleResolutionIsEqualTo(oldResolution ResolvedModuleWithFailedLookupLocations, newResolution ResolvedModuleWithFailedLookupLocations) bool {
	return oldResolution == newResolution || oldResolution.resolvedModule == newResolution.resolvedModule || !!oldResolution.resolvedModule && !!newResolution.resolvedModule && oldResolution.resolvedModule.isExternalLibraryImport == newResolution.resolvedModule.isExternalLibraryImport && oldResolution.resolvedModule.extension == newResolution.resolvedModule.extension && oldResolution.resolvedModule.resolvedFileName == newResolution.resolvedModule.resolvedFileName && oldResolution.resolvedModule.originalPath == newResolution.resolvedModule.originalPath && packageIdIsEqual(oldResolution.resolvedModule.packageId, newResolution.resolvedModule.packageId) && oldResolution.alternateResult == newResolution.alternateResult
}

/** @internal */

func getResolvedModuleFromResolution(resolution ResolvedModuleWithFailedLookupLocations) *ResolvedModuleFull {
	return resolution.resolvedModule
}

/** @internal */

func getResolvedTypeReferenceDirectiveFromResolution(resolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations) *ResolvedTypeReferenceDirective {
	return resolution.resolvedTypeReferenceDirective
}

/** @internal */

func createModuleNotFoundChain(sourceFile SourceFile, host TypeCheckerHost, moduleReference string, mode ResolutionMode, packageName string) DiagnosticMessageChain {
	alternateResult := host.getResolvedModule(sourceFile, moduleReference, mode). /* ? */ alternateResult
	alternateResultMessage := alternateResult && (__COND__(getEmitModuleResolutionKind(host.getCompilerOptions()) == ModuleResolutionKindNode10, []any{Diagnostics.There_are_types_at_0_but_this_result_could_not_be_resolved_under_your_current_moduleResolution_setting_Consider_updating_to_node16_nodenext_or_bundler, []any{alternateResult}} /* as const */, []any{Diagnostics.There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The_1_library_may_need_to_update_its_package_json_or_typings, []any{alternateResult, __COND__(alternateResult.includes(nodeModulesPathPart+"@types/"), __TEMPLATE__("@types/", mangleScopedPackageName(packageName)), packageName)}} /* as const */))
	var result DiagnosticMessageChain
	switch {
	case alternateResultMessage:
		result = chainDiagnosticMessages(nil, alternateResultMessage[0], alternateResultMessage[1]...)
	case host.typesPackageExists(packageName):
		result = chainDiagnosticMessages(nil, Diagnostics.If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1, packageName, mangleScopedPackageName(packageName))
	case host.packageBundlesTypes(packageName):
		result = chainDiagnosticMessages(nil, Diagnostics.If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1, packageName, moduleReference)
	default:
		result = chainDiagnosticMessages(nil, Diagnostics.Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0, moduleReference, mangleScopedPackageName(packageName))
	}
	if result {
		result.repopulateInfo = func() /* TODO(TS-TO-GO) inferred type { moduleReference: string; mode: ResolutionMode; packageName: string | undefined; } */ any {
			return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"moduleReference": moduleReference,
				"mode":            mode,
				"packageName":     __COND__(packageName == moduleReference, nil, packageName),
			})
		}
	}
	return result
}

/** @internal */

func createModeMismatchDetails(currentSourceFile SourceFile) DiagnosticMessageChain {
	ext := tryGetExtensionFromPath(currentSourceFile.fileName)
	scope := currentSourceFile.packageJsonScope
	var targetExt * /* TODO(TS-TO-GO) inferred type Extension.Mjs | Extension.Mts */ any
	switch {
	case ext == ExtensionTs:
		targetExt = ExtensionMts
	case ext == ExtensionJs:
		targetExt = ExtensionMjs
	default:
		targetExt = nil
	}
	var result DiagnosticMessageChain
	switch {
	case scope && !scope.contents.packageJsonContent.type_:
		if targetExt {
			result = chainDiagnosticMessages(nil, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1, targetExt, combinePaths(scope.packageDirectory, "package.json"))
		} else {
			result = chainDiagnosticMessages(nil, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0, combinePaths(scope.packageDirectory, "package.json"))
		}
	case targetExt:
		result = chainDiagnosticMessages(nil, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module, targetExt)
	default:
		result = chainDiagnosticMessages(nil, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module)
	}
	result.repopulateInfo = func() true {
		return true
	}
	return result
}

func packageIdIsEqual(a *PackageId, b *PackageId) bool {
	return a == b || !!a && !!b && a.name == b.name && a.subModuleName == b.subModuleName && a.version == b.version && a.peerDependencies == b.peerDependencies
}

/** @internal */

func packageIdToPackageName(TODO_IDENTIFIER PackageId) string {
	if subModuleName {
		return __TEMPLATE__(name, "/", subModuleName)
	} else {
		return name
	}
}

/** @internal */

func packageIdToString(packageId PackageId) string {
	return __TEMPLATE__(packageIdToPackageName(packageId), "@", packageId.version /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: packageId.peerDependencies ?? "" */, TODO)
}

/** @internal */

func typeDirectiveIsEqualTo(oldResolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations, newResolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations) bool {
	return oldResolution == newResolution || oldResolution.resolvedTypeReferenceDirective == newResolution.resolvedTypeReferenceDirective || !!oldResolution.resolvedTypeReferenceDirective && !!newResolution.resolvedTypeReferenceDirective && oldResolution.resolvedTypeReferenceDirective.resolvedFileName == newResolution.resolvedTypeReferenceDirective.resolvedFileName && !!oldResolution.resolvedTypeReferenceDirective.primary == !!newResolution.resolvedTypeReferenceDirective.primary && oldResolution.resolvedTypeReferenceDirective.originalPath == newResolution.resolvedTypeReferenceDirective.originalPath
}

/** @internal */

func hasChangesInResolutions(names []K, newResolutions []V, getOldResolution func(name K) *V, comparer func(oldResolution V, newResolution V) bool) bool {
	Debug.assert(names.length == newResolutions.length)

	for i := 0; i < names.length; i++ {
		newResolution := newResolutions[i]
		entry := names[i]
		oldResolution := getOldResolution(entry)
		var changed /* TODO(TS-TO-GO) inferred type boolean | V */ any
		if oldResolution {
			changed = !newResolution || !comparer(oldResolution, newResolution)
		} else {
			changed = newResolution
		}
		if changed {
			return true
		}
	}
	return false
}

// Returns true if this node contains a parse error anywhere underneath it.

func containsParseError(node Node) bool {
	aggregateChildData(node)
	return (node.flags & NodeFlagsThisNodeOrAnySubNodesHasError) != 0
}

func aggregateChildData(node Node) {
	if !(node.flags & NodeFlagsHasAggregatedChildData) {
		// A node is considered to contain a parse error if:
		//  a) the parser explicitly marked that it had an error
		//  b) any of it's children reported that it had an error.
		thisNodeOrAnySubNodesHasError := ((node.flags & NodeFlagsThisNodeHasError) != 0) || forEachChild(node, containsParseError)

		// If so, mark ourselves accordingly.
		if thisNodeOrAnySubNodesHasError {
			(node /* as Mutable<Node> */).flags |= NodeFlagsThisNodeOrAnySubNodesHasError
		}

		// Also mark that we've propagated the child information to this node.  This way we can
		// always consult the bit directly on this node without needing to check its children
		// again.
		(node /* as Mutable<Node> */).flags |= NodeFlagsHasAggregatedChildData
	}
}

/** @internal */

/* OVERLOAD: export function getSourceFileOfNode(node: Node): SourceFile; */
/** @internal */

/* OVERLOAD: export function getSourceFileOfNode(node: Node | undefined): SourceFile | undefined; */
/** @internal */

func getSourceFileOfNode(node Node) *SourceFile {
	for node && node.kind != SyntaxKindSourceFile {
		node = node.parent
	}
	return node /* as SourceFile */
}

/** @internal */

func getSourceFileOfModule(module Symbol) *SourceFile {
	return getSourceFileOfNode(module.valueDeclaration || getNonAugmentationDeclaration(module))
}

/** @internal */

func isPlainJsFile(file *SourceFile, checkJs *bool) bool {
	return !!file && (file.scriptKind == ScriptKindJS || file.scriptKind == ScriptKindJSX) && !file.checkJsDirective && checkJs == nil
}

/** @internal */

func isStatementWithLocals(node Node) bool {
	switch node.kind {
	case SyntaxKindBlock,
		SyntaxKindCaseBlock,
		SyntaxKindForStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement:
		return true
	}
	return false
}

/** @internal */

func getStartPositionOfLine(line number, sourceFile SourceFileLike) number {
	Debug.assert(line >= 0)
	return getLineStarts(sourceFile)[line]
}

// This is a useful function for debugging purposes.

func nodePosToString(node Node) string {
	file := getSourceFileOfNode(node)
	loc := getLineAndCharacterOfPosition(file, node.pos)
	return __TEMPLATE__(file.fileName, "(", loc.line+1, ",", loc.character+1, ")")
}

/** @internal */

func getEndLinePosition(line number, sourceFile SourceFileLike) number {
	Debug.assert(line >= 0)
	lineStarts := getLineStarts(sourceFile)

	lineIndex := line
	sourceText := sourceFile.text
	if lineIndex+1 == lineStarts.length {
		// last line - return EOF
		return sourceText.length - 1
	} else {
		// current line start
		start := lineStarts[lineIndex]
		// take the start position of the next line - 1 = it should be some line break
		pos := lineStarts[lineIndex+1] - 1
		Debug.assert(isLineBreak(sourceText.charCodeAt(pos)))
		// walk backwards skipping line breaks, stop the the beginning of current line.
		// i.e:
		// <some text>
		// $ <- end of line for this position should match the start position
		for start <= pos && isLineBreak(sourceText.charCodeAt(pos)) {
			pos--
		}
		return pos
	}
}

/**
 * Returns a value indicating whether a name is unique globally or within the current file.
 * Note: This does not consider whether a name appears as a free identifier or not, so at the expression `x.y` this includes both `x` and `y`.
 *
 * @internal
 */

func isFileLevelUniqueName(sourceFile SourceFile, name string, hasGlobalName /* TODO(TS-TO-GO) TypeNode IndexedAccessType: PrintHandlers["hasGlobalName"] */ any) bool {
	return !(hasGlobalName && hasGlobalName(name)) && !sourceFile.identifiers.has(name)
}

// Returns true if this node is missing from the actual source code. A 'missing' node is different
// from 'undefined/defined'. When a node is undefined (which can happen for optional nodes
// in the tree), it is definitely missing. However, a node may be defined, but still be
// missing.  This happens whenever the parser knows it needs to parse something, but can't
// get anything in the source code that it expects at that location. For example:
//
//          let a: ;
//
// Here, the Type in the Type-Annotation is not-optional (as there is a colon in the source
// code). So the parser will attempt to parse out a type, and will create an actual node.
// However, this node will be 'missing' in the sense that no actual source-code/tokens are
// contained within it.

func nodeIsMissing(node Node) bool {
	if node == nil {
		return true
	}

	return node.pos == node.end && node.pos >= 0 && node.kind != SyntaxKindEndOfFileToken
}

/** @internal */

func nodeIsPresent(node Node) bool {
	return !nodeIsMissing(node)
}

/**
 * Tests whether `child` is a grammar error on `parent`.
 * @internal
 */

func isGrammarError(parent Node, child /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any) bool {
	if isTypeParameterDeclaration(parent) {
		return child == parent.expression
	}
	if isClassStaticBlockDeclaration(parent) {
		return child == parent.modifiers
	}
	if isPropertySignature(parent) {
		return child == parent.initializer
	}
	if isPropertyDeclaration(parent) {
		return child == parent.questionToken && isAutoAccessorPropertyDeclaration(parent)
	}
	if isPropertyAssignment(parent) {
		return child == parent.modifiers || child == parent.questionToken || child == parent.exclamationToken || isGrammarErrorElement(parent.modifiers, child, isModifierLike)
	}
	if isShorthandPropertyAssignment(parent) {
		return child == parent.equalsToken || child == parent.modifiers || child == parent.questionToken || child == parent.exclamationToken || isGrammarErrorElement(parent.modifiers, child, isModifierLike)
	}
	if isMethodDeclaration(parent) {
		return child == parent.exclamationToken
	}
	if isConstructorDeclaration(parent) {
		return child == parent.typeParameters || child == parent.type_ || isGrammarErrorElement(parent.typeParameters, child, isTypeParameterDeclaration)
	}
	if isGetAccessorDeclaration(parent) {
		return child == parent.typeParameters || isGrammarErrorElement(parent.typeParameters, child, isTypeParameterDeclaration)
	}
	if isSetAccessorDeclaration(parent) {
		return child == parent.typeParameters || child == parent.type_ || isGrammarErrorElement(parent.typeParameters, child, isTypeParameterDeclaration)
	}
	if isNamespaceExportDeclaration(parent) {
		return child == parent.modifiers || isGrammarErrorElement(parent.modifiers, child, isModifierLike)
	}
	return false
}

func isGrammarErrorElement(nodeArray *NodeArray[T], child /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any, isElement func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is T */ any) bool {
	if !nodeArray || isArray(child) || !isElement(child) {
		return false
	}
	return contains(nodeArray, child)
}

func insertStatementsAfterPrologue(to []T, from *[]T, isPrologueDirective func(node Node) bool) []T {
	if from == nil || from.length == 0 {
		return to
	}
	statementIndex := 0
	// skip all prologue directives to insert at the correct position
	for ; statementIndex < to.length; statementIndex++ {
		if !isPrologueDirective(to[statementIndex]) {
			break
		}
	}
	to.splice(statementIndex, 0, from...)
	return to
}

func insertStatementAfterPrologue(to []T, statement *T, isPrologueDirective func(node Node) bool) []T {
	if statement == nil {
		return to
	}
	statementIndex := 0
	// skip all prologue directives to insert at the correct position
	for ; statementIndex < to.length; statementIndex++ {
		if !isPrologueDirective(to[statementIndex]) {
			break
		}
	}
	to.splice(statementIndex, 0, statement)
	return to
}

func isAnyPrologueDirective(node Node) bool {
	return isPrologueDirective(node) || !!(getEmitFlags(node) & EmitFlagsCustomPrologue)
}

/**
 * Prepends statements to an array while taking care of prologue directives.
 *
 * @internal
 */

func insertStatementsAfterStandardPrologue(to []T, from *[]T) []T {
	return insertStatementsAfterPrologue(to, from, isPrologueDirective)
}

/** @internal */

func insertStatementsAfterCustomPrologue(to []T, from *[]T) []T {
	return insertStatementsAfterPrologue(to, from, isAnyPrologueDirective)
}

/**
 * Prepends statements to an array while taking care of prologue directives.
 *
 * @internal
 * @knipignore
 */

func insertStatementAfterStandardPrologue(to []T, statement *T) []T {
	return insertStatementAfterPrologue(to, statement, isPrologueDirective)
}

/** @internal */

func insertStatementAfterCustomPrologue(to []T, statement *T) []T {
	return insertStatementAfterPrologue(to, statement, isAnyPrologueDirective)
}

/**
 * Determine if the given comment is a triple-slash
 *
 * @return true if the comment is a triple-slash comment else false
 *
 * @internal
 */

func isRecognizedTripleSlashComment(text string, commentPos number, commentEnd number) bool {
	// Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text
	// so that we don't end up computing comment string and doing match for all // comments
	if text.charCodeAt(commentPos+1) == CharacterCodesslash && commentPos+2 < commentEnd && text.charCodeAt(commentPos+2) == CharacterCodesslash {
		textSubStr := text.substring(commentPos, commentEnd)
		if fullTripleSlashReferencePathRegEx.test(textSubStr) || fullTripleSlashAMDReferencePathRegEx.test(textSubStr) || fullTripleSlashAMDModuleRegEx.test(textSubStr) || fullTripleSlashReferenceTypeReferenceDirectiveRegEx.test(textSubStr) || fullTripleSlashLibReferenceRegEx.test(textSubStr) || defaultLibReferenceRegEx.test(textSubStr) {
			return true
		} else {
			return false
		}
	}
	return false
}

/** @internal */

func isPinnedComment(text string, start number) bool {
	return text.charCodeAt(start+1) == CharacterCodesasterisk && text.charCodeAt(start+2) == CharacterCodesexclamation
}

/** @internal */

func createCommentDirectivesMap(sourceFile SourceFile, commentDirectives []CommentDirective) CommentDirectivesMap {
	directivesByLine := NewMap(commentDirectives.map_(func(commentDirective CommentDirective) /* TODO(TS-TO-GO) inferred type [string, CommentDirective] */ any {
		return []any{__TEMPLATE__(getLineAndCharacterOfPosition(sourceFile, commentDirective.range_.end).line), commentDirective}
	}))

	usedLines := NewMap[string, bool]()

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getUnusedExpectations": getUnusedExpectations,
		"markUsed":              markUsed,
	}

	getUnusedExpectations := func() []CommentDirective {
		return arrayFrom(directivesByLine.entries()).filter(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [string, CommentDirective] */ any) bool {
			return directive.type_ == CommentDirectiveTypeExpectError && !usedLines.get(line)
		}).map_(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [string, CommentDirective] */ any) CommentDirective {
			return directive
		})
	}

	markUsed := func(line number) bool {
		if !directivesByLine.has(__TEMPLATE__(line)) {
			return false
		}

		usedLines.set(__TEMPLATE__(line), true)
		return true
	}

}

/** @internal */

func getTokenPosOfNode(node Node, sourceFile SourceFileLike, includeJsDoc bool) number {
	// With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*
	// want to skip trivia because this will launch us forward to the next token.
	if nodeIsMissing(node) {
		return node.pos
	}

	if isJSDocNode(node) || node.kind == SyntaxKindJsxText {
		// JsxText cannot actually contain comments, even though the scanner will think it sees comments
		return skipTrivia(( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: sourceFile ?? getSourceFileOfNode(node) */ TODO).text, node.pos /*stopAfterLineBreak*/, false /*stopAtComments*/, true)
	}

	if includeJsDoc && hasJSDocNodes(node) {
		return getTokenPosOfNode(node.jsDoc[0], sourceFile)
	}

	// For a syntax list, it is possible that one of its children has JSDocComment nodes, while
	// the syntax list itself considers them as normal trivia. Therefore if we simply skip
	// trivia for the list, we may have skipped the JSDocComment as well. So we should process its
	// first child to determine the actual position of its first token.
	if node.kind == SyntaxKindSyntaxList {
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: sourceFile ??= getSourceFileOfNode(node) */ TODO
		first := firstOrUndefined(getNodeChildren(node, sourceFile))
		if first {
			return getTokenPosOfNode(first, sourceFile, includeJsDoc)
		}
	}

	return skipTrivia(( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: sourceFile ?? getSourceFileOfNode(node) */ TODO).text, node.pos, false, false, isInJSDoc(node))
}

/** @internal */

func getNonDecoratorTokenPosOfNode(node Node, sourceFile SourceFileLike) number {
	var lastDecorator *Decorator
	if !nodeIsMissing(node) && canHaveModifiers(node) {
		lastDecorator = findLast(node.modifiers, isDecorator)
	} else {
		lastDecorator = nil
	}
	if !lastDecorator {
		return getTokenPosOfNode(node, sourceFile)
	}

	return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, lastDecorator.end)
}

/** @internal */

func getNonModifierTokenPosOfNode(node Node, sourceFile SourceFileLike) number {
	var lastModifier * /* TODO(TS-TO-GO) inferred type Decorator | AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword */ any
	if !nodeIsMissing(node) && canHaveModifiers(node) && node.modifiers {
		lastModifier = last(node.modifiers)
	} else {
		lastModifier = nil
	}
	if !lastModifier {
		return getTokenPosOfNode(node, sourceFile)
	}

	return skipTrivia((sourceFile || getSourceFileOfNode(node)).text, lastModifier.end)
}

/** @internal */

func getSourceTextOfNodeFromSourceFile(sourceFile SourceFile, node Node, includeTrivia bool /*  = false */) string {
	return getTextOfNodeFromSourceText(sourceFile.text, node, includeTrivia)
}

func isJSDocTypeExpressionOrChild(node Node) bool {
	return !!findAncestor(node, isJSDocTypeExpression)
}

/** @internal */

func isExportNamespaceAsDefaultDeclaration(node Node) bool {
	return !!(isExportDeclaration(node) && node.exportClause && isNamespaceExport(node.exportClause) && moduleExportNameIsDefault(node.exportClause.name))
}

/** @internal */

func moduleExportNameTextUnescaped(node ModuleExportName) string {
	if node.kind == SyntaxKindStringLiteral {
		return node.text
	} else {
		return unescapeLeadingUnderscores(node.escapedText)
	}
}

/** @internal */

func moduleExportNameTextEscaped(node ModuleExportName) __String {
	if node.kind == SyntaxKindStringLiteral {
		return escapeLeadingUnderscores(node.text)
	} else {
		return node.escapedText
	}
}

/**
 * Equality checks against a keyword without underscores don't need to bother
 * to turn "__" into "___" or vice versa, since they will never be equal in
 * either case. So we can ignore those cases to improve performance.
 *
 * @internal
 */

func moduleExportNameIsDefault(node ModuleExportName) bool {
	return (__COND__(node.kind == SyntaxKindStringLiteral, node.text, node.escapedText)) == InternalSymbolNameDefault
}

/** @internal */

func getTextOfNodeFromSourceText(sourceText string, node Node, includeTrivia bool /*  = false */) string {
	if nodeIsMissing(node) {
		return ""
	}

	text := sourceText.substring(__COND__(includeTrivia, node.pos, skipTrivia(sourceText, node.pos)), node.end)

	if isJSDocTypeExpressionOrChild(node) {
		// strip space + asterisk at line start
		text = text.split(regexp.MustParse(`\r\n|\n|\r`)).map_(func(line string) string {
			return line.replace(regexp.MustParse(`^\s*\*`), "").trimStart()
		}).join("\n")
	}

	return text
}

/** @internal */

func getTextOfNode(node Node, includeTrivia bool /*  = false */) string {
	return getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node, includeTrivia)
}

func getPos(range_ Node) number {
	return range_.pos
}

/**
 * Note: it is expected that the `nodeArray` and the `node` are within the same file.
 * For example, searching for a `SourceFile` in a `SourceFile[]` wouldn't work.
 *
 * @internal
 */

func indexOfNode(nodeArray []Node, node Node) number {
	return binarySearch(nodeArray, node, getPos, compareValues)
}

/**
 * Gets flags that control emit behavior of a node.
 *
 * @internal
 */

func getEmitFlags(node Node) EmitFlags {
	emitNode := node.emitNode
	return emitNode && emitNode.flags || 0
}

/**
 * Gets flags that control emit behavior of a node.
 *
 * @internal
 */

func getInternalEmitFlags(node Node) InternalEmitFlags {
	emitNode := node.emitNode
	return emitNode && emitNode.internalFlags || 0
}

// Map from a type name, to a map of targets to array of features introduced to the type at that target.

type ScriptTargetFeatures ReadonlyMap[string, ReadonlyMap[string, []string]]

/** @internal */

var getScriptTargetFeatures func() ScriptTargetFeatures = memoize(func() ScriptTargetFeatures {
	return NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"find", "findIndex", "fill", "copyWithin", "entries", "keys", "values"},
			"es2016": []string{"includes"},
			"es2019": []string{"flat", "flatMap"},
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Iterator": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": emptyArray,
		})),
		"AsyncIterator": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": emptyArray,
		})),
		"Atomics": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2017": emptyArray,
		})),
		"SharedArrayBuffer": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2017": emptyArray,
		})),
		"AsyncIterable": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": emptyArray,
		})),
		"AsyncIterableIterator": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": emptyArray,
		})),
		"AsyncGenerator": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": emptyArray,
		})),
		"AsyncGeneratorFunction": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": emptyArray,
		})),
		"RegExp": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"flags", "sticky", "unicode"},
			"es2018": []string{"dotAll"},
		})),
		"Reflect": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"apply", "construct", "defineProperty", "deleteProperty", "get", "getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "set", "setPrototypeOf"},
		})),
		"ArrayConstructor": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"from", "of"},
			"esnext": []string{"fromAsync"},
		})),
		"ObjectConstructor": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"assign", "getOwnPropertySymbols", "keys", "is", "setPrototypeOf"},
			"es2017": []string{"values", "entries", "getOwnPropertyDescriptors"},
			"es2019": []string{"fromEntries"},
			"es2022": []string{"hasOwn"},
		})),
		"NumberConstructor": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"isFinite", "isInteger", "isNaN", "isSafeInteger", "parseFloat", "parseInt"},
		})),
		"Math": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"clz32", "imul", "sign", "log10", "log2", "log1p", "expm1", "cosh", "sinh", "tanh", "acosh", "asinh", "atanh", "hypot", "trunc", "fround", "cbrt"},
		})),
		"Map": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"entries", "keys", "values"},
		})),
		"Set": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"entries", "keys", "values"},
		})),
		"PromiseConstructor": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"all", "race", "reject", "resolve"},
			"es2020": []string{"allSettled"},
			"es2021": []string{"any"},
		})),
		"Symbol": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"for", "keyFor"},
			"es2019": []string{"description"},
		})),
		"WeakMap": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"entries", "keys", "values"},
		})),
		"WeakSet": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"entries", "keys", "values"},
		})),
		"String": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"codePointAt", "includes", "endsWith", "normalize", "repeat", "startsWith", "anchor", "big", "blink", "bold", "fixed", "fontcolor", "fontsize", "italics", "link", "small", "strike", "sub", "sup"},
			"es2017": []string{"padStart", "padEnd"},
			"es2019": []string{"trimStart", "trimEnd", "trimLeft", "trimRight"},
			"es2020": []string{"matchAll"},
			"es2021": []string{"replaceAll"},
			"es2022": []string{"at"},
			"esnext": []string{"isWellFormed", "toWellFormed"},
		})),
		"StringConstructor": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": []string{"fromCodePoint", "raw"},
		})),
		"DateTimeFormat": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2017": []string{"formatToParts"},
		})),
		"Promise": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2015": emptyArray,
			"es2018": []string{"finally"},
		})),
		"RegExpMatchArray": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": []string{"groups"},
		})),
		"RegExpExecArray": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": []string{"groups"},
		})),
		"Intl": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": []string{"PluralRules"},
		})),
		"NumberFormat": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2018": []string{"formatToParts"},
		})),
		"SymbolConstructor": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2020": []string{"matchAll"},
		})),
		"DataView": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2020": []string{"setBigInt64", "setBigUint64", "getBigInt64", "getBigUint64"},
		})),
		"BigInt": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2020": emptyArray,
		})),
		"RelativeTimeFormat": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2020": []string{"format", "formatToParts", "resolvedOptions"},
		})),
		"Int8Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Uint8Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Uint8ClampedArray": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Int16Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Uint16Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Int32Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Uint32Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Float32Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Float64Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"BigInt64Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2020": emptyArray,
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"BigUint64Array": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2020": emptyArray,
			"es2022": []string{"at"},
			"es2023": []string{"findLastIndex", "findLast", "toReversed", "toSorted", "toSpliced", "with"},
		})),
		"Error": NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"es2022": []string{"cause"},
		})),
	}))
})

/** @internal */

type GetLiteralTextFlags int32

const (
	GetLiteralTextFlagsNone                          GetLiteralTextFlags = 0
	GetLiteralTextFlagsNeverAsciiEscape              GetLiteralTextFlags = 1 << 0
	GetLiteralTextFlagsJsxAttributeEscape            GetLiteralTextFlags = 1 << 1
	GetLiteralTextFlagsTerminateUnterminatedLiterals GetLiteralTextFlags = 1 << 2
	GetLiteralTextFlagsAllowNumericSeparator         GetLiteralTextFlags = 1 << 3
)

/** @internal */

func getLiteralText(node LiteralLikeNode, sourceFile *SourceFile, flags GetLiteralTextFlags) string {
	// If we don't need to downlevel and we can reach the original source text using
	// the node's parent reference, then simply get the text as it was originally written.
	if sourceFile && canUseOriginalText(node, flags) {
		return getSourceTextOfNodeFromSourceFile(sourceFile, node)
	}

	// If we can't reach the original source text, use the canonical form if it's a number,
	// or a (possibly escaped) quoted form of the original text if it's string-like.
	switch node.kind {
	case SyntaxKindStringLiteral:
		var escapeText /* TODO(TS-TO-GO) inferred type typeof escapeJsxAttributeString */ any
		switch {
		case flags & GetLiteralTextFlagsJsxAttributeEscape:
			escapeText = escapeJsxAttributeString
		case flags&GetLiteralTextFlagsNeverAsciiEscape || (getEmitFlags(node) & EmitFlagsNoAsciiEscaping):
			escapeText = escapeString
		default:
			escapeText = escapeNonAsciiString
		}
		if (node /* as StringLiteral */).singleQuote {
			return "'" + escapeText(node.text, CharacterCodessingleQuote) + "'"
		} else {
			return "\"" + escapeText(node.text, CharacterCodesdoubleQuote) + "\""
		}
		fallthrough
	case SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindTemplateHead,
		SyntaxKindTemplateMiddle,
		SyntaxKindTemplateTail:
		// If a NoSubstitutionTemplateLiteral appears to have a substitution in it, the original text
		// had to include a backslash: `not \${a} substitution`.
		var escapeText /* TODO(TS-TO-GO) inferred type typeof escapeString */ any
		if flags&GetLiteralTextFlagsNeverAsciiEscape || (getEmitFlags(node) & EmitFlagsNoAsciiEscaping) {
			escapeText = escapeString
		} else {
			escapeText = escapeNonAsciiString
		}

		rawText := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (node as TemplateLiteralLikeNode).rawText ?? escapeTemplateSubstitution(escapeText(node.text, CharacterCodes.backtick)) */ TODO
		switch node.kind {
		case SyntaxKindNoSubstitutionTemplateLiteral:
			return "`" + rawText + "`"
		case SyntaxKindTemplateHead:
			return "`" + rawText + "${"
		case SyntaxKindTemplateMiddle:
			return "}" + rawText + "${"
		case SyntaxKindTemplateTail:
			return "}" + rawText + "`"
		}
		break
		fallthrough
	case SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral:
		return node.text
	case SyntaxKindRegularExpressionLiteral:
		if flags&GetLiteralTextFlagsTerminateUnterminatedLiterals && node.isUnterminated {
			return node.text + (__COND__(node.text.charCodeAt(node.text.length-1) == CharacterCodesbackslash, " /", "/"))
		}
		return node.text
	}

	return Debug.fail(__TEMPLATE__("Literal kind '", node.kind, "' not accounted for."))
}

func canUseOriginalText(node LiteralLikeNode, flags GetLiteralTextFlags) bool {
	if nodeIsSynthesized(node) || !node.parent || (flags&GetLiteralTextFlagsTerminateUnterminatedLiterals && node.isUnterminated) {
		return false
	}

	if isNumericLiteral(node) {
		if node.numericLiteralFlags & TokenFlagsIsInvalid {
			return false
		}
		if node.numericLiteralFlags & TokenFlagsContainsSeparator {
			return !!(flags & GetLiteralTextFlagsAllowNumericSeparator)
		}
	}

	return !isBigIntLiteral(node)
}

/** @internal */

func getTextOfConstantValue(value /* TODO(TS-TO-GO) TypeNode UnionType: string | number */ any) string {
	if isString(value) {
		return __TEMPLATE__("\"", escapeString(value), "\"")
	} else {
		return "" + value
	}
}

// Make an identifier from an external module name by extracting the string after the last "/" and replacing
// all non-alphanumeric characters with underscores

func makeIdentifierFromModuleName(moduleName string) string {
	return getBaseFileName(moduleName).replace(regexp.MustParse(`^(\d)`), "_$1").replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\W/g */ TODO, "_")
}

/** @internal */

func isBlockOrCatchScoped(declaration Declaration) bool {
	return (getCombinedNodeFlags(declaration)&NodeFlagsBlockScoped) != 0 || isCatchClauseVariableDeclarationOrBindingElement(declaration)
}

/** @internal */

func isCatchClauseVariableDeclarationOrBindingElement(declaration Declaration) bool {
	node := getRootDeclaration(declaration)
	return node.kind == SyntaxKindVariableDeclaration && node.parent.kind == SyntaxKindCatchClause
}

/** @internal */

func isAmbientModule(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AmbientModuleDeclaration */ any {
	return isModuleDeclaration(node) && (node.name.kind == SyntaxKindStringLiteral || isGlobalScopeAugmentation(node))
}

/** @internal */

func isModuleWithStringLiteralName(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ModuleDeclaration */ any {
	return isModuleDeclaration(node) && node.name.kind == SyntaxKindStringLiteral
}

/** @internal */

func isNonGlobalAmbientModule(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ModuleDeclaration & { name: StringLiteral; } */ any {
	return isModuleDeclaration(node) && isStringLiteral(node.name)
}

/**
 * An effective module (namespace) declaration is either
 * 1. An actual declaration: namespace X { ... }
 * 2. A Javascript declaration, which is:
 *    An identifier in a nested property access expression: Y in `X.Y.Z = { ... }`
 */

func isEffectiveModuleDeclaration(node Node) bool {
	return isModuleDeclaration(node) || isIdentifier(node)
}

/**
 * Given a symbol for a module, checks that it is a shorthand ambient module.
 *
 * @internal
 */

func isShorthandAmbientModuleSymbol(moduleSymbol Symbol) bool {
	return isShorthandAmbientModule(moduleSymbol.valueDeclaration)
}

func isShorthandAmbientModule(node Node) bool {
	// The only kind of module that can be missing a body is a shorthand ambient module.
	return !!node && node.kind == SyntaxKindModuleDeclaration && (!(node /* as ModuleDeclaration */).body)
}

/** @internal */

func isBlockScopedContainerTopLevel(node Node) bool {
	return node.kind == SyntaxKindSourceFile || node.kind == SyntaxKindModuleDeclaration || isFunctionLikeOrClassStaticBlockDeclaration(node)
}

/** @internal */

func isGlobalScopeAugmentation(module ModuleDeclaration) bool {
	return !!(module.flags & NodeFlagsGlobalAugmentation)
}

/** @internal */

func isExternalModuleAugmentation(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AmbientModuleDeclaration */ any {
	return isAmbientModule(node) && isModuleAugmentationExternal(node)
}

/** @internal */

func isModuleAugmentationExternal(node AmbientModuleDeclaration) bool {
	// external module augmentation is a ambient module declaration that is either:
	// - defined in the top level scope and source file is an external module
	// - defined inside ambient module declaration located in the top level scope and source file not an external module
	switch node.parent.kind {
	case SyntaxKindSourceFile:
		return isExternalModule(node.parent)
	case SyntaxKindModuleBlock:
		return isAmbientModule(node.parent.parent) && isSourceFile(node.parent.parent.parent) && !isExternalModule(node.parent.parent.parent)
	}
	return false
}

/** @internal */

func getNonAugmentationDeclaration(symbol Symbol) Declaration {
	return symbol.declarations. /* ? */ find(func(d Declaration) bool {
		return !isExternalModuleAugmentation(d) && !(isModuleDeclaration(d) && isGlobalScopeAugmentation(d))
	})
}

func isCommonJSContainingModuleKind(kind ModuleKind) bool {
	return kind == ModuleKindCommonJS || kind == ModuleKindNode16 || kind == ModuleKindNodeNext
}

/** @internal */

func isEffectiveExternalModule(node SourceFile, compilerOptions CompilerOptions) bool {
	return isExternalModule(node) || (isCommonJSContainingModuleKind(getEmitModuleKind(compilerOptions)) && !!node.commonJsModuleIndicator)
}

/**
 * Returns whether the source file will be treated as if it were in strict mode at runtime.
 *
 * @internal
 */

func isEffectiveStrictModeSourceFile(node SourceFile, compilerOptions CompilerOptions) bool {
	// We can only verify strict mode for JS/TS files
	switch node.scriptKind {
	case ScriptKindJS,
		ScriptKindTS,
		ScriptKindJSX,
		ScriptKindTSX:
	default:
		return false
	}
	// Strict mode does not matter for declaration files.
	if node.isDeclarationFile {
		return false
	}
	// If `alwaysStrict` is set, then treat the file as strict.
	if getStrictOptionValue(compilerOptions, "alwaysStrict") {
		return true
	}
	// Starting with a "use strict" directive indicates the file is strict.
	if startsWithUseStrict(node.statements) {
		return true
	}
	if isExternalModule(node) || getIsolatedModules(compilerOptions) {
		// Modules are always strict.
		return true
	}
	return false
}

/** @internal */

func isAmbientPropertyDeclaration(node PropertyDeclaration) bool {
	return !!(node.flags & NodeFlagsAmbient) || hasSyntacticModifier(node, ModifierFlagsAmbient)
}

/** @internal */

func isBlockScope(node Node, parentNode Node) bool {
	switch node.kind {
	case SyntaxKindSourceFile,
		SyntaxKindCaseBlock,
		SyntaxKindCatchClause,
		SyntaxKindModuleDeclaration,
		SyntaxKindForStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement,
		SyntaxKindConstructor,
		SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindPropertyDeclaration,
		SyntaxKindClassStaticBlockDeclaration:
		return true
	case SyntaxKindBlock:
		return !isFunctionLikeOrClassStaticBlockDeclaration(parentNode)
	}

	return false
}

/** @internal */

func isDeclarationWithTypeParameters(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is DeclarationWithTypeParameters */ any {
	Debug.type_(node)
	switch node.kind {
	case SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocSignature:
		return true
	default:
		assertType(node)
		return isDeclarationWithTypeParameterChildren(node)
	}
}

/** @internal */

func isDeclarationWithTypeParameterChildren(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is DeclarationWithTypeParameterChildren */ any {
	Debug.type_(node)
	switch node.kind {
	case SyntaxKindCallSignature,
		SyntaxKindConstructSignature,
		SyntaxKindMethodSignature,
		SyntaxKindIndexSignature,
		SyntaxKindFunctionType,
		SyntaxKindConstructorType,
		SyntaxKindJSDocFunctionType,
		SyntaxKindClassDeclaration,
		SyntaxKindClassExpression,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindJSDocTemplateTag,
		SyntaxKindFunctionDeclaration,
		SyntaxKindMethodDeclaration,
		SyntaxKindConstructor,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return true
	default:
		assertType(node)
		return false
	}
}

/** @internal */

func isAnyImportSyntax(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AnyImportSyntax */ any {
	switch node.kind {
	case SyntaxKindImportDeclaration,
		SyntaxKindImportEqualsDeclaration:
		return true
	default:
		return false
	}
}

/** @internal */

func isAnyImportOrBareOrAccessedRequire(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AnyImportOrBareOrAccessedRequire */ any {
	return isAnyImportSyntax(node) || isVariableDeclarationInitializedToBareOrAccessedRequire(node)
}

/** @internal */

func isAnyImportOrRequireStatement(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AnyImportOrRequireStatement */ any {
	return isAnyImportSyntax(node) || isRequireVariableStatement(node)
}

/** @internal */

func isLateVisibilityPaintedStatement(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LateVisibilityPaintedStatement */ any {
	switch node.kind {
	case SyntaxKindImportDeclaration,
		SyntaxKindImportEqualsDeclaration,
		SyntaxKindVariableStatement,
		SyntaxKindClassDeclaration,
		SyntaxKindFunctionDeclaration,
		SyntaxKindModuleDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindEnumDeclaration:
		return true
	default:
		return false
	}
}

/** @internal */

func hasPossibleExternalModuleReference(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any {
	return isAnyImportOrReExport(node) || isModuleDeclaration(node) || isImportTypeNode(node) || isImportCall(node)
}

/** @internal */

func isAnyImportOrReExport(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AnyImportOrReExport */ any {
	return isAnyImportSyntax(node) || isExportDeclaration(node)
}

/** @internal */

func getEnclosingContainer(node Node) Node {
	return findAncestor(node.parent, func(n Node) bool {
		return !!(getContainerFlags(n) & ContainerFlagsIsContainer)
	})
}

// Gets the nearest enclosing block scope container that has the provided node
// as a descendant, that is not the provided node.

func getEnclosingBlockScopeContainer(node Node) Node {
	return findAncestor(node.parent, func(current Node) bool {
		return isBlockScope(current, current.parent)
	})
}

/** @internal */

func forEachEnclosingBlockScopeContainer(node Node, cb func(container Node)) {
	container := getEnclosingBlockScopeContainer(node)
	for container {
		cb(container)
		container = getEnclosingBlockScopeContainer(container)
	}
}

// Return display name of an identifier
// Computed property names will just be emitted as "[<expr>]", where <expr> is the source
// text of the expression in the computed property.

func declarationNameToString(name /* TODO(TS-TO-GO) TypeNode UnionType: DeclarationName | QualifiedName | undefined */ any) string {
	if !name || getFullWidth(name) == 0 {
		return "(Missing)"
	} else {
		return getTextOfNode(name)
	}
}

/** @internal */

func getNameFromIndexInfo(info IndexInfo) *string {
	if info.declaration {
		return declarationNameToString(info.declaration.parameters[0].name)
	} else {
		return nil
	}
}

/** @internal */

func isComputedNonLiteralName(name PropertyName) bool {
	return name.kind == SyntaxKindComputedPropertyName && !isStringOrNumericLiteralLike(name.expression)
}

/** @internal */

func tryGetTextOfPropertyName(name /* TODO(TS-TO-GO) TypeNode UnionType: PropertyName | NoSubstitutionTemplateLiteral | JsxAttributeName */ any) *__String {
	switch name.kind {
	case SyntaxKindIdentifier,
		SyntaxKindPrivateIdentifier:
		if name.emitNode. /* ? */ autoGenerate {
			return nil
		} else {
			return name.escapedText
		}
	case SyntaxKindStringLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral:
		return escapeLeadingUnderscores(name.text)
	case SyntaxKindComputedPropertyName:
		if isStringOrNumericLiteralLike(name.expression) {
			return escapeLeadingUnderscores(name.expression.text)
		}
		return nil
	case SyntaxKindJsxNamespacedName:
		return getEscapedTextOfJsxNamespacedName(name)
	default:
		return Debug.assertNever(name)
	}
}

/** @internal */

func getTextOfPropertyName(name /* TODO(TS-TO-GO) TypeNode UnionType: PropertyName | NoSubstitutionTemplateLiteral | JsxAttributeName */ any) __String {
	return Debug.checkDefined(tryGetTextOfPropertyName(name))
}

/** @internal */

func entityNameToString(name /* TODO(TS-TO-GO) TypeNode UnionType: EntityNameOrEntityNameExpression | JSDocMemberName | JsxTagNameExpression | PrivateIdentifier */ any) string {
	switch name.kind {
	case SyntaxKindThisKeyword:
		return "this"
	case SyntaxKindPrivateIdentifier,
		SyntaxKindIdentifier:
		if getFullWidth(name) == 0 {
			return idText(name)
		} else {
			return getTextOfNode(name)
		}
	case SyntaxKindQualifiedName:
		return entityNameToString(name.left) + "." + entityNameToString(name.right)
	case SyntaxKindPropertyAccessExpression:
		if isIdentifier(name.name) || isPrivateIdentifier(name.name) {
			return entityNameToString(name.expression) + "." + entityNameToString(name.name)
		} else {
			return Debug.assertNever(name.name)
		}
		fallthrough
	case SyntaxKindJSDocMemberName:
		return entityNameToString(name.left) + "#" + entityNameToString(name.right)
	case SyntaxKindJsxNamespacedName:
		return entityNameToString(name.namespace) + ":" + entityNameToString(name.name)
	default:
		return Debug.assertNever(name)
	}
}

/** @internal */

func createDiagnosticForNode(node Node, message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
	sourceFile := getSourceFileOfNode(node)
	return createDiagnosticForNodeInSourceFile(sourceFile, node, message, args...)
}

/** @internal */

func createDiagnosticForNodeArray(sourceFile SourceFile, nodes NodeArray[Node], message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
	start := skipTrivia(sourceFile.text, nodes.pos)
	return createFileDiagnostic(sourceFile, start, nodes.end-start, message, args...)
}

/** @internal */

func createDiagnosticForNodeInSourceFile(sourceFile SourceFile, node Node, message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
	span := getErrorSpanForNode(sourceFile, node)
	return createFileDiagnostic(sourceFile, span.start, span.length, message, args...)
}

/** @internal */

func createDiagnosticForNodeFromMessageChain(sourceFile SourceFile, node Node, messageChain DiagnosticMessageChain, relatedInformation []DiagnosticRelatedInformation) DiagnosticWithLocation {
	span := getErrorSpanForNode(sourceFile, node)
	return createFileDiagnosticFromMessageChain(sourceFile, span.start, span.length, messageChain, relatedInformation)
}

/** @internal */

func createDiagnosticForNodeArrayFromMessageChain(sourceFile SourceFile, nodes NodeArray[Node], messageChain DiagnosticMessageChain, relatedInformation []DiagnosticRelatedInformation) DiagnosticWithLocation {
	start := skipTrivia(sourceFile.text, nodes.pos)
	return createFileDiagnosticFromMessageChain(sourceFile, start, nodes.end-start, messageChain, relatedInformation)
}

func assertDiagnosticLocation(sourceText string, start number, length number) {
	Debug.assertGreaterThanOrEqual(start, 0)
	Debug.assertGreaterThanOrEqual(length, 0)
	Debug.assertLessThanOrEqual(start, sourceText.length)
	Debug.assertLessThanOrEqual(start+length, sourceText.length)
}

/** @internal */

func createFileDiagnosticFromMessageChain(file SourceFile, start number, length number, messageChain DiagnosticMessageChain, relatedInformation []DiagnosticRelatedInformation) DiagnosticWithLocation {
	assertDiagnosticLocation(file.text, start, length)
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":               file,
		"start":              start,
		"length":             length,
		"code":               messageChain.code,
		"category":           messageChain.category,
		"messageText":        __COND__(messageChain.next, messageChain, messageChain.messageText),
		"relatedInformation": relatedInformation,
		"canonicalHead":      messageChain.canonicalHead,
	}
}

/** @internal */

func createDiagnosticForFileFromMessageChain(sourceFile SourceFile, messageChain DiagnosticMessageChain, relatedInformation []DiagnosticRelatedInformation) DiagnosticWithLocation {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":               sourceFile,
		"start":              0,
		"length":             0,
		"code":               messageChain.code,
		"category":           messageChain.category,
		"messageText":        __COND__(messageChain.next, messageChain, messageChain.messageText),
		"relatedInformation": relatedInformation,
	}
}

/** @internal */

func createDiagnosticMessageChainFromDiagnostic(diagnostic DiagnosticRelatedInformation) DiagnosticMessageChain {
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof diagnostic.messageText */ TODO == "string" {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"code":        diagnostic.code,
			"category":    diagnostic.category,
			"messageText": diagnostic.messageText,
			"next":        (diagnostic /* as DiagnosticMessageChain */).next,
		}
	} else {
		return diagnostic.messageText
	}
}

/** @internal */

func createDiagnosticForRange(sourceFile SourceFile, range_ TextRange, message DiagnosticMessage) DiagnosticWithLocation {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":        sourceFile,
		"start":       range_.pos,
		"length":      range_.end - range_.pos,
		"code":        message.code,
		"category":    message.category,
		"messageText": message.message,
	}
}

/** @internal */

func getCanonicalDiagnostic(message DiagnosticMessage, args []string) CanonicalDiagnostic {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"code":        message.code,
		"messageText": formatMessage(message, args...),
	}
}

/** @internal */

func getSpanOfTokenAtPosition(sourceFile SourceFile, pos number) TextSpan {
	scanner := createScanner(sourceFile.languageVersion /*skipTrivia*/, true, sourceFile.languageVariant, sourceFile.text /*onError*/, nil, pos)
	scanner.scan()
	start := scanner.getTokenStart()
	return createTextSpanFromBounds(start, scanner.getTokenEnd())
}

/** @internal */

func scanTokenAtPosition(sourceFile SourceFile, pos number) SyntaxKind {
	scanner := createScanner(sourceFile.languageVersion /*skipTrivia*/, true, sourceFile.languageVariant, sourceFile.text /*onError*/, nil, pos)
	scanner.scan()
	return scanner.getToken()
}

func getErrorSpanForArrowFunction(sourceFile SourceFile, node ArrowFunction) TextSpan {
	pos := skipTrivia(sourceFile.text, node.pos)
	if node.body && node.body.kind == SyntaxKindBlock {
		TODO_IDENTIFIER := getLineAndCharacterOfPosition(sourceFile, node.body.pos)
		TODO_IDENTIFIER := getLineAndCharacterOfPosition(sourceFile, node.body.end)
		if startLine < endLine {
			// The arrow function spans multiple lines,
			// make the error span be the first line, inclusive.
			return createTextSpan(pos, getEndLinePosition(startLine, sourceFile)-pos+1)
		}
	}
	return createTextSpanFromBounds(pos, node.end)
}

/** @internal */

func getErrorSpanForNode(sourceFile SourceFile, node Node) TextSpan {
	var errorNode Node = node
	switch node.kind {
	case SyntaxKindSourceFile:
		pos := skipTrivia(sourceFile.text, 0 /*stopAfterLineBreak*/, false)
		if pos == sourceFile.text.length {
			// file is empty - return span for the beginning of the file
			return createTextSpan(0, 0)
		}
		return getSpanOfTokenAtPosition(sourceFile, pos)
		fallthrough
	case SyntaxKindVariableDeclaration,
		SyntaxKindBindingElement,
		SyntaxKindClassDeclaration,
		SyntaxKindClassExpression,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindModuleDeclaration,
		SyntaxKindEnumDeclaration,
		SyntaxKindEnumMember,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature,
		SyntaxKindNamespaceImport:
		errorNode = (node /* as NamedDeclaration */).name
	case SyntaxKindArrowFunction:
		return getErrorSpanForArrowFunction(sourceFile, node /* as ArrowFunction */)
	case SyntaxKindCaseClause,
		SyntaxKindDefaultClause:
		start := skipTrivia(sourceFile.text, (node /* as CaseOrDefaultClause */).pos)
		var end number
		if (node /* as CaseOrDefaultClause */).statements.length > 0 {
			end = (node /* as CaseOrDefaultClause */).statements[0].pos
		} else {
			end = (node /* as CaseOrDefaultClause */).end
		}
		return createTextSpanFromBounds(start, end)
		fallthrough
	case SyntaxKindReturnStatement,
		SyntaxKindYieldExpression:
		pos := skipTrivia(sourceFile.text, (node /* as ReturnStatement | YieldExpression */).pos)
		return getSpanOfTokenAtPosition(sourceFile, pos)
		fallthrough
	case SyntaxKindSatisfiesExpression:
		pos := skipTrivia(sourceFile.text, (node /* as SatisfiesExpression */).expression.end)
		return getSpanOfTokenAtPosition(sourceFile, pos)
		fallthrough
	case SyntaxKindJSDocSatisfiesTag:
		pos := skipTrivia(sourceFile.text, (node /* as JSDocSatisfiesTag */).tagName.pos)
		return getSpanOfTokenAtPosition(sourceFile, pos)
		fallthrough
	case SyntaxKindConstructor:
		constructorDeclaration := node /* as ConstructorDeclaration */
		start := skipTrivia(sourceFile.text, constructorDeclaration.pos)
		scanner := createScanner(sourceFile.languageVersion /*skipTrivia*/, true, sourceFile.languageVariant, sourceFile.text /*onError*/, nil, start)
		token := scanner.scan()
		for token != SyntaxKindConstructorKeyword && token != SyntaxKindEndOfFileToken {
			token = scanner.scan()
		}
		end := scanner.getTokenEnd()
		return createTextSpanFromBounds(start, end)
	}

	if errorNode == nil {
		// If we don't have a better node, then just set the error on the first token of
		// construct.
		return getSpanOfTokenAtPosition(sourceFile, node.pos)
	}

	Debug.assert(!isJSDoc(errorNode))

	isMissing := nodeIsMissing(errorNode)
	var pos number
	if isMissing || isJsxText(node) {
		pos = errorNode.pos
	} else {
		pos = skipTrivia(sourceFile.text, errorNode.pos)
	}

	// These asserts should all be satisfied for a properly constructed `errorNode`.
	if isMissing {
		Debug.assert(pos == errorNode.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")
		Debug.assert(pos == errorNode.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")
	} else {
		Debug.assert(pos >= errorNode.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")
		Debug.assert(pos <= errorNode.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809")
	}

	return createTextSpanFromBounds(pos, errorNode.end)
}

/** @internal */

func isGlobalSourceFile(node Node) bool {
	return node.kind == SyntaxKindSourceFile && !isExternalOrCommonJsModule(node /* as SourceFile */)
}

/** @internal */

func isExternalOrCommonJsModule(file SourceFile) bool {
	return (file.externalModuleIndicator || file.commonJsModuleIndicator) != nil
}

/** @internal */

func isJsonSourceFile(file SourceFile) /* TODO(TS-TO-GO) TypeNode TypePredicate: file is JsonSourceFile */ any {
	return file.scriptKind == ScriptKindJSON
}

/** @internal */

func isEnumConst(node EnumDeclaration) bool {
	return !!(getCombinedModifierFlags(node) & ModifierFlagsConst)
}

/** @internal */

func isDeclarationReadonly(declaration Declaration) bool {
	return !!(getCombinedModifierFlags(declaration)&ModifierFlagsReadonly && !isParameterPropertyDeclaration(declaration, declaration.parent))
}

/**
 * Gets whether a bound `VariableDeclaration` or `VariableDeclarationList` is part of an `await using` declaration.
 * @internal
 */

func isVarAwaitUsing(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | VariableDeclarationList */ any) bool {
	return (getCombinedNodeFlags(node) & NodeFlagsBlockScoped) == NodeFlagsAwaitUsing
}

/**
 * Gets whether a bound `VariableDeclaration` or `VariableDeclarationList` is part of a `using` declaration.
 * @internal
 */

func isVarUsing(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | VariableDeclarationList */ any) bool {
	return (getCombinedNodeFlags(node) & NodeFlagsBlockScoped) == NodeFlagsUsing
}

/**
 * Gets whether a bound `VariableDeclaration` or `VariableDeclarationList` is part of a `const` declaration.
 * @internal
 */

func isVarConst(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | VariableDeclarationList */ any) bool {
	return (getCombinedNodeFlags(node) & NodeFlagsBlockScoped) == NodeFlagsConst
}

/**
 * Gets whether a bound `VariableDeclaration` or `VariableDeclarationList` is part of a `const`, `using` or `await using` declaration.
 * @internal
 */

func isVarConstLike(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | VariableDeclarationList */ any) bool {
	blockScopeKind := getCombinedNodeFlags(node) & NodeFlagsBlockScoped
	return blockScopeKind == NodeFlagsConst || blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing
}

/**
 * Gets whether a bound `VariableDeclaration` or `VariableDeclarationList` is part of a `let` declaration.
 * @internal
 */

func isLet(node Node) bool {
	return (getCombinedNodeFlags(node) & NodeFlagsBlockScoped) == NodeFlagsLet
}

/** @internal */

func isSuperCall(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is SuperCall */ any {
	return n.kind == SyntaxKindCallExpression && (n /* as CallExpression */).expression.kind == SyntaxKindSuperKeyword
}

/** @internal */

func isImportCall(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is ImportCall */ any {
	return n.kind == SyntaxKindCallExpression && (n /* as CallExpression */).expression.kind == SyntaxKindImportKeyword
}

/** @internal */

func isImportMeta(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is ImportMetaProperty */ any {
	return isMetaProperty(n) && n.keywordToken == SyntaxKindImportKeyword && n.name.escapedText == "meta"
}

/** @internal */

func isLiteralImportTypeNode(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is LiteralImportTypeNode */ any {
	return isImportTypeNode(n) && isLiteralTypeNode(n.argument) && isStringLiteral(n.argument.literal)
}

/** @internal */

func isPrologueDirective(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is PrologueDirective */ any {
	return node.kind == SyntaxKindExpressionStatement && (node /* as ExpressionStatement */).expression.kind == SyntaxKindStringLiteral
}

/** @internal */

func isCustomPrologue(node Statement) bool {
	return !!(getEmitFlags(node) & EmitFlagsCustomPrologue)
}

/** @internal */

func isHoistedFunction(node Statement) bool {
	return isCustomPrologue(node) && isFunctionDeclaration(node)
}

func isHoistedVariable(node VariableDeclaration) bool {
	return isIdentifier(node.name) && !node.initializer
}

/** @internal */

func isHoistedVariableStatement(node Statement) bool {
	return isCustomPrologue(node) && isVariableStatement(node) && every(node.declarationList.declarations, isHoistedVariable)
}

/** @internal */

func getLeadingCommentRangesOfNode(node Node, sourceFileOfNode SourceFile) *[]CommentRange {
	if node.kind != SyntaxKindJsxText {
		return getLeadingCommentRanges(sourceFileOfNode.text, node.pos)
	} else {
		return nil
	}
}

/** @internal */

func getJSDocCommentRanges(node Node, text string) *[]CommentRange {
	var commentRanges *[]CommentRange
	if node.kind == SyntaxKindParameter || node.kind == SyntaxKindTypeParameter || node.kind == SyntaxKindFunctionExpression || node.kind == SyntaxKindArrowFunction || node.kind == SyntaxKindParenthesizedExpression || node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindExportSpecifier {
		commentRanges = concatenate(getTrailingCommentRanges(text, node.pos), getLeadingCommentRanges(text, node.pos))
	} else {
		commentRanges = getLeadingCommentRanges(text, node.pos)
	}
	// True if the comment starts with '/**' but not if it is '/**/'
	return filter(commentRanges, func(comment CommentRange) bool {
		return comment.end <= node.end && text.charCodeAt(comment.pos+1) == CharacterCodesasterisk && text.charCodeAt(comment.pos+2) == CharacterCodesasterisk && text.charCodeAt(comment.pos+3) != CharacterCodesslash
	})
}

var fullTripleSlashReferencePathRegEx = regexp.MustParse(`^\/\/\/\s*<reference\s+path\s*=\s*(?:'[^']*'|"[^"]*").*?\/>`)
var fullTripleSlashReferenceTypeReferenceDirectiveRegEx = regexp.MustParse(`^\/\/\/\s*<reference\s+types\s*=\s*(?:'[^']*'|"[^"]*").*?\/>`)
var fullTripleSlashLibReferenceRegEx = regexp.MustParse(`^\/\/\/\s*<reference\s+lib\s*=\s*(?:'[^']*'|"[^"]*").*?\/>`)
var fullTripleSlashAMDReferencePathRegEx = regexp.MustParse(`^\/\/\/\s*<amd-dependency\s+path\s*=\s*(?:'[^']*'|"[^"]*").*?\/>`)
var fullTripleSlashAMDModuleRegEx = regexp.MustParse(`^\/\/\/\s*<amd-module\s+(?:\S.*?)??\/>`)
var defaultLibReferenceRegEx = regexp.MustParse(`^\/\/\/\s*<reference\s+no-default-lib\s*=\s*(?:'[^']*'|"[^"]*")\s*\/>`)

func isPartOfTypeNode(node Node) bool {
	if SyntaxKindFirstTypeNode <= node.kind && node.kind <= SyntaxKindLastTypeNode {
		return true
	}

	switch node.kind {
	case SyntaxKindAnyKeyword,
		SyntaxKindUnknownKeyword,
		SyntaxKindNumberKeyword,
		SyntaxKindBigIntKeyword,
		SyntaxKindStringKeyword,
		SyntaxKindBooleanKeyword,
		SyntaxKindSymbolKeyword,
		SyntaxKindObjectKeyword,
		SyntaxKindUndefinedKeyword,
		SyntaxKindNullKeyword,
		SyntaxKindNeverKeyword:
		return true
	case SyntaxKindVoidKeyword:
		return node.parent.kind != SyntaxKindVoidExpression
	case SyntaxKindExpressionWithTypeArguments:
		return isPartOfTypeExpressionWithTypeArguments(node)
	case SyntaxKindTypeParameter:
		return node.parent.kind == SyntaxKindMappedType || node.parent.kind == SyntaxKindInferType
	case SyntaxKindIdentifier:
		if node.parent.kind == SyntaxKindQualifiedName && (node.parent /* as QualifiedName */).right == node {
			node = node.parent
		} else if node.parent.kind == SyntaxKindPropertyAccessExpression && (node.parent /* as PropertyAccessExpression */).name == node {
			node = node.parent
		}
		Debug.assert(node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindQualifiedName || node.kind == SyntaxKindPropertyAccessExpression, "'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.")
		fallthrough
	case SyntaxKindQualifiedName,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindThisKeyword:
		TODO_IDENTIFIER := node
		if parent.kind == SyntaxKindTypeQuery {
			return false
		}
		if parent.kind == SyntaxKindImportType {
			return !(parent /* as ImportTypeNode */).isTypeOf
		}
		// Do not recursively call isPartOfTypeNode on the parent. In the example:
		//
		//     let a: A.B.C;
		//
		// Calling isPartOfTypeNode would consider the qualified name A.B a type node.
		// Only C and A.B.C are type nodes.
		if SyntaxKindFirstTypeNode <= parent.kind && parent.kind <= SyntaxKindLastTypeNode {
			return true
		}
		switch parent.kind {
		case SyntaxKindExpressionWithTypeArguments:
			return isPartOfTypeExpressionWithTypeArguments(parent)
		case SyntaxKindTypeParameter:
			return node == (parent /* as TypeParameterDeclaration */).constraint
		case SyntaxKindJSDocTemplateTag:
			return node == (parent /* as JSDocTemplateTag */).constraint
		case SyntaxKindPropertyDeclaration,
			SyntaxKindPropertySignature,
			SyntaxKindParameter,
			SyntaxKindVariableDeclaration:
			return node == (parent /* as HasType */).type_
		case SyntaxKindFunctionDeclaration,
			SyntaxKindFunctionExpression,
			SyntaxKindArrowFunction,
			SyntaxKindConstructor,
			SyntaxKindMethodDeclaration,
			SyntaxKindMethodSignature,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			return node == (parent /* as FunctionLikeDeclaration */).type_
		case SyntaxKindCallSignature,
			SyntaxKindConstructSignature,
			SyntaxKindIndexSignature:
			return node == (parent /* as SignatureDeclaration */).type_
		case SyntaxKindTypeAssertionExpression:
			return node == (parent /* as TypeAssertion */).type_
		case SyntaxKindCallExpression,
			SyntaxKindNewExpression,
			SyntaxKindTaggedTemplateExpression:
			return contains((parent /* as CallExpression | TaggedTemplateExpression */).typeArguments, node)
		}
	}

	return false
}

func isPartOfTypeExpressionWithTypeArguments(node Node) bool {
	return isJSDocImplementsTag(node.parent) || isJSDocAugmentsTag(node.parent) || isHeritageClause(node.parent) && !isExpressionWithTypeArgumentsInClassExtendsClause(node)
}

// Warning: This has the same semantics as the forEach family of functions,
//          in that traversal terminates in the event that 'visitor' supplies a truthy value.

func forEachReturnStatement(body /* TODO(TS-TO-GO) TypeNode UnionType: Block | Statement */ any, visitor func(stmt ReturnStatement) T) *T {
	return traverse(body)

	traverse := func(node Node) *T {
		switch node.kind {
		case SyntaxKindReturnStatement:
			return visitor(node /* as ReturnStatement */)
		case SyntaxKindCaseBlock,
			SyntaxKindBlock,
			SyntaxKindIfStatement,
			SyntaxKindDoStatement,
			SyntaxKindWhileStatement,
			SyntaxKindForStatement,
			SyntaxKindForInStatement,
			SyntaxKindForOfStatement,
			SyntaxKindWithStatement,
			SyntaxKindSwitchStatement,
			SyntaxKindCaseClause,
			SyntaxKindDefaultClause,
			SyntaxKindLabeledStatement,
			SyntaxKindTryStatement,
			SyntaxKindCatchClause:
			return forEachChild(node, traverse)
		}
	}

}

/** @internal */

func forEachYieldExpression(body Block, visitor func(expr YieldExpression)) {
	return traverse(body)

	traverse := func(node Node) {
		switch node.kind {
		case SyntaxKindYieldExpression:
			visitor(node /* as YieldExpression */)
			operand := (node /* as YieldExpression */).expression
			if operand {
				traverse(operand)
			}
			return
		case SyntaxKindEnumDeclaration,
			SyntaxKindInterfaceDeclaration,
			SyntaxKindModuleDeclaration,
			SyntaxKindTypeAliasDeclaration:
			return
		default:
			if isFunctionLike(node) {
				if node.name && node.name.kind == SyntaxKindComputedPropertyName {
					// Note that we will not include methods/accessors of a class because they would require
					// first descending into the class. This is by design.
					traverse(node.name.expression)
					return
				}
			} else if !isPartOfTypeNode(node) {
				// This is the general case, which should include mostly expressions and statements.
				// Also includes NodeArrays.
				forEachChild(node, traverse)
			}
		}
	}

}

/**
 * Gets the most likely element type for a TypeNode. This is not an exhaustive test
 * as it assumes a rest argument can only be an array type (either T[], or Array<T>).
 *
 * @param node The type node.
 *
 * @internal
 */

func getRestParameterElementType(node *TypeNode) *TypeNode {
	if node && node.kind == SyntaxKindArrayType {
		return (node /* as ArrayTypeNode */).elementType
	} else if node && node.kind == SyntaxKindTypeReference {
		return singleOrUndefined((node /* as TypeReferenceNode */).typeArguments)
	} else {
		return nil
	}
}

/** @internal */

func getMembersOfDeclaration(node Declaration) *NodeArray[ /* TODO(TS-TO-GO) TypeNode UnionType: ClassElement | TypeElement | ObjectLiteralElement */ any] {
	switch node.kind {
	case SyntaxKindInterfaceDeclaration,
		SyntaxKindClassDeclaration,
		SyntaxKindClassExpression,
		SyntaxKindTypeLiteral:
		return (node /* as ObjectTypeDeclaration */).members
	case SyntaxKindObjectLiteralExpression:
		return (node /* as ObjectLiteralExpression */).properties
	}
}

/** @internal */

func isVariableLike(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is VariableLikeDeclaration */ any {
	if node {
		switch node.kind {
		case SyntaxKindBindingElement,
			SyntaxKindEnumMember,
			SyntaxKindParameter,
			SyntaxKindPropertyAssignment,
			SyntaxKindPropertyDeclaration,
			SyntaxKindPropertySignature,
			SyntaxKindShorthandPropertyAssignment,
			SyntaxKindVariableDeclaration:
			return true
		}
	}
	return false
}

/** @internal */

func isVariableLikeOrAccessor(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AccessorDeclaration | VariableLikeDeclaration */ any {
	return isVariableLike(node) || isAccessor(node)
}

/** @internal */

func isVariableDeclarationInVariableStatement(node VariableDeclaration) bool {
	return node.parent.kind == SyntaxKindVariableDeclarationList && node.parent.parent.kind == SyntaxKindVariableStatement
}

/** @internal */

func isCommonJsExportedExpression(node Node) bool {
	if !isInJSFile(node) {
		return false
	}
	return (isObjectLiteralExpression(node.parent) && isBinaryExpression(node.parent.parent) && getAssignmentDeclarationKind(node.parent.parent) == AssignmentDeclarationKindModuleExports) || isCommonJsExportPropertyAssignment(node.parent)
}

/** @internal */

func isCommonJsExportPropertyAssignment(node Node) bool {
	if !isInJSFile(node) {
		return false
	}
	return (isBinaryExpression(node) && getAssignmentDeclarationKind(node) == AssignmentDeclarationKindExportsProperty)
}

/** @internal */

func isValidESSymbolDeclaration(node Node) bool {
	return (__COND__(isVariableDeclaration(node), isVarConst(node) && isIdentifier(node.name) && isVariableDeclarationInVariableStatement(node), __COND__(isPropertyDeclaration(node), hasEffectiveReadonlyModifier(node) && hasStaticModifier(node), isPropertySignature(node) && hasEffectiveReadonlyModifier(node)))) || isCommonJsExportPropertyAssignment(node)
}

/** @internal */

func introducesArgumentsExoticObject(node Node) bool {
	switch node.kind {
	case SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindConstructor,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression:
		return true
	}
	return false
}

/** @internal */

func unwrapInnermostStatementOfLabel(node LabeledStatement, beforeUnwrapLabelCallback func(node LabeledStatement)) Statement {
	for true {
		if beforeUnwrapLabelCallback {
			beforeUnwrapLabelCallback(node)
		}
		if node.statement.kind != SyntaxKindLabeledStatement {
			return node.statement
		}
		node = node.statement /* as LabeledStatement */
	}
}

/** @internal */

func isFunctionBlock(node Node) bool {
	return node && node.kind == SyntaxKindBlock && isFunctionLike(node.parent)
}

/** @internal */

func isObjectLiteralMethod(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is MethodDeclaration */ any {
	return node && node.kind == SyntaxKindMethodDeclaration && node.parent.kind == SyntaxKindObjectLiteralExpression
}

/** @internal */

func isObjectLiteralOrClassExpressionMethodOrAccessor(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is MethodDeclaration | AccessorDeclaration */ any {
	return (node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor) && (node.parent.kind == SyntaxKindObjectLiteralExpression || node.parent.kind == SyntaxKindClassExpression)
}

/** @internal */

func isIdentifierTypePredicate(predicate TypePredicate) /* TODO(TS-TO-GO) TypeNode TypePredicate: predicate is IdentifierTypePredicate */ any {
	return predicate && predicate.kind == TypePredicateKindIdentifier
}

/** @internal */

func isThisTypePredicate(predicate TypePredicate) /* TODO(TS-TO-GO) TypeNode TypePredicate: predicate is ThisTypePredicate */ any {
	return predicate && predicate.kind == TypePredicateKindThis
}

/** @internal */

func forEachPropertyAssignment(objectLiteral *ObjectLiteralExpression, key string, callback func(property PropertyAssignment) *T, key2 string) *T {
	return forEach(objectLiteral. /* ? */ properties, func(property /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) *T {
		if !isPropertyAssignment(property) {
			return nil
		}
		propName := tryGetTextOfPropertyName(property.name)
		if key == propName || (key2 && key2 == propName) {
			return callback(property)
		} else {
			return nil
		}
	})
}

/** @internal */

func getPropertyArrayElementValue(objectLiteral ObjectLiteralExpression, propKey string, elementValue string) *StringLiteral {
	return forEachPropertyAssignment(objectLiteral, propKey, func(property PropertyAssignment) *StringLiteral {
		if isArrayLiteralExpression(property.initializer) {
			return find(property.initializer.elements, func(element Expression) /* TODO(TS-TO-GO) TypeNode TypePredicate: element is StringLiteral */ any {
				return isStringLiteral(element) && element.text == elementValue
			})
		} else {
			return nil
		}
	})
}

/** @internal */

func getTsConfigObjectLiteralExpression(tsConfigSourceFile *TsConfigSourceFile) *ObjectLiteralExpression {
	if tsConfigSourceFile && tsConfigSourceFile.statements.length {
		expression := tsConfigSourceFile.statements[0].expression
		return tryCast(expression, isObjectLiteralExpression)
	}
}

/** @internal */

func getTsConfigPropArrayElementValue(tsConfigSourceFile *TsConfigSourceFile, propKey string, elementValue string) *StringLiteral {
	return forEachTsConfigPropArray(tsConfigSourceFile, propKey, func(property PropertyAssignment) *StringLiteral {
		if isArrayLiteralExpression(property.initializer) {
			return find(property.initializer.elements, func(element Expression) /* TODO(TS-TO-GO) TypeNode TypePredicate: element is StringLiteral */ any {
				return isStringLiteral(element) && element.text == elementValue
			})
		} else {
			return nil
		}
	})
}

/** @internal */

func forEachTsConfigPropArray(tsConfigSourceFile *TsConfigSourceFile, propKey string, callback func(property PropertyAssignment) *T) *T {
	return forEachPropertyAssignment(getTsConfigObjectLiteralExpression(tsConfigSourceFile), propKey, callback)
}

/** @internal */

func getContainingFunction(node Node) *SignatureDeclaration {
	return findAncestor(node.parent, isFunctionLike)
}

/** @internal */

func getContainingFunctionDeclaration(node Node) *FunctionLikeDeclaration {
	return findAncestor(node.parent, isFunctionLikeDeclaration)
}

/** @internal */

func getContainingClass(node Node) *ClassLikeDeclaration {
	return findAncestor(node.parent, isClassLike)
}

/** @internal */

func getContainingClassStaticBlock(node Node) Node {
	return findAncestor(node.parent, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if isClassLike(n) || isFunctionLike(n) {
			return "quit"
		}
		return isClassStaticBlockDeclaration(n)
	})
}

/** @internal */

func getContainingFunctionOrClassStaticBlock(node Node) /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | ClassStaticBlockDeclaration | undefined */ any {
	return findAncestor(node.parent, isFunctionLikeOrClassStaticBlockDeclaration)
}

/** @internal */

func getContainingClassExcludingClassDecorators(node Node) *ClassLikeDeclaration {
	decorator := findAncestor(node.parent, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if isClassLike(n) {
			return "quit"
		} else {
			return isDecorator(n)
		}
	})
	if decorator && isClassLike(decorator.parent) {
		return getContainingClass(decorator.parent)
	} else {
		return getContainingClass( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: decorator ?? node */ TODO)
	}
}

/** @internal */

type ThisContainer /* TODO(TS-TO-GO) TypeNode UnionType: | FunctionDeclaration | FunctionExpression | ModuleDeclaration | ClassStaticBlockDeclaration | PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | CallSignatureDeclaration | ConstructSignatureDeclaration | IndexSignatureDeclaration | EnumDeclaration | SourceFile */ any

/** @internal */

/* OVERLOAD: export function getThisContainer(node: Node, includeArrowFunctions: false, includeClassComputedPropertyName: false): ThisContainer; */
/** @internal */

/* OVERLOAD: export function getThisContainer(node: Node, includeArrowFunctions: false, includeClassComputedPropertyName: boolean): ThisContainer | ComputedPropertyName; */
/** @internal */

/* OVERLOAD: export function getThisContainer(node: Node, includeArrowFunctions: boolean, includeClassComputedPropertyName: false): ThisContainer | ArrowFunction; */
/** @internal */

/* OVERLOAD: export function getThisContainer(node: Node, includeArrowFunctions: boolean, includeClassComputedPropertyName: boolean): ThisContainer | ArrowFunction | ComputedPropertyName; */
func getThisContainer(node Node, includeArrowFunctions bool, includeClassComputedPropertyName bool) /* TODO(TS-TO-GO) inferred type ArrowFunction | ComputedPropertyName | ThisContainer */ any {
	Debug.assert(node.kind != SyntaxKindSourceFile)
	for true {
		node = node.parent
		if !node {
			return Debug.fail()
			// If we never pass in a SourceFile, this should be unreachable, since we'll stop when we reach that.
		}
		switch node.kind {
		case SyntaxKindComputedPropertyName:
			if includeClassComputedPropertyName && isClassLike(node.parent.parent) {
				return node /* as ComputedPropertyName */
			}
			node = node.parent.parent
		case SyntaxKindDecorator:
			if node.parent.kind == SyntaxKindParameter && isClassElement(node.parent.parent) {
				// If the decorator's parent is a Parameter, we resolve the this container from
				// the grandparent class declaration.
				node = node.parent.parent
			} else if isClassElement(node.parent) {
				// If the decorator's parent is a class element, we resolve the 'this' container
				// from the parent class declaration.
				node = node.parent
			}
		case SyntaxKindArrowFunction:
			if !includeArrowFunctions {
				continue
			}
			fallthrough
		case SyntaxKindFunctionDeclaration,
			SyntaxKindFunctionExpression,
			SyntaxKindModuleDeclaration,
			SyntaxKindClassStaticBlockDeclaration,
			SyntaxKindPropertyDeclaration,
			SyntaxKindPropertySignature,
			SyntaxKindMethodDeclaration,
			SyntaxKindMethodSignature,
			SyntaxKindConstructor,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor,
			SyntaxKindCallSignature,
			SyntaxKindConstructSignature,
			SyntaxKindIndexSignature,
			SyntaxKindEnumDeclaration,
			SyntaxKindSourceFile:
			return node /* as ThisContainer | ArrowFunction */
		}
	}
}

/**
 * @returns Whether the node creates a new 'this' scope for its children.
 *
 * @internal
 */

func isThisContainerOrFunctionBlock(node Node) bool {
	switch node.kind {
	case SyntaxKindArrowFunction,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindPropertyDeclaration:
		return true
	case SyntaxKindBlock:
		switch node.parent.kind {
		case SyntaxKindConstructor,
			SyntaxKindMethodDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			return true
		default:
			return false
		}
		fallthrough
	default:
		return false
	}
}

/** @internal */

func isInTopLevelContext(node Node) bool {
	// The name of a class or function declaration is a BindingIdentifier in its surrounding scope.
	if isIdentifier(node) && (isClassDeclaration(node.parent) || isFunctionDeclaration(node.parent)) && node.parent.name == node {
		node = node.parent
	}
	container := getThisContainer(node /*includeArrowFunctions*/, true /*includeClassComputedPropertyName*/, false)
	return isSourceFile(container)
}

/** @internal */

func getNewTargetContainer(node Node) /* TODO(TS-TO-GO) TypeNode UnionType: FunctionDeclaration | ConstructorDeclaration | FunctionExpression | undefined */ any {
	container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
	if container {
		switch container.kind {
		case SyntaxKindConstructor,
			SyntaxKindFunctionDeclaration,
			SyntaxKindFunctionExpression:
			return container
		}
	}

	return nil
}

/** @internal */

type SuperContainer /* TODO(TS-TO-GO) TypeNode UnionType: | PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | ClassStaticBlockDeclaration */ any

/** @internal */

type SuperContainerOrFunctions /* TODO(TS-TO-GO) TypeNode UnionType: | SuperContainer | FunctionDeclaration | FunctionExpression | ArrowFunction */ any

/**
 * Given an super call/property node, returns the closest node where
 * - a super call/property access is legal in the node and not legal in the parent node the node.
 *   i.e. super call is legal in constructor but not legal in the class body.
 * - the container is an arrow function (so caller might need to call getSuperContainer again in case it needs to climb higher)
 * - a super call/property is definitely illegal in the container (but might be legal in some subnode)
 *   i.e. super property access is illegal in function declaration but can be legal in the statement list
 *
 * @internal
 */

/* OVERLOAD: export function getSuperContainer(node: Node, stopOnFunctions: false): SuperContainer | undefined; */
/** @internal */

/* OVERLOAD: export function getSuperContainer(node: Node, stopOnFunctions: boolean): SuperContainerOrFunctions | undefined; */
func getSuperContainer(node Node, stopOnFunctions bool) *SuperContainerOrFunctions {
	for true {
		node = node.parent
		if !node {
			return nil
		}
		switch node.kind {
		case SyntaxKindComputedPropertyName:
			node = node.parent
		case SyntaxKindFunctionDeclaration,
			SyntaxKindFunctionExpression,
			SyntaxKindArrowFunction:
			if !stopOnFunctions {
				continue
			}
			fallthrough
		case SyntaxKindPropertyDeclaration,
			SyntaxKindPropertySignature,
			SyntaxKindMethodDeclaration,
			SyntaxKindMethodSignature,
			SyntaxKindConstructor,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor,
			SyntaxKindClassStaticBlockDeclaration:
			return node /* as SuperContainerOrFunctions */
		case SyntaxKindDecorator:
			if node.parent.kind == SyntaxKindParameter && isClassElement(node.parent.parent) {
				// If the decorator's parent is a Parameter, we resolve the this container from
				// the grandparent class declaration.
				node = node.parent.parent
			} else if isClassElement(node.parent) {
				// If the decorator's parent is a class element, we resolve the 'this' container
				// from the parent class declaration.
				node = node.parent
			}
		}
	}
}

/** @internal */

func getImmediatelyInvokedFunctionExpression(func_ Node) *CallExpression {
	if func_.kind == SyntaxKindFunctionExpression || func_.kind == SyntaxKindArrowFunction {
		prev := func_
		parent := func_.parent
		for parent.kind == SyntaxKindParenthesizedExpression {
			prev = parent
			parent = parent.parent
		}
		if parent.kind == SyntaxKindCallExpression && (parent /* as CallExpression */).expression == prev {
			return parent /* as CallExpression */
		}
	}
}

/**
 * Determines whether a node is a property or element access expression for `super`.
 *
 * @internal
 */

func isSuperProperty(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is SuperProperty */ any {
	kind := node.kind
	return (kind == SyntaxKindPropertyAccessExpression || kind == SyntaxKindElementAccessExpression) && (node /* as PropertyAccessExpression | ElementAccessExpression */).expression.kind == SyntaxKindSuperKeyword
}

/**
 * Determines whether a node is a property or element access expression for `this`.
 *
 * @internal
 */

func isThisProperty(node Node) bool {
	kind := node.kind
	return (kind == SyntaxKindPropertyAccessExpression || kind == SyntaxKindElementAccessExpression) && (node /* as PropertyAccessExpression | ElementAccessExpression */).expression.kind == SyntaxKindThisKeyword
}

/** @internal */

func isThisInitializedDeclaration(node Node) bool {
	return !!node && isVariableDeclaration(node) && node.initializer. /* ? */ kind == SyntaxKindThisKeyword
}

/** @internal */

func isThisInitializedObjectBindingExpression(node Node) bool {
	return !!node && (isShorthandPropertyAssignment(node) || isPropertyAssignment(node)) && isBinaryExpression(node.parent.parent) && node.parent.parent.operatorToken.kind == SyntaxKindEqualsToken && node.parent.parent.right.kind == SyntaxKindThisKeyword
}

/** @internal */

func getEntityNameFromTypeNode(node TypeNode) *EntityNameOrEntityNameExpression {
	switch node.kind {
	case SyntaxKindTypeReference:
		return (node /* as TypeReferenceNode */).typeName
	case SyntaxKindExpressionWithTypeArguments:
		if isEntityNameExpression((node /* as ExpressionWithTypeArguments */).expression) {
			return (node /* as ExpressionWithTypeArguments */).expression /* as EntityNameExpression */
		} else {
			return nil
		}
	case SyntaxKindIdentifier, /* as TypeNodeSyntaxKind */
		SyntaxKindQualifiedName /* as TypeNodeSyntaxKind */ :
		return (node /* as Node */ /* as EntityName */)
	}

	return nil
}

/** @internal */

func getInvokedExpression(node CallLikeExpression) /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxTagNameExpression */ any {
	switch node.kind {
	case SyntaxKindTaggedTemplateExpression:
		return node.tag
	case SyntaxKindJsxOpeningElement,
		SyntaxKindJsxSelfClosingElement:
		return node.tagName
	case SyntaxKindBinaryExpression:
		return node.right
	default:
		return node.expression
	}
}

/** @internal */

/* OVERLOAD: export function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassDeclaration): true; */
/** @internal */

/* OVERLOAD: export function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassExpression): boolean; */
/** @internal */

/* OVERLOAD: export function nodeCanBeDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean; */
/** @internal */

/* OVERLOAD: export function nodeCanBeDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean; */
/** @internal */

func nodeCanBeDecorated(useLegacyDecorators bool, node Node, parent Node, grandparent Node) bool {
	// private names cannot be used with decorators yet
	if useLegacyDecorators && isNamedDeclaration(node) && isPrivateIdentifier(node.name) {
		return false
	}

	switch node.kind {
	case SyntaxKindClassDeclaration:
		return true
	case SyntaxKindClassExpression:
		return !useLegacyDecorators
	case SyntaxKindPropertyDeclaration:
		return parent != nil && (__COND__(useLegacyDecorators, isClassDeclaration(parent), isClassLike(parent) && !hasAbstractModifier(node) && !hasAmbientModifier(node)))
	case SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindMethodDeclaration:
		return (node /* as FunctionLikeDeclaration */).body != nil && parent != nil && (__COND__(useLegacyDecorators, isClassDeclaration(parent), isClassLike(parent)))
	case SyntaxKindParameter:
		if !useLegacyDecorators {
			return false
		}
		return parent != nil && (parent /* as FunctionLikeDeclaration */).body != nil && (parent.kind == SyntaxKindConstructor || parent.kind == SyntaxKindMethodDeclaration || parent.kind == SyntaxKindSetAccessor) && getThisParameter(parent /* as FunctionLikeDeclaration */) != node && grandparent != nil && grandparent.kind == SyntaxKindClassDeclaration
	}

	return false
}

/** @internal */

/* OVERLOAD: export function nodeIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean; */
/** @internal */

/* OVERLOAD: export function nodeIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean; */
/** @internal */

/* OVERLOAD: export function nodeIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean; */
/** @internal */

func nodeIsDecorated(useLegacyDecorators bool, node Node, parent Node, grandparent Node) bool {
	return hasDecorators(node) && nodeCanBeDecorated(useLegacyDecorators, node, parent, grandparent)
}

/** @internal */

/* OVERLOAD: export function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean; */
/** @internal */

/* OVERLOAD: export function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: ClassElement, parent: Node): boolean; */
/** @internal */

/* OVERLOAD: export function nodeOrChildIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node, grandparent: Node): boolean; */
/** @internal */

func nodeOrChildIsDecorated(useLegacyDecorators bool, node Node, parent Node, grandparent Node) bool {
	return nodeIsDecorated(useLegacyDecorators, node, parent, grandparent) || childIsDecorated(useLegacyDecorators, node, parent)
}

/** @internal */

/* OVERLOAD: export function childIsDecorated(useLegacyDecorators: boolean, node: ClassDeclaration | ClassExpression): boolean; */
/** @internal */

/* OVERLOAD: export function childIsDecorated(useLegacyDecorators: boolean, node: Node, parent: Node): boolean; */
/** @internal */

func childIsDecorated(useLegacyDecorators bool, node Node, parent Node) bool {
	switch node.kind {
	case SyntaxKindClassDeclaration:
		return some((node /* as ClassDeclaration */).members, func(m ClassElement) bool {
			return nodeOrChildIsDecorated(useLegacyDecorators, m, node, parent)
		})
	case SyntaxKindClassExpression:
		return !useLegacyDecorators && some((node /* as ClassExpression */).members, func(m ClassElement) bool {
			return nodeOrChildIsDecorated(useLegacyDecorators, m, node, parent)
		})
	case SyntaxKindMethodDeclaration,
		SyntaxKindSetAccessor,
		SyntaxKindConstructor:
		return some((node /* as FunctionLikeDeclaration */).parameters, func(p ParameterDeclaration) bool {
			return nodeIsDecorated(useLegacyDecorators, p, node, parent)
		})
	default:
		return false
	}
}

/** @internal */

func classOrConstructorParameterIsDecorated(useLegacyDecorators bool, node /* TODO(TS-TO-GO) TypeNode UnionType: ClassDeclaration | ClassExpression */ any) bool {
	if nodeIsDecorated(useLegacyDecorators, node) {
		return true
	}
	constructor := getFirstConstructorWithBody(node)
	return !!constructor && childIsDecorated(useLegacyDecorators, constructor, node)
}

/** @internal */

func classElementOrClassElementParameterIsDecorated(useLegacyDecorators bool, node ClassElement, parent /* TODO(TS-TO-GO) TypeNode UnionType: ClassDeclaration | ClassExpression */ any) bool {
	var parameters *NodeArray[ParameterDeclaration]
	if isAccessor(node) {
		TODO_IDENTIFIER := getAllAccessorDeclarations(parent.members, node)
		var firstAccessorWithDecorators *AccessorDeclaration
		switch {
		case hasDecorators(firstAccessor):
			firstAccessorWithDecorators = firstAccessor
		case secondAccessor && hasDecorators(secondAccessor):
			firstAccessorWithDecorators = secondAccessor
		default:
			firstAccessorWithDecorators = nil
		}
		if !firstAccessorWithDecorators || node != firstAccessorWithDecorators {
			return false
		}
		parameters = setAccessor. /* ? */ parameters
	} else if isMethodDeclaration(node) {
		parameters = node.parameters
	}
	if nodeIsDecorated(useLegacyDecorators, node, parent) {
		return true
	}
	if parameters {
		for _, parameter := range parameters {
			if parameterIsThisKeyword(parameter) {
				continue
			}
			if nodeIsDecorated(useLegacyDecorators, parameter, node, parent) {
				return true
			}
		}
	}
	return false
}

/** @internal */

func isEmptyStringLiteral(node StringLiteral) bool {
	if node.textSourceNode {
		switch node.textSourceNode.kind {
		case SyntaxKindStringLiteral:
			return isEmptyStringLiteral(node.textSourceNode)
		case SyntaxKindNoSubstitutionTemplateLiteral:
			return node.text == ""
		}
		return false
	}
	return node.text == ""
}

/** @internal */

func isJSXTagName(node Node) bool {
	TODO_IDENTIFIER := node
	if parent.kind == SyntaxKindJsxOpeningElement || parent.kind == SyntaxKindJsxSelfClosingElement || parent.kind == SyntaxKindJsxClosingElement {
		return (parent /* as JsxOpeningLikeElement */).tagName == node
	}
	return false
}

/** @internal */

func isExpressionNode(node Node) bool {
	switch node.kind {
	case SyntaxKindSuperKeyword,
		SyntaxKindNullKeyword,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindRegularExpressionLiteral,
		SyntaxKindArrayLiteralExpression,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression,
		SyntaxKindCallExpression,
		SyntaxKindNewExpression,
		SyntaxKindTaggedTemplateExpression,
		SyntaxKindAsExpression,
		SyntaxKindTypeAssertionExpression,
		SyntaxKindSatisfiesExpression,
		SyntaxKindNonNullExpression,
		SyntaxKindParenthesizedExpression,
		SyntaxKindFunctionExpression,
		SyntaxKindClassExpression,
		SyntaxKindArrowFunction,
		SyntaxKindVoidExpression,
		SyntaxKindDeleteExpression,
		SyntaxKindTypeOfExpression,
		SyntaxKindPrefixUnaryExpression,
		SyntaxKindPostfixUnaryExpression,
		SyntaxKindBinaryExpression,
		SyntaxKindConditionalExpression,
		SyntaxKindSpreadElement,
		SyntaxKindTemplateExpression,
		SyntaxKindOmittedExpression,
		SyntaxKindJsxElement,
		SyntaxKindJsxSelfClosingElement,
		SyntaxKindJsxFragment,
		SyntaxKindYieldExpression,
		SyntaxKindAwaitExpression,
		SyntaxKindMetaProperty:
		return true
	case SyntaxKindExpressionWithTypeArguments:
		return !isHeritageClause(node.parent) && !isJSDocAugmentsTag(node.parent)
	case SyntaxKindQualifiedName:
		for node.parent.kind == SyntaxKindQualifiedName {
			node = node.parent
		}
		return node.parent.kind == SyntaxKindTypeQuery || isJSDocLinkLike(node.parent) || isJSDocNameReference(node.parent) || isJSDocMemberName(node.parent) || isJSXTagName(node)
	case SyntaxKindJSDocMemberName:
		for isJSDocMemberName(node.parent) {
			node = node.parent
		}
		return node.parent.kind == SyntaxKindTypeQuery || isJSDocLinkLike(node.parent) || isJSDocNameReference(node.parent) || isJSDocMemberName(node.parent) || isJSXTagName(node)
	case SyntaxKindPrivateIdentifier:
		return isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindInKeyword
	case SyntaxKindIdentifier:
		if node.parent.kind == SyntaxKindTypeQuery || isJSDocLinkLike(node.parent) || isJSDocNameReference(node.parent) || isJSDocMemberName(node.parent) || isJSXTagName(node) {
			return true
		}
		fallthrough
	case SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindThisKeyword:
		return isInExpressionContext(node)
	default:
		return false
	}
}

/** @internal */

func isInExpressionContext(node Node) bool {
	TODO_IDENTIFIER := node
	switch parent.kind {
	case SyntaxKindVariableDeclaration,
		SyntaxKindParameter,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature,
		SyntaxKindEnumMember,
		SyntaxKindPropertyAssignment,
		SyntaxKindBindingElement:
		return (parent /* as HasInitializer */).initializer == node
	case SyntaxKindExpressionStatement,
		SyntaxKindIfStatement,
		SyntaxKindDoStatement,
		SyntaxKindWhileStatement,
		SyntaxKindReturnStatement,
		SyntaxKindWithStatement,
		SyntaxKindSwitchStatement,
		SyntaxKindCaseClause,
		SyntaxKindThrowStatement:
		return (parent /* as ExpressionStatement */).expression == node
	case SyntaxKindForStatement:
		forStatement := parent /* as ForStatement */
		return (forStatement.initializer == node && forStatement.initializer.kind != SyntaxKindVariableDeclarationList) || forStatement.condition == node || forStatement.incrementor == node
	case SyntaxKindForInStatement,
		SyntaxKindForOfStatement:
		forInOrOfStatement := parent /* as ForInOrOfStatement */
		return (forInOrOfStatement.initializer == node && forInOrOfStatement.initializer.kind != SyntaxKindVariableDeclarationList) || forInOrOfStatement.expression == node
	case SyntaxKindTypeAssertionExpression,
		SyntaxKindAsExpression:
		return node == (parent /* as AssertionExpression */).expression
	case SyntaxKindTemplateSpan:
		return node == (parent /* as TemplateSpan */).expression
	case SyntaxKindComputedPropertyName:
		return node == (parent /* as ComputedPropertyName */).expression
	case SyntaxKindDecorator,
		SyntaxKindJsxExpression,
		SyntaxKindJsxSpreadAttribute,
		SyntaxKindSpreadAssignment:
		return true
	case SyntaxKindExpressionWithTypeArguments:
		return (parent /* as ExpressionWithTypeArguments */).expression == node && !isPartOfTypeNode(parent)
	case SyntaxKindShorthandPropertyAssignment:
		return (parent /* as ShorthandPropertyAssignment */).objectAssignmentInitializer == node
	case SyntaxKindSatisfiesExpression:
		return node == (parent /* as SatisfiesExpression */).expression
	default:
		return isExpressionNode(parent)
	}
}

/** @internal */

func isPartOfTypeQuery(node Node) bool {
	for node.kind == SyntaxKindQualifiedName || node.kind == SyntaxKindIdentifier {
		node = node.parent
	}
	return node.kind == SyntaxKindTypeQuery
}

/** @internal */

func isNamespaceReexportDeclaration(node Node) bool {
	return isNamespaceExport(node) && !!node.parent.moduleSpecifier
}

/** @internal */

func isExternalModuleImportEqualsDeclaration(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ImportEqualsDeclaration & { moduleReference: ExternalModuleReference; } */ any {
	return node.kind == SyntaxKindImportEqualsDeclaration && (node /* as ImportEqualsDeclaration */).moduleReference.kind == SyntaxKindExternalModuleReference
}

/** @internal */

func getExternalModuleImportEqualsDeclarationExpression(node Node) Expression {
	Debug.assert(isExternalModuleImportEqualsDeclaration(node))
	return ((node /* as ImportEqualsDeclaration */).moduleReference /* as ExternalModuleReference */).expression
}

/** @internal */

func getExternalModuleRequireArgument(node Node) /* TODO(TS-TO-GO) TypeNode UnionType: false | StringLiteral */ any {
	return isVariableDeclarationInitializedToBareOrAccessedRequire(node) && (getLeftmostAccessExpression(node.initializer) /* as CallExpression */).arguments[0] /* as StringLiteral */
}

/** @internal */

func isInternalModuleImportEqualsDeclaration(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ImportEqualsDeclaration */ any {
	return node.kind == SyntaxKindImportEqualsDeclaration && (node /* as ImportEqualsDeclaration */).moduleReference.kind != SyntaxKindExternalModuleReference
}

/** @internal */

func isFullSourceFile(sourceFile any) /* TODO(TS-TO-GO) TypeNode TypePredicate: sourceFile is SourceFile */ any {
	return (sourceFile /* as Partial<SourceFile> */). /* ? */ kind == SyntaxKindSourceFile
}

/** @internal */

func isSourceFileJS(file SourceFile) bool {
	return isInJSFile(file)
}

/** @internal */

func isInJSFile(node Node) bool {
	return !!node && !!(node.flags & NodeFlagsJavaScriptFile)
}

/** @internal */

func isInJsonFile(node Node) bool {
	return !!node && !!(node.flags & NodeFlagsJsonFile)
}

/** @internal */

func isSourceFileNotJson(file SourceFile) bool {
	return !isJsonSourceFile(file)
}

/** @internal */

func isInJSDoc(node Node) bool {
	return !!node && !!(node.flags & NodeFlagsJSDoc)
}

/** @internal */

func isJSDocIndexSignature(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments */ any) *bool {
	return isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText == "Object" && node.typeArguments && node.typeArguments.length == 2 && (node.typeArguments[0].kind == SyntaxKindStringKeyword || node.typeArguments[0].kind == SyntaxKindNumberKeyword)
}

/**
 * Returns true if the node is a CallExpression to the identifier 'require' with
 * exactly one argument (of the form 'require("name")').
 * This function does not test if the node is in a JavaScript file or not.
 *
 * @internal
 */

/* OVERLOAD: export function isRequireCall(callExpression: Node, requireStringLiteralLikeArgument: true): callExpression is RequireOrImportCall & { expression: Identifier; arguments: [StringLiteralLike]; }; */
/** @internal */

/* OVERLOAD: export function isRequireCall(callExpression: Node, requireStringLiteralLikeArgument: boolean): callExpression is CallExpression; */
/** @internal */

func isRequireCall(callExpression Node, requireStringLiteralLikeArgument bool) /* TODO(TS-TO-GO) TypeNode TypePredicate: callExpression is CallExpression */ any {
	if callExpression.kind != SyntaxKindCallExpression {
		return false
	}
	TODO_IDENTIFIER := callExpression /* as CallExpression */

	if expression.kind != SyntaxKindIdentifier || (expression /* as Identifier */).escapedText != "require" {
		return false
	}

	if args.length != 1 {
		return false
	}
	arg := args[0]
	return !requireStringLiteralLikeArgument || isStringLiteralLike(arg)
}

/**
 * Returns true if the node is a VariableDeclaration initialized to a require call (see `isRequireCall`).
 * This function does not test if the node is in a JavaScript file or not.
 *
 * @internal
 */

func isVariableDeclarationInitializedToRequire(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is VariableDeclarationInitializedTo<RequireOrImportCall> */ any {
	return isVariableDeclarationInitializedWithRequireHelper(node /*allowAccessedRequire*/, false)
}

/**
 * Like {@link isVariableDeclarationInitializedToRequire} but allows things like `require("...").foo.bar` or `require("...")["baz"]`.
 *
 * @internal
 */

func isVariableDeclarationInitializedToBareOrAccessedRequire(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is VariableDeclarationInitializedTo<RequireOrImportCall | AccessExpression> */ any {
	return isVariableDeclarationInitializedWithRequireHelper(node /*allowAccessedRequire*/, true)
}

/** @internal */

func isBindingElementOfBareOrAccessedRequire(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is BindingElementOfBareOrAccessedRequire */ any {
	return isBindingElement(node) && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent)
}

func isVariableDeclarationInitializedWithRequireHelper(node Node, allowAccessedRequire bool) bool {
	return isVariableDeclaration(node) && !!node.initializer && isRequireCall(__COND__(allowAccessedRequire, getLeftmostAccessExpression(node.initializer), node.initializer) /*requireStringLiteralLikeArgument*/, true)
}

/** @internal */

func isRequireVariableStatement(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is RequireVariableStatement */ any {
	return isVariableStatement(node) && node.declarationList.declarations.length > 0 && every(node.declarationList.declarations, func(decl VariableDeclaration) bool {
		return isVariableDeclarationInitializedToRequire(decl)
	})
}

/** @internal */

func isSingleOrDoubleQuote(charCode number) bool {
	return charCode == CharacterCodessingleQuote || charCode == CharacterCodesdoubleQuote
}

/** @internal */

func isStringDoubleQuoted(str StringLiteralLike, sourceFile SourceFile) bool {
	return getSourceTextOfNodeFromSourceFile(sourceFile, str).charCodeAt(0) == CharacterCodesdoubleQuote
}

/** @internal */

func isAssignmentDeclaration(decl Declaration) bool {
	return isBinaryExpression(decl) || isAccessExpression(decl) || isIdentifier(decl) || isCallExpression(decl)
}

/**
 * Get the initializer, taking into account defaulted Javascript initializers
 *
 * @internal
 */

func getEffectiveInitializer(node HasExpressionInitializer) Expression {
	if isInJSFile(node) && node.initializer && isBinaryExpression(node.initializer) && (node.initializer.operatorToken.kind == SyntaxKindBarBarToken || node.initializer.operatorToken.kind == SyntaxKindQuestionQuestionToken) && node.name && isEntityNameExpression(node.name) && isSameEntityName(node.name, node.initializer.left) {
		return node.initializer.right
	}
	return node.initializer
}

/**
 * Get the declaration initializer when it is container-like (See getExpandoInitializer).
 *
 * @internal
 */

func getDeclaredExpandoInitializer(node HasExpressionInitializer) Expression {
	init := getEffectiveInitializer(node)
	return init && getExpandoInitializer(init, isPrototypeAccess(node.name))
}

func hasExpandoValueProperty(node ObjectLiteralExpression, isPrototypeAssignment bool) * /* TODO(TS-TO-GO) inferred type false | Expression */ any {
	return forEach(node.properties, func(p /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) * /* TODO(TS-TO-GO) inferred type false | Expression */ any {
		return isPropertyAssignment(p) && isIdentifier(p.name) && p.name.escapedText == "value" && p.initializer && getExpandoInitializer(p.initializer, isPrototypeAssignment)
	})
}

/**
 * Get the assignment 'initializer' -- the righthand side-- when the initializer is container-like (See getExpandoInitializer).
 * We treat the right hand side of assignments with container-like initializers as declarations.
 *
 * @internal
 */

func getAssignedExpandoInitializer(node Node) Expression {
	if node && node.parent && isBinaryExpression(node.parent) && node.parent.operatorToken.kind == SyntaxKindEqualsToken {
		isPrototypeAssignment := isPrototypeAccess(node.parent.left)
		return getExpandoInitializer(node.parent.right, isPrototypeAssignment) || getDefaultedExpandoInitializer(node.parent.left, node.parent.right, isPrototypeAssignment)
	}
	if node && isCallExpression(node) && isBindableObjectDefinePropertyCall(node) {
		result := hasExpandoValueProperty(node.arguments[2], node.arguments[1].text == "prototype")
		if result {
			return result
		}
	}
}

/**
 * Recognized expando initializers are:
 * 1. (function() {})() -- IIFEs
 * 2. function() { } -- Function expressions
 * 3. class { } -- Class expressions
 * 4. {} -- Empty object literals
 * 5. { ... } -- Non-empty object literals, when used to initialize a prototype, like `C.prototype = { m() { } }`
 *
 * This function returns the provided initializer, or undefined if it is not valid.
 *
 * @internal
 */

func getExpandoInitializer(initializer Node, isPrototypeAssignment bool) Expression {
	if isCallExpression(initializer) {
		e := skipParentheses(initializer.expression)
		if e.kind == SyntaxKindFunctionExpression || e.kind == SyntaxKindArrowFunction {
			return initializer
		} else {
			return nil
		}
	}
	if initializer.kind == SyntaxKindFunctionExpression || initializer.kind == SyntaxKindClassExpression || initializer.kind == SyntaxKindArrowFunction {
		return initializer /* as Expression */
	}
	if isObjectLiteralExpression(initializer) && (initializer.properties.length == 0 || isPrototypeAssignment) {
		return initializer
	}
}

/**
 * A defaulted expando initializer matches the pattern
 * `Lhs = Lhs || ExpandoInitializer`
 * or `var Lhs = Lhs || ExpandoInitializer`
 *
 * The second Lhs is required to be the same as the first except that it may be prefixed with
 * 'window.', 'global.' or 'self.' The second Lhs is otherwise ignored by the binder and checker.
 */

func getDefaultedExpandoInitializer(name Expression, initializer Expression, isPrototypeAssignment bool) Expression {
	e := isBinaryExpression(initializer) && (initializer.operatorToken.kind == SyntaxKindBarBarToken || initializer.operatorToken.kind == SyntaxKindQuestionQuestionToken) && getExpandoInitializer(initializer.right, isPrototypeAssignment)
	if e && isSameEntityName(name, initializer.left) {
		return e
	}
}

/** @internal */

func isDefaultedExpandoInitializer(node BinaryExpression) *bool {
	var name * /* TODO(TS-TO-GO) inferred type Expression | ObjectBindingPattern | ArrayBindingPattern */ any
	switch {
	case isVariableDeclaration(node.parent):
		name = node.parent.name
	case isBinaryExpression(node.parent) && node.parent.operatorToken.kind == SyntaxKindEqualsToken:
		name = node.parent.left
	default:
		name = nil
	}
	return name && getExpandoInitializer(node.right, isPrototypeAccess(name)) && isEntityNameExpression(name) && isSameEntityName(name, node.left)
}

/**
 * Given an expando initializer, return its declaration name, or the left-hand side of the assignment if it's part of an assignment declaration.
 *
 * @internal
 */

func getNameOfExpando(node Declaration) *DeclarationName {
	if isBinaryExpression(node.parent) {
		var parent BinaryExpression
		if (node.parent.operatorToken.kind == SyntaxKindBarBarToken || node.parent.operatorToken.kind == SyntaxKindQuestionQuestionToken) && isBinaryExpression(node.parent.parent) {
			parent = node.parent.parent
		} else {
			parent = node.parent
		}
		if parent.operatorToken.kind == SyntaxKindEqualsToken && isIdentifier(parent.left) {
			return parent.left
		}
	} else if isVariableDeclaration(node.parent) {
		return node.parent.name
	}
}

/**
 * Is the 'declared' name the same as the one in the initializer?
 * @return true for identical entity names, as well as ones where the initializer is prefixed with
 * 'window', 'self' or 'global'. For example:
 *
 * var my = my || {}
 * var min = window.min || {}
 * my.app = self.my.app || class { }
 *
 * @internal
 */

func isSameEntityName(name Expression, initializer Expression) bool {
	if isPropertyNameLiteral(name) && isPropertyNameLiteral(initializer) {
		return getTextOfIdentifierOrLiteral(name) == getTextOfIdentifierOrLiteral(initializer)
	}
	if isMemberName(name) && isLiteralLikeAccess(initializer) && (initializer.expression.kind == SyntaxKindThisKeyword || isIdentifier(initializer.expression) && (initializer.expression.escapedText == "window" || initializer.expression.escapedText == "self" || initializer.expression.escapedText == "global")) {
		return isSameEntityName(name, getNameOrArgument(initializer))
	}
	if isLiteralLikeAccess(name) && isLiteralLikeAccess(initializer) {
		return getElementOrPropertyAccessName(name) == getElementOrPropertyAccessName(initializer) && isSameEntityName(name.expression, initializer.expression)
	}
	return false
}

/** @internal */

func getRightMostAssignedExpression(node Expression) Expression {
	for isAssignmentExpression(node /*excludeCompoundAssignment*/, true) {
		node = node.right
	}
	return node
}

/** @internal */

func isExportsIdentifier(node Node) bool {
	return isIdentifier(node) && node.escapedText == "exports"
}

/** @internal */

func isModuleIdentifier(node Node) bool {
	return isIdentifier(node) && node.escapedText == "module"
}

/** @internal */

func isModuleExportsAccessExpression(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LiteralLikeElementAccessExpression & { expression: Identifier; } */ any {
	return (isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node)) && isModuleIdentifier(node.expression) && getElementOrPropertyAccessName(node) == "exports"
}

/// Given a BinaryExpression, returns SpecialPropertyAssignmentKind for the various kinds of property
/// assignments we treat as special in the binder

func getAssignmentDeclarationKind(expr /* TODO(TS-TO-GO) TypeNode UnionType: BinaryExpression | CallExpression */ any) AssignmentDeclarationKind {
	special := getAssignmentDeclarationKindWorker(expr)
	if special == AssignmentDeclarationKindProperty || isInJSFile(expr) {
		return special
	} else {
		return AssignmentDeclarationKindNone
	}
}

/** @internal */

func isBindableObjectDefinePropertyCall(expr CallExpression) /* TODO(TS-TO-GO) TypeNode TypePredicate: expr is BindableObjectDefinePropertyCall */ any {
	return length(expr.arguments) == 3 && isPropertyAccessExpression(expr.expression) && isIdentifier(expr.expression.expression) && idText(expr.expression.expression) == "Object" && idText(expr.expression.name) == "defineProperty" && isStringOrNumericLiteralLike(expr.arguments[1]) && isBindableStaticNameExpression(expr.arguments[0] /*excludeThisKeyword*/, true)
}

/**
 * x.y OR x[0]
 */

func isLiteralLikeAccess(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LiteralLikeElementAccessExpression | PropertyAccessExpression */ any {
	return isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node)
}

/**
 * x[0] OR x['a'] OR x[Symbol.y]
 */

func isLiteralLikeElementAccess(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LiteralLikeElementAccessExpression */ any {
	return isElementAccessExpression(node) && isStringOrNumericLiteralLike(node.argumentExpression)
}

/**
 * Any series of property and element accesses.
 *
 * @internal
 */

func isBindableStaticAccessExpression(node Node, excludeThisKeyword bool) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is BindableStaticAccessExpression */ any {
	return isPropertyAccessExpression(node) && (!excludeThisKeyword && node.expression.kind == SyntaxKindThisKeyword || isIdentifier(node.name) && isBindableStaticNameExpression(node.expression /*excludeThisKeyword*/, true)) || isBindableStaticElementAccessExpression(node, excludeThisKeyword)
}

/**
 * Any series of property and element accesses, ending in a literal element access
 *
 * @internal
 */

func isBindableStaticElementAccessExpression(node Node, excludeThisKeyword bool) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is BindableStaticElementAccessExpression */ any {
	return isLiteralLikeElementAccess(node) && ((!excludeThisKeyword && node.expression.kind == SyntaxKindThisKeyword) || isEntityNameExpression(node.expression) || isBindableStaticAccessExpression(node.expression /*excludeThisKeyword*/, true))
}

/** @internal */

func isBindableStaticNameExpression(node Node, excludeThisKeyword bool) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is BindableStaticNameExpression */ any {
	return isEntityNameExpression(node) || isBindableStaticAccessExpression(node, excludeThisKeyword)
}

/** @internal */

func getNameOrArgument(expr /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | LiteralLikeElementAccessExpression */ any) /* TODO(TS-TO-GO) TypeNode UnionType: MemberName | (Expression & (NumericLiteral | StringLiteralLike)) */ any {
	if isPropertyAccessExpression(expr) {
		return expr.name
	}
	return expr.argumentExpression
}

func getAssignmentDeclarationKindWorker(expr /* TODO(TS-TO-GO) TypeNode UnionType: BinaryExpression | CallExpression */ any) AssignmentDeclarationKind {
	if isCallExpression(expr) {
		if !isBindableObjectDefinePropertyCall(expr) {
			return AssignmentDeclarationKindNone
		}
		entityName := expr.arguments[0]
		if isExportsIdentifier(entityName) || isModuleExportsAccessExpression(entityName) {
			return AssignmentDeclarationKindObjectDefinePropertyExports
		}
		if isBindableStaticAccessExpression(entityName) && getElementOrPropertyAccessName(entityName) == "prototype" {
			return AssignmentDeclarationKindObjectDefinePrototypeProperty
		}
		return AssignmentDeclarationKindObjectDefinePropertyValue
	}
	if expr.operatorToken.kind != SyntaxKindEqualsToken || !isAccessExpression(expr.left) || isVoidZero(getRightMostAssignedExpression(expr)) {
		return AssignmentDeclarationKindNone
	}
	if isBindableStaticNameExpression(expr.left.expression /*excludeThisKeyword*/, true) && getElementOrPropertyAccessName(expr.left) == "prototype" && isObjectLiteralExpression(getInitializerOfBinaryExpression(expr)) {
		// F.prototype = { ... }
		return AssignmentDeclarationKindPrototype
	}
	return getAssignmentDeclarationPropertyAccessKind(expr.left)
}

func isVoidZero(node Node) bool {
	return isVoidExpression(node) && isNumericLiteral(node.expression) && node.expression.text == "0"
}

/**
 * Does not handle signed numeric names like `a[+0]` - handling those would require handling prefix unary expressions
 * throughout late binding handling as well, which is awkward (but ultimately probably doable if there is demand)
 *
 * @internal
 */

func getElementOrPropertyAccessArgumentExpressionOrName(node AccessExpression) /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | StringLiteralLike | NumericLiteral | ElementAccessExpression | undefined */ any {
	if isPropertyAccessExpression(node) {
		return node.name
	}
	arg := skipParentheses(node.argumentExpression)
	if isNumericLiteral(arg) || isStringLiteralLike(arg) {
		return arg
	}
	return node
}

/** @internal */

/* OVERLOAD: export function getElementOrPropertyAccessName(node: LiteralLikeElementAccessExpression | PropertyAccessExpression): __String; */
/** @internal */

/* OVERLOAD: export function getElementOrPropertyAccessName(node: AccessExpression): __String | undefined; */
/** @internal */

func getElementOrPropertyAccessName(node AccessExpression) *__String {
	name := getElementOrPropertyAccessArgumentExpressionOrName(node)
	if name {
		if isIdentifier(name) {
			return name.escapedText
		}
		if isStringLiteralLike(name) || isNumericLiteral(name) {
			return escapeLeadingUnderscores(name.text)
		}
	}
	return nil
}

/** @internal */

func getAssignmentDeclarationPropertyAccessKind(lhs AccessExpression) AssignmentDeclarationKind {
	if lhs.expression.kind == SyntaxKindThisKeyword {
		return AssignmentDeclarationKindThisProperty
	} else if isModuleExportsAccessExpression(lhs) {
		// module.exports = expr
		return AssignmentDeclarationKindModuleExports
	} else if isBindableStaticNameExpression(lhs.expression /*excludeThisKeyword*/, true) {
		if isPrototypeAccess(lhs.expression) {
			// F.G....prototype.x = expr
			return AssignmentDeclarationKindPrototypeProperty
		}

		nextToLast := lhs
		for !isIdentifier(nextToLast.expression) {
			nextToLast = nextToLast.expression /* as Exclude<BindableStaticNameExpression, Identifier> */
		}
		id := nextToLast.expression
		if (id.escapedText == "exports" || id.escapedText == "module" && getElementOrPropertyAccessName(nextToLast) == "exports") && isBindableStaticAccessExpression(lhs) {
			// exports.name = expr OR module.exports.name = expr OR exports["name"] = expr ...
			return AssignmentDeclarationKindExportsProperty
		}
		if isBindableStaticNameExpression(lhs /*excludeThisKeyword*/, true) || (isElementAccessExpression(lhs) && isDynamicName(lhs)) {
			// F.G...x = expr
			return AssignmentDeclarationKindProperty
		}
	}

	return AssignmentDeclarationKindNone
}

/** @internal */

func getInitializerOfBinaryExpression(expr BinaryExpression) Expression {
	for isBinaryExpression(expr.right) {
		expr = expr.right
	}
	return expr.right
}

/** @internal */

type PrototypePropertyAssignment struct {
	_prototypePropertyAssignmentBrand any
	left                              AccessExpression
}

/** @internal */

func isPrototypePropertyAssignment(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is PrototypePropertyAssignment */ any {
	return isBinaryExpression(node) && getAssignmentDeclarationKind(node) == AssignmentDeclarationKindPrototypeProperty
}

/** @internal */

func isSpecialPropertyDeclaration(expr /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | ElementAccessExpression */ any) /* TODO(TS-TO-GO) TypeNode TypePredicate: expr is PropertyAccessExpression | LiteralLikeElementAccessExpression */ any {
	return isInJSFile(expr) && expr.parent && expr.parent.kind == SyntaxKindExpressionStatement && (!isElementAccessExpression(expr) || isLiteralLikeElementAccess(expr)) && !!getJSDocTypeTag(expr.parent)
}

/** @internal */

func setValueDeclaration(symbol Symbol, node Declaration) {
	TODO_IDENTIFIER := symbol
	if !valueDeclaration || !(node.flags&NodeFlagsAmbient && !isInJSFile(node) && !(valueDeclaration.flags&NodeFlagsAmbient)) && (isAssignmentDeclaration(valueDeclaration) && !isAssignmentDeclaration(node)) || (valueDeclaration.kind != node.kind && isEffectiveModuleDeclaration(valueDeclaration)) {
		// other kinds of value declarations take precedence over modules and assignment declarations
		symbol.valueDeclaration = node
	}
}

/** @internal */

func isFunctionSymbol(symbol Symbol) *bool {
	if !symbol || !symbol.valueDeclaration {
		return false
	}
	decl := symbol.valueDeclaration
	return decl.kind == SyntaxKindFunctionDeclaration || isVariableDeclaration(decl) && decl.initializer && isFunctionLike(decl.initializer)
}

/** @internal */

func canHaveModuleSpecifier(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is CanHaveModuleSpecifier */ any {
	switch node. /* ? */ kind {
	case SyntaxKindVariableDeclaration,
		SyntaxKindBindingElement,
		SyntaxKindImportDeclaration,
		SyntaxKindExportDeclaration,
		SyntaxKindImportEqualsDeclaration,
		SyntaxKindImportClause,
		SyntaxKindNamespaceExport,
		SyntaxKindNamespaceImport,
		SyntaxKindExportSpecifier,
		SyntaxKindImportSpecifier,
		SyntaxKindImportType:
		return true
	}
	return false
}

/** @internal */

func tryGetModuleSpecifierFromDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: CanHaveModuleSpecifier | JSDocImportTag */ any) *StringLiteralLike {
	switch node.kind {
	case SyntaxKindVariableDeclaration,
		SyntaxKindBindingElement:
		return findAncestor(node.initializer, func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is RequireOrImportCall */ any {
			return isRequireCall(node /*requireStringLiteralLikeArgument*/, true)
		}). /* ? */ arguments[0]
	case SyntaxKindImportDeclaration,
		SyntaxKindExportDeclaration,
		SyntaxKindJSDocImportTag:
		return tryCast(node.moduleSpecifier, isStringLiteralLike)
	case SyntaxKindImportEqualsDeclaration:
		return tryCast(tryCast(node.moduleReference, isExternalModuleReference). /* ? */ expression, isStringLiteralLike)
	case SyntaxKindImportClause,
		SyntaxKindNamespaceExport:
		return tryCast(node.parent.moduleSpecifier, isStringLiteralLike)
	case SyntaxKindNamespaceImport,
		SyntaxKindExportSpecifier:
		return tryCast(node.parent.parent.moduleSpecifier, isStringLiteralLike)
	case SyntaxKindImportSpecifier:
		return tryCast(node.parent.parent.parent.moduleSpecifier, isStringLiteralLike)
	case SyntaxKindImportType:
		if isLiteralImportTypeNode(node) {
			return node.argument.literal
		} else {
			return nil
		}
	default:
		Debug.assertNever(node)
	}
}

/** @internal */

func importFromModuleSpecifier(node StringLiteralLike) AnyValidImportOrReExport {
	return tryGetImportFromModuleSpecifier(node) || Debug.failBadSyntaxKind(node.parent)
}

/** @internal */

func tryGetImportFromModuleSpecifier(node StringLiteralLike) *AnyValidImportOrReExport {
	switch node.parent.kind {
	case SyntaxKindImportDeclaration,
		SyntaxKindExportDeclaration,
		SyntaxKindJSDocImportTag:
		return node.parent /* as AnyValidImportOrReExport */
	case SyntaxKindExternalModuleReference:
		return (node.parent /* as ExternalModuleReference */).parent /* as AnyValidImportOrReExport */
	case SyntaxKindCallExpression:
		if isImportCall(node.parent) || isRequireCall(node.parent /*requireStringLiteralLikeArgument*/, false) {
			return node.parent /* as RequireOrImportCall */
		} else {
			return nil
		}
	case SyntaxKindLiteralType:
		Debug.assert(isStringLiteral(node))
		return tryCast(node.parent.parent, isImportTypeNode) /* as ValidImportTypeNode | undefined */
	default:
		return nil
	}
}

/** @internal */

func getExternalModuleName(node /* TODO(TS-TO-GO) TypeNode UnionType: AnyImportOrReExport | ImportTypeNode | ImportCall | ModuleDeclaration | JSDocImportTag */ any) Expression {
	switch node.kind {
	case SyntaxKindImportDeclaration,
		SyntaxKindExportDeclaration,
		SyntaxKindJSDocImportTag:
		return node.moduleSpecifier
	case SyntaxKindImportEqualsDeclaration:
		if node.moduleReference.kind == SyntaxKindExternalModuleReference {
			return node.moduleReference.expression
		} else {
			return nil
		}
	case SyntaxKindImportType:
		if isLiteralImportTypeNode(node) {
			return node.argument.literal
		} else {
			return nil
		}
	case SyntaxKindCallExpression:
		return node.arguments[0]
	case SyntaxKindModuleDeclaration:
		if node.name.kind == SyntaxKindStringLiteral {
			return node.name
		} else {
			return nil
		}
	default:
		return Debug.assertNever(node)
	}
}

/** @internal */

func getNamespaceDeclarationNode(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | NamespaceImport | NamespaceExport | undefined */ any {
	switch node.kind {
	case SyntaxKindImportDeclaration:
		return node.importClause && tryCast(node.importClause.namedBindings, isNamespaceImport)
	case SyntaxKindImportEqualsDeclaration:
		return node
	case SyntaxKindExportDeclaration:
		return node.exportClause && tryCast(node.exportClause, isNamespaceExport)
	default:
		return Debug.assertNever(node)
	}
}

/** @internal */

func isDefaultImport(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration | JSDocImportTag */ any) bool {
	return (node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindJSDocImportTag) && !!node.importClause && !!node.importClause.name
}

/** @internal */

func forEachImportClauseDeclaration(node ImportClause, action func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: ImportClause | NamespaceImport | ImportSpecifier */ any) *T) *T {
	if node.name {
		result := action(node)
		if result {
			return result
		}
	}
	if node.namedBindings {
		var result *T
		if isNamespaceImport(node.namedBindings) {
			result = action(node.namedBindings)
		} else {
			result = forEach(node.namedBindings.elements, action)
		}
		if result {
			return result
		}
	}
}

/** @internal */

func hasQuestionToken(node Node) bool {
	switch node.kind {
	case SyntaxKindParameter,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindShorthandPropertyAssignment,
		SyntaxKindPropertyAssignment,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature:
		return (node /* as ParameterDeclaration | MethodDeclaration | PropertyDeclaration */).questionToken != nil
	}
	return false
}

/** @internal */

func isJSDocConstructSignature(node Node) bool {
	var param *ParameterDeclaration
	if isJSDocFunctionType(node) {
		param = firstOrUndefined(node.parameters)
	} else {
		param = nil
	}
	name := tryCast(param && param.name, isIdentifier)
	return !!name && name.escapedText == "new"
}

/** @internal */

func isJSDocTypeAlias(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag */ any {
	return node.kind == SyntaxKindJSDocTypedefTag || node.kind == SyntaxKindJSDocCallbackTag || node.kind == SyntaxKindJSDocEnumTag
}

/** @internal */

func isTypeAlias(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | TypeAliasDeclaration */ any {
	return isJSDocTypeAlias(node) || isTypeAliasDeclaration(node)
}

func getSourceOfAssignment(node Node) Node {
	if isExpressionStatement(node) && isBinaryExpression(node.expression) && node.expression.operatorToken.kind == SyntaxKindEqualsToken {
		return getRightMostAssignedExpression(node.expression)
	} else {
		return nil
	}
}

func getSourceOfDefaultedAssignment(node Node) Node {
	if isExpressionStatement(node) && isBinaryExpression(node.expression) && getAssignmentDeclarationKind(node.expression) != AssignmentDeclarationKindNone && isBinaryExpression(node.expression.right) && (node.expression.right.operatorToken.kind == SyntaxKindBarBarToken || node.expression.right.operatorToken.kind == SyntaxKindQuestionQuestionToken) {
		return node.expression.right.right
	} else {
		return nil
	}
}

func getSingleInitializerOfVariableStatementOrPropertyDeclaration(node Node) Expression {
	switch node.kind {
	case SyntaxKindVariableStatement:
		v := getSingleVariableOfVariableStatement(node)
		return v && v.initializer
	case SyntaxKindPropertyDeclaration:
		return (node /* as PropertyDeclaration */).initializer
	case SyntaxKindPropertyAssignment:
		return (node /* as PropertyAssignment */).initializer
	}
}

/** @internal */

func getSingleVariableOfVariableStatement(node Node) *VariableDeclaration {
	if isVariableStatement(node) {
		return firstOrUndefined(node.declarationList.declarations)
	} else {
		return nil
	}
}

func getNestedModuleDeclaration(node Node) Node {
	if isModuleDeclaration(node) && node.body && node.body.kind == SyntaxKindModuleDeclaration {
		return node.body
	} else {
		return nil
	}
}

/** @internal */

func canHaveFlowNode(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is HasFlowNode */ any {
	if node.kind >= SyntaxKindFirstStatement && node.kind <= SyntaxKindLastStatement {
		return true
	}

	switch node.kind {
	case SyntaxKindIdentifier,
		SyntaxKindThisKeyword,
		SyntaxKindSuperKeyword,
		SyntaxKindQualifiedName,
		SyntaxKindMetaProperty,
		SyntaxKindElementAccessExpression,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindBindingElement,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor:
		return true
	default:
		return false
	}
}

/** @internal */

func canHaveJSDoc(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is HasJSDoc */ any {
	switch node.kind {
	case SyntaxKindArrowFunction,
		SyntaxKindBinaryExpression,
		SyntaxKindBlock,
		SyntaxKindBreakStatement,
		SyntaxKindCallSignature,
		SyntaxKindCaseClause,
		SyntaxKindClassDeclaration,
		SyntaxKindClassExpression,
		SyntaxKindClassStaticBlockDeclaration,
		SyntaxKindConstructor,
		SyntaxKindConstructorType,
		SyntaxKindConstructSignature,
		SyntaxKindContinueStatement,
		SyntaxKindDebuggerStatement,
		SyntaxKindDoStatement,
		SyntaxKindElementAccessExpression,
		SyntaxKindEmptyStatement,
		SyntaxKindEndOfFileToken,
		SyntaxKindEnumDeclaration,
		SyntaxKindEnumMember,
		SyntaxKindExportAssignment,
		SyntaxKindExportDeclaration,
		SyntaxKindExportSpecifier,
		SyntaxKindExpressionStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement,
		SyntaxKindForStatement,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindFunctionType,
		SyntaxKindGetAccessor,
		SyntaxKindIdentifier,
		SyntaxKindIfStatement,
		SyntaxKindImportDeclaration,
		SyntaxKindImportEqualsDeclaration,
		SyntaxKindIndexSignature,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindJSDocFunctionType,
		SyntaxKindJSDocSignature,
		SyntaxKindLabeledStatement,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindModuleDeclaration,
		SyntaxKindNamedTupleMember,
		SyntaxKindNamespaceExportDeclaration,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindParameter,
		SyntaxKindParenthesizedExpression,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindPropertyAssignment,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature,
		SyntaxKindReturnStatement,
		SyntaxKindSemicolonClassElement,
		SyntaxKindSetAccessor,
		SyntaxKindShorthandPropertyAssignment,
		SyntaxKindSpreadAssignment,
		SyntaxKindSwitchStatement,
		SyntaxKindThrowStatement,
		SyntaxKindTryStatement,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindTypeParameter,
		SyntaxKindVariableDeclaration,
		SyntaxKindVariableStatement,
		SyntaxKindWhileStatement,
		SyntaxKindWithStatement:
		return true
	default:
		return false
	}
}

/**
 * This function checks multiple locations for JSDoc comments that apply to a host node.
 * At each location, the whole comment may apply to the node, or only a specific tag in
 * the comment. In the first case, location adds the entire {@link JSDoc} object. In the
 * second case, it adds the applicable {@link JSDocTag}.
 *
 * For example, a JSDoc comment before a parameter adds the entire {@link JSDoc}. But a
 * `@param` tag on the parent function only adds the {@link JSDocTag} for the `@param`.
 *
 * ```ts
 * /** JSDoc will be returned for `a` *\/
 * const a = 0
 * /**
 *  * Entire JSDoc will be returned for `b`
 *  * @param c JSDocTag will be returned for `c`
 *  *\/
 * function b(/** JSDoc will be returned for `c` *\/ c) {}
 * ```
 */

/* OVERLOAD: export function getJSDocCommentsAndTags(hostNode: Node): readonly (JSDoc | JSDocTag)[]; */
/** @internal separate signature so that stripInternal can remove noCache from the public API */
// eslint-disable-next-line @typescript-eslint/unified-signatures

/* OVERLOAD: export function getJSDocCommentsAndTags(hostNode: Node, noCache?: boolean): readonly (JSDoc | JSDocTag)[]; */
func getJSDocCommentsAndTags(hostNode Node, noCache bool) [] /* TODO(TS-TO-GO) TypeNode UnionType: JSDoc | JSDocTag */ any {
	var result *[] /* TODO(TS-TO-GO) TypeNode UnionType: JSDoc | JSDocTag */ any
	// Pull parameter comments from declaring function as well
	if isVariableLike(hostNode) && hasInitializer(hostNode) && hasJSDocNodes(hostNode.initializer) {
		result = addRange(result, filterOwnedJSDocTags(hostNode, hostNode.initializer.jsDoc))
	}

	var node Node = hostNode
	for node && node.parent {
		if hasJSDocNodes(node) {
			result = addRange(result, filterOwnedJSDocTags(hostNode, node.jsDoc))
		}

		if node.kind == SyntaxKindParameter {
			result = addRange(result, (__COND__(noCache, getJSDocParameterTagsNoCache, getJSDocParameterTags))(node /* as ParameterDeclaration */))
			break
		}
		if node.kind == SyntaxKindTypeParameter {
			result = addRange(result, (__COND__(noCache, getJSDocTypeParameterTagsNoCache, getJSDocTypeParameterTags))(node /* as TypeParameterDeclaration */))
			break
		}
		node = getNextJSDocCommentLocation(node)
	}
	return result || emptyArray
}

func filterOwnedJSDocTags(hostNode Node, comments JSDocArray) [] /* TODO(TS-TO-GO) inferred type (JSDocTag | JSDoc) */ any {
	lastJsDoc := last(comments)
	return flatMap(comments, func(jsDoc JSDoc) *[] /* TODO(TS-TO-GO) inferred type JSDocTag[] | JSDoc */ any {
		if jsDoc == lastJsDoc {
			ownedTags := filter(jsDoc.tags, func(tag JSDocTag) bool {
				return ownsJSDocTag(hostNode, tag)
			})
			if jsDoc.tags == ownedTags {
				return []JSDoc{jsDoc}
			} else {
				return ownedTags
			}
		} else {
			return filter(jsDoc.tags, isJSDocOverloadTag)
		}
	})
}

/**
 * Determines whether a host node owns a jsDoc tag. A `@type`/`@satisfies` tag attached to a
 * a ParenthesizedExpression belongs only to the ParenthesizedExpression.
 */

func ownsJSDocTag(hostNode Node, tag JSDocTag) bool {
	return !(isJSDocTypeTag(tag) || isJSDocSatisfiesTag(tag)) || !tag.parent || !isJSDoc(tag.parent) || !isParenthesizedExpression(tag.parent.parent) || tag.parent.parent == hostNode
}

/** @internal */

func getNextJSDocCommentLocation(node Node) Node {
	parent := node.parent
	if parent.kind == SyntaxKindPropertyAssignment || parent.kind == SyntaxKindExportAssignment || parent.kind == SyntaxKindPropertyDeclaration || parent.kind == SyntaxKindExpressionStatement && node.kind == SyntaxKindPropertyAccessExpression || parent.kind == SyntaxKindReturnStatement || getNestedModuleDeclaration(parent) || isAssignmentExpression(node) {
		return parent
	} else if parent.parent && (getSingleVariableOfVariableStatement(parent.parent) == node || isAssignmentExpression(parent)) {
		return parent.parent
	} else if parent.parent && parent.parent.parent && (getSingleVariableOfVariableStatement(parent.parent.parent) || getSingleInitializerOfVariableStatementOrPropertyDeclaration(parent.parent.parent) == node || getSourceOfDefaultedAssignment(parent.parent.parent)) {
		return parent.parent.parent
	}
}

/**
 * Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it.
 *
 * @internal
 */

func getParameterSymbolFromJSDoc(node JSDocParameterTag) Symbol {
	if node.symbol {
		return node.symbol
	}
	if !isIdentifier(node.name) {
		return nil
	}
	name := node.name.escapedText
	decl := getHostSignatureFromJSDoc(node)
	if !decl {
		return nil
	}
	parameter := find(decl.parameters, func(p ParameterDeclaration) bool {
		return p.name.kind == SyntaxKindIdentifier && p.name.escapedText == name
	})
	return parameter && parameter.symbol
}

/** @internal */

func getEffectiveContainerForJSDocTemplateTag(node JSDocTemplateTag) /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | undefined */ any {
	if isJSDoc(node.parent) && node.parent.tags {
		// A @template tag belongs to any @typedef, @callback, or @enum tags in the same comment block, if they exist.
		typeAlias := find(node.parent.tags, isJSDocTypeAlias)
		if typeAlias {
			return typeAlias
		}
	}
	// otherwise it belongs to the host it annotates
	return getHostSignatureFromJSDoc(node)
}

/** @internal */

func getJSDocOverloadTags(node Node) []JSDocOverloadTag {
	return getAllJSDocTags(node, isJSDocOverloadTag)
}

/** @internal */

func getHostSignatureFromJSDoc(node Node) *SignatureDeclaration {
	host := getEffectiveJSDocHost(node)
	if host {
		switch {
		case isPropertySignature(host) && host.type_ && isFunctionLike(host.type_):
			return host.type_
		case isFunctionLike(host):
			return host
		default:
			return nil
		}
	}
	return nil
}

/** @internal */

func getEffectiveJSDocHost(node Node) Node {
	host := getJSDocHost(node)
	if host {
		return getSourceOfDefaultedAssignment(host) || getSourceOfAssignment(host) || getSingleInitializerOfVariableStatementOrPropertyDeclaration(host) || getSingleVariableOfVariableStatement(host) || getNestedModuleDeclaration(host) || host
	}
}

/**
 * Use getEffectiveJSDocHost if you additionally need to look for jsdoc on parent nodes, like assignments.
 *
 * @internal
 */

func getJSDocHost(node Node) *HasJSDoc {
	jsDoc := getJSDocRoot(node)
	if !jsDoc {
		return nil
	}

	host := jsDoc.parent
	if host && host.jsDoc && jsDoc == lastOrUndefined(host.jsDoc) {
		return host
	}
}

/** @internal */

func getJSDocRoot(node Node) *JSDoc {
	return findAncestor(node.parent, isJSDoc)
}

/** @internal */

func getTypeParameterFromJsDoc(node /* TODO(TS-TO-GO) TypeNode IntersectionType: TypeParameterDeclaration & { parent: JSDocTemplateTag; } */ any) *TypeParameterDeclaration {
	name := node.name.escapedText
	TODO_IDENTIFIER := node.parent.parent.parent /* as SignatureDeclaration | InterfaceDeclaration | ClassDeclaration */
	return typeParameters && find(typeParameters, func(p TypeParameterDeclaration) bool {
		return p.name.escapedText == name
	})
}

/** @internal @knipignore */

func hasTypeArguments(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is HasTypeArguments */ any {
	return !!(node /* as HasTypeArguments */).typeArguments
}

/** @internal */

type AssignmentKind int32

const (
	AssignmentKindNone AssignmentKind = iota
	AssignmentKindDefinite
	AssignmentKindCompound
)

type AssignmentTarget /* TODO(TS-TO-GO) TypeNode UnionType: | BinaryExpression | PrefixUnaryExpression | PostfixUnaryExpression | ForInOrOfStatement */ any

func getAssignmentTarget(node Node) *AssignmentTarget {
	parent := node.parent
	for true {
		switch parent.kind {
		case SyntaxKindBinaryExpression:
			binaryExpression := parent /* as BinaryExpression */
			binaryOperator := binaryExpression.operatorToken.kind
			if isAssignmentOperator(binaryOperator) && binaryExpression.left == node {
				return binaryExpression
			} else {
				return nil
			}
		case SyntaxKindPrefixUnaryExpression,
			SyntaxKindPostfixUnaryExpression:
			unaryExpression := parent /* as PrefixUnaryExpression | PostfixUnaryExpression */
			unaryOperator := unaryExpression.operator
			if unaryOperator == SyntaxKindPlusPlusToken || unaryOperator == SyntaxKindMinusMinusToken {
				return unaryExpression
			} else {
				return nil
			}
		case SyntaxKindForInStatement,
			SyntaxKindForOfStatement:
			forInOrOfStatement := parent /* as ForInOrOfStatement */
			if forInOrOfStatement.initializer == node {
				return forInOrOfStatement
			} else {
				return nil
			}
		case SyntaxKindParenthesizedExpression,
			SyntaxKindArrayLiteralExpression,
			SyntaxKindSpreadElement,
			SyntaxKindNonNullExpression:
			node = parent
		case SyntaxKindSpreadAssignment:
			node = parent.parent
		case SyntaxKindShorthandPropertyAssignment:
			if (parent /* as ShorthandPropertyAssignment */).name != node {
				return nil
			}
			node = parent.parent
		case SyntaxKindPropertyAssignment:
			if (parent /* as PropertyAssignment */).name == node {
				return nil
			}
			node = parent.parent
		default:
			return nil
		}
		parent = node.parent
	}
}

/** @internal */

func getAssignmentTargetKind(node Node) AssignmentKind {
	target := getAssignmentTarget(node)
	if !target {
		return AssignmentKindNone
	}
	switch target.kind {
	case SyntaxKindBinaryExpression:
		binaryOperator := target.operatorToken.kind
		if binaryOperator == SyntaxKindEqualsToken || isLogicalOrCoalescingAssignmentOperator(binaryOperator) {
			return AssignmentKindDefinite
		} else {
			return AssignmentKindCompound
		}
	case SyntaxKindPrefixUnaryExpression,
		SyntaxKindPostfixUnaryExpression:
		return AssignmentKindCompound
	case SyntaxKindForInStatement,
		SyntaxKindForOfStatement:
		return AssignmentKindDefinite
	}
}

// A node is an assignment target if it is on the left hand side of an '=' token, if it is parented by a property
// assignment in an object literal that is an assignment target, or if it is parented by an array literal that is
// an assignment target. Examples include 'a = xxx', '{ p: a } = xxx', '[{ a }] = xxx'.
// (Note that `p` is not a target in the above examples, only `a`.)

func isAssignmentTarget(node Node) bool {
	return !!getAssignmentTarget(node)
}

func isCompoundLikeAssignment(assignment AssignmentExpression[EqualsToken]) bool {
	right := skipParentheses(assignment.right)
	return right.kind == SyntaxKindBinaryExpression && isShiftOperatorOrHigher((right /* as BinaryExpression */).operatorToken.kind)
}

/** @internal */

func isInCompoundLikeAssignment(node Node) bool {
	target := getAssignmentTarget(node)
	return !!target && isAssignmentExpression(target /*excludeCompoundAssignment*/, true) && isCompoundLikeAssignment(target)
}

/** @internal */

type NodeWithPossibleHoistedDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: | Block | VariableStatement | WithStatement | IfStatement | SwitchStatement | CaseBlock | CaseClause | DefaultClause | LabeledStatement | ForStatement | ForInOrOfStatement | DoStatement | WhileStatement | TryStatement | CatchClause */ any

/**
 * Indicates whether a node could contain a `var` VariableDeclarationList that contributes to
 * the same `var` declaration scope as the node's parent.
 *
 * @internal
 */

func isNodeWithPossibleHoistedDeclaration(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is NodeWithPossibleHoistedDeclaration */ any {
	switch node.kind {
	case SyntaxKindBlock,
		SyntaxKindVariableStatement,
		SyntaxKindWithStatement,
		SyntaxKindIfStatement,
		SyntaxKindSwitchStatement,
		SyntaxKindCaseBlock,
		SyntaxKindCaseClause,
		SyntaxKindDefaultClause,
		SyntaxKindLabeledStatement,
		SyntaxKindForStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement,
		SyntaxKindDoStatement,
		SyntaxKindWhileStatement,
		SyntaxKindTryStatement,
		SyntaxKindCatchClause:
		return true
	}
	return false
}

/** @internal */

type ValueSignatureDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction */ any

/** @internal */

func isValueSignatureDeclaration(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ValueSignatureDeclaration */ any {
	return isFunctionExpression(node) || isArrowFunction(node) || isMethodOrAccessor(node) || isFunctionDeclaration(node) || isConstructorDeclaration(node)
}

func walkUp(node Node, kind SyntaxKind) Node {
	for node && node.kind == kind {
		node = node.parent
	}
	return node
}

/** @internal */

func walkUpParenthesizedTypes(node Node) Node {
	return walkUp(node, SyntaxKindParenthesizedType)
}

/** @internal */

func walkUpParenthesizedExpressions(node Node) Node {
	return walkUp(node, SyntaxKindParenthesizedExpression)
}

/**
 * Walks up parenthesized types.
 * It returns both the outermost parenthesized type and its parent.
 * If given node is not a parenthesiezd type, undefined is return as the former.
 *
 * @internal
 */

func walkUpParenthesizedTypesAndGetParentAndChild(node Node) /* TODO(TS-TO-GO) TypeNode TupleType: [ParenthesizedTypeNode | undefined, Node] */ any {
	var child *ParenthesizedTypeNode
	for node && node.kind == SyntaxKindParenthesizedType {
		child = node /* as ParenthesizedTypeNode */
		node = node.parent
	}
	return []any{child, node}
}

/** @internal */

func skipTypeParentheses(node TypeNode) TypeNode {
	for isParenthesizedTypeNode(node) {
		node = node.type_
	}
	return node
}

/** @internal */

/* OVERLOAD: export function skipParentheses(node: Expression, excludeJSDocTypeAssertions?: boolean): Expression; */
/** @internal */

/* OVERLOAD: export function skipParentheses(node: Node, excludeJSDocTypeAssertions?: boolean): Node; */
/** @internal */

func skipParentheses(node Node, excludeJSDocTypeAssertions bool) Node {
	var flags number
	if excludeJSDocTypeAssertions {
		flags = OuterExpressionKindsParentheses | OuterExpressionKindsExcludeJSDocTypeAssertion
	} else {
		flags = OuterExpressionKindsParentheses
	}
	return skipOuterExpressions(node, flags)
}

// a node is delete target iff. it is PropertyAccessExpression/ElementAccessExpression with parentheses skipped

func isDeleteTarget(node Node) bool {
	if node.kind != SyntaxKindPropertyAccessExpression && node.kind != SyntaxKindElementAccessExpression {
		return false
	}
	node = walkUpParenthesizedExpressions(node.parent)
	return node && node.kind == SyntaxKindDeleteExpression
}

/** @internal */

func isNodeDescendantOf(node Node, ancestor Node) bool {
	for node {
		if node == ancestor {
			return true
		}
		node = node.parent
	}
	return false
}

// True if `name` is the name of a declaration node

func isDeclarationName(name Node) bool {
	return !isSourceFile(name) && !isBindingPattern(name) && isDeclaration(name.parent) && name.parent.name == name
}

// See GH#16030

func getDeclarationFromName(name Node) Declaration {
	parent := name.parent
	switch name.kind {
	case SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindNumericLiteral:
		if isComputedPropertyName(parent) {
			return parent.parent
		}
		fallthrough
	case SyntaxKindIdentifier:
		if isDeclaration(parent) {
			if parent.name == name {
				return parent
			} else {
				return nil
			}
		} else if isQualifiedName(parent) {
			tag := parent.parent
			if isJSDocParameterTag(tag) && tag.name == parent {
				return tag
			} else {
				return nil
			}
		} else {
			binExp := parent.parent
			if isBinaryExpression(binExp) && getAssignmentDeclarationKind(binExp) != AssignmentDeclarationKindNone && ((binExp.left /* as BindableStaticNameExpression */).symbol || binExp.symbol) && getNameOfDeclaration(binExp) == name {
				return binExp
			} else {
				return nil
			}
		}
		fallthrough
	case SyntaxKindPrivateIdentifier:
		if isDeclaration(parent) && parent.name == name {
			return parent
		} else {
			return nil
		}
	default:
		return nil
	}
}

/** @internal */

func isLiteralComputedPropertyDeclarationName(node Node) bool {
	return isStringOrNumericLiteralLike(node) && node.parent.kind == SyntaxKindComputedPropertyName && isDeclaration(node.parent.parent)
}

// Return true if the given identifier is classified as an IdentifierName

func isIdentifierName(node Identifier) bool {
	parent := node.parent
	switch parent.kind {
	case SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindEnumMember,
		SyntaxKindPropertyAssignment,
		SyntaxKindPropertyAccessExpression:
		return (parent /* as NamedDeclaration | PropertyAccessExpression */).name == node
	case SyntaxKindQualifiedName:
		return (parent /* as QualifiedName */).right == node
	case SyntaxKindBindingElement,
		SyntaxKindImportSpecifier:
		return (parent /* as BindingElement | ImportSpecifier */).propertyName == node
	case SyntaxKindExportSpecifier,
		SyntaxKindJsxAttribute,
		SyntaxKindJsxSelfClosingElement,
		SyntaxKindJsxOpeningElement,
		SyntaxKindJsxClosingElement:
		return true
	}
	return false
}

/** @internal */

func getAliasDeclarationFromName(node EntityName) Declaration {
	switch node.parent.kind {
	case SyntaxKindImportClause,
		SyntaxKindImportSpecifier,
		SyntaxKindNamespaceImport,
		SyntaxKindExportSpecifier,
		SyntaxKindExportAssignment,
		SyntaxKindImportEqualsDeclaration,
		SyntaxKindNamespaceExport:
		return node.parent /* as Declaration */
	case SyntaxKindQualifiedName:
		for ok := true; ok; ok = node.parent.kind == SyntaxKindQualifiedName { // do-while loop
			node = node.parent /* as QualifiedName */
		}
		return getAliasDeclarationFromName(node)
	}
}

/** @internal */

func isAliasableExpression(e Expression) bool {
	return isEntityNameExpression(e) || isClassExpression(e)
}

/** @internal */

func exportAssignmentIsAlias(node /* TODO(TS-TO-GO) TypeNode UnionType: ExportAssignment | BinaryExpression */ any) bool {
	e := getExportAssignmentExpression(node)
	return isAliasableExpression(e)
}

/** @internal */

func getExportAssignmentExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: ExportAssignment | BinaryExpression */ any) Expression {
	if isExportAssignment(node) {
		return node.expression
	} else {
		return node.right
	}
}

/** @internal */

func getPropertyAssignmentAliasLikeExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAssignment | ShorthandPropertyAssignment | PropertyAccessExpression */ any) Expression {
	switch {
	case node.kind == SyntaxKindShorthandPropertyAssignment:
		return node.name
	case node.kind == SyntaxKindPropertyAssignment:
		return node.initializer
	default:
		return (node.parent /* as BinaryExpression */).right
	}
}

/** @internal */

func getEffectiveBaseTypeNode(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassLikeDeclaration | InterfaceDeclaration */ any) *ExpressionWithTypeArguments {
	baseType := getClassExtendsHeritageElement(node)
	if baseType && isInJSFile(node) {
		// Prefer an @augments tag because it may have type parameters.
		tag := getJSDocAugmentsTag(node)
		if tag {
			return tag.class
		}
	}
	return baseType
}

/** @internal */

func getClassExtendsHeritageElement(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassLikeDeclaration | InterfaceDeclaration */ any) *ExpressionWithTypeArguments {
	heritageClause := getHeritageClause(node.heritageClauses, SyntaxKindExtendsKeyword)
	if heritageClause && heritageClause.types.length > 0 {
		return heritageClause.types[0]
	} else {
		return nil
	}
}

/** @internal */

func getEffectiveImplementsTypeNodes(node ClassLikeDeclaration) *[]ExpressionWithTypeArguments {
	if isInJSFile(node) {
		return getJSDocImplementsTags(node).map_(func(n JSDocImplementsTag) /* TODO(TS-TO-GO) inferred type ExpressionWithTypeArguments & { readonly expression: Identifier | PropertyAccessEntityNameExpression; } */ any {
			return n.class
		})
	} else {
		heritageClause := getHeritageClause(node.heritageClauses, SyntaxKindImplementsKeyword)
		return heritageClause. /* ? */ types
	}
}

/**
 * Returns the node in an `extends` or `implements` clause of a class or interface.
 *
 * @internal
 */

func getAllSuperTypeNodes(node Node) []TypeNode {
	switch {
	case isInterfaceDeclaration(node):
		return getInterfaceBaseTypeNodes(node) || emptyArray
	case isClassLike(node):
		return concatenate(singleElementArray(getEffectiveBaseTypeNode(node)), getEffectiveImplementsTypeNodes(node)) || emptyArray
	default:
		return emptyArray
	}
}

/** @internal */

func getInterfaceBaseTypeNodes(node InterfaceDeclaration) *NodeArray[ExpressionWithTypeArguments] {
	heritageClause := getHeritageClause(node.heritageClauses, SyntaxKindExtendsKeyword)
	if heritageClause {
		return heritageClause.types
	} else {
		return nil
	}
}

/** @internal */

func getHeritageClause(clauses *NodeArray[HeritageClause], kind SyntaxKind) *HeritageClause {
	if clauses {
		for _, clause := range clauses {
			if clause.token == kind {
				return clause
			}
		}
	}

	return nil
}

/** @internal */

func getAncestor(node Node, kind SyntaxKind) Node {
	for node {
		if node.kind == kind {
			return node
		}
		node = node.parent
	}
	return nil
}

/** @internal */

func isKeyword(token SyntaxKind) /* TODO(TS-TO-GO) TypeNode TypePredicate: token is KeywordSyntaxKind */ any {
	return SyntaxKindFirstKeyword <= token && token <= SyntaxKindLastKeyword
}

/** @internal */

func isPunctuation(token SyntaxKind) /* TODO(TS-TO-GO) TypeNode TypePredicate: token is PunctuationSyntaxKind */ any {
	return SyntaxKindFirstPunctuation <= token && token <= SyntaxKindLastPunctuation
}

/** @internal */

func isKeywordOrPunctuation(token SyntaxKind) /* TODO(TS-TO-GO) TypeNode TypePredicate: token is PunctuationOrKeywordSyntaxKind */ any {
	return isKeyword(token) || isPunctuation(token)
}

/** @internal */

func isContextualKeyword(token SyntaxKind) bool {
	return SyntaxKindFirstContextualKeyword <= token && token <= SyntaxKindLastContextualKeyword
}

/** @internal */

func isNonContextualKeyword(token SyntaxKind) bool {
	return isKeyword(token) && !isContextualKeyword(token)
}

/** @internal */

func isStringANonContextualKeyword(name string) bool {
	token := stringToToken(name)
	return token != nil && isNonContextualKeyword(token)
}

/** @internal */

func isIdentifierANonContextualKeyword(node Identifier) bool {
	originalKeywordKind := identifierToKeywordKind(node)
	return !!originalKeywordKind && !isContextualKeyword(originalKeywordKind)
}

/** @internal */

func isTrivia(token SyntaxKind) /* TODO(TS-TO-GO) TypeNode TypePredicate: token is TriviaSyntaxKind */ any {
	return SyntaxKindFirstTriviaToken <= token && token <= SyntaxKindLastTriviaToken
}

// dprint-ignore

type FunctionFlags int32

const (
	FunctionFlagsNormal         FunctionFlags = 0
	FunctionFlagsGenerator      FunctionFlags = 1 << 0
	FunctionFlagsAsync          FunctionFlags = 1 << 1
	FunctionFlagsInvalid        FunctionFlags = 1 << 2
	FunctionFlagsAsyncGenerator FunctionFlags = FunctionFlagsAsync | FunctionFlagsGenerator
)

/** @internal */

func getFunctionFlags(node *SignatureDeclaration) FunctionFlags {
	if !node {
		return FunctionFlagsInvalid
	}

	flags := FunctionFlagsNormal
	switch node.kind {
	case SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindMethodDeclaration:
		if node.asteriskToken {
			flags |= FunctionFlagsGenerator
		}
		fallthrough
	case SyntaxKindArrowFunction:
		if hasSyntacticModifier(node, ModifierFlagsAsync) {
			flags |= FunctionFlagsAsync
		}
	}

	if !(node /* as FunctionLikeDeclaration */).body {
		flags |= FunctionFlagsInvalid
	}

	return flags
}

/** @internal */

func isAsyncFunction(node Node) bool {
	switch node.kind {
	case SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindMethodDeclaration:
		return (node /* as FunctionLikeDeclaration */).body != nil && (node /* as FunctionLikeDeclaration */).asteriskToken == nil && hasSyntacticModifier(node, ModifierFlagsAsync)
	}
	return false
}

/** @internal */

func isStringOrNumericLiteralLike(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is StringLiteralLike | NumericLiteral */ any {
	return isStringLiteralLike(node) || isNumericLiteral(node)
}

/** @internal */

func isSignedNumericLiteral(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is PrefixUnaryExpression & { operand: NumericLiteral; } */ any {
	return isPrefixUnaryExpression(node) && (node.operator == SyntaxKindPlusToken || node.operator == SyntaxKindMinusToken) && isNumericLiteral(node.operand)
}

/**
 * A declaration has a dynamic name if all of the following are true:
 *   1. The declaration has a computed property name.
 *   2. The computed name is *not* expressed as a StringLiteral.
 *   3. The computed name is *not* expressed as a NumericLiteral.
 *   4. The computed name is *not* expressed as a PlusToken or MinusToken
 *      immediately followed by a NumericLiteral.
 *
 * @internal
 */

func hasDynamicName(declaration Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: declaration is DynamicNamedDeclaration | DynamicNamedBinaryExpression */ any {
	name := getNameOfDeclaration(declaration)
	return !!name && isDynamicName(name)
}

/** @internal */

func isDynamicName(name DeclarationName) bool {
	if !(name.kind == SyntaxKindComputedPropertyName || name.kind == SyntaxKindElementAccessExpression) {
		return false
	}
	var expr Expression
	if isElementAccessExpression(name) {
		expr = skipParentheses(name.argumentExpression)
	} else {
		expr = name.expression
	}
	return !isStringOrNumericLiteralLike(expr) && !isSignedNumericLiteral(expr)
}

/** @internal */

func getPropertyNameForPropertyNameNode(name /* TODO(TS-TO-GO) TypeNode UnionType: PropertyName | JsxAttributeName */ any) *__String {
	switch name.kind {
	case SyntaxKindIdentifier,
		SyntaxKindPrivateIdentifier:
		return name.escapedText
	case SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral:
		return escapeLeadingUnderscores(name.text)
	case SyntaxKindComputedPropertyName:
		nameExpression := name.expression
		if isStringOrNumericLiteralLike(nameExpression) {
			return escapeLeadingUnderscores(nameExpression.text)
		} else if isSignedNumericLiteral(nameExpression) {
			if nameExpression.operator == SyntaxKindMinusToken {
				return tokenToString(nameExpression.operator) + nameExpression.operand.text /* as __String */
			}
			return nameExpression.operand.text /* as __String */
		}
		return nil
	case SyntaxKindJsxNamespacedName:
		return getEscapedTextOfJsxNamespacedName(name)
	default:
		return Debug.assertNever(name)
	}
}

/** @internal */

func isPropertyNameLiteral(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is PropertyNameLiteral */ any {
	switch node.kind {
	case SyntaxKindIdentifier,
		SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindNumericLiteral:
		return true
	default:
		return false
	}
}

/** @internal */

func getTextOfIdentifierOrLiteral(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyNameLiteral | PrivateIdentifier */ any) string {
	switch {
	case isMemberName(node):
		return idText(node)
	case isJsxNamespacedName(node):
		return getTextOfJsxNamespacedName(node)
	default:
		return node.text
	}
}

/** @internal */

func getEscapedTextOfIdentifierOrLiteral(node PropertyNameLiteral) __String {
	switch {
	case isMemberName(node):
		return node.escapedText
	case isJsxNamespacedName(node):
		return getEscapedTextOfJsxNamespacedName(node)
	default:
		return escapeLeadingUnderscores(node.text)
	}
}

/** @internal */

func getSymbolNameForPrivateIdentifier(containingClassSymbol Symbol, description __String) __String {
	return __TEMPLATE__("__#", getSymbolId(containingClassSymbol), "@", description) /* as __String */
}

/** @internal */

func isKnownSymbol(symbol Symbol) bool {
	return startsWith(symbol.escapedName /* as string */, "__@")
}

/** @internal */

func isPrivateIdentifierSymbol(symbol Symbol) bool {
	return startsWith(symbol.escapedName /* as string */, "__#")
}

/**
 * Indicates whether a property name is the special `__proto__` property.
 * Per the ECMA-262 spec, this only matters for property assignments whose name is
 * the Identifier `__proto__`, or the string literal `"__proto__"`, but not for
 * computed property names.
 */

func isProtoSetter(node PropertyName) bool {
	if isIdentifier(node) {
		return idText(node) == "__proto__"
	} else {
		return isStringLiteral(node) && node.text == "__proto__"
	}
}

/** @internal */

type AnonymousFunctionDefinition /* TODO(TS-TO-GO) TypeNode UnionType: | ClassExpression & { readonly name?: undefined; } | FunctionExpression & { readonly name?: undefined; } | ArrowFunction */ any

/**
 * Indicates whether an expression is an anonymous function definition.
 *
 * @see https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition
 */

func isAnonymousFunctionDefinition(node Expression, cb func(node AnonymousFunctionDefinition) bool) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is WrappedExpression<AnonymousFunctionDefinition> */ any {
	node = skipOuterExpressions(node)
	switch node.kind {
	case SyntaxKindClassExpression:
		if classHasDeclaredOrExplicitlyAssignedName(node /* as ClassExpression */) {
			return false
		}
	case SyntaxKindFunctionExpression:
		if (node /* as FunctionExpression */).name {
			return false
		}
	case SyntaxKindArrowFunction:
	default:
		return false
	}
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof cb */ TODO == "function" {
		return cb(node /* as AnonymousFunctionDefinition */)
	} else {
		return true
	}
}

/** @internal */

type NamedEvaluationSource /* TODO(TS-TO-GO) TypeNode UnionType: | PropertyAssignment & { readonly name: Identifier; } | ShorthandPropertyAssignment & { readonly objectAssignmentInitializer: Expression; } | VariableDeclaration & { readonly name: Identifier; readonly initializer: Expression; } | ParameterDeclaration & { readonly name: Identifier; readonly initializer: Expression; readonly dotDotDotToken: undefined; } | BindingElement & { readonly name: Identifier; readonly initializer: Expression; readonly dotDotDotToken: undefined; } | PropertyDeclaration & { readonly initializer: Expression; } | AssignmentExpression<EqualsToken | AmpersandAmpersandEqualsToken | BarBarEqualsToken | QuestionQuestionEqualsToken> & { readonly left: Identifier; } | ExportAssignment */ any

/**
 * Indicates whether a node is a potential source of an assigned name for a class, function, or arrow function.
 *
 * @internal
 */

func isNamedEvaluationSource(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is NamedEvaluationSource */ any {
	switch node.kind {
	case SyntaxKindPropertyAssignment:
		return !isProtoSetter((node /* as PropertyAssignment */).name)
	case SyntaxKindShorthandPropertyAssignment:
		return !!(node /* as ShorthandPropertyAssignment */).objectAssignmentInitializer
	case SyntaxKindVariableDeclaration:
		return isIdentifier((node /* as VariableDeclaration */).name) && !!(node /* as VariableDeclaration */).initializer
	case SyntaxKindParameter:
		return isIdentifier((node /* as ParameterDeclaration */).name) && !!(node /* as VariableDeclaration */).initializer && !(node /* as BindingElement */).dotDotDotToken
	case SyntaxKindBindingElement:
		return isIdentifier((node /* as BindingElement */).name) && !!(node /* as VariableDeclaration */).initializer && !(node /* as BindingElement */).dotDotDotToken
	case SyntaxKindPropertyDeclaration:
		return !!(node /* as PropertyDeclaration */).initializer
	case SyntaxKindBinaryExpression:
		switch (node /* as BinaryExpression */).operatorToken.kind {
		case SyntaxKindEqualsToken,
			SyntaxKindAmpersandAmpersandEqualsToken,
			SyntaxKindBarBarEqualsToken,
			SyntaxKindQuestionQuestionEqualsToken:
			return isIdentifier((node /* as BinaryExpression */).left)
		}
	case SyntaxKindExportAssignment:
		return true
	}
	return false
}

/** @internal */

type NamedEvaluation /* TODO(TS-TO-GO) TypeNode UnionType: | PropertyAssignment & { readonly name: Identifier; readonly initializer: WrappedExpression<AnonymousFunctionDefinition>; } | ShorthandPropertyAssignment & { readonly objectAssignmentInitializer: WrappedExpression<AnonymousFunctionDefinition>; } | VariableDeclaration & { readonly name: Identifier; readonly initializer: WrappedExpression<AnonymousFunctionDefinition>; } | ParameterDeclaration & { readonly name: Identifier; readonly dotDotDotToken: undefined; readonly initializer: WrappedExpression<AnonymousFunctionDefinition>; } | BindingElement & { readonly name: Identifier; readonly dotDotDotToken: undefined; readonly initializer: WrappedExpression<AnonymousFunctionDefinition>; } | PropertyDeclaration & { readonly initializer: WrappedExpression<AnonymousFunctionDefinition>; } | AssignmentExpression<EqualsToken> & { readonly left: Identifier; readonly right: WrappedExpression<AnonymousFunctionDefinition>; } | AssignmentExpression<AmpersandAmpersandEqualsToken | BarBarEqualsToken | QuestionQuestionEqualsToken> & { readonly left: Identifier; readonly right: WrappedExpression<AnonymousFunctionDefinition>; } | ExportAssignment & { readonly expression: WrappedExpression<AnonymousFunctionDefinition>; } */ any

/** @internal */

func isNamedEvaluation(node Node, cb func(node AnonymousFunctionDefinition) bool) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is NamedEvaluation */ any {
	if !isNamedEvaluationSource(node) {
		return false
	}
	switch node.kind {
	case SyntaxKindPropertyAssignment:
		return isAnonymousFunctionDefinition(node.initializer, cb)
	case SyntaxKindShorthandPropertyAssignment:
		return isAnonymousFunctionDefinition(node.objectAssignmentInitializer, cb)
	case SyntaxKindVariableDeclaration,
		SyntaxKindParameter,
		SyntaxKindBindingElement,
		SyntaxKindPropertyDeclaration:
		return isAnonymousFunctionDefinition(node.initializer, cb)
	case SyntaxKindBinaryExpression:
		return isAnonymousFunctionDefinition(node.right, cb)
	case SyntaxKindExportAssignment:
		return isAnonymousFunctionDefinition(node.expression, cb)
	}
}

/** @internal */

func isPushOrUnshiftIdentifier(node Identifier) bool {
	return node.escapedText == "push" || node.escapedText == "unshift"
}

/**
 * This function returns true if the this node's root declaration is a parameter.
 * For example, passing a `ParameterDeclaration` will return true, as will passing a
 * binding element that is a child of a `ParameterDeclaration`.
 *
 * If you are looking to test that a `Node` is a `ParameterDeclaration`, use `isParameter`.
 *
 * @internal
 */

func isPartOfParameterDeclaration(node Declaration) bool {
	root := getRootDeclaration(node)
	return root.kind == SyntaxKindParameter
}

/** @internal */

func getRootDeclaration(node Node) Node {
	for node.kind == SyntaxKindBindingElement {
		node = node.parent.parent
	}
	return node
}

/** @internal */

func nodeStartsNewLexicalEnvironment(node Node) bool {
	kind := node.kind
	return kind == SyntaxKindConstructor || kind == SyntaxKindFunctionExpression || kind == SyntaxKindFunctionDeclaration || kind == SyntaxKindArrowFunction || kind == SyntaxKindMethodDeclaration || kind == SyntaxKindGetAccessor || kind == SyntaxKindSetAccessor || kind == SyntaxKindModuleDeclaration || kind == SyntaxKindSourceFile
}

/** @internal */

func nodeIsSynthesized(range_ TextRange) bool {
	return positionIsSynthesized(range_.pos) || positionIsSynthesized(range_.end)
}

/** @internal */

type Associativity int32

const (
	AssociativityLeft Associativity = iota
	AssociativityRight
)

/** @internal */

func getExpressionAssociativity(expression Expression) Associativity {
	operator := getOperator(expression)
	hasArguments := expression.kind == SyntaxKindNewExpression && (expression /* as NewExpression */).arguments != nil
	return getOperatorAssociativity(expression.kind, operator, hasArguments)
}

/** @internal */

func getOperatorAssociativity(kind SyntaxKind, operator SyntaxKind, hasArguments bool) Associativity {
	switch kind {
	case SyntaxKindNewExpression:
		if hasArguments {
			return AssociativityLeft
		} else {
			return AssociativityRight
		}
	case SyntaxKindPrefixUnaryExpression,
		SyntaxKindTypeOfExpression,
		SyntaxKindVoidExpression,
		SyntaxKindDeleteExpression,
		SyntaxKindAwaitExpression,
		SyntaxKindConditionalExpression,
		SyntaxKindYieldExpression:
		return AssociativityRight
	case SyntaxKindBinaryExpression:
		switch operator {
		case SyntaxKindAsteriskAsteriskToken,
			SyntaxKindEqualsToken,
			SyntaxKindPlusEqualsToken,
			SyntaxKindMinusEqualsToken,
			SyntaxKindAsteriskAsteriskEqualsToken,
			SyntaxKindAsteriskEqualsToken,
			SyntaxKindSlashEqualsToken,
			SyntaxKindPercentEqualsToken,
			SyntaxKindLessThanLessThanEqualsToken,
			SyntaxKindGreaterThanGreaterThanEqualsToken,
			SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken,
			SyntaxKindAmpersandEqualsToken,
			SyntaxKindCaretEqualsToken,
			SyntaxKindBarEqualsToken,
			SyntaxKindBarBarEqualsToken,
			SyntaxKindAmpersandAmpersandEqualsToken,
			SyntaxKindQuestionQuestionEqualsToken:
			return AssociativityRight
		}
	}
	return AssociativityLeft
}

/** @internal */

func getExpressionPrecedence(expression Expression) OperatorPrecedence {
	operator := getOperator(expression)
	hasArguments := expression.kind == SyntaxKindNewExpression && (expression /* as NewExpression */).arguments != nil
	return getOperatorPrecedence(expression.kind, operator, hasArguments)
}

func getOperator(expression Expression) SyntaxKind {
	if expression.kind == SyntaxKindBinaryExpression {
		return (expression /* as BinaryExpression */).operatorToken.kind
	} else if expression.kind == SyntaxKindPrefixUnaryExpression || expression.kind == SyntaxKindPostfixUnaryExpression {
		return (expression /* as PrefixUnaryExpression | PostfixUnaryExpression */).operator
	} else {
		return expression.kind
	}
}

/** @internal */

type OperatorPrecedence int32

const (
	// Expression:
	//     AssignmentExpression
	//     Expression `,` AssignmentExpression
	OperatorPrecedenceComma OperatorPrecedence = iota
	// NOTE: `Spread` is higher than `Comma` due to how it is parsed in |ElementList|
	// SpreadElement:
	//     `...` AssignmentExpression
	OperatorPrecedenceSpread
	// AssignmentExpression:
	//     ConditionalExpression
	//     YieldExpression
	//     ArrowFunction
	//     AsyncArrowFunction
	//     LeftHandSideExpression `=` AssignmentExpression
	//     LeftHandSideExpression AssignmentOperator AssignmentExpression
	//
	// NOTE: AssignmentExpression is broken down into several precedences due to the requirements
	//       of the parenthesizer rules.
	// AssignmentExpression: YieldExpression
	// YieldExpression:
	//     `yield`
	//     `yield` AssignmentExpression
	//     `yield` `*` AssignmentExpression
	OperatorPrecedenceYield
	// AssignmentExpression: LeftHandSideExpression `=` AssignmentExpression
	// AssignmentExpression: LeftHandSideExpression AssignmentOperator AssignmentExpression
	// AssignmentOperator: one of
	//     `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=` `**=`
	OperatorPrecedenceAssignment
	// NOTE: `Conditional` is considered higher than `Assignment` here, but in reality they have
	//       the same precedence.
	// AssignmentExpression: ConditionalExpression
	// ConditionalExpression:
	//     ShortCircuitExpression
	//     ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression
	// ShortCircuitExpression:
	//     LogicalORExpression
	//     CoalesceExpression
	OperatorPrecedenceConditional
	// CoalesceExpression:
	//     CoalesceExpressionHead `??` BitwiseORExpression
	// CoalesceExpressionHead:
	//     CoalesceExpression
	//     BitwiseORExpression
	OperatorPrecedenceCoalesce OperatorPrecedence = OperatorPrecedenceConditional
	// LogicalORExpression:
	//     LogicalANDExpression
	//     LogicalORExpression `||` LogicalANDExpression
	OperatorPrecedenceLogicalOR
	// LogicalANDExpression:
	//     BitwiseORExpression
	//     LogicalANDExprerssion `&&` BitwiseORExpression
	OperatorPrecedenceLogicalAND
	// BitwiseORExpression:
	//     BitwiseXORExpression
	//     BitwiseORExpression `^` BitwiseXORExpression
	OperatorPrecedenceBitwiseOR
	// BitwiseXORExpression:
	//     BitwiseANDExpression
	//     BitwiseXORExpression `^` BitwiseANDExpression
	OperatorPrecedenceBitwiseXOR
	// BitwiseANDExpression:
	//     EqualityExpression
	//     BitwiseANDExpression `^` EqualityExpression
	OperatorPrecedenceBitwiseAND
	// EqualityExpression:
	//     RelationalExpression
	//     EqualityExpression `==` RelationalExpression
	//     EqualityExpression `!=` RelationalExpression
	//     EqualityExpression `===` RelationalExpression
	//     EqualityExpression `!==` RelationalExpression
	OperatorPrecedenceEquality
	// RelationalExpression:
	//     ShiftExpression
	//     RelationalExpression `<` ShiftExpression
	//     RelationalExpression `>` ShiftExpression
	//     RelationalExpression `<=` ShiftExpression
	//     RelationalExpression `>=` ShiftExpression
	//     RelationalExpression `instanceof` ShiftExpression
	//     RelationalExpression `in` ShiftExpression
	//     [+TypeScript] RelationalExpression `as` Type
	OperatorPrecedenceRelational
	// ShiftExpression:
	//     AdditiveExpression
	//     ShiftExpression `<<` AdditiveExpression
	//     ShiftExpression `>>` AdditiveExpression
	//     ShiftExpression `>>>` AdditiveExpression
	OperatorPrecedenceShift
	// AdditiveExpression:
	//     MultiplicativeExpression
	//     AdditiveExpression `+` MultiplicativeExpression
	//     AdditiveExpression `-` MultiplicativeExpression
	OperatorPrecedenceAdditive
	// MultiplicativeExpression:
	//     ExponentiationExpression
	//     MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
	// MultiplicativeOperator: one of `*`, `/`, `%`
	OperatorPrecedenceMultiplicative
	// ExponentiationExpression:
	//     UnaryExpression
	//     UpdateExpression `**` ExponentiationExpression
	OperatorPrecedenceExponentiation
	// UnaryExpression:
	//     UpdateExpression
	//     `delete` UnaryExpression
	//     `void` UnaryExpression
	//     `typeof` UnaryExpression
	//     `+` UnaryExpression
	//     `-` UnaryExpression
	//     `~` UnaryExpression
	//     `!` UnaryExpression
	//     AwaitExpression
	// UpdateExpression:            // TODO: Do we need to investigate the precedence here?
	//     `++` UnaryExpression
	//     `--` UnaryExpression
	OperatorPrecedenceUnary
	// UpdateExpression:
	//     LeftHandSideExpression
	//     LeftHandSideExpression `++`
	//     LeftHandSideExpression `--`
	OperatorPrecedenceUpdate
	// LeftHandSideExpression:
	//     NewExpression
	//     CallExpression
	// NewExpression:
	//     MemberExpression
	//     `new` NewExpression
	OperatorPrecedenceLeftHandSide
	// CallExpression:
	//     CoverCallExpressionAndAsyncArrowHead
	//     SuperCall
	//     ImportCall
	//     CallExpression Arguments
	//     CallExpression `[` Expression `]`
	//     CallExpression `.` IdentifierName
	//     CallExpression TemplateLiteral
	// MemberExpression:
	//     PrimaryExpression
	//     MemberExpression `[` Expression `]`
	//     MemberExpression `.` IdentifierName
	//     MemberExpression TemplateLiteral
	//     SuperProperty
	//     MetaProperty
	//     `new` MemberExpression Arguments
	OperatorPrecedenceMember
	// TODO: JSXElement?
	// PrimaryExpression:
	//     `this`
	//     IdentifierReference
	//     Literal
	//     ArrayLiteral
	//     ObjectLiteral
	//     FunctionExpression
	//     ClassExpression
	//     GeneratorExpression
	//     AsyncFunctionExpression
	//     AsyncGeneratorExpression
	//     RegularExpressionLiteral
	//     TemplateLiteral
	//     CoverParenthesizedExpressionAndArrowParameterList
	OperatorPrecedencePrimary
	OperatorPrecedenceHighest OperatorPrecedence = OperatorPrecedencePrimary
	OperatorPrecedenceLowest  OperatorPrecedence = OperatorPrecedenceComma
	// -1 is lower than all other precedences. Returning it will cause binary expression
	// parsing to stop.
	OperatorPrecedenceInvalid OperatorPrecedence = -1
)

/** @internal */

func getOperatorPrecedence(nodeKind SyntaxKind, operatorKind SyntaxKind, hasArguments bool) OperatorPrecedence {
	switch nodeKind {
	case SyntaxKindCommaListExpression:
		return OperatorPrecedenceComma
	case SyntaxKindSpreadElement:
		return OperatorPrecedenceSpread
	case SyntaxKindYieldExpression:
		return OperatorPrecedenceYield
	case SyntaxKindConditionalExpression:
		return OperatorPrecedenceConditional
	case SyntaxKindBinaryExpression:
		switch operatorKind {
		case SyntaxKindCommaToken:
			return OperatorPrecedenceComma
		case SyntaxKindEqualsToken,
			SyntaxKindPlusEqualsToken,
			SyntaxKindMinusEqualsToken,
			SyntaxKindAsteriskAsteriskEqualsToken,
			SyntaxKindAsteriskEqualsToken,
			SyntaxKindSlashEqualsToken,
			SyntaxKindPercentEqualsToken,
			SyntaxKindLessThanLessThanEqualsToken,
			SyntaxKindGreaterThanGreaterThanEqualsToken,
			SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken,
			SyntaxKindAmpersandEqualsToken,
			SyntaxKindCaretEqualsToken,
			SyntaxKindBarEqualsToken,
			SyntaxKindBarBarEqualsToken,
			SyntaxKindAmpersandAmpersandEqualsToken,
			SyntaxKindQuestionQuestionEqualsToken:
			return OperatorPrecedenceAssignment
		default:
			return getBinaryOperatorPrecedence(operatorKind)
		}
		fallthrough
	case SyntaxKindTypeAssertionExpression,
		SyntaxKindNonNullExpression,
		SyntaxKindPrefixUnaryExpression,
		SyntaxKindTypeOfExpression,
		SyntaxKindVoidExpression,
		SyntaxKindDeleteExpression,
		SyntaxKindAwaitExpression:
		return OperatorPrecedenceUnary
	case SyntaxKindPostfixUnaryExpression:
		return OperatorPrecedenceUpdate
	case SyntaxKindCallExpression:
		return OperatorPrecedenceLeftHandSide
	case SyntaxKindNewExpression:
		if hasArguments {
			return OperatorPrecedenceMember
		} else {
			return OperatorPrecedenceLeftHandSide
		}
	case SyntaxKindTaggedTemplateExpression,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression,
		SyntaxKindMetaProperty:
		return OperatorPrecedenceMember
	case SyntaxKindAsExpression,
		SyntaxKindSatisfiesExpression:
		return OperatorPrecedenceRelational
	case SyntaxKindThisKeyword,
		SyntaxKindSuperKeyword,
		SyntaxKindIdentifier,
		SyntaxKindPrivateIdentifier,
		SyntaxKindNullKeyword,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindStringLiteral,
		SyntaxKindArrayLiteralExpression,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindClassExpression,
		SyntaxKindRegularExpressionLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindTemplateExpression,
		SyntaxKindParenthesizedExpression,
		SyntaxKindOmittedExpression,
		SyntaxKindJsxElement,
		SyntaxKindJsxSelfClosingElement,
		SyntaxKindJsxFragment:
		return OperatorPrecedencePrimary
	default:
		return OperatorPrecedenceInvalid
	}
}

/** @internal */

func getBinaryOperatorPrecedence(kind SyntaxKind) OperatorPrecedence {
	switch kind {
	case SyntaxKindQuestionQuestionToken:
		return OperatorPrecedenceCoalesce
	case SyntaxKindBarBarToken:
		return OperatorPrecedenceLogicalOR
	case SyntaxKindAmpersandAmpersandToken:
		return OperatorPrecedenceLogicalAND
	case SyntaxKindBarToken:
		return OperatorPrecedenceBitwiseOR
	case SyntaxKindCaretToken:
		return OperatorPrecedenceBitwiseXOR
	case SyntaxKindAmpersandToken:
		return OperatorPrecedenceBitwiseAND
	case SyntaxKindEqualsEqualsToken,
		SyntaxKindExclamationEqualsToken,
		SyntaxKindEqualsEqualsEqualsToken,
		SyntaxKindExclamationEqualsEqualsToken:
		return OperatorPrecedenceEquality
	case SyntaxKindLessThanToken,
		SyntaxKindGreaterThanToken,
		SyntaxKindLessThanEqualsToken,
		SyntaxKindGreaterThanEqualsToken,
		SyntaxKindInstanceOfKeyword,
		SyntaxKindInKeyword,
		SyntaxKindAsKeyword,
		SyntaxKindSatisfiesKeyword:
		return OperatorPrecedenceRelational
	case SyntaxKindLessThanLessThanToken,
		SyntaxKindGreaterThanGreaterThanToken,
		SyntaxKindGreaterThanGreaterThanGreaterThanToken:
		return OperatorPrecedenceShift
	case SyntaxKindPlusToken,
		SyntaxKindMinusToken:
		return OperatorPrecedenceAdditive
	case SyntaxKindAsteriskToken,
		SyntaxKindSlashToken,
		SyntaxKindPercentToken:
		return OperatorPrecedenceMultiplicative
	case SyntaxKindAsteriskAsteriskToken:
		return OperatorPrecedenceExponentiation
	}

	// -1 is lower than all other precedences.  Returning it will cause binary expression
	// parsing to stop.
	return -1
}

/** @internal */

func getSemanticJsxChildren(children []JsxChild) []JsxChild {
	return filter(children, func(i JsxChild) bool {
		switch i.kind {
		case SyntaxKindJsxExpression:
			return !!i.expression
		case SyntaxKindJsxText:
			return !i.containsOnlyTriviaWhiteSpaces
		default:
			return true
		}
	})
}

/** @internal */

func createDiagnosticCollection() DiagnosticCollection {
	nonFileDiagnostics := []never{} /* as Diagnostic[] */ /* as SortedArray<Diagnostic> */
	// See GH#19873
	filesWithDiagnostics := []never{} /* as string[] */ /* as SortedArray<string> */
	fileDiagnostics := NewMap[string, SortedArray[DiagnosticWithLocation]]()
	hasReadNonFileDiagnostics := false

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"add":                  add,
		"lookup":               lookup,
		"getGlobalDiagnostics": getGlobalDiagnostics,
		"getDiagnostics":       getDiagnostics,
	}

	lookup := func(diagnostic Diagnostic) *Diagnostic {
		var diagnostics *SortedArray[Diagnostic]
		if diagnostic.file {
			diagnostics = fileDiagnostics.get(diagnostic.file.fileName)
		} else {
			diagnostics = nonFileDiagnostics
		}
		if !diagnostics {
			return nil
		}
		result := binarySearch(diagnostics, diagnostic, identity, compareDiagnosticsSkipRelatedInformation)
		if result >= 0 {
			return diagnostics[result]
		}
		if ~result > 0 && diagnosticsEqualityComparer(diagnostic, diagnostics[~result-1]) {
			return diagnostics[~result-1]
		}
		return nil
	}

	add := func(diagnostic Diagnostic) {
		var diagnostics *SortedArray[Diagnostic]
		if diagnostic.file {
			diagnostics = fileDiagnostics.get(diagnostic.file.fileName)
			if !diagnostics {
				diagnostics = []never{} /* as Diagnostic[] */ /* as SortedArray<DiagnosticWithLocation> */
				// See GH#19873
				fileDiagnostics.set(diagnostic.file.fileName, diagnostics /* as SortedArray<DiagnosticWithLocation> */)
				insertSorted(filesWithDiagnostics, diagnostic.file.fileName, compareStringsCaseSensitive)
			}
		} else {
			// If we've already read the non-file diagnostics, do not modify the existing array.
			if hasReadNonFileDiagnostics {
				hasReadNonFileDiagnostics = false
				nonFileDiagnostics = nonFileDiagnostics.slice() /* as SortedArray<Diagnostic> */
			}

			diagnostics = nonFileDiagnostics
		}

		insertSorted(diagnostics, diagnostic, compareDiagnosticsSkipRelatedInformation, diagnosticsEqualityComparer)
	}

	getGlobalDiagnostics := func() []Diagnostic {
		hasReadNonFileDiagnostics = true
		return nonFileDiagnostics
	}

	/* OVERLOAD: function getDiagnostics(fileName: string): DiagnosticWithLocation[]; */
	/* OVERLOAD: function getDiagnostics(): Diagnostic[]; */
	getDiagnostics := func(fileName string) []Diagnostic {
		if fileName {
			return fileDiagnostics.get(fileName) || []never{}
		}

		var fileDiags []Diagnostic = flatMapToMutable(filesWithDiagnostics, func(f string) * /* TODO(TS-TO-GO) inferred type SortedArray<DiagnosticWithLocation> */ any {
			return fileDiagnostics.get(f)
		})
		if !nonFileDiagnostics.length {
			return fileDiags
		}
		fileDiags.unshift(nonFileDiagnostics...)
		return fileDiags
	}

}

var templateSubstitutionRegExp = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\$\{/g */ TODO

/** @internal */

func escapeTemplateSubstitution(str string) string {
	return str.replace(templateSubstitutionRegExp, "\\${")
}

func containsInvalidEscapeFlag(node TemplateLiteralToken) bool {
	return !!((node.templateFlags || 0) & TokenFlagsContainsInvalidEscape)
}

/** @internal */

func hasInvalidEscape(template TemplateLiteral) bool {
	return template && !!(__COND__(isNoSubstitutionTemplateLiteral(template), containsInvalidEscapeFlag(template), (containsInvalidEscapeFlag(template.head) || some(template.templateSpans, func(span TemplateSpan) bool {
		return containsInvalidEscapeFlag(span.literal)
	}))))
}

// This consists of the first 19 unprintable ASCII characters, canonical escapes, lineSeparator,
// paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in
// the language service. These characters should be escaped when printing, and if any characters are added,
// the map below must be updated. Note that this regexp *does not* include the 'delete' character.
// There is no reason for this other than that JSON.stringify does not handle it either.
var doubleQuoteEscapedCharsRegExp = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /[\\"\u0000-\u001f\u2028\u2029\u0085]/g */ TODO
var singleQuoteEscapedCharsRegExp = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /[\\'\u0000-\u001f\u2028\u2029\u0085]/g */ TODO

// Template strings preserve simple LF newlines, still encode CRLF (or CR)
var backtickQuoteEscapedCharsRegExp = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\r\n|[\\`\u0000-\u001f\u2028\u2029\u0085]/g */ TODO
var escapedCharsMap = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"TODO_IDENTIFIER": "\\t",
	"TODO_IDENTIFIER": "\\v",
	"TODO_IDENTIFIER": "\\f",
	"TODO_IDENTIFIER": "\\b",
	"TODO_IDENTIFIER": "\\r",
	"TODO_IDENTIFIER": "\\n",
	"TODO_IDENTIFIER": "\\\\",
	"TODO_IDENTIFIER": "\\\"",
	"TODO_IDENTIFIER": "\\'",
	"TODO_IDENTIFIER": "\\`",
	"TODO_IDENTIFIER": "\\u2028",
	"TODO_IDENTIFIER": "\\u2029",
	"TODO_IDENTIFIER": "\\u0085",
	"TODO_IDENTIFIER": "\\r\\n",
}))

func encodeUtf16EscapeSequence(charCode number) string {
	hexCharCode := charCode.toString(16).toUpperCase()
	paddedHexCode := ("0000" + hexCharCode).slice(-4)
	return "\\u" + paddedHexCode
}

func getReplacement(c string, offset number, input string) string {
	if c.charCodeAt(0) == CharacterCodesnullCharacter {
		lookAhead := input.charCodeAt(offset + c.length)
		if lookAhead >= CharacterCodes_0 && lookAhead <= CharacterCodes_9 {
			// If the null character is followed by digits, print as a hex escape to prevent the result from parsing as an octal (which is forbidden in strict mode)
			return "\\x00"
		}
		// Otherwise, keep printing a literal \0 for the null character
		return "\\0"
	}
	return escapedCharsMap.get(c) || encodeUtf16EscapeSequence(c.charCodeAt(0))
}

/**
 * Based heavily on the abstract 'Quote'/'QuoteJSONString' operation from ECMA-262 (24.3.2.2),
 * but augmented for a few select characters (e.g. lineSeparator, paragraphSeparator, nextLine)
 * Note that this doesn't actually wrap the input in double quotes.
 *
 * @internal
 */

func escapeString(s string, quoteChar /* TODO(TS-TO-GO) TypeNode UnionType: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick */ any) string {
	var escapedCharsRegExp RegExp
	switch {
	case quoteChar == CharacterCodesbacktick:
		escapedCharsRegExp = backtickQuoteEscapedCharsRegExp
	case quoteChar == CharacterCodessingleQuote:
		escapedCharsRegExp = singleQuoteEscapedCharsRegExp
	default:
		escapedCharsRegExp = doubleQuoteEscapedCharsRegExp
	}
	return s.replace(escapedCharsRegExp, getReplacement)
}

var nonAsciiCharacters = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /[^\u0000-\u007F]/g */ TODO

/** @internal */

func escapeNonAsciiString(s string, quoteChar /* TODO(TS-TO-GO) TypeNode UnionType: CharacterCodes.doubleQuote | CharacterCodes.singleQuote | CharacterCodes.backtick */ any) string {
	s = escapeString(s, quoteChar)
	// Replace non-ASCII characters with '\uNNNN' escapes if any exist.
	// Otherwise just return the original string.
	if nonAsciiCharacters.test(s) {
		return s.replace(nonAsciiCharacters, func(c string) string {
			return encodeUtf16EscapeSequence(c.charCodeAt(0))
		})
	} else {
		return s
	}
}

// This consists of the first 19 unprintable ASCII characters, JSX canonical escapes, lineSeparator,
// paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in
// the language service. These characters should be escaped when printing, and if any characters are added,
// the map below must be updated.
var jsxDoubleQuoteEscapedCharsRegExp = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /["\u0000-\u001f\u2028\u2029\u0085]/g */ TODO
var jsxSingleQuoteEscapedCharsRegExp = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /['\u0000-\u001f\u2028\u2029\u0085]/g */ TODO
var jsxEscapedCharsMap = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"TODO_IDENTIFIER": "&quot;",
	"TODO_IDENTIFIER": "&apos;",
}))

func encodeJsxCharacterEntity(charCode number) string {
	hexCharCode := charCode.toString(16).toUpperCase()
	return "&#x" + hexCharCode + ";"
}

func getJsxAttributeStringReplacement(c string) string {
	if c.charCodeAt(0) == CharacterCodesnullCharacter {
		return "&#0;"
	}
	return jsxEscapedCharsMap.get(c) || encodeJsxCharacterEntity(c.charCodeAt(0))
}

/** @internal */

func escapeJsxAttributeString(s string, quoteChar /* TODO(TS-TO-GO) TypeNode UnionType: CharacterCodes.doubleQuote | CharacterCodes.singleQuote */ any) string {
	var escapedCharsRegExp RegExp
	if quoteChar == CharacterCodessingleQuote {
		escapedCharsRegExp = jsxSingleQuoteEscapedCharsRegExp
	} else {
		escapedCharsRegExp = jsxDoubleQuoteEscapedCharsRegExp
	}
	return s.replace(escapedCharsRegExp, getJsxAttributeStringReplacement)
}

/**
 * Strip off existed surrounding single quotes, double quotes, or backticks from a given string
 *
 * @return non-quoted string
 *
 * @internal
 */

func stripQuotes(name string) string {
	length := name.length
	if length >= 2 && name.charCodeAt(0) == name.charCodeAt(length-1) && isQuoteOrBacktick(name.charCodeAt(0)) {
		return name.substring(1, length-1)
	}
	return name
}

func isQuoteOrBacktick(charCode number) bool {
	return charCode == CharacterCodessingleQuote || charCode == CharacterCodesdoubleQuote || charCode == CharacterCodesbacktick
}

/** @internal */

func isIntrinsicJsxName(name /* TODO(TS-TO-GO) TypeNode UnionType: __String | string */ any) bool {
	ch := (name /* as string */).charCodeAt(0)
	return (ch >= CharacterCodesa && ch <= CharacterCodesz) || (name /* as string */).includes("-")
}

var indentStrings []string = []string{"", "    "}

/** @internal */

func getIndentString(level number) string {
	// prepopulate cache
	singleLevel := indentStrings[1]
	for current := indentStrings.length; current <= level; current++ {
		indentStrings.push(indentStrings[current-1] + singleLevel)
	}
	return indentStrings[level]
}

func getIndentSize() number {
	return indentStrings[1].length
}

/** @internal */

func createTextWriter(newLine string) EmitTextWriter {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	var output string
	var indent number
	var lineStart bool
	var lineCount number
	var linePos number
	hasTrailingComment := false
	/* eslint-enable no-var */

	updateLineCountAndPosFor := func(s string) {
		lineStartsOfS := computeLineStarts(s)
		if lineStartsOfS.length > 1 {
			lineCount = lineCount + lineStartsOfS.length - 1
			linePos = output.length - s.length + last(lineStartsOfS)
			lineStart = (linePos - output.length) == 0
		} else {
			lineStart = false
		}
	}

	writeText := func(s string) {
		if s && s.length {
			if lineStart {
				s = getIndentString(indent) + s
				lineStart = false
			}
			output += s
			updateLineCountAndPosFor(s)
		}
	}

	write := func(s string) {
		if s {
			hasTrailingComment = false
		}
		writeText(s)
	}

	writeComment := func(s string) {
		if s {
			hasTrailingComment = true
		}
		writeText(s)
	}

	reset := func() {
		output = ""
		indent = 0
		lineStart = true
		lineCount = 0
		linePos = 0
		hasTrailingComment = false
	}

	rawWrite := func(s string) {
		if s != nil {
			output += s
			updateLineCountAndPosFor(s)
			hasTrailingComment = false
		}
	}

	writeLiteral := func(s string) {
		if s && s.length {
			write(s)
		}
	}

	writeLine := func(force bool) {
		if !lineStart || force {
			output += newLine
			lineCount++
			linePos = output.length
			lineStart = true
			hasTrailingComment = false
		}
	}

	reset()

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"write":        write,
		"rawWrite":     rawWrite,
		"writeLiteral": writeLiteral,
		"writeLine":    writeLine,
		"increaseIndent": func() {
			indent++
		},
		"decreaseIndent": func() {
			indent--
		},
		"getIndent": func() number {
			return indent
		},
		"getTextPos": func() number {
			return output.length
		},
		"getLine": func() number {
			return lineCount
		},
		"getColumn": func() number {
			if lineStart {
				return indent * getIndentSize()
			} else {
				return output.length - linePos
			}
		},
		"getText": func() string {
			return output
		},
		"isAtStartOfLine": func() bool {
			return lineStart
		},
		"hasTrailingComment": func() bool {
			return hasTrailingComment
		},
		"hasTrailingWhitespace": func() bool {
			return !!output.length && isWhiteSpaceLike(output.charCodeAt(output.length-1))
		},
		"clear":              reset,
		"writeKeyword":       write,
		"writeOperator":      write,
		"writeParameter":     write,
		"writeProperty":      write,
		"writePunctuation":   write,
		"writeSpace":         write,
		"writeStringLiteral": write,
		"writeSymbol": func(s string, _ Symbol) {
			return write(s)
		},
		"writeTrailingSemicolon": write,
		"writeComment":           writeComment,
	}
}

/** @internal */

func getTrailingSemicolonDeferringWriter(writer EmitTextWriter) EmitTextWriter {
	pendingTrailingSemicolon := false

	commitPendingTrailingSemicolon := func() {
		if pendingTrailingSemicolon {
			writer.writeTrailingSemicolon(";")
			pendingTrailingSemicolon = false
		}
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		/* TODO(TS-TO-GO) Node SpreadAssignment: ...writer */
		"writeTrailingSemicolon": func() {
			pendingTrailingSemicolon = true
		},
		"writeLiteral": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeLiteral(s)
		},
		"writeStringLiteral": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeStringLiteral(s)
		},
		"writeSymbol": func(s string, sym Symbol) {
			commitPendingTrailingSemicolon()
			writer.writeSymbol(s, sym)
		},
		"writePunctuation": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writePunctuation(s)
		},
		"writeKeyword": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeKeyword(s)
		},
		"writeOperator": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeOperator(s)
		},
		"writeParameter": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeParameter(s)
		},
		"writeSpace": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeSpace(s)
		},
		"writeProperty": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeProperty(s)
		},
		"writeComment": func(s string) {
			commitPendingTrailingSemicolon()
			writer.writeComment(s)
		},
		"writeLine": func() {
			commitPendingTrailingSemicolon()
			writer.writeLine()
		},
		"increaseIndent": func() {
			commitPendingTrailingSemicolon()
			writer.increaseIndent()
		},
		"decreaseIndent": func() {
			commitPendingTrailingSemicolon()
			writer.decreaseIndent()
		},
	}
}

/** @internal */

func hostUsesCaseSensitiveFileNames(host /* TODO(TS-TO-GO) TypeNode TypeLiteral: { useCaseSensitiveFileNames?(): boolean; } */ any) bool {
	if host.useCaseSensitiveFileNames {
		return host.useCaseSensitiveFileNames()
	} else {
		return false
	}
}

/** @internal */

func hostGetCanonicalFileName(host /* TODO(TS-TO-GO) TypeNode TypeLiteral: { useCaseSensitiveFileNames?(): boolean; } */ any) GetCanonicalFileName {
	return createGetCanonicalFileName(hostUsesCaseSensitiveFileNames(host))
}

/** @internal */

type ResolveModuleNameResolutionHost struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ResolveModuleNameResolutionHost { getCanonicalFileName(p: string): string; getCommonSourceDirectory(): string; getCurrentDirectory(): string; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ResolveModuleNameResolutionHost { getCanonicalFileName(p: string): string; getCommonSourceDirectory(): string; getCurrentDirectory(): string; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ResolveModuleNameResolutionHost { getCanonicalFileName(p: string): string; getCommonSourceDirectory(): string; getCurrentDirectory(): string; } */
}

/** @internal */

func getResolvedExternalModuleName(host ResolveModuleNameResolutionHost, file SourceFile, referenceFile SourceFile) string {
	return file.moduleName || getExternalModuleNameFromPath(host, file.fileName, referenceFile && referenceFile.fileName)
}

func getCanonicalAbsolutePath(host ResolveModuleNameResolutionHost, path string) string {
	return host.getCanonicalFileName(getNormalizedAbsolutePath(path, host.getCurrentDirectory()))
}

/** @internal */

func getExternalModuleNameFromDeclaration(host ResolveModuleNameResolutionHost, resolver EmitResolver, declaration /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ImportDeclaration | ExportDeclaration | ModuleDeclaration | ImportTypeNode */ any) *string {
	file := resolver.getExternalModuleFileFromDeclaration(declaration)
	if !file || file.isDeclarationFile {
		return nil
	}
	// If the declaration already uses a non-relative name, and is outside the common source directory, continue to use it
	specifier := getExternalModuleName(declaration)
	if specifier && isStringLiteralLike(specifier) && !pathIsRelative(specifier.text) && !getCanonicalAbsolutePath(host, file.path).includes(getCanonicalAbsolutePath(host, ensureTrailingDirectorySeparator(host.getCommonSourceDirectory()))) {
		return nil
	}
	return getResolvedExternalModuleName(host, file)
}

/**
 * Resolves a local path to a path which is absolute to the base of the emit
 *
 * @internal
 */

func getExternalModuleNameFromPath(host ResolveModuleNameResolutionHost, fileName string, referencePath string) string {
	getCanonicalFileName := func(f string) string {
		return host.getCanonicalFileName(f)
	}
	dir := toPath(__COND__(referencePath, getDirectoryPath(referencePath), host.getCommonSourceDirectory()), host.getCurrentDirectory(), getCanonicalFileName)
	filePath := getNormalizedAbsolutePath(fileName, host.getCurrentDirectory())
	relativePath := getRelativePathToDirectoryOrUrl(dir, filePath, dir, getCanonicalFileName /*isAbsolutePathAnUrl*/, false)
	extensionless := removeFileExtension(relativePath)
	if referencePath {
		return ensurePathIsNonModuleName(extensionless)
	} else {
		return extensionless
	}
}

/** @internal */

func getOwnEmitOutputFilePath(fileName string, host EmitHost, extension string) string {
	compilerOptions := host.getCompilerOptions()
	var emitOutputFilePathWithoutExtension string
	if compilerOptions.outDir {
		emitOutputFilePathWithoutExtension = removeFileExtension(getSourceFilePathInNewDir(fileName, host, compilerOptions.outDir))
	} else {
		emitOutputFilePathWithoutExtension = removeFileExtension(fileName)
	}

	return emitOutputFilePathWithoutExtension + extension
}

/** @internal */

func getDeclarationEmitOutputFilePath(fileName string, host EmitHost) string {
	return getDeclarationEmitOutputFilePathWorker(fileName, host.getCompilerOptions(), host)
}

/** @internal */

func getDeclarationEmitOutputFilePathWorker(fileName string, options CompilerOptions, host Pick[EmitHost /* TODO(TS-TO-GO) TypeNode UnionType: "getCommonSourceDirectory" | "getCurrentDirectory" | "getCanonicalFileName" */, any]) string {
	outputDir := options.declarationDir || options.outDir
	// Prefer declaration folder if specified

	var path string
	if outputDir {
		path = getSourceFilePathInNewDirWorker(fileName, outputDir, host.getCurrentDirectory(), host.getCommonSourceDirectory(), func(f string) string {
			return host.getCanonicalFileName(f)
		})
	} else {
		path = fileName
	}
	declarationExtension := getDeclarationEmitExtensionForPath(path)
	return removeFileExtension(path) + declarationExtension
}

/** @internal */

func getDeclarationEmitExtensionForPath(path string) /* TODO(TS-TO-GO) TypeNode UnionType: Extension.Dts | Extension.Dmts | Extension.Dcts | ".d.json.ts" */ any {
	switch {
	case fileExtensionIsOneOf(path, []Extension{ExtensionMjs, ExtensionMts}):
		return ExtensionDmts
	case fileExtensionIsOneOf(path, []Extension{ExtensionCjs, ExtensionCts}):
		return ExtensionDcts
	case fileExtensionIsOneOf(path, []Extension{ExtensionJson}):
		return `.d.json.ts`
	default:
		return ExtensionDts
	}
}

/**
 * This function is an inverse of `getDeclarationEmitExtensionForPath`.
 *
 * @internal
 */

func getPossibleOriginalInputExtensionForExtension(path string) []Extension {
	switch {
	case fileExtensionIsOneOf(path, []Extension{ExtensionDmts, ExtensionMjs, ExtensionMts}):
		return [] /* TODO(TS-TO-GO) inferred type Extension.Mjs | Extension.Mts */ any{ExtensionMts, ExtensionMjs}
	case fileExtensionIsOneOf(path, []Extension{ExtensionDcts, ExtensionCjs, ExtensionCts}):
		return [] /* TODO(TS-TO-GO) inferred type Extension.Cjs | Extension.Cts */ any{ExtensionCts, ExtensionCjs}
	case fileExtensionIsOneOf(path, []string{`.d.json.ts`}):
		return [] /* TODO(TS-TO-GO) inferred type Extension.Json */ any{ExtensionJson}
	default:
		return [] /* TODO(TS-TO-GO) inferred type Extension.Ts | Extension.Tsx | Extension.Js | Extension.Jsx */ any{ExtensionTsx, ExtensionTs, ExtensionJsx, ExtensionJs}
	}
}

/**
 * Returns 'undefined' if and only if 'options.paths' is undefined.
 *
 * @internal
 */

func getPathsBasePath(options CompilerOptions, host /* TODO(TS-TO-GO) TypeNode TypeLiteral: { getCurrentDirectory?(): string; } */ any) *string {
	if !options.paths {
		return nil
	}
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: options.baseUrl ?? Debug.checkDefined(options.pathsBasePath || host.getCurrentDirectory?.(), "Encountered 'paths' without a 'baseUrl', config file, or host 'getCurrentDirectory'.") */ TODO
}

/** @internal */

type EmitFileNames struct {
	jsFilePath          *string
	sourceMapFilePath   *string
	declarationFilePath *string
	declarationMapPath  *string
	buildInfoPath       *string
}

/**
 * Gets the source files that are expected to have an emit output.
 *
 * Originally part of `forEachExpectedEmitFile`, this functionality was extracted to support
 * transformations.
 *
 * @param host An EmitHost.
 * @param targetSourceFile An optional target source file to emit.
 *
 * @internal
 */

func getSourceFilesToEmit(host EmitHost, targetSourceFile SourceFile, forceDtsEmit bool) []SourceFile {
	options := host.getCompilerOptions()
	if options.outFile {
		moduleKind := getEmitModuleKind(options)
		moduleEmitEnabled := options.emitDeclarationOnly || moduleKind == ModuleKindAMD || moduleKind == ModuleKindSystem
		// Can emit only sources that are not declaration file and are either non module code or module with --module or --target es6 specified
		return filter(host.getSourceFiles(), func(sourceFile SourceFile) bool {
			return (moduleEmitEnabled || !isExternalModule(sourceFile)) && sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit)
		})
	} else {
		var sourceFiles []SourceFile
		if targetSourceFile == nil {
			sourceFiles = host.getSourceFiles()
		} else {
			sourceFiles = []SourceFile{targetSourceFile}
		}
		return filter(sourceFiles, func(sourceFile SourceFile) bool {
			return sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit)
		})
	}
}

/**
 * Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks.
 *
 * @internal
 */

func sourceFileMayBeEmitted(sourceFile SourceFile, host SourceFileMayBeEmittedHost, forceDtsEmit bool) bool {
	options := host.getCompilerOptions()
	// Js files are emitted only if option is enabled
	if options.noEmitForJsFiles && isSourceFileJS(sourceFile) {
		return false
	}
	// Declaration files are not emitted
	if sourceFile.isDeclarationFile {
		return false
	}
	// Source file from node_modules are not emitted
	if host.isSourceFileFromExternalLibrary(sourceFile) {
		return false
	}
	// forcing dts emit => file needs to be emitted
	if forceDtsEmit {
		return true
	}
	// Check other conditions for file emit
	// Source files from referenced projects are not emitted
	if host.isSourceOfProjectReferenceRedirect(sourceFile.fileName) {
		return false
	}
	// Any non json file should be emitted
	if !isJsonSourceFile(sourceFile) {
		return true
	}
	if host.getResolvedProjectReferenceToRedirect(sourceFile.fileName) {
		return false
	}
	// Emit json file if outFile is specified
	if options.outFile {
		return true
	}
	// Json file is not emitted if outDir is not specified
	if !options.outDir {
		return false
	}
	// Otherwise if rootDir or composite config file, we know common sourceDir and can check if file would be emitted in same location
	if options.rootDir || (options.composite && options.configFilePath) {
		commonDir := getNormalizedAbsolutePath(getCommonSourceDirectory(options, func() []never {
			return []never{}
		}, host.getCurrentDirectory(), host.getCanonicalFileName), host.getCurrentDirectory())
		outputPath := getSourceFilePathInNewDirWorker(sourceFile.fileName, options.outDir, host.getCurrentDirectory(), commonDir, host.getCanonicalFileName)
		if comparePaths(sourceFile.fileName, outputPath, host.getCurrentDirectory(), !host.useCaseSensitiveFileNames()) == ComparisonEqualTo {
			return false
		}
	}
	return true
}

/** @internal */

func getSourceFilePathInNewDir(fileName string, host EmitHost, newDirPath string) string {
	return getSourceFilePathInNewDirWorker(fileName, newDirPath, host.getCurrentDirectory(), host.getCommonSourceDirectory(), func(f string) string {
		return host.getCanonicalFileName(f)
	})
}

func getSourceFilePathInNewDirWorker(fileName string, newDirPath string, currentDirectory string, commonSourceDirectory string, getCanonicalFileName GetCanonicalFileName) string {
	sourceFilePath := getNormalizedAbsolutePath(fileName, currentDirectory)
	isSourceFileInCommonSourceDirectory := getCanonicalFileName(sourceFilePath).indexOf(getCanonicalFileName(commonSourceDirectory)) == 0
	if isSourceFileInCommonSourceDirectory {
		sourceFilePath = sourceFilePath.substring(commonSourceDirectory.length)
	} else {
		sourceFilePath = sourceFilePath
	}
	return combinePaths(newDirPath, sourceFilePath)
}

/** @internal */

func writeFile(host /* TODO(TS-TO-GO) TypeNode TypeLiteral: { writeFile: WriteFileCallback; } */ any, diagnostics DiagnosticCollection, fileName string, text string, writeByteOrderMark bool, sourceFiles []SourceFile, data WriteFileCallbackData) {
	host.writeFile(fileName, text, writeByteOrderMark, func(hostErrorMessage string) {
		diagnostics.add(createCompilerDiagnostic(Diagnostics.Could_not_write_file_0_Colon_1, fileName, hostErrorMessage))
	}, sourceFiles, data)
}

func ensureDirectoriesExist(directoryPath string, createDirectory func(path string), directoryExists func(path string) bool) {
	if directoryPath.length > getRootLength(directoryPath) && !directoryExists(directoryPath) {
		parentDirectory := getDirectoryPath(directoryPath)
		ensureDirectoriesExist(parentDirectory, createDirectory, directoryExists)
		createDirectory(directoryPath)
	}
}

/** @internal */

func writeFileEnsuringDirectories(path string, data string, writeByteOrderMark bool, writeFile func(path string, data string, writeByteOrderMark bool), createDirectory func(path string), directoryExists func(path string) bool) {
	// PERF: Checking for directory existence is expensive.  Instead, assume the directory exists
	// and fall back to creating it if the file write fails.
	{ // try
		writeFile(path, data, writeByteOrderMark)
	}
	{ // catch
		ensureDirectoriesExist(getDirectoryPath(normalizePath(path)), createDirectory, directoryExists)
		writeFile(path, data, writeByteOrderMark)
	}
}

/** @internal */

func getLineOfLocalPosition(sourceFile SourceFile, pos number) number {
	lineStarts := getLineStarts(sourceFile)
	return computeLineOfPosition(lineStarts, pos)
}

func getLineOfLocalPositionFromLineMap(lineMap []number, pos number) number {
	return computeLineOfPosition(lineMap, pos)
}

/** @internal */

func getFirstConstructorWithBody(node ClassLikeDeclaration) * /* TODO(TS-TO-GO) TypeNode IntersectionType: ConstructorDeclaration & { body: FunctionBody; } */ any {
	return find(node.members, func(member ClassElement) /* TODO(TS-TO-GO) TypeNode TypePredicate: member is ConstructorDeclaration & { body: FunctionBody; } */ any {
		return isConstructorDeclaration(member) && nodeIsPresent(member.body)
	})
}

/** @internal */

func getSetAccessorValueParameter(accessor SetAccessorDeclaration) *ParameterDeclaration {
	if accessor && accessor.parameters.length > 0 {
		hasThis := accessor.parameters.length == 2 && parameterIsThisKeyword(accessor.parameters[0])
		return accessor.parameters[__COND__(hasThis, 1, 0)]
	}
}

/**
 * Get the type annotation for the value parameter.
 *
 * @internal
 */

func getSetAccessorTypeAnnotationNode(accessor SetAccessorDeclaration) *TypeNode {
	parameter := getSetAccessorValueParameter(accessor)
	return parameter && parameter.type_
}

/** @internal */

func getThisParameter(signature /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) *ParameterDeclaration {
	// callback tags do not currently support this parameters
	if signature.parameters.length && !isJSDocSignature(signature) {
		thisParameter := signature.parameters[0]
		if parameterIsThisKeyword(thisParameter) {
			return thisParameter
		}
	}
}

/** @internal */

func parameterIsThisKeyword(parameter ParameterDeclaration) bool {
	return isThisIdentifier(parameter.name)
}

/** @internal */

func isThisIdentifier(node Node) bool {
	return !!node && node.kind == SyntaxKindIdentifier && identifierIsThisKeyword(node /* as Identifier */)
}

/** @internal */

func isInTypeQuery(node Node) bool {
	// TypeScript 1.0 spec (April 2014): 3.6.3
	// A type query consists of the keyword typeof followed by an expression.
	// The expression is restricted to a single identifier or a sequence of identifiers separated by periods
	return !!findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		switch {
		case n.kind == SyntaxKindTypeQuery:
			return true
		case n.kind == SyntaxKindIdentifier || n.kind == SyntaxKindQualifiedName:
			return false
		default:
			return "quit"
		}
	})
}

/** @internal */

func isThisInTypeQuery(node Node) bool {
	if !isThisIdentifier(node) {
		return false
	}

	for isQualifiedName(node.parent) && node.parent.left == node {
		node = node.parent
	}

	return node.parent.kind == SyntaxKindTypeQuery
}

/** @internal */

func identifierIsThisKeyword(id Identifier) bool {
	return id.escapedText == "this"
}

/** @internal */

func getAllAccessorDeclarations(declarations *[]Declaration, accessor AccessorDeclaration) AllAccessorDeclarations {
	// TODO: GH#18217
	var firstAccessor AccessorDeclaration
	var secondAccessor AccessorDeclaration
	var getAccessor GetAccessorDeclaration
	var setAccessor SetAccessorDeclaration
	if hasDynamicName(accessor) {
		firstAccessor = accessor
		if accessor.kind == SyntaxKindGetAccessor {
			getAccessor = accessor
		} else if accessor.kind == SyntaxKindSetAccessor {
			setAccessor = accessor
		} else {
			Debug.fail("Accessor has wrong kind")
		}
	} else {
		forEach(declarations, func(member Declaration) {
			if isAccessor(member) && isStatic(member) == isStatic(accessor) {
				memberName := getPropertyNameForPropertyNameNode(member.name)
				accessorName := getPropertyNameForPropertyNameNode(accessor.name)
				if memberName == accessorName {
					if !firstAccessor {
						firstAccessor = member
					} else if !secondAccessor {
						secondAccessor = member
					}

					if member.kind == SyntaxKindGetAccessor && !getAccessor {
						getAccessor = member
					}

					if member.kind == SyntaxKindSetAccessor && !setAccessor {
						setAccessor = member
					}
				}
			}
		})
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"firstAccessor":  firstAccessor,
		"secondAccessor": secondAccessor,
		"getAccessor":    getAccessor,
		"setAccessor":    setAccessor,
	}
}

/**
 * Gets the effective type annotation of a variable, parameter, or property. If the node was
 * parsed in a JavaScript file, gets the type annotation from JSDoc.  Also gets the type of
 * functions only the JSDoc case.
 *
 * @internal
 */

func getEffectiveTypeAnnotationNode(node Node) *TypeNode {
	if !isInJSFile(node) && isFunctionDeclaration(node) {
		return nil
	}
	if isTypeAliasDeclaration(node) {
		return nil
		// has a .type, is not a type annotation
	}
	// has a .type, is not a type annotation
	type_ := (node /* as HasType */).type_
	if type_ || !isInJSFile(node) {
		return type_
	}
	if isJSDocPropertyLikeTag(node) {
		return node.typeExpression && node.typeExpression.type_
	} else {
		return getJSDocType(node)
	}
}

/** @internal */

func getTypeAnnotationNode(node Node) *TypeNode {
	return (node /* as HasType */).type_
}

/**
 * Gets the effective return type annotation of a signature. If the node was parsed in a
 * JavaScript file, gets the return type annotation from JSDoc.
 *
 * @internal
 */

func getEffectiveReturnTypeNode(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) *TypeNode {
	if isJSDocSignature(node) {
		return node.type_ && node.type_.typeExpression && node.type_.typeExpression.type_
	} else {
		return node.type_ || (__COND__(isInJSFile(node), getJSDocReturnType(node), nil))
	}
}

/** @internal */

func getJSDocTypeParameterDeclarations(node DeclarationWithTypeParameters) []TypeParameterDeclaration {
	return flatMap(getJSDocTags(node), func(tag JSDocTag) *NodeArray[TypeParameterDeclaration] {
		if isNonTypeAliasTemplate(tag) {
			return tag.typeParameters
		} else {
			return nil
		}
	})
}

/** template tags are only available when a typedef isn't already using them */

func isNonTypeAliasTemplate(tag JSDocTag) /* TODO(TS-TO-GO) TypeNode TypePredicate: tag is JSDocTemplateTag */ any {
	return isJSDocTemplateTag(tag) && !(tag.parent.kind == SyntaxKindJSDoc && (tag.parent.tags.some(isJSDocTypeAlias) || tag.parent.tags.some(isJSDocOverloadTag)))
}

/**
 * Gets the effective type annotation of the value parameter of a set accessor. If the node
 * was parsed in a JavaScript file, gets the type annotation from JSDoc.
 *
 * @internal
 */

func getEffectiveSetAccessorTypeAnnotationNode(node SetAccessorDeclaration) *TypeNode {
	parameter := getSetAccessorValueParameter(node)
	return parameter && getEffectiveTypeAnnotationNode(parameter)
}

func emitNewLineBeforeLeadingComments(lineMap []number, writer EmitTextWriter, node TextRange, leadingComments *[]CommentRange) {
	emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, node.pos, leadingComments)
}

func emitNewLineBeforeLeadingCommentsOfPosition(lineMap []number, writer EmitTextWriter, pos number, leadingComments *[]CommentRange) {
	// If the leading comments start on different line than the start of node, write new line
	if leadingComments && leadingComments.length && pos != leadingComments[0].pos && getLineOfLocalPositionFromLineMap(lineMap, pos) != getLineOfLocalPositionFromLineMap(lineMap, leadingComments[0].pos) {
		writer.writeLine()
	}
}

/** @internal */

func emitNewLineBeforeLeadingCommentOfPosition(lineMap []number, writer EmitTextWriter, pos number, commentPos number) {
	// If the leading comments start on different line than the start of node, write new line
	if pos != commentPos && getLineOfLocalPositionFromLineMap(lineMap, pos) != getLineOfLocalPositionFromLineMap(lineMap, commentPos) {
		writer.writeLine()
	}
}

func emitComments(text string, lineMap []number, writer EmitTextWriter, comments *[]CommentRange, leadingSeparator bool, trailingSeparator bool, newLine string, writeComment func(text string, lineMap []number, writer EmitTextWriter, commentPos number, commentEnd number, newLine string)) {
	if comments && comments.length > 0 {
		if leadingSeparator {
			writer.writeSpace(" ")
		}

		emitInterveningSeparator := false
		for _, comment := range comments {
			if emitInterveningSeparator {
				writer.writeSpace(" ")
				emitInterveningSeparator = false
			}

			writeComment(text, lineMap, writer, comment.pos, comment.end, newLine)
			if comment.hasTrailingNewLine {
				writer.writeLine()
			} else {
				emitInterveningSeparator = true
			}
		}

		if emitInterveningSeparator && trailingSeparator {
			writer.writeSpace(" ")
		}
	}
}

/** @internal */

type DetachedCommentInfo struct {
	nodePos               number
	detachedCommentEndPos number
}

/**
 * Detached comment is a comment at the top of file or function body that is separated from
 * the next statement by space.
 *
 * @internal
 */

func emitDetachedComments(text string, lineMap []number, writer EmitTextWriter, writeComment func(text string, lineMap []number, writer EmitTextWriter, commentPos number, commentEnd number, newLine string), node TextRange, newLine string, removeComments bool) *DetachedCommentInfo {
	var leadingComments *[]CommentRange
	var currentDetachedCommentInfo * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { nodePos: number; detachedCommentEndPos: number; } */ any
	if removeComments {
		// removeComments is true, only reserve pinned comment at the top of file
		// For example:
		//      /*! Pinned Comment */
		//
		//      var x = 10;
		if node.pos == 0 {
			leadingComments = filter(getLeadingCommentRanges(text, node.pos), isPinnedCommentLocal)
		}
	} else {
		// removeComments is false, just get detached as normal and bypass the process to filter comment
		leadingComments = getLeadingCommentRanges(text, node.pos)
	}

	if leadingComments {
		var detachedComments []CommentRange = []never{}
		var lastComment *CommentRange

		for _, comment := range leadingComments {
			if lastComment {
				lastCommentLine := getLineOfLocalPositionFromLineMap(lineMap, lastComment.end)
				commentLine := getLineOfLocalPositionFromLineMap(lineMap, comment.pos)

				if commentLine >= lastCommentLine+2 {
					// There was a blank line between the last comment and this comment.  This
					// comment is not part of the copyright comments.  Return what we have so
					// far.
					break
				}
			}

			detachedComments.push(comment)
			lastComment = comment
		}

		if detachedComments.length {
			// All comments look like they could have been part of the copyright header.  Make
			// sure there is at least one blank line between it and the node.  If not, it's not
			// a copyright header.
			lastCommentLine := getLineOfLocalPositionFromLineMap(lineMap, last(detachedComments).end)
			nodeLine := getLineOfLocalPositionFromLineMap(lineMap, skipTrivia(text, node.pos))
			if nodeLine >= lastCommentLine+2 {
				// Valid detachedComments
				emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments)
				emitComments(text, lineMap, writer, detachedComments /*leadingSeparator*/, false /*trailingSeparator*/, true, newLine, writeComment)
				currentDetachedCommentInfo = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"nodePos":               node.pos,
					"detachedCommentEndPos": last(detachedComments).end,
				}
			}
		}
	}

	return currentDetachedCommentInfo

	isPinnedCommentLocal := func(comment CommentRange) bool {
		return isPinnedComment(text, comment.pos)
	}

}

/** @internal */

func writeCommentRange(text string, lineMap []number, writer EmitTextWriter, commentPos number, commentEnd number, newLine string) {
	if text.charCodeAt(commentPos+1) == CharacterCodesasterisk {
		firstCommentLineAndCharacter := computeLineAndCharacterOfPosition(lineMap, commentPos)
		lineCount := lineMap.length
		var firstCommentLineIndent *number
		for ; /* TODO(TS-TO-GO) Node VariableDeclarationList: let pos = commentPos, currentLine = firstCommentLineAndCharacter.line */ pos < commentEnd; currentLine++ {
			var nextLineStart number
			if (currentLine + 1) == lineCount {
				nextLineStart = text.length + 1
			} else {
				nextLineStart = lineMap[currentLine+1]
			}

			if pos != commentPos {
				// If we are not emitting first line, we need to write the spaces to adjust the alignment
				if firstCommentLineIndent == nil {
					firstCommentLineIndent = calculateIndent(text, lineMap[firstCommentLineAndCharacter.line], commentPos)
				}

				// These are number of spaces writer is going to write at current indent
				currentWriterIndentSpacing := writer.getIndent() * getIndentSize()

				// Number of spaces we want to be writing
				// eg: Assume writer indent
				// module m {
				//         /* starts at character 9 this is line 1
				//    * starts at character pos 4 line                        --1  = 8 - 8 + 3
				//   More left indented comment */                            --2  = 8 - 8 + 2
				//     class c { }
				// }
				// module m {
				//     /* this is line 1 -- Assume current writer indent 8
				//      * line                                                --3 = 8 - 4 + 5
				//            More right indented comment */                  --4 = 8 - 4 + 11
				//     class c { }
				// }
				spacesToEmit := currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(text, pos, nextLineStart)
				if spacesToEmit > 0 {
					numberOfSingleSpacesToEmit := spacesToEmit % getIndentSize()
					indentSizeSpaceString := getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize())

					// Write indent size string ( in eg 1: = "", 2: "" , 3: string with 8 spaces 4: string with 12 spaces
					writer.rawWrite(indentSizeSpaceString)

					// Emit the single spaces (in eg: 1: 3 spaces, 2: 2 spaces, 3: 1 space, 4: 3 spaces)
					for numberOfSingleSpacesToEmit {
						writer.rawWrite(" ")
						numberOfSingleSpacesToEmit--
					}
				} else {
					// No spaces to emit write empty string
					writer.rawWrite("")
				}
			}

			// Write the comment line text
			writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart)

			pos = nextLineStart
		}
	} else {
		// Single line comment of style //....
		writer.writeComment(text.substring(commentPos, commentEnd))
	}
}

func writeTrimmedCurrentLine(text string, commentEnd number, writer EmitTextWriter, newLine string, pos number, nextLineStart number) {
	end := Math.min(commentEnd, nextLineStart-1)
	currentLineText := text.substring(pos, end).trim()
	if currentLineText {
		// trimmed forward and ending spaces text
		writer.writeComment(currentLineText)
		if end != commentEnd {
			writer.writeLine()
		}
	} else {
		// Empty string - make sure we write empty line
		writer.rawWrite(newLine)
	}
}

func calculateIndent(text string, pos number, end number) number {
	currentLineIndent := 0
	for ; pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos)); pos++ {
		if text.charCodeAt(pos) == CharacterCodestab {
			// Tabs = TabSize = indent size and go to next tabStop
			currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize())
		} else {
			// Single space
			currentLineIndent++
		}
	}

	return currentLineIndent
}

/** @internal */

func hasEffectiveModifiers(node Node) bool {
	return getEffectiveModifierFlags(node) != ModifierFlagsNone
}

/** @internal */

func hasSyntacticModifiers(node Node) bool {
	return getSyntacticModifierFlags(node) != ModifierFlagsNone
}

/** @internal */

func hasEffectiveModifier(node Node, flags ModifierFlags) bool {
	return !!getSelectedEffectiveModifierFlags(node, flags)
}

/** @internal */

func hasSyntacticModifier(node Node, flags ModifierFlags) bool {
	return !!getSelectedSyntacticModifierFlags(node, flags)
}

/** @internal */

func isStatic(node Node) bool {
	// https://tc39.es/ecma262/#sec-static-semantics-isstatic
	return isClassElement(node) && hasStaticModifier(node) || isClassStaticBlockDeclaration(node)
}

/** @internal */

func hasStaticModifier(node Node) bool {
	return hasSyntacticModifier(node, ModifierFlagsStatic)
}

/** @internal */

func hasOverrideModifier(node Node) bool {
	return hasEffectiveModifier(node, ModifierFlagsOverride)
}

/** @internal */

func hasAbstractModifier(node Node) bool {
	return hasSyntacticModifier(node, ModifierFlagsAbstract)
}

/** @internal */

func hasAmbientModifier(node Node) bool {
	return hasSyntacticModifier(node, ModifierFlagsAmbient)
}

/** @internal */

func hasAccessorModifier(node Node) bool {
	return hasSyntacticModifier(node, ModifierFlagsAccessor)
}

/** @internal */

func hasEffectiveReadonlyModifier(node Node) bool {
	return hasEffectiveModifier(node, ModifierFlagsReadonly)
}

/** @internal */

func hasDecorators(node Node) bool {
	return hasSyntacticModifier(node, ModifierFlagsDecorator)
}

/** @internal */

func getSelectedEffectiveModifierFlags(node Node, flags ModifierFlags) ModifierFlags {
	return getEffectiveModifierFlags(node) & flags
}

/** @internal @knipignore */

func getSelectedSyntacticModifierFlags(node Node, flags ModifierFlags) ModifierFlags {
	return getSyntacticModifierFlags(node) & flags
}

func getModifierFlagsWorker(node Node, includeJSDoc bool, alwaysIncludeJSDoc bool) ModifierFlags {
	if node.kind >= SyntaxKindFirstToken && node.kind <= SyntaxKindLastToken {
		return ModifierFlagsNone
	}

	if !(node.modifierFlagsCache & ModifierFlagsHasComputedFlags) {
		node.modifierFlagsCache = getSyntacticModifierFlagsNoCache(node) | ModifierFlagsHasComputedFlags
	}

	if alwaysIncludeJSDoc || includeJSDoc && isInJSFile(node) {
		if !(node.modifierFlagsCache & ModifierFlagsHasComputedJSDocModifiers) && node.parent {
			node.modifierFlagsCache |= getRawJSDocModifierFlagsNoCache(node) | ModifierFlagsHasComputedJSDocModifiers
		}
		return selectEffectiveModifierFlags(node.modifierFlagsCache)
	}

	return selectSyntacticModifierFlags(node.modifierFlagsCache)
}

/**
 * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifiers will be cached on the node to improve performance.
 *
 * NOTE: This function may use `parent` pointers.
 *
 * @internal
 */

func getEffectiveModifierFlags(node Node) ModifierFlags {
	return getModifierFlagsWorker(node /*includeJSDoc*/, true)
}

/** @internal */

func getEffectiveModifierFlagsAlwaysIncludeJSDoc(node Node) ModifierFlags {
	return getModifierFlagsWorker(node /*includeJSDoc*/, true /*alwaysIncludeJSDoc*/, true)
}

/**
 * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifiers will be cached on the node to improve performance.
 *
 * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
 *
 * @internal
 */

func getSyntacticModifierFlags(node Node) ModifierFlags {
	return getModifierFlagsWorker(node /*includeJSDoc*/, false)
}

func getRawJSDocModifierFlagsNoCache(node Node) ModifierFlags {
	flags := ModifierFlagsNone
	if !!node.parent && !isParameter(node) {
		if isInJSFile(node) {
			if getJSDocPublicTagNoCache(node) {
				flags |= ModifierFlagsJSDocPublic
			}
			if getJSDocPrivateTagNoCache(node) {
				flags |= ModifierFlagsJSDocPrivate
			}
			if getJSDocProtectedTagNoCache(node) {
				flags |= ModifierFlagsJSDocProtected
			}
			if getJSDocReadonlyTagNoCache(node) {
				flags |= ModifierFlagsJSDocReadonly
			}
			if getJSDocOverrideTagNoCache(node) {
				flags |= ModifierFlagsJSDocOverride
			}
		}
		if getJSDocDeprecatedTagNoCache(node) {
			flags |= ModifierFlagsDeprecated
		}
	}

	return flags
}

func selectSyntacticModifierFlags(flags ModifierFlags) number {
	return flags & ModifierFlagsSyntacticModifiers
}

func selectEffectiveModifierFlags(flags ModifierFlags) number {
	return (flags & ModifierFlagsNonCacheOnlyModifiers) | ( /* TODO(TS-TO-GO) GreaterThanGreaterThanGreaterThanToken BinaryExpression: (flags & ModifierFlags.JSDocCacheOnlyModifiers) >>> 23 */ TODO)
	// shift ModifierFlags.JSDoc* to match ModifierFlags.*
}

func getJSDocModifierFlagsNoCache(node Node) ModifierFlags {
	return selectEffectiveModifierFlags(getRawJSDocModifierFlagsNoCache(node))
}

/**
 * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifier flags cache on the node is ignored.
 *
 * NOTE: This function may use `parent` pointers.
 *
 * @internal
 */

func getEffectiveModifierFlagsNoCache(node Node) ModifierFlags {
	return getSyntacticModifierFlagsNoCache(node) | getJSDocModifierFlagsNoCache(node)
}

/**
 * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifier flags cache on the node is ignored.
 *
 * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
 *
 * @internal
 * @knipignore
 */

func getSyntacticModifierFlagsNoCache(node Node) ModifierFlags {
	var flags ModifierFlags
	if canHaveModifiers(node) {
		flags = modifiersToFlags(node.modifiers)
	} else {
		flags = ModifierFlagsNone
	}
	if node.flags&NodeFlagsNestedNamespace || node.kind == SyntaxKindIdentifier && node.flags&NodeFlagsIdentifierIsInJSDocNamespace {
		flags |= ModifierFlagsExport
	}
	return flags
}

/** @internal */

func modifiersToFlags(modifiers *[]ModifierLike) ModifierFlags {
	flags := ModifierFlagsNone
	if modifiers {
		for _, modifier := range modifiers {
			flags |= modifierToFlag(modifier.kind)
		}
	}
	return flags
}

/** @internal */

func modifierToFlag(token SyntaxKind) ModifierFlags {
	switch token {
	case SyntaxKindStaticKeyword:
		return ModifierFlagsStatic
	case SyntaxKindPublicKeyword:
		return ModifierFlagsPublic
	case SyntaxKindProtectedKeyword:
		return ModifierFlagsProtected
	case SyntaxKindPrivateKeyword:
		return ModifierFlagsPrivate
	case SyntaxKindAbstractKeyword:
		return ModifierFlagsAbstract
	case SyntaxKindAccessorKeyword:
		return ModifierFlagsAccessor
	case SyntaxKindExportKeyword:
		return ModifierFlagsExport
	case SyntaxKindDeclareKeyword:
		return ModifierFlagsAmbient
	case SyntaxKindConstKeyword:
		return ModifierFlagsConst
	case SyntaxKindDefaultKeyword:
		return ModifierFlagsDefault
	case SyntaxKindAsyncKeyword:
		return ModifierFlagsAsync
	case SyntaxKindReadonlyKeyword:
		return ModifierFlagsReadonly
	case SyntaxKindOverrideKeyword:
		return ModifierFlagsOverride
	case SyntaxKindInKeyword:
		return ModifierFlagsIn
	case SyntaxKindOutKeyword:
		return ModifierFlagsOut
	case SyntaxKindDecorator:
		return ModifierFlagsDecorator
	}
	return ModifierFlagsNone
}

/** @internal */

func isBinaryLogicalOperator(token SyntaxKind) bool {
	return token == SyntaxKindBarBarToken || token == SyntaxKindAmpersandAmpersandToken
}

/** @internal */

func isLogicalOperator(token SyntaxKind) bool {
	return isBinaryLogicalOperator(token) || token == SyntaxKindExclamationToken
}

/** @internal */

func isLogicalOrCoalescingAssignmentOperator(token SyntaxKind) /* TODO(TS-TO-GO) TypeNode TypePredicate: token is LogicalOrCoalescingAssignmentOperator */ any {
	return token == SyntaxKindBarBarEqualsToken || token == SyntaxKindAmpersandAmpersandEqualsToken || token == SyntaxKindQuestionQuestionEqualsToken
}

/** @internal */

func isLogicalOrCoalescingAssignmentExpression(expr Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: expr is AssignmentExpression<Token<LogicalOrCoalescingAssignmentOperator>> */ any {
	return isBinaryExpression(expr) && isLogicalOrCoalescingAssignmentOperator(expr.operatorToken.kind)
}

/** @internal */

func isLogicalOrCoalescingBinaryOperator(token SyntaxKind) /* TODO(TS-TO-GO) TypeNode TypePredicate: token is LogicalOperator | SyntaxKind.QuestionQuestionToken */ any {
	return isBinaryLogicalOperator(token) || token == SyntaxKindQuestionQuestionToken
}

/** @internal */

func isLogicalOrCoalescingBinaryExpression(expr Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: expr is BinaryExpression */ any {
	return isBinaryExpression(expr) && isLogicalOrCoalescingBinaryOperator(expr.operatorToken.kind)
}

/** @internal */

func isAssignmentOperator(token SyntaxKind) bool {
	return token >= SyntaxKindFirstAssignment && token <= SyntaxKindLastAssignment
}

/**
 * Get `C` given `N` if `N` is in the position `class C extends N` where `N` is an ExpressionWithTypeArguments.
 *
 * @internal
 */

func tryGetClassExtendingExpressionWithTypeArguments(node Node) *ClassLikeDeclaration {
	cls := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
	if cls && !cls.isImplements {
		return cls.class
	} else {
		return nil
	}
}

/** @internal */

type ClassImplementingOrExtendingExpressionWithTypeArguments struct {
	class        ClassLikeDeclaration
	isImplements bool
}

/** @internal */

func tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node Node) *ClassImplementingOrExtendingExpressionWithTypeArguments {
	if isExpressionWithTypeArguments(node) {
		if isHeritageClause(node.parent) && isClassLike(node.parent.parent) {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"class":        node.parent.parent,
				"isImplements": node.parent.token == SyntaxKindImplementsKeyword,
			}
		}
		if isJSDocAugmentsTag(node.parent) {
			host := getEffectiveJSDocHost(node.parent)
			if host && isClassLike(host) {
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"class":        host,
					"isImplements": false,
				}
			}
		}
	}
	return nil
}

/** @internal */

/* OVERLOAD: export function isAssignmentExpression(node: Node, excludeCompoundAssignment: true): node is AssignmentExpression<EqualsToken>; */
/** @internal */

/* OVERLOAD: export function isAssignmentExpression(node: Node, excludeCompoundAssignment?: false): node is AssignmentExpression<AssignmentOperatorToken>; */
/** @internal */

func isAssignmentExpression(node Node, excludeCompoundAssignment bool) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AssignmentExpression<AssignmentOperatorToken> */ any {
	return isBinaryExpression(node) && (__COND__(excludeCompoundAssignment, node.operatorToken.kind == SyntaxKindEqualsToken, isAssignmentOperator(node.operatorToken.kind))) && isLeftHandSideExpression(node.left)
}

/** @internal */

func isDestructuringAssignment(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is DestructuringAssignment */ any {
	if isAssignmentExpression(node /*excludeCompoundAssignment*/, true) {
		kind := node.left.kind
		return kind == SyntaxKindObjectLiteralExpression || kind == SyntaxKindArrayLiteralExpression
	}

	return false
}

/** @internal */

func isExpressionWithTypeArgumentsInClassExtendsClause(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ExpressionWithTypeArguments */ any {
	return tryGetClassExtendingExpressionWithTypeArguments(node) != nil
}

/** @internal */

func isEntityNameExpression(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is EntityNameExpression */ any {
	return node.kind == SyntaxKindIdentifier || isPropertyAccessEntityNameExpression(node)
}

/** @internal */

func getFirstIdentifier(node EntityNameOrEntityNameExpression) Identifier {
	switch node.kind {
	case SyntaxKindIdentifier:
		return node
	case SyntaxKindQualifiedName:
		for ok := true; ok; ok = node.kind != SyntaxKindIdentifier { // do-while loop
			node = node.left
		}
		return node
	case SyntaxKindPropertyAccessExpression:
		for ok := true; ok; ok = node.kind != SyntaxKindIdentifier { // do-while loop
			node = node.expression
		}
		return node
	}
}

/** @internal */

func isDottedName(node Expression) bool {
	return node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindThisKeyword || node.kind == SyntaxKindSuperKeyword || node.kind == SyntaxKindMetaProperty || node.kind == SyntaxKindPropertyAccessExpression && isDottedName((node /* as PropertyAccessExpression */).expression) || node.kind == SyntaxKindParenthesizedExpression && isDottedName((node /* as ParenthesizedExpression */).expression)
}

/** @internal */

func isPropertyAccessEntityNameExpression(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is PropertyAccessEntityNameExpression */ any {
	return isPropertyAccessExpression(node) && isIdentifier(node.name) && isEntityNameExpression(node.expression)
}

/** @internal */

func tryGetPropertyAccessOrIdentifierToString(expr /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxTagNameExpression */ any) *string {
	if isPropertyAccessExpression(expr) {
		baseStr := tryGetPropertyAccessOrIdentifierToString(expr.expression)
		if baseStr != nil {
			return baseStr + "." + entityNameToString(expr.name)
		}
	} else if isElementAccessExpression(expr) {
		baseStr := tryGetPropertyAccessOrIdentifierToString(expr.expression)
		if baseStr != nil && isPropertyName(expr.argumentExpression) {
			return baseStr + "." + getPropertyNameForPropertyNameNode(expr.argumentExpression)
		}
	} else if isIdentifier(expr) {
		return unescapeLeadingUnderscores(expr.escapedText)
	} else if isJsxNamespacedName(expr) {
		return getTextOfJsxNamespacedName(expr)
	}
	return nil
}

/** @internal */

func isPrototypeAccess(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is BindableStaticAccessExpression */ any {
	return isBindableStaticAccessExpression(node) && getElementOrPropertyAccessName(node) == "prototype"
}

/** @internal */

func isRightSideOfQualifiedNameOrPropertyAccess(node Node) bool {
	return (node.parent.kind == SyntaxKindQualifiedName && (node.parent /* as QualifiedName */).right == node) || (node.parent.kind == SyntaxKindPropertyAccessExpression && (node.parent /* as PropertyAccessExpression */).name == node) || (node.parent.kind == SyntaxKindMetaProperty && (node.parent /* as MetaProperty */).name == node)
}

/** @internal */

func isRightSideOfAccessExpression(node Node) bool {
	return !!node.parent && (isPropertyAccessExpression(node.parent) && node.parent.name == node || isElementAccessExpression(node.parent) && node.parent.argumentExpression == node)
}

/** @internal */

func isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(node Node) bool {
	return isQualifiedName(node.parent) && node.parent.right == node || isPropertyAccessExpression(node.parent) && node.parent.name == node || isJSDocMemberName(node.parent) && node.parent.right == node
}

/** @internal */

func isInstanceOfExpression(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is InstanceofExpression */ any {
	return isBinaryExpression(node) && node.operatorToken.kind == SyntaxKindInstanceOfKeyword
}

/** @internal */

func isRightSideOfInstanceofExpression(node Node) bool {
	return isInstanceOfExpression(node.parent) && node == node.parent.right
}

/** @internal */

func isEmptyObjectLiteral(expression Node) bool {
	return expression.kind == SyntaxKindObjectLiteralExpression && (expression /* as ObjectLiteralExpression */).properties.length == 0
}

/** @internal */

func isEmptyArrayLiteral(expression Node) bool {
	return expression.kind == SyntaxKindArrayLiteralExpression && (expression /* as ArrayLiteralExpression */).elements.length == 0
}

/** @internal */

func getLocalSymbolForExportDefault(symbol Symbol) Symbol {
	if !isExportDefaultSymbol(symbol) || !symbol.declarations {
		return nil
	}
	for _, decl := range symbol.declarations {
		if decl.localSymbol {
			return decl.localSymbol
		}
	}
	return nil
}

func isExportDefaultSymbol(symbol Symbol) bool {
	return symbol && length(symbol.declarations) > 0 && hasSyntacticModifier(symbol.declarations[0], ModifierFlagsDefault)
}

/**
 * Return ".ts", ".d.ts", or ".tsx", if that is the extension.
 *
 * @internal
 */

func tryExtractTSExtension(fileName string) *string {
	return find(supportedTSExtensionsForExtractExtension, func(extension Extension) bool {
		return fileExtensionIs(fileName, extension)
	})
}

/**
 * Replace each instance of non-ascii characters by one, two, three, or four escape sequences
 * representing the UTF-8 encoding of the character, and return the expanded char code list.
 */

func getExpandedCharCodes(input string) []number {
	var output []number = []never{}
	length := input.length

	for i := 0; i < length; i++ {
		charCode := input.charCodeAt(i)

		// handle utf8
		if charCode < 0x80 {
			output.push(charCode)
		} else if charCode < 0x800 {
			output.push(( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCode >> 6 */ TODO) | 0b11000000)
			output.push((charCode & 0b00111111) | 0b10000000)
		} else if charCode < 0x10000 {
			output.push(( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCode >> 12 */ TODO) | 0b11100000)
			output.push((( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCode >> 6 */ TODO) & 0b00111111) | 0b10000000)
			output.push((charCode & 0b00111111) | 0b10000000)
		} else if charCode < 0x20000 {
			output.push(( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCode >> 18 */ TODO) | 0b11110000)
			output.push((( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCode >> 12 */ TODO) & 0b00111111) | 0b10000000)
			output.push((( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCode >> 6 */ TODO) & 0b00111111) | 0b10000000)
			output.push((charCode & 0b00111111) | 0b10000000)
		} else {
			Debug.assert(false, "Unexpected code point")
		}
	}

	return output
}

var base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="

/**
 * Converts a string to a base-64 encoded ASCII string.
 *
 * @internal
 */

func convertToBase64(input string) string {
	result := ""
	charCodes := getExpandedCharCodes(input)
	i := 0
	length := charCodes.length
	var byte1 number
	var byte2 number
	var byte3 number
	var byte4 number

	for i < length {
		// Convert every 6-bits in the input 3 character points
		// into a base64 digit
		byte1 = /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCodes[i] >> 2 */ TODO
		byte2 = /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: (charCodes[i] & 0B00000011) << 4 */ TODO | /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCodes[i + 1] >> 4 */ TODO
		byte3 = /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: (charCodes[i + 1] & 0B00001111) << 2 */ TODO | /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: charCodes[i + 2] >> 6 */ TODO
		byte4 = charCodes[i+2] & 0b00111111

		// We are out of characters in the input, set the extra
		// digits to 64 (padding character).
		if i+1 >= length {
			byte3 = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: byte4 = 64 */ TODO
		} else if i+2 >= length {
			byte4 = 64
		}

		// Write to the output
		result += base64Digits.charAt(byte1) + base64Digits.charAt(byte2) + base64Digits.charAt(byte3) + base64Digits.charAt(byte4)

		i += 3
	}

	return result
}

func getStringFromExpandedCharCodes(codes []number) string {
	output := ""
	i := 0
	length := codes.length
	for i < length {
		charCode := codes[i]

		if charCode < 0x80 {
			output += String.fromCharCode(charCode)
			i++
		} else if (charCode & 0b11000000) == 0b11000000 {
			value := charCode & 0b00111111
			i++
			var nextCode number = codes[i]
			for (nextCode & 0b11000000) == 0b10000000 {
				value = ( /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: value << 6 */ TODO) | (nextCode & 0b00111111)
				i++
				nextCode = codes[i]
			}
			// `value` may be greater than 10FFFF (the maximum unicode codepoint) - JS will just make this into an invalid character for us
			output += String.fromCharCode(value)
		} else {
			// We don't want to kill the process when decoding fails (due to a following char byte not
			// following a leading char), so we just print the (bad) value
			output += String.fromCharCode(charCode)
			i++
		}
	}
	return output
}

/** @internal */

func base64encode(host * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { base64encode?(input: string): string; } */ any, input string) string {
	if host && host.base64encode {
		return host.base64encode(input)
	}
	return convertToBase64(input)
}

/** @internal */

func base64decode(host * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { base64decode?(input: string): string; } */ any, input string) string {
	if host && host.base64decode {
		return host.base64decode(input)
	}
	length := input.length
	var expandedCharCodes []number = []never{}
	i := 0
	for i < length {
		// Stop decoding once padding characters are present
		if input.charCodeAt(i) == base64Digits.charCodeAt(64) {
			break
		}
		// convert 4 input digits into three characters, ignoring padding characters at the end
		ch1 := base64Digits.indexOf(input[i])
		ch2 := base64Digits.indexOf(input[i+1])
		ch3 := base64Digits.indexOf(input[i+2])
		ch4 := base64Digits.indexOf(input[i+3])

		code1 := ( /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: (ch1 & 0B00111111) << 2 */ TODO) | (( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: ch2 >> 4 */ TODO) & 0b00000011)
		code2 := ( /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: (ch2 & 0B00001111) << 4 */ TODO) | (( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: ch3 >> 2 */ TODO) & 0b00001111)
		code3 := ( /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: (ch3 & 0B00000011) << 6 */ TODO) | (ch4 & 0b00111111)

		if code2 == 0 && ch3 != 0 {
			expandedCharCodes.push(code1)
		} else if code3 == 0 && ch4 != 0 {
			expandedCharCodes.push(code1, code2)
		} else {
			expandedCharCodes.push(code1, code2, code3)
		}
		i += 4
	}
	return getStringFromExpandedCharCodes(expandedCharCodes)
}

/** @internal */

func readJsonOrUndefined(path string, hostOrText /* TODO(TS-TO-GO) TypeNode UnionType: { readFile(fileName: string): string | undefined; } | string */ any) *any {
	var jsonText *string
	if isString(hostOrText) {
		jsonText = hostOrText
	} else {
		jsonText = hostOrText.readFile(path)
	}
	if !jsonText {
		return nil
	}
	// gracefully handle if readFile fails or returns not JSON
	result := parseConfigFileTextToJson(path, jsonText)
	if !result.error {
		return result.config
	} else {
		return nil
	}
}

/** @internal */

func readJson(path string, host /* TODO(TS-TO-GO) TypeNode TypeLiteral: { readFile(fileName: string): string | undefined; } */ any) any {
	return readJsonOrUndefined(path, host) || map[any]any{ /* TODO(TS-TO-GO): was object literal */
	}
}

/** @internal */

func tryParseJson(text string) any {
	{ // try
		return JSON.parse(text)
	}
	{ // catch
		return nil
	}
}

/** @internal */

func directoryProbablyExists(directoryName string, host /* TODO(TS-TO-GO) TypeNode TypeLiteral: { directoryExists?: (directoryName: string) => boolean; } */ any) bool {
	// if host does not support 'directoryExists' assume that directory will exist
	return !host.directoryExists || host.directoryExists(directoryName)
}

var carriageReturnLineFeed = "\r\n"
var lineFeed = "\n"

/** @internal */

func getNewLineCharacter(options /* TODO(TS-TO-GO) TypeNode UnionType: CompilerOptions | PrinterOptions */ any) string {
	switch options.newLine {
	case NewLineKindCarriageReturnLineFeed:
		return carriageReturnLineFeed
	case NewLineKindLineFeed,
		nil:
		return lineFeed
	}
}

/**
 * Creates a new TextRange from the provided pos and end.
 *
 * @param pos The start position.
 * @param end The end position.
 *
 * @internal
 */

func createRange(pos number, end number /*  = pos */) TextRange {
	Debug.assert(end >= pos || end == -1)
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"pos": pos,
		"end": end,
	}
}

/**
 * Creates a new TextRange from a provided range with a new end position.
 *
 * @param range A TextRange.
 * @param end The new end position.
 *
 * @internal
 */

func moveRangeEnd(range_ TextRange, end number) TextRange {
	return createRange(range_.pos, end)
}

/**
 * Creates a new TextRange from a provided range with a new start position.
 *
 * @param range A TextRange.
 * @param pos The new Start position.
 *
 * @internal
 */

func moveRangePos(range_ TextRange, pos number) TextRange {
	return createRange(pos, range_.end)
}

/**
 * Moves the start position of a range past any decorators.
 *
 * @internal
 */

func moveRangePastDecorators(node Node) TextRange {
	var lastDecorator *Decorator
	if canHaveModifiers(node) {
		lastDecorator = findLast(node.modifiers, isDecorator)
	} else {
		lastDecorator = nil
	}
	if lastDecorator && !positionIsSynthesized(lastDecorator.end) {
		return moveRangePos(node, lastDecorator.end)
	} else {
		return node
	}
}

/**
 * Moves the start position of a range past any decorators or modifiers.
 *
 * @internal
 */

func moveRangePastModifiers(node Node) TextRange {
	if isPropertyDeclaration(node) || isMethodDeclaration(node) {
		return moveRangePos(node, node.name.pos)
	}

	var lastModifier * /* TODO(TS-TO-GO) inferred type Decorator | AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword */ any
	if canHaveModifiers(node) {
		lastModifier = lastOrUndefined(node.modifiers)
	} else {
		lastModifier = nil
	}
	if lastModifier && !positionIsSynthesized(lastModifier.end) {
		return moveRangePos(node, lastModifier.end)
	} else {
		return moveRangePastDecorators(node)
	}
}

/**
 * Creates a new TextRange for a token at the provides start position.
 *
 * @param pos The start position.
 * @param token The token.
 *
 * @internal
 */

func createTokenRange(pos number, token SyntaxKind) TextRange {
	return createRange(pos, pos+tokenToString(token).length)
}

/** @internal */

func rangeIsOnSingleLine(range_ TextRange, sourceFile SourceFile) bool {
	return rangeStartIsOnSameLineAsRangeEnd(range_, range_, sourceFile)
}

/** @internal */

func rangeStartPositionsAreOnSameLine(range1 TextRange, range2 TextRange, sourceFile SourceFile) bool {
	return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile /*includeComments*/, false), getStartPositionOfRange(range2, sourceFile /*includeComments*/, false), sourceFile)
}

/** @internal */

func rangeEndPositionsAreOnSameLine(range1 TextRange, range2 TextRange, sourceFile SourceFile) bool {
	return positionsAreOnSameLine(range1.end, range2.end, sourceFile)
}

/** @internal @knipignore */

func rangeStartIsOnSameLineAsRangeEnd(range1 TextRange, range2 TextRange, sourceFile SourceFile) bool {
	return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile /*includeComments*/, false), range2.end, sourceFile)
}

/** @internal */

func rangeEndIsOnSameLineAsRangeStart(range1 TextRange, range2 TextRange, sourceFile SourceFile) bool {
	return positionsAreOnSameLine(range1.end, getStartPositionOfRange(range2, sourceFile /*includeComments*/, false), sourceFile)
}

/** @internal */

func getLinesBetweenRangeEndAndRangeStart(range1 TextRange, range2 TextRange, sourceFile SourceFile, includeSecondRangeComments bool) number {
	range2Start := getStartPositionOfRange(range2, sourceFile, includeSecondRangeComments)
	return getLinesBetweenPositions(sourceFile, range1.end, range2Start)
}

/** @internal @knipignore */

func getLinesBetweenRangeEndPositions(range1 TextRange, range2 TextRange, sourceFile SourceFile) number {
	return getLinesBetweenPositions(sourceFile, range1.end, range2.end)
}

/** @internal */

func isNodeArrayMultiLine(list NodeArray[Node], sourceFile SourceFile) bool {
	return !positionsAreOnSameLine(list.pos, list.end, sourceFile)
}

/** @internal */

func positionsAreOnSameLine(pos1 number, pos2 number, sourceFile SourceFile) bool {
	return getLinesBetweenPositions(sourceFile, pos1, pos2) == 0
}

/** @internal @knipignore */

func getStartPositionOfRange(range_ TextRange, sourceFile SourceFile, includeComments bool) number {
	if positionIsSynthesized(range_.pos) {
		return -1
	} else {
		return skipTrivia(sourceFile.text, range_.pos /*stopAfterLineBreak*/, false, includeComments)
	}
}

/** @internal */

func getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(pos number, stopPos number, sourceFile SourceFile, includeComments bool) number {
	startPos := skipTrivia(sourceFile.text, pos /*stopAfterLineBreak*/, false, includeComments)
	prevPos := getPreviousNonWhitespacePosition(startPos, stopPos, sourceFile)
	return getLinesBetweenPositions(sourceFile /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: prevPos ?? stopPos */, TODO, startPos)
}

/** @internal */

func getLinesBetweenPositionAndNextNonWhitespaceCharacter(pos number, stopPos number, sourceFile SourceFile, includeComments bool) number {
	nextPos := skipTrivia(sourceFile.text, pos /*stopAfterLineBreak*/, false, includeComments)
	return getLinesBetweenPositions(sourceFile, pos, Math.min(stopPos, nextPos))
}

func getPreviousNonWhitespacePosition(pos number, stopPos number /*  = 0 */, sourceFile SourceFile) *number {
	for /* TODO(TS-TO-GO) Node PostfixUnaryExpression: pos-- */ TODO > stopPos {
		if !isWhiteSpaceLike(sourceFile.text.charCodeAt(pos)) {
			return pos
		}
	}
}

/**
 * Determines whether a name was originally the declaration name of an enum or namespace
 * declaration.
 *
 * @internal
 */

func isDeclarationNameOfEnumOrNamespace(node Identifier) bool {
	parseNode := getParseTreeNode(node)
	if parseNode {
		switch parseNode.parent.kind {
		case SyntaxKindEnumDeclaration,
			SyntaxKindModuleDeclaration:
			return parseNode == (parseNode.parent /* as EnumDeclaration | ModuleDeclaration */).name
		}
	}
	return false
}

/** @internal */

func getInitializedVariables(node VariableDeclarationList) []InitializedVariableDeclaration {
	return filter(node.declarations, isInitializedVariable)
}

/** @internal */

func isInitializedVariable(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is InitializedVariableDeclaration */ any {
	return isVariableDeclaration(node) && node.initializer != nil
}

/** @internal */

func isWatchSet(options CompilerOptions) *bool {
	// Firefox has Object.prototype.watch
	return options.watch && hasProperty(options, "watch")
}

/** @internal */

func closeFileWatcher(watcher FileWatcher) {
	watcher.close()
}

/** @internal */

func getCheckFlags(symbol Symbol) CheckFlags {
	if symbol.flags & SymbolFlagsTransient {
		return (symbol /* as TransientSymbol */).links.checkFlags
	} else {
		return 0
	}
}

/** @internal */

func getDeclarationModifierFlagsFromSymbol(s Symbol, isWrite bool /*  = false */) ModifierFlags {
	if s.valueDeclaration {
		declaration := (isWrite && s.declarations && find(s.declarations, isSetAccessorDeclaration)) || (s.flags&SymbolFlagsGetAccessor && find(s.declarations, isGetAccessorDeclaration)) || s.valueDeclaration
		flags := getCombinedModifierFlags(declaration)
		if s.parent && s.parent.flags&SymbolFlagsClass {
			return flags
		} else {
			return flags & ~ModifierFlagsAccessibilityModifier
		}
	}
	if getCheckFlags(s) & CheckFlagsSynthetic {
		// NOTE: potentially unchecked cast to TransientSymbol
		checkFlags := (s /* as TransientSymbol */).links.checkFlags
		var accessModifier /* TODO(TS-TO-GO) inferred type ModifierFlags.Public | ModifierFlags.Private | ModifierFlags.Protected */ any
		switch {
		case checkFlags & CheckFlagsContainsPrivate:
			accessModifier = ModifierFlagsPrivate
		case checkFlags & CheckFlagsContainsPublic:
			accessModifier = ModifierFlagsPublic
		default:
			accessModifier = ModifierFlagsProtected
		}
		var staticModifier /* TODO(TS-TO-GO) inferred type 0 | ModifierFlags.Static */ any
		if checkFlags & CheckFlagsContainsStatic {
			staticModifier = ModifierFlagsStatic
		} else {
			staticModifier = 0
		}
		return accessModifier | staticModifier
	}
	if s.flags & SymbolFlagsPrototype {
		return ModifierFlagsPublic | ModifierFlagsStatic
	}
	return 0
}

/** @internal */

func skipAlias(symbol Symbol, checker TypeChecker) Symbol {
	if symbol.flags & SymbolFlagsAlias {
		return checker.getAliasedSymbol(symbol)
	} else {
		return symbol
	}
}

/**
 * See comment on `declareModuleMember` in `binder.ts`.
 *
 * @internal
 */

func getCombinedLocalAndExportSymbolFlags(symbol Symbol) SymbolFlags {
	if symbol.exportSymbol {
		return symbol.exportSymbol.flags | symbol.flags
	} else {
		return symbol.flags
	}
}

/** @internal */

func isWriteOnlyAccess(node Node) bool {
	return accessKind(node) == AccessKindWrite
}

/** @internal */

func isWriteAccess(node Node) bool {
	return accessKind(node) != AccessKindRead
}

type AccessKind int32

const (
	/** Only reads from a variable. */
	AccessKindRead AccessKind = iota
	/** Only writes to a variable without ever reading it. E.g.: `x=1;`. */
	AccessKindWrite
	/** Reads from and writes to a variable. E.g.: `f(x++);`, `x/=1`. */
	AccessKindReadWrite
)

func accessKind(node Node) AccessKind {
	TODO_IDENTIFIER := node

	switch parent. /* ? */ kind {
	case SyntaxKindParenthesizedExpression:
		return accessKind(parent)
	case SyntaxKindPostfixUnaryExpression,
		SyntaxKindPrefixUnaryExpression:
		TODO_IDENTIFIER := parent /* as PrefixUnaryExpression | PostfixUnaryExpression */
		if operator == SyntaxKindPlusPlusToken || operator == SyntaxKindMinusMinusToken {
			return AccessKindReadWrite
		} else {
			return AccessKindRead
		}
	case SyntaxKindBinaryExpression:
		TODO_IDENTIFIER := parent /* as BinaryExpression */
		switch {
		case left == node && isAssignmentOperator(operatorToken.kind):
			if operatorToken.kind == SyntaxKindEqualsToken {
				return AccessKindWrite
			} else {
				return AccessKindReadWrite
			}
		default:
			return AccessKindRead
		}
	case SyntaxKindPropertyAccessExpression:
		if (parent /* as PropertyAccessExpression */).name != node {
			return AccessKindRead
		} else {
			return accessKind(parent)
		}
	case SyntaxKindPropertyAssignment:
		parentAccess := accessKind(parent.parent)
		// In `({ x: varname }) = { x: 1 }`, the left `x` is a read, the right `x` is a write.
		if node == (parent /* as PropertyAssignment */).name {
			return reverseAccessKind(parentAccess)
		} else {
			return parentAccess
		}
		fallthrough
	case SyntaxKindShorthandPropertyAssignment:
		if node == (parent /* as ShorthandPropertyAssignment */).objectAssignmentInitializer {
			return AccessKindRead
		} else {
			return accessKind(parent.parent)
		}
	case SyntaxKindArrayLiteralExpression:
		return accessKind(parent)
	case SyntaxKindForInStatement,
		SyntaxKindForOfStatement:
		if node == (parent /* as ForInStatement | ForOfStatement */).initializer {
			return AccessKindWrite
		} else {
			return AccessKindRead
		}
	default:
		return AccessKindRead
	}
}

func reverseAccessKind(a AccessKind) AccessKind {
	switch a {
	case AccessKindRead:
		return AccessKindWrite
	case AccessKindWrite:
		return AccessKindRead
	case AccessKindReadWrite:
		return AccessKindReadWrite
	default:
		return Debug.assertNever(a)
	}
}

/** @internal */

func compareDataObjects(dst any, src any) bool {
	if !dst || !src || Object.keys(dst).length != Object.keys(src).length {
		return false
	}

	/* TODO(TS-TO-GO) Node ForInStatement: for (const e in dst) { if (typeof dst[e] === "object") { if (!compareDataObjects(dst[e], src[e])) { return false; } } else if (typeof dst[e] !== "function") { if (dst[e] !== src[e]) { return false; } } } */
	return true
}

/**
 * clears already present map by calling onDeleteExistingValue callback before deleting that key/value
 *
 * @internal
 */

func clearMap(map_ /* TODO(TS-TO-GO) TypeNode TypeLiteral: { forEach: Map<K, T>["forEach"]; clear: Map<K, T>["clear"]; } */ any, onDeleteValue func(valueInMap T, key K)) {
	// Remove all
	map_.forEach(onDeleteValue)
	map_.clear()
}

/** @internal */

type MutateMapSkippingNewValuesDelete[K any, T any] struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface MutateMapSkippingNewValuesDelete<K, T> { onDeleteValue(existingValue: T, key: K): void; } */
}

/** @internal */

type MutateMapSkippingNewValuesOptions[K any, T any, U any] struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface MutateMapSkippingNewValuesOptions<K, T, U> extends MutateMapSkippingNewValuesDelete<K, T> { /** * If present this is called with the key when there is value for that key both in new map as well as existing map provided * Caller can then decide to update or remove this key. * If the key is removed, caller will get callback of createNewValue for that key. * If this callback is not provided, the value of such keys is not updated. * / onExistingValue?(existingValue: T, valueInNewMap: U, key: K): void; } */
}

/**
 * Mutates the map with newMap such that keys in map will be same as newMap.
 *
 * @internal
 */

/* OVERLOAD: export function mutateMapSkippingNewValues<K, T>( map: Map<K, T>, newMap: ReadonlySet<K> | undefined, options: MutateMapSkippingNewValuesDelete<K, T>, ): void; */
/** @internal */

/* OVERLOAD: export function mutateMapSkippingNewValues<K, T, U>( map: Map<K, T>, newMap: ReadonlyMap<K, U> | undefined, options: MutateMapSkippingNewValuesOptions<K, T, U>, ): void; */
func mutateMapSkippingNewValues(map_ Map[K, T], newMap /* TODO(TS-TO-GO) TypeNode UnionType: ReadonlyMap<K, U> | ReadonlySet<K> | undefined */ any, options MutateMapSkippingNewValuesOptions[K, T, U]) {
	TODO_IDENTIFIER := options
	// Needs update
	map_.forEach(func(existingValue T, key K) {
		// Not present any more in new map, remove it
		if !newMap. /* ? */ has(key) {
			map_.delete(key)
			onDeleteValue(existingValue, key)
		} else if onExistingValue {
			onExistingValue(existingValue, (newMap /* as Map<K, U> */).get(key), key)
		}
	})
}

/** @internal */

type MutateMapOptionsCreate[K any, T any, U any] struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface MutateMapOptionsCreate<K, T, U> { createNewValue(key: K, valueInNewMap: U): T; } */
}

/** @internal */

type MutateMapWithNewSetOptions[K any, T any] struct {
}

/** @internal */

type MutateMapOptions[K any, T any, U any] struct {
}

/**
 * Mutates the map with newMap such that keys in map will be same as newMap.
 *
 * @internal
 */

/* OVERLOAD: export function mutateMap<K, T>(map: Map<K, T>, newMap: ReadonlySet<K> | undefined, options: MutateMapWithNewSetOptions<K, T>): void; */
/** @internal */

/* OVERLOAD: export function mutateMap<K, T, U>(map: Map<K, T>, newMap: ReadonlyMap<K, U> | undefined, options: MutateMapOptions<K, T, U>): void; */
func mutateMap(map_ Map[K, T], newMap /* TODO(TS-TO-GO) TypeNode UnionType: ReadonlyMap<K, U> | ReadonlySet<K> | undefined */ any, options MutateMapOptions[K, T, U]) {
	// Needs update
	mutateMapSkippingNewValues(map_, newMap /* as ReadonlyMap<K, U> */, options)

	TODO_IDENTIFIER := options
	// Add new values that are not already present
	newMap. /* ? */ forEach(func(valueInNewMap /* TODO(TS-TO-GO) inferred type K | U */ any, key K) {
		if !map_.has(key) {
			// New values
			map_.set(key, createNewValue(key, valueInNewMap /* as U & K */))
		}
	})
}

/** @internal */

func isAbstractConstructorSymbol(symbol Symbol) bool {
	if symbol.flags & SymbolFlagsClass {
		declaration := getClassLikeDeclarationOfSymbol(symbol)
		return !!declaration && hasSyntacticModifier(declaration, ModifierFlagsAbstract)
	}
	return false
}

/** @internal */

func getClassLikeDeclarationOfSymbol(symbol Symbol) *ClassLikeDeclaration {
	return symbol.declarations. /* ? */ find(isClassLike)
}

/** @internal */

func getObjectFlags(type_ Type) ObjectFlags {
	if type_.flags & TypeFlagsObjectFlagsType {
		return (type_ /* as ObjectFlagsType */).objectFlags
	} else {
		return 0
	}
}

/** @internal */

func isUMDExportSymbol(symbol Symbol) bool {
	return !!symbol && !!symbol.declarations && !!symbol.declarations[0] && isNamespaceExportDeclaration(symbol.declarations[0])
}

/** @internal */

func showModuleSpecifier(TODO_IDENTIFIER ImportDeclaration) string {
	if isStringLiteral(moduleSpecifier) {
		return moduleSpecifier.text
	} else {
		return getTextOfNode(moduleSpecifier)
	}
}

/** @internal */

func getLastChild(node Node) Node {
	var lastChild Node
	forEachChild(node, func(child Node) {
		if nodeIsPresent(child) {
			lastChild = child
		}
	}, func(children NodeArray[Node]) {
		// As an optimization, jump straight to the end of the list.
		for i := children.length - 1; i >= 0; i-- {
			if nodeIsPresent(children[i]) {
				lastChild = children[i]
				break
			}
		}
	})
	return lastChild
}

/**
 * Add a value to a set, and return true if it wasn't already present.
 *
 * @internal
 */

/* OVERLOAD: export function addToSeen<K>(seen: Map<K, true>, key: K): boolean; */
/** @internal */

/* OVERLOAD: export function addToSeen<K, T>(seen: Map<K, T>, key: K, value: T): boolean; */
/** @internal */

func addToSeen(seen Map[K, T], key K, value T /*  = true as any */) bool {
	if seen.has(key) {
		return false
	}
	seen.set(key, value)
	return true
}

/** @internal */

func isObjectTypeDeclaration(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ObjectTypeDeclaration */ any {
	return isClassLike(node) || isInterfaceDeclaration(node) || isTypeLiteralNode(node)
}

/** @internal */

func isTypeNodeKind(kind SyntaxKind) /* TODO(TS-TO-GO) TypeNode TypePredicate: kind is TypeNodeSyntaxKind */ any {
	return (kind >= SyntaxKindFirstTypeNode && kind <= SyntaxKindLastTypeNode) || kind == SyntaxKindAnyKeyword || kind == SyntaxKindUnknownKeyword || kind == SyntaxKindNumberKeyword || kind == SyntaxKindBigIntKeyword || kind == SyntaxKindObjectKeyword || kind == SyntaxKindBooleanKeyword || kind == SyntaxKindStringKeyword || kind == SyntaxKindSymbolKeyword || kind == SyntaxKindVoidKeyword || kind == SyntaxKindUndefinedKeyword || kind == SyntaxKindNeverKeyword || kind == SyntaxKindIntrinsicKeyword || kind == SyntaxKindExpressionWithTypeArguments || kind == SyntaxKindJSDocAllType || kind == SyntaxKindJSDocUnknownType || kind == SyntaxKindJSDocNullableType || kind == SyntaxKindJSDocNonNullableType || kind == SyntaxKindJSDocOptionalType || kind == SyntaxKindJSDocFunctionType || kind == SyntaxKindJSDocVariadicType
}

/** @internal */

func isAccessExpression(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AccessExpression */ any {
	return node.kind == SyntaxKindPropertyAccessExpression || node.kind == SyntaxKindElementAccessExpression
}

/** @internal */

func getNameOfAccessExpression(node AccessExpression) Expression {
	if node.kind == SyntaxKindPropertyAccessExpression {
		return node.name
	}
	Debug.assert(node.kind == SyntaxKindElementAccessExpression)
	return node.argumentExpression
}

/** @internal */

func isNamedImportsOrExports(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is NamedImportsOrExports */ any {
	return node.kind == SyntaxKindNamedImports || node.kind == SyntaxKindNamedExports
}

/** @internal */

func getLeftmostAccessExpression(expr Expression) Expression {
	for isAccessExpression(expr) {
		expr = expr.expression
	}
	return expr
}

/** @internal */

func forEachNameInAccessChainWalkingLeft(name /* TODO(TS-TO-GO) TypeNode UnionType: MemberName | StringLiteralLike */ any, action func(name /* TODO(TS-TO-GO) TypeNode UnionType: MemberName | StringLiteralLike */ any) *T) *T {
	if isAccessExpression(name.parent) && isRightSideOfAccessExpression(name) {
		return walkAccessExpression(name.parent)
	}

	walkAccessExpression := func(access AccessExpression) *T {
		if access.kind == SyntaxKindPropertyAccessExpression {
			res := action(access.name)
			if res != nil {
				return res
			}
		} else if access.kind == SyntaxKindElementAccessExpression {
			if isIdentifier(access.argumentExpression) || isStringLiteralLike(access.argumentExpression) {
				res := action(access.argumentExpression)
				if res != nil {
					return res
				}
			} else {
				// Chain interrupted by non-static-name access 'x[expr()].y.z'
				return nil
			}
		}

		if isAccessExpression(access.expression) {
			return walkAccessExpression(access.expression)
		}
		if isIdentifier(access.expression) {
			// End of chain at Identifier 'x.y.z'
			return action(access.expression)
		}
		// End of chain at non-Identifier 'x().y.z'
		return nil
	}

}

/** @internal */

func getLeftmostExpression(node Expression, stopAtCallExpressions bool) Expression {
	for true {
		switch node.kind {
		case SyntaxKindPostfixUnaryExpression:
			node = (node /* as PostfixUnaryExpression */).operand
			continue
			fallthrough
		case SyntaxKindBinaryExpression:
			node = (node /* as BinaryExpression */).left
			continue
			fallthrough
		case SyntaxKindConditionalExpression:
			node = (node /* as ConditionalExpression */).condition
			continue
			fallthrough
		case SyntaxKindTaggedTemplateExpression:
			node = (node /* as TaggedTemplateExpression */).tag
			continue
			fallthrough
		case SyntaxKindCallExpression:
			if stopAtCallExpressions {
				return node
			}
			fallthrough
		case SyntaxKindAsExpression,
			SyntaxKindElementAccessExpression,
			SyntaxKindPropertyAccessExpression,
			SyntaxKindNonNullExpression,
			SyntaxKindPartiallyEmittedExpression,
			SyntaxKindSatisfiesExpression:
			node = (node /* as CallExpression | PropertyAccessExpression | ElementAccessExpression | AsExpression | NonNullExpression | PartiallyEmittedExpression | SatisfiesExpression */).expression
			continue
		}

		return node
	}
}

/** @internal */

type ObjectAllocator struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface ObjectAllocator { getNodeConstructor(): new (kind: SyntaxKind, pos: number, end: number) => Node; getTokenConstructor(): new <TKind extends SyntaxKind>(kind: TKind, pos: number, end: number) => Token<TKind>; getIdentifierConstructor(): new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier; getPrivateIdentifierConstructor(): new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier; getSourceFileConstructor(): new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile; getSymbolConstructor(): new (flags: SymbolFlags, name: __String) => Symbol; getTypeConstructor(): new (checker: TypeChecker, flags: TypeFlags) => Type; getSignatureConstructor(): new (checker: TypeChecker, flags: SignatureFlags) => Signature; getSourceMapSourceConstructor(): new (fileName: string, text: string, skipTrivia?: (pos: number) => number) => SourceMapSource; } */
}

func Symbol(this Symbol, flags SymbolFlags, name __String) {
	// Note: if modifying this, be sure to update SymbolObject in src/services/services.ts
	this.flags = flags
	this.escapedName = name
	this.declarations = nil
	this.valueDeclaration = nil
	this.id = 0
	this.mergeId = 0
	this.parent = nil
	this.members = nil
	this.exports = nil
	this.exportSymbol = nil
	this.constEnumOnlyModule = nil
	this.isReferenced = nil
	this.lastAssignmentPos = nil
	(this /* as any */).links = nil
	// used by TransientSymbol
}

func Type(this Type, checker TypeChecker, flags TypeFlags) {
	// Note: if modifying this, be sure to update TypeObject in src/services/services.ts
	this.flags = flags
	if Debug.isDebugging || tracing {
		this.checker = checker
	}
}

func Signature(this Signature, checker TypeChecker, flags SignatureFlags) {
	// Note: if modifying this, be sure to update SignatureObject in src/services/services.ts
	this.flags = flags
	if Debug.isDebugging {
		this.checker = checker
	}
}

func Node(this Mutable[Node], kind SyntaxKind, pos number, end number) {
	// Note: if modifying this, be sure to update NodeObject in src/services/services.ts
	this.pos = pos
	this.end = end
	this.kind = kind
	this.id = 0
	this.flags = NodeFlagsNone
	this.modifierFlagsCache = ModifierFlagsNone
	this.transformFlags = TransformFlagsNone
	this.parent = nil
	this.original = nil
	this.emitNode = nil
}

func Token(this Mutable[Node], kind SyntaxKind, pos number, end number) {
	// Note: if modifying this, be sure to update TokenOrIdentifierObject in src/services/services.ts
	this.pos = pos
	this.end = end
	this.kind = kind
	this.id = 0
	this.flags = NodeFlagsNone
	this.transformFlags = TransformFlagsNone
	this.parent = nil
	this.emitNode = nil
}

func Identifier(this Mutable[Node], kind SyntaxKind, pos number, end number) {
	// Note: if modifying this, be sure to update TokenOrIdentifierObject in src/services/services.ts
	this.pos = pos
	this.end = end
	this.kind = kind
	this.id = 0
	this.flags = NodeFlagsNone
	this.transformFlags = TransformFlagsNone
	this.parent = nil
	this.original = nil
	this.emitNode = nil
}

func SourceMapSource(this SourceMapSource, fileName string, text string, skipTrivia func(pos number) number) {
	// Note: if modifying this, be sure to update SourceMapSourceObject in src/services/services.ts
	this.fileName = fileName
	this.text = text
	this.skipTrivia = skipTrivia || (func(pos number) number {
		return pos
	})
}

/** @internal */

var objectAllocator ObjectAllocator = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"getNodeConstructor": func() any {
		return Node /* as any */
	},
	"getTokenConstructor": func() any {
		return Token /* as any */
	},
	"getIdentifierConstructor": func() any {
		return Identifier /* as any */
	},
	"getPrivateIdentifierConstructor": func() any {
		return Node /* as any */
	},
	"getSourceFileConstructor": func() any {
		return Node /* as any */
	},
	"getSymbolConstructor": func() any {
		return Symbol /* as any */
	},
	"getTypeConstructor": func() any {
		return Type /* as any */
	},
	"getSignatureConstructor": func() any {
		return Signature /* as any */
	},
	"getSourceMapSourceConstructor": func() any {
		return SourceMapSource /* as any */
	},
}

var objectAllocatorPatchers []func(objectAllocator ObjectAllocator) = []never{}

/**
 * Used by `deprecatedCompat` to patch the object allocator to apply deprecations.
 * @internal
 * @knipignore
 */

func addObjectAllocatorPatcher(fn func(objectAllocator ObjectAllocator)) {
	objectAllocatorPatchers.push(fn)
	fn(objectAllocator)
}

/** @internal */

func setObjectAllocator(alloc ObjectAllocator) {
	Object.assign(objectAllocator, alloc)
	forEach(objectAllocatorPatchers, func(fn /* TODO(TS-TO-GO) inferred type (objectAllocator: ObjectAllocator) => void */ any) {
		return fn(objectAllocator)
	})
}

/** @internal */

func formatStringFromArgs(text string, args DiagnosticArguments) string {
	return text.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\{(\d+)\}/g */ TODO, func(_match string, index string) string {
		return "" + Debug.checkDefined(args[+index])
	})
}

var localizedDiagnosticMessages *MapLike[string]

/** @internal */

func setLocalizedDiagnosticMessages(messages *MapLike[string]) {
	localizedDiagnosticMessages = messages
}

/** @internal */
// If the localized messages json is unset, and if given function use it to set the json

func maybeSetLocalizedDiagnosticMessages(getMessages *func() *MapLike[string]) {
	if !localizedDiagnosticMessages && getMessages {
		localizedDiagnosticMessages = getMessages()
	}
}

/** @internal */

func getLocaleSpecificMessage(message DiagnosticMessage) string {
	return localizedDiagnosticMessages && localizedDiagnosticMessages[message.key] || message.message
}

/** @internal */

func createDetachedDiagnostic(fileName string, sourceText string, start number, length number, message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithDetachedLocation {
	if (start + length) > sourceText.length {
		length = sourceText.length - start
	}

	assertDiagnosticLocation(sourceText, start, length)
	text := getLocaleSpecificMessage(message)

	if some(args) {
		text = formatStringFromArgs(text, args)
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":               nil,
		"start":              start,
		"length":             length,
		"messageText":        text,
		"category":           message.category,
		"code":               message.code,
		"reportsUnnecessary": message.reportsUnnecessary,
		"fileName":           fileName,
	}
}

func isDiagnosticWithDetachedLocation(diagnostic /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticRelatedInformation | DiagnosticWithDetachedLocation */ any) /* TODO(TS-TO-GO) TypeNode TypePredicate: diagnostic is DiagnosticWithDetachedLocation */ any {
	return diagnostic.file == nil && diagnostic.start != nil && diagnostic.length != nil && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof (diagnostic as DiagnosticWithDetachedLocation).fileName */ TODO == "string"
}

func attachFileToDiagnostic(diagnostic DiagnosticWithDetachedLocation, file SourceFile) DiagnosticWithLocation {
	fileName := file.fileName || ""
	length := file.text.length
	Debug.assertEqual(diagnostic.fileName, fileName)
	Debug.assertLessThanOrEqual(diagnostic.start, length)
	Debug.assertLessThanOrEqual(diagnostic.start+diagnostic.length, length)
	var diagnosticWithLocation DiagnosticWithLocation = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":               file,
		"start":              diagnostic.start,
		"length":             diagnostic.length,
		"messageText":        diagnostic.messageText,
		"category":           diagnostic.category,
		"code":               diagnostic.code,
		"reportsUnnecessary": diagnostic.reportsUnnecessary,
	}
	if diagnostic.relatedInformation {
		diagnosticWithLocation.relatedInformation = []never{}
		for _, related := range diagnostic.relatedInformation {
			if isDiagnosticWithDetachedLocation(related) && related.fileName == fileName {
				Debug.assertLessThanOrEqual(related.start, length)
				Debug.assertLessThanOrEqual(related.start+related.length, length)
				diagnosticWithLocation.relatedInformation.push(attachFileToDiagnostic(related, file))
			} else {
				diagnosticWithLocation.relatedInformation.push(related)
			}
		}
	}
	return diagnosticWithLocation
}

/** @internal */

func attachFileToDiagnostics(diagnostics []DiagnosticWithDetachedLocation, file SourceFile) []DiagnosticWithLocation {
	var diagnosticsWithLocation []DiagnosticWithLocation = []never{}
	for _, diagnostic := range diagnostics {
		diagnosticsWithLocation.push(attachFileToDiagnostic(diagnostic, file))
	}
	return diagnosticsWithLocation
}

/** @internal */

func createFileDiagnostic(file SourceFile, start number, length number, message DiagnosticMessage, args DiagnosticArguments) DiagnosticWithLocation {
	assertDiagnosticLocation(file.text, start, length)

	text := getLocaleSpecificMessage(message)

	if some(args) {
		text = formatStringFromArgs(text, args)
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":               file,
		"start":              start,
		"length":             length,
		"messageText":        text,
		"category":           message.category,
		"code":               message.code,
		"reportsUnnecessary": message.reportsUnnecessary,
		"reportsDeprecated":  message.reportsDeprecated,
	}
}

/** @internal */

func formatMessage(message DiagnosticMessage, args DiagnosticArguments) string {
	text := getLocaleSpecificMessage(message)

	if some(args) {
		text = formatStringFromArgs(text, args)
	}

	return text
}

/** @internal */

func createCompilerDiagnostic(message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
	text := getLocaleSpecificMessage(message)

	if some(args) {
		text = formatStringFromArgs(text, args)
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":               nil,
		"start":              nil,
		"length":             nil,
		"messageText":        text,
		"category":           message.category,
		"code":               message.code,
		"reportsUnnecessary": message.reportsUnnecessary,
		"reportsDeprecated":  message.reportsDeprecated,
	}
}

/** @internal */

func createCompilerDiagnosticFromMessageChain(chain DiagnosticMessageChain, relatedInformation []DiagnosticRelatedInformation) Diagnostic {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"file":               nil,
		"start":              nil,
		"length":             nil,
		"code":               chain.code,
		"category":           chain.category,
		"messageText":        __COND__(chain.next, chain, chain.messageText),
		"relatedInformation": relatedInformation,
	}
}

/** @internal */

func chainDiagnosticMessages(details /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessageChain | DiagnosticMessageChain[] | undefined */ any, message DiagnosticMessage, args DiagnosticArguments) DiagnosticMessageChain {
	text := getLocaleSpecificMessage(message)

	if some(args) {
		text = formatStringFromArgs(text, args)
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"messageText": text,
		"category":    message.category,
		"code":        message.code,
		"next":        __COND__(details == nil || Array.isArray(details), details, []DiagnosticMessageChain{details}),
	}
}

/** @internal */

func concatenateDiagnosticMessageChains(headChain DiagnosticMessageChain, tailChain DiagnosticMessageChain) {
	lastChain := headChain
	for lastChain.next {
		lastChain = lastChain.next[0]
	}

	lastChain.next = []DiagnosticMessageChain{tailChain}
}

func getDiagnosticFilePath(diagnostic Diagnostic) *string {
	if diagnostic.file {
		return diagnostic.file.path
	} else {
		return nil
	}
}

/** @internal */

func compareDiagnostics(d1 Diagnostic, d2 Diagnostic) Comparison {
	return compareDiagnosticsSkipRelatedInformation(d1, d2) || compareRelatedInformation(d1, d2) || ComparisonEqualTo
}

func compareDiagnosticsSkipRelatedInformation(d1 Diagnostic, d2 Diagnostic) Comparison {
	code1 := getDiagnosticCode(d1)
	code2 := getDiagnosticCode(d2)
	return compareStringsCaseSensitive(getDiagnosticFilePath(d1), getDiagnosticFilePath(d2)) || compareValues(d1.start, d2.start) || compareValues(d1.length, d2.length) || compareValues(code1, code2) || compareMessageText(d1, d2) || ComparisonEqualTo
}

// A diagnostic with more elaboration should be considered *less than* a diagnostic
// with less elaboration that is otherwise similar.
func compareRelatedInformation(d1 Diagnostic, d2 Diagnostic) Comparison {
	if !d1.relatedInformation && !d2.relatedInformation {
		return ComparisonEqualTo
	}
	if d1.relatedInformation && d2.relatedInformation {
		return compareValues(d2.relatedInformation.length, d1.relatedInformation.length) || forEach(d1.relatedInformation, func(d1i DiagnosticRelatedInformation, index number) Comparison {
			d2i := d2.relatedInformation[index]
			return compareDiagnostics(d1i, d2i)
			// EqualTo is 0, so falsy, and will cause the next item to be compared
		}) || ComparisonEqualTo
	}
	if d1.relatedInformation {
		return ComparisonLessThan
	} else {
		return ComparisonGreaterThan
	}
}

// An diagnostic message with more elaboration should be considered *less than* a diagnostic message
// with less elaboration that is otherwise similar.
func compareMessageText(d1 Diagnostic, d2 Diagnostic) Comparison {
	headMsg1 := getDiagnosticMessage(d1)
	headMsg2 := getDiagnosticMessage(d2)
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof headMsg1 */ TODO != "string" {
		headMsg1 = headMsg1.messageText
	}
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof headMsg2 */ TODO != "string" {
		headMsg2 = headMsg2.messageText
	}
	var chain1 *[]DiagnosticMessageChain
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof d1.messageText */ TODO != "string" {
		chain1 = d1.messageText.next
	} else {
		chain1 = nil
	}
	var chain2 *[]DiagnosticMessageChain
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof d2.messageText */ TODO != "string" {
		chain2 = d2.messageText.next
	} else {
		chain2 = nil
	}

	res := compareStringsCaseSensitive(headMsg1, headMsg2)
	if res {
		return res
	}

	res = compareMessageChain(chain1, chain2)
	if res {
		return res
	}

	if d1.canonicalHead && !d2.canonicalHead {
		return ComparisonLessThan
	}
	if d2.canonicalHead && !d1.canonicalHead {
		return ComparisonGreaterThan
	}

	return ComparisonEqualTo
}

// First compare by size of the message chain,
// then compare by content of the message chain.
func compareMessageChain(c1 *[]DiagnosticMessageChain, c2 *[]DiagnosticMessageChain) Comparison {
	if c1 == nil && c2 == nil {
		return ComparisonEqualTo
	}
	if c1 == nil {
		return ComparisonGreaterThan
	}
	if c2 == nil {
		return ComparisonLessThan
	}

	return compareMessageChainSize(c1, c2) || compareMessageChainContent(c1, c2)
}

func compareMessageChainSize(c1 *[]DiagnosticMessageChain, c2 *[]DiagnosticMessageChain) Comparison {
	if c1 == nil && c2 == nil {
		return ComparisonEqualTo
	}
	if c1 == nil {
		return ComparisonGreaterThan
	}
	if c2 == nil {
		return ComparisonLessThan
	}

	res := compareValues(c2.length, c1.length)
	if res {
		return res
	}

	for i := 0; i < c2.length; i++ {
		res = compareMessageChainSize(c1[i].next, c2[i].next)
		if res {
			return res
		}
	}

	return ComparisonEqualTo
}

// Assumes the two chains have the same shape.
func compareMessageChainContent(c1 []DiagnosticMessageChain, c2 []DiagnosticMessageChain) Comparison {
	var res TODO
	for i := 0; i < c2.length; i++ {
		res = compareStringsCaseSensitive(c1[i].messageText, c2[i].messageText)
		if res {
			return res
		}
		if c1[i].next == nil {
			continue
		}
		res = compareMessageChainContent(c1[i].next, c2[i].next)
		if res {
			return res
		}
	}
	return ComparisonEqualTo
}

/** @internal */

func diagnosticsEqualityComparer(d1 Diagnostic, d2 Diagnostic) bool {
	code1 := getDiagnosticCode(d1)
	code2 := getDiagnosticCode(d2)
	msg1 := getDiagnosticMessage(d1)
	msg2 := getDiagnosticMessage(d2)
	return compareStringsCaseSensitive(getDiagnosticFilePath(d1), getDiagnosticFilePath(d2)) == ComparisonEqualTo && compareValues(d1.start, d2.start) == ComparisonEqualTo && compareValues(d1.length, d2.length) == ComparisonEqualTo && compareValues(code1, code2) == ComparisonEqualTo && messageTextEqualityComparer(msg1, msg2)
}

func getDiagnosticCode(d Diagnostic) number {
	return d.canonicalHead. /* ? */ code || d.code
}

func getDiagnosticMessage(d Diagnostic) /* TODO(TS-TO-GO) TypeNode UnionType: string | DiagnosticMessageChain */ any {
	return d.canonicalHead. /* ? */ messageText || d.messageText
}

func messageTextEqualityComparer(m1 /* TODO(TS-TO-GO) TypeNode UnionType: string | DiagnosticMessageChain */ any, m2 /* TODO(TS-TO-GO) TypeNode UnionType: string | DiagnosticMessageChain */ any) bool {
	var t1 string
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof m1 */ TODO == "string" {
		t1 = m1
	} else {
		t1 = m1.messageText
	}
	var t2 string
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof m2 */ TODO == "string" {
		t2 = m2
	} else {
		t2 = m2.messageText
	}
	return compareStringsCaseSensitive(t1, t2) == ComparisonEqualTo
}

/** @internal */

func getLanguageVariant(scriptKind ScriptKind) LanguageVariant {
	// .tsx and .jsx files are treated as jsx language variant.
	if scriptKind == ScriptKindTSX || scriptKind == ScriptKindJSX || scriptKind == ScriptKindJS || scriptKind == ScriptKindJSON {
		return LanguageVariantJSX
	} else {
		return LanguageVariantStandard
	}
}

/**
 * This is a somewhat unavoidable full tree walk to locate a JSX tag - `import.meta` requires the same,
 * but we avoid that walk (or parts of it) if at all possible using the `PossiblyContainsImportMeta` node flag.
 * Unfortunately, there's no `NodeFlag` space to do the same for JSX.
 */

func walkTreeForJSXTags(node Node) Node {
	if !(node.transformFlags & TransformFlagsContainsJsx) {
		return nil
	}
	if isJsxOpeningLikeElement(node) || isJsxFragment(node) {
		return node
	} else {
		return forEachChild(node, walkTreeForJSXTags)
	}
}

func isFileModuleFromUsingJSXTag(file SourceFile) Node {
	// Excludes declaration files - they still require an explicit `export {}` or the like
	// for back compat purposes. (not that declaration files should contain JSX tags!)
	if !file.isDeclarationFile {
		return walkTreeForJSXTags(file)
	} else {
		return nil
	}
}

/**
 * Note that this requires file.impliedNodeFormat be set already; meaning it must be set very early on
 * in SourceFile construction.
 */

func isFileForcedToBeModuleByFormat(file SourceFile, options CompilerOptions) * /* TODO(TS-TO-GO) TypeNode LiteralType: true */ any {
	// Excludes declaration files - they still require an explicit `export {}` or the like
	// for back compat purposes. The only non-declaration files _not_ forced to be a module are `.js` files
	// that aren't esm-mode (meaning not in a `type: module` scope).
	if (getImpliedNodeFormatForEmitWorker(file, options) == ModuleKindESNext || (fileExtensionIsOneOf(file.fileName, []Extension{ExtensionCjs, ExtensionCts, ExtensionMjs, ExtensionMts}))) && !file.isDeclarationFile {
		return true
	} else {
		return nil
	}
}

/** @internal */

func getSetExternalModuleIndicator(options CompilerOptions) func(file SourceFile) {
	// TODO: Should this callback be cached?
	switch getEmitModuleDetectionKind(options) {
	case ModuleDetectionKindForce:
		return func(file SourceFile) {
			file.externalModuleIndicator = isFileProbablyExternalModule(file) || !file.isDeclarationFile || nil
		}
	case ModuleDetectionKindLegacy:
		return func(file SourceFile) {
			file.externalModuleIndicator = isFileProbablyExternalModule(file)
		}
	case ModuleDetectionKindAuto:
		var checks []func(file SourceFile, options CompilerOptions) /* TODO(TS-TO-GO) TypeNode UnionType: Node | true | undefined */ any = [] /* TODO(TS-TO-GO) inferred type typeof isFileProbablyExternalModule */ any{isFileProbablyExternalModule}
		if options.jsx == JsxEmitReactJSX || options.jsx == JsxEmitReactJSXDev {
			checks.push(isFileModuleFromUsingJSXTag)
		}
		checks.push(isFileForcedToBeModuleByFormat)
		combined := or(checks...)
		callback := func(file SourceFile) undefined {
			return ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: file.externalModuleIndicator = combined(file, options) */ TODO)
		}
		return callback
	}
}

/**
 * @internal
 * Returns true if an `import` and a `require` of the same module specifier
 * can resolve to a different file.
 */

func importSyntaxAffectsModuleResolution(options CompilerOptions) bool {
	moduleResolution := getEmitModuleResolutionKind(options)
	return ModuleResolutionKindNode16 <= moduleResolution && moduleResolution <= ModuleResolutionKindNodeNext || getResolvePackageJsonExports(options) || getResolvePackageJsonImports(options)
}

type CompilerOptionKeys /* TODO(TS-TO-GO) TypeNode MappedType: { [K in keyof CompilerOptions as string extends K ? never : K]: any; } */ any

func createComputedCompilerOptions(options /* TODO(TS-TO-GO) TypeNode MappedType: { [K in keyof T & CompilerOptionKeys | StrictOptionName]: { dependencies: T[K]; computeValue: (compilerOptions: Pick<CompilerOptions, K | T[K][number]>) => Exclude<CompilerOptions[K], undefined>; }; } */ any) /* TODO(TS-TO-GO) inferred type { [K in StrictOptionName | (keyof T & ("verbatimModuleSyntax" | "isolatedModules" | "jsx" | "all" | "allowImportingTsExtensions" | "allowJs" | "allowNonTsExtensions" | "allowArbitraryExtensions" | "allowSyntheticDefaultImports" | "allowUmdGlobalAccess" | "allowUnreachableCode" | "allowUnusedLabels" | "alwaysStrict" | "baseUrl" | "build" | "charset" | "checkJs" | "configFilePath" | "configFile" | "customConditions" | "declaration" | "declarationMap" | "emitDeclarationOnly" | "declarationDir" | "diagnostics" | "extendedDiagnostics" | "disableSizeLimit" | "disableSourceOfProjectReferenceRedirect" | "disableSolutionSearching" | "disableReferencedProjectLoad" | "downlevelIteration" | "emitBOM" | "emitDecoratorMetadata" | "exactOptionalPropertyTypes" | "experimentalDecorators" | "forceConsistentCasingInFileNames" | "generateCpuProfile" | "generateTrace" | "help" | "ignoreDeprecations" | "importHelpers" | "importsNotUsedAsValues" | "init" | "inlineSourceMap" | "inlineSources" | "isolatedDeclarations" | "keyofStringsOnly" | "lib" | "listEmittedFiles" | "listFiles" | "explainFiles" | "listFilesOnly" | "locale" | "mapRoot" | "maxNodeModuleJsDepth" | "module" | "moduleResolution" | "moduleSuffixes" | "moduleDetection" | "newLine" | "noEmit" | "noCheck" | "noEmitForJsFiles" | "noEmitHelpers" | "noEmitOnError" | "noErrorTruncation" | "noFallthroughCasesInSwitch" | "noImplicitAny" | "noImplicitReturns" | "noImplicitThis" | "noStrictGenericChecks" | "noUnusedLocals" | "noUnusedParameters" | "noImplicitUseStrict" | "noPropertyAccessFromIndexSignature" | "assumeChangesOnlyAffectDirectDependencies" | "noLib" | "noResolve" | "noDtsResolution" | "noUncheckedIndexedAccess" | "out" | "outDir" | "outFile" | "paths" | "pathsBasePath" | "plugins" | "preserveConstEnums" | "noImplicitOverride" | "preserveSymlinks" | "preserveValueImports" | "preserveWatchOutput" | "project" | "pretty" | "reactNamespace" | "jsxFactory" | "jsxFragmentFactory" | "jsxImportSource" | "composite" | "incremental" | "tsBuildInfoFile" | "removeComments" | "resolvePackageJsonExports" | "resolvePackageJsonImports" | "rootDir" | "rootDirs" | "skipLibCheck" | "skipDefaultLibCheck" | "sourceMap" | "sourceRoot" | "strict" | "strictFunctionTypes" | "strictBindCallApply" | "strictNullChecks" | "strictPropertyInitialization" | "strictBuiltinIteratorReturn" | "stripInternal" | "suppressExcessPropertyErrors" | "suppressImplicitAnyIndexErrors" | "suppressOutputPathCheck" | "target" | "traceResolution" | "useUnknownInCatchVariables" | "noUncheckedSideEffectImports" | "resolveJsonModule" | "types" | "typeRoots" | "version" | "watch" | "esModuleInterop" | "showConfig" | "useDefineForClassFields" | "tscBuild"))]: { dependencies: T[K]; computeValue: (compilerOptions: Pick<CompilerOptions, K | T[K][number]>) => Exclude<CompilerOptions[K], undefined>; }; } */ any {
	return options
}

var _computedOptions = createComputedCompilerOptions(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"target": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "module" */ any{"module"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "module" | "target"> */ any) /* TODO(TS-TO-GO) inferred type ScriptTarget.ES5 | ScriptTarget.ES2015 | ScriptTarget.ES2016 | ScriptTarget.ES2017 | ScriptTarget.ES2018 | ScriptTarget.ES2019 | ScriptTarget.ES2020 | ScriptTarget.ES2021 | ScriptTarget.ES2022 | ScriptTarget.ES2023 | ScriptTarget.ESNext | ScriptTarget.JSON */ any {
			var target * /* TODO(TS-TO-GO) inferred type ScriptTarget.ES5 | ScriptTarget.ES2015 | ScriptTarget.ES2016 | ScriptTarget.ES2017 | ScriptTarget.ES2018 | ScriptTarget.ES2019 | ScriptTarget.ES2020 | ScriptTarget.ES2021 | ScriptTarget.ES2022 | ScriptTarget.ES2023 | ScriptTarget.ESNext | ScriptTarget.JSON */ any
			if compilerOptions.target == ScriptTargetES3 {
				target = nil
			} else {
				target = compilerOptions.target
			}
			return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: target ?? ((compilerOptions.module === ModuleKind.Node16 && ScriptTarget.ES2022) || (compilerOptions.module === ModuleKind.NodeNext && ScriptTarget.ESNext) || ScriptTarget.ES5) */ TODO
		},
	},
	"module": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "target" */ any{"target"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "module" | "target"> */ any) ModuleKind {
			switch {
			case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof compilerOptions.module */ TODO == "number":
				return compilerOptions.module
			case _computedOptions.target.computeValue(compilerOptions) >= ScriptTargetES2015:
				return ModuleKindES2015
			default:
				return ModuleKindCommonJS
			}
		},
	},
	"moduleResolution": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "module" | "target" */ any{"module", "target"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "module" | "moduleResolution" | "target"> */ any) ModuleResolutionKind {
			moduleResolution := compilerOptions.moduleResolution
			if moduleResolution == nil {
				switch _computedOptions.module.computeValue(compilerOptions) {
				case ModuleKindCommonJS:
					moduleResolution = ModuleResolutionKindNode10
				case ModuleKindNode16:
					moduleResolution = ModuleResolutionKindNode16
				case ModuleKindNodeNext:
					moduleResolution = ModuleResolutionKindNodeNext
				case ModuleKindPreserve:
					moduleResolution = ModuleResolutionKindBundler
				default:
					moduleResolution = ModuleResolutionKindClassic
				}
			}
			return moduleResolution
		},
	},
	"moduleDetection": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "module" | "target" */ any{"module", "target"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "module" | "moduleDetection" | "target"> */ any) ModuleDetectionKind {
			return compilerOptions.moduleDetection || (__COND__(_computedOptions.module.computeValue(compilerOptions) == ModuleKindNode16 || _computedOptions.module.computeValue(compilerOptions) == ModuleKindNodeNext, ModuleDetectionKindForce, ModuleDetectionKindAuto))
		},
	},
	"isolatedModules": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "verbatimModuleSyntax" */ any{"verbatimModuleSyntax"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "verbatimModuleSyntax" | "isolatedModules"> */ any) bool {
			return !!(compilerOptions.isolatedModules || compilerOptions.verbatimModuleSyntax)
		},
	},
	"esModuleInterop": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "module" | "target" */ any{"module", "target"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "module" | "target" | "esModuleInterop"> */ any) bool {
			if compilerOptions.esModuleInterop != nil {
				return compilerOptions.esModuleInterop
			}
			switch _computedOptions.module.computeValue(compilerOptions) {
			case ModuleKindNode16,
				ModuleKindNodeNext,
				ModuleKindPreserve:
				return true
			}
			return false
		},
	},
	"allowSyntheticDefaultImports": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "module" | "moduleResolution" | "target" */ any{"module", "target", "moduleResolution"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "allowSyntheticDefaultImports" | "module" | "moduleResolution" | "target"> */ any) bool {
			if compilerOptions.allowSyntheticDefaultImports != nil {
				return compilerOptions.allowSyntheticDefaultImports
			}
			return _computedOptions.esModuleInterop.computeValue(compilerOptions) || _computedOptions.module.computeValue(compilerOptions) == ModuleKindSystem || _computedOptions.moduleResolution.computeValue(compilerOptions) == ModuleResolutionKindBundler
		},
	},
	"resolvePackageJsonExports": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "moduleResolution" */ any{"moduleResolution"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "moduleResolution" | "resolvePackageJsonExports"> */ any) bool {
			moduleResolution := _computedOptions.moduleResolution.computeValue(compilerOptions)
			if !moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution) {
				return false
			}
			if compilerOptions.resolvePackageJsonExports != nil {
				return compilerOptions.resolvePackageJsonExports
			}
			switch moduleResolution {
			case ModuleResolutionKindNode16,
				ModuleResolutionKindNodeNext,
				ModuleResolutionKindBundler:
				return true
			}
			return false
		},
	},
	"resolvePackageJsonImports": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "moduleResolution" | "resolvePackageJsonExports" */ any{"moduleResolution", "resolvePackageJsonExports"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "moduleResolution" | "resolvePackageJsonExports" | "resolvePackageJsonImports"> */ any) bool {
			moduleResolution := _computedOptions.moduleResolution.computeValue(compilerOptions)
			if !moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution) {
				return false
			}
			if compilerOptions.resolvePackageJsonExports != nil {
				return compilerOptions.resolvePackageJsonExports
			}
			switch moduleResolution {
			case ModuleResolutionKindNode16,
				ModuleResolutionKindNodeNext,
				ModuleResolutionKindBundler:
				return true
			}
			return false
		},
	},
	"resolveJsonModule": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "module" | "moduleResolution" | "target" */ any{"moduleResolution", "module", "target"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "module" | "moduleResolution" | "target" | "resolveJsonModule"> */ any) bool {
			if compilerOptions.resolveJsonModule != nil {
				return compilerOptions.resolveJsonModule
			}
			return _computedOptions.moduleResolution.computeValue(compilerOptions) == ModuleResolutionKindBundler
		},
	},
	"declaration": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "composite" */ any{"composite"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "declaration" | "composite"> */ any) bool {
			return !!(compilerOptions.declaration || compilerOptions.composite)
		},
	},
	"preserveConstEnums": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "verbatimModuleSyntax" | "isolatedModules" */ any{"isolatedModules", "verbatimModuleSyntax"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "verbatimModuleSyntax" | "isolatedModules" | "preserveConstEnums"> */ any) bool {
			return !!(compilerOptions.preserveConstEnums || _computedOptions.isolatedModules.computeValue(compilerOptions))
		},
	},
	"incremental": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "composite" */ any{"composite"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "composite" | "incremental"> */ any) bool {
			return !!(compilerOptions.incremental || compilerOptions.composite)
		},
	},
	"declarationMap": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "declaration" | "composite" */ any{"declaration", "composite"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "declaration" | "declarationMap" | "composite"> */ any) bool {
			return !!(compilerOptions.declarationMap && _computedOptions.declaration.computeValue(compilerOptions))
		},
	},
	"allowJs": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "checkJs" */ any{"checkJs"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "allowJs" | "checkJs"> */ any) bool {
			if compilerOptions.allowJs == nil {
				return !!compilerOptions.checkJs
			} else {
				return compilerOptions.allowJs
			}
		},
	},
	"useDefineForClassFields": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "module" | "target" */ any{"target", "module"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "module" | "target" | "useDefineForClassFields"> */ any) bool {
			if compilerOptions.useDefineForClassFields == nil {
				return _computedOptions.target.computeValue(compilerOptions) >= ScriptTargetES2022
			} else {
				return compilerOptions.useDefineForClassFields
			}
		},
	},
	"noImplicitAny": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "noImplicitAny" | "strict"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "noImplicitAny")
		},
	},
	"noImplicitThis": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "noImplicitThis" | "strict"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "noImplicitThis")
		},
	},
	"strictNullChecks": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "strict" | "strictNullChecks"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "strictNullChecks")
		},
	},
	"strictFunctionTypes": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "strict" | "strictFunctionTypes"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "strictFunctionTypes")
		},
	},
	"strictBindCallApply": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "strict" | "strictBindCallApply"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "strictBindCallApply")
		},
	},
	"strictPropertyInitialization": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "strict" | "strictPropertyInitialization"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
		},
	},
	"strictBuiltinIteratorReturn": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "strict" | "strictBuiltinIteratorReturn"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
		},
	},
	"alwaysStrict": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "alwaysStrict" | "strict"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "alwaysStrict")
		},
	},
	"useUnknownInCatchVariables": map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"dependencies": [] /* TODO(TS-TO-GO) inferred type "strict" */ any{"strict"},
		"computeValue": func(compilerOptions /* TODO(TS-TO-GO) inferred type Pick<CompilerOptions, "strict" | "useUnknownInCatchVariables"> */ any) bool {
			return getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
		},
	},
})

/** @internal */

var computedOptions Record[string /* TODO(TS-TO-GO) TypeNode TypeLiteral: { dependencies: readonly string[]; computeValue: (options: CompilerOptions) => CompilerOptionsValue; } */, any] = _computedOptions

/** @internal */

var getEmitScriptTarget func(compilerOptions CompilerOptions) ScriptTarget = _computedOptions.target.computeValue

/** @internal */

var getEmitModuleKind func(compilerOptions Pick[CompilerOptions /* TODO(TS-TO-GO) TypeNode UnionType: "module" | "target" */, any]) ModuleKind = _computedOptions.module.computeValue

/** @internal */

var getEmitModuleResolutionKind func(compilerOptions CompilerOptions) ModuleResolutionKind = _computedOptions.moduleResolution.computeValue

/** @internal @knipignore */

var getEmitModuleDetectionKind func(compilerOptions CompilerOptions) ModuleDetectionKind = _computedOptions.moduleDetection.computeValue

/** @internal */

var getIsolatedModules func(compilerOptions CompilerOptions) bool = _computedOptions.isolatedModules.computeValue

/** @internal */

var getESModuleInterop func(compilerOptions CompilerOptions) bool = _computedOptions.esModuleInterop.computeValue

/** @internal */

var getAllowSyntheticDefaultImports func(compilerOptions CompilerOptions) bool = _computedOptions.allowSyntheticDefaultImports.computeValue

/** @internal */

var getResolvePackageJsonExports func(compilerOptions CompilerOptions) bool = _computedOptions.resolvePackageJsonExports.computeValue

/** @internal */

var getResolvePackageJsonImports func(compilerOptions CompilerOptions) bool = _computedOptions.resolvePackageJsonImports.computeValue

/** @internal */

var getResolveJsonModule func(compilerOptions CompilerOptions) bool = _computedOptions.resolveJsonModule.computeValue

/** @internal */

var getEmitDeclarations func(compilerOptions CompilerOptions) bool = _computedOptions.declaration.computeValue

/** @internal */

var shouldPreserveConstEnums func(compilerOptions CompilerOptions) bool = _computedOptions.preserveConstEnums.computeValue

/** @internal */

var isIncrementalCompilation func(compilerOptions CompilerOptions) bool = _computedOptions.incremental.computeValue

/** @internal */

var getAreDeclarationMapsEnabled func(compilerOptions CompilerOptions) bool = _computedOptions.declarationMap.computeValue

/** @internal */

var getAllowJSCompilerOption func(compilerOptions CompilerOptions) bool = _computedOptions.allowJs.computeValue

/** @internal */

var getUseDefineForClassFields func(compilerOptions CompilerOptions) bool = _computedOptions.useDefineForClassFields.computeValue

/** @internal */

func emitModuleKindIsNonNodeESM(moduleKind ModuleKind) bool {
	return moduleKind >= ModuleKindES2015 && moduleKind <= ModuleKindESNext
}

/** @internal */

func hasJsonModuleEmitEnabled(options CompilerOptions) bool {
	switch getEmitModuleKind(options) {
	case ModuleKindNone,
		ModuleKindSystem,
		ModuleKindUMD:
		return false
	}
	return true
}

/** @internal */

func unreachableCodeIsError(options CompilerOptions) bool {
	return options.allowUnreachableCode == false
}

/** @internal */

func unusedLabelIsError(options CompilerOptions) bool {
	return options.allowUnusedLabels == false
}

/** @internal */

func moduleResolutionSupportsPackageJsonExportsAndImports(moduleResolution ModuleResolutionKind) bool {
	return moduleResolution >= ModuleResolutionKindNode16 && moduleResolution <= ModuleResolutionKindNodeNext || moduleResolution == ModuleResolutionKindBundler
}

/** @internal */

type StrictOptionName /* TODO(TS-TO-GO) TypeNode UnionType: | "noImplicitAny" | "noImplicitThis" | "strictNullChecks" | "strictFunctionTypes" | "strictBindCallApply" | "strictPropertyInitialization" | "strictBuiltinIteratorReturn" | "alwaysStrict" | "useUnknownInCatchVariables" */ any

/** @internal */

func getStrictOptionValue(compilerOptions CompilerOptions, flag StrictOptionName) bool {
	if compilerOptions[flag] == nil {
		return !!compilerOptions.strict
	} else {
		return !!compilerOptions[flag]
	}
}

/** @internal */

func getNameOfScriptTarget(scriptTarget ScriptTarget) *string {
	return forEachEntry(targetOptionDeclaration.type_, func(value /* TODO(TS-TO-GO) inferred type string | number */ any, key string) *string {
		if value == scriptTarget {
			return key
		} else {
			return nil
		}
	})
}

/** @internal */

func getEmitStandardClassFields(compilerOptions CompilerOptions) bool {
	return compilerOptions.useDefineForClassFields != false && getEmitScriptTarget(compilerOptions) >= ScriptTargetES2022
}

/** @internal */

func compilerOptionsAffectSemanticDiagnostics(newOptions CompilerOptions, oldOptions CompilerOptions) bool {
	return optionsHaveChanges(oldOptions, newOptions, semanticDiagnosticsOptionDeclarations)
}

/** @internal */

func compilerOptionsAffectEmit(newOptions CompilerOptions, oldOptions CompilerOptions) bool {
	return optionsHaveChanges(oldOptions, newOptions, affectsEmitOptionDeclarations)
}

/** @internal */

func compilerOptionsAffectDeclarationPath(newOptions CompilerOptions, oldOptions CompilerOptions) bool {
	return optionsHaveChanges(oldOptions, newOptions, affectsDeclarationPathOptionDeclarations)
}

/** @internal */

func getCompilerOptionValue(options CompilerOptions, option CommandLineOption) any {
	switch {
	case option.strictFlag:
		return getStrictOptionValue(options, option.name /* as StrictOptionName */)
	case option.allowJsFlag:
		return getAllowJSCompilerOption(options)
	default:
		return options[option.name]
	}
}

/** @internal */

func getJSXTransformEnabled(options CompilerOptions) bool {
	jsx := options.jsx
	return jsx == JsxEmitReact || jsx == JsxEmitReactJSX || jsx == JsxEmitReactJSXDev
}

/** @internal */

func getJSXImplicitImportBase(compilerOptions CompilerOptions, file SourceFile) *string {
	jsxImportSourcePragmas := file. /* ? */ pragmas.get("jsximportsource")
	var jsxImportSourcePragma * /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
	if isArray(jsxImportSourcePragmas) {
		jsxImportSourcePragma = jsxImportSourcePragmas[jsxImportSourcePragmas.length-1]
	} else {
		jsxImportSourcePragma = jsxImportSourcePragmas
	}
	jsxRuntimePragmas := file. /* ? */ pragmas.get("jsxruntime")
	var jsxRuntimePragma * /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
	if isArray(jsxRuntimePragmas) {
		jsxRuntimePragma = jsxRuntimePragmas[jsxRuntimePragmas.length-1]
	} else {
		jsxRuntimePragma = jsxRuntimePragmas
	}
	if jsxRuntimePragma. /* ? */ arguments.factory == "classic" {
		return nil
	}
	if compilerOptions.jsx == JsxEmitReactJSX || compilerOptions.jsx == JsxEmitReactJSXDev || compilerOptions.jsxImportSource || jsxImportSourcePragma || jsxRuntimePragma. /* ? */ arguments.factory == "automatic" {
		return jsxImportSourcePragma. /* ? */ arguments.factory || compilerOptions.jsxImportSource || "react"
	} else {
		return nil
	}
}

/** @internal */

func getJSXRuntimeImport(base *string, options CompilerOptions) *string {
	if base {
		return __TEMPLATE__(base, "/", __COND__(options.jsx == JsxEmitReactJSXDev, "jsx-dev-runtime", "jsx-runtime"))
	} else {
		return nil
	}
}

/** @internal */

func hasZeroOrOneAsteriskCharacter(str string) bool {
	seenAsterisk := false
	for i := 0; i < str.length; i++ {
		if str.charCodeAt(i) == CharacterCodesasterisk {
			if !seenAsterisk {
				seenAsterisk = true
			} else {
				// have already seen asterisk
				return false
			}
		}
	}
	return true
}

/** @internal */

type SymlinkedDirectory struct {
	real     string
	realPath Path
}

/** @internal */

type SymlinkCache struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */ /* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SymlinkCache { /** Gets a map from symlink to realpath. Keys have trailing directory separators. * / getSymlinkedDirectories(): ReadonlyMap<Path, SymlinkedDirectory | false> | undefined; /** Gets a map from realpath to symlinks. Keys have trailing directory separators. * / getSymlinkedDirectoriesByRealpath(): MultiMap<Path, string> | undefined; /** Gets a map from symlink to realpath * / getSymlinkedFiles(): ReadonlyMap<Path, string> | undefined; setSymlinkedDirectory(symlink: string, real: SymlinkedDirectory | false): void; setSymlinkedFile(symlinkPath: Path, real: string): void; hasAnySymlinks(): boolean; /** * @internal * Uses resolvedTypeReferenceDirectives from program instead of from files, since files * don't include automatic type reference directives. Must be called only when * `hasProcessedResolutions` returns false (once per cache instance). * / setSymlinksFromResolutions( forEachResolvedModule: ( callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, forEachResolvedTypeReferenceDirective: ( callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void, ) => void, typeReferenceDirectives: ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations>, ): void; setSymlinksFromResolution(resolution: ResolvedModuleFull | undefined): void; /** * @internal * Whether `setSymlinksFromResolutions` has already been called. * / hasProcessedResolutions(): boolean; } */
}

/** @internal */

func createSymlinkCache(cwd string, getCanonicalFileName GetCanonicalFileName) SymlinkCache {
	var symlinkedDirectories *Map[Path /* TODO(TS-TO-GO) TypeNode UnionType: SymlinkedDirectory | false */, any]
	var symlinkedDirectoriesByRealpath *MultiMap[Path, string]
	var symlinkedFiles *Map[Path, string]
	hasProcessedResolutions := false
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getSymlinkedFiles": func() *Map[Path, string] {
			return symlinkedFiles
		},
		"getSymlinkedDirectories": func() *Map[Path /* TODO(TS-TO-GO) inferred type false | SymlinkedDirectory */, any] {
			return symlinkedDirectories
		},
		"getSymlinkedDirectoriesByRealpath": func() * /* TODO(TS-TO-GO) inferred type MultiMap<Path, string> */ any {
			return symlinkedDirectoriesByRealpath
		},
		"setSymlinkedFile": func(path Path, real string) Map[any, any] {
			return (symlinkedFiles || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symlinkedFiles = new Map() */ TODO)).set(path, real)
		},
		"setSymlinkedDirectory": func(symlink string, real /* TODO(TS-TO-GO) inferred type false | SymlinkedDirectory */ any) {
			// Large, interconnected dependency graphs in pnpm will have a huge number of symlinks
			// where both the realpath and the symlink path are inside node_modules/.pnpm. Since
			// this path is never a candidate for a module specifier, we can ignore it entirely.
			symlinkPath := toPath(symlink, cwd, getCanonicalFileName)
			if !containsIgnoredPath(symlinkPath) {
				symlinkPath = ensureTrailingDirectorySeparator(symlinkPath)
				if real != false && !symlinkedDirectories. /* ? */ has(symlinkPath) {
					( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: symlinkedDirectoriesByRealpath ||= createMultiMap() */ TODO).add(real.realPath, symlink)
				}
				(symlinkedDirectories || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: symlinkedDirectories = new Map() */ TODO)).set(symlinkPath, real)
			}
		},
		"setSymlinksFromResolutions": func(forEachResolvedModule /* TODO(TS-TO-GO) inferred type (callback: (resolution: ResolvedModuleWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void) => void */ any, forEachResolvedTypeReferenceDirective /* TODO(TS-TO-GO) inferred type (callback: (resolution: ResolvedTypeReferenceDirectiveWithFailedLookupLocations, moduleName: string, mode: ResolutionMode, filePath: Path) => void) => void */ any, typeReferenceDirectives /* TODO(TS-TO-GO) inferred type ModeAwareCache<ResolvedTypeReferenceDirectiveWithFailedLookupLocations> */ any) {
			Debug.assert(!hasProcessedResolutions)
			hasProcessedResolutions = true
			forEachResolvedModule(func(resolution ResolvedModuleWithFailedLookupLocations) {
				return processResolution(this, resolution.resolvedModule)
			})
			forEachResolvedTypeReferenceDirective(func(resolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations) {
				return processResolution(this, resolution.resolvedTypeReferenceDirective)
			})
			typeReferenceDirectives.forEach(func(resolution ResolvedTypeReferenceDirectiveWithFailedLookupLocations) {
				return processResolution(this, resolution.resolvedTypeReferenceDirective)
			})
		},
		"hasProcessedResolutions": func() bool {
			return hasProcessedResolutions
		},
		"setSymlinksFromResolution": func(resolution *ResolvedModuleFull) {
			processResolution(this, resolution)
		},
		"hasAnySymlinks": hasAnySymlinks,
	}

	hasAnySymlinks := func() bool {
		return !!symlinkedFiles. /* ? */ size || (!!symlinkedDirectories && !!forEachEntry(symlinkedDirectories, func(value /* TODO(TS-TO-GO) inferred type false | SymlinkedDirectory */ any) bool {
			return !!value
		}))
	}

	processResolution := func(cache SymlinkCache, resolution /* TODO(TS-TO-GO) TypeNode UnionType: ResolvedModuleFull | ResolvedTypeReferenceDirective | undefined */ any) {
		if !resolution || !resolution.originalPath || !resolution.resolvedFileName {
			return
		}
		TODO_IDENTIFIER := resolution
		cache.setSymlinkedFile(toPath(originalPath, cwd, getCanonicalFileName), resolvedFileName)
		TODO_IDENTIFIER := guessDirectorySymlink(resolvedFileName, originalPath, cwd, getCanonicalFileName) || emptyArray
		if commonResolved && commonOriginal {
			cache.setSymlinkedDirectory(commonOriginal, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"real":     ensureTrailingDirectorySeparator(commonResolved),
				"realPath": ensureTrailingDirectorySeparator(toPath(commonResolved, cwd, getCanonicalFileName)),
			})
		}
	}

}

func guessDirectorySymlink(a string, b string, cwd string, getCanonicalFileName GetCanonicalFileName) * /* TODO(TS-TO-GO) TypeNode TupleType: [string, string] */ any {
	aParts := getPathComponents(getNormalizedAbsolutePath(a, cwd))
	bParts := getPathComponents(getNormalizedAbsolutePath(b, cwd))
	isDirectory := false
	for aParts.length >= 2 && bParts.length >= 2 && !isNodeModulesOrScopedPackageDirectory(aParts[aParts.length-2], getCanonicalFileName) && !isNodeModulesOrScopedPackageDirectory(bParts[bParts.length-2], getCanonicalFileName) && getCanonicalFileName(aParts[aParts.length-1]) == getCanonicalFileName(bParts[bParts.length-1]) {
		aParts.pop()
		bParts.pop()
		isDirectory = true
	}
	if isDirectory {
		return []any{getPathFromPathComponents(aParts), getPathFromPathComponents(bParts)}
	} else {
		return nil
	}
}

// KLUDGE: Don't assume one 'node_modules' links to another. More likely a single directory inside the node_modules is the symlink.
// ALso, don't assume that an `@foo` directory is linked. More likely the contents of that are linked.
func isNodeModulesOrScopedPackageDirectory(s *string, getCanonicalFileName GetCanonicalFileName) bool {
	return s != nil && (getCanonicalFileName(s) == "node_modules" || startsWith(s, "@"))
}

func stripLeadingDirectorySeparator(s string) *string {
	if isAnyDirectorySeparator(s.charCodeAt(0)) {
		return s.slice(1)
	} else {
		return nil
	}
}

/** @internal */

func tryRemoveDirectoryPrefix(path string, dirPath string, getCanonicalFileName GetCanonicalFileName) *string {
	withoutPrefix := tryRemovePrefix(path, dirPath, getCanonicalFileName)
	if withoutPrefix == nil {
		return nil
	} else {
		return stripLeadingDirectorySeparator(withoutPrefix)
	}
}

// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.
// It may be inefficient (we could just match (/[-[\]{}()*+?.,\\^$|#\s]/g), but this is future
// proof.
var reservedCharacterPattern = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /[^\w\s/]/g */ TODO

/** @internal */

func regExpEscape(text string) string {
	return text.replace(reservedCharacterPattern, escapeRegExpCharacter)
}

func escapeRegExpCharacter(match string) string {
	return "\\" + match
}

var wildcardCharCodes = []CharacterCodes{CharacterCodesasterisk, CharacterCodesquestion}

var commonPackageFolders []string = []string{"node_modules", "bower_components", "jspm_packages"}

var implicitExcludePathRegexPattern = __TEMPLATE__("(?!(", commonPackageFolders.join("|"), ")(/|$))")

/** @internal */

type WildcardMatcher struct {
	singleAsteriskRegexFragment string
	doubleAsteriskRegexFragment string
	replaceWildcardCharacter    func(match string) string
}

var filesMatcher WildcardMatcher = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	/**
	 * Matches any single directory segment unless it is the last segment and a .min.js file
	 * Breakdown:
	 *  [^./]                   # matches everything up to the first . character (excluding directory separators)
	 *  (\\.(?!min\\.js$))?     # matches . characters but not if they are part of the .min.js file extension
	 */
	"singleAsteriskRegexFragment": "([^./]|(\\.(?!min\\.js$))?)*",
	/**
	 * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
	 * files or directories, does not match subdirectories that start with a . character
	 */
	"doubleAsteriskRegexFragment": __TEMPLATE__("(/", implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
	"replaceWildcardCharacter": func(match string) string {
		return replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment)
	},
}

var directoriesMatcher WildcardMatcher = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"singleAsteriskRegexFragment": "[^/]*",
	/**
	 * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
	 * files or directories, does not match subdirectories that start with a . character
	 */
	"doubleAsteriskRegexFragment": __TEMPLATE__("(/", implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
	"replaceWildcardCharacter": func(match string) string {
		return replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)
	},
}

var excludeMatcher WildcardMatcher = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"singleAsteriskRegexFragment": "[^/]*",
	"doubleAsteriskRegexFragment": "(/.+?)?",
	"replaceWildcardCharacter": func(match string) string {
		return replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)
	},
}

var wildcardMatchers = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"files":       filesMatcher,
	"directories": directoriesMatcher,
	"exclude":     excludeMatcher,
}

/** @internal */

func getRegularExpressionForWildcard(specs *[]string, basePath string, usage /* TODO(TS-TO-GO) TypeNode UnionType: "files" | "directories" | "exclude" */ any) *string {
	patterns := getRegularExpressionsForWildcards(specs, basePath, usage)
	if !patterns || !patterns.length {
		return nil
	}

	pattern := patterns.map_(func(pattern string) string {
		return __TEMPLATE__("(", pattern, ")")
	}).join("|")
	// If excluding, match "foo/bar/baz...", but if including, only allow "foo".
	var terminator /* TODO(TS-TO-GO) inferred type "($|/)" | "$" */ any
	if usage == "exclude" {
		terminator = "($|/)"
	} else {
		terminator = "$"
	}
	return __TEMPLATE__("^(", pattern, ")", terminator)
}

/** @internal */

func getRegularExpressionsForWildcards(specs *[]string, basePath string, usage /* TODO(TS-TO-GO) TypeNode UnionType: "files" | "directories" | "exclude" */ any) *[]string {
	if specs == nil || specs.length == 0 {
		return nil
	}

	return flatMap(specs, func(spec string) *string {
		return spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage])
	})
}

/**
 * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
 * and does not contain any glob characters itself.
 *
 * @internal
 */

func isImplicitGlob(lastPathComponent string) bool {
	return !regexp.MustParse(`[.*?]`).test(lastPathComponent)
}

/** @internal */

func getPatternFromSpec(spec string, basePath string, usage /* TODO(TS-TO-GO) TypeNode UnionType: "files" | "directories" | "exclude" */ any) *string {
	pattern := spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage])
	return pattern && __TEMPLATE__("^(", pattern, ")", __COND__(usage == "exclude", "($|/)", "$"))
}

/** @internal */

func getSubPatternFromSpec(spec string, basePath string, usage /* TODO(TS-TO-GO) TypeNode UnionType: "files" | "directories" | "exclude" */ any, TODO_IDENTIFIER WildcardMatcher /*  = wildcardMatchers[usage] */) *string {
	subpattern := ""
	hasWrittenComponent := false
	components := getNormalizedPathComponents(spec, basePath)
	lastComponent := last(components)
	if usage != "exclude" && lastComponent == "**" {
		return nil
	}

	// getNormalizedPathComponents includes the separator for the root component.
	// We need to remove to create our regex correctly.
	components[0] = removeTrailingDirectorySeparator(components[0])

	if isImplicitGlob(lastComponent) {
		components.push("**", "*")
	}

	optionalCount := 0
	for _, component := range components {
		if component == "**" {
			subpattern += doubleAsteriskRegexFragment
		} else {
			if usage == "directories" {
				subpattern += "("
				optionalCount++
			}

			if hasWrittenComponent {
				subpattern += directorySeparator
			}

			if usage != "exclude" {
				componentPattern := ""
				// The * and ? wildcards should not match directories or files that start with . if they
				// appear first in a component. Dotted directories and files can be included explicitly
				// like so: **/.*/.*
				if component.charCodeAt(0) == CharacterCodesasterisk {
					componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?"
					component = component.substr(1)
				} else if component.charCodeAt(0) == CharacterCodesquestion {
					componentPattern += "[^./]"
					component = component.substr(1)
				}

				componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter)

				// Patterns should not include subfolders like node_modules unless they are
				// explicitly included as part of the path.
				//
				// As an optimization, if the component pattern is the same as the component,
				// then there definitely were no wildcard characters and we do not need to
				// add the exclusion pattern.
				if componentPattern != component {
					subpattern += implicitExcludePathRegexPattern
				}

				subpattern += componentPattern
			} else {
				subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter)
			}
		}

		hasWrittenComponent = true
	}

	for optionalCount > 0 {
		subpattern += ")?"
		optionalCount--
	}

	return subpattern
}

func replaceWildcardCharacter(match string, singleAsteriskRegexFragment string) string {
	switch {
	case match == "*":
		return singleAsteriskRegexFragment
	case match == "?":
		return "[^/]"
	default:
		return "\\" + match
	}
}

/** @internal */

type FileSystemEntries struct {
	files       []string
	directories []string
}

/** @internal */

type FileMatcherPatterns struct {
	includeFilePatterns     *[]string
	includeFilePattern      *string
	includeDirectoryPattern *string
	excludePattern          *string
	basePaths               []string
}

/**
 * @param path directory of the tsconfig.json
 *
 * @internal
 */

func getFileMatcherPatterns(path string, excludes *[]string, includes *[]string, useCaseSensitiveFileNames bool, currentDirectory string) FileMatcherPatterns {
	path = normalizePath(path)
	currentDirectory = normalizePath(currentDirectory)
	absolutePath := combinePaths(currentDirectory, path)

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"includeFilePatterns": map_(getRegularExpressionsForWildcards(includes, absolutePath, "files"), func(pattern string) string {
			return __TEMPLATE__("^", pattern, "$")
		}),
		"includeFilePattern":      getRegularExpressionForWildcard(includes, absolutePath, "files"),
		"includeDirectoryPattern": getRegularExpressionForWildcard(includes, absolutePath, "directories"),
		"excludePattern":          getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
		"basePaths":               getBasePaths(path, includes, useCaseSensitiveFileNames),
	}
}

/** @internal */

func getRegexFromPattern(pattern string, useCaseSensitiveFileNames bool) RegExp {
	return NewRegExp(pattern, __COND__(useCaseSensitiveFileNames, "", "i"))
}

/**
 * @param path directory of the tsconfig.json
 *
 * @internal
 */

func matchFiles(path string, extensions *[]string, excludes *[]string, includes *[]string, useCaseSensitiveFileNames bool, currentDirectory string, depth *number, getFileSystemEntries func(path string) FileSystemEntries, realpath func(path string) string) []string {
	path = normalizePath(path)
	currentDirectory = normalizePath(currentDirectory)

	patterns := getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory)

	includeFileRegexes := patterns.includeFilePatterns && patterns.includeFilePatterns.map_(func(pattern string) RegExp {
		return getRegexFromPattern(pattern, useCaseSensitiveFileNames)
	})
	includeDirectoryRegex := patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames)
	excludeRegex := patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames)

	// Associate an array of results with each include regex. This keeps results in order of the "include" order.
	// If there are no "includes", then just put everything in results[0].
	var results [][]string
	if includeFileRegexes {
		results = includeFileRegexes.map_(func() []never {
			return []never{}
		})
	} else {
		results = [][]never{[]never{}}
	}
	visited := NewMap[string /* TODO(TS-TO-GO) TypeNode LiteralType: true */, any]()
	toCanonical := createGetCanonicalFileName(useCaseSensitiveFileNames)
	for _, basePath := range patterns.basePaths {
		visitDirectory(basePath, combinePaths(currentDirectory, basePath), depth)
	}

	return flatten(results)

	visitDirectory := func(path string, absolutePath string, depth *number) {
		canonicalPath := toCanonical(realpath(absolutePath))
		if visited.has(canonicalPath) {
			return
		}
		visited.set(canonicalPath, true)
		TODO_IDENTIFIER := getFileSystemEntries(path)

		for _, current := range toSorted(files, compareStringsCaseSensitive) {
			name := combinePaths(path, current)
			absoluteName := combinePaths(absolutePath, current)
			if extensions && !fileExtensionIsOneOf(name, extensions) {
				continue
			}
			if excludeRegex && excludeRegex.test(absoluteName) {
				continue
			}
			if !includeFileRegexes {
				results[0].push(name)
			} else {
				includeIndex := findIndex(includeFileRegexes, func(re RegExp) bool {
					return re.test(absoluteName)
				})
				if includeIndex != -1 {
					results[includeIndex].push(name)
				}
			}
		}

		if depth != nil {
			depth--
			if depth == 0 {
				return
			}
		}

		for _, current := range toSorted(directories, compareStringsCaseSensitive) {
			name := combinePaths(path, current)
			absoluteName := combinePaths(absolutePath, current)
			if (!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) && (!excludeRegex || !excludeRegex.test(absoluteName)) {
				visitDirectory(name, absoluteName, depth)
			}
		}
	}

}

/**
 * Computes the unique non-wildcard base paths amongst the provided include patterns.
 */

func getBasePaths(path string, includes *[]string, useCaseSensitiveFileNames bool) []string {
	// Storage for our results in the form of literal paths (e.g. the paths as written by the user).
	var basePaths []string = []string{path}

	if includes {
		// Storage for literal base paths amongst the include patterns.
		var includeBasePaths []string = []never{}
		for _, include := range includes {
			// We also need to check the relative paths by converting them to absolute and normalizing
			// in case they escape the base path (e.g "..\somedirectory")
			var absolute string
			if isRootedDiskPath(include) {
				absolute = include
			} else {
				absolute = normalizePath(combinePaths(path, include))
			}
			// Append the literal and canonical candidate base paths.
			includeBasePaths.push(getIncludeBasePath(absolute))
		}

		// Sort the offsets array using either the literal or canonical path representations.
		includeBasePaths.sort(getStringComparer(!useCaseSensitiveFileNames))

		// Iterate over each include base path and include unique base paths that are not a
		// subpath of an existing base path
		for _, includeBasePath := range includeBasePaths {
			if every(basePaths, func(basePath string) bool {
				return !containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames)
			}) {
				basePaths.push(includeBasePath)
			}
		}
	}

	return basePaths
}

func getIncludeBasePath(absolute string) string {
	wildcardOffset := indexOfAnyCharCode(absolute, wildcardCharCodes)
	if wildcardOffset < 0 {
		// No "*" or "?" in the path
		if !hasExtension(absolute) {
			return absolute
		} else {
			return removeTrailingDirectorySeparator(getDirectoryPath(absolute))
		}
	}
	return absolute.substring(0, absolute.lastIndexOf(directorySeparator, wildcardOffset))
}

/** @internal */

func ensureScriptKind(fileName string, scriptKind *ScriptKind) ScriptKind {
	// Using scriptKind as a condition handles both:
	// - 'scriptKind' is unspecified and thus it is `undefined`
	// - 'scriptKind' is set and it is `Unknown` (0)
	// If the 'scriptKind' is 'undefined' or 'Unknown' then we attempt
	// to get the ScriptKind from the file name. If it cannot be resolved
	// from the file name then the default 'TS' script kind is returned.
	return scriptKind || getScriptKindFromFileName(fileName) || ScriptKindTS
}

/** @internal */

func getScriptKindFromFileName(fileName string) ScriptKind {
	ext := fileName.substr(fileName.lastIndexOf("."))
	switch ext.toLowerCase() {
	case ExtensionJs,
		ExtensionCjs,
		ExtensionMjs:
		return ScriptKindJS
	case ExtensionJsx:
		return ScriptKindJSX
	case ExtensionTs,
		ExtensionCts,
		ExtensionMts:
		return ScriptKindTS
	case ExtensionTsx:
		return ScriptKindTSX
	case ExtensionJson:
		return ScriptKindJSON
	default:
		return ScriptKindUnknown
	}
}

/**
 *  Groups of supported extensions in order of file resolution precedence. (eg, TS > TSX > DTS and seperately, CTS > DCTS)
 */

var supportedTSExtensions [][]Extension = [][] /* TODO(TS-TO-GO) inferred type (Extension.Ts | Extension.Tsx | Extension.Dts)[] | (Extension.Cts | Extension.Dcts)[] | (Extension.Mts | Extension.Dmts) */ any{[] /* TODO(TS-TO-GO) inferred type Extension.Ts | Extension.Tsx | Extension.Dts */ any{ExtensionTs, ExtensionTsx, ExtensionDts}, [] /* TODO(TS-TO-GO) inferred type Extension.Cts | Extension.Dcts */ any{ExtensionCts, ExtensionDcts}, [] /* TODO(TS-TO-GO) inferred type Extension.Mts | Extension.Dmts */ any{ExtensionMts, ExtensionDmts}}

/** @internal */

var supportedTSExtensionsFlat []Extension = flatten(supportedTSExtensions)
var supportedTSExtensionsWithJson [][]Extension = [][]Extension{ /* TODO(TS-TO-GO) Node SpreadElement: ...supportedTSExtensions */ [] /* TODO(TS-TO-GO) inferred type Extension.Json */ any{ExtensionJson}}

/** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */

var supportedTSExtensionsForExtractExtension []Extension = [] /* TODO(TS-TO-GO) inferred type Extension.Ts | Extension.Tsx | Extension.Dts | Extension.Mts | Extension.Dmts | Extension.Cts | Extension.Dcts */ any{ExtensionDts, ExtensionDcts, ExtensionDmts, ExtensionCts, ExtensionMts, ExtensionTs, ExtensionTsx}
var supportedJSExtensions [][]Extension = [][] /* TODO(TS-TO-GO) inferred type (Extension.Js | Extension.Jsx)[] | Extension.Mjs[] | Extension.Cjs */ any{[] /* TODO(TS-TO-GO) inferred type Extension.Js | Extension.Jsx */ any{ExtensionJs, ExtensionJsx}, [] /* TODO(TS-TO-GO) inferred type Extension.Mjs */ any{ExtensionMjs}, [] /* TODO(TS-TO-GO) inferred type Extension.Cjs */ any{ExtensionCjs}}

/** @internal */

var supportedJSExtensionsFlat []Extension = flatten(supportedJSExtensions)
var allSupportedExtensions [][]Extension = [][] /* TODO(TS-TO-GO) inferred type (Extension.Ts | Extension.Tsx | Extension.Dts | Extension.Js | Extension.Jsx)[] | (Extension.Cjs | Extension.Cts | Extension.Dcts)[] | (Extension.Mjs | Extension.Mts | Extension.Dmts) */ any{[] /* TODO(TS-TO-GO) inferred type Extension.Ts | Extension.Tsx | Extension.Dts | Extension.Js | Extension.Jsx */ any{ExtensionTs, ExtensionTsx, ExtensionDts, ExtensionJs, ExtensionJsx}, [] /* TODO(TS-TO-GO) inferred type Extension.Cjs | Extension.Cts | Extension.Dcts */ any{ExtensionCts, ExtensionDcts, ExtensionCjs}, [] /* TODO(TS-TO-GO) inferred type Extension.Mjs | Extension.Mts | Extension.Dmts */ any{ExtensionMts, ExtensionDmts, ExtensionMjs}}
var allSupportedExtensionsWithJson [][]Extension = [][]Extension{ /* TODO(TS-TO-GO) Node SpreadElement: ...allSupportedExtensions */ [] /* TODO(TS-TO-GO) inferred type Extension.Json */ any{ExtensionJson}}

/** @internal */

var supportedDeclarationExtensions []Extension = [] /* TODO(TS-TO-GO) inferred type Extension.Dts | Extension.Dmts | Extension.Dcts */ any{ExtensionDts, ExtensionDcts, ExtensionDmts}

/** @internal */

var supportedTSImplementationExtensions []Extension = [] /* TODO(TS-TO-GO) inferred type Extension.Ts | Extension.Tsx | Extension.Mts | Extension.Cts */ any{ExtensionTs, ExtensionCts, ExtensionMts, ExtensionTsx}

/** @internal */

var extensionsNotSupportingExtensionlessResolution []Extension = [] /* TODO(TS-TO-GO) inferred type Extension.Mjs | Extension.Mts | Extension.Dmts | Extension.Cjs | Extension.Cts | Extension.Dcts */ any{ExtensionMts, ExtensionDmts, ExtensionMjs, ExtensionCts, ExtensionDcts, ExtensionCjs}

/** @internal */

/* OVERLOAD: export function getSupportedExtensions(options?: CompilerOptions): readonly Extension[][]; */
/** @internal */

/* OVERLOAD: export function getSupportedExtensions(options?: CompilerOptions, extraFileExtensions?: readonly FileExtensionInfo[]): readonly string[][]; */
/** @internal */

func getSupportedExtensions(options CompilerOptions, extraFileExtensions []FileExtensionInfo) [][]string {
	needJsExtensions := options && getAllowJSCompilerOption(options)

	if !extraFileExtensions || extraFileExtensions.length == 0 {
		if needJsExtensions {
			return allSupportedExtensions
		} else {
			return supportedTSExtensions
		}
	}

	var builtins [][]Extension
	if needJsExtensions {
		builtins = allSupportedExtensions
	} else {
		builtins = supportedTSExtensions
	}
	flatBuiltins := flatten(builtins)
	extensions := [][]string{ /* TODO(TS-TO-GO) Node SpreadElement: ...builtins */ /* TODO(TS-TO-GO) Node SpreadElement: ...mapDefined(extraFileExtensions, x => x.scriptKind === ScriptKind.Deferred || needJsExtensions && isJSLike(x.scriptKind) && !flatBuiltins.includes(x.extension as Extension) ? [x.extension] : undefined) */ }

	return extensions
}

/** @internal */

/* OVERLOAD: export function getSupportedExtensionsWithJsonIfResolveJsonModule(options: CompilerOptions | undefined, supportedExtensions: readonly Extension[][]): readonly Extension[][]; */
/** @internal */

/* OVERLOAD: export function getSupportedExtensionsWithJsonIfResolveJsonModule(options: CompilerOptions | undefined, supportedExtensions: readonly string[][]): readonly string[][]; */
/** @internal */

func getSupportedExtensionsWithJsonIfResolveJsonModule(options *CompilerOptions, supportedExtensions [][]string) [][]string {
	if !options || !getResolveJsonModule(options) {
		return supportedExtensions
	}
	if supportedExtensions == allSupportedExtensions {
		return allSupportedExtensionsWithJson
	}
	if supportedExtensions == supportedTSExtensions {
		return supportedTSExtensionsWithJson
	}
	return [][]string{ /* TODO(TS-TO-GO) Node SpreadElement: ...supportedExtensions */ []Extension{ExtensionJson}}
}

func isJSLike(scriptKind *ScriptKind) bool {
	return scriptKind == ScriptKindJS || scriptKind == ScriptKindJSX
}

/** @internal */

func hasJSFileExtension(fileName string) bool {
	return some(supportedJSExtensionsFlat, func(extension Extension) bool {
		return fileExtensionIs(fileName, extension)
	})
}

/** @internal */

func hasTSFileExtension(fileName string) bool {
	return some(supportedTSExtensionsFlat, func(extension Extension) bool {
		return fileExtensionIs(fileName, extension)
	})
}

/** @internal */

func hasImplementationTSFileExtension(fileName string) bool {
	return some(supportedTSImplementationExtensions, func(extension Extension) bool {
		return fileExtensionIs(fileName, extension)
	}) && !isDeclarationFileName(fileName)
}

/**
 * @internal
 * Corresponds to UserPreferences#importPathEnding
 */

type ModuleSpecifierEnding int32

const (
	ModuleSpecifierEndingMinimal ModuleSpecifierEnding = iota
	ModuleSpecifierEndingIndex
	ModuleSpecifierEndingJsExtension
	ModuleSpecifierEndingTsExtension
)

func usesExtensionsOnImports(TODO_IDENTIFIER SourceFile, hasExtension func(text string) bool /*  = or(hasJSFileExtension, hasTSFileExtension) */) bool {
	return firstDefined(imports, func(TODO_IDENTIFIER StringLiteralLike) *bool {
		if pathIsRelative(text) && !fileExtensionIsOneOf(text, extensionsNotSupportingExtensionlessResolution) {
			return hasExtension(text)
		} else {
			return nil
		}
	}) || false
}

/** @internal */

func getModuleSpecifierEndingPreference(preference /* TODO(TS-TO-GO) TypeNode IndexedAccessType: UserPreferences["importModuleSpecifierEnding"] */ any, resolutionMode ResolutionMode, compilerOptions CompilerOptions, sourceFile SourceFile) ModuleSpecifierEnding {
	moduleResolution := getEmitModuleResolutionKind(compilerOptions)
	moduleResolutionIsNodeNext := ModuleResolutionKindNode16 <= moduleResolution && moduleResolution <= ModuleResolutionKindNodeNext
	if preference == "js" || resolutionMode == ModuleKindESNext && moduleResolutionIsNodeNext {
		// Extensions are explicitly requested or required. Now choose between .js and .ts.
		if !shouldAllowImportingTsExtension(compilerOptions) {
			return ModuleSpecifierEndingJsExtension
		}
		// `allowImportingTsExtensions` is a strong signal, so use .ts unless the file
		// already uses .js extensions and no .ts extensions.
		if inferPreference() != ModuleSpecifierEndingJsExtension {
			return ModuleSpecifierEndingTsExtension
		} else {
			return ModuleSpecifierEndingJsExtension
		}
	}
	if preference == "minimal" {
		return ModuleSpecifierEndingMinimal
	}
	if preference == "index" {
		return ModuleSpecifierEndingIndex
	}

	// No preference was specified.
	// Look at imports and/or requires to guess whether .js, .ts, or extensionless imports are preferred.
	// N.B. that `Index` detection is not supported since it would require file system probing to do
	// accurately, and more importantly, literally nobody wants `Index` and its existence is a mystery.
	if !shouldAllowImportingTsExtension(compilerOptions) {
		// If .ts imports are not valid, we only need to see one .js import to go with that.
		if sourceFile && usesExtensionsOnImports(sourceFile) {
			return ModuleSpecifierEndingJsExtension
		} else {
			return ModuleSpecifierEndingMinimal
		}
	}

	return inferPreference()

	inferPreference := func() /* TODO(TS-TO-GO) inferred type ModuleSpecifierEnding.Minimal | ModuleSpecifierEnding.JsExtension | ModuleSpecifierEnding.TsExtension */ any {
		usesJsExtensions := false
		var specifiers []StringLiteralLike
		switch {
		case sourceFile. /* ? */ imports.length:
			specifiers = sourceFile.imports
		case sourceFile && isSourceFileJS(sourceFile):
			specifiers = getRequiresAtTopOfFile(sourceFile).map_(func(r RequireOrImportCall) StringLiteralLike {
				return r.arguments[0]
			})
		default:
			specifiers = emptyArray
		}
		for _, specifier := range specifiers {
			if pathIsRelative(specifier.text) {
				if moduleResolutionIsNodeNext && resolutionMode == ModuleKindCommonJS && getModeForUsageLocation(sourceFile, specifier, compilerOptions) == ModuleKindESNext {
					// We're trying to decide a preference for a CommonJS module specifier, but looking at an ESM import.
					continue
				}
				if fileExtensionIsOneOf(specifier.text, extensionsNotSupportingExtensionlessResolution) {
					// These extensions are not optional, so do not indicate a preference.
					continue
				}
				if hasTSFileExtension(specifier.text) {
					return ModuleSpecifierEndingTsExtension
				}
				if hasJSFileExtension(specifier.text) {
					usesJsExtensions = true
				}
			}
		}
		if usesJsExtensions {
			return ModuleSpecifierEndingJsExtension
		} else {
			return ModuleSpecifierEndingMinimal
		}
	}

}

func getRequiresAtTopOfFile(sourceFile SourceFile) []RequireOrImportCall {
	nonRequireStatementCount := 0
	var requires *[]RequireOrImportCall
	for _, statement := range sourceFile.statements {
		if nonRequireStatementCount > 3 {
			break
		}
		if isRequireVariableStatement(statement) {
			requires = concatenate(requires, statement.declarationList.declarations.map_(func(d /* TODO(TS-TO-GO) inferred type VariableDeclarationInitializedTo<RequireOrImportCall> */ any) RequireOrImportCall {
				return d.initializer
			}))
		} else if isExpressionStatement(statement) && isRequireCall(statement.expression /*requireStringLiteralLikeArgument*/, true) {
			requires = append(requires, statement.expression)
		} else {
			nonRequireStatementCount++
		}
	}
	return requires || emptyArray
}

/** @internal */

func isSupportedSourceFileName(fileName string, compilerOptions CompilerOptions, extraFileExtensions []FileExtensionInfo) bool {
	if !fileName {
		return false
	}

	supportedExtensions := getSupportedExtensions(compilerOptions, extraFileExtensions)
	for _, extension := range flatten(getSupportedExtensionsWithJsonIfResolveJsonModule(compilerOptions, supportedExtensions)) {
		if fileExtensionIs(fileName, extension) {
			return true
		}
	}
	return false
}

func numberOfDirectorySeparators(str string) number {
	match := str.match( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\//g */ TODO)
	if match {
		return match.length
	} else {
		return 0
	}
}

/** @internal */

func compareNumberOfDirectorySeparators(path1 string, path2 string) Comparison {
	return compareValues(numberOfDirectorySeparators(path1), numberOfDirectorySeparators(path2))
}

var extensionsToRemove = []Extension{ExtensionDts, ExtensionDmts, ExtensionDcts, ExtensionMjs, ExtensionMts, ExtensionCjs, ExtensionCts, ExtensionTs, ExtensionJs, ExtensionTsx, ExtensionJsx, ExtensionJson}

/** @internal */

func removeFileExtension(path string) string {
	for _, ext := range extensionsToRemove {
		extensionless := tryRemoveExtension(path, ext)
		if extensionless != nil {
			return extensionless
		}
	}
	return path
}

/** @internal @knipignore */

func tryRemoveExtension(path string, extension string) *string {
	if fileExtensionIs(path, extension) {
		return removeExtension(path, extension)
	} else {
		return nil
	}
}

/** @internal */

func removeExtension(path string, extension string) string {
	return path.substring(0, path.length-extension.length)
}

/** @internal */

func changeExtension(path T, newExtension string) T {
	return changeAnyExtension(path, newExtension, extensionsToRemove /*ignoreCase*/, false) /* as T */
}

/**
 * Returns the input if there are no stars, a pattern if there is exactly one,
 * and undefined if there are more.
 *
 * @internal
 */

func tryParsePattern(pattern string) /* TODO(TS-TO-GO) TypeNode UnionType: string | Pattern | undefined */ any {
	indexOfStar := pattern.indexOf("*")
	if indexOfStar == -1 {
		return pattern
	}
	if pattern.indexOf("*", indexOfStar+1) != -1 {
		return nil
	} else {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"prefix": pattern.substr(0, indexOfStar),
			"suffix": pattern.substr(indexOfStar + 1),
		}
	}
}

/** @internal */

type ParsedPatterns struct {
	matchableStringSet *ReadonlySet[string]
	patterns           *[]Pattern
}

var parsedPatternsCache = NewWeakMap[MapLike[[]string], ParsedPatterns]()

/**
 * Divides patterns into a set of exact specifiers and patterns.
 * NOTE that this function caches the result based on object identity.
 *
 * @internal
 */

func tryParsePatterns(paths MapLike[[]string]) ParsedPatterns {
	result := parsedPatternsCache.get(paths)
	if result != nil {
		return result
	}

	var matchableStringSet *Set[string]
	var patterns *[]Pattern

	pathList := getOwnKeys(paths)
	for _, path := range pathList {
		patternOrStr := tryParsePattern(path)
		if patternOrStr == nil {
			continue
		} else if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof patternOrStr */ TODO == "string" {
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: matchableStringSet ??= new Set() */ TODO).add(patternOrStr)
		} else {
			( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: patterns ??= [] */ TODO).push(patternOrStr)
		}
	}

	parsedPatternsCache.set(paths /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = { matchableStringSet, patterns, } */, TODO)

	return result
}

/** @internal */

func positionIsSynthesized(pos number) bool {
	// This is a fast way of testing the following conditions:
	//  pos === undefined || pos === null || isNaN(pos) || pos < 0;
	return !(pos >= 0)
}

/**
 * True if an extension is one of the supported TypeScript extensions.
 *
 * @internal
 */

func extensionIsTS(ext string) bool {
	return ext == ExtensionTs || ext == ExtensionTsx || ext == ExtensionDts || ext == ExtensionCts || ext == ExtensionMts || ext == ExtensionDmts || ext == ExtensionDcts || (startsWith(ext, ".d.") && endsWith(ext, ".ts"))
}

/** @internal */

func resolutionExtensionIsTSOrJson(ext string) bool {
	return extensionIsTS(ext) || ext == ExtensionJson
}

/**
 * Gets the extension from a path.
 * Path must have a valid extension.
 *
 * @internal
 */

func extensionFromPath(path string) Extension {
	ext := tryGetExtensionFromPath(path)
	if ext != nil {
		return ext
	} else {
		return Debug.fail(__TEMPLATE__("File ", path, " has unknown extension."))
	}
}

/** @internal */

func isAnySupportedFileExtension(path string) bool {
	return tryGetExtensionFromPath(path) != nil
}

/** @internal */

func tryGetExtensionFromPath(path string) *Extension {
	return find(extensionsToRemove, func(e Extension) bool {
		return fileExtensionIs(path, e)
	})
}

/** @internal */

func isCheckJsEnabledForFile(sourceFile SourceFile, compilerOptions CompilerOptions) *bool {
	if sourceFile.checkJsDirective {
		return sourceFile.checkJsDirective.enabled
	} else {
		return compilerOptions.checkJs
	}
}

/** @internal */

var emptyFileSystemEntries FileSystemEntries = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"files":       emptyArray,
	"directories": emptyArray,
}

/**
 * `parsedPatterns` contains both patterns (containing "*") and regular strings.
 * Return an exact match if possible, or a pattern match, or undefined.
 * (These are verified by verifyCompilerOptions to have 0 or 1 "*" characters.)
 *
 * @internal
 */

func matchPatternOrExact(parsedPatterns ParsedPatterns, candidate string) /* TODO(TS-TO-GO) TypeNode UnionType: string | Pattern | undefined */ any {
	TODO_IDENTIFIER := parsedPatterns

	if matchableStringSet. /* ? */ has(candidate) {
		return candidate
	}

	if patterns == nil || patterns.length == 0 {
		return nil
	}

	return findBestPatternMatch(patterns, func(_ Pattern) Pattern {
		return _
	}, candidate)
}

/** @internal */

type Mutable[T any] /* TODO(TS-TO-GO) TypeNode MappedType: { -readonly [K in keyof T]: T[K]; } */ any

/** @internal */

func sliceAfter(arr []T, value T) []T {
	index := arr.indexOf(value)
	Debug.assert(index != -1)
	return arr.slice(index)
}

/** @internal */

func addRelatedInfo(diagnostic T, relatedInformation []DiagnosticRelatedInformation) T {
	if !relatedInformation.length {
		return diagnostic
	}
	if !diagnostic.relatedInformation {
		diagnostic.relatedInformation = []never{}
	}
	Debug.assert(diagnostic.relatedInformation != emptyArray, "Diagnostic had empty array singleton for related info, but is still being constructed!")
	diagnostic.relatedInformation.push(relatedInformation...)
	return diagnostic
}

/** @internal */

func minAndMax(arr []T, getValue func(value T) number) /* TODO(TS-TO-GO) TypeNode TypeLiteral: { readonly min: number; readonly max: number; } */ any {
	Debug.assert(arr.length != 0)
	min := getValue(arr[0])
	max := min
	for i := 1; i < arr.length; i++ {
		value := getValue(arr[i])
		if value < min {
			min = value
		} else if value > max {
			max = value
		}
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"min": min,
		"max": max,
	}
}

/** @internal */

func rangeOfNode(node Node) TextRange {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"pos": getTokenPosOfNode(node),
		"end": node.end,
	}
}

/** @internal */

func rangeOfTypeParameters(sourceFile SourceFile, typeParameters NodeArray[TypeParameterDeclaration]) TextRange {
	// Include the `<>`
	pos := typeParameters.pos - 1
	end := Math.min(sourceFile.text.length, skipTrivia(sourceFile.text, typeParameters.end)+1)
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"pos": pos,
		"end": end,
	}
}

/** @internal */

type HostWithIsSourceOfProjectReferenceRedirect struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface HostWithIsSourceOfProjectReferenceRedirect { isSourceOfProjectReferenceRedirect(fileName: string): boolean; } */
}

/** @internal */

func skipTypeChecking(sourceFile SourceFile, options CompilerOptions, host HostWithIsSourceOfProjectReferenceRedirect) bool {
	return skipTypeCheckingWorker(sourceFile, options, host /*ignoreNoCheck*/, false)
}

/** @internal */

func skipTypeCheckingIgnoringNoCheck(sourceFile SourceFile, options CompilerOptions, host HostWithIsSourceOfProjectReferenceRedirect) bool {
	return skipTypeCheckingWorker(sourceFile, options, host /*ignoreNoCheck*/, true)
}

func skipTypeCheckingWorker(sourceFile SourceFile, options CompilerOptions, host HostWithIsSourceOfProjectReferenceRedirect, ignoreNoCheck bool) bool {
	// If skipLibCheck is enabled, skip reporting errors if file is a declaration file.
	// If skipDefaultLibCheck is enabled, skip reporting errors if file contains a
	// '/// <reference no-default-lib="true"/>' directive.
	return (options.skipLibCheck && sourceFile.isDeclarationFile || options.skipDefaultLibCheck && sourceFile.hasNoDefaultLib) || (!ignoreNoCheck && options.noCheck) || host.isSourceOfProjectReferenceRedirect(sourceFile.fileName) || !canIncludeBindAndCheckDiagnostics(sourceFile, options)
}

/** @internal */

func canIncludeBindAndCheckDiagnostics(sourceFile SourceFile, options CompilerOptions) bool {
	if !!sourceFile.checkJsDirective && sourceFile.checkJsDirective.enabled == false {
		return false
	}
	if sourceFile.scriptKind == ScriptKindTS || sourceFile.scriptKind == ScriptKindTSX || sourceFile.scriptKind == ScriptKindExternal {
		return true
	}

	isJs := sourceFile.scriptKind == ScriptKindJS || sourceFile.scriptKind == ScriptKindJSX
	isCheckJs := isJs && isCheckJsEnabledForFile(sourceFile, options)
	isPlainJs := isPlainJsFile(sourceFile, options.checkJs)

	// By default, only type-check .ts, .tsx, Deferred, plain JS, checked JS and External
	// - plain JS: .js files with no // ts-check and checkJs: undefined
	// - check JS: .js files with either // ts-check or checkJs: true
	// - external: files that are added by plugins
	return isPlainJs || isCheckJs || sourceFile.scriptKind == ScriptKindDeferred
}

/** @internal */

func isJsonEqual(a any, b any) bool {
	// eslint-disable-next-line no-restricted-syntax
	return a == b || /* TODO(TS-TO-GO) Node TypeOfExpression: typeof a */ TODO == "object" && a != /* TODO(TS-TO-GO) Node NullKeyword: null */ TODO && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof b */ TODO == "object" && b != /* TODO(TS-TO-GO) Node NullKeyword: null */ TODO && equalOwnProperties(a /* as MapLike<unknown> */, b /* as MapLike<unknown> */, isJsonEqual)
}

/**
 * Converts a bigint literal string, e.g. `0x1234n`,
 * to its decimal string representation, e.g. `4660`.
 *
 * @internal
 */

func parsePseudoBigInt(stringValue string) string {
	var log2Base number
	switch stringValue.charCodeAt(1) {
	case CharacterCodesb,
		CharacterCodesB:
		log2Base = 1
	case CharacterCodeso,
		CharacterCodesO:
		log2Base = 3
	case CharacterCodesx,
		CharacterCodesX:
		log2Base = 4
	default:
		nIndex := stringValue.length - 1
		nonZeroStart := 0
		for stringValue.charCodeAt(nonZeroStart) == CharacterCodes_0 {
			nonZeroStart++
		}
		return stringValue.slice(nonZeroStart, nIndex) || "0"
	}

	// Omit leading "0b", "0o", or "0x", and trailing "n"
	startIndex := 2
	endIndex := stringValue.length - 1
	bitsNeeded := (endIndex - startIndex) * log2Base
	// Stores the value specified by the string as a LE array of 16-bit integers
	// using Uint16 instead of Uint32 so combining steps can use bitwise operators
	segments := NewUint16Array(( /* TODO(TS-TO-GO) GreaterThanGreaterThanGreaterThanToken BinaryExpression: bitsNeeded >>> 4 */ TODO) + (__COND__(bitsNeeded&15, 1, 0)))
	// Add the digits, one at a time
	for ; /* TODO(TS-TO-GO) Node VariableDeclarationList: let i = endIndex - 1, bitOffset = 0 */ i >= startIndex; /* TODO(TS-TO-GO) CommaToken BinaryExpression: i--, bitOffset += log2Base */ TODO {
		segment := /* TODO(TS-TO-GO) GreaterThanGreaterThanGreaterThanToken BinaryExpression: bitOffset >>> 4 */ TODO
		digitChar := stringValue.charCodeAt(i)
		// Find character range: 0-9 < A-F < a-f
		var digit number
		if digitChar <= CharacterCodes_9 {
			digit = digitChar - CharacterCodes_0
		} else {
			digit = 10 + digitChar - (__COND__(digitChar <= CharacterCodesF, CharacterCodesA, CharacterCodesa))
		}
		shiftedDigit := /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: digit << (bitOffset & 15) */ TODO
		segments[segment] |= shiftedDigit
		residual := /* TODO(TS-TO-GO) GreaterThanGreaterThanGreaterThanToken BinaryExpression: shiftedDigit >>> 16 */ TODO
		if residual {
			segments[segment+1] |= residual
			// overflows segment
		}
		// overflows segment
	}
	// Repeatedly divide segments by 10 and add remainder to base10Value
	base10Value := ""
	firstNonzeroSegment := segments.length - 1
	segmentsRemaining := true
	for segmentsRemaining {
		mod10 := 0
		segmentsRemaining = false
		for segment := firstNonzeroSegment; segment >= 0; segment-- {
			newSegment := /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: mod10 << 16 */ TODO | segments[segment]
			segmentValue := (newSegment / 10) | 0
			segments[segment] = segmentValue
			mod10 = newSegment - segmentValue*10
			if segmentValue && !segmentsRemaining {
				firstNonzeroSegment = segment
				segmentsRemaining = true
			}
		}
		base10Value = mod10 + base10Value
	}
	return base10Value
}

/** @internal */

func pseudoBigIntToString(TODO_IDENTIFIER PseudoBigInt) string {
	return (__COND__(negative && base10Value != "0", "-", "")) + base10Value
}

/** @internal */

func parseBigInt(text string) *PseudoBigInt {
	if !isValidBigIntString(text /*roundTripOnly*/, false) {
		return nil
	}
	return parseValidBigInt(text)
}

/**
 * @internal
 * @param text a valid bigint string excluding a trailing `n`, but including a possible prefix `-`. Use `isValidBigIntString(text, roundTripOnly)` before calling this function.
 */

func parseValidBigInt(text string) PseudoBigInt {
	negative := text.startsWith("-")
	base10Value := parsePseudoBigInt(__TEMPLATE__(__COND__(negative, text.slice(1), text), "n"))
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"negative":    negative,
		"base10Value": base10Value,
	}
}

/**
 * @internal
 * Tests whether the provided string can be parsed as a bigint.
 * @param s The string to test.
 * @param roundTripOnly Indicates the resulting bigint matches the input when converted back to a string.
 */

func isValidBigIntString(s string, roundTripOnly bool) bool {
	if s == "" {
		return false
	}
	scanner := createScanner(ScriptTargetESNext /*skipTrivia*/, false)
	success := true
	scanner.setOnError(func() bool {
		return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: success = false */ TODO
	})
	scanner.setText(s + "n")
	result := scanner.scan()
	negative := result == SyntaxKindMinusToken
	if negative {
		result = scanner.scan()
	}
	flags := scanner.getTokenFlags()
	// validate that
	// * scanning proceeded without error
	// * a bigint can be scanned, and that when it is scanned, it is
	// * the full length of the input string (so the scanner is one character beyond the augmented input length)
	// * it does not contain a numeric seperator (the `BigInt` constructor does not accept a numeric seperator in its input)
	return success && result == SyntaxKindBigIntLiteral && scanner.getTokenEnd() == (s.length+1) && !(flags & TokenFlagsContainsSeparator) && (!roundTripOnly || s == pseudoBigIntToString(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"negative":    negative,
		"base10Value": parsePseudoBigInt(scanner.getTokenValue()),
	}))
}

/** @internal */

func isValidTypeOnlyAliasUseSite(useSite Node) bool {
	return !!(useSite.flags & NodeFlagsAmbient) || isPartOfTypeQuery(useSite) || isIdentifierInNonEmittingHeritageClause(useSite) || isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(useSite) || !(isExpressionNode(useSite) || isShorthandPropertyNameUseSite(useSite))
}

func isShorthandPropertyNameUseSite(useSite Node) bool {
	return isIdentifier(useSite) && isShorthandPropertyAssignment(useSite.parent) && useSite.parent.name == useSite
}

func isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(node Node) bool {
	for node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindPropertyAccessExpression {
		node = node.parent
	}
	if node.kind != SyntaxKindComputedPropertyName {
		return false
	}
	if hasSyntacticModifier(node.parent, ModifierFlagsAbstract) {
		return true
	}
	containerKind := node.parent.parent.kind
	return containerKind == SyntaxKindInterfaceDeclaration || containerKind == SyntaxKindTypeLiteral
}

/** Returns true for an identifier in 1) an `implements` clause, and 2) an `extends` clause of an interface. */

func isIdentifierInNonEmittingHeritageClause(node Node) bool {
	if node.kind != SyntaxKindIdentifier {
		return false
	}
	heritageClause := findAncestor(node.parent, func(parent Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		switch parent.kind {
		case SyntaxKindHeritageClause:
			return true
		case SyntaxKindPropertyAccessExpression,
			SyntaxKindExpressionWithTypeArguments:
			return false
		default:
			return "quit"
		}
	}) /* as HeritageClause | undefined */
	return heritageClause. /* ? */ token == SyntaxKindImplementsKeyword || heritageClause. /* ? */ parent.kind == SyntaxKindInterfaceDeclaration
}

/** @internal */

func isIdentifierTypeReference(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is TypeReferenceNode & { typeName: Identifier; } */ any {
	return isTypeReferenceNode(node) && isIdentifier(node.typeName)
}

/** @internal */

func arrayIsHomogeneous(array []T, comparer EqualityComparer[T] /*  = equateValues */) bool {
	if array.length < 2 {
		return true
	}
	first := array[0]
	for ; /* TODO(TS-TO-GO) Node VariableDeclarationList: let i = 1, length = array.length */ i < length; i++ {
		target := array[i]
		if !comparer(first, target) {
			return false
		}
	}
	return true
}

/**
 * Bypasses immutability and directly sets the `pos` property of a `TextRange` or `Node`.
 *
 * @internal
 */

func setTextRangePos(range_ T, pos number) T {
	(range_ /* as TextRange */).pos = pos
	return range_
}

/**
 * Bypasses immutability and directly sets the `end` property of a `TextRange` or `Node`.
 *
 * @internal
 */

func setTextRangeEnd(range_ T, end number) T {
	(range_ /* as TextRange */).end = end
	return range_
}

/**
 * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node`.
 *
 * @internal
 */

func setTextRangePosEnd(range_ T, pos number, end number) T {
	return setTextRangeEnd(setTextRangePos(range_, pos), end)
}

/**
 * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node` from the
 * provided position and width.
 *
 * @internal
 */

func setTextRangePosWidth(range_ T, pos number, width number) T {
	return setTextRangePosEnd(range_, pos, pos+width)
}

/**
 * Bypasses immutability and directly sets the `flags` property of a `Node`.
 *
 * @internal
 */

/* OVERLOAD: export function setNodeFlags<T extends Node>(node: T, newFlags: NodeFlags): T; */
/** @internal */

/* OVERLOAD: export function setNodeFlags<T extends Node>(node: T | undefined, newFlags: NodeFlags): T | undefined; */
/** @internal */

func setNodeFlags(node *T, newFlags NodeFlags) *T {
	if node {
		(node /* as Mutable<T> */).flags = newFlags
	}
	return node
}

/**
 * Bypasses immutability and directly sets the `parent` property of a `Node`.
 *
 * @internal
 */

/* OVERLOAD: export function setParent<T extends Node>(child: T, parent: T["parent"] | undefined): T; */
/** @internal */

/* OVERLOAD: export function setParent<T extends Node>(child: T | undefined, parent: T["parent"] | undefined): T | undefined; */
/** @internal */

func setParent(child *T, parent * /* TODO(TS-TO-GO) TypeNode IndexedAccessType: T["parent"] */ any) *T {
	if child && parent {
		(child /* as Mutable<T> */).parent = parent
	}
	return child
}

/**
 * Bypasses immutability and directly sets the `parent` property of each `Node` recursively.
 * @param rootNode The root node from which to start the recursion.
 * @param incremental When `true`, only recursively descends through nodes whose `parent` pointers are incorrect.
 * This allows us to quickly bail out of setting `parent` for subtrees during incremental parsing.
 *
 * @internal
 */

/* OVERLOAD: export function setParentRecursive<T extends Node>(rootNode: T, incremental: boolean): T; */
/** @internal */

/* OVERLOAD: export function setParentRecursive<T extends Node>(rootNode: T | undefined, incremental: boolean): T | undefined; */
/** @internal */

func setParentRecursive(rootNode *T, incremental bool) *T {
	if !rootNode {
		return rootNode
	}
	forEachChildRecursively(rootNode, __COND__(isJSDocNode(rootNode), bindParentToChildIgnoringJSDoc, bindParentToChild))
	return rootNode

	bindParentToChildIgnoringJSDoc := func(child Node, parent Node) /* TODO(TS-TO-GO) TypeNode UnionType: void | "skip" */ any {
		if incremental && child.parent == parent {
			return "skip"
		}
		setParent(child, parent)
	}

	bindJSDoc := func(child Node) {
		if hasJSDocNodes(child) {
			for _, doc := range child.jsDoc {
				bindParentToChildIgnoringJSDoc(doc, child)
				forEachChildRecursively(doc, bindParentToChildIgnoringJSDoc)
			}
		}
	}

	bindParentToChild := func(child Node, parent Node) /* TODO(TS-TO-GO) inferred type void | "skip" */ any {
		return bindParentToChildIgnoringJSDoc(child, parent) || bindJSDoc(child)
	}

}

func isPackedElement(node Expression) bool {
	return !isOmittedExpression(node)
}

/**
 * Determines whether the provided node is an ArrayLiteralExpression that contains no missing elements.
 *
 * @internal
 */

func isPackedArrayLiteral(node Expression) bool {
	return isArrayLiteralExpression(node) && every(node.elements, isPackedElement)
}

/**
 * Indicates whether the result of an `Expression` will be unused.
 *
 * NOTE: This requires a node with a valid `parent` pointer.
 *
 * @internal
 */

func expressionResultIsUnused(node Expression) bool {
	Debug.assertIsDefined(node.parent)
	for true {
		var parent Node = node.parent
		// walk up parenthesized expressions, but keep a pointer to the top-most parenthesized expression
		if isParenthesizedExpression(parent) {
			node = parent
			continue
		}
		// result is unused in an expression statement, `void` expression, or the initializer or incrementer of a `for` loop
		if isExpressionStatement(parent) || isVoidExpression(parent) || isForStatement(parent) && (parent.initializer == node || parent.incrementor == node) {
			return true
		}
		if isCommaListExpression(parent) {
			// left side of comma is always unused
			if node != last(parent.elements) {
				return true
			}
			// right side of comma is unused if parent is unused
			node = parent
			continue
		}
		if isBinaryExpression(parent) && parent.operatorToken.kind == SyntaxKindCommaToken {
			// left side of comma is always unused
			if node == parent.left {
				return true
			}
			// right side of comma is unused if parent is unused
			node = parent
			continue
		}
		return false
	}
}

/** @internal */

func containsIgnoredPath(path string) bool {
	return some(ignoredPaths, func(p string) bool {
		return path.includes(p)
	})
}

/** @internal */

func getContainingNodeArray(node Node) *NodeArray[Node] {
	if !node.parent {
		return nil
	}
	switch node.kind {
	case SyntaxKindTypeParameter:
		TODO_IDENTIFIER := node /* as TypeParameterDeclaration */
		if parent.kind == SyntaxKindInferType {
			return nil
		} else {
			return parent.typeParameters
		}
	case SyntaxKindParameter:
		return (node /* as ParameterDeclaration */).parent.parameters
	case SyntaxKindTemplateLiteralTypeSpan:
		return (node /* as TemplateLiteralTypeSpan */).parent.templateSpans
	case SyntaxKindTemplateSpan:
		return (node /* as TemplateSpan */).parent.templateSpans
	case SyntaxKindDecorator:
		TODO_IDENTIFIER := node /* as Decorator */
		if canHaveDecorators(parent) {
			return parent.modifiers
		} else {
			return nil
		}
		fallthrough
	case SyntaxKindHeritageClause:
		return (node /* as HeritageClause */).parent.heritageClauses
	}

	TODO_IDENTIFIER := node
	if isJSDocTag(node) {
		if isJSDocTypeLiteral(node.parent) {
			return nil
		} else {
			return node.parent.tags
		}
	}

	switch parent.kind {
	case SyntaxKindTypeLiteral,
		SyntaxKindInterfaceDeclaration:
		if isTypeElement(node) {
			return (parent /* as TypeLiteralNode | InterfaceDeclaration */).members
		} else {
			return nil
		}
	case SyntaxKindUnionType,
		SyntaxKindIntersectionType:
		return (parent /* as UnionOrIntersectionTypeNode */).types
	case SyntaxKindTupleType,
		SyntaxKindArrayLiteralExpression,
		SyntaxKindCommaListExpression,
		SyntaxKindNamedImports,
		SyntaxKindNamedExports:
		return (parent /* as TupleTypeNode | ArrayLiteralExpression | CommaListExpression | NamedImports | NamedExports */).elements
	case SyntaxKindObjectLiteralExpression,
		SyntaxKindJsxAttributes:
		return (parent /* as ObjectLiteralExpressionBase<ObjectLiteralElement> */).properties
	case SyntaxKindCallExpression,
		SyntaxKindNewExpression:
		switch {
		case isTypeNode(node):
			return (parent /* as CallExpression | NewExpression */).typeArguments
		case (parent /* as CallExpression | NewExpression */).expression == node:
			return nil
		default:
			return (parent /* as CallExpression | NewExpression */).arguments
		}
	case SyntaxKindJsxElement,
		SyntaxKindJsxFragment:
		if isJsxChild(node) {
			return (parent /* as JsxElement | JsxFragment */).children
		} else {
			return nil
		}
	case SyntaxKindJsxOpeningElement,
		SyntaxKindJsxSelfClosingElement:
		if isTypeNode(node) {
			return (parent /* as JsxOpeningElement | JsxSelfClosingElement */).typeArguments
		} else {
			return nil
		}
	case SyntaxKindBlock,
		SyntaxKindCaseClause,
		SyntaxKindDefaultClause,
		SyntaxKindModuleBlock:
		return (parent /* as Block | CaseOrDefaultClause | ModuleBlock */).statements
	case SyntaxKindCaseBlock:
		return (parent /* as CaseBlock */).clauses
	case SyntaxKindClassDeclaration,
		SyntaxKindClassExpression:
		if isClassElement(node) {
			return (parent /* as ClassLikeDeclaration */).members
		} else {
			return nil
		}
	case SyntaxKindEnumDeclaration:
		if isEnumMember(node) {
			return (parent /* as EnumDeclaration */).members
		} else {
			return nil
		}
	case SyntaxKindSourceFile:
		return (parent /* as SourceFile */).statements
	}
}

/** @internal */

func hasContextSensitiveParameters(node FunctionLikeDeclaration) bool {
	// Functions with type parameters are not context sensitive.
	if !node.typeParameters {
		// Functions with any parameters that lack type annotations are context sensitive.
		if some(node.parameters, func(p ParameterDeclaration) bool {
			return !getEffectiveTypeAnnotationNode(p)
		}) {
			return true
		}
		if node.kind != SyntaxKindArrowFunction {
			// If the first parameter is not an explicit 'this' parameter, then the function has
			// an implicit 'this' parameter which is subject to contextual typing.
			parameter := firstOrUndefined(node.parameters)
			if !(parameter && parameterIsThisKeyword(parameter)) {
				return true
			}
		}
	}
	return false
}

/** @internal */

func isInfinityOrNaNString(name /* TODO(TS-TO-GO) TypeNode UnionType: string | __String */ any) bool {
	return name == "Infinity" || name == "-Infinity" || name == "NaN"
}

/** @internal */

func isCatchClauseVariableDeclaration(node Node) bool {
	return node.kind == SyntaxKindVariableDeclaration && node.parent.kind == SyntaxKindCatchClause
}

/** @internal */

func isFunctionExpressionOrArrowFunction(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is FunctionExpression | ArrowFunction */ any {
	return node.kind == SyntaxKindFunctionExpression || node.kind == SyntaxKindArrowFunction
}

/** @internal */

func escapeSnippetText(text string) string {
	return text.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\$/g */ TODO, func() string {
		return "\\$"
	})
}

/** @internal */

func isNumericLiteralName(name /* TODO(TS-TO-GO) TypeNode UnionType: string | __String */ any) bool {
	// The intent of numeric names is that
	//     - they are names with text in a numeric form, and that
	//     - setting properties/indexing with them is always equivalent to doing so with the numeric literal 'numLit',
	//         acquired by applying the abstract 'ToNumber' operation on the name's text.
	//
	// The subtlety is in the latter portion, as we cannot reliably say that anything that looks like a numeric literal is a numeric name.
	// In fact, it is the case that the text of the name must be equal to 'ToString(numLit)' for this to hold.
	//
	// Consider the property name '"0xF00D"'. When one indexes with '0xF00D', they are actually indexing with the value of 'ToString(0xF00D)'
	// according to the ECMAScript specification, so it is actually as if the user indexed with the string '"61453"'.
	// Thus, the text of all numeric literals equivalent to '61543' such as '0xF00D', '0xf00D', '0170015', etc. are not valid numeric names
	// because their 'ToString' representation is not equal to their original text.
	// This is motivated by ECMA-262 sections 9.3.1, 9.8.1, 11.1.5, and 11.2.1.
	//
	// Here, we test whether 'ToString(ToNumber(name))' is exactly equal to 'name'.
	// The '+' prefix operator is equivalent here to applying the abstract ToNumber operation.
	// Applying the 'toString()' method on a number gives us the abstract ToString operation on a number.
	//
	// Note that this accepts the values 'Infinity', '-Infinity', and 'NaN', and that this is intentional.
	// This is desired behavior, because when indexing with them as numeric entities, you are indexing
	// with the strings '"Infinity"', '"-Infinity"', and '"NaN"' respectively.
	return (+name).toString() == name
}

/** @internal */

func createPropertyNameNodeForIdentifierOrLiteral(name string, target ScriptTarget, singleQuote bool, stringNamed bool, isMethod bool) /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | StringLiteral | NumericLiteral */ any {
	isMethodNamedNew := isMethod && name == "new"
	switch {
	case !isMethodNamedNew && isIdentifierText(name, target):
		return factory.createIdentifier(name)
	case !stringNamed && !isMethodNamedNew && isNumericLiteralName(name) && +name >= 0:
		return factory.createNumericLiteral(+name)
	default:
		return factory.createStringLiteral(name, !!singleQuote)
	}
}

/** @internal */

func isThisTypeParameter(type_ Type) bool {
	return !!(type_.flags&TypeFlagsTypeParameter && (type_ /* as TypeParameter */).isThisType)
}

/** @internal */

type NodeModulePathParts struct {
	topLevelNodeModulesIndex number
	topLevelPackageNameIndex number
	packageRootIndex         number
	fileNameIndex            number
}

/** @internal */

func getNodeModulePathParts(fullPath string) *NodeModulePathParts {
	// If fullPath can't be valid module file within node_modules, returns undefined.
	// Example of expected pattern: /base/path/node_modules/[@scope/otherpackage/@otherscope/node_modules/]package/[subdirectory/]file.js
	// Returns indices:                       ^            ^                                                      ^             ^

	topLevelNodeModulesIndex := 0
	topLevelPackageNameIndex := 0
	packageRootIndex := 0
	fileNameIndex := 0

	type States int32
	const (
		StatesBeforeNodeModules States = iota
		StatesNodeModules
		StatesScope
		StatesPackageContent
	)

	partStart := 0
	partEnd := 0
	state := StatesBeforeNodeModules

	for partEnd >= 0 {
		partStart = partEnd
		partEnd = fullPath.indexOf("/", partStart+1)
		switch state {
		case StatesBeforeNodeModules:
			if fullPath.indexOf(nodeModulesPathPart, partStart) == partStart {
				topLevelNodeModulesIndex = partStart
				topLevelPackageNameIndex = partEnd
				state = StatesNodeModules
			}
		case StatesNodeModules,
			StatesScope:
			if state == StatesNodeModules && fullPath.charAt(partStart+1) == "@" {
				state = StatesScope
			} else {
				packageRootIndex = partEnd
				state = StatesPackageContent
			}
		case StatesPackageContent:
			if fullPath.indexOf(nodeModulesPathPart, partStart) == partStart {
				state = StatesNodeModules
			} else {
				state = StatesPackageContent
			}
		}
	}

	fileNameIndex = partStart

	if state > StatesNodeModules {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"topLevelNodeModulesIndex": topLevelNodeModulesIndex,
			"topLevelPackageNameIndex": topLevelPackageNameIndex,
			"packageRootIndex":         packageRootIndex,
			"fileNameIndex":            fileNameIndex,
		}
	} else {
		return nil
	}
}

/** @internal */

func isTypeDeclaration(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is TypeParameterDeclaration | ClassDeclaration | InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag | JSDocEnumTag | EnumDeclaration | ImportClause | ImportSpecifier | ExportSpecifier */ any {
	switch node.kind {
	case SyntaxKindTypeParameter,
		SyntaxKindClassDeclaration,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindEnumDeclaration,
		SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocEnumTag:
		return true
	case SyntaxKindImportClause:
		return (node /* as ImportClause */).isTypeOnly
	case SyntaxKindImportSpecifier,
		SyntaxKindExportSpecifier:
		return (node /* as ImportSpecifier | ExportSpecifier */).parent.parent.isTypeOnly
	default:
		return false
	}
}

/** @internal */

func canHaveExportModifier(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is Extract<HasModifiers, Statement> */ any {
	return isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isInterfaceDeclaration(node) || isTypeDeclaration(node) || (isModuleDeclaration(node) && !isExternalModuleAugmentation(node) && !isGlobalScopeAugmentation(node))
}

/** @internal */

func isOptionalJSDocPropertyLikeTag(node Node) bool {
	if !isJSDocPropertyLikeTag(node) {
		return false
	}
	TODO_IDENTIFIER := node
	return isBracketed || !!typeExpression && typeExpression.type_.kind == SyntaxKindJSDocOptionalType
}

/** @internal */

func canUsePropertyAccess(name string, languageVersion ScriptTarget) bool {
	if name.length == 0 {
		return false
	}
	firstChar := name.charCodeAt(0)
	if firstChar == CharacterCodeshash {
		return name.length > 1 && isIdentifierStart(name.charCodeAt(1), languageVersion)
	} else {
		return isIdentifierStart(firstChar, languageVersion)
	}
}

/** @internal */

func hasTabstop(node Node) bool {
	return getSnippetElement(node). /* ? */ kind == SnippetKindTabStop
}

/** @internal */

func isJSDocOptionalParameter(node ParameterDeclaration) bool {
	return isInJSFile(node) && (node.type_ && node.type_.kind == SyntaxKindJSDocOptionalType || getJSDocParameterTags(node).some(isOptionalJSDocPropertyLikeTag))
}

/** @internal */

func isOptionalDeclaration(declaration Declaration) bool {
	switch declaration.kind {
	case SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature:
		return !!(declaration /* as PropertyDeclaration | PropertySignature */).questionToken
	case SyntaxKindParameter:
		return !!(declaration /* as ParameterDeclaration */).questionToken || isJSDocOptionalParameter(declaration /* as ParameterDeclaration */)
	case SyntaxKindJSDocPropertyTag,
		SyntaxKindJSDocParameterTag:
		return isOptionalJSDocPropertyLikeTag(declaration)
	default:
		return false
	}
}

/** @internal */

func isNonNullAccess(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is AccessExpression */ any {
	kind := node.kind
	return (kind == SyntaxKindPropertyAccessExpression || kind == SyntaxKindElementAccessExpression) && isNonNullExpression((node /* as AccessExpression */).expression)
}

/** @internal */

func isJSDocSatisfiesExpression(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is JSDocSatisfiesExpression */ any {
	return isInJSFile(node) && isParenthesizedExpression(node) && hasJSDocNodes(node) && !!getJSDocSatisfiesTag(node)
}

/** @internal */

func getJSDocSatisfiesExpressionType(node JSDocSatisfiesExpression) TypeNode {
	return Debug.checkDefined(tryGetJSDocSatisfiesTypeNode(node))
}

/** @internal */

func tryGetJSDocSatisfiesTypeNode(node Node) *TypeNode {
	tag := getJSDocSatisfiesTag(node)
	return tag && tag.typeExpression && tag.typeExpression.type_
}

/** @internal */

func getEscapedTextOfJsxAttributeName(node JsxAttributeName) __String {
	if isIdentifier(node) {
		return node.escapedText
	} else {
		return getEscapedTextOfJsxNamespacedName(node)
	}
}

/** @internal */

func getTextOfJsxAttributeName(node JsxAttributeName) string {
	if isIdentifier(node) {
		return idText(node)
	} else {
		return getTextOfJsxNamespacedName(node)
	}
}

/** @internal */

func isJsxAttributeName(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is JsxAttributeName */ any {
	kind := node.kind
	return kind == SyntaxKindIdentifier || kind == SyntaxKindJsxNamespacedName
}

/** @internal */

func getEscapedTextOfJsxNamespacedName(node JsxNamespacedName) __String {
	return __TEMPLATE__(node.namespace.escapedText, ":", idText(node.name)) /* as __String */
}

/** @internal */

func getTextOfJsxNamespacedName(node JsxNamespacedName) string {
	return __TEMPLATE__(idText(node.namespace), ":", idText(node.name))
}

/** @internal */

func intrinsicTagNameToString(node /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | JsxNamespacedName */ any) string {
	if isIdentifier(node) {
		return idText(node)
	} else {
		return getTextOfJsxNamespacedName(node)
	}
}

/**
 * Indicates whether a type can be used as a property name.
 * @internal
 */

func isTypeUsableAsPropertyName(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any {
	return !!(type_.flags & TypeFlagsStringOrNumberLiteralOrUnique)
}

/**
 * Gets the symbolic name for a member from its type.
 * @internal
 */

func getPropertyNameFromType(type_ /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any) __String {
	if type_.flags & TypeFlagsUniqueESSymbol {
		return (type_ /* as UniqueESSymbolType */).escapedName
	}
	if type_.flags & (TypeFlagsStringLiteral | TypeFlagsNumberLiteral) {
		return escapeLeadingUnderscores("" + (type_ /* as StringLiteralType | NumberLiteralType */).value)
	}
	return Debug.fail()
}

/** @internal */

func isExpandoPropertyDeclaration(declaration Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: declaration is PropertyAccessExpression | ElementAccessExpression | BinaryExpression */ any {
	return !!declaration && (isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isBinaryExpression(declaration))
}

/** @internal */

func hasResolutionModeOverride(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportTypeNode | ImportDeclaration | ExportDeclaration | JSDocImportTag | undefined */ any) bool {
	if node == nil {
		return false
	}
	return !!getResolutionModeOverride(node.attributes)
}

var stringReplace = String.prototype.replace

/** @internal */

func replaceFirstStar(s string, replacement string) string {
	// `s.replace("*", replacement)` triggers CodeQL as they think it's a potentially incorrect string escaping.
	// See: https://codeql.github.com/codeql-query-help/javascript/js-incomplete-sanitization/
	// But, we really do want to replace only the first star.
	// Attempt to defeat this analysis by indirectly calling the method.
	return stringReplace.call(s, "*", replacement)
}

/** @internal */

func getNameFromImportAttribute(node ImportAttribute) __String {
	if isIdentifier(node.name) {
		return node.name.escapedText
	} else {
		return escapeLeadingUnderscores(node.name.text)
	}
}

/** @internal */

func isSourceElement(node Node) bool {
	switch node.kind {
	case SyntaxKindTypeParameter,
		SyntaxKindParameter,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature,
		SyntaxKindConstructorType,
		SyntaxKindFunctionType,
		SyntaxKindCallSignature,
		SyntaxKindConstructSignature,
		SyntaxKindIndexSignature,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindClassStaticBlockDeclaration,
		SyntaxKindConstructor,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindTypeReference,
		SyntaxKindTypePredicate,
		SyntaxKindTypeQuery,
		SyntaxKindTypeLiteral,
		SyntaxKindArrayType,
		SyntaxKindTupleType,
		SyntaxKindUnionType,
		SyntaxKindIntersectionType,
		SyntaxKindParenthesizedType,
		SyntaxKindOptionalType,
		SyntaxKindRestType,
		SyntaxKindThisType,
		SyntaxKindTypeOperator,
		SyntaxKindConditionalType,
		SyntaxKindInferType,
		SyntaxKindTemplateLiteralType,
		SyntaxKindImportType,
		SyntaxKindNamedTupleMember,
		SyntaxKindJSDocAugmentsTag,
		SyntaxKindJSDocImplementsTag,
		SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocEnumTag,
		SyntaxKindJSDocTemplateTag,
		SyntaxKindJSDocTypeTag,
		SyntaxKindJSDocLink,
		SyntaxKindJSDocLinkCode,
		SyntaxKindJSDocLinkPlain,
		SyntaxKindJSDocParameterTag,
		SyntaxKindJSDocPropertyTag,
		SyntaxKindJSDocFunctionType,
		SyntaxKindJSDocNonNullableType,
		SyntaxKindJSDocNullableType,
		SyntaxKindJSDocAllType,
		SyntaxKindJSDocUnknownType,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindJSDocVariadicType,
		SyntaxKindJSDocTypeExpression,
		SyntaxKindJSDocPublicTag,
		SyntaxKindJSDocProtectedTag,
		SyntaxKindJSDocPrivateTag,
		SyntaxKindJSDocSatisfiesTag,
		SyntaxKindJSDocThisTag,
		SyntaxKindIndexedAccessType,
		SyntaxKindMappedType,
		SyntaxKindFunctionDeclaration,
		SyntaxKindBlock,
		SyntaxKindModuleBlock,
		SyntaxKindVariableStatement,
		SyntaxKindExpressionStatement,
		SyntaxKindIfStatement,
		SyntaxKindDoStatement,
		SyntaxKindWhileStatement,
		SyntaxKindForStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement,
		SyntaxKindContinueStatement,
		SyntaxKindBreakStatement,
		SyntaxKindReturnStatement,
		SyntaxKindWithStatement,
		SyntaxKindSwitchStatement,
		SyntaxKindLabeledStatement,
		SyntaxKindThrowStatement,
		SyntaxKindTryStatement,
		SyntaxKindVariableDeclaration,
		SyntaxKindBindingElement,
		SyntaxKindClassDeclaration,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindEnumDeclaration,
		SyntaxKindModuleDeclaration,
		SyntaxKindImportDeclaration,
		SyntaxKindImportEqualsDeclaration,
		SyntaxKindExportDeclaration,
		SyntaxKindExportAssignment,
		SyntaxKindEmptyStatement,
		SyntaxKindDebuggerStatement,
		SyntaxKindMissingDeclaration:
		return true
	}
	return false
}

/** @internal */

func evaluatorResult(value T, isSyntacticallyString bool /*  = false */, resolvedOtherFiles bool /*  = false */, hasExternalReferences bool /*  = false */) EvaluatorResult[T] {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"value":                 value,
		"isSyntacticallyString": isSyntacticallyString,
		"resolvedOtherFiles":    resolvedOtherFiles,
		"hasExternalReferences": hasExternalReferences,
	}
}

/** @internal */

func createEvaluator(TODO_IDENTIFIER EvaluationResolver) /* TODO(TS-TO-GO) TypeNode TypeLiteral: { (expr: TemplateExpression, location?: Declaration): EvaluatorResult<string | undefined>; (expr: Expression, location?: Declaration): EvaluatorResult; } */ any {
	/* OVERLOAD: function evaluate(expr: TemplateExpression, location?: Declaration): EvaluatorResult<string | undefined>; */
	/* OVERLOAD: function evaluate(expr: Expression, location?: Declaration): EvaluatorResult; */
	evaluate := func(expr Expression, location Declaration) EvaluatorResult {
		isSyntacticallyString := false
		resolvedOtherFiles := false
		hasExternalReferences := false
		// It's unclear when/whether we should consider skipping other kinds of outer expressions.
		// Type assertions intentionally break evaluation when evaluating literal types, such as:
		//     type T = `one ${"two" as any} three`; // string
		// But it's less clear whether such an assertion should break enum member evaluation:
		//     enum E {
		//       A = "one" as any
		//     }
		// SatisfiesExpressions and non-null assertions seem to have even less reason to break
		// emitting enum members as literals. However, these expressions also break Babel's
		// evaluation (but not esbuild's), and the isolatedModules errors we give depend on
		// our evaluation results, so we're currently being conservative so as to issue errors
		// on code that might break Babel.
		expr = skipParentheses(expr)
		switch expr.kind {
		case SyntaxKindPrefixUnaryExpression:
			result := evaluate((expr /* as PrefixUnaryExpression */).operand, location)
			resolvedOtherFiles = result.resolvedOtherFiles
			hasExternalReferences = result.hasExternalReferences
			if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result.value */ TODO == "number" {
				switch (expr /* as PrefixUnaryExpression */).operator {
				case SyntaxKindPlusToken:
					return evaluatorResult(result.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindMinusToken:
					return evaluatorResult(-result.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindTildeToken:
					return evaluatorResult(~result.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				}
			}
		case SyntaxKindBinaryExpression:
			left := evaluate((expr /* as BinaryExpression */).left, location)
			right := evaluate((expr /* as BinaryExpression */).right, location)
			isSyntacticallyString = (left.isSyntacticallyString || right.isSyntacticallyString) && (expr /* as BinaryExpression */).operatorToken.kind == SyntaxKindPlusToken
			resolvedOtherFiles = left.resolvedOtherFiles || right.resolvedOtherFiles
			hasExternalReferences = left.hasExternalReferences || right.hasExternalReferences
			if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof left.value */ TODO == "number" && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof right.value */ TODO == "number" {
				switch (expr /* as BinaryExpression */).operatorToken.kind {
				case SyntaxKindBarToken:
					return evaluatorResult(left.value|right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindAmpersandToken:
					return evaluatorResult(left.value&right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindGreaterThanGreaterThanToken:
					return evaluatorResult( /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: left.value >> right.value */ TODO, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindGreaterThanGreaterThanGreaterThanToken:
					return evaluatorResult( /* TODO(TS-TO-GO) GreaterThanGreaterThanGreaterThanToken BinaryExpression: left.value >>> right.value */ TODO, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindLessThanLessThanToken:
					return evaluatorResult( /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: left.value << right.value */ TODO, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindCaretToken:
					return evaluatorResult(left.value^right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindAsteriskToken:
					return evaluatorResult(left.value*right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindSlashToken:
					return evaluatorResult(left.value/right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindPlusToken:
					return evaluatorResult(left.value+right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindMinusToken:
					return evaluatorResult(left.value-right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindPercentToken:
					return evaluatorResult(left.value%right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				case SyntaxKindAsteriskAsteriskToken:
					return evaluatorResult(left.value**right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
				}
			} else if ( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof left.value */ TODO == "string" || /* TODO(TS-TO-GO) Node TypeOfExpression: typeof left.value */ TODO == "number") && ( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof right.value */ TODO == "string" || /* TODO(TS-TO-GO) Node TypeOfExpression: typeof right.value */ TODO == "number") && (expr /* as BinaryExpression */).operatorToken.kind == SyntaxKindPlusToken {
				return evaluatorResult(""+left.value+right.value, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
			}

			break
			fallthrough
		case SyntaxKindStringLiteral,
			SyntaxKindNoSubstitutionTemplateLiteral:
			return evaluatorResult((expr /* as StringLiteralLike */).text /*isSyntacticallyString*/, true)
		case SyntaxKindTemplateExpression:
			return evaluateTemplateExpression(expr /* as TemplateExpression */, location)
		case SyntaxKindNumericLiteral:
			return evaluatorResult(+(expr /* as NumericLiteral */).text)
		case SyntaxKindIdentifier:
			return evaluateEntityNameExpression(expr /* as Identifier */, location)
		case SyntaxKindPropertyAccessExpression:
			if isEntityNameExpression(expr) {
				return evaluateEntityNameExpression(expr, location)
			}
		case SyntaxKindElementAccessExpression:
			return evaluateElementAccessExpression(expr /* as ElementAccessExpression */, location)
		}
		return evaluatorResult(nil, isSyntacticallyString, resolvedOtherFiles, hasExternalReferences)
	}

	evaluateTemplateExpression := func(expr TemplateExpression, location Declaration) EvaluatorResult[*string] {
		result := expr.head.text
		resolvedOtherFiles := false
		hasExternalReferences := false
		for _, span := range expr.templateSpans {
			spanResult := evaluate(span.expression, location)
			if spanResult.value == nil {
				return evaluatorResult(nil /*isSyntacticallyString*/, true)
			}
			result += spanResult.value
			result += span.literal.text
			resolvedOtherFiles = resolvedOtherFiles || spanResult.resolvedOtherFiles
			hasExternalReferences = hasExternalReferences || spanResult.hasExternalReferences
		}
		return evaluatorResult(result, true, resolvedOtherFiles, hasExternalReferences)
	}

	return evaluate
}

/** @internal */

func isConstAssertion(location Node) bool {
	return (isAssertionExpression(location) && isConstTypeReference(location.type_)) || (isJSDocTypeTag(location) && isConstTypeReference(location.typeExpression))
}

/** @internal */

func findConstructorDeclaration(node ClassLikeDeclaration) *ConstructorDeclaration {
	members := node.members
	for _, member := range members {
		if member.kind == SyntaxKindConstructor && nodeIsPresent((member /* as ConstructorDeclaration */).body) {
			return member /* as ConstructorDeclaration */
		}
	}
}

/** @internal */

type NameResolverOptions struct {
	compilerOptions                  CompilerOptions
	getSymbolOfDeclaration           func(node Declaration) Symbol
	error                            func(location Node, message DiagnosticMessage, args DiagnosticArguments)
	globals                          SymbolTable
	argumentsSymbol                  Symbol
	requireSymbol                    Symbol
	lookup                           func(symbols SymbolTable, name __String, meaning SymbolFlags) Symbol
	setRequiresScopeChangeCache      *func(node FunctionLikeDeclaration, value bool)
	getRequiresScopeChangeCache      *func(node FunctionLikeDeclaration) *bool
	onPropertyWithInvalidInitializer func(location Node, name __String, declaration PropertyDeclaration, result Symbol) bool
	onFailedToResolveSymbol          func(location Node, name /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage)
	onSuccessfullyResolvedSymbol     func(location Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool)
}

/** @internal */

type NameResolver func(location Node, nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage *DiagnosticMessage, isUse bool, excludeGlobals bool) Symbol

/** @internal */

func createNameResolver(TODO_IDENTIFIER NameResolverOptions) NameResolver {
	/* eslint-disable no-var */
	var isolatedModulesLikeFlagName string
	if compilerOptions.verbatimModuleSyntax {
		isolatedModulesLikeFlagName = "verbatimModuleSyntax"
	} else {
		isolatedModulesLikeFlagName = "isolatedModules"
	}
	/* eslint-disable no-var */
	emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
	emptySymbols := createSymbolTable()
	return resolveNameHelper
	resolveNameHelper := func(location Node, nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage *DiagnosticMessage, isUse bool, excludeGlobals bool) Symbol {
		originalLocation := location
		// needed for did-you-mean error reporting, which gathers candidates starting from the original location
		var result Symbol
		var lastLocation Node
		var lastSelfReferenceLocation Declaration
		var propertyWithInvalidInitializer *PropertyDeclaration
		var associatedDeclarationForContainingInitializerOrBindingName /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | BindingElement | undefined */ any
		withinDeferredContext := false
		var grandparent Node
		var name /* TODO(TS-TO-GO) inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | InternalSymbolName */ any
		if isString(nameArg) {
			name = nameArg
		} else {
			name = (nameArg /* as Identifier */).escapedText
		}
	loop:
		for location {
			if name == "const" && isConstAssertion(location) {
				// `const` in an `as const` has no symbol, but issues no error because there is no *actual* lookup of the type
				// (it refers to the constant type of the expression instead)
				return nil
			}
			if isModuleOrEnumDeclaration(location) && lastLocation && location.name == lastLocation {
				// If lastLocation is the name of a namespace or enum, skip the parent since it will have is own locals that could
				// conflict.
				lastLocation = location
				location = location.parent
			}
			// Locals of a source file are not in scope (because they get merged into the global symbol table)
			if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = lookup(location.locals, name, meaning) */ TODO {
					useResult := true
					if isFunctionLike(location) && lastLocation && lastLocation != (location /* as FunctionLikeDeclaration */).body {
						// symbol lookup restrictions for function-like declarations
						// - Type parameters of a function are in scope in the entire function declaration, including the parameter
						//   list and return type. However, local types are only in scope in the function body.
						// - parameters are only in the scope of function body
						// This restriction does not apply to JSDoc comment types because they are parented
						// at a higher level than type parameters would normally be
						if meaning&result.flags&SymbolFlagsType && lastLocation.kind != SyntaxKindJSDoc {
							if result.flags & SymbolFlagsTypeParameter {
								useResult = !!(lastLocation.flags & NodeFlagsSynthesized) || lastLocation == (location /* as FunctionLikeDeclaration */).type_ || lastLocation.kind == SyntaxKindParameter || lastLocation.kind == SyntaxKindJSDocParameterTag || lastLocation.kind == SyntaxKindJSDocReturnTag || lastLocation.kind == SyntaxKindTypeParameter
							} else {
								useResult = false
							}
						}
						if meaning & result.flags & SymbolFlagsVariable {
							// expression inside parameter will lookup as normal variable scope when targeting es2015+
							if useOuterVariableScopeInParameter(result, location, lastLocation) {
								useResult = false
							} else if result.flags & SymbolFlagsFunctionScopedVariable {
								// parameters are visible only inside function body, parameter list and return type
								// technically for parameter list case here we might mix parameters and variables declared in function,
								// however it is detected separately when checking initializers of parameters
								// to make sure that they reference no variables declared after them.
								useResult = lastLocation.kind == SyntaxKindParameter || !!(lastLocation.flags & NodeFlagsSynthesized) || (lastLocation == (location /* as FunctionLikeDeclaration */).type_ && !!findAncestor(result.valueDeclaration, isParameter))
							}
						}
					} else if location.kind == SyntaxKindConditionalType {
						// A type parameter declared using 'infer T' in a conditional type is visible only in
						// the true branch of the conditional type.
						useResult = lastLocation == location.trueType
					}

					if useResult {
						break loop
					} else {
						result = nil
					}
				}
			}
			withinDeferredContext = withinDeferredContext || getIsDeferredContext(location, lastLocation)
			switch location.kind {
			case SyntaxKindSourceFile:
				if !isExternalOrCommonJsModule(location /* as SourceFile */) {
					break
				}
				fallthrough
			case SyntaxKindModuleDeclaration:
				moduleExports := getSymbolOfDeclaration(location /* as SourceFile | ModuleDeclaration */). /* ? */ exports || emptySymbols
				if location.kind == SyntaxKindSourceFile || (isModuleDeclaration(location) && location.flags&NodeFlagsAmbient && !isGlobalScopeAugmentation(location)) {
					// It's an external module. First see if the module has an export default and if the local
					// name of that export default matches.
					if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = moduleExports.get(InternalSymbolName.Default) */ TODO {
						localSymbol := getLocalSymbolForExportDefault(result)
						if localSymbol && (result.flags & meaning) && localSymbol.escapedName == name {
							break loop
						}
						result = nil
					}

					// Because of module/namespace merging, a module's exports are in scope,
					// yet we never want to treat an export specifier as putting a member in scope.
					// Therefore, if the name we find is purely an export specifier, it is not actually considered in scope.
					// Two things to note about this:
					//     1. We have to check this without calling getSymbol. The problem with calling getSymbol
					//        on an export specifier is that it might find the export specifier itself, and try to
					//        resolve it as an alias. This will cause the checker to consider the export specifier
					//        a circular alias reference when it might not be.
					//     2. We check === SymbolFlags.Alias in order to check that the symbol is *purely*
					//        an alias. If we used &, we'd be throwing out symbols that have non alias aspects,
					//        which is not the desired behavior.
					moduleExport := moduleExports.get(name)
					if moduleExport && moduleExport.flags == SymbolFlagsAlias && (getDeclarationOfKind(moduleExport, SyntaxKindExportSpecifier) || getDeclarationOfKind(moduleExport, SyntaxKindNamespaceExport)) {
						break
					}
				}
				if name != InternalSymbolNameDefault && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = lookup(moduleExports, name, meaning & SymbolFlags.ModuleMember) */ TODO) {
					if isSourceFile(location) && location.commonJsModuleIndicator && !result.declarations. /* ? */ some(isJSDocTypeAlias) {
						result = nil
					} else {
						break loop
					}
				}
			case SyntaxKindEnumDeclaration:
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = lookup(getSymbolOfDeclaration(location as EnumDeclaration)?.exports || emptySymbols, name, meaning & SymbolFlags.EnumMember) */ TODO {
					if nameNotFoundMessage && getIsolatedModules(compilerOptions) && !(location.flags & NodeFlagsAmbient) && getSourceFileOfNode(location) != getSourceFileOfNode(result.valueDeclaration) {
						error(originalLocation, Diagnostics.Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead, unescapeLeadingUnderscores(name), isolatedModulesLikeFlagName, __TEMPLATE__(unescapeLeadingUnderscores(getSymbolOfDeclaration(location /* as EnumDeclaration */).escapedName), ".", unescapeLeadingUnderscores(name)))
					}
					break loop
				}
			case SyntaxKindPropertyDeclaration:
				if !isStatic(location) {
					ctor := findConstructorDeclaration(location.parent /* as ClassLikeDeclaration */)
					if ctor && ctor.locals {
						if lookup(ctor.locals, name, meaning&SymbolFlagsValue) {
							// Remember the property node, it will be used later to report appropriate error
							Debug.assertNode(location, isPropertyDeclaration)
							propertyWithInvalidInitializer = location
						}
					}
				}
			case SyntaxKindClassDeclaration,
				SyntaxKindClassExpression,
				SyntaxKindInterfaceDeclaration:
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = lookup(getSymbolOfDeclaration(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols, name, meaning & SymbolFlags.Type) */ TODO {
					if !isTypeParameterSymbolDeclaredInContainer(result, location) {
						// ignore type parameters not declared in this container
						result = nil
						break
					}
					if lastLocation && isStatic(lastLocation) {
						// TypeScript 1.0 spec (April 2014): 3.4.1
						// The scope of a type parameter extends over the entire declaration with which the type
						// parameter list is associated, with the exception of static member declarations in classes.
						if nameNotFoundMessage {
							error(originalLocation, Diagnostics.Static_members_cannot_reference_class_type_parameters)
						}
						return nil
					}
					break loop
				}
				if isClassExpression(location) && meaning&SymbolFlagsClass {
					className := location.name
					if className && name == className.escapedText {
						result = location.symbol
						break loop
					}
				}
			case SyntaxKindExpressionWithTypeArguments:
				if lastLocation == (location /* as ExpressionWithTypeArguments */).expression && (location.parent /* as HeritageClause */).token == SyntaxKindExtendsKeyword {
					container := location.parent.parent
					if isClassLike(container) && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = lookup(getSymbolOfDeclaration(container).members!, name, meaning & SymbolFlags.Type) */ TODO) {
						if nameNotFoundMessage {
							error(originalLocation, Diagnostics.Base_class_expressions_cannot_reference_class_type_parameters)
						}
						return nil
					}
				}
			case SyntaxKindComputedPropertyName:
				grandparent = location.parent.parent
				if isClassLike(grandparent) || grandparent.kind == SyntaxKindInterfaceDeclaration {
					// A reference to this grandparent's type parameters would be an error
					if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = lookup(getSymbolOfDeclaration(grandparent as ClassLikeDeclaration | InterfaceDeclaration).members!, name, meaning & SymbolFlags.Type) */ TODO {
						if nameNotFoundMessage {
							error(originalLocation, Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type)
						}
						return nil
					}
				}
			case SyntaxKindArrowFunction:
				if getEmitScriptTarget(compilerOptions) >= ScriptTargetES2015 {
					break
				}
				fallthrough
			case SyntaxKindMethodDeclaration,
				SyntaxKindConstructor,
				SyntaxKindGetAccessor,
				SyntaxKindSetAccessor,
				SyntaxKindFunctionDeclaration:
				if meaning&SymbolFlagsVariable && name == "arguments" {
					result = argumentsSymbol
					break loop
				}
			case SyntaxKindFunctionExpression:
				if meaning&SymbolFlagsVariable && name == "arguments" {
					result = argumentsSymbol
					break loop
				}

				if meaning & SymbolFlagsFunction {
					functionName := (location /* as FunctionExpression */).name
					if functionName && name == functionName.escapedText {
						result = (location /* as FunctionExpression */).symbol
						break loop
					}
				}
			case SyntaxKindDecorator:
				if location.parent && location.parent.kind == SyntaxKindParameter {
					location = location.parent
				}
				if location.parent && (isClassElement(location.parent) || location.parent.kind == SyntaxKindClassDeclaration) {
					location = location.parent
				}
			case SyntaxKindJSDocTypedefTag,
				SyntaxKindJSDocCallbackTag,
				SyntaxKindJSDocEnumTag,
				SyntaxKindJSDocImportTag:
				root := getJSDocRoot(location)
				if root {
					location = root.parent
				}
			case SyntaxKindParameter:
				if lastLocation && (lastLocation == (location /* as ParameterDeclaration */).initializer || lastLocation == (location /* as ParameterDeclaration */).name && isBindingPattern(lastLocation)) {
					if !associatedDeclarationForContainingInitializerOrBindingName {
						associatedDeclarationForContainingInitializerOrBindingName = location /* as ParameterDeclaration */
					}
				}
			case SyntaxKindBindingElement:
				if lastLocation && (lastLocation == (location /* as BindingElement */).initializer || lastLocation == (location /* as BindingElement */).name && isBindingPattern(lastLocation)) {
					if isPartOfParameterDeclaration(location /* as BindingElement */) && !associatedDeclarationForContainingInitializerOrBindingName {
						associatedDeclarationForContainingInitializerOrBindingName = location /* as BindingElement */
					}
				}
			case SyntaxKindInferType:
				if meaning & SymbolFlagsTypeParameter {
					parameterName := (location /* as InferTypeNode */).typeParameter.name
					if parameterName && name == parameterName.escapedText {
						result = (location /* as InferTypeNode */).typeParameter.symbol
						break loop
					}
				}
			case SyntaxKindExportSpecifier:
				if lastLocation && lastLocation == (location /* as ExportSpecifier */).propertyName && (location /* as ExportSpecifier */).parent.parent.moduleSpecifier {
					location = location.parent.parent.parent
				}
			}
			if isSelfReferenceLocation(location, lastLocation) {
				lastSelfReferenceLocation = location
			}
			lastLocation = location
			switch {
			case isJSDocTemplateTag(location):
				location = getEffectiveContainerForJSDocTemplateTag(location) || location.parent
			case isJSDocParameterTag(location) || isJSDocReturnTag(location):
				location = getHostSignatureFromJSDoc(location) || location.parent
			default:
				location = location.parent
			}
		}

		// We just climbed up parents looking for the name, meaning that we started in a descendant node of `lastLocation`.
		// If `result === lastSelfReferenceLocation.symbol`, that means that we are somewhere inside `lastSelfReferenceLocation` looking up a name, and resolving to `lastLocation` itself.
		// That means that this is a self-reference of `lastLocation`, and shouldn't count this when considering whether `lastLocation` is used.
		if isUse && result && (!lastSelfReferenceLocation || result != lastSelfReferenceLocation.symbol) {
			result.isReferenced |= meaning
		}

		if !result {
			if lastLocation {
				Debug.assertNode(lastLocation, isSourceFile)
				if lastLocation.commonJsModuleIndicator && name == "exports" && meaning&lastLocation.symbol.flags {
					return lastLocation.symbol
				}
			}

			if !excludeGlobals {
				result = lookup(globals, name, meaning)
			}
		}
		if !result {
			if originalLocation && isInJSFile(originalLocation) && originalLocation.parent {
				if isRequireCall(originalLocation.parent /*requireStringLiteralLikeArgument*/, false) {
					return requireSymbol
				}
			}
		}

		if nameNotFoundMessage {
			if propertyWithInvalidInitializer && onPropertyWithInvalidInitializer(originalLocation, name, propertyWithInvalidInitializer, result) {
				return nil
			}
			if !result {
				onFailedToResolveSymbol(originalLocation, nameArg, meaning, nameNotFoundMessage)
			} else {
				onSuccessfullyResolvedSymbol(originalLocation, result, meaning, lastLocation, associatedDeclarationForContainingInitializerOrBindingName, withinDeferredContext)
			}
		}

		return result
	}

	useOuterVariableScopeInParameter := func(result Symbol, location Node, lastLocation Node) bool {
		target := getEmitScriptTarget(compilerOptions)
		functionLocation := location /* as FunctionLikeDeclaration */
		if isParameter(lastLocation) && functionLocation.body && result.valueDeclaration && result.valueDeclaration.pos >= functionLocation.body.pos && result.valueDeclaration.end <= functionLocation.body.end {
			// check for several cases where we introduce temporaries that require moving the name/initializer of the parameter to the body
			// - static field in a class expression
			// - optional chaining pre-es2020
			// - nullish coalesce pre-es2020
			// - spread assignment in binding pattern pre-es2017
			if target >= ScriptTargetES2015 {
				declarationRequiresScopeChange := getRequiresScopeChangeCache(functionLocation)
				if declarationRequiresScopeChange == nil {
					declarationRequiresScopeChange = forEach(functionLocation.parameters, requiresScopeChange) || false
					setRequiresScopeChangeCache(functionLocation, declarationRequiresScopeChange)
				}
				return !declarationRequiresScopeChange
			}
		}
		return false

		requiresScopeChange := func(node ParameterDeclaration) bool {
			return requiresScopeChangeWorker(node.name) || !!node.initializer && requiresScopeChangeWorker(node.initializer)
		}

		requiresScopeChangeWorker := func(node Node) bool {
			switch node.kind {
			case SyntaxKindArrowFunction,
				SyntaxKindFunctionExpression,
				SyntaxKindFunctionDeclaration,
				SyntaxKindConstructor:
				return false
			case SyntaxKindMethodDeclaration,
				SyntaxKindGetAccessor,
				SyntaxKindSetAccessor,
				SyntaxKindPropertyAssignment:
				return requiresScopeChangeWorker((node /* as MethodDeclaration | AccessorDeclaration | PropertyAssignment */).name)
			case SyntaxKindPropertyDeclaration:
				if hasStaticModifier(node) {
					return !emitStandardClassFields
				}
				return requiresScopeChangeWorker((node /* as PropertyDeclaration */).name)
			default:
				if isNullishCoalesce(node) || isOptionalChain(node) {
					return target < ScriptTargetES2020
				}
				if isBindingElement(node) && node.dotDotDotToken && isObjectBindingPattern(node.parent) {
					return target < ScriptTargetES2017
				}
				if isTypeNode(node) {
					return false
				}
				return forEachChild(node, requiresScopeChangeWorker) || false
			}
		}

	}

	getIsDeferredContext := func(location Node, lastLocation Node) bool {
		if location.kind != SyntaxKindArrowFunction && location.kind != SyntaxKindFunctionExpression {
			// initializers in instance property declaration of class like entities are executed in constructor and thus deferred
			return isTypeQueryNode(location) || ((isFunctionLikeDeclaration(location) || (location.kind == SyntaxKindPropertyDeclaration && !isStatic(location))) && (!lastLocation || lastLocation != (location /* as SignatureDeclaration | PropertyDeclaration */).name))
			// A name is evaluated within the enclosing scope - so it shouldn't count as deferred
		}
		if lastLocation && lastLocation == (location /* as FunctionExpression | ArrowFunction */).name {
			return false
		}
		// generator functions and async functions are not inlined in control flow when immediately invoked
		if (location /* as FunctionExpression | ArrowFunction */).asteriskToken || hasSyntacticModifier(location, ModifierFlagsAsync) {
			return true
		}
		return !getImmediatelyInvokedFunctionExpression(location)
	}

	type SelfReferenceLocation /* TODO(TS-TO-GO) TypeNode UnionType: | ParameterDeclaration | FunctionDeclaration | ClassDeclaration | InterfaceDeclaration | EnumDeclaration | TypeAliasDeclaration | ModuleDeclaration */ any

	isSelfReferenceLocation := func(node Node, lastLocation Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is SelfReferenceLocation */ any {
		switch node.kind {
		case SyntaxKindParameter:
			return !!lastLocation && lastLocation == (node /* as ParameterDeclaration */).name
		case SyntaxKindFunctionDeclaration,
			SyntaxKindClassDeclaration,
			SyntaxKindInterfaceDeclaration,
			SyntaxKindEnumDeclaration,
			SyntaxKindTypeAliasDeclaration,
			SyntaxKindModuleDeclaration:
			return true
		default:
			return false
		}
	}

	isTypeParameterSymbolDeclaredInContainer := func(symbol Symbol, container Node) bool {
		if symbol.declarations {
			for _, decl := range symbol.declarations {
				if decl.kind == SyntaxKindTypeParameter {
					var parent Node
					if isJSDocTemplateTag(decl.parent) {
						parent = getJSDocHost(decl.parent)
					} else {
						parent = decl.parent
					}
					if parent == container {
						return !(isJSDocTemplateTag(decl.parent) && find((decl.parent.parent /* as JSDoc */).tags, isJSDocTypeAlias))
					}
				}
			}
		}

		return false
	}

}

/** @internal */

func isPrimitiveLiteralValue(node Expression, includeBigInt bool /*  = true */) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is PrimitiveLiteral */ any {
	Debug.type_(node)
	switch node.kind {
	case SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindNumericLiteral,
		SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral:
		return true
	case SyntaxKindBigIntLiteral:
		return includeBigInt
	case SyntaxKindPrefixUnaryExpression:
		if node.operator == SyntaxKindMinusToken {
			return isNumericLiteral(node.operand) || (includeBigInt && isBigIntLiteral(node.operand))
		}
		if node.operator == SyntaxKindPlusToken {
			return isNumericLiteral(node.operand)
		}
		return false
	default:
		assertType(node)
		return false
	}
}

/** @internal */

func unwrapParenthesizedExpression(o Expression) Expression {
	for o.kind == SyntaxKindParenthesizedExpression {
		o = (o /* as ParenthesizedExpression */).expression
	}
	return o
}

/** @internal */

func hasInferredType(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is HasInferredType */ any {
	Debug.type_(node)
	switch node.kind {
	case SyntaxKindParameter,
		SyntaxKindPropertySignature,
		SyntaxKindPropertyDeclaration,
		SyntaxKindBindingElement,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression,
		SyntaxKindBinaryExpression,
		SyntaxKindVariableDeclaration,
		SyntaxKindExportAssignment,
		SyntaxKindPropertyAssignment:
		return true
	default:
		assertType(node)
		return false
	}
}

/** @internal */

func isSideEffectImport(node Node) bool {
	ancestor := findAncestor(node, isImportDeclaration)
	return !!ancestor && !ancestor.importClause
}

// require('module').builtinModules.filter(x => !x.startsWith('_'))
var unprefixedNodeCoreModulesList = []string{"assert", "assert/strict", "async_hooks", "buffer", "child_process", "cluster", "console", "constants", "crypto", "dgram", "diagnostics_channel", "dns", "dns/promises", "domain", "events", "fs", "fs/promises", "http", "http2", "https", "inspector", "inspector/promises", "module", "net", "os", "path", "path/posix", "path/win32", "perf_hooks", "process", "punycode", "querystring", "readline", "readline/promises", "repl", "stream", "stream/consumers", "stream/promises", "stream/web", "string_decoder", "sys", "test/mock_loader", "timers", "timers/promises", "tls", "trace_events", "tty", "url", "util", "util/types", "v8", "vm", "wasi", "worker_threads", "zlib"}

/** @internal */

var unprefixedNodeCoreModules Set[string] = NewSet(unprefixedNodeCoreModulesList)

// await fetch('https://nodejs.org/docs/latest/api/all.json').then(r => r.text()).then(t =>
//   new Set(t.match(/(?<=')node:.+?(?=')/g))
//     .difference(new Set(require('module').builtinModules.map(x => `node:${x}`))))

var exclusivelyPrefixedNodeCoreModules Set[string] = NewSet([]string{"node:sea", "node:sqlite", "node:test", "node:test/reporters"})

/** @internal */

var nodeCoreModules Set[string] = NewSet([]string{ /* TODO(TS-TO-GO) Node SpreadElement: ...unprefixedNodeCoreModulesList */ /* TODO(TS-TO-GO) Node SpreadElement: ...unprefixedNodeCoreModulesList.map(name => `node:${name}`) */ /* TODO(TS-TO-GO) Node SpreadElement: ...exclusivelyPrefixedNodeCoreModules */ })
