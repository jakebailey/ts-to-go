// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

type Printer struct {
	TODO_IDENTIFIER          any
	extendedDiagnostics      bool
	omitBraceSourcePositions bool
	newLine                  string
	moduleKind/* TODO(TS-TO-GO) inferred type ts.ModuleKind */ any
	bundledHelpers                 Map[string, bool]
	currentSourceFile              *SourceFile
	nodeIdToGeneratedName          []string
	nodeIdToGeneratedPrivateName   []string
	autoGeneratedIdToGeneratedName []string
	generatedNames                 Set[string]
	formattedNameTempFlagsStack    []*Map[string, TempFlags]
	formattedNameTempFlags         *Map[string, TempFlags]
	privateNameTempFlagsStack      []TempFlags
	privateNameTempFlags           TempFlags
	tempFlagsStack                 []TempFlags
	tempFlags                      TempFlags
	reservedNamesStack             []*Set[string]
	reservedNames                  *Set[string]
	reservedPrivateNamesStack      []*Set[string]
	reservedPrivateNames           *Set[string]
	preserveSourceNewlines         *bool
	nextListElementPos             *number
	writer                         EmitTextWriter
	ownWriter                      EmitTextWriter
	write/* TODO(TS-TO-GO) inferred type (s: string) => void */ any
	isOwnFileEmit                         bool
	sourceMapsDisabled                    bool
	sourceMapGenerator                    *SourceMapGenerator
	sourceMapSource                       SourceMapSource
	sourceMapSourceIndex                  number
	mostRecentlyAddedSourceMapSource      SourceMapSource
	mostRecentlyAddedSourceMapSourceIndex number
	containerPos                          number
	containerEnd                          number
	declarationListContainerEnd           number
	currentLineMap                        *[]number
	detachedCommentsInfo                  *[] /* TODO(TS-TO-GO) TypeNode TypeLiteral: { nodePos: number; detachedCommentEndPos: number; } */ any
	hasWrittenComment                     bool
	commentsDisabled                      bool
	lastSubstitution                      *Node
	currentParenthesizerRule              *ParenthesizerRule[any]
	TODO_IDENTIFIER                       any
	parenthesizer/* TODO(TS-TO-GO) inferred type ts.ParenthesizerRules */ any
	typeArgumentParenthesizerRuleSelector OrdinalParentheizerRuleSelector[TypeNode]
	emitBinaryExpression/* TODO(TS-TO-GO) inferred type (node: BinaryExpression) => void */ any
}

var brackets = createBracketsMap()

/** @internal */

func isBuildInfoFile(file string) bool {
	return fileExtensionIs(file, ExtensionTsBuildInfo)
}

/**
 * Iterates over the source files that are expected to have an emit output.
 *
 * @param host An EmitHost.
 * @param action The action to execute.
 * @param sourceFilesOrTargetSourceFile
 *   If an array, the full list of source files to emit.
 *   Else, calls `getSourceFilesToEmit` with the (optional) target source file to determine the list of source files to emit.
 *
 * @internal
 */

func forEachEmittedFile(host EmitHost, action func(emitFileNames EmitFileNames, sourceFileOrBundle Union[SourceFile, Bundle, undefined]) T, sourceFilesOrTargetSourceFile Union[[]SourceFile, SourceFile], forceDtsEmit bool /*  = false */, onlyBuildInfo bool, includeBuildInfo bool) *T {
	var sourceFiles [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
	if isArray(sourceFilesOrTargetSourceFile) {
		sourceFiles = sourceFilesOrTargetSourceFile
	} else {
		sourceFiles = getSourceFilesToEmit(host, sourceFilesOrTargetSourceFile, forceDtsEmit)
	}
	options := host.getCompilerOptions()
	if !onlyBuildInfo {
		if options.outFile {
			if sourceFiles.length != 0 {
				bundle := factory.createBundle(sourceFiles)
				result := action(getOutputPathsFor(bundle, host, forceDtsEmit), bundle)
				if result {
					return result
				}
			}
		} else {
			for _, sourceFile := range sourceFiles {
				result := action(getOutputPathsFor(sourceFile, host, forceDtsEmit), sourceFile)
				if result {
					return result
				}
			}
		}
	}
	if includeBuildInfo {
		buildInfoPath := getTsBuildInfoEmitOutputFilePath(options)
		if buildInfoPath {
			return action( /* TODO(TS-TO-GO) inferred type ts.EmitFileNames */ any{
				buildInfoPath: buildInfoPath,
			}, nil /*sourceFileOrBundle*/)
		}
	}
}

func getTsBuildInfoEmitOutputFilePath(options CompilerOptions) *string {
	configFile := options.configFilePath
	if !canEmitTsBuildInfo(options) {
		return nil
	}
	if options.tsBuildInfoFile {
		return options.tsBuildInfoFile
	}
	outPath := options.outFile
	var buildInfoExtensionLess string
	if outPath {
		buildInfoExtensionLess = removeFileExtension(outPath)
	} else {
		if !configFile {
			return nil
		}
		configFileExtensionLess := removeFileExtension(configFile)
		switch {
		case options.outDir:
			if options.rootDir {
				buildInfoExtensionLess = resolvePath(options.outDir, getRelativePathFromDirectory(options.rootDir, configFileExtensionLess, true /*ignoreCase*/))
			} else {
				buildInfoExtensionLess = combinePaths(options.outDir, getBaseFileName(configFileExtensionLess))
			}
		default:
			buildInfoExtensionLess = configFileExtensionLess
		}
	}
	return buildInfoExtensionLess + ExtensionTsBuildInfo
}

func canEmitTsBuildInfo(options CompilerOptions) bool {
	return isIncrementalCompilation(options) || options.tscBuild
}

func getOutputPathsForBundle(options CompilerOptions, forceDtsPaths bool) EmitFileNames {
	outPath := options.outFile
	var jsFilePath *string
	if options.emitDeclarationOnly {
		jsFilePath = nil
	} else {
		jsFilePath = outPath
	}
	sourceMapFilePath := jsFilePath && getSourceMapFilePath(jsFilePath, options)
	var declarationFilePath *string
	if forceDtsPaths || getEmitDeclarations(options) {
		declarationFilePath = removeFileExtension(outPath) + ExtensionDts
	} else {
		declarationFilePath = nil
	}
	var declarationMapPath *string
	if declarationFilePath && getAreDeclarationMapsEnabled(options) {
		declarationMapPath = declarationFilePath + ".map"
	} else {
		declarationMapPath = nil
	}
	return /* TODO(TS-TO-GO) inferred type ts.EmitFileNames */ any{
		jsFilePath:          jsFilePath,
		sourceMapFilePath:   sourceMapFilePath,
		declarationFilePath: declarationFilePath,
		declarationMapPath:  declarationMapPath,
	}
}

/** @internal */

func getOutputPathsFor(sourceFile Union[SourceFile, Bundle], host EmitHost, forceDtsPaths bool) EmitFileNames {
	options := host.getCompilerOptions()
	if sourceFile.kind == ast.KindBundle {
		return getOutputPathsForBundle(options, forceDtsPaths)
	} else {
		ownOutputFilePath := getOwnEmitOutputFilePath(sourceFile.fileName, host, getOutputExtension(sourceFile.fileName, options))
		isJsonFile := isJsonSourceFile(sourceFile)
		// If json file emits to the same location skip writing it, if emitDeclarationOnly skip writing it
		isJsonEmittedToSameLocation := isJsonFile && comparePaths(sourceFile.fileName, ownOutputFilePath, host.getCurrentDirectory(), !host.useCaseSensitiveFileNames()) == ComparisonEqualTo
		var jsFilePath *string
		if options.emitDeclarationOnly || isJsonEmittedToSameLocation {
			jsFilePath = nil
		} else {
			jsFilePath = ownOutputFilePath
		}
		var sourceMapFilePath *string
		if !jsFilePath || isJsonSourceFile(sourceFile) {
			sourceMapFilePath = nil
		} else {
			sourceMapFilePath = getSourceMapFilePath(jsFilePath, options)
		}
		var declarationFilePath *string
		if forceDtsPaths || (getEmitDeclarations(options) && !isJsonFile) {
			declarationFilePath = getDeclarationEmitOutputFilePath(sourceFile.fileName, host)
		} else {
			declarationFilePath = nil
		}
		var declarationMapPath *string
		if declarationFilePath && getAreDeclarationMapsEnabled(options) {
			declarationMapPath = declarationFilePath + ".map"
		} else {
			declarationMapPath = nil
		}
		return /* TODO(TS-TO-GO) inferred type ts.EmitFileNames */ any{
			jsFilePath:          jsFilePath,
			sourceMapFilePath:   sourceMapFilePath,
			declarationFilePath: declarationFilePath,
			declarationMapPath:  declarationMapPath,
		}
	}
}

func getSourceMapFilePath(jsFilePath string, options CompilerOptions) *string {
	if options.sourceMap && !options.inlineSourceMap {
		return jsFilePath + ".map"
	} else {
		return nil
	}
}

/** @internal */

func getOutputExtension(fileName string, options Pick[CompilerOptions /* TODO(TS-TO-GO) TypeNode LiteralType: "jsx" */, any]) Extension {
	switch {
	case fileExtensionIs(fileName, ExtensionJson):
		return ExtensionJson
	case options.jsx == JsxEmitPreserve && fileExtensionIsOneOf(fileName, [] /* TODO(TS-TO-GO) inferred type ts.Extension */ any{ExtensionJsx, ExtensionTsx}):
		return ExtensionJsx
	case fileExtensionIsOneOf(fileName, [] /* TODO(TS-TO-GO) inferred type ts.Extension */ any{ExtensionMts, ExtensionMjs}):
		return ExtensionMjs
	case fileExtensionIsOneOf(fileName, [] /* TODO(TS-TO-GO) inferred type ts.Extension */ any{ExtensionCts, ExtensionCjs}):
		return ExtensionCjs
	default:
		return ExtensionJs
	}
}

func getOutputPathWithoutChangingExt(inputFileName string, ignoreCase bool, outputDir *string, getCommonSourceDirectory func() string) string {
	if outputDir {
		return resolvePath(outputDir, getRelativePathFromDirectory(getCommonSourceDirectory(), inputFileName, ignoreCase))
	} else {
		return inputFileName
	}
}

/** @internal */

func getOutputDeclarationFileName(inputFileName string, configFile ParsedCommandLine, ignoreCase bool, getCommonSourceDirectory /* TODO(TS-TO-GO) inferred type () => string */ any /*  = (): string => getCommonSourceDirectoryOfConfig(configFile, ignoreCase) */) string {
	return getOutputDeclarationFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory)
}

/** @internal */

func getOutputDeclarationFileNameWorker(inputFileName string, options CompilerOptions, ignoreCase bool, getCommonSourceDirectory func() string) string {
	return changeExtension(getOutputPathWithoutChangingExt(inputFileName, ignoreCase, options.declarationDir || options.outDir, getCommonSourceDirectory), getDeclarationEmitExtensionForPath(inputFileName))
}

func getOutputJSFileName(inputFileName string, configFile ParsedCommandLine, ignoreCase bool, getCommonSourceDirectory /* TODO(TS-TO-GO) inferred type () => string */ any /*  = () => getCommonSourceDirectoryOfConfig(configFile, ignoreCase) */) *string {
	if configFile.options.emitDeclarationOnly {
		return nil
	}
	isJsonFile := fileExtensionIs(inputFileName, ExtensionJson)
	outputFileName := getOutputJSFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory)
	if !isJsonFile || comparePaths(inputFileName, outputFileName, Debug.checkDefined(configFile.options.configFilePath), ignoreCase) != ComparisonEqualTo {
		return outputFileName
	} else {
		return nil
	}
}

/** @internal */

func getOutputJSFileNameWorker(inputFileName string, options CompilerOptions, ignoreCase bool, getCommonSourceDirectory func() string) string {
	return changeExtension(getOutputPathWithoutChangingExt(inputFileName, ignoreCase, options.outDir, getCommonSourceDirectory), getOutputExtension(inputFileName, options))
}

func createAddOutput() /* TODO(TS-TO-GO) inferred type { addOutput: (path: string | undefined) => void; getOutputs: () => readonly string[]; } */ any {
	var outputs *[]string
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"addOutput":  addOutput,
		"getOutputs": getOutputs,
	}
	addOutput := func(path *string) {
		if path {
			(outputs || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: outputs = [] */ TODO)).push(path)
		}
	}

	getOutputs := func() []string {
		return outputs || emptyArray
	}

}

func getSingleOutputFileNames(configFile ParsedCommandLine, addOutput /* TODO(TS-TO-GO) TypeNode IndexedAccessType: ReturnType<typeof createAddOutput>["addOutput"] */ any) {
	TODO_IDENTIFIER := getOutputPathsForBundle(configFile.options, false /*forceDtsPaths*/)
	addOutput(jsFilePath)
	addOutput(sourceMapFilePath)
	addOutput(declarationFilePath)
	addOutput(declarationMapPath)
}

func getOwnOutputFileNames(configFile ParsedCommandLine, inputFileName string, ignoreCase bool, addOutput /* TODO(TS-TO-GO) TypeNode IndexedAccessType: ReturnType<typeof createAddOutput>["addOutput"] */ any, getCommonSourceDirectory func() string) {
	if isDeclarationFileName(inputFileName) {
		return
	}
	js := getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
	addOutput(js)
	if fileExtensionIs(inputFileName, ExtensionJson) {
		return
	}
	if js && configFile.options.sourceMap {
		addOutput(__TEMPLATE__(js, ".map"))
	}
	if getEmitDeclarations(configFile.options) {
		dts := getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
		addOutput(dts)
		if configFile.options.declarationMap {
			addOutput(__TEMPLATE__(dts, ".map"))
		}
	}
}

/** @internal */

func getCommonSourceDirectory(options CompilerOptions, emittedFiles func() []string, currentDirectory string, getCanonicalFileName GetCanonicalFileName, checkSourceFilesBelongToPath func(commonSourceDirectory string)) string {
	var commonSourceDirectory TODO
	if options.rootDir {
		// If a rootDir is specified use it as the commonSourceDirectory
		commonSourceDirectory = getNormalizedAbsolutePath(options.rootDir, currentDirectory)
		checkSourceFilesBelongToPath(options.rootDir)
	} else if options.composite && options.configFilePath {
		// Project compilations never infer their root from the input source paths
		commonSourceDirectory = getDirectoryPath(normalizeSlashes(options.configFilePath))
		checkSourceFilesBelongToPath(commonSourceDirectory)
	} else {
		commonSourceDirectory = computeCommonSourceDirectoryOfFilenames(emittedFiles(), currentDirectory, getCanonicalFileName)
	}

	if commonSourceDirectory != "" && commonSourceDirectory[commonSourceDirectory.length-1] != directorySeparator {
		// Make sure directory path ends with directory separator so this string can directly
		// used to replace with "" to get the relative path of the source file and the relative path doesn't
		// start with / making it rooted path
		commonSourceDirectory += directorySeparator
	}
	return commonSourceDirectory
}

/** @internal */

func getCommonSourceDirectoryOfConfig(TODO_IDENTIFIER ParsedCommandLine, ignoreCase bool) string {
	return getCommonSourceDirectory(options, func() []string {
		return filter(fileNames, func(file string) bool {
			return !(options.noEmitForJsFiles && fileExtensionIsOneOf(file, supportedJSExtensionsFlat)) && !isDeclarationFileName(file)
		})
	}, getDirectoryPath(normalizeSlashes(Debug.checkDefined(options.configFilePath))), createGetCanonicalFileName(!ignoreCase))
}

/** @internal */

func getAllProjectOutputs(configFile ParsedCommandLine, ignoreCase bool) []string {
	TODO_IDENTIFIER := createAddOutput()
	if configFile.options.outFile {
		getSingleOutputFileNames(configFile, addOutput)
	} else {
		getCommonSourceDirectory := memoize(func() string {
			return getCommonSourceDirectoryOfConfig(configFile, ignoreCase)
		})
		for _, inputFileName := range configFile.fileNames {
			getOwnOutputFileNames(configFile, inputFileName, ignoreCase, addOutput, getCommonSourceDirectory)
		}
	}
	addOutput(getTsBuildInfoEmitOutputFilePath(configFile.options))
	return getOutputs()
}

func getOutputFileNames(commandLine ParsedCommandLine, inputFileName string, ignoreCase bool) []string {
	inputFileName = normalizePath(inputFileName)
	Debug.assert(contains(commandLine.fileNames, inputFileName), `Expected fileName to be present in command line`)
	TODO_IDENTIFIER := createAddOutput()
	if commandLine.options.outFile {
		getSingleOutputFileNames(commandLine, addOutput)
	} else {
		getOwnOutputFileNames(commandLine, inputFileName, ignoreCase, addOutput)
	}
	return getOutputs()
}

/** @internal */

func getFirstProjectOutput(configFile ParsedCommandLine, ignoreCase bool) string {
	if configFile.options.outFile {
		TODO_IDENTIFIER := getOutputPathsForBundle(configFile.options, false /*forceDtsPaths*/)
		return Debug.checkDefined(jsFilePath || declarationFilePath, __TEMPLATE__("project ", configFile.options.configFilePath, " expected to have at least one output"))
	}

	getCommonSourceDirectory := memoize(func() string {
		return getCommonSourceDirectoryOfConfig(configFile, ignoreCase)
	})
	for _, inputFileName := range configFile.fileNames {
		if isDeclarationFileName(inputFileName) {
			continue
		}
		jsFilePath := getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
		if jsFilePath {
			return jsFilePath
		}
		if fileExtensionIs(inputFileName, ExtensionJson) {
			continue
		}
		if getEmitDeclarations(configFile.options) {
			return getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
		}
	}
	buildInfoPath := getTsBuildInfoEmitOutputFilePath(configFile.options)
	if buildInfoPath {
		return buildInfoPath
	}
	return Debug.fail(__TEMPLATE__("project ", configFile.options.configFilePath, " expected to have at least one output"))
}

/** @internal */

func emitResolverSkipsTypeChecking(emitOnly Union[bool, EmitOnly, undefined], forceDtsEmit *bool) bool {
	return forceDtsEmit && emitOnly
}

/** @internal */
// targetSourceFile is when users only want one file in entire project to be emitted. This is used in compileOnSave feature

func emitFiles(resolver EmitResolver, host EmitHost, targetSourceFile *SourceFile, TODO_IDENTIFIER EmitTransformers, emitOnly Union[bool, EmitOnly, undefined], onlyBuildInfo bool, forceDtsEmit bool, skipBuildInfo bool) EmitResult {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	compilerOptions := host.getCompilerOptions()
	var sourceMapDataList *[]SourceMapEmitResult
	if compilerOptions.sourceMap || compilerOptions.inlineSourceMap || getAreDeclarationMapsEnabled(compilerOptions) {
		sourceMapDataList = []never{}
	} else {
		sourceMapDataList = nil
	}
	var emittedFilesList *[]string
	if compilerOptions.listEmittedFiles {
		emittedFilesList = []never{}
	} else {
		emittedFilesList = nil
	}
	emitterDiagnostics := createDiagnosticCollection()
	newLine := getNewLineCharacter(compilerOptions)
	writer := createTextWriter(newLine)
	TODO_IDENTIFIER := performance.createTimer("printTime", "beforePrint", "afterPrint")
	emitSkipped := false
	/* eslint-enable no-var */

	// Emit each output file
	enter()
	forEachEmittedFile(host, emitSourceFileOrBundle, getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit), forceDtsEmit, onlyBuildInfo, targetSourceFile == nil && !skipBuildInfo)
	exit()

	return /* TODO(TS-TO-GO) inferred type ts.EmitResult */ any{
		emitSkipped:  emitSkipped,
		diagnostics:  emitterDiagnostics.getDiagnostics(),
		emittedFiles: emittedFilesList,
		sourceMaps:   sourceMapDataList,
	}

	emitSourceFileOrBundle := func(TODO_IDENTIFIER EmitFileNames, sourceFileOrBundle Union[SourceFile, Bundle, undefined]) {
		tracing. /* ? */ push(tracing.Phase.Emit, "emitJsFileOrBundle", &Args{
			jsFilePath: jsFilePath,
		})
		emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath)
		tracing. /* ? */ pop()

		tracing. /* ? */ push(tracing.Phase.Emit, "emitDeclarationFileOrBundle", &Args{
			declarationFilePath: declarationFilePath,
		})
		emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath)
		tracing. /* ? */ pop()

		tracing. /* ? */ push(tracing.Phase.Emit, "emitBuildInfo", &Args{
			buildInfoPath: buildInfoPath,
		})
		emitBuildInfo(buildInfoPath)
		tracing. /* ? */ pop()
	}

	emitBuildInfo := func(buildInfoPath *string) {
		// Write build information if applicable
		if !buildInfoPath || targetSourceFile != nil {
			return
		}
		if host.isEmitBlocked(buildInfoPath) {
			emitSkipped = true
			return
		}
		buildInfo := host.getBuildInfo() || & /* TODO(TS-TO-GO) inferred type ts.BuildInfo */ any{
			version: version,
		}
		// Pass buildinfo as additional data to avoid having to reparse
		writeFile(host, emitterDiagnostics, buildInfoPath, getBuildInfoText(buildInfo), false /*writeByteOrderMark*/, nil /*sourceFiles*/, & /* TODO(TS-TO-GO) inferred type ts.WriteFileCallbackData */ any{
			buildInfo: buildInfo,
		})
		emittedFilesList. /* ? */ push(buildInfoPath)
	}

	emitJsFileOrBundle := func(sourceFileOrBundle Union[SourceFile, Bundle, undefined], jsFilePath *string, sourceMapFilePath *string) {
		if sourceFileOrBundle == nil || emitOnly || !jsFilePath {
			return
		}

		// Make sure not to write js file and source map file if any of them cannot be written
		if host.isEmitBlocked(jsFilePath) || compilerOptions.noEmit {
			emitSkipped = true
			return
		}

		(ifElse(isSourceFile(sourceFileOrBundle), [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any{sourceFileOrBundle}, filter(sourceFileOrBundle.sourceFiles, isSourceFileNotJson))).forEach(func(sourceFile /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any) {
			if compilerOptions.noCheck || !canIncludeBindAndCheckDiagnostics(sourceFile, compilerOptions) {
				markLinkedReferences(sourceFile)
			}
		})

		// Transform the source files
		transform := transformNodes(resolver, host, factory, compilerOptions, [] /* TODO(TS-TO-GO) inferred type ts.SourceFile | ts.Bundle */ any{sourceFileOrBundle}, scriptTransformers, false /*allowDtsFiles*/)

		var printerOptions PrinterOptions = /* TODO(TS-TO-GO) inferred type ts.PrinterOptions */ any{
			removeComments:      compilerOptions.removeComments,
			newLine:             compilerOptions.newLine,
			noEmitHelpers:       compilerOptions.noEmitHelpers,
			module:              getEmitModuleKind(compilerOptions),
			moduleResolution:    getEmitModuleResolutionKind(compilerOptions),
			target:              getEmitScriptTarget(compilerOptions),
			sourceMap:           compilerOptions.sourceMap,
			inlineSourceMap:     compilerOptions.inlineSourceMap,
			inlineSources:       compilerOptions.inlineSources,
			extendedDiagnostics: compilerOptions.extendedDiagnostics,
		}

		// Create a printer to print the nodes
		printer := createPrinter(printerOptions, & /* TODO(TS-TO-GO) inferred type ts.PrintHandlers */ any{
			// resolver hooks
			hasGlobalName: resolver.hasGlobalName,
			// transform hooks
			onEmitNode:                transform.emitNodeWithNotification,
			isEmitNotificationEnabled: transform.isEmitNotificationEnabled,
			substituteNode:            transform.substituteNode,
		})

		Debug.assert(transform.transformed.length == 1, "Should only see one output from the transform")
		printSourceFileOrBundle(jsFilePath, sourceMapFilePath, transform, printer, compilerOptions)

		// Clean up emit nodes on parse tree
		transform.dispose()

		if emittedFilesList != nil {
			emittedFilesList.push(jsFilePath)
			if sourceMapFilePath {
				emittedFilesList.push(sourceMapFilePath)
			}
		}
	}

	emitDeclarationFileOrBundle := func(sourceFileOrBundle Union[SourceFile, Bundle, undefined], declarationFilePath *string, declarationMapPath *string) {
		if sourceFileOrBundle == nil || emitOnly == EmitOnlyJs {
			return
		}
		if !declarationFilePath {
			if emitOnly || compilerOptions.emitDeclarationOnly {
				emitSkipped = true
			}
			return
		}
		var sourceFiles [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if isSourceFile(sourceFileOrBundle) {
			sourceFiles = [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any{sourceFileOrBundle}
		} else {
			sourceFiles = sourceFileOrBundle.sourceFiles
		}
		var filesForEmit [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if forceDtsEmit {
			filesForEmit = sourceFiles
		} else {
			filesForEmit = filter(sourceFiles, isSourceFileNotJson)
		}
		// Setup and perform the transformation to retrieve declarations from the input files
		var inputListOrBundle [] /* TODO(TS-TO-GO) inferred type ts.SourceFile[] | ts.Bundle */ any
		if compilerOptions.outFile {
			inputListOrBundle = [] /* TODO(TS-TO-GO) inferred type ts.Bundle */ any{factory.createBundle(filesForEmit)}
		} else {
			inputListOrBundle = filesForEmit
		}
		// Checker wont collect the linked aliases since thats only done when declaration is enabled and checking is performed.
		// Do that here when emitting only dts files
		filesForEmit.forEach(func(sourceFile /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any) {
			if (emitOnly && !getEmitDeclarations(compilerOptions)) || compilerOptions.noCheck || emitResolverSkipsTypeChecking(emitOnly, forceDtsEmit) || !canIncludeBindAndCheckDiagnostics(sourceFile, compilerOptions) {
				collectLinkedAliases(sourceFile)
			}
		})

		declarationTransform := transformNodes(resolver, host, factory, compilerOptions, inputListOrBundle, declarationTransformers, false /*allowDtsFiles*/)
		if length(declarationTransform.diagnostics) != 0 {
			for _, diagnostic := range declarationTransform.diagnostics {
				emitterDiagnostics.add(diagnostic)
			}
		}

		declBlocked := (declarationTransform.diagnostics != nil && declarationTransform.diagnostics.length != 0) || host.isEmitBlocked(declarationFilePath) || compilerOptions.noEmit
		emitSkipped = emitSkipped || declBlocked
		if !declBlocked || forceDtsEmit {
			Debug.assert(declarationTransform.transformed.length == 1, "Should only see one output from the decl transform")
			var printerOptions PrinterOptions = /* TODO(TS-TO-GO) inferred type ts.PrinterOptions */ any{
				removeComments:              compilerOptions.removeComments,
				newLine:                     compilerOptions.newLine,
				noEmitHelpers:               true,
				module:                      compilerOptions.module,
				moduleResolution:            compilerOptions.moduleResolution,
				target:                      compilerOptions.target,
				sourceMap:                   emitOnly != EmitOnlyBuilderSignature && compilerOptions.declarationMap,
				inlineSourceMap:             compilerOptions.inlineSourceMap,
				extendedDiagnostics:         compilerOptions.extendedDiagnostics,
				onlyPrintJsDocStyle:         true,
				omitBraceSourceMapPositions: true,
			}

			declarationPrinter := createPrinter(printerOptions, & /* TODO(TS-TO-GO) inferred type ts.PrintHandlers */ any{
				// resolver hooks
				hasGlobalName: resolver.hasGlobalName,
				// transform hooks
				onEmitNode:                declarationTransform.emitNodeWithNotification,
				isEmitNotificationEnabled: declarationTransform.isEmitNotificationEnabled,
				substituteNode:            declarationTransform.substituteNode,
			})
			dtsWritten := printSourceFileOrBundle(declarationFilePath, declarationMapPath, declarationTransform, declarationPrinter, SourceMapOptions{
				sourceMap:           printerOptions.sourceMap,
				sourceRoot:          compilerOptions.sourceRoot,
				mapRoot:             compilerOptions.mapRoot,
				extendedDiagnostics: compilerOptions.extendedDiagnostics,
			})
			if emittedFilesList != nil {
				if dtsWritten {
					emittedFilesList.push(declarationFilePath)
				}
				if declarationMapPath {
					emittedFilesList.push(declarationMapPath)
				}
			}
		}
		declarationTransform.dispose()
	}

	collectLinkedAliases := func(node *Node) {
		if isExportAssignment(node) {
			if node.expression.kind == ast.KindIdentifier {
				resolver.collectLinkedAliases(node.expression.AsIdentifier(), true /*setVisibility*/)
			}
			return
		} else if isExportSpecifier(node) {
			resolver.collectLinkedAliases(node.propertyName || node.name, true /*setVisibility*/)
			return
		}
		forEachChild(node, collectLinkedAliases)
	}

	markLinkedReferences := func(file SourceFile) {
		if ts.isSourceFileJS(file) {
			return
			// JS files don't use reference calculations as they don't do import ellision, no need to calculate it
		}
		// JS files don't use reference calculations as they don't do import ellision, no need to calculate it
		ts.forEachChildRecursively(file, func(n /* TODO(TS-TO-GO) inferred type ts.Node */ any) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
			if isImportEqualsDeclaration(n) && ts.getSyntacticModifierFlags(n)&ts.ModifierFlags.Export == 0 {
				return "skip"
				// These are deferred and marked in a chain when referenced
			}
			// These are deferred and marked in a chain when referenced
			if ts.isImportDeclaration(n) {
				return "skip"
				// likewise, these are ultimately what get marked by calls on other nodes - we want to skip them
			}
			// likewise, these are ultimately what get marked by calls on other nodes - we want to skip them
			resolver.markLinkedReferences(n)
		})
	}

	printSourceFileOrBundle := func(jsFilePath string, sourceMapFilePath *string, transform TransformationResult[Union[SourceFile, Bundle]], printer Printer, mapOptions SourceMapOptions) bool {
		sourceFileOrBundle := transform.transformed[0]
		var bundle * /* TODO(TS-TO-GO) inferred type ts.Bundle */ any
		if sourceFileOrBundle.kind == ast.KindBundle {
			bundle = sourceFileOrBundle
		} else {
			bundle = nil
		}
		var sourceFile * /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if sourceFileOrBundle.kind == ast.KindSourceFile {
			sourceFile = sourceFileOrBundle
		} else {
			sourceFile = nil
		}
		var sourceFiles [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if bundle != nil {
			sourceFiles = bundle.sourceFiles
		} else {
			sourceFiles = [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any{sourceFile}
		}

		var sourceMapGenerator *SourceMapGenerator
		if shouldEmitSourceMaps(mapOptions, sourceFileOrBundle) {
			sourceMapGenerator = createSourceMapGenerator(host, getBaseFileName(normalizeSlashes(jsFilePath)), getSourceRoot(mapOptions), getSourceMapDirectory(mapOptions, jsFilePath, sourceFile), mapOptions)
		}

		if bundle != nil {
			printer.writeBundle(bundle, writer, sourceMapGenerator)
		} else {
			printer.writeFile(sourceFile, writer, sourceMapGenerator)
		}

		var sourceMapUrlPos TODO
		if sourceMapGenerator != nil {
			if sourceMapDataList != nil {
				sourceMapDataList.push( /* TODO(TS-TO-GO) inferred type ts.SourceMapEmitResult */ any{
					inputSourceFileNames: sourceMapGenerator.getSources(),
					sourceMap:            sourceMapGenerator.toJSON(),
				})
			}

			sourceMappingURL := getSourceMappingURL(mapOptions, sourceMapGenerator, jsFilePath, sourceMapFilePath, sourceFile)

			if sourceMappingURL != "" {
				if !writer.isAtStartOfLine() {
					writer.rawWrite(newLine)
				}
				sourceMapUrlPos = writer.getTextPos()
				writer.writeComment(__TEMPLATE__("//# ", "sourceMappingURL", "=", sourceMappingURL))
				// Tools can sometimes see this line as a source mapping url comment
			}

			// Write the source map
			if sourceMapFilePath {
				sourceMap := sourceMapGenerator.toString()
				writeFile(host, emitterDiagnostics, sourceMapFilePath, sourceMap, false /*writeByteOrderMark*/, sourceFiles)
			}
		} else {
			writer.writeLine()
		}

		// Write the output file
		text := writer.getText()
		var data WriteFileCallbackData = /* TODO(TS-TO-GO) inferred type ts.WriteFileCallbackData */ any{
			sourceMapUrlPos: sourceMapUrlPos,
			diagnostics:     transform.diagnostics,
		}
		writeFile(host, emitterDiagnostics, jsFilePath, text, compilerOptions.emitBOM, sourceFiles, data)

		// Reset state
		writer.clear()
		return !data.skippedDtsWrite
	}

	type SourceMapOptions struct {
		sourceMap           bool
		inlineSourceMap     bool
		inlineSources       bool
		sourceRoot          string
		mapRoot             string
		extendedDiagnostics bool
	}

	shouldEmitSourceMaps := func(mapOptions SourceMapOptions, sourceFileOrBundle Union[SourceFile, Bundle]) *bool {
		return (mapOptions.sourceMap || mapOptions.inlineSourceMap) && (sourceFileOrBundle.kind != ast.KindSourceFile || !fileExtensionIs(sourceFileOrBundle.fileName, ExtensionJson))
	}

	getSourceRoot := func(mapOptions SourceMapOptions) string {
		// Normalize source root and make sure it has trailing "/" so that it can be used to combine paths with the
		// relative paths of the sources list in the sourcemap
		sourceRoot := normalizeSlashes(mapOptions.sourceRoot || "")
		if sourceRoot != "" {
			return ensureTrailingDirectorySeparator(sourceRoot)
		} else {
			return sourceRoot
		}
	}

	getSourceMapDirectory := func(mapOptions SourceMapOptions, filePath string, sourceFile *SourceFile) string {
		if mapOptions.sourceRoot {
			return host.getCommonSourceDirectory()
		}
		if mapOptions.mapRoot {
			sourceMapDir := normalizeSlashes(mapOptions.mapRoot)
			if sourceFile != nil {
				// For modules or multiple emit files the mapRoot will have directory structure like the sources
				// So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
				sourceMapDir = getDirectoryPath(getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir))
			}
			if getRootLength(sourceMapDir) == 0 {
				// The relative paths are relative to the common directory
				sourceMapDir = combinePaths(host.getCommonSourceDirectory(), sourceMapDir)
			}
			return sourceMapDir
		}
		return getDirectoryPath(normalizePath(filePath))
	}

	getSourceMappingURL := func(mapOptions SourceMapOptions, sourceMapGenerator SourceMapGenerator, filePath string, sourceMapFilePath *string, sourceFile *SourceFile) string {
		if mapOptions.inlineSourceMap {
			// Encode the sourceMap into the sourceMap url
			sourceMapText := sourceMapGenerator.toString()
			base64SourceMapText := base64encode(sys, sourceMapText)
			return __TEMPLATE__("data:application/json;base64,", base64SourceMapText)
		}

		sourceMapFile := getBaseFileName(normalizeSlashes(Debug.checkDefined(sourceMapFilePath)))
		if mapOptions.mapRoot {
			sourceMapDir := normalizeSlashes(mapOptions.mapRoot)
			if sourceFile != nil {
				// For modules or multiple emit files the mapRoot will have directory structure like the sources
				// So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
				sourceMapDir = getDirectoryPath(getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir))
			}
			if getRootLength(sourceMapDir) == 0 {
				// The relative paths are relative to the common directory
				sourceMapDir = combinePaths(host.getCommonSourceDirectory(), sourceMapDir)
				return encodeURI(getRelativePathToDirectoryOrUrl(getDirectoryPath(normalizePath(filePath)), combinePaths(sourceMapDir, sourceMapFile), host.getCurrentDirectory(), host.getCanonicalFileName, true))
			} else {
				return encodeURI(combinePaths(sourceMapDir, sourceMapFile))
			}
		}
		return encodeURI(sourceMapFile)
	}

}

/** @internal */

func getBuildInfoText(buildInfo BuildInfo) string {
	return JSON.stringify(buildInfo)
}

/** @internal */

func getBuildInfo(buildInfoFile string, buildInfoText string) * /* TODO(TS-TO-GO) inferred type ts.BuildInfo */ any {
	return readJsonOrUndefined(buildInfoFile, buildInfoText) /* as BuildInfo | undefined */
}

/** @internal */

var notImplementedResolver EmitResolver = /* TODO(TS-TO-GO) inferred type ts.EmitResolver */ any{
	hasGlobalName:                             notImplemented,
	getReferencedExportContainer:              notImplemented,
	getReferencedImportDeclaration:            notImplemented,
	getReferencedDeclarationWithCollidingName: notImplemented,
	isDeclarationWithCollidingName:            notImplemented,
	isValueAliasDeclaration:                   notImplemented,
	isReferencedAliasDeclaration:              notImplemented,
	isTopLevelValueImportEqualsWithEntityName: notImplemented,
	hasNodeCheckFlag:                          notImplemented,
	isDeclarationVisible:                      notImplemented,
	isLateBound: func(_node /* TODO(TS-TO-GO) inferred type ts.Declaration */ any) bool {
		return false
	},
	collectLinkedAliases:                   notImplemented,
	markLinkedReferences:                   notImplemented,
	isImplementationOfOverload:             notImplemented,
	requiresAddingImplicitUndefined:        notImplemented,
	isExpandoFunctionDeclaration:           notImplemented,
	getPropertiesOfContainerFunction:       notImplemented,
	createTypeOfDeclaration:                notImplemented,
	createReturnTypeOfSignatureDeclaration: notImplemented,
	createTypeOfExpression:                 notImplemented,
	createLiteralConstValue:                notImplemented,
	isSymbolAccessible:                     notImplemented,
	isEntityNameVisible:                    notImplemented,
	// Returns the constant value this property access resolves to: notImplemented, or 'undefined' for a non-constant
	getConstantValue:                          notImplemented,
	getEnumMemberValue:                        notImplemented,
	getReferencedValueDeclaration:             notImplemented,
	getReferencedValueDeclarations:            notImplemented,
	getTypeReferenceSerializationKind:         notImplemented,
	isOptionalParameter:                       notImplemented,
	isArgumentsLocalBinding:                   notImplemented,
	getExternalModuleFileFromDeclaration:      notImplemented,
	isLiteralConstDeclaration:                 notImplemented,
	getJsxFactoryEntity:                       notImplemented,
	getJsxFragmentFactoryEntity:               notImplemented,
	isBindingCapturedByNode:                   notImplemented,
	getDeclarationStatementsForSourceFile:     notImplemented,
	isImportRequiredByAugmentation:            notImplemented,
	isDefinitelyReferenceToGlobalSymbolObject: notImplemented,
	createLateBoundIndexSignatures:            notImplemented,
}

type PipelinePhase int32

const (
	PipelinePhaseNotification PipelinePhase = iota
	PipelinePhaseSubstitution
	PipelinePhaseComments
	PipelinePhaseSourceMaps
	PipelinePhaseEmit
)

/** @internal */

var createPrinterWithDefaults func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(& /* TODO(TS-TO-GO) inferred type ts.PrinterOptions */ any{})
})

/** @internal */

var createPrinterWithRemoveComments func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(& /* TODO(TS-TO-GO) inferred type ts.PrinterOptions */ any{
		removeComments: true,
	})
})

/** @internal */

var createPrinterWithRemoveCommentsNeverAsciiEscape func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(& /* TODO(TS-TO-GO) inferred type ts.PrinterOptions */ any{
		removeComments:   true,
		neverAsciiEscape: true,
	})
})

/** @internal */

var createPrinterWithRemoveCommentsOmitTrailingSemicolon func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(& /* TODO(TS-TO-GO) inferred type ts.PrinterOptions */ any{
		removeComments:        true,
		omitTrailingSemicolon: true,
	})
})

func createPrinter(printerOptions PrinterOptions /*  = {} */, handlers PrintHandlers /*  = {} */) Printer {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	tc.TODO_IDENTIFIER = handlers

	tc.extendedDiagnostics = printerOptions.extendedDiagnostics
	tc.omitBraceSourcePositions = printerOptions.omitBraceSourceMapPositions
	tc.newLine = getNewLineCharacter(printerOptions)
	tc.moduleKind = getEmitModuleKind(printerOptions)
	tc.bundledHelpers = NewMap[string, bool]()

	// Map of generated names for specific nodes.
	// Map of generated names for specific nodes.
	// Map of generated names for temp and loop variables.
	// Set of names generated by the NameGenerator.
	// Stack of enclosing name generation scopes.
	// TempFlags for the current name generation scope.
	// Stack of enclosing name generation scopes.
	// TempFlags for the current name generation scope.
	// Stack of reserved names in enclosing name generation scopes.
	// Names reserved in nested name generation scopes.
	// Stack of reserved member names in enclosing name generation scopes.
	// Member names reserved in nested name generation scopes.
	tc.preserveSourceNewlines = printerOptions.preserveSourceNewlines
	// Can be overridden inside nodes with the `IgnoreSourceNewlines` emit flag.
	// See comment in `getLeadingLineTerminatorCount`.

	// Reusable `EmitTextWriter` for basic printing.
	tc.write = printer.writeBase

	// Source Maps
	tc.sourceMapsDisabled = true
	tc.sourceMapSourceIndex = -1
	tc.mostRecentlyAddedSourceMapSourceIndex = -1

	// Comments
	tc.containerPos = -1
	tc.containerEnd = -1
	tc.declarationListContainerEnd = -1
	tc.hasWrittenComment = false
	tc.commentsDisabled = printerOptions.removeComments
	tc.TODO_IDENTIFIER = performance.createTimerIf(printer.extendedDiagnostics, "commentTime", "beforeComment", "afterComment")
	tc.parenthesizer = factory.parenthesizer
	tc.typeArgumentParenthesizerRuleSelector = /* TODO(TS-TO-GO) inferred type OrdinalParentheizerRuleSelector<ts.TypeNode> */ any{
		select_: func(index number) * /* TODO(TS-TO-GO) inferred type ((typeNode: TypeNode) => TypeNode) */ any {
			if index == 0 {
				return printer.parenthesizer.parenthesizeLeadingTypeArgument
			} else {
				return nil
			}
		},
	}
	tc.emitBinaryExpression = printer.createEmitBinaryExpression()
	/* eslint-enable no-var */

	printer.reset()
	return /* TODO(TS-TO-GO) inferred type ts.Printer */ any{
		// public API
		printNode:   printNode,
		printList:   printList,
		printFile:   printFile,
		printBundle: printBundle,
		// internal API
		writeNode:   writeNode,
		writeList:   writeList,
		writeFile:   writeFile,
		writeBundle: writeBundle,
	}
}

func (printer *Printer) printNode(hint EmitHint, node *Node, sourceFile SourceFile) string {
	switch hint {
	case EmitHintSourceFile:
		Debug.assert(isSourceFile(node), "Expected a SourceFile node.")
	case EmitHintIdentifierName:
		Debug.assert(isIdentifier(node), "Expected an Identifier node.")
	case EmitHintExpression:
		Debug.assert(isExpression(node), "Expected an Expression node.")
	}
	switch node.kind {
	case ast.KindSourceFile:
		return printer.printFile(node.AsSourceFile())
	case ast.KindBundle:
		return printer.printBundle(node.AsBundle())
	}
	printer.writeNode(hint, node, sourceFile, printer.beginPrint())
	return printer.endPrint()
}

func (printer *Printer) printList(format ListFormat, nodes NodeArray[T], sourceFile SourceFile) string {
	printer.writeList(format, nodes, sourceFile, printer.beginPrint())
	return printer.endPrint()
}

func (printer *Printer) printBundle(bundle Bundle) string {
	printer.writeBundle(bundle, printer.beginPrint(), nil /*sourceMapGenerator*/)
	return printer.endPrint()
}

func (printer *Printer) printFile(sourceFile SourceFile) string {
	printer.writeFile(sourceFile, printer.beginPrint(), nil /*sourceMapGenerator*/)
	return printer.endPrint()
}

/**
 * If `sourceFile` is `undefined`, `node` must be a synthesized `TypeNode`.
 */

/* OVERLOAD: function writeNode(hint: EmitHint, node: TypeNode, sourceFile: undefined, output: EmitTextWriter): void; */
/* OVERLOAD: function writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile, output: EmitTextWriter): void; */
func (printer *Printer) writeNode(hint EmitHint, node *Node, sourceFile *SourceFile, output EmitTextWriter) {
	previousWriter := printer.writer
	printer.setWriter(output, nil /*_sourceMapGenerator*/)
	printer.print(hint, node, sourceFile)
	printer.reset()
	printer.writer = previousWriter
}

func (printer *Printer) writeList(format ListFormat, nodes NodeArray[T], sourceFile *SourceFile, output EmitTextWriter) {
	previousWriter := printer.writer
	printer.setWriter(output, nil /*_sourceMapGenerator*/)
	if sourceFile != nil {
		printer.setSourceFile(sourceFile)
	}
	printer.emitList(nil, nodes, format)
	printer.reset()
	printer.writer = previousWriter
}

func (printer *Printer) writeBundle(bundle Bundle, output EmitTextWriter, sourceMapGenerator *SourceMapGenerator) {
	printer.isOwnFileEmit = false
	previousWriter := printer.writer
	printer.setWriter(output, printer.sourceMapGenerator)
	printer.emitShebangIfNeeded(bundle)
	printer.emitPrologueDirectivesIfNeeded(bundle)
	printer.emitHelpers(bundle)
	printer.emitSyntheticTripleSlashReferencesIfNeeded(bundle)
	for _, sourceFile := range bundle.sourceFiles {
		printer.print(EmitHintSourceFile, sourceFile, sourceFile)
	}
	printer.reset()
	printer.writer = previousWriter
}

func (printer *Printer) writeFile(sourceFile SourceFile, output EmitTextWriter, sourceMapGenerator *SourceMapGenerator) {
	printer.isOwnFileEmit = true
	previousWriter := printer.writer
	printer.setWriter(output, printer.sourceMapGenerator)
	printer.emitShebangIfNeeded(sourceFile)
	printer.emitPrologueDirectivesIfNeeded(sourceFile)
	printer.print(EmitHintSourceFile, sourceFile, sourceFile)
	printer.reset()
	printer.writer = previousWriter
}

func (printer *Printer) beginPrint() /* TODO(TS-TO-GO) inferred type ts.EmitTextWriter */ any {
	return printer.ownWriter || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: ownWriter = createTextWriter(newLine) */ TODO)
}

func (printer *Printer) endPrint() string {
	text := printer.ownWriter.getText()
	printer.ownWriter.clear()
	return text
}

func (printer *Printer) print(hint EmitHint, node *Node, sourceFile *SourceFile) {
	if sourceFile != nil {
		printer.setSourceFile(sourceFile)
	}

	printer.pipelineEmit(hint, node, nil /*parenthesizerRule*/)
}

func (printer *Printer) setSourceFile(sourceFile *SourceFile) {
	printer.currentSourceFile = sourceFile
	printer.currentLineMap = nil
	printer.detachedCommentsInfo = nil
	if sourceFile != nil {
		printer.setSourceMapSource(sourceFile)
	}
}

func (printer *Printer) setWriter(_writer *EmitTextWriter, _sourceMapGenerator *SourceMapGenerator) {
	if _writer != nil && printerOptions.omitTrailingSemicolon {
		_writer = getTrailingSemicolonDeferringWriter(_writer)
	}

	printer.writer = _writer
	// TODO: GH#18217
	printer.sourceMapGenerator = _sourceMapGenerator
	printer.sourceMapsDisabled = !printer.writer || printer.sourceMapGenerator == nil
}

func (printer *Printer) reset() {
	printer.nodeIdToGeneratedName = []never{}
	printer.nodeIdToGeneratedPrivateName = []never{}
	printer.autoGeneratedIdToGeneratedName = []never{}
	printer.generatedNames = NewSet()
	printer.formattedNameTempFlagsStack = []never{}
	printer.formattedNameTempFlags = NewMap()
	printer.privateNameTempFlagsStack = []never{}
	printer.privateNameTempFlags = TempFlagsAuto
	printer.tempFlagsStack = []never{}
	printer.tempFlags = TempFlagsAuto
	printer.reservedNamesStack = []never{}
	printer.reservedNames = nil
	printer.reservedPrivateNamesStack = []never{}
	printer.reservedPrivateNames = nil
	printer.currentSourceFile = nil
	printer.currentLineMap = nil
	printer.detachedCommentsInfo = nil
	printer.setWriter(nil, nil /*_sourceMapGenerator*/)
}

func (printer *Printer) getCurrentLineMap() []number {
	return printer.currentLineMap || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: currentLineMap = getLineStarts(Debug.checkDefined(currentSourceFile)) */ TODO)
}

/* OVERLOAD: function emit<T extends Node>(node: T, parenthesizerRule?: (node: T) => T): void; */
/* OVERLOAD: function emit<T extends Node>(node: T | undefined, parenthesizerRule?: (node: T) => T): void; */
func (printer *Printer) emit(node *T, parenthesizerRule func(node T) T) {
	if node == nil {
		return
	}
	printer.pipelineEmit(EmitHintUnspecified, node, parenthesizerRule)
}

/* OVERLOAD: function emitIdentifierName(node: Identifier): void; */
/* OVERLOAD: function emitIdentifierName(node: Identifier | undefined): void; */
func (printer *Printer) emitIdentifierName(node *Identifier) {
	if node == nil {
		return
	}
	printer.pipelineEmit(EmitHintIdentifierName, node, nil /*parenthesizerRule*/)
}

/* OVERLOAD: function emitExpression<T extends Expression>(node: T, parenthesizerRule?: (node: T) => T): void; */
/* OVERLOAD: function emitExpression<T extends Expression>(node: T | undefined, parenthesizerRule?: (node: T) => T): void; */
func (printer *Printer) emitExpression(node *T, parenthesizerRule func(node T) T) {
	if node == nil {
		return
	}
	printer.pipelineEmit(EmitHintExpression, node, parenthesizerRule)
}

func (printer *Printer) emitJsxAttributeValue(node JsxAttributeValue) {
	printer.pipelineEmit(ifElse(isStringLiteral(node), EmitHintJsxAttributeValue, EmitHintUnspecified), node)
}

func (printer *Printer) beforeEmitNode(node *Node) {
	if printer.preserveSourceNewlines && (getInternalEmitFlags(node)&InternalEmitFlagsIgnoreSourceNewlines != 0) {
		printer.preserveSourceNewlines = false
	}
}

func (printer *Printer) afterEmitNode(savedPreserveSourceNewlines *bool) {
	printer.preserveSourceNewlines = savedPreserveSourceNewlines
}

func (printer *Printer) pipelineEmit(emitHint EmitHint, node T, parenthesizerRule func(node T) T) {
	printer.currentParenthesizerRule = parenthesizerRule
	pipelinePhase := printer.getPipelinePhase(PipelinePhaseNotification, emitHint, node)
	pipelinePhase(emitHint, node)
	printer.currentParenthesizerRule = nil
}

func (printer *Printer) shouldEmitComments(node *Node) bool {
	return !printer.commentsDisabled && !isSourceFile(node)
}

func (printer *Printer) shouldEmitSourceMaps(node *Node) bool {
	return !printer.sourceMapsDisabled && !isSourceFile(node) && !isInJsonFile(node)
}

func (printer *Printer) getPipelinePhase(phase PipelinePhase, emitHint EmitHint, node *Node) /* TODO(TS-TO-GO) inferred type (hint: EmitHint, node: Node) => void */ any {
	switch phase {
	case PipelinePhaseNotification:
		if onEmitNode != noEmitNotification && (isEmitNotificationEnabled == nil || isEmitNotificationEnabled(node)) {
			return printer.pipelineEmitWithNotification
		}
		fallthrough
	case PipelinePhaseSubstitution:
		if substituteNode != noEmitSubstitution && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: lastSubstitution = substituteNode(emitHint, node) || node */ TODO) != node {
			if printer.currentParenthesizerRule != nil {
				printer.lastSubstitution = printer.currentParenthesizerRule(printer.lastSubstitution)
			}
			return printer.pipelineEmitWithSubstitution
		}
		fallthrough
	case PipelinePhaseComments:
		if printer.shouldEmitComments(node) {
			return printer.pipelineEmitWithComments
		}
		fallthrough
	case PipelinePhaseSourceMaps:
		if printer.shouldEmitSourceMaps(node) {
			return printer.pipelineEmitWithSourceMaps
		}
		fallthrough
	case PipelinePhaseEmit:
		return printer.pipelineEmitWithHint
	default:
		return Debug.assertNever(phase)
	}
}

func (printer *Printer) getNextPipelinePhase(currentPhase PipelinePhase, emitHint EmitHint, node *Node) /* TODO(TS-TO-GO) inferred type (hint: EmitHint, node: Node) => void */ any {
	return printer.getPipelinePhase(currentPhase+1, emitHint, node)
}

func (printer *Printer) pipelineEmitWithNotification(hint EmitHint, node *Node) {
	pipelinePhase := printer.getNextPipelinePhase(PipelinePhaseNotification, hint, node)
	onEmitNode(hint, node, pipelinePhase)
}

func (printer *Printer) pipelineEmitWithHint(hint EmitHint, node *Node) {
	onBeforeEmitNode(node)
	if printer.preserveSourceNewlines {
		savedPreserveSourceNewlines := printer.preserveSourceNewlines
		printer.beforeEmitNode(node)
		printer.pipelineEmitWithHintWorker(hint, node)
		printer.afterEmitNode(savedPreserveSourceNewlines)
	} else {
		printer.pipelineEmitWithHintWorker(hint, node)
	}
	onAfterEmitNode(node)
	// clear the parenthesizer rule as we ascend
	printer.currentParenthesizerRule = nil
}

func (printer *Printer) pipelineEmitWithHintWorker(hint EmitHint, node *Node, allowSnippets bool /*  = true */) {
	if allowSnippets {
		snippet := getSnippetElement(node)
		if snippet != nil {
			return printer.emitSnippetNode(hint, node, snippet)
		}
	}
	if hint == EmitHintSourceFile {
		return printer.emitSourceFile(cast(node, isSourceFile))
	}
	if hint == EmitHintIdentifierName {
		return printer.emitIdentifier(cast(node, isIdentifier))
	}
	if hint == EmitHintJsxAttributeValue {
		return printer.emitLiteral(cast(node, isStringLiteral), true /*jsxAttributeEscape*/)
	}
	if hint == EmitHintMappedTypeParameter {
		return printer.emitMappedTypeParameter(cast(node, isTypeParameterDeclaration))
	}
	if hint == EmitHintImportTypeNodeAttributes {
		return printer.emitImportTypeNodeAttributes(cast(node, isImportAttributes))
	}
	if hint == EmitHintEmbeddedStatement {
		Debug.assertNode(node, isEmptyStatement)
		return printer.emitEmptyStatement(true)
	}
	if hint == EmitHintUnspecified {
		switch node.kind {
		case ast.KindTemplateHead,
			ast.KindTemplateMiddle,
			ast.KindTemplateTail:
			return printer.emitLiteral(node.AsLiteralExpression(), false /*jsxAttributeEscape*/)

			// Identifiers
		case ast.KindIdentifier:
			return printer.emitIdentifier(node.AsIdentifier())

			// PrivateIdentifiers
		case ast.KindPrivateIdentifier:
			return printer.emitPrivateIdentifier(node.AsPrivateIdentifier())

			// Parse tree nodes
			// Names
		case ast.KindQualifiedName:
			return printer.emitQualifiedName(node.AsQualifiedName())
		case ast.KindComputedPropertyName:
			return printer.emitComputedPropertyName(node.AsComputedPropertyName())

			// Signature elements
		case ast.KindTypeParameter:
			return printer.emitTypeParameter(node.AsTypeParameterDeclaration())
		case ast.KindParameter:
			return printer.emitParameter(node.AsParameterDeclaration())
		case ast.KindDecorator:
			return printer.emitDecorator(node.AsDecorator())

			// Type members
		case ast.KindPropertySignature:
			return printer.emitPropertySignature(node.AsPropertySignature())
		case ast.KindPropertyDeclaration:
			return printer.emitPropertyDeclaration(node.AsPropertyDeclaration())
		case ast.KindMethodSignature:
			return printer.emitMethodSignature(node.AsMethodSignature())
		case ast.KindMethodDeclaration:
			return printer.emitMethodDeclaration(node.AsMethodDeclaration())
		case ast.KindClassStaticBlockDeclaration:
			return printer.emitClassStaticBlockDeclaration(node.AsClassStaticBlockDeclaration())
		case ast.KindConstructor:
			return printer.emitConstructor(node.AsConstructorDeclaration())
		case ast.KindGetAccessor,
			ast.KindSetAccessor:
			return printer.emitAccessorDeclaration(node.AsAccessorDeclaration())
		case ast.KindCallSignature:
			return printer.emitCallSignature(node.AsCallSignatureDeclaration())
		case ast.KindConstructSignature:
			return printer.emitConstructSignature(node.AsConstructSignatureDeclaration())
		case ast.KindIndexSignature:
			return printer.emitIndexSignature(node.AsIndexSignatureDeclaration())

			// Types
		case ast.KindTypePredicate:
			return printer.emitTypePredicate(node.AsTypePredicateNode())
		case ast.KindTypeReference:
			return printer.emitTypeReference(node.AsTypeReferenceNode())
		case ast.KindFunctionType:
			return printer.emitFunctionType(node.AsFunctionTypeNode())
		case ast.KindConstructorType:
			return printer.emitConstructorType(node.AsConstructorTypeNode())
		case ast.KindTypeQuery:
			return printer.emitTypeQuery(node.AsTypeQueryNode())
		case ast.KindTypeLiteral:
			return printer.emitTypeLiteral(node.AsTypeLiteralNode())
		case ast.KindArrayType:
			return printer.emitArrayType(node.AsArrayTypeNode())
		case ast.KindTupleType:
			return printer.emitTupleType(node.AsTupleTypeNode())
		case ast.KindOptionalType:
			return printer.emitOptionalType(node.AsOptionalTypeNode())
			// SyntaxKind.RestType is handled below
		case ast.KindUnionType:
			return printer.emitUnionType(node.AsUnionTypeNode())
		case ast.KindIntersectionType:
			return printer.emitIntersectionType(node.AsIntersectionTypeNode())
		case ast.KindConditionalType:
			return printer.emitConditionalType(node.AsConditionalTypeNode())
		case ast.KindInferType:
			return printer.emitInferType(node.AsInferTypeNode())
		case ast.KindParenthesizedType:
			return printer.emitParenthesizedType(node.AsParenthesizedTypeNode())
		case ast.KindExpressionWithTypeArguments:
			return printer.emitExpressionWithTypeArguments(node.AsExpressionWithTypeArguments())
		case ast.KindThisType:
			return printer.emitThisType()
		case ast.KindTypeOperator:
			return printer.emitTypeOperator(node.AsTypeOperatorNode())
		case ast.KindIndexedAccessType:
			return printer.emitIndexedAccessType(node.AsIndexedAccessTypeNode())
		case ast.KindMappedType:
			return printer.emitMappedType(node.AsMappedTypeNode())
		case ast.KindLiteralType:
			return printer.emitLiteralType(node.AsLiteralTypeNode())
		case ast.KindNamedTupleMember:
			return printer.emitNamedTupleMember(node.AsNamedTupleMember())
		case ast.KindTemplateLiteralType:
			return printer.emitTemplateType(node.AsTemplateLiteralTypeNode())
		case ast.KindTemplateLiteralTypeSpan:
			return printer.emitTemplateTypeSpan(node.AsTemplateLiteralTypeSpan())
		case ast.KindImportType:
			return printer.emitImportTypeNode(node.AsImportTypeNode())

			// Binding patterns
		case ast.KindObjectBindingPattern:
			return printer.emitObjectBindingPattern(node.AsObjectBindingPattern())
		case ast.KindArrayBindingPattern:
			return printer.emitArrayBindingPattern(node.AsArrayBindingPattern())
		case ast.KindBindingElement:
			return printer.emitBindingElement(node.AsBindingElement())

			// Misc
		case ast.KindTemplateSpan:
			return printer.emitTemplateSpan(node.AsTemplateSpan())
		case ast.KindSemicolonClassElement:
			return printer.emitSemicolonClassElement()

			// Statements
		case ast.KindBlock:
			return printer.emitBlock(node.AsBlock())
		case ast.KindVariableStatement:
			return printer.emitVariableStatement(node.AsVariableStatement())
		case ast.KindEmptyStatement:
			return printer.emitEmptyStatement(false)
		case ast.KindExpressionStatement:
			return printer.emitExpressionStatement(node.AsExpressionStatement())
		case ast.KindIfStatement:
			return printer.emitIfStatement(node.AsIfStatement())
		case ast.KindDoStatement:
			return printer.emitDoStatement(node.AsDoStatement())
		case ast.KindWhileStatement:
			return printer.emitWhileStatement(node.AsWhileStatement())
		case ast.KindForStatement:
			return printer.emitForStatement(node.AsForStatement())
		case ast.KindForInStatement:
			return printer.emitForInStatement(node.AsForInStatement())
		case ast.KindForOfStatement:
			return printer.emitForOfStatement(node.AsForOfStatement())
		case ast.KindContinueStatement:
			return printer.emitContinueStatement(node.AsContinueStatement())
		case ast.KindBreakStatement:
			return printer.emitBreakStatement(node.AsBreakStatement())
		case ast.KindReturnStatement:
			return printer.emitReturnStatement(node.AsReturnStatement())
		case ast.KindWithStatement:
			return printer.emitWithStatement(node.AsWithStatement())
		case ast.KindSwitchStatement:
			return printer.emitSwitchStatement(node.AsSwitchStatement())
		case ast.KindLabeledStatement:
			return printer.emitLabeledStatement(node.AsLabeledStatement())
		case ast.KindThrowStatement:
			return printer.emitThrowStatement(node.AsThrowStatement())
		case ast.KindTryStatement:
			return printer.emitTryStatement(node.AsTryStatement())
		case ast.KindDebuggerStatement:
			return printer.emitDebuggerStatement(node.AsDebuggerStatement())

			// Declarations
		case ast.KindVariableDeclaration:
			return printer.emitVariableDeclaration(node.AsVariableDeclaration())
		case ast.KindVariableDeclarationList:
			return printer.emitVariableDeclarationList(node.AsVariableDeclarationList())
		case ast.KindFunctionDeclaration:
			return printer.emitFunctionDeclaration(node.AsFunctionDeclaration())
		case ast.KindClassDeclaration:
			return printer.emitClassDeclaration(node.AsClassDeclaration())
		case ast.KindInterfaceDeclaration:
			return printer.emitInterfaceDeclaration(node.AsInterfaceDeclaration())
		case ast.KindTypeAliasDeclaration:
			return printer.emitTypeAliasDeclaration(node.AsTypeAliasDeclaration())
		case ast.KindEnumDeclaration:
			return printer.emitEnumDeclaration(node.AsEnumDeclaration())
		case ast.KindModuleDeclaration:
			return printer.emitModuleDeclaration(node.AsModuleDeclaration())
		case ast.KindModuleBlock:
			return printer.emitModuleBlock(node.AsModuleBlock())
		case ast.KindCaseBlock:
			return printer.emitCaseBlock(node.AsCaseBlock())
		case ast.KindNamespaceExportDeclaration:
			return printer.emitNamespaceExportDeclaration(node.AsNamespaceExportDeclaration())
		case ast.KindImportEqualsDeclaration:
			return printer.emitImportEqualsDeclaration(node.AsImportEqualsDeclaration())
		case ast.KindImportDeclaration:
			return printer.emitImportDeclaration(node.AsImportDeclaration())
		case ast.KindImportClause:
			return printer.emitImportClause(node.AsImportClause())
		case ast.KindNamespaceImport:
			return printer.emitNamespaceImport(node.AsNamespaceImport())
		case ast.KindNamespaceExport:
			return printer.emitNamespaceExport(node.AsNamespaceExport())
		case ast.KindNamedImports:
			return printer.emitNamedImports(node.AsNamedImports())
		case ast.KindImportSpecifier:
			return printer.emitImportSpecifier(node.AsImportSpecifier())
		case ast.KindExportAssignment:
			return printer.emitExportAssignment(node.AsExportAssignment())
		case ast.KindExportDeclaration:
			return printer.emitExportDeclaration(node.AsExportDeclaration())
		case ast.KindNamedExports:
			return printer.emitNamedExports(node.AsNamedExports())
		case ast.KindExportSpecifier:
			return printer.emitExportSpecifier(node.AsExportSpecifier())
		case ast.KindImportAttributes:
			return printer.emitImportAttributes(node.AsImportAttributes())
		case ast.KindImportAttribute:
			return printer.emitImportAttribute(node.AsImportAttribute())
		case ast.KindMissingDeclaration:
			return

			// Module references
		case ast.KindExternalModuleReference:
			return printer.emitExternalModuleReference(node.AsExternalModuleReference())

			// JSX (non-expression)
		case ast.KindJsxText:
			return printer.emitJsxText(node.AsJsxText())
		case ast.KindJsxOpeningElement,
			ast.KindJsxOpeningFragment:
			return printer.emitJsxOpeningElementOrFragment(node.AsJsxOpeningElement())
		case ast.KindJsxClosingElement,
			ast.KindJsxClosingFragment:
			return printer.emitJsxClosingElementOrFragment(node.AsJsxClosingElement())
		case ast.KindJsxAttribute:
			return printer.emitJsxAttribute(node.AsJsxAttribute())
		case ast.KindJsxAttributes:
			return printer.emitJsxAttributes(node.AsJsxAttributes())
		case ast.KindJsxSpreadAttribute:
			return printer.emitJsxSpreadAttribute(node.AsJsxSpreadAttribute())
		case ast.KindJsxExpression:
			return printer.emitJsxExpression(node.AsJsxExpression())
		case ast.KindJsxNamespacedName:
			return printer.emitJsxNamespacedName(node.AsJsxNamespacedName())

			// Clauses
		case ast.KindCaseClause:
			return printer.emitCaseClause(node.AsCaseClause())
		case ast.KindDefaultClause:
			return printer.emitDefaultClause(node.AsDefaultClause())
		case ast.KindHeritageClause:
			return printer.emitHeritageClause(node.AsHeritageClause())
		case ast.KindCatchClause:
			return printer.emitCatchClause(node.AsCatchClause())

			// Property assignments
		case ast.KindPropertyAssignment:
			return printer.emitPropertyAssignment(node.AsPropertyAssignment())
		case ast.KindShorthandPropertyAssignment:
			return printer.emitShorthandPropertyAssignment(node.AsShorthandPropertyAssignment())
		case ast.KindSpreadAssignment:
			return printer.emitSpreadAssignment(node.AsSpreadAssignment())

			// Enum
		case ast.KindEnumMember:
			return printer.emitEnumMember(node.AsEnumMember())

			// Top-level nodes
		case ast.KindSourceFile:
			return printer.emitSourceFile(node.AsSourceFile())
		case ast.KindBundle:
			return Debug.fail("Bundles should be printed using printBundle")

			// JSDoc nodes (only used in codefixes currently)
		case ast.KindJSDocTypeExpression:
			return printer.emitJSDocTypeExpression(node.AsJSDocTypeExpression())
		case ast.KindJSDocNameReference:
			return printer.emitJSDocNameReference(node.AsJSDocNameReference())
		case ast.KindJSDocAllType:
			return printer.writePunctuation("*")
		case ast.KindJSDocUnknownType:
			return printer.writePunctuation("?")
		case ast.KindJSDocNullableType:
			return printer.emitJSDocNullableType(node.AsJSDocNullableType())
		case ast.KindJSDocNonNullableType:
			return printer.emitJSDocNonNullableType(node.AsJSDocNonNullableType())
		case ast.KindJSDocOptionalType:
			return printer.emitJSDocOptionalType(node.AsJSDocOptionalType())
		case ast.KindJSDocFunctionType:
			return printer.emitJSDocFunctionType(node.AsJSDocFunctionType())
		case ast.KindRestType,
			ast.KindJSDocVariadicType:
			return printer.emitRestOrJSDocVariadicType(node /* as RestTypeNode | JSDocVariadicType */)
		case ast.KindJSDocNamepathType:
			return
		case ast.KindJSDoc:
			return printer.emitJSDoc(node.AsJSDoc())
		case ast.KindJSDocTypeLiteral:
			return printer.emitJSDocTypeLiteral(node.AsJSDocTypeLiteral())
		case ast.KindJSDocSignature:
			return printer.emitJSDocSignature(node.AsJSDocSignature())
		case ast.KindJSDocTag,
			ast.KindJSDocClassTag,
			ast.KindJSDocOverrideTag:
			return printer.emitJSDocSimpleTag(node.AsJSDocTag())
		case ast.KindJSDocAugmentsTag,
			ast.KindJSDocImplementsTag:
			return printer.emitJSDocHeritageTag(node /* as JSDocImplementsTag | JSDocAugmentsTag */)
		case ast.KindJSDocAuthorTag,
			ast.KindJSDocDeprecatedTag:
			return
			// SyntaxKind.JSDocClassTag (see JSDocTag, above)
		case ast.KindJSDocPublicTag,
			ast.KindJSDocPrivateTag,
			ast.KindJSDocProtectedTag,
			ast.KindJSDocReadonlyTag:
			return
		case ast.KindJSDocCallbackTag:
			return printer.emitJSDocCallbackTag(node.AsJSDocCallbackTag())
		case ast.KindJSDocOverloadTag:
			return printer.emitJSDocOverloadTag(node.AsJSDocOverloadTag())
			// SyntaxKind.JSDocEnumTag (see below)
		case ast.KindJSDocParameterTag,
			ast.KindJSDocPropertyTag:
			return printer.emitJSDocPropertyLikeTag(node.AsJSDocPropertyLikeTag())
		case ast.KindJSDocEnumTag,
			ast.KindJSDocReturnTag,
			ast.KindJSDocThisTag,
			ast.KindJSDocTypeTag,
			ast.KindJSDocThrowsTag,
			ast.KindJSDocSatisfiesTag:
			return printer.emitJSDocSimpleTypedTag(node /* as JSDocTypeTag | JSDocReturnTag | JSDocThisTag | JSDocTypeTag | JSDocThrowsTag | JSDocSatisfiesTag */)
		case ast.KindJSDocTemplateTag:
			return printer.emitJSDocTemplateTag(node.AsJSDocTemplateTag())
		case ast.KindJSDocTypedefTag:
			return printer.emitJSDocTypedefTag(node.AsJSDocTypedefTag())
		case ast.KindJSDocSeeTag:
			return printer.emitJSDocSeeTag(node.AsJSDocSeeTag())
		case ast.KindJSDocImportTag:
			return printer.emitJSDocImportTag(node.AsJSDocImportTag())
			// SyntaxKind.JSDocPropertyTag (see JSDocParameterTag, above)

			// Transformation nodes
		case ast.KindNotEmittedStatement,
			ast.KindNotEmittedTypeElement:
			return
		}
		if isExpression(node) {
			hint = EmitHintExpression
			if substituteNode != noEmitSubstitution {
				substitute := substituteNode(hint, node) || node
				if substitute != node {
					node = substitute
					if printer.currentParenthesizerRule != nil {
						node = printer.currentParenthesizerRule(node)
					}
				}
			}
		}
	}
	if hint == EmitHintExpression {
		switch node.kind {
		case ast.KindNumericLiteral,
			ast.KindBigIntLiteral:
			return printer.emitNumericOrBigIntLiteral(node /* as NumericLiteral | BigIntLiteral */)
		case ast.KindStringLiteral,
			ast.KindRegularExpressionLiteral,
			ast.KindNoSubstitutionTemplateLiteral:
			return printer.emitLiteral(node.AsLiteralExpression(), false /*jsxAttributeEscape*/)

			// Identifiers
		case ast.KindIdentifier:
			return printer.emitIdentifier(node.AsIdentifier())
		case ast.KindPrivateIdentifier:
			return printer.emitPrivateIdentifier(node.AsPrivateIdentifier())

			// Expressions
		case ast.KindArrayLiteralExpression:
			return printer.emitArrayLiteralExpression(node.AsArrayLiteralExpression())
		case ast.KindObjectLiteralExpression:
			return printer.emitObjectLiteralExpression(node.AsObjectLiteralExpression())
		case ast.KindPropertyAccessExpression:
			return printer.emitPropertyAccessExpression(node.AsPropertyAccessExpression())
		case ast.KindElementAccessExpression:
			return printer.emitElementAccessExpression(node.AsElementAccessExpression())
		case ast.KindCallExpression:
			return printer.emitCallExpression(node.AsCallExpression())
		case ast.KindNewExpression:
			return printer.emitNewExpression(node.AsNewExpression())
		case ast.KindTaggedTemplateExpression:
			return printer.emitTaggedTemplateExpression(node.AsTaggedTemplateExpression())
		case ast.KindTypeAssertionExpression:
			return printer.emitTypeAssertionExpression(node.AsTypeAssertion())
		case ast.KindParenthesizedExpression:
			return printer.emitParenthesizedExpression(node.AsParenthesizedExpression())
		case ast.KindFunctionExpression:
			return printer.emitFunctionExpression(node.AsFunctionExpression())
		case ast.KindArrowFunction:
			return printer.emitArrowFunction(node.AsArrowFunction())
		case ast.KindDeleteExpression:
			return printer.emitDeleteExpression(node.AsDeleteExpression())
		case ast.KindTypeOfExpression:
			return printer.emitTypeOfExpression(node.AsTypeOfExpression())
		case ast.KindVoidExpression:
			return printer.emitVoidExpression(node.AsVoidExpression())
		case ast.KindAwaitExpression:
			return printer.emitAwaitExpression(node.AsAwaitExpression())
		case ast.KindPrefixUnaryExpression:
			return printer.emitPrefixUnaryExpression(node.AsPrefixUnaryExpression())
		case ast.KindPostfixUnaryExpression:
			return printer.emitPostfixUnaryExpression(node.AsPostfixUnaryExpression())
		case ast.KindBinaryExpression:
			return printer.emitBinaryExpression(node.AsBinaryExpression())
		case ast.KindConditionalExpression:
			return printer.emitConditionalExpression(node.AsConditionalExpression())
		case ast.KindTemplateExpression:
			return printer.emitTemplateExpression(node.AsTemplateExpression())
		case ast.KindYieldExpression:
			return printer.emitYieldExpression(node.AsYieldExpression())
		case ast.KindSpreadElement:
			return printer.emitSpreadElement(node.AsSpreadElement())
		case ast.KindClassExpression:
			return printer.emitClassExpression(node.AsClassExpression())
		case ast.KindOmittedExpression:
			return
		case ast.KindAsExpression:
			return printer.emitAsExpression(node.AsAsExpression())
		case ast.KindNonNullExpression:
			return printer.emitNonNullExpression(node.AsNonNullExpression())
		case ast.KindExpressionWithTypeArguments:
			return printer.emitExpressionWithTypeArguments(node.AsExpressionWithTypeArguments())
		case ast.KindSatisfiesExpression:
			return printer.emitSatisfiesExpression(node.AsSatisfiesExpression())
		case ast.KindMetaProperty:
			return printer.emitMetaProperty(node.AsMetaProperty())
		case ast.KindSyntheticExpression:
			return Debug.fail("SyntheticExpression should never be printed.")
		case ast.KindMissingDeclaration:
			return

			// JSX
		case ast.KindJsxElement:
			return printer.emitJsxElement(node.AsJsxElement())
		case ast.KindJsxSelfClosingElement:
			return printer.emitJsxSelfClosingElement(node.AsJsxSelfClosingElement())
		case ast.KindJsxFragment:
			return printer.emitJsxFragment(node.AsJsxFragment())

			// Synthesized list
		case ast.KindSyntaxList:
			return Debug.fail("SyntaxList should not be printed")

			// Transformation nodes
		case ast.KindNotEmittedStatement:
			return
		case ast.KindPartiallyEmittedExpression:
			return printer.emitPartiallyEmittedExpression(node.AsPartiallyEmittedExpression())
		case ast.KindCommaListExpression:
			return printer.emitCommaList(node.AsCommaListExpression())
		case ast.KindSyntheticReferenceExpression:
			return Debug.fail("SyntheticReferenceExpression should not be printed")
		}
	}
	if isKeyword(node.kind) {
		return printer.writeTokenNode(node, printer.writeKeyword)
	}
	if isTokenKind(node.kind) {
		return printer.writeTokenNode(node, printer.writePunctuation)
	}
	Debug.fail(__TEMPLATE__("Unhandled SyntaxKind: ", Debug.formatSyntaxKind(node.kind), "."))
}

func (printer *Printer) emitMappedTypeParameter(node TypeParameterDeclaration) {
	printer.emit(node.name)
	printer.writeSpace()
	printer.writeKeyword("in")
	printer.writeSpace()
	printer.emit(node.constraint)
}

func (printer *Printer) pipelineEmitWithSubstitution(hint EmitHint, node *Node) {
	pipelinePhase := printer.getNextPipelinePhase(PipelinePhaseSubstitution, hint, node)
	Debug.assertIsDefined(printer.lastSubstitution)
	node = printer.lastSubstitution
	printer.lastSubstitution = nil
	pipelinePhase(hint, node)
}

func (printer *Printer) emitHelpers(node *Node) *bool {
	helpersEmitted := false
	var bundle * /* TODO(TS-TO-GO) inferred type ts.Bundle */ any
	if node.kind == ast.KindBundle {
		bundle = node.AsBundle()
	} else {
		bundle = nil
	}
	if bundle != nil && printer.moduleKind == ModuleKindNone {
		return
	}
	var numNodes number
	if bundle != nil {
		numNodes = bundle.sourceFiles.length
	} else {
		numNodes = 1
	}
	for i := 0; i < numNodes; i++ {
		var currentNode /* TODO(TS-TO-GO) inferred type ts.Node */ any
		if bundle != nil {
			currentNode = bundle.sourceFiles[i]
		} else {
			currentNode = node
		}
		var sourceFile * /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if isSourceFile(currentNode) {
			sourceFile = currentNode
		} else {
			sourceFile = printer.currentSourceFile
		}
		shouldSkip := printerOptions.noEmitHelpers || (sourceFile != nil && hasRecordedExternalHelpers(sourceFile))
		shouldBundle := isSourceFile(currentNode) && !printer.isOwnFileEmit
		helpers := printer.getSortedEmitHelpers(currentNode)
		if helpers != nil {
			for _, helper := range helpers {
				if !helper.scoped {
					// Skip the helper if it can be skipped and the noEmitHelpers compiler
					// option is set, or if it can be imported and the importHelpers compiler
					// option is set.
					if shouldSkip {
						continue
					}

					// Skip the helper if it can be bundled but hasn't already been emitted and we
					// are emitting a bundled module.
					if shouldBundle {
						if printer.bundledHelpers.get(helper.name) {
							continue
						}

						printer.bundledHelpers.set(helper.name, true)
					}
				} else if bundle != nil {
					// Skip the helper if it is scoped and we are emitting bundled helpers
					continue
				}
				if /* TODO(TS-TO-GO) Expression TypeOfExpression: typeof helper.text */ TODO == "string" {
					printer.writeLines(helper.text)
				} else {
					printer.writeLines(helper.text(printer.makeFileLevelOptimisticUniqueName))
				}
				helpersEmitted = true
			}
		}
	}

	return helpersEmitted
}

func (printer *Printer) getSortedEmitHelpers(node *Node) * /* TODO(TS-TO-GO) inferred type ts.SortedReadonlyArray<ts.EmitHelper> */ any {
	helpers := getEmitHelpers(node)
	return helpers && toSorted(helpers, compareEmitHelpers)
}

//
// Literals/Pseudo-literals
//

// SyntaxKind.NumericLiteral
// SyntaxKind.BigIntLiteral
func (printer *Printer) emitNumericOrBigIntLiteral(node Union[NumericLiteral, BigIntLiteral]) {
	printer.emitLiteral(node, false /*jsxAttributeEscape*/)
}

// SyntaxKind.StringLiteral
// SyntaxKind.RegularExpressionLiteral
// SyntaxKind.NoSubstitutionTemplateLiteral
// SyntaxKind.TemplateHead
// SyntaxKind.TemplateMiddle
// SyntaxKind.TemplateTail
func (printer *Printer) emitLiteral(node LiteralLikeNode, jsxAttributeEscape bool) {
	text := printer.getLiteralTextOfNode(node, nil /*sourceFile*/, printerOptions.neverAsciiEscape, jsxAttributeEscape)
	if (printerOptions.sourceMap || printerOptions.inlineSourceMap) && (node.kind == ast.KindStringLiteral || isTemplateLiteralKind(node.kind)) {
		printer.writeLiteral(text)
	} else {
		// Quick info expects all literals to be called with writeStringLiteral, as there's no specific type for numberLiterals
		printer.writeStringLiteral(text)
	}
}

//
// Snippet Elements
//

func (printer *Printer) emitSnippetNode(hint EmitHint, node *Node, snippet SnippetElement) {
	switch snippet.kind {
	case SnippetKindPlaceholder:
		printer.emitPlaceholder(hint, node, snippet)
	case SnippetKindTabStop:
		printer.emitTabStop(hint, node, snippet)
	}
}

func (printer *Printer) emitPlaceholder(hint EmitHint, node *Node, snippet Placeholder) {
	printer.nonEscapingWrite(__TEMPLATE__("${", snippet.order, ":"))
	// `${2:`
	printer.pipelineEmitWithHintWorker(hint, node, false /*allowSnippets*/)
	// `...`
	printer.nonEscapingWrite(`}`)
	// `${2:...}`
}

func (printer *Printer) emitTabStop(hint EmitHint, node *Node, snippet TabStop) {
	// A tab stop should only be attached to an empty node, i.e. a node that doesn't emit any text.
	Debug.assert(node.kind == ast.KindEmptyStatement, __TEMPLATE__("A tab stop cannot be attached to a node of kind ", Debug.formatSyntaxKind(node.kind), "."))
	Debug.assert(hint != EmitHintEmbeddedStatement, `A tab stop cannot be attached to an embedded statement.`)
	printer.nonEscapingWrite(__TEMPLATE__("$", snippet.order))
}

//
// Identifiers
//

func (printer *Printer) emitIdentifier(node Identifier) {
	var writeText /* TODO(TS-TO-GO) inferred type (s: string, sym: Symbol) => void */ any
	if node.symbol {
		writeText = printer.writeSymbol
	} else {
		writeText = printer.write
	}
	writeText(printer.getTextOfNode(node, false /*includeTrivia*/), node.symbol)
	printer.emitList(node, getIdentifierTypeArguments(node), ListFormatTypeParameters)
	// Call emitList directly since it could be an array of TypeParameterDeclarations _or_ type arguments
}

//
// Names
//

func (printer *Printer) emitPrivateIdentifier(node PrivateIdentifier) {
	printer.write(printer.getTextOfNode(node, false /*includeTrivia*/))
}

func (printer *Printer) emitQualifiedName(node QualifiedName) {
	printer.emitEntityName(node.left)
	printer.writePunctuation(".")
	printer.emit(node.right)
}

func (printer *Printer) emitEntityName(node EntityName) {
	if node.kind == ast.KindIdentifier {
		printer.emitExpression(node)
	} else {
		printer.emit(node)
	}
}

func (printer *Printer) emitComputedPropertyName(node ComputedPropertyName) {
	printer.writePunctuation("[")
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeExpressionOfComputedPropertyName)
	printer.writePunctuation("]")
}

//
// Signature elements
//

func (printer *Printer) emitTypeParameter(node TypeParameterDeclaration) {
	printer.emitModifierList(node, node.modifiers)
	printer.emit(node.name)
	if node.constraint != nil {
		printer.writeSpace()
		printer.writeKeyword("extends")
		printer.writeSpace()
		printer.emit(node.constraint)
	}
	if node.default_ != nil {
		printer.writeSpace()
		printer.writeOperator("=")
		printer.writeSpace()
		printer.emit(node.default_)
	}
}

func (printer *Printer) emitParameter(node ParameterDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, true /*allowDecorators*/)
	printer.emit(node.dotDotDotToken)
	printer.emitNodeWithWriter(node.name, printer.writeParameter)
	printer.emit(node.questionToken)
	if node.parent && node.parent.kind == ast.KindJSDocFunctionType && !node.name {
		printer.emit(node.type_)
	} else {
		printer.emitTypeAnnotation(node.type_)
	}
	// The comment position has to fallback to any present node within the parameterdeclaration because as it turns out, the parser can make parameter declarations with _just_ an initializer.
	printer.emitInitializer(node.initializer, ifElse(node.type_ != nil, node.type_.end, ifElse(node.questionToken != nil, node.questionToken.end, ifElse(node.name, node.name.end, ifElse(node.modifiers != nil, node.modifiers.end, node.pos)))), node, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

func (printer *Printer) emitDecorator(decorator Decorator) {
	printer.writePunctuation("@")
	printer.emitExpression(decorator.expression, printer.parenthesizer.parenthesizeLeftSideOfAccess)
}

//
// Type members
//

func (printer *Printer) emitPropertySignature(node PropertySignature) {
	printer.emitModifierList(node, node.modifiers)
	printer.emitNodeWithWriter(node.name, printer.writeProperty)
	printer.emit(node.questionToken)
	printer.emitTypeAnnotation(node.type_)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitPropertyDeclaration(node PropertyDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, true /*allowDecorators*/)
	printer.emit(node.name)
	printer.emit(node.questionToken)
	printer.emit(node.exclamationToken)
	printer.emitTypeAnnotation(node.type_)
	printer.emitInitializer(node.initializer, ifElse(node.type_ != nil, node.type_.end, ifElse(node.questionToken != nil, node.questionToken.end, node.name.end)), node)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitMethodSignature(node MethodSignature) {
	printer.emitModifierList(node, node.modifiers)
	printer.emit(node.name)
	printer.emit(node.questionToken)
	printer.emitSignatureAndBody(node, printer.emitSignatureHead, printer.emitEmptyFunctionBody)
}

func (printer *Printer) emitMethodDeclaration(node MethodDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, true /*allowDecorators*/)
	printer.emit(node.asteriskToken)
	printer.emit(node.name)
	printer.emit(node.questionToken)
	printer.emitSignatureAndBody(node, printer.emitSignatureHead, printer.emitFunctionBody)
}

func (printer *Printer) emitClassStaticBlockDeclaration(node ClassStaticBlockDeclaration) {
	printer.writeKeyword("static")
	printer.pushNameGenerationScope(node)
	printer.emitBlockFunctionBody(node.body)
	printer.popNameGenerationScope(node)
}

func (printer *Printer) emitConstructor(node ConstructorDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.writeKeyword("constructor")
	printer.emitSignatureAndBody(node, printer.emitSignatureHead, printer.emitFunctionBody)
}

func (printer *Printer) emitAccessorDeclaration(node AccessorDeclaration) {
	pos := printer.emitDecoratorsAndModifiers(node, node.modifiers, true /*allowDecorators*/)
	var token /* TODO(TS-TO-GO) inferred type ts.SyntaxKind.GetKeyword | ts.SyntaxKind.SetKeyword */ any
	if node.kind == ast.KindGetAccessor {
		token = ast.KindGetKeyword
	} else {
		token = ast.KindSetKeyword
	}
	printer.emitTokenWithComment(token, pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emit(node.name)
	printer.emitSignatureAndBody(node, printer.emitSignatureHead, printer.emitFunctionBody)
}

func (printer *Printer) emitCallSignature(node CallSignatureDeclaration) {
	printer.emitSignatureAndBody(node, printer.emitSignatureHead, printer.emitEmptyFunctionBody)
}

func (printer *Printer) emitConstructSignature(node ConstructSignatureDeclaration) {
	printer.writeKeyword("new")
	printer.writeSpace()
	printer.emitSignatureAndBody(node, printer.emitSignatureHead, printer.emitEmptyFunctionBody)
}

func (printer *Printer) emitIndexSignature(node IndexSignatureDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.emitParametersForIndexSignature(node, node.parameters)
	printer.emitTypeAnnotation(node.type_)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitTemplateTypeSpan(node TemplateLiteralTypeSpan) {
	printer.emit(node.type_)
	printer.emit(node.literal)
}

func (printer *Printer) emitSemicolonClassElement() {
	printer.writeTrailingSemicolon()
}

//
// Types
//

func (printer *Printer) emitTypePredicate(node TypePredicateNode) {
	if node.assertsModifier != nil {
		printer.emit(node.assertsModifier)
		printer.writeSpace()
	}
	printer.emit(node.parameterName)
	if node.type_ != nil {
		printer.writeSpace()
		printer.writeKeyword("is")
		printer.writeSpace()
		printer.emit(node.type_)
	}
}

func (printer *Printer) emitTypeReference(node TypeReferenceNode) {
	printer.emit(node.typeName)
	printer.emitTypeArguments(node, node.typeArguments)
}

func (printer *Printer) emitFunctionType(node FunctionTypeNode) {
	printer.emitSignatureAndBody(node, printer.emitFunctionTypeHead, printer.emitFunctionTypeBody)
}

func (printer *Printer) emitFunctionTypeHead(node Union[FunctionTypeNode, ConstructorTypeNode]) {
	printer.emitTypeParameters(node, node.typeParameters)
	printer.emitParametersForArrow(node, node.parameters)
	printer.writeSpace()
	printer.writePunctuation("=>")
}

func (printer *Printer) emitFunctionTypeBody(node Union[FunctionTypeNode, ConstructorTypeNode]) {
	printer.writeSpace()
	printer.emit(node.type_)
}

func (printer *Printer) emitJSDocFunctionType(node JSDocFunctionType) {
	printer.writeKeyword("function")
	printer.emitParameters(node, node.parameters)
	printer.writePunctuation(":")
	printer.emit(node.type_)
}

func (printer *Printer) emitJSDocNullableType(node JSDocNullableType) {
	printer.writePunctuation("?")
	printer.emit(node.type_)
}

func (printer *Printer) emitJSDocNonNullableType(node JSDocNonNullableType) {
	printer.writePunctuation("!")
	printer.emit(node.type_)
}

func (printer *Printer) emitJSDocOptionalType(node JSDocOptionalType) {
	printer.emit(node.type_)
	printer.writePunctuation("=")
}

func (printer *Printer) emitConstructorType(node ConstructorTypeNode) {
	printer.emitModifierList(node, node.modifiers)
	printer.writeKeyword("new")
	printer.writeSpace()
	printer.emitSignatureAndBody(node, printer.emitFunctionTypeHead, printer.emitFunctionTypeBody)
}

func (printer *Printer) emitTypeQuery(node TypeQueryNode) {
	printer.writeKeyword("typeof")
	printer.writeSpace()
	printer.emit(node.exprName)
	printer.emitTypeArguments(node, node.typeArguments)
}

func (printer *Printer) emitTypeLiteral(node TypeLiteralNode) {
	printer.pushNameGenerationScope(node)
	forEach(node.members, printer.generateMemberNames)

	printer.writePunctuation("{")
	var flags /* TODO(TS-TO-GO) inferred type ts.ListFormat.SingleLineTypeLiteralMembers | ts.ListFormat.MultiLineTypeLiteralMembers */ any
	if getEmitFlags(node)&EmitFlagsSingleLine != 0 {
		flags = ListFormatSingleLineTypeLiteralMembers
	} else {
		flags = ListFormatMultiLineTypeLiteralMembers
	}
	printer.emitList(node, node.members, flags|ListFormatNoSpaceIfEmpty)
	printer.writePunctuation("}")

	printer.popNameGenerationScope(node)
}

func (printer *Printer) emitArrayType(node ArrayTypeNode) {
	printer.emit(node.elementType, printer.parenthesizer.parenthesizeNonArrayTypeOfPostfixType)
	printer.writePunctuation("[")
	printer.writePunctuation("]")
}

func (printer *Printer) emitRestOrJSDocVariadicType(node Union[RestTypeNode, JSDocVariadicType]) {
	printer.writePunctuation("...")
	printer.emit(node.type_)
}

func (printer *Printer) emitTupleType(node TupleTypeNode) {
	printer.emitTokenWithComment(ast.KindOpenBracketToken, node.pos, printer.writePunctuation, node)
	var flags /* TODO(TS-TO-GO) inferred type ts.ListFormat.SingleLineTupleTypeElements | ts.ListFormat.MultiLineTupleTypeElements */ any
	if getEmitFlags(node)&EmitFlagsSingleLine != 0 {
		flags = ListFormatSingleLineTupleTypeElements
	} else {
		flags = ListFormatMultiLineTupleTypeElements
	}
	printer.emitList(node, node.elements, flags|ListFormatNoSpaceIfEmpty, printer.parenthesizer.parenthesizeElementTypeOfTupleType)
	printer.emitTokenWithComment(ast.KindCloseBracketToken, node.elements.end, printer.writePunctuation, node)
}

func (printer *Printer) emitNamedTupleMember(node NamedTupleMember) {
	printer.emit(node.dotDotDotToken)
	printer.emit(node.name)
	printer.emit(node.questionToken)
	printer.emitTokenWithComment(ast.KindColonToken, node.name.end, printer.writePunctuation, node)
	printer.writeSpace()
	printer.emit(node.type_)
}

func (printer *Printer) emitOptionalType(node OptionalTypeNode) {
	printer.emit(node.type_, printer.parenthesizer.parenthesizeTypeOfOptionalType)
	printer.writePunctuation("?")
}

func (printer *Printer) emitUnionType(node UnionTypeNode) {
	printer.emitList(node, node.types, ListFormatUnionTypeConstituents, printer.parenthesizer.parenthesizeConstituentTypeOfUnionType)
}

func (printer *Printer) emitIntersectionType(node IntersectionTypeNode) {
	printer.emitList(node, node.types, ListFormatIntersectionTypeConstituents, printer.parenthesizer.parenthesizeConstituentTypeOfIntersectionType)
}

func (printer *Printer) emitConditionalType(node ConditionalTypeNode) {
	printer.emit(node.checkType, printer.parenthesizer.parenthesizeCheckTypeOfConditionalType)
	printer.writeSpace()
	printer.writeKeyword("extends")
	printer.writeSpace()
	printer.emit(node.extendsType, printer.parenthesizer.parenthesizeExtendsTypeOfConditionalType)
	printer.writeSpace()
	printer.writePunctuation("?")
	printer.writeSpace()
	printer.emit(node.trueType)
	printer.writeSpace()
	printer.writePunctuation(":")
	printer.writeSpace()
	printer.emit(node.falseType)
}

func (printer *Printer) emitInferType(node InferTypeNode) {
	printer.writeKeyword("infer")
	printer.writeSpace()
	printer.emit(node.typeParameter)
}

func (printer *Printer) emitParenthesizedType(node ParenthesizedTypeNode) {
	printer.writePunctuation("(")
	printer.emit(node.type_)
	printer.writePunctuation(")")
}

func (printer *Printer) emitThisType() {
	printer.writeKeyword("this")
}

func (printer *Printer) emitTypeOperator(node TypeOperatorNode) {
	printer.writeTokenText(node.operator, printer.writeKeyword)
	printer.writeSpace()

	var parenthesizerRule /* TODO(TS-TO-GO) inferred type (type: TypeNode) => TypeNode */ any
	if node.operator == ast.KindReadonlyKeyword {
		parenthesizerRule = printer.parenthesizer.parenthesizeOperandOfReadonlyTypeOperator
	} else {
		parenthesizerRule = printer.parenthesizer.parenthesizeOperandOfTypeOperator
	}
	printer.emit(node.type_, parenthesizerRule)
}

func (printer *Printer) emitIndexedAccessType(node IndexedAccessTypeNode) {
	printer.emit(node.objectType, printer.parenthesizer.parenthesizeNonArrayTypeOfPostfixType)
	printer.writePunctuation("[")
	printer.emit(node.indexType)
	printer.writePunctuation("]")
}

func (printer *Printer) emitMappedType(node MappedTypeNode) {
	emitFlags := getEmitFlags(node)
	printer.writePunctuation("{")
	if emitFlags&EmitFlagsSingleLine != 0 {
		printer.writeSpace()
	} else {
		printer.writeLine()
		printer.increaseIndent()
	}
	if node.readonlyToken != nil {
		printer.emit(node.readonlyToken)
		if node.readonlyToken.kind != ast.KindReadonlyKeyword {
			printer.writeKeyword("readonly")
		}
		printer.writeSpace()
	}
	printer.writePunctuation("[")

	printer.pipelineEmit(EmitHintMappedTypeParameter, node.typeParameter)
	if node.nameType != nil {
		printer.writeSpace()
		printer.writeKeyword("as")
		printer.writeSpace()
		printer.emit(node.nameType)
	}

	printer.writePunctuation("]")
	if node.questionToken != nil {
		printer.emit(node.questionToken)
		if node.questionToken.kind != ast.KindQuestionToken {
			printer.writePunctuation("?")
		}
	}
	printer.writePunctuation(":")
	printer.writeSpace()
	printer.emit(node.type_)
	printer.writeTrailingSemicolon()
	if emitFlags&EmitFlagsSingleLine != 0 {
		printer.writeSpace()
	} else {
		printer.writeLine()
		printer.decreaseIndent()
	}
	printer.emitList(node, node.members, ListFormatPreserveLines)
	printer.writePunctuation("}")
}

func (printer *Printer) emitLiteralType(node LiteralTypeNode) {
	printer.emitExpression(node.literal)
}

func (printer *Printer) emitTemplateType(node TemplateLiteralTypeNode) {
	printer.emit(node.head)
	printer.emitList(node, node.templateSpans, ListFormatTemplateExpressionSpans)
}

func (printer *Printer) emitImportTypeNode(node ImportTypeNode) {
	if node.isTypeOf {
		printer.writeKeyword("typeof")
		printer.writeSpace()
	}
	printer.writeKeyword("import")
	printer.writePunctuation("(")
	printer.emit(node.argument)
	if node.attributes != nil {
		printer.writePunctuation(",")
		printer.writeSpace()
		printer.pipelineEmit(EmitHintImportTypeNodeAttributes, node.attributes)
	}
	printer.writePunctuation(")")
	if node.qualifier != nil {
		printer.writePunctuation(".")
		printer.emit(node.qualifier)
	}
	printer.emitTypeArguments(node, node.typeArguments)
}

//
// Binding patterns
//

func (printer *Printer) emitObjectBindingPattern(node ObjectBindingPattern) {
	printer.writePunctuation("{")
	printer.emitList(node, node.elements, ListFormatObjectBindingPatternElements)
	printer.writePunctuation("}")
}

func (printer *Printer) emitArrayBindingPattern(node ArrayBindingPattern) {
	printer.writePunctuation("[")
	printer.emitList(node, node.elements, ListFormatArrayBindingPatternElements)
	printer.writePunctuation("]")
}

func (printer *Printer) emitBindingElement(node BindingElement) {
	printer.emit(node.dotDotDotToken)
	if node.propertyName != nil {
		printer.emit(node.propertyName)
		printer.writePunctuation(":")
		printer.writeSpace()
	}
	printer.emit(node.name)
	printer.emitInitializer(node.initializer, node.name.end, node, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

//
// Expressions
//

func (printer *Printer) emitArrayLiteralExpression(node ArrayLiteralExpression) {
	elements := node.elements
	var preferNewLine /* TODO(TS-TO-GO) inferred type ts.ListFormat.None | ts.ListFormat.PreferNewLine */ any
	if node.multiLine {
		preferNewLine = ListFormatPreferNewLine
	} else {
		preferNewLine = ListFormatNone
	}
	printer.emitExpressionList(node, elements, ListFormatArrayLiteralExpressionElements|preferNewLine, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

func (printer *Printer) emitObjectLiteralExpression(node ObjectLiteralExpression) {
	printer.pushNameGenerationScope(node)
	forEach(node.properties, printer.generateMemberNames)

	indentedFlag := getEmitFlags(node) & EmitFlagsIndented
	if indentedFlag != 0 {
		printer.increaseIndent()
	}

	var preferNewLine /* TODO(TS-TO-GO) inferred type ts.ListFormat.None | ts.ListFormat.PreferNewLine */ any
	if node.multiLine {
		preferNewLine = ListFormatPreferNewLine
	} else {
		preferNewLine = ListFormatNone
	}
	var allowTrailingComma /* TODO(TS-TO-GO) inferred type ts.ListFormat.None | ts.ListFormat.AllowTrailingComma */ any
	if printer.currentSourceFile != nil && printer.currentSourceFile.languageVersion >= ScriptTargetES5 && !isJsonSourceFile(printer.currentSourceFile) {
		allowTrailingComma = ListFormatAllowTrailingComma
	} else {
		allowTrailingComma = ListFormatNone
	}
	printer.emitList(node, node.properties, ListFormatObjectLiteralExpressionProperties|allowTrailingComma|preferNewLine)

	if indentedFlag != 0 {
		printer.decreaseIndent()
	}

	printer.popNameGenerationScope(node)
}

func (printer *Printer) emitPropertyAccessExpression(node PropertyAccessExpression) {
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeLeftSideOfAccess)
	token := node.questionDotToken || setTextRangePosEnd(factory.createToken(ast.KindDotToken).AsDotToken(), node.expression.end, node.name.pos)
	linesBeforeDot := printer.getLinesBetweenNodes(node, node.expression, token)
	linesAfterDot := printer.getLinesBetweenNodes(node, token, node.name)

	printer.writeLinesAndIndent(linesBeforeDot, false /*writeSpaceIfNotIndenting*/)

	shouldEmitDotDot := token.kind != ast.KindQuestionDotToken && printer.mayNeedDotDotForPropertyAccess(node.expression) && !printer.writer.hasTrailingComment() && !printer.writer.hasTrailingWhitespace()

	if shouldEmitDotDot {
		printer.writePunctuation(".")
	}

	if node.questionDotToken != nil {
		printer.emit(token)
	} else {
		printer.emitTokenWithComment(token.kind, node.expression.end, printer.writePunctuation, node)
	}
	printer.writeLinesAndIndent(linesAfterDot, false /*writeSpaceIfNotIndenting*/)
	printer.emit(node.name)
	printer.decreaseIndentIf(linesBeforeDot, linesAfterDot)
}

// 1..toString is a valid property access, emit a dot after the literal
// Also emit a dot if expression is a integer const enum value - it will appear in generated code as numeric literal
func (printer *Printer) mayNeedDotDotForPropertyAccess(expression Expression) *bool {
	expression = skipPartiallyEmittedExpressions(expression)
	if isNumericLiteral(expression) {
		// check if numeric literal is a decimal literal that was originally written with a dot
		text := printer.getLiteralTextOfNode(expression.AsLiteralExpression(), nil /*sourceFile*/, true /*neverAsciiEscape*/, false /*jsxAttributeEscape*/)
		// If the number will be printed verbatim and it doesn't already contain a dot or an exponent indicator, add one
		// if the expression doesn't have any comments that will be emitted.
		return expression.numericLiteralFlags&TokenFlagsWithSpecifier == 0 && !text.includes(tokenToString(ast.KindDotToken)) && !text.includes(String.fromCharCode(CharacterCodesE)) && !text.includes(String.fromCharCode(CharacterCodese))
	} else if isAccessExpression(expression) {
		// check if constant enum value is a non-negative integer
		constantValue := getConstantValue(expression)
		// isFinite handles cases when constantValue is undefined
		return /* TODO(TS-TO-GO) Expression TypeOfExpression: typeof constantValue */ TODO == "number" && isFinite(constantValue) && constantValue >= 0 && Math.floor(constantValue) == constantValue
	}
}

func (printer *Printer) emitElementAccessExpression(node ElementAccessExpression) {
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeLeftSideOfAccess)
	printer.emit(node.questionDotToken)
	printer.emitTokenWithComment(ast.KindOpenBracketToken, node.expression.end, printer.writePunctuation, node)
	printer.emitExpression(node.argumentExpression)
	printer.emitTokenWithComment(ast.KindCloseBracketToken, node.argumentExpression.end, printer.writePunctuation, node)
}

func (printer *Printer) emitCallExpression(node CallExpression) {
	indirectCall := getInternalEmitFlags(node) & InternalEmitFlagsIndirectCall
	if indirectCall != 0 {
		printer.writePunctuation("(")
		printer.writeLiteral("0")
		printer.writePunctuation(",")
		printer.writeSpace()
	}
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeLeftSideOfAccess)
	if indirectCall != 0 {
		printer.writePunctuation(")")
	}
	printer.emit(node.questionDotToken)
	printer.emitTypeArguments(node, node.typeArguments)
	printer.emitExpressionList(node, node.arguments, ListFormatCallExpressionArguments, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

func (printer *Printer) emitNewExpression(node NewExpression) {
	printer.emitTokenWithComment(ast.KindNewKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeExpressionOfNew)
	printer.emitTypeArguments(node, node.typeArguments)
	printer.emitExpressionList(node, node.arguments, ListFormatNewExpressionArguments, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

func (printer *Printer) emitTaggedTemplateExpression(node TaggedTemplateExpression) {
	indirectCall := getInternalEmitFlags(node) & InternalEmitFlagsIndirectCall
	if indirectCall != 0 {
		printer.writePunctuation("(")
		printer.writeLiteral("0")
		printer.writePunctuation(",")
		printer.writeSpace()
	}
	printer.emitExpression(node.tag, printer.parenthesizer.parenthesizeLeftSideOfAccess)
	if indirectCall != 0 {
		printer.writePunctuation(")")
	}
	printer.emitTypeArguments(node, node.typeArguments)
	printer.writeSpace()
	printer.emitExpression(node.template)
}

func (printer *Printer) emitTypeAssertionExpression(node TypeAssertion) {
	printer.writePunctuation("<")
	printer.emit(node.type_)
	printer.writePunctuation(">")
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeOperandOfPrefixUnary)
}

func (printer *Printer) emitParenthesizedExpression(node ParenthesizedExpression) {
	openParenPos := printer.emitTokenWithComment(ast.KindOpenParenToken, node.pos, printer.writePunctuation, node)
	indented := printer.writeLineSeparatorsAndIndentBefore(node.expression, node)
	printer.emitExpression(node.expression, nil /*parenthesizerRule*/)
	printer.writeLineSeparatorsAfter(node.expression, node)
	printer.decreaseIndentIf(indented)
	printer.emitTokenWithComment(ast.KindCloseParenToken, ifElse(node.expression, node.expression.end, openParenPos), printer.writePunctuation, node)
}

func (printer *Printer) emitFunctionExpression(node FunctionExpression) {
	printer.generateNameIfNeeded(node.name)
	printer.emitFunctionDeclarationOrExpression(node)
}

func (printer *Printer) emitArrowFunction(node ArrowFunction) {
	printer.emitModifierList(node, node.modifiers)
	printer.emitSignatureAndBody(node, printer.emitArrowFunctionHead, printer.emitArrowFunctionBody)
}

func (printer *Printer) emitArrowFunctionHead(node ArrowFunction) {
	printer.emitTypeParameters(node, node.typeParameters)
	printer.emitParametersForArrow(node, node.parameters)
	printer.emitTypeAnnotation(node.type_)
	printer.writeSpace()
	printer.emit(node.equalsGreaterThanToken)
}

func (printer *Printer) emitArrowFunctionBody(node ArrowFunction) {
	if isBlock(node.body) {
		printer.emitBlockFunctionBody(node.body)
	} else {
		printer.writeSpace()
		printer.emitExpression(node.body, printer.parenthesizer.parenthesizeConciseBodyOfArrowFunction)
	}
}

func (printer *Printer) emitDeleteExpression(node DeleteExpression) {
	printer.emitTokenWithComment(ast.KindDeleteKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeOperandOfPrefixUnary)
}

func (printer *Printer) emitTypeOfExpression(node TypeOfExpression) {
	printer.emitTokenWithComment(ast.KindTypeOfKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeOperandOfPrefixUnary)
}

func (printer *Printer) emitVoidExpression(node VoidExpression) {
	printer.emitTokenWithComment(ast.KindVoidKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeOperandOfPrefixUnary)
}

func (printer *Printer) emitAwaitExpression(node AwaitExpression) {
	printer.emitTokenWithComment(ast.KindAwaitKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeOperandOfPrefixUnary)
}

func (printer *Printer) emitPrefixUnaryExpression(node PrefixUnaryExpression) {
	printer.writeTokenText(node.operator, printer.writeOperator)
	if printer.shouldEmitWhitespaceBeforeOperand(node) {
		printer.writeSpace()
	}
	printer.emitExpression(node.operand, printer.parenthesizer.parenthesizeOperandOfPrefixUnary)
}

func (printer *Printer) shouldEmitWhitespaceBeforeOperand(node PrefixUnaryExpression) bool {
	// In some cases, we need to emit a space between the operator and the operand. One obvious case
	// is when the operator is an identifier, like delete or typeof. We also need to do this for plus
	// and minus expressions in certain cases. Specifically, consider the following two cases (parens
	// are just for clarity of exposition, and not part of the source code):
	//
	//  (+(+1))
	//  (+(++1))
	//
	// We need to emit a space in both cases. In the first case, the absence of a space will make
	// the resulting expression a prefix increment operation. And in the second, it will make the resulting
	// expression a prefix increment whose operand is a plus expression - (++(+x))
	// The same is true of minus of course.
	operand := node.operand
	return operand.kind == ast.KindPrefixUnaryExpression && ((node.operator == ast.KindPlusToken && ((operand.AsPrefixUnaryExpression()).operator == ast.KindPlusToken || (operand.AsPrefixUnaryExpression()).operator == ast.KindPlusPlusToken)) || (node.operator == ast.KindMinusToken && ((operand.AsPrefixUnaryExpression()).operator == ast.KindMinusToken || (operand.AsPrefixUnaryExpression()).operator == ast.KindMinusMinusToken)))
}

func (printer *Printer) emitPostfixUnaryExpression(node PostfixUnaryExpression) {
	printer.emitExpression(node.operand, printer.parenthesizer.parenthesizeOperandOfPostfixUnary)
	printer.writeTokenText(node.operator, printer.writeOperator)
}

func (printer *Printer) createEmitBinaryExpression() /* TODO(TS-TO-GO) inferred type (node: BinaryExpression) => void */ any {
	type WorkArea struct {
		stackIndex                       number
		preserveSourceNewlinesStack      []*bool
		containerPosStack                []number
		containerEndStack                []number
		declarationListContainerEndStack []number
		shouldEmitCommentsStack          []bool
		shouldEmitSourceMapsStack        []bool
	}

	return createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, nil /*foldState*/)

	onEnter := func(node BinaryExpression, state *WorkArea) WorkArea {
		if state != nil {
			state.stackIndex++
			state.preserveSourceNewlinesStack[state.stackIndex] = printer.preserveSourceNewlines
			state.containerPosStack[state.stackIndex] = printer.containerPos
			state.containerEndStack[state.stackIndex] = printer.containerEnd
			state.declarationListContainerEndStack[state.stackIndex] = printer.declarationListContainerEnd
			emitComments := /* TODO(TS-TO-GO) EqualsToken BinaryExpression: state.shouldEmitCommentsStack[state.stackIndex] = shouldEmitComments(node) */ TODO
			emitSourceMaps := /* TODO(TS-TO-GO) EqualsToken BinaryExpression: state.shouldEmitSourceMapsStack[state.stackIndex] = shouldEmitSourceMaps(node) */ TODO
			onBeforeEmitNode(node)
			if emitComments {
				printer.emitCommentsBeforeNode(node)
			}
			if emitSourceMaps {
				printer.emitSourceMapsBeforeNode(node)
			}
			printer.beforeEmitNode(node)
		} else {
			state = &WorkArea{
				stackIndex:                       0,
				preserveSourceNewlinesStack:      []undefined{nil},
				containerPosStack:                []number{-1},
				containerEndStack:                []number{-1},
				declarationListContainerEndStack: []number{-1},
				shouldEmitCommentsStack:          []false{false},
				shouldEmitSourceMapsStack:        []false{false},
			}
		}
		return state
	}

	onLeft := func(next Expression, _workArea WorkArea, parent BinaryExpression) * /* TODO(TS-TO-GO) inferred type ts.BinaryExpression */ any {
		return maybeEmitExpression(next, parent, "left")
	}

	onOperator := func(operatorToken BinaryOperatorToken, _state WorkArea, node BinaryExpression) {
		isCommaOperator := operatorToken.kind != ast.KindCommaToken
		linesBeforeOperator := printer.getLinesBetweenNodes(node, node.left, operatorToken)
		linesAfterOperator := printer.getLinesBetweenNodes(node, operatorToken, node.right)
		printer.writeLinesAndIndent(linesBeforeOperator, isCommaOperator)
		printer.emitLeadingCommentsOfPosition(operatorToken.pos)
		printer.writeTokenNode(operatorToken, ifElse(operatorToken.kind == ast.KindInKeyword, printer.writeKeyword, printer.writeOperator))
		printer.emitTrailingCommentsOfPosition(operatorToken.end, true /*prefixSpace*/)
		// Binary operators should have a space before the comment starts
		printer.writeLinesAndIndent(linesAfterOperator, true /*writeSpaceIfNotIndenting*/)
	}

	onRight := func(next Expression, _workArea WorkArea, parent BinaryExpression) * /* TODO(TS-TO-GO) inferred type ts.BinaryExpression */ any {
		return maybeEmitExpression(next, parent, "right")
	}

	onExit := func(node BinaryExpression, state WorkArea) {
		linesBeforeOperator := printer.getLinesBetweenNodes(node, node.left, node.operatorToken)
		linesAfterOperator := printer.getLinesBetweenNodes(node, node.operatorToken, node.right)
		printer.decreaseIndentIf(linesBeforeOperator, linesAfterOperator)
		if state.stackIndex > 0 {
			savedPreserveSourceNewlines := state.preserveSourceNewlinesStack[state.stackIndex]
			savedContainerPos := state.containerPosStack[state.stackIndex]
			savedContainerEnd := state.containerEndStack[state.stackIndex]
			savedDeclarationListContainerEnd := state.declarationListContainerEndStack[state.stackIndex]
			shouldEmitComments := state.shouldEmitCommentsStack[state.stackIndex]
			shouldEmitSourceMaps := state.shouldEmitSourceMapsStack[state.stackIndex]
			printer.afterEmitNode(savedPreserveSourceNewlines)
			if shouldEmitSourceMaps {
				printer.emitSourceMapsAfterNode(node)
			}
			if shouldEmitComments {
				printer.emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
			}
			onAfterEmitNode(node)
			state.stackIndex--
		}
	}

	maybeEmitExpression := func(next Expression, parent BinaryExpression, side Union[ /* TODO(TS-TO-GO) TypeNode LiteralType: "left" */ any /* TODO(TS-TO-GO) TypeNode LiteralType: "right" */, any]) * /* TODO(TS-TO-GO) inferred type ts.BinaryExpression */ any {
		var parenthesizerRule /* TODO(TS-TO-GO) inferred type (leftSide: Expression) => Expression */ any
		if side == "left" {
			parenthesizerRule = printer.parenthesizer.getParenthesizeLeftSideOfBinaryForOperator(parent.operatorToken.kind)
		} else {
			parenthesizerRule = printer.parenthesizer.getParenthesizeRightSideOfBinaryForOperator(parent.operatorToken.kind)
		}

		pipelinePhase := printer.getPipelinePhase(PipelinePhaseNotification, EmitHintExpression, next)
		if pipelinePhase == printer.pipelineEmitWithSubstitution {
			Debug.assertIsDefined(printer.lastSubstitution)
			next = parenthesizerRule(cast(printer.lastSubstitution, isExpression))
			pipelinePhase = printer.getNextPipelinePhase(PipelinePhaseSubstitution, EmitHintExpression, next)
			printer.lastSubstitution = nil
		}

		if pipelinePhase == printer.pipelineEmitWithComments || pipelinePhase == printer.pipelineEmitWithSourceMaps || pipelinePhase == printer.pipelineEmitWithHint {
			if isBinaryExpression(next) {
				return next
			}
		}

		printer.currentParenthesizerRule = parenthesizerRule
		pipelinePhase(EmitHintExpression, next)
	}

}

func (printer *Printer) emitConditionalExpression(node ConditionalExpression) {
	linesBeforeQuestion := printer.getLinesBetweenNodes(node, node.condition, node.questionToken)
	linesAfterQuestion := printer.getLinesBetweenNodes(node, node.questionToken, node.whenTrue)
	linesBeforeColon := printer.getLinesBetweenNodes(node, node.whenTrue, node.colonToken)
	linesAfterColon := printer.getLinesBetweenNodes(node, node.colonToken, node.whenFalse)

	printer.emitExpression(node.condition, printer.parenthesizer.parenthesizeConditionOfConditionalExpression)
	printer.writeLinesAndIndent(linesBeforeQuestion, true /*writeSpaceIfNotIndenting*/)
	printer.emit(node.questionToken)
	printer.writeLinesAndIndent(linesAfterQuestion, true /*writeSpaceIfNotIndenting*/)
	printer.emitExpression(node.whenTrue, printer.parenthesizer.parenthesizeBranchOfConditionalExpression)
	printer.decreaseIndentIf(linesBeforeQuestion, linesAfterQuestion)

	printer.writeLinesAndIndent(linesBeforeColon, true /*writeSpaceIfNotIndenting*/)
	printer.emit(node.colonToken)
	printer.writeLinesAndIndent(linesAfterColon, true /*writeSpaceIfNotIndenting*/)
	printer.emitExpression(node.whenFalse, printer.parenthesizer.parenthesizeBranchOfConditionalExpression)
	printer.decreaseIndentIf(linesBeforeColon, linesAfterColon)
}

func (printer *Printer) emitTemplateExpression(node TemplateExpression) {
	printer.emit(node.head)
	printer.emitList(node, node.templateSpans, ListFormatTemplateExpressionSpans)
}

func (printer *Printer) emitYieldExpression(node YieldExpression) {
	printer.emitTokenWithComment(ast.KindYieldKeyword, node.pos, printer.writeKeyword, node)
	printer.emit(node.asteriskToken)
	printer.emitExpressionWithLeadingSpace(node.expression && printer.parenthesizeExpressionForNoAsi(node.expression), printer.parenthesizeExpressionForNoAsiAndDisallowedComma)
}

func (printer *Printer) emitSpreadElement(node SpreadElement) {
	printer.emitTokenWithComment(ast.KindDotDotDotToken, node.pos, printer.writePunctuation, node)
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

func (printer *Printer) emitClassExpression(node ClassExpression) {
	printer.generateNameIfNeeded(node.name)
	printer.emitClassDeclarationOrExpression(node)
}

func (printer *Printer) emitExpressionWithTypeArguments(node ExpressionWithTypeArguments) {
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeLeftSideOfAccess)
	printer.emitTypeArguments(node, node.typeArguments)
}

func (printer *Printer) emitAsExpression(node AsExpression) {
	printer.emitExpression(node.expression, nil /*parenthesizerRule*/)
	if node.type_ {
		printer.writeSpace()
		printer.writeKeyword("as")
		printer.writeSpace()
		printer.emit(node.type_)
	}
}

func (printer *Printer) emitNonNullExpression(node NonNullExpression) {
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeLeftSideOfAccess)
	printer.writeOperator("!")
}

func (printer *Printer) emitSatisfiesExpression(node SatisfiesExpression) {
	printer.emitExpression(node.expression, nil /*parenthesizerRule*/)
	if node.type_ {
		printer.writeSpace()
		printer.writeKeyword("satisfies")
		printer.writeSpace()
		printer.emit(node.type_)
	}
}

func (printer *Printer) emitMetaProperty(node MetaProperty) {
	printer.writeToken(node.keywordToken, node.pos, printer.writePunctuation)
	printer.writePunctuation(".")
	printer.emit(node.name)
}

//
// Misc
//

func (printer *Printer) emitTemplateSpan(node TemplateSpan) {
	printer.emitExpression(node.expression)
	printer.emit(node.literal)
}

//
// Statements
//

func (printer *Printer) emitBlock(node Block) {
	printer.emitBlockStatements(node, !node.multiLine && printer.isEmptyBlock(node) /*forceSingleLine*/)
}

func (printer *Printer) emitBlockStatements(node BlockLike, forceSingleLine bool) {
	printer.emitTokenWithComment(ast.KindOpenBraceToken, node.pos, printer.writePunctuation, node /*contextNode*/)
	var format /* TODO(TS-TO-GO) inferred type ts.ListFormat.SingleLineTypeLiteralMembers | ts.ListFormat.MultiLineBlockStatements */ any
	if forceSingleLine || getEmitFlags(node)&EmitFlagsSingleLine != 0 {
		format = ListFormatSingleLineBlockStatements
	} else {
		format = ListFormatMultiLineBlockStatements
	}
	printer.emitList(node, node.statements, format)
	printer.emitTokenWithComment(ast.KindCloseBraceToken, node.statements.end, printer.writePunctuation, node /*contextNode*/, format&ListFormatMultiLine != 0 /*indentLeading*/)
}

func (printer *Printer) emitVariableStatement(node VariableStatement) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.emit(node.declarationList)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitEmptyStatement(isEmbeddedStatement bool) {
	// While most trailing semicolons are possibly insignificant, an embedded "empty"
	// statement is significant and cannot be elided by a trailing-semicolon-omitting writer.
	if isEmbeddedStatement {
		printer.writePunctuation(";")
	} else {
		printer.writeTrailingSemicolon()
	}
}

func (printer *Printer) emitExpressionStatement(node ExpressionStatement) {
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeExpressionOfExpressionStatement)
	// Emit semicolon in non json files
	// or if json file that created synthesized expression(eg.define expression statement when --out and amd code generation)
	if printer.currentSourceFile == nil || !isJsonSourceFile(printer.currentSourceFile) || nodeIsSynthesized(node.expression) {
		printer.writeTrailingSemicolon()
	}
}

func (printer *Printer) emitIfStatement(node IfStatement) {
	openParenPos := printer.emitTokenWithComment(ast.KindIfKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node)
	printer.emitExpression(node.expression)
	printer.emitTokenWithComment(ast.KindCloseParenToken, node.expression.end, printer.writePunctuation, node)
	printer.emitEmbeddedStatement(node, node.thenStatement)
	if node.elseStatement != nil {
		printer.writeLineOrSpace(node, node.thenStatement, node.elseStatement)
		printer.emitTokenWithComment(ast.KindElseKeyword, node.thenStatement.end, printer.writeKeyword, node)
		if node.elseStatement.kind == ast.KindIfStatement {
			printer.writeSpace()
			printer.emit(node.elseStatement)
		} else {
			printer.emitEmbeddedStatement(node, node.elseStatement)
		}
	}
}

func (printer *Printer) emitWhileClause(node Union[WhileStatement, DoStatement], startPos number) {
	openParenPos := printer.emitTokenWithComment(ast.KindWhileKeyword, startPos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node)
	printer.emitExpression(node.expression)
	printer.emitTokenWithComment(ast.KindCloseParenToken, node.expression.end, printer.writePunctuation, node)
}

func (printer *Printer) emitDoStatement(node DoStatement) {
	printer.emitTokenWithComment(ast.KindDoKeyword, node.pos, printer.writeKeyword, node)
	printer.emitEmbeddedStatement(node, node.statement)
	if isBlock(node.statement) && !printer.preserveSourceNewlines {
		printer.writeSpace()
	} else {
		printer.writeLineOrSpace(node, node.statement, node.expression)
	}

	printer.emitWhileClause(node, node.statement.end)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitWhileStatement(node WhileStatement) {
	printer.emitWhileClause(node, node.pos)
	printer.emitEmbeddedStatement(node, node.statement)
}

func (printer *Printer) emitForStatement(node ForStatement) {
	openParenPos := printer.emitTokenWithComment(ast.KindForKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	pos := printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node /*contextNode*/)
	printer.emitForBinding(node.initializer)
	pos = printer.emitTokenWithComment(ast.KindSemicolonToken, ifElse(node.initializer != nil, node.initializer.end, pos), printer.writePunctuation, node)
	printer.emitExpressionWithLeadingSpace(node.condition)
	pos = printer.emitTokenWithComment(ast.KindSemicolonToken, ifElse(node.condition != nil, node.condition.end, pos), printer.writePunctuation, node)
	printer.emitExpressionWithLeadingSpace(node.incrementor)
	printer.emitTokenWithComment(ast.KindCloseParenToken, ifElse(node.incrementor != nil, node.incrementor.end, pos), printer.writePunctuation, node)
	printer.emitEmbeddedStatement(node, node.statement)
}

func (printer *Printer) emitForInStatement(node ForInStatement) {
	openParenPos := printer.emitTokenWithComment(ast.KindForKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node)
	printer.emitForBinding(node.initializer)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindInKeyword, node.initializer.end, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression)
	printer.emitTokenWithComment(ast.KindCloseParenToken, node.expression.end, printer.writePunctuation, node)
	printer.emitEmbeddedStatement(node, node.statement)
}

func (printer *Printer) emitForOfStatement(node ForOfStatement) {
	openParenPos := printer.emitTokenWithComment(ast.KindForKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitWithTrailingSpace(node.awaitModifier)
	printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node)
	printer.emitForBinding(node.initializer)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindOfKeyword, node.initializer.end, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression)
	printer.emitTokenWithComment(ast.KindCloseParenToken, node.expression.end, printer.writePunctuation, node)
	printer.emitEmbeddedStatement(node, node.statement)
}

func (printer *Printer) emitForBinding(node Union[VariableDeclarationList, Expression, undefined]) {
	if node != nil {
		if node.kind == ast.KindVariableDeclarationList {
			printer.emit(node)
		} else {
			printer.emitExpression(node)
		}
	}
}

func (printer *Printer) emitContinueStatement(node ContinueStatement) {
	printer.emitTokenWithComment(ast.KindContinueKeyword, node.pos, printer.writeKeyword, node)
	printer.emitWithLeadingSpace(node.label)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitBreakStatement(node BreakStatement) {
	printer.emitTokenWithComment(ast.KindBreakKeyword, node.pos, printer.writeKeyword, node)
	printer.emitWithLeadingSpace(node.label)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitTokenWithComment(token SyntaxKind, pos number, writer func(s string), contextNode *Node, indentLeading bool) number {
	node := getParseTreeNode(contextNode)
	isSimilarNode := node && node.kind == contextNode.kind
	startPos := pos
	if isSimilarNode && printer.currentSourceFile != nil {
		pos = skipTrivia(printer.currentSourceFile.text, pos)
	}
	if isSimilarNode && contextNode.pos != startPos {
		needsIndent := indentLeading && printer.currentSourceFile && !positionsAreOnSameLine(startPos, pos, printer.currentSourceFile)
		if needsIndent {
			printer.increaseIndent()
		}
		printer.emitLeadingCommentsOfPosition(startPos)
		if needsIndent {
			printer.decreaseIndent()
		}
	}

	// We don't emit source positions for most tokens as it tends to be quite noisy, however
	// we need to emit source positions for open and close braces so that tools like istanbul
	// can map branches for code coverage. However, we still omit brace source positions when
	// the output is a declaration file.
	if !printer.omitBraceSourcePositions && (token == ast.KindOpenBraceToken || token == ast.KindCloseBraceToken) {
		pos = printer.writeToken(token, pos, printer.writer, contextNode)
	} else {
		pos = printer.writeTokenText(token, printer.writer, pos)
	}

	if isSimilarNode && contextNode.end != pos {
		isJsxExprContext := contextNode.kind == ast.KindJsxExpression
		printer.emitTrailingCommentsOfPosition(pos, !isJsxExprContext /*prefixSpace*/, isJsxExprContext /*forceNoNewline*/)
	}
	return pos
}

func (printer *Printer) commentWillEmitNewLine(node CommentRange) bool {
	return node.kind == ast.KindSingleLineCommentTrivia || node.hasTrailingNewLine
}

func (printer *Printer) willEmitLeadingNewLine(node Expression) bool {
	if printer.currentSourceFile == nil {
		return false
	}
	leadingCommentRanges := getLeadingCommentRanges(printer.currentSourceFile.text, node.pos)
	if leadingCommentRanges != nil {
		parseNode := getParseTreeNode(node)
		if parseNode != nil && isParenthesizedExpression(parseNode.parent) {
			return true
		}
	}
	if some(leadingCommentRanges, printer.commentWillEmitNewLine) {
		return true
	}
	if some(getSyntheticLeadingComments(node), printer.commentWillEmitNewLine) {
		return true
	}
	if isPartiallyEmittedExpression(node) {
		if node.pos != node.expression.pos {
			if some(getTrailingCommentRanges(printer.currentSourceFile.text, node.expression.pos), printer.commentWillEmitNewLine) {
				return true
			}
		}
		return printer.willEmitLeadingNewLine(node.expression)
	}
	return false
}

/**
 * Wraps an expression in parens if we would emit a leading comment that would introduce a line separator
 * between the node and its parent.
 */

func (printer *Printer) parenthesizeExpressionForNoAsi(node Expression) /* TODO(TS-TO-GO) inferred type ts.Expression */ any {
	if !printer.commentsDisabled && isPartiallyEmittedExpression(node) && printer.willEmitLeadingNewLine(node) {
		parseNode := getParseTreeNode(node)
		if parseNode != nil && isParenthesizedExpression(parseNode) {
			// If the original node was a parenthesized expression, restore it to preserve comment and source map emit
			parens := factory.createParenthesizedExpression(node.expression)
			setOriginalNode(parens, node)
			setTextRange(parens, parseNode)
			return parens
		}
		return factory.createParenthesizedExpression(node)
	}
	return node
}

func (printer *Printer) parenthesizeExpressionForNoAsiAndDisallowedComma(node Expression) /* TODO(TS-TO-GO) inferred type ts.Expression */ any {
	return printer.parenthesizeExpressionForNoAsi(printer.parenthesizer.parenthesizeExpressionForDisallowedComma(node))
}

func (printer *Printer) emitReturnStatement(node ReturnStatement) {
	printer.emitTokenWithComment(ast.KindReturnKeyword, node.pos, printer.writeKeyword, node /*contextNode*/)
	printer.emitExpressionWithLeadingSpace(node.expression && printer.parenthesizeExpressionForNoAsi(node.expression), printer.parenthesizeExpressionForNoAsi)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitWithStatement(node WithStatement) {
	openParenPos := printer.emitTokenWithComment(ast.KindWithKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node)
	printer.emitExpression(node.expression)
	printer.emitTokenWithComment(ast.KindCloseParenToken, node.expression.end, printer.writePunctuation, node)
	printer.emitEmbeddedStatement(node, node.statement)
}

func (printer *Printer) emitSwitchStatement(node SwitchStatement) {
	openParenPos := printer.emitTokenWithComment(ast.KindSwitchKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node)
	printer.emitExpression(node.expression)
	printer.emitTokenWithComment(ast.KindCloseParenToken, node.expression.end, printer.writePunctuation, node)
	printer.writeSpace()
	printer.emit(node.caseBlock)
}

func (printer *Printer) emitLabeledStatement(node LabeledStatement) {
	printer.emit(node.label)
	printer.emitTokenWithComment(ast.KindColonToken, node.label.end, printer.writePunctuation, node)
	printer.writeSpace()
	printer.emit(node.statement)
}

func (printer *Printer) emitThrowStatement(node ThrowStatement) {
	printer.emitTokenWithComment(ast.KindThrowKeyword, node.pos, printer.writeKeyword, node)
	printer.emitExpressionWithLeadingSpace(printer.parenthesizeExpressionForNoAsi(node.expression), printer.parenthesizeExpressionForNoAsi)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitTryStatement(node TryStatement) {
	printer.emitTokenWithComment(ast.KindTryKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emit(node.tryBlock)
	if node.catchClause != nil {
		printer.writeLineOrSpace(node, node.tryBlock, node.catchClause)
		printer.emit(node.catchClause)
	}
	if node.finallyBlock != nil {
		printer.writeLineOrSpace(node, node.catchClause || node.tryBlock, node.finallyBlock)
		printer.emitTokenWithComment(ast.KindFinallyKeyword, (node.catchClause || node.tryBlock).end, printer.writeKeyword, node)
		printer.writeSpace()
		printer.emit(node.finallyBlock)
	}
}

func (printer *Printer) emitDebuggerStatement(node DebuggerStatement) {
	printer.writeToken(ast.KindDebuggerKeyword, node.pos, printer.writeKeyword)
	printer.writeTrailingSemicolon()
}

//
// Declarations
//

func (printer *Printer) emitVariableDeclaration(node VariableDeclaration) {
	printer.emit(node.name)
	printer.emit(node.exclamationToken)
	printer.emitTypeAnnotation(node.type_)
	printer.emitInitializer(node.initializer, ifNotNilElse(ifNotNilElse(node.type_. /* ? */ end, node.name.emitNode. /* ? */ typeNode. /* ? */ end), node.name.end), node, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

func (printer *Printer) emitVariableDeclarationList(node VariableDeclarationList) {
	if isVarAwaitUsing(node) {
		printer.writeKeyword("await")
		printer.writeSpace()
		printer.writeKeyword("using")
	} else {
		var head /* TODO(TS-TO-GO) inferred type "using" | "const" | "let" | "var" */ any
		switch {
		case isLet(node):
			head = "let"
		case isVarConst(node):
			head = "const"
		case isVarUsing(node):
			head = "using"
		default:
			head = "var"
		}
		printer.writeKeyword(head)
	}
	printer.writeSpace()
	printer.emitList(node, node.declarations, ListFormatVariableDeclarationList)
}

func (printer *Printer) emitFunctionDeclaration(node FunctionDeclaration) {
	printer.emitFunctionDeclarationOrExpression(node)
}

func (printer *Printer) emitFunctionDeclarationOrExpression(node Union[FunctionDeclaration, FunctionExpression]) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.writeKeyword("function")
	printer.emit(node.asteriskToken)
	printer.writeSpace()
	printer.emitIdentifierName(node.name)
	printer.emitSignatureAndBody(node, printer.emitSignatureHead, printer.emitFunctionBody)
}

func (printer *Printer) emitSignatureAndBody(node T, emitSignatureHead func(node T), emitBody func(node T)) {
	indentedFlag := getEmitFlags(node) & EmitFlagsIndented
	if indentedFlag != 0 {
		printer.increaseIndent()
	}

	printer.pushNameGenerationScope(node)
	forEach(node.parameters, printer.generateNames)
	printer.emitSignatureHead(node)
	emitBody(node)
	printer.popNameGenerationScope(node)

	if indentedFlag != 0 {
		printer.decreaseIndent()
	}
}

func (printer *Printer) emitFunctionBody(node T) {
	body := node.body
	if body != nil {
		printer.emitBlockFunctionBody(body)
	} else {
		printer.writeTrailingSemicolon()
	}
}

func (printer *Printer) emitEmptyFunctionBody(_node SignatureDeclaration) {
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitSignatureHead(node SignatureDeclaration) {
	printer.emitTypeParameters(node, node.typeParameters)
	printer.emitParameters(node, node.parameters)
	printer.emitTypeAnnotation(node.type_)
}

func (printer *Printer) shouldEmitBlockFunctionBodyOnSingleLine(body Block) bool {
	// We must emit a function body as a single-line body in the following case:
	// * The body has NodeEmitFlags.SingleLine specified.

	// We must emit a function body as a multi-line body in the following cases:
	// * The body is explicitly marked as multi-line.
	// * A non-synthesized body's start and end position are on different lines.
	// * Any statement in the body starts on a new line.

	if getEmitFlags(body)&EmitFlagsSingleLine != 0 {
		return true
	}

	if body.multiLine {
		return false
	}

	if !nodeIsSynthesized(body) && printer.currentSourceFile != nil && !rangeIsOnSingleLine(body, printer.currentSourceFile) {
		return false
	}

	if printer.getLeadingLineTerminatorCount(body, firstOrUndefined(body.statements), ListFormatPreserveLines) != 0 || printer.getClosingLineTerminatorCount(body, lastOrUndefined(body.statements), ListFormatPreserveLines, body.statements) != 0 {
		return false
	}

	var previousStatement Statement
	for _, statement := range body.statements {
		if printer.getSeparatingLineTerminatorCount(previousStatement, statement, ListFormatPreserveLines) > 0 {
			return false
		}

		previousStatement = statement
	}

	return true
}

func (printer *Printer) emitBlockFunctionBody(body Block) {
	printer.generateNames(body)
	onBeforeEmitNode(body)
	printer.writeSpace()
	printer.writePunctuation("{")
	printer.increaseIndent()

	var emitBlockFunctionBody /* TODO(TS-TO-GO) inferred type (body: Block, emitBlockFunctionBodyOnSingleLine?: boolean) => void */ any
	if printer.shouldEmitBlockFunctionBodyOnSingleLine(body) {
		emitBlockFunctionBody = printer.emitBlockFunctionBodyOnSingleLine
	} else {
		emitBlockFunctionBody = printer.emitBlockFunctionBodyWorker
	}

	printer.emitBodyWithDetachedComments(body, body.statements, emitBlockFunctionBody)

	printer.decreaseIndent()
	printer.writeToken(ast.KindCloseBraceToken, body.statements.end, printer.writePunctuation, body)
	onAfterEmitNode(body)
}

func (printer *Printer) emitBlockFunctionBodyOnSingleLine(body Block) {
	printer.emitBlockFunctionBodyWorker(body, true /*emitBlockFunctionBodyOnSingleLine*/)
}

func (printer *Printer) emitBlockFunctionBodyWorker(body Block, emitBlockFunctionBodyOnSingleLine bool) {
	// Emit all the prologue directives (like "use strict").
	statementOffset := printer.emitPrologueDirectives(body.statements)
	pos := printer.writer.getTextPos()
	printer.emitHelpers(body)
	if statementOffset == 0 && pos == printer.writer.getTextPos() && printer.emitBlockFunctionBodyOnSingleLine {
		printer.decreaseIndent()
		printer.emitList(body, body.statements, ListFormatSingleLineFunctionBodyStatements)
		printer.increaseIndent()
	} else {
		printer.emitList(body, body.statements, ListFormatMultiLineFunctionBodyStatements, nil /*parenthesizerRule*/, statementOffset)
	}
}

func (printer *Printer) emitClassDeclaration(node ClassDeclaration) {
	printer.emitClassDeclarationOrExpression(node)
}

func (printer *Printer) emitClassDeclarationOrExpression(node Union[ClassDeclaration, ClassExpression]) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, true /*allowDecorators*/)
	printer.emitTokenWithComment(ast.KindClassKeyword, moveRangePastModifiers(node).pos, printer.writeKeyword, node)
	if node.name != nil {
		printer.writeSpace()
		printer.emitIdentifierName(node.name)
	}

	indentedFlag := getEmitFlags(node) & EmitFlagsIndented
	if indentedFlag != 0 {
		printer.increaseIndent()
	}

	printer.emitTypeParameters(node, node.typeParameters)
	printer.emitList(node, node.heritageClauses, ListFormatClassHeritageClauses)
	printer.writeSpace()
	printer.writePunctuation("{")

	printer.pushNameGenerationScope(node)
	forEach(node.members, printer.generateMemberNames)
	printer.emitList(node, node.members, ListFormatClassMembers)
	printer.popNameGenerationScope(node)

	printer.writePunctuation("}")

	if indentedFlag != 0 {
		printer.decreaseIndent()
	}
}

func (printer *Printer) emitInterfaceDeclaration(node InterfaceDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.writeKeyword("interface")
	printer.writeSpace()
	printer.emit(node.name)
	printer.emitTypeParameters(node, node.typeParameters)
	printer.emitList(node, node.heritageClauses, ListFormatHeritageClauses)
	printer.writeSpace()
	printer.writePunctuation("{")

	printer.pushNameGenerationScope(node)
	forEach(node.members, printer.generateMemberNames)
	printer.emitList(node, node.members, ListFormatInterfaceMembers)
	printer.popNameGenerationScope(node)

	printer.writePunctuation("}")
}

func (printer *Printer) emitTypeAliasDeclaration(node TypeAliasDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.writeKeyword("type")
	printer.writeSpace()
	printer.emit(node.name)
	printer.emitTypeParameters(node, node.typeParameters)
	printer.writeSpace()
	printer.writePunctuation("=")
	printer.writeSpace()
	printer.emit(node.type_)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitEnumDeclaration(node EnumDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.writeKeyword("enum")
	printer.writeSpace()
	printer.emit(node.name)

	printer.writeSpace()
	printer.writePunctuation("{")
	printer.emitList(node, node.members, ListFormatEnumMembers)
	printer.writePunctuation("}")
}

func (printer *Printer) emitModuleDeclaration(node ModuleDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	if ^node.flags&ast.NodeFlagsGlobalAugmentation != 0 {
		printer.writeKeyword(ifElse(node.flags&ast.NodeFlagsNamespace != 0, "namespace", "module"))
		printer.writeSpace()
	}
	printer.emit(node.name)

	body := node.body
	if body == nil {
		return printer.writeTrailingSemicolon()
	}
	for body != nil && isModuleDeclaration(body) {
		printer.writePunctuation(".")
		printer.emit(body.name)
		body = body.body
	}

	printer.writeSpace()
	printer.emit(body)
}

func (printer *Printer) emitModuleBlock(node ModuleBlock) {
	printer.pushNameGenerationScope(node)
	forEach(node.statements, printer.generateNames)
	printer.emitBlockStatements(node, printer.isEmptyBlock(node) /*forceSingleLine*/)
	printer.popNameGenerationScope(node)
}

func (printer *Printer) emitCaseBlock(node CaseBlock) {
	printer.emitTokenWithComment(ast.KindOpenBraceToken, node.pos, printer.writePunctuation, node)
	printer.emitList(node, node.clauses, ListFormatCaseBlockClauses)
	printer.emitTokenWithComment(ast.KindCloseBraceToken, node.clauses.end, printer.writePunctuation, node, true /*indentLeading*/)
}

func (printer *Printer) emitImportEqualsDeclaration(node ImportEqualsDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.emitTokenWithComment(ast.KindImportKeyword, ifElse(node.modifiers != nil, node.modifiers.end, node.pos), printer.writeKeyword, node)
	printer.writeSpace()
	if node.isTypeOnly {
		printer.emitTokenWithComment(ast.KindTypeKeyword, node.pos, printer.writeKeyword, node)
		printer.writeSpace()
	}
	printer.emit(node.name)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindEqualsToken, node.name.end, printer.writePunctuation, node)
	printer.writeSpace()
	printer.emitModuleReference(node.moduleReference)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitModuleReference(node ModuleReference) {
	if node.kind == ast.KindIdentifier {
		printer.emitExpression(node)
	} else {
		printer.emit(node)
	}
}

func (printer *Printer) emitImportDeclaration(node ImportDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	printer.emitTokenWithComment(ast.KindImportKeyword, ifElse(node.modifiers != nil, node.modifiers.end, node.pos), printer.writeKeyword, node)
	printer.writeSpace()
	if node.importClause != nil {
		printer.emit(node.importClause)
		printer.writeSpace()
		printer.emitTokenWithComment(ast.KindFromKeyword, node.importClause.end, printer.writeKeyword, node)
		printer.writeSpace()
	}
	printer.emitExpression(node.moduleSpecifier)
	if node.attributes != nil {
		printer.emitWithLeadingSpace(node.attributes)
	}
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitImportClause(node ImportClause) {
	if node.isTypeOnly {
		printer.emitTokenWithComment(ast.KindTypeKeyword, node.pos, printer.writeKeyword, node)
		printer.writeSpace()
	}
	printer.emit(node.name)
	if node.name != nil && node.namedBindings != nil {
		printer.emitTokenWithComment(ast.KindCommaToken, node.name.end, printer.writePunctuation, node)
		printer.writeSpace()
	}
	printer.emit(node.namedBindings)
}

func (printer *Printer) emitNamespaceImport(node NamespaceImport) {
	asPos := printer.emitTokenWithComment(ast.KindAsteriskToken, node.pos, printer.writePunctuation, node)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindAsKeyword, asPos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emit(node.name)
}

func (printer *Printer) emitNamedImports(node NamedImports) {
	printer.emitNamedImportsOrExports(node)
}

func (printer *Printer) emitImportSpecifier(node ImportSpecifier) {
	printer.emitImportOrExportSpecifier(node)
}

func (printer *Printer) emitExportAssignment(node ExportAssignment) {
	nextPos := printer.emitTokenWithComment(ast.KindExportKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	if node.isExportEquals {
		printer.emitTokenWithComment(ast.KindEqualsToken, nextPos, printer.writeOperator, node)
	} else {
		printer.emitTokenWithComment(ast.KindDefaultKeyword, nextPos, printer.writeKeyword, node)
	}
	printer.writeSpace()
	printer.emitExpression(node.expression, ifElse(node.isExportEquals, printer.parenthesizer.getParenthesizeRightSideOfBinaryForOperator(ast.KindEqualsToken), printer.parenthesizer.parenthesizeExpressionOfExportDefault))
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitExportDeclaration(node ExportDeclaration) {
	printer.emitDecoratorsAndModifiers(node, node.modifiers, false /*allowDecorators*/)
	nextPos := printer.emitTokenWithComment(ast.KindExportKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	if node.isTypeOnly {
		nextPos = printer.emitTokenWithComment(ast.KindTypeKeyword, nextPos, printer.writeKeyword, node)
		printer.writeSpace()
	}
	if node.exportClause != nil {
		printer.emit(node.exportClause)
	} else {
		nextPos = printer.emitTokenWithComment(ast.KindAsteriskToken, nextPos, printer.writePunctuation, node)
	}
	if node.moduleSpecifier != nil {
		printer.writeSpace()
		var fromPos number
		if node.exportClause != nil {
			fromPos = node.exportClause.end
		} else {
			fromPos = nextPos
		}
		printer.emitTokenWithComment(ast.KindFromKeyword, fromPos, printer.writeKeyword, node)
		printer.writeSpace()
		printer.emitExpression(node.moduleSpecifier)
	}
	if node.attributes != nil {
		printer.emitWithLeadingSpace(node.attributes)
	}
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitImportTypeNodeAttributes(node ImportAttributes) {
	printer.writePunctuation("{")
	printer.writeSpace()
	printer.writeKeyword(ifElse(node.token == ast.KindAssertKeyword, "assert", "with"))
	printer.writePunctuation(":")
	printer.writeSpace()
	elements := node.elements
	printer.emitList(node, elements, ListFormatImportAttributes)
	printer.writeSpace()
	printer.writePunctuation("}")
}

func (printer *Printer) emitImportAttributes(node ImportAttributes) {
	printer.emitTokenWithComment(node.token, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	elements := node.elements
	printer.emitList(node, elements, ListFormatImportAttributes)
}

func (printer *Printer) emitImportAttribute(node ImportAttribute) {
	printer.emit(node.name)
	printer.writePunctuation(":")
	printer.writeSpace()

	value := node.value
	/** @see {emitPropertyAssignment} */

	if (getEmitFlags(value) & EmitFlagsNoLeadingComments) == 0 {
		commentRange := getCommentRange(value)
		printer.emitTrailingCommentsOfPosition(commentRange.pos)
	}
	printer.emit(value)
}

func (printer *Printer) emitNamespaceExportDeclaration(node NamespaceExportDeclaration) {
	nextPos := printer.emitTokenWithComment(ast.KindExportKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	nextPos = printer.emitTokenWithComment(ast.KindAsKeyword, nextPos, printer.writeKeyword, node)
	printer.writeSpace()
	// eslint-disable-next-line @typescript-eslint/no-unused-vars
	nextPos = printer.emitTokenWithComment(ast.KindNamespaceKeyword, nextPos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emit(node.name)
	printer.writeTrailingSemicolon()
}

func (printer *Printer) emitNamespaceExport(node NamespaceExport) {
	asPos := printer.emitTokenWithComment(ast.KindAsteriskToken, node.pos, printer.writePunctuation, node)
	printer.writeSpace()
	printer.emitTokenWithComment(ast.KindAsKeyword, asPos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emit(node.name)
}

func (printer *Printer) emitNamedExports(node NamedExports) {
	printer.emitNamedImportsOrExports(node)
}

func (printer *Printer) emitExportSpecifier(node ExportSpecifier) {
	printer.emitImportOrExportSpecifier(node)
}

func (printer *Printer) emitNamedImportsOrExports(node NamedImportsOrExports) {
	printer.writePunctuation("{")
	printer.emitList(node, node.elements, ListFormatNamedImportsOrExportsElements)
	printer.writePunctuation("}")
}

func (printer *Printer) emitImportOrExportSpecifier(node ImportOrExportSpecifier) {
	if node.isTypeOnly {
		printer.writeKeyword("type")
		printer.writeSpace()
	}
	if node.propertyName != nil {
		printer.emit(node.propertyName)
		printer.writeSpace()
		printer.emitTokenWithComment(ast.KindAsKeyword, node.propertyName.end, printer.writeKeyword, node)
		printer.writeSpace()
	}

	printer.emit(node.name)
}

//
// Module references
//

func (printer *Printer) emitExternalModuleReference(node ExternalModuleReference) {
	printer.writeKeyword("require")
	printer.writePunctuation("(")
	printer.emitExpression(node.expression)
	printer.writePunctuation(")")
}

//
// JSX
//

func (printer *Printer) emitJsxElement(node JsxElement) {
	printer.emit(node.openingElement)
	printer.emitList(node, node.children, ListFormatJsxElementOrFragmentChildren)
	printer.emit(node.closingElement)
}

func (printer *Printer) emitJsxSelfClosingElement(node JsxSelfClosingElement) {
	printer.writePunctuation("<")
	printer.emitJsxTagName(node.tagName)
	printer.emitTypeArguments(node, node.typeArguments)
	printer.writeSpace()
	printer.emit(node.attributes)
	printer.writePunctuation("/>")
}

func (printer *Printer) emitJsxFragment(node JsxFragment) {
	printer.emit(node.openingFragment)
	printer.emitList(node, node.children, ListFormatJsxElementOrFragmentChildren)
	printer.emit(node.closingFragment)
}

func (printer *Printer) emitJsxOpeningElementOrFragment(node Union[JsxOpeningElement, JsxOpeningFragment]) {
	printer.writePunctuation("<")

	if isJsxOpeningElement(node) {
		indented := printer.writeLineSeparatorsAndIndentBefore(node.tagName, node)
		printer.emitJsxTagName(node.tagName)
		printer.emitTypeArguments(node, node.typeArguments)
		if node.attributes.properties && node.attributes.properties.length > 0 {
			printer.writeSpace()
		}
		printer.emit(node.attributes)
		printer.writeLineSeparatorsAfter(node.attributes, node)
		printer.decreaseIndentIf(indented)
	}

	printer.writePunctuation(">")
}

func (printer *Printer) emitJsxText(node JsxText) {
	printer.writer.writeLiteral(node.text)
}

func (printer *Printer) emitJsxClosingElementOrFragment(node Union[JsxClosingElement, JsxClosingFragment]) {
	printer.writePunctuation("</")
	if isJsxClosingElement(node) {
		printer.emitJsxTagName(node.tagName)
	}
	printer.writePunctuation(">")
}

func (printer *Printer) emitJsxAttributes(node JsxAttributes) {
	printer.emitList(node, node.properties, ListFormatJsxElementAttributes)
}

func (printer *Printer) emitJsxAttribute(node JsxAttribute) {
	printer.emit(node.name)
	printer.emitNodeWithPrefix("=", printer.writePunctuation, node.initializer, printer.emitJsxAttributeValue)
}

func (printer *Printer) emitJsxSpreadAttribute(node JsxSpreadAttribute) {
	printer.writePunctuation("{...")
	printer.emitExpression(node.expression)
	printer.writePunctuation("}")
}

func (printer *Printer) hasTrailingCommentsAtPosition(pos number) bool {
	result := false
	forEachTrailingCommentRange(printer.currentSourceFile. /* ? */ text || "", pos+1, func() bool {
		return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = true */ TODO
	})
	return result
}

func (printer *Printer) hasLeadingCommentsAtPosition(pos number) bool {
	result := false
	forEachLeadingCommentRange(printer.currentSourceFile. /* ? */ text || "", pos+1, func() bool {
		return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = true */ TODO
	})
	return result
}

func (printer *Printer) hasCommentsAtPosition(pos number) bool {
	return printer.hasTrailingCommentsAtPosition(pos) || printer.hasLeadingCommentsAtPosition(pos)
}

func (printer *Printer) emitJsxExpression(node JsxExpression) {
	if node.expression != nil || (!printer.commentsDisabled && !nodeIsSynthesized(node) && printer.hasCommentsAtPosition(node.pos)) {
		isMultiline := printer.currentSourceFile && !nodeIsSynthesized(node) && getLineAndCharacterOfPosition(printer.currentSourceFile, node.pos).line != getLineAndCharacterOfPosition(printer.currentSourceFile, node.end).line
		if isMultiline {
			printer.writer.increaseIndent()
		}
		end := printer.emitTokenWithComment(ast.KindOpenBraceToken, node.pos, printer.writePunctuation, node)
		printer.emit(node.dotDotDotToken)
		printer.emitExpression(node.expression)
		printer.emitTokenWithComment(ast.KindCloseBraceToken, node.expression. /* ? */ end || end, printer.writePunctuation, node)
		if isMultiline {
			printer.writer.decreaseIndent()
		}
	}
}

func (printer *Printer) emitJsxNamespacedName(node JsxNamespacedName) {
	printer.emitIdentifierName(node.namespace)
	printer.writePunctuation(":")
	printer.emitIdentifierName(node.name)
}

func (printer *Printer) emitJsxTagName(node JsxTagNameExpression) {
	if node.kind == ast.KindIdentifier {
		printer.emitExpression(node)
	} else {
		printer.emit(node)
	}
}

//
// Clauses
//

func (printer *Printer) emitCaseClause(node CaseClause) {
	printer.emitTokenWithComment(ast.KindCaseKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)

	printer.emitCaseOrDefaultClauseRest(node, node.statements, node.expression.end)
}

func (printer *Printer) emitDefaultClause(node DefaultClause) {
	pos := printer.emitTokenWithComment(ast.KindDefaultKeyword, node.pos, printer.writeKeyword, node)
	printer.emitCaseOrDefaultClauseRest(node, node.statements, pos)
}

func (printer *Printer) emitCaseOrDefaultClauseRest(parentNode *Node, statements NodeArray[Statement], colonPos number) {
	emitAsSingleStatement := statements.length == 1 && (printer.currentSourceFile == nil || nodeIsSynthesized(parentNode) || nodeIsSynthesized(statements[0]) || rangeStartPositionsAreOnSameLine(parentNode, statements[0], printer.currentSourceFile))

	format := ListFormatCaseOrDefaultClauseStatements
	if emitAsSingleStatement {
		printer.writeToken(ast.KindColonToken, colonPos, printer.writePunctuation, parentNode)
		printer.writeSpace()
		format &^= (ListFormatMultiLine | ListFormatIndented)
	} else {
		printer.emitTokenWithComment(ast.KindColonToken, colonPos, printer.writePunctuation, parentNode)
	}
	printer.emitList(parentNode, statements, format)
}

func (printer *Printer) emitHeritageClause(node HeritageClause) {
	printer.writeSpace()
	printer.writeTokenText(node.token, printer.writeKeyword)
	printer.writeSpace()
	printer.emitList(node, node.types, ListFormatHeritageClauseTypes)
}

func (printer *Printer) emitCatchClause(node CatchClause) {
	openParenPos := printer.emitTokenWithComment(ast.KindCatchKeyword, node.pos, printer.writeKeyword, node)
	printer.writeSpace()
	if node.variableDeclaration != nil {
		printer.emitTokenWithComment(ast.KindOpenParenToken, openParenPos, printer.writePunctuation, node)
		printer.emit(node.variableDeclaration)
		printer.emitTokenWithComment(ast.KindCloseParenToken, node.variableDeclaration.end, printer.writePunctuation, node)
		printer.writeSpace()
	}
	printer.emit(node.block)
}

//
// Property assignments
//

func (printer *Printer) emitPropertyAssignment(node PropertyAssignment) {
	printer.emit(node.name)
	printer.writePunctuation(":")
	printer.writeSpace()
	// This is to ensure that we emit comment in the following case:
	//      For example:
	//          obj = {
	//              id: /*comment1*/ ()=>void
	//          }
	// "comment1" is not considered to be leading comment for node.initializer
	// but rather a trailing comment on the previous node.
	initializer := node.initializer
	if (getEmitFlags(initializer) & EmitFlagsNoLeadingComments) == 0 {
		commentRange := getCommentRange(initializer)
		printer.emitTrailingCommentsOfPosition(commentRange.pos)
	}
	printer.emitExpression(initializer, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

func (printer *Printer) emitShorthandPropertyAssignment(node ShorthandPropertyAssignment) {
	printer.emit(node.name)
	if node.objectAssignmentInitializer != nil {
		printer.writeSpace()
		printer.writePunctuation("=")
		printer.writeSpace()
		printer.emitExpression(node.objectAssignmentInitializer, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
	}
}

func (printer *Printer) emitSpreadAssignment(node SpreadAssignment) {
	if node.expression {
		printer.emitTokenWithComment(ast.KindDotDotDotToken, node.pos, printer.writePunctuation, node)
		printer.emitExpression(node.expression, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
	}
}

//
// Enum
//

func (printer *Printer) emitEnumMember(node EnumMember) {
	printer.emit(node.name)
	printer.emitInitializer(node.initializer, node.name.end, node, printer.parenthesizer.parenthesizeExpressionForDisallowedComma)
}

// JSDoc
func (printer *Printer) emitJSDoc(node JSDoc) {
	printer.write("/**")
	if node.comment {
		text := getTextOfJSDocComment(node.comment)
		if text {
			lines := text.split(regexp.MustParse(`\r\n?|\n`))
			for _, line := range lines {
				printer.writeLine()
				printer.writeSpace()
				printer.writePunctuation("*")
				printer.writeSpace()
				printer.write(line)
			}
		}
	}
	if node.tags != nil {
		if node.tags.length == 1 && node.tags[0].kind == ast.KindJSDocTypeTag && !node.comment {
			printer.writeSpace()
			printer.emit(node.tags[0])
		} else {
			printer.emitList(node, node.tags, ListFormatJSDocComment)
		}
	}
	printer.writeSpace()
	printer.write("*/")
}

func (printer *Printer) emitJSDocSimpleTypedTag(tag Union[JSDocTypeTag, JSDocThisTag, JSDocEnumTag, JSDocReturnTag, JSDocThrowsTag, JSDocSatisfiesTag]) {
	printer.emitJSDocTagName(tag.tagName)
	printer.emitJSDocTypeExpression(tag.typeExpression)
	printer.emitJSDocComment(tag.comment)
}

func (printer *Printer) emitJSDocSeeTag(tag JSDocSeeTag) {
	printer.emitJSDocTagName(tag.tagName)
	printer.emit(tag.name)
	printer.emitJSDocComment(tag.comment)
}

func (printer *Printer) emitJSDocImportTag(tag JSDocImportTag) {
	printer.emitJSDocTagName(tag.tagName)
	printer.writeSpace()

	if tag.importClause != nil {
		printer.emit(tag.importClause)
		printer.writeSpace()

		printer.emitTokenWithComment(ast.KindFromKeyword, tag.importClause.end, printer.writeKeyword, tag)
		printer.writeSpace()
	}

	printer.emitExpression(tag.moduleSpecifier)
	if tag.attributes != nil {
		printer.emitWithLeadingSpace(tag.attributes)
	}
	printer.emitJSDocComment(tag.comment)
}

func (printer *Printer) emitJSDocNameReference(node JSDocNameReference) {
	printer.writeSpace()
	printer.writePunctuation("{")
	printer.emit(node.name)
	printer.writePunctuation("}")
}

func (printer *Printer) emitJSDocHeritageTag(tag Union[JSDocImplementsTag, JSDocAugmentsTag]) {
	printer.emitJSDocTagName(tag.tagName)
	printer.writeSpace()
	printer.writePunctuation("{")
	printer.emit(tag.class)
	printer.writePunctuation("}")
	printer.emitJSDocComment(tag.comment)
}

func (printer *Printer) emitJSDocTemplateTag(tag JSDocTemplateTag) {
	printer.emitJSDocTagName(tag.tagName)
	printer.emitJSDocTypeExpression(tag.constraint)
	printer.writeSpace()
	printer.emitList(tag, tag.typeParameters, ListFormatCommaListElements)
	printer.emitJSDocComment(tag.comment)
}

func (printer *Printer) emitJSDocTypedefTag(tag JSDocTypedefTag) {
	printer.emitJSDocTagName(tag.tagName)
	if tag.typeExpression != nil {
		if tag.typeExpression.kind == ast.KindJSDocTypeExpression {
			printer.emitJSDocTypeExpression(tag.typeExpression)
		} else {
			printer.writeSpace()
			printer.writePunctuation("{")
			printer.write("Object")
			if tag.typeExpression.isArrayType {
				printer.writePunctuation("[")
				printer.writePunctuation("]")
			}
			printer.writePunctuation("}")
		}
	}
	if tag.fullName != nil {
		printer.writeSpace()
		printer.emit(tag.fullName)
	}
	printer.emitJSDocComment(tag.comment)
	if tag.typeExpression != nil && tag.typeExpression.kind == ast.KindJSDocTypeLiteral {
		printer.emitJSDocTypeLiteral(tag.typeExpression)
	}
}

func (printer *Printer) emitJSDocCallbackTag(tag JSDocCallbackTag) {
	printer.emitJSDocTagName(tag.tagName)
	if tag.name != nil {
		printer.writeSpace()
		printer.emit(tag.name)
	}
	printer.emitJSDocComment(tag.comment)
	printer.emitJSDocSignature(tag.typeExpression)
}

func (printer *Printer) emitJSDocOverloadTag(tag JSDocOverloadTag) {
	printer.emitJSDocComment(tag.comment)
	printer.emitJSDocSignature(tag.typeExpression)
}

func (printer *Printer) emitJSDocSimpleTag(tag JSDocTag) {
	printer.emitJSDocTagName(tag.tagName)
	printer.emitJSDocComment(tag.comment)
}

func (printer *Printer) emitJSDocTypeLiteral(lit JSDocTypeLiteral) {
	printer.emitList(lit, factory.createNodeArray(lit.jsDocPropertyTags), ListFormatJSDocComment)
}

func (printer *Printer) emitJSDocSignature(sig JSDocSignature) {
	if sig.typeParameters != nil {
		printer.emitList(sig, factory.createNodeArray(sig.typeParameters), ListFormatJSDocComment)
	}
	if sig.parameters {
		printer.emitList(sig, factory.createNodeArray(sig.parameters), ListFormatJSDocComment)
	}
	if sig.type_ != nil {
		printer.writeLine()
		printer.writeSpace()
		printer.writePunctuation("*")
		printer.writeSpace()
		printer.emit(sig.type_)
	}
}

func (printer *Printer) emitJSDocPropertyLikeTag(param JSDocPropertyLikeTag) {
	printer.emitJSDocTagName(param.tagName)
	printer.emitJSDocTypeExpression(param.typeExpression)
	printer.writeSpace()
	if param.isBracketed {
		printer.writePunctuation("[")
	}
	printer.emit(param.name)
	if param.isBracketed {
		printer.writePunctuation("]")
	}
	printer.emitJSDocComment(param.comment)
}

func (printer *Printer) emitJSDocTagName(tagName Identifier) {
	printer.writePunctuation("@")
	printer.emit(tagName)
}

func (printer *Printer) emitJSDocComment(comment Union[string, NodeArray[JSDocComment], undefined]) {
	text := getTextOfJSDocComment(comment)
	if text {
		printer.writeSpace()
		printer.write(text)
	}
}

func (printer *Printer) emitJSDocTypeExpression(typeExpression *JSDocTypeExpression) {
	if typeExpression != nil {
		printer.writeSpace()
		printer.writePunctuation("{")
		printer.emit(typeExpression.type_)
		printer.writePunctuation("}")
	}
}

//
// Top-level nodes
//

func (printer *Printer) emitSourceFile(node SourceFile) {
	printer.writeLine()
	statements := node.statements
	// Emit detached comment if there are no prologue directives or if the first node is synthesized.
	// The synthesized node will have no leading comment so some comments may be missed.
	shouldEmitDetachedComment := statements.length == 0 || !isPrologueDirective(statements[0]) || nodeIsSynthesized(statements[0])
	if shouldEmitDetachedComment {
		printer.emitBodyWithDetachedComments(node, statements, printer.emitSourceFileWorker)
		return
	}
	printer.emitSourceFileWorker(node)
}

func (printer *Printer) emitSyntheticTripleSlashReferencesIfNeeded(node Bundle) {
	printer.emitTripleSlashDirectives(node.hasNoDefaultLib, node.syntheticFileReferences || []never{}, node.syntheticTypeReferences || []never{}, node.syntheticLibReferences || []never{})
}

func (printer *Printer) emitTripleSlashDirectivesIfNeeded(node SourceFile) {
	if node.isDeclarationFile {
		printer.emitTripleSlashDirectives(node.hasNoDefaultLib, node.referencedFiles, node.typeReferenceDirectives, node.libReferenceDirectives)
	}
}

func (printer *Printer) emitTripleSlashDirectives(hasNoDefaultLib bool, files []FileReference, types []FileReference, libs []FileReference) {
	if hasNoDefaultLib {
		printer.writeComment(`/// <reference no-default-lib="true"/>`)
		printer.writeLine()
	}
	if printer.currentSourceFile != nil && printer.currentSourceFile.moduleName {
		printer.writeComment(__TEMPLATE__("/// <amd-module name=\"", printer.currentSourceFile.moduleName, "\" />"))
		printer.writeLine()
	}
	if printer.currentSourceFile != nil && printer.currentSourceFile.amdDependencies {
		for _, dep := range printer.currentSourceFile.amdDependencies {
			if dep.name {
				printer.writeComment(__TEMPLATE__("/// <amd-dependency name=\"", dep.name, "\" path=\"", dep.path, "\" />"))
			} else {
				printer.writeComment(__TEMPLATE__("/// <amd-dependency path=\"", dep.path, "\" />"))
			}
			printer.writeLine()
		}
	}

	writeDirectives := func(kind Union[ /* TODO(TS-TO-GO) TypeNode LiteralType: "path" */ any /* TODO(TS-TO-GO) TypeNode LiteralType: "types" */, any /* TODO(TS-TO-GO) TypeNode LiteralType: "lib" */, any], directives []FileReference) {
		for _, directive := range directives {
			var resolutionMode string
			if directive.resolutionMode {
				resolutionMode = __TEMPLATE__("resolution-mode=\"", ifElse(directive.resolutionMode == ModuleKindESNext, "import", "require"), "\" ")
			} else {
				resolutionMode = ""
			}
			var preserve /* TODO(TS-TO-GO) inferred type "" | "preserve=\"true\" " */ any
			if directive.preserve {
				preserve = `preserve="true" `
			} else {
				preserve = ""
			}
			printer.writeComment(__TEMPLATE__("/// <reference ", kind, "=\"", directive.fileName, "\" ", resolutionMode, preserve, "/>"))
			printer.writeLine()
		}
	}

	writeDirectives("path", files)
	writeDirectives("types", types)
	writeDirectives("lib", libs)
}

func (printer *Printer) emitSourceFileWorker(node SourceFile) {
	statements := node.statements
	printer.pushNameGenerationScope(node)
	forEach(node.statements, printer.generateNames)
	printer.emitHelpers(node)
	index := findIndex(statements, func(statement /* TODO(TS-TO-GO) inferred type ts.Statement */ any) bool {
		return !isPrologueDirective(statement)
	})
	printer.emitTripleSlashDirectivesIfNeeded(node)
	printer.emitList(node, statements, ListFormatMultiLine, nil /*parenthesizerRule*/, ifElse(index == -1, statements.length, index))
	printer.popNameGenerationScope(node)
}

// Transformation nodes

func (printer *Printer) emitPartiallyEmittedExpression(node PartiallyEmittedExpression) {
	emitFlags := getEmitFlags(node)
	if emitFlags&EmitFlagsNoLeadingComments == 0 && node.pos != node.expression.pos {
		printer.emitTrailingCommentsOfPosition(node.expression.pos)
	}
	printer.emitExpression(node.expression)
	if emitFlags&EmitFlagsNoTrailingComments == 0 && node.end != node.expression.end {
		printer.emitLeadingCommentsOfPosition(node.expression.end)
	}
}

func (printer *Printer) emitCommaList(node CommaListExpression) {
	printer.emitExpressionList(node, node.elements, ListFormatCommaListElements, nil /*parenthesizerRule*/)
}

/**
 * Emits any prologue directives at the start of a Statement list, returning the
 * number of prologue directives written to the output.
 */

func (printer *Printer) emitPrologueDirectives(statements []*Node, sourceFile SourceFile, seenPrologueDirectives Set[string]) number {
	needsToSetSourceFile := sourceFile != nil
	for i := 0; i < statements.length; i++ {
		statement := statements[i]
		if isPrologueDirective(statement) {
			var shouldEmitPrologueDirective bool
			if seenPrologueDirectives != nil {
				shouldEmitPrologueDirective = !seenPrologueDirectives.has(statement.expression.text)
			} else {
				shouldEmitPrologueDirective = true
			}
			if shouldEmitPrologueDirective {
				if needsToSetSourceFile {
					needsToSetSourceFile = false
					printer.setSourceFile(sourceFile)
				}
				printer.writeLine()
				printer.emit(statement)
				if seenPrologueDirectives != nil {
					seenPrologueDirectives.add(statement.expression.text)
				}
			}
		} else {
			// return index of the first non prologue directive
			return i
		}
	}

	return statements.length
}

func (printer *Printer) emitPrologueDirectivesIfNeeded(sourceFileOrBundle Union[Bundle, SourceFile]) {
	if isSourceFile(sourceFileOrBundle) {
		printer.emitPrologueDirectives(sourceFileOrBundle.statements, sourceFileOrBundle)
	} else {
		seenPrologueDirectives := NewSet[string]()
		for _, sourceFile := range sourceFileOrBundle.sourceFiles {
			printer.emitPrologueDirectives(sourceFile.statements, sourceFile, seenPrologueDirectives)
		}
		printer.setSourceFile(nil)
	}
}

func (printer *Printer) emitShebangIfNeeded(sourceFileOrBundle Union[Bundle, SourceFile]) *true {
	if isSourceFile(sourceFileOrBundle) {
		shebang := getShebang(sourceFileOrBundle.text)
		if shebang {
			printer.writeComment(shebang)
			printer.writeLine()
			return true
		}
	} else {
		for _, sourceFile := range sourceFileOrBundle.sourceFiles {
			// Emit only the first encountered shebang
			if printer.emitShebangIfNeeded(sourceFile) {
				return true
			}
		}
	}
}

//
// Helpers
//

func (printer *Printer) emitNodeWithWriter(node *Node, writer /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof write */ any) {
	if node == nil {
		return
	}
	savedWrite := printer.write
	printer.write = printer.writer
	printer.emit(node)
	printer.write = savedWrite
}

func (printer *Printer) emitDecoratorsAndModifiers(node *Node, modifiers *NodeArray[ModifierLike], allowDecorators bool) number {
	if modifiers. /* ? */ length {
		if every(modifiers, isModifier) {
			// if all modifier-likes are `Modifier`, simply emit the array as modifiers.
			return printer.emitModifierList(node, modifiers.(NodeArray[Modifier]))
		}

		if every(modifiers, isDecorator) {
			if allowDecorators {
				// if all modifier-likes are `Decorator`, simply emit the array as decorators.
				return printer.emitDecoratorList(node, modifiers.(NodeArray[Decorator]))
			}
			return node.pos
		}

		onBeforeEmitNodeArray(modifiers)

		// partition modifiers into contiguous chunks of `Modifier` or `Decorator`
		var lastMode Union[ /* TODO(TS-TO-GO) TypeNode LiteralType: "modifiers" */ any /* TODO(TS-TO-GO) TypeNode LiteralType: "decorators" */, any, undefined]
		var mode Union[ /* TODO(TS-TO-GO) TypeNode LiteralType: "modifiers" */ any /* TODO(TS-TO-GO) TypeNode LiteralType: "decorators" */, any, undefined]
		start := 0
		pos := 0
		var lastModifier *ModifierLike
		for start < modifiers.length {
			for pos < modifiers.length {
				lastModifier = modifiers[pos]
				if isDecorator(lastModifier) {
					mode = "decorators"
				} else {
					mode = "modifiers"
				}
				if lastMode == nil {
					lastMode = mode
				} else if mode != lastMode {
					break
				}

				pos++
			}

			var textRange TextRange = /* TODO(TS-TO-GO) inferred type ts.TextRange */ any{
				pos: -1,
				end: -1,
			}
			if start == 0 {
				textRange.pos = modifiers.pos
			}
			if pos == modifiers.length-1 {
				textRange.end = modifiers.end
			}
			if lastMode == "modifiers" || allowDecorators {
				printer.emitNodeListItems(printer.emit, node, modifiers, ifElse(lastMode == "modifiers", ListFormatModifiers, ListFormatDecorators), nil, start, pos-start, false, textRange)
			}
			start = pos
			lastMode = mode
			pos++
		}

		onAfterEmitNodeArray(modifiers)

		if lastModifier != nil && !positionIsSynthesized(lastModifier.end) {
			return lastModifier.end
		}
	}

	return node.pos
}

func (printer *Printer) emitModifierList(node *Node, modifiers *NodeArray[Modifier]) number {
	printer.emitList(node, modifiers, ListFormatModifiers)
	lastModifier := lastOrUndefined(modifiers)
	if lastModifier != nil && !positionIsSynthesized(lastModifier.end) {
		return lastModifier.end
	} else {
		return node.pos
	}
}

func (printer *Printer) emitTypeAnnotation(node *TypeNode) {
	if node != nil {
		printer.writePunctuation(":")
		printer.writeSpace()
		printer.emit(node)
	}
}

func (printer *Printer) emitInitializer(node Expression, equalCommentStartPos number, container *Node, parenthesizerRule func(node Expression) Expression) {
	if node != nil {
		printer.writeSpace()
		printer.emitTokenWithComment(ast.KindEqualsToken, equalCommentStartPos, printer.writeOperator, container)
		printer.writeSpace()
		printer.emitExpression(node, parenthesizerRule)
	}
}

func (printer *Printer) emitNodeWithPrefix(prefix string, prefixWriter func(s string), node *T, emit func(node T)) {
	if node != nil {
		prefixWriter(prefix)
		printer.emit(node)
	}
}

func (printer *Printer) emitWithLeadingSpace(node *Node) {
	if node != nil {
		printer.writeSpace()
		printer.emit(node)
	}
}

func (printer *Printer) emitExpressionWithLeadingSpace(node Expression, parenthesizerRule func(node Expression) Expression) {
	if node != nil {
		printer.writeSpace()
		printer.emitExpression(node, parenthesizerRule)
	}
}

func (printer *Printer) emitWithTrailingSpace(node *Node) {
	if node != nil {
		printer.emit(node)
		printer.writeSpace()
	}
}

func (printer *Printer) emitEmbeddedStatement(parent *Node, node Statement) {
	if isBlock(node) || getEmitFlags(parent)&EmitFlagsSingleLine != 0 || printer.preserveSourceNewlines && printer.getLeadingLineTerminatorCount(parent, node, ListFormatNone) == 0 {
		printer.writeSpace()
		printer.emit(node)
	} else {
		printer.writeLine()
		printer.increaseIndent()
		if isEmptyStatement(node) {
			printer.pipelineEmit(EmitHintEmbeddedStatement, node)
		} else {
			printer.emit(node)
		}
		printer.decreaseIndent()
	}
}

func (printer *Printer) emitDecoratorList(parentNode *Node, decorators *NodeArray[Decorator]) number {
	printer.emitList(parentNode, decorators, ListFormatDecorators)
	lastDecorator := lastOrUndefined(decorators)
	if lastDecorator != nil && !positionIsSynthesized(lastDecorator.end) {
		return lastDecorator.end
	} else {
		return parentNode.pos
	}
}

func (printer *Printer) emitTypeArguments(parentNode *Node, typeArguments *NodeArray[TypeNode]) {
	printer.emitList(parentNode, typeArguments, ListFormatTypeArguments, printer.typeArgumentParenthesizerRuleSelector)
}

func (printer *Printer) emitTypeParameters(parentNode Union[SignatureDeclaration, InterfaceDeclaration, TypeAliasDeclaration, ClassDeclaration, ClassExpression], typeParameters *NodeArray[TypeParameterDeclaration]) {
	if isFunctionLike(parentNode) && parentNode.typeArguments != nil {
		return printer.emitTypeArguments(parentNode, parentNode.typeArguments)
	}
	printer.emitList(parentNode, typeParameters, ListFormatTypeParameters|(ifElse(isArrowFunction(parentNode), ListFormatAllowTrailingComma, ListFormatNone)))
}

func (printer *Printer) emitParameters(parentNode *Node, parameters NodeArray[ParameterDeclaration]) {
	printer.emitList(parentNode, parameters, ListFormatParameters)
}

func (printer *Printer) canEmitSimpleArrowHead(parentNode Union[FunctionTypeNode, ConstructorTypeNode, ArrowFunction], parameters NodeArray[ParameterDeclaration]) *bool {
	parameter := singleOrUndefined(parameters)
	return parameter && parameter.pos == parentNode.pos && isArrowFunction(parentNode) && parentNode.type_ == nil && !some(parentNode.modifiers) && !some(parentNode.typeParameters) && !some(parameter.modifiers) && parameter.dotDotDotToken == nil && parameter.questionToken == nil && parameter.type_ == nil && parameter.initializer == nil && isIdentifier(parameter.name)
	// parameter name must be identifier
}

func (printer *Printer) emitParametersForArrow(parentNode Union[FunctionTypeNode, ConstructorTypeNode, ArrowFunction], parameters NodeArray[ParameterDeclaration]) {
	if printer.canEmitSimpleArrowHead(parentNode, parameters) {
		printer.emitList(parentNode, parameters, ListFormatParameters & ^ListFormatParenthesis)
	} else {
		printer.emitParameters(parentNode, parameters)
	}
}

func (printer *Printer) emitParametersForIndexSignature(parentNode *Node, parameters NodeArray[ParameterDeclaration]) {
	printer.emitList(parentNode, parameters, ListFormatIndexSignatureParameters)
}

func (printer *Printer) writeDelimiter(format ListFormat) {
	switch format & ListFormatDelimitersMask {
	case ListFormatNone:
	case ListFormatCommaDelimited:
		printer.writePunctuation(",")
	case ListFormatBarDelimited:
		printer.writeSpace()
		printer.writePunctuation("|")
	case ListFormatAsteriskDelimited:
		printer.writeSpace()
		printer.writePunctuation("*")
		printer.writeSpace()
	case ListFormatAmpersandDelimited:
		printer.writeSpace()
		printer.writePunctuation("&")
	}
}

func (printer *Printer) emitList(parentNode *Node, children *Children, format ListFormat, parenthesizerRule ParenthesizerRuleOrSelector[Child], start number, count number) {
	printer.emitNodeList(printer.emit, parentNode, children, format|(ifElse(parentNode != nil && getEmitFlags(parentNode)&EmitFlagsMultiLine != 0, ListFormatPreferNewLine, 0)), parenthesizerRule, start, count)
}

func (printer *Printer) emitExpressionList(parentNode *Node, children *Children, format ListFormat, parenthesizerRule ParenthesizerRuleOrSelector[Child], start number, count number) {
	printer.emitNodeList(printer.emitExpression, parentNode, children, format, parenthesizerRule, start, count)
}

func (printer *Printer) emitNodeList(emit EmitFunction, parentNode *Node, children *Children, format ListFormat, parenthesizerRule *ParenthesizerRuleOrSelector[Child], start number /*  = 0 */, count number /*  = children ? children.length - start : 0 */) {
	isUndefined := children == nil
	if isUndefined && format&ListFormatOptionalIfUndefined != 0 {
		return
	}

	isEmpty := children == nil || start >= children.length || count == 0
	if isEmpty && format&ListFormatOptionalIfEmpty != 0 {
		onBeforeEmitNodeArray(children)
		onAfterEmitNodeArray(children)
		return
	}

	if format&ListFormatBracketsMask != 0 {
		printer.writePunctuation(getOpeningBracket(format))
		if isEmpty && children != nil {
			printer.emitTrailingCommentsOfPosition(children.pos, true /*prefixSpace*/)
			// Emit comments within empty bracketed lists
		}
	}

	onBeforeEmitNodeArray(children)

	if isEmpty {
		// Write a line terminator if the parent node was multi-line
		if format&ListFormatMultiLine != 0 && !(printer.preserveSourceNewlines && (parentNode == nil || printer.currentSourceFile != nil && rangeIsOnSingleLine(parentNode, printer.currentSourceFile))) {
			printer.writeLine()
		} else if format&ListFormatSpaceBetweenBraces != 0 && format&ListFormatNoSpaceIfEmpty == 0 {
			printer.writeSpace()
		}
	} else {
		printer.emitNodeListItems(printer.emit, parentNode, children, format, parenthesizerRule, start, count, children.hasTrailingComma, children)
	}

	onAfterEmitNodeArray(children)

	if format&ListFormatBracketsMask != 0 {
		if isEmpty && children != nil {
			printer.emitLeadingCommentsOfPosition(children.end)
			// Emit leading comments within empty lists
		}
		printer.writePunctuation(getClosingBracket(format))
	}
}

/**
 * Emits a list without brackets or raising events.
 *
 * NOTE: You probably don't want to call this directly and should be using `emitList` or `emitExpressionList` instead.
 */

func (printer *Printer) emitNodeListItems(emit EmitFunction, parentNode *Node, children []Child, format ListFormat, parenthesizerRule *ParenthesizerRuleOrSelector[Child], start number, count number, hasTrailingComma bool, childrenTextRange *TextRange) {
	// Write the opening line terminator or leading whitespace.
	mayEmitInterveningComments := (format & ListFormatNoInterveningComments) == 0
	shouldEmitInterveningComments := mayEmitInterveningComments

	leadingLineTerminatorCount := printer.getLeadingLineTerminatorCount(parentNode, children[start], format)
	if leadingLineTerminatorCount != 0 {
		printer.writeLine(leadingLineTerminatorCount)
		shouldEmitInterveningComments = false
	} else if format&ListFormatSpaceBetweenBraces != 0 {
		printer.writeSpace()
	}

	// Increase the indent, if requested.
	if format&ListFormatIndented != 0 {
		printer.increaseIndent()
	}

	emitListItem := getEmitListItem(printer.emit, parenthesizerRule)

	// Emit each child.
	var previousSibling *Node
	shouldDecreaseIndentAfterEmit := false
	for i := 0; i < count; i++ {
		child := children[start+i]

		// Write the delimiter if this is not the first node.
		if format&ListFormatAsteriskDelimited != 0 {
			// always write JSDoc in the format "\n *"
			printer.writeLine()
			printer.writeDelimiter(format)
		} else if previousSibling != nil {
			// i.e
			//      function commentedParameters(
			//          /* Parameter a */
			//          a
			//          /* End of parameter a */ -> this comment isn't considered to be trailing comment of parameter "a" due to newline
			//          ,
			if format&ListFormatDelimitersMask != 0 && previousSibling.end != (ifElse(parentNode != nil, parentNode.end, -1)) {
				previousSiblingEmitFlags := getEmitFlags(previousSibling)
				if previousSiblingEmitFlags&EmitFlagsNoTrailingComments == 0 {
					printer.emitLeadingCommentsOfPosition(previousSibling.end)
				}
			}

			printer.writeDelimiter(format)

			// Write either a line terminator or whitespace to separate the elements.
			separatingLineTerminatorCount := printer.getSeparatingLineTerminatorCount(previousSibling, child, format)
			if separatingLineTerminatorCount > 0 {
				// If a synthesized node in a single-line list starts on a new
				// line, we should increase the indent.
				if (format & (ListFormatLinesMask | ListFormatIndented)) == ListFormatSingleLine {
					printer.increaseIndent()
					shouldDecreaseIndentAfterEmit = true
				}

				if shouldEmitInterveningComments && format&ListFormatDelimitersMask != 0 && !positionIsSynthesized(child.pos) {
					commentRange := getCommentRange(child)
					printer.emitTrailingCommentsOfPosition(commentRange.pos, format&ListFormatSpaceBetweenSiblings != 0 /*prefixSpace*/, true /*forceNoNewline*/)
				}

				printer.writeLine(separatingLineTerminatorCount)
				shouldEmitInterveningComments = false
			} else if previousSibling && format&ListFormatSpaceBetweenSiblings != 0 {
				printer.writeSpace()
			}
		}

		// Emit this child.
		if shouldEmitInterveningComments {
			commentRange := getCommentRange(child)
			printer.emitTrailingCommentsOfPosition(commentRange.pos)
		} else {
			shouldEmitInterveningComments = mayEmitInterveningComments
		}

		printer.nextListElementPos = child.pos
		emitListItem(child, printer.emit, parenthesizerRule, i)

		if shouldDecreaseIndentAfterEmit {
			printer.decreaseIndent()
			shouldDecreaseIndentAfterEmit = false
		}

		previousSibling = child
	}

	// Write a trailing comma, if requested.
	var emitFlags /* TODO(TS-TO-GO) inferred type 0 | ts.EmitFlags */ any
	if previousSibling != nil {
		emitFlags = getEmitFlags(previousSibling)
	} else {
		emitFlags = 0
	}
	skipTrailingComments := printer.commentsDisabled || emitFlags&EmitFlagsNoTrailingComments != 0
	emitTrailingComma := hasTrailingComma && (format & ListFormatAllowTrailingComma) && (format & ListFormatCommaDelimited)
	if emitTrailingComma {
		if previousSibling != nil && !skipTrailingComments {
			printer.emitTokenWithComment(ast.KindCommaToken, previousSibling.end, printer.writePunctuation, previousSibling)
		} else {
			printer.writePunctuation(",")
		}
	}

	// Emit any trailing comment of the last element in the list
	// i.e
	//       var array = [...
	//          2
	//          /* end of element 2 */
	//       ];
	if previousSibling != nil && (ifElse(parentNode != nil, parentNode.end, -1)) != previousSibling.end && (format&ListFormatDelimitersMask != 0) && !skipTrailingComments {
		printer.emitLeadingCommentsOfPosition(ifElse(emitTrailingComma && childrenTextRange. /* ? */ end, childrenTextRange.end, previousSibling.end))
	}

	// Decrease the indent, if requested.
	if format&ListFormatIndented != 0 {
		printer.decreaseIndent()
	}

	// Write the closing line terminator or closing whitespace.
	closingLineTerminatorCount := printer.getClosingLineTerminatorCount(parentNode, children[start+count-1], format, childrenTextRange)
	if closingLineTerminatorCount != 0 {
		printer.writeLine(closingLineTerminatorCount)
	} else if format&(ListFormatSpaceAfterList|ListFormatSpaceBetweenBraces) != 0 {
		printer.writeSpace()
	}
}

// Writers

func (printer *Printer) writeLiteral(s string) {
	printer.writer.writeLiteral(s)
}

func (printer *Printer) writeStringLiteral(s string) {
	printer.writer.writeStringLiteral(s)
}

func (printer *Printer) writeBase(s string) {
	printer.writer.write(s)
}

func (printer *Printer) writeSymbol(s string, sym *Symbol) {
	printer.writer.writeSymbol(s, sym)
}

func (printer *Printer) writePunctuation(s string) {
	printer.writer.writePunctuation(s)
}

func (printer *Printer) writeTrailingSemicolon() {
	printer.writer.writeTrailingSemicolon(";")
}

func (printer *Printer) writeKeyword(s string) {
	printer.writer.writeKeyword(s)
}

func (printer *Printer) writeOperator(s string) {
	printer.writer.writeOperator(s)
}

func (printer *Printer) writeParameter(s string) {
	printer.writer.writeParameter(s)
}

func (printer *Printer) writeComment(s string) {
	printer.writer.writeComment(s)
}

func (printer *Printer) writeSpace() {
	printer.writer.writeSpace(" ")
}

func (printer *Printer) writeProperty(s string) {
	printer.writer.writeProperty(s)
}

func (printer *Printer) nonEscapingWrite(s string) {
	// This should be defined in a snippet-escaping text writer.
	if printer.writer.nonEscapingWrite != nil {
		printer.writer.nonEscapingWrite(s)
	} else {
		printer.writer.write(s)
	}
}

func (printer *Printer) writeLine(count number /*  = 1 */) {
	for i := 0; i < count; i++ {
		printer.writer.writeLine(i > 0)
	}
}

func (printer *Printer) increaseIndent() {
	printer.writer.increaseIndent()
}

func (printer *Printer) decreaseIndent() {
	printer.writer.decreaseIndent()
}

func (printer *Printer) writeToken(token SyntaxKind, pos number, writer func(s string), contextNode *Node) number {
	if !printer.sourceMapsDisabled {
		return printer.emitTokenWithSourceMap(contextNode, token, printer.writer, pos, printer.writeTokenText)
	} else {
		return printer.writeTokenText(token, printer.writer, pos)
	}
}

func (printer *Printer) writeTokenNode(node *Node, writer func(s string)) {
	if onBeforeEmitToken != nil {
		onBeforeEmitToken(node)
	}
	printer.writer(tokenToString(node.kind))
	if onAfterEmitToken != nil {
		onAfterEmitToken(node)
	}
}

/* OVERLOAD: function writeTokenText(token: SyntaxKind, writer: (s: string) => void): void; */
/* OVERLOAD: function writeTokenText(token: SyntaxKind, writer: (s: string) => void, pos: number): number; */
func (printer *Printer) writeTokenText(token SyntaxKind, writer func(s string), pos number) number {
	tokenString := tokenToString(token)
	printer.writer(tokenString)
	if pos < 0 {
		return pos
	} else {
		return pos + tokenString.length
	}
}

func (printer *Printer) writeLineOrSpace(parentNode *Node, prevChildNode *Node, nextChildNode *Node) {
	if getEmitFlags(parentNode)&EmitFlagsSingleLine != 0 {
		printer.writeSpace()
	} else if printer.preserveSourceNewlines {
		lines := printer.getLinesBetweenNodes(parentNode, prevChildNode, nextChildNode)
		if lines != 0 {
			printer.writeLine(lines)
		} else {
			printer.writeSpace()
		}
	} else {
		printer.writeLine()
	}
}

func (printer *Printer) writeLines(text string) {
	lines := text.split(regexp.MustParse(`\r\n?|\n`))
	indentation := guessIndentation(lines)
	for _, lineText := range lines {
		var line string
		if indentation {
			line = lineText.slice(indentation)
		} else {
			line = lineText
		}
		if line.length != 0 {
			printer.writeLine()
			printer.write(line)
		}
	}
}

func (printer *Printer) writeLinesAndIndent(lineCount number, writeSpaceIfNotIndenting bool) {
	if lineCount != 0 {
		printer.increaseIndent()
		printer.writeLine(lineCount)
	} else if writeSpaceIfNotIndenting {
		printer.writeSpace()
	}
}

// Helper function to decrease the indent if we previously indented.  Allows multiple
// previous indent values to be considered at a time.  This also allows caller to just
// call this once, passing in all their appropriate indent values, instead of needing
// to call this helper function multiple times.
func (printer *Printer) decreaseIndentIf(value1 Union[bool, number, undefined], value2 Union[bool, number]) {
	if value1 {
		printer.decreaseIndent()
	}
	if value2 {
		printer.decreaseIndent()
	}
}

func (printer *Printer) getLeadingLineTerminatorCount(parentNode *Node, firstChild *Node, format ListFormat) number {
	if format&ListFormatPreserveLines != 0 || printer.preserveSourceNewlines {
		if format&ListFormatPreferNewLine != 0 {
			return 1
		}

		if firstChild == nil {
			if parentNode == nil || printer.currentSourceFile != nil && rangeIsOnSingleLine(parentNode, printer.currentSourceFile) {
				return 0
			} else {
				return 1
			}
		}
		if firstChild.pos == printer.nextListElementPos {
			// If this child starts at the beginning of a list item in a parent list, its leading
			// line terminators have already been written as the separating line terminators of the
			// parent list. Example:
			//
			// class Foo {
			//   constructor() {}
			//   public foo() {}
			// }
			//
			// The outer list is the list of class members, with one line terminator between the
			// constructor and the method. The constructor is written, the separating line terminator
			// is written, and then we start emitting the method. Its modifiers ([public]) constitute an inner
			// list, so we look for its leading line terminators. If we didn't know that we had already
			// written a newline as part of the parent list, it would appear that we need to write a
			// leading newline to start the modifiers.
			return 0
		}
		if firstChild.kind == ast.KindJsxText {
			// JsxText will be written with its leading whitespace, so don't add more manually.
			return 0
		}
		if printer.currentSourceFile != nil && parentNode != nil && !positionIsSynthesized(parentNode.pos) && !nodeIsSynthesized(firstChild) && (!firstChild.parent || getOriginalNode(firstChild.parent) == getOriginalNode(parentNode)) {
			if printer.preserveSourceNewlines {
				return printer.getEffectiveLines(func(includeComments bool) number {
					return getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(firstChild.pos, parentNode.pos, printer.currentSourceFile, includeComments)
				})
			}
			if rangeStartPositionsAreOnSameLine(parentNode, firstChild, printer.currentSourceFile) {
				return 0
			} else {
				return 1
			}
		}
		if printer.synthesizedNodeStartsOnNewLine(firstChild, format) {
			return 1
		}
	}
	if format&ListFormatMultiLine != 0 {
		return 1
	} else {
		return 0
	}
}

func (printer *Printer) getSeparatingLineTerminatorCount(previousNode *Node, nextNode *Node, format ListFormat) number {
	if format&ListFormatPreserveLines != 0 || printer.preserveSourceNewlines {
		if previousNode == nil || nextNode == nil {
			return 0
		}
		if nextNode.kind == ast.KindJsxText {
			// JsxText will be written with its leading whitespace, so don't add more manually.
			return 0
		} else if printer.currentSourceFile != nil && !nodeIsSynthesized(previousNode) && !nodeIsSynthesized(nextNode) {
			if printer.preserveSourceNewlines && printer.siblingNodePositionsAreComparable(previousNode, nextNode) {
				return printer.getEffectiveLines(func(includeComments bool) number {
					return getLinesBetweenRangeEndAndRangeStart(previousNode, nextNode, printer.currentSourceFile, includeComments)
				})
			} else if !printer.preserveSourceNewlines && printer.originalNodesHaveSameParent(previousNode, nextNode) {
				if rangeEndIsOnSameLineAsRangeStart(previousNode, nextNode, printer.currentSourceFile) {
					return 0
				} else {
					return 1
				}
			}
			// If the two nodes are not comparable, add a line terminator based on the format that can indicate
			// whether new lines are preferred or not.
			if format&ListFormatPreferNewLine != 0 {
				return 1
			} else {
				return 0
			}
		} else if printer.synthesizedNodeStartsOnNewLine(previousNode, format) || printer.synthesizedNodeStartsOnNewLine(nextNode, format) {
			return 1
		}
	} else if getStartsOnNewLine(nextNode) {
		return 1
	}
	if format&ListFormatMultiLine != 0 {
		return 1
	} else {
		return 0
	}
}

func (printer *Printer) getClosingLineTerminatorCount(parentNode *Node, lastChild *Node, format ListFormat, childrenTextRange *TextRange) number {
	if format&ListFormatPreserveLines != 0 || printer.preserveSourceNewlines {
		if format&ListFormatPreferNewLine != 0 {
			return 1
		}

		if lastChild == nil {
			if parentNode == nil || printer.currentSourceFile != nil && rangeIsOnSingleLine(parentNode, printer.currentSourceFile) {
				return 0
			} else {
				return 1
			}
		}
		if printer.currentSourceFile != nil && parentNode != nil && !positionIsSynthesized(parentNode.pos) && !nodeIsSynthesized(lastChild) && (!lastChild.parent || lastChild.parent == parentNode) {
			if printer.preserveSourceNewlines {
				var end number
				if childrenTextRange != nil && !positionIsSynthesized(childrenTextRange.end) {
					end = childrenTextRange.end
				} else {
					end = lastChild.end
				}
				return printer.getEffectiveLines(func(includeComments bool) number {
					return getLinesBetweenPositionAndNextNonWhitespaceCharacter(end, parentNode.end, printer.currentSourceFile, includeComments)
				})
			}
			if rangeEndPositionsAreOnSameLine(parentNode, lastChild, printer.currentSourceFile) {
				return 0
			} else {
				return 1
			}
		}
		if printer.synthesizedNodeStartsOnNewLine(lastChild, format) {
			return 1
		}
	}
	if format&ListFormatMultiLine != 0 && format&ListFormatNoTrailingNewLine == 0 {
		return 1
	}
	return 0
}

func (printer *Printer) getEffectiveLines(getLineDifference func(includeComments bool) number) number {
	// If 'preserveSourceNewlines' is disabled, we should never call this function
	// because it could be more expensive than alternative approximations.
	Debug.assert(printer.preserveSourceNewlines)
	// We start by measuring the line difference from a position to its adjacent comments,
	// so that this is counted as a one-line difference, not two:
	//
	//   node1;
	//   // NODE2 COMMENT
	//   node2;
	lines := getLineDifference(true)
	if lines == 0 {
		// However, if the line difference considering comments was 0, we might have this:
		//
		//   node1; // NODE2 COMMENT
		//   node2;
		//
		// in which case we should be ignoring node2's comment, so this too is counted as
		// a one-line difference, not zero.
		return getLineDifference(false)
	}
	return lines
}

func (printer *Printer) writeLineSeparatorsAndIndentBefore(node *Node, parent *Node) bool {
	leadingNewlines := printer.preserveSourceNewlines && printer.getLeadingLineTerminatorCount(parent, node, ListFormatNone)
	if leadingNewlines {
		printer.writeLinesAndIndent(leadingNewlines, false /*writeSpaceIfNotIndenting*/)
	}
	return leadingNewlines
}

func (printer *Printer) writeLineSeparatorsAfter(node *Node, parent *Node) {
	trailingNewlines := printer.preserveSourceNewlines && printer.getClosingLineTerminatorCount(parent, node, ListFormatNone, nil /*childrenTextRange*/)
	if trailingNewlines {
		printer.writeLine(trailingNewlines)
	}
}

func (printer *Printer) synthesizedNodeStartsOnNewLine(node *Node, format ListFormat) bool {
	if nodeIsSynthesized(node) {
		startsOnNewLine := getStartsOnNewLine(node)
		if startsOnNewLine == nil {
			return (format & ListFormatPreferNewLine) != 0
		}

		return startsOnNewLine
	}

	return (format & ListFormatPreferNewLine) != 0
}

func (printer *Printer) getLinesBetweenNodes(parent *Node, node1 *Node, node2 *Node) number {
	if getEmitFlags(parent)&EmitFlagsNoIndentation != 0 {
		return 0
	}

	parent = printer.skipSynthesizedParentheses(parent)
	node1 = printer.skipSynthesizedParentheses(node1)
	node2 = printer.skipSynthesizedParentheses(node2)

	// Always use a newline for synthesized code if the synthesizer desires it.
	if getStartsOnNewLine(node2) {
		return 1
	}

	if printer.currentSourceFile != nil && !nodeIsSynthesized(parent) && !nodeIsSynthesized(node1) && !nodeIsSynthesized(node2) {
		if printer.preserveSourceNewlines {
			return printer.getEffectiveLines(func(includeComments bool) number {
				return getLinesBetweenRangeEndAndRangeStart(node1, node2, printer.currentSourceFile, includeComments)
			})
		}
		if rangeEndIsOnSameLineAsRangeStart(node1, node2, printer.currentSourceFile) {
			return 0
		} else {
			return 1
		}
	}

	return 0
}

func (printer *Printer) isEmptyBlock(block BlockLike) bool {
	return block.statements.length == 0 && (printer.currentSourceFile == nil || rangeEndIsOnSameLineAsRangeStart(block, block, printer.currentSourceFile))
}

func (printer *Printer) skipSynthesizedParentheses(node *Node) /* TODO(TS-TO-GO) inferred type ts.Node */ any {
	for node.kind == ast.KindParenthesizedExpression && nodeIsSynthesized(node) {
		node = (node.AsParenthesizedExpression()).expression
	}

	return node
}

func (printer *Printer) getTextOfNode(node Union[Identifier, PrivateIdentifier, LiteralExpression, JsxNamespacedName], includeTrivia bool) string {
	if isGeneratedIdentifier(node) || isGeneratedPrivateIdentifier(node) {
		return printer.generateName(node)
	}
	if isStringLiteral(node) && node.textSourceNode != nil {
		return printer.getTextOfNode(node.textSourceNode, includeTrivia)
	}
	sourceFile := printer.currentSourceFile
	// const needed for control flow
	canUseSourceFile := sourceFile != nil && node.parent && !nodeIsSynthesized(node)
	if isMemberName(node) {
		if !canUseSourceFile || getSourceFileOfNode(node) != getOriginalNode(sourceFile) {
			return idText(node)
		}
	} else if isJsxNamespacedName(node) {
		if !canUseSourceFile || getSourceFileOfNode(node) != getOriginalNode(sourceFile) {
			return getTextOfJsxNamespacedName(node)
		}
	} else {
		Debug.assertNode(node, isLiteralExpression)
		// not strictly necessary
		if !canUseSourceFile {
			return node.text
		}
	}
	return getSourceTextOfNodeFromSourceFile(sourceFile, node, includeTrivia)
}

func (printer *Printer) getLiteralTextOfNode(node LiteralLikeNode, sourceFile * /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any /*  = currentSourceFile */, neverAsciiEscape *bool, jsxAttributeEscape bool) string {
	if node.kind == ast.KindStringLiteral && (node.AsStringLiteral()).textSourceNode != nil {
		textSourceNode := (node.AsStringLiteral()).textSourceNode
		if isIdentifier(textSourceNode) || isPrivateIdentifier(textSourceNode) || isNumericLiteral(textSourceNode) || isJsxNamespacedName(textSourceNode) {
			var text string
			if isNumericLiteral(textSourceNode) {
				text = textSourceNode.text
			} else {
				text = printer.getTextOfNode(textSourceNode)
			}
			switch {
			case jsxAttributeEscape:
				return __TEMPLATE__("\"", escapeJsxAttributeString(text), "\"")
			case neverAsciiEscape || (getEmitFlags(node)&EmitFlagsNoAsciiEscaping != 0):
				return __TEMPLATE__("\"", escapeString(text), "\"")
			default:
				return __TEMPLATE__("\"", escapeNonAsciiString(text), "\"")
			}
		} else {
			return printer.getLiteralTextOfNode(textSourceNode, getSourceFileOfNode(textSourceNode), neverAsciiEscape, jsxAttributeEscape)
		}
	}

	flags := (ifElse(neverAsciiEscape, GetLiteralTextFlagsNeverAsciiEscape, 0)) | (ifElse(jsxAttributeEscape, GetLiteralTextFlagsJsxAttributeEscape, 0)) | (ifElse(printerOptions.terminateUnterminatedLiterals, GetLiteralTextFlagsTerminateUnterminatedLiterals, 0)) | (ifElse(printerOptions.target && printerOptions.target >= ScriptTargetES2021, GetLiteralTextFlagsAllowNumericSeparator, 0))

	return getLiteralText(node, sourceFile, flags)
}

/**
 * Push a new name generation scope.
 */

func (printer *Printer) pushNameGenerationScope(node *Node) {
	printer.privateNameTempFlagsStack.push(printer.privateNameTempFlags)
	printer.privateNameTempFlags = TempFlagsAuto
	printer.reservedPrivateNamesStack.push(printer.reservedPrivateNames)

	if node != nil && getEmitFlags(node)&EmitFlagsReuseTempVariableScope != 0 {
		return
	}

	printer.tempFlagsStack.push(printer.tempFlags)
	printer.tempFlags = TempFlagsAuto
	printer.formattedNameTempFlagsStack.push(printer.formattedNameTempFlags)
	printer.formattedNameTempFlags = nil
	printer.reservedNamesStack.push(printer.reservedNames)
}

/**
 * Pop the current name generation scope.
 */

func (printer *Printer) popNameGenerationScope(node *Node) {
	printer.privateNameTempFlags = printer.privateNameTempFlagsStack.pop()
	printer.reservedPrivateNames = printer.reservedPrivateNamesStack.pop()

	if node != nil && getEmitFlags(node)&EmitFlagsReuseTempVariableScope != 0 {
		return
	}

	printer.tempFlags = printer.tempFlagsStack.pop()
	printer.formattedNameTempFlags = printer.formattedNameTempFlagsStack.pop()
	printer.reservedNames = printer.reservedNamesStack.pop()
}

func (printer *Printer) reserveNameInNestedScopes(name string) {
	if printer.reservedNames == nil || printer.reservedNames == lastOrUndefined(printer.reservedNamesStack) {
		printer.reservedNames = NewSet()
	}
	printer.reservedNames.add(name)
}

func (printer *Printer) reservePrivateNameInNestedScopes(name string) {
	if printer.reservedPrivateNames == nil || printer.reservedPrivateNames == lastOrUndefined(printer.reservedPrivateNamesStack) {
		printer.reservedPrivateNames = NewSet()
	}
	printer.reservedPrivateNames.add(name)
}

func (printer *Printer) generateNames(node *Node) {
	if node == nil {
		return
	}
	switch node.kind {
	case ast.KindBlock:
		forEach((node.AsBlock()).statements, printer.generateNames)
	case ast.KindLabeledStatement,
		ast.KindWithStatement,
		ast.KindDoStatement,
		ast.KindWhileStatement:
		printer.generateNames((node /* as LabeledStatement | WithStatement | DoStatement | WhileStatement */).statement)
	case ast.KindIfStatement:
		printer.generateNames((node.AsIfStatement()).thenStatement)
		printer.generateNames((node.AsIfStatement()).elseStatement)
	case ast.KindForStatement,
		ast.KindForOfStatement,
		ast.KindForInStatement:
		printer.generateNames((node /* as ForStatement | ForInOrOfStatement */).initializer)
		printer.generateNames((node /* as ForStatement | ForInOrOfStatement */).statement)
	case ast.KindSwitchStatement:
		printer.generateNames((node.AsSwitchStatement()).caseBlock)
	case ast.KindCaseBlock:
		forEach((node.AsCaseBlock()).clauses, printer.generateNames)
	case ast.KindCaseClause,
		ast.KindDefaultClause:
		forEach((node.AsCaseOrDefaultClause()).statements, printer.generateNames)
	case ast.KindTryStatement:
		printer.generateNames((node.AsTryStatement()).tryBlock)
		printer.generateNames((node.AsTryStatement()).catchClause)
		printer.generateNames((node.AsTryStatement()).finallyBlock)
	case ast.KindCatchClause:
		printer.generateNames((node.AsCatchClause()).variableDeclaration)
		printer.generateNames((node.AsCatchClause()).block)
	case ast.KindVariableStatement:
		printer.generateNames((node.AsVariableStatement()).declarationList)
	case ast.KindVariableDeclarationList:
		forEach((node.AsVariableDeclarationList()).declarations, printer.generateNames)
	case ast.KindVariableDeclaration,
		ast.KindParameter,
		ast.KindBindingElement,
		ast.KindClassDeclaration:
		printer.generateNameIfNeeded((node.AsNamedDeclaration()).name)
	case ast.KindFunctionDeclaration:
		printer.generateNameIfNeeded((node.AsFunctionDeclaration()).name)
		if getEmitFlags(node)&EmitFlagsReuseTempVariableScope != 0 {
			forEach((node.AsFunctionDeclaration()).parameters, printer.generateNames)
			printer.generateNames((node.AsFunctionDeclaration()).body)
		}
	case ast.KindObjectBindingPattern,
		ast.KindArrayBindingPattern:
		forEach((node.AsBindingPattern()).elements, printer.generateNames)
	case ast.KindImportDeclaration:
		printer.generateNames((node.AsImportDeclaration()).importClause)
	case ast.KindImportClause:
		printer.generateNameIfNeeded((node.AsImportClause()).name)
		printer.generateNames((node.AsImportClause()).namedBindings)
	case ast.KindNamespaceImport:
		printer.generateNameIfNeeded((node.AsNamespaceImport()).name)
	case ast.KindNamespaceExport:
		printer.generateNameIfNeeded((node.AsNamespaceExport()).name)
	case ast.KindNamedImports:
		forEach((node.AsNamedImports()).elements, printer.generateNames)
	case ast.KindImportSpecifier:
		printer.generateNameIfNeeded((node.AsImportSpecifier()).propertyName || (node.AsImportSpecifier()).name)
	}
}

func (printer *Printer) generateMemberNames(node *Node) {
	if node == nil {
		return
	}
	switch node.kind {
	case ast.KindPropertyAssignment,
		ast.KindShorthandPropertyAssignment,
		ast.KindPropertyDeclaration,
		ast.KindPropertySignature,
		ast.KindMethodDeclaration,
		ast.KindMethodSignature,
		ast.KindGetAccessor,
		ast.KindSetAccessor:
		printer.generateNameIfNeeded((node.AsNamedDeclaration()).name)
	}
}

func (printer *Printer) generateNameIfNeeded(name *DeclarationName) {
	if name != nil {
		if isGeneratedIdentifier(name) || isGeneratedPrivateIdentifier(name) {
			printer.generateName(name)
		} else if isBindingPattern(name) {
			printer.generateNames(name)
		}
	}
}

/**
 * Generate the text for a generated identifier.
 */

func (printer *Printer) generateName(name Union[GeneratedIdentifier, GeneratedPrivateIdentifier]) string {
	autoGenerate := name.emitNode.autoGenerate
	if (autoGenerate.flags & GeneratedIdentifierFlagsKindMask) == GeneratedIdentifierFlagsNode {
		// Node names generate unique names based on their original node
		// and are cached based on that node's id.
		return printer.generateNameCached(getNodeForGeneratedName(name), isPrivateIdentifier(name), autoGenerate.flags, autoGenerate.prefix, autoGenerate.suffix)
	} else {
		// Auto, Loop, and Unique names are cached based on their unique
		// autoGenerateId.
		autoGenerateId := autoGenerate.id
		return printer.autoGeneratedIdToGeneratedName[autoGenerateId] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: autoGeneratedIdToGeneratedName[autoGenerateId] = makeName(name) */ TODO)
	}
}

func (printer *Printer) generateNameCached(node *Node, privateName bool, flags GeneratedIdentifierFlags, prefix Union[string, GeneratedNamePart], suffix string) string {
	nodeId := getNodeId(node)
	var cache []string
	if privateName {
		cache = printer.nodeIdToGeneratedPrivateName
	} else {
		cache = printer.nodeIdToGeneratedName
	}
	return cache[nodeId] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: cache[nodeId] = generateNameForNode(node, privateName, flags ?? GeneratedIdentifierFlags.None, formatGeneratedNamePart(prefix, generateName), formatGeneratedNamePart(suffix)) */ TODO)
}

/**
 * Returns a value indicating whether a name is unique globally, within the current file,
 * or within the NameGenerator.
 */

func (printer *Printer) isUniqueName(name string, privateName bool) bool {
	return printer.isFileLevelUniqueNameInCurrentFile(name, privateName) && !printer.isReservedName(name, privateName) && !printer.generatedNames.has(name)
}

func (printer *Printer) isReservedName(name string, privateName bool) bool {
	var set *Set[string]
	var stack []*Set[string]
	if privateName {
		set = printer.reservedPrivateNames
		stack = printer.reservedPrivateNamesStack
	} else {
		set = printer.reservedNames
		stack = printer.reservedNamesStack
	}

	if set. /* ? */ has(name) {
		return true
	}
	for i := stack.length - 1; i >= 0; i-- {
		if set == stack[i] {
			continue
		}
		set = stack[i]
		if set. /* ? */ has(name) {
			return true
		}
	}
	return false
}

/**
 * Returns a value indicating whether a name is unique globally or within the current file.
 *
 * @param _isPrivate (unused) this parameter exists to avoid an unnecessary adaptor frame in v8
 * when `isfileLevelUniqueName` is passed as a callback to `makeUniqueName`.
 */

func (printer *Printer) isFileLevelUniqueNameInCurrentFile(name string, _isPrivate bool) bool {
	if printer.currentSourceFile != nil {
		return isFileLevelUniqueName(printer.currentSourceFile, name, hasGlobalName)
	} else {
		return true
	}
}

/**
 * Returns a value indicating whether a name is unique within a container.
 */

func (printer *Printer) isUniqueLocalName(name string, container *HasLocals) bool {
	for node := container; node != nil && isNodeDescendantOf(node, container); node = node.nextContainer {
		if canHaveLocals(node) && node.locals != nil {
			local := node.locals.get(escapeLeadingUnderscores(name))
			// We conservatively include alias symbols to cover cases where they're emitted as locals
			if local != nil && local.flags&(ast.SymbolFlagsValue|ast.SymbolFlagsExportValue|ast.SymbolFlagsAlias) != 0 {
				return false
			}
		}
	}
	return true
}

func (printer *Printer) getTempFlags(formattedNameKey string) TempFlags {
	switch formattedNameKey {
	case "":
		return printer.tempFlags
	case "#":
		return printer.privateNameTempFlags
	default:
		return ifNotNilElse(printer.formattedNameTempFlags. /* ? */ get(formattedNameKey), TempFlagsAuto)
	}
}

func (printer *Printer) setTempFlags(formattedNameKey string, flags TempFlags) {
	switch formattedNameKey {
	case "":
		printer.tempFlags = flags
	case "#":
		printer.privateNameTempFlags = flags
	default:
		if printer.formattedNameTempFlags == nil {
			printer.formattedNameTempFlags = NewMap()
		}
		printer.formattedNameTempFlags.set(formattedNameKey, flags)
	}
}

/**
 * Return the next available name in the pattern _a ... _z, _0, _1, ...
 * TempFlags._i or TempFlags._n may be used to express a preference for that dedicated name.
 * Note that names generated by makeTempVariableName and makeUniqueName will never conflict.
 */

func (printer *Printer) makeTempVariableName(flags TempFlags, reservedInNestedScopes bool, privateName bool, prefix string, suffix string) string {
	if prefix.length > 0 && prefix.charCodeAt(0) == CharacterCodeshash {
		prefix = prefix.slice(1)
	}

	// Generate a key to use to acquire a TempFlags counter based on the fixed portions of the generated name.
	key := formatGeneratedName(privateName, prefix, "", suffix)
	tempFlags := printer.getTempFlags(key)

	if flags != 0 && tempFlags&flags == 0 {
		var name /* TODO(TS-TO-GO) inferred type "_i" | "_n" */ any
		if flags == TempFlags_i {
			name = "_i"
		} else {
			name = "_n"
		}
		fullName := formatGeneratedName(privateName, prefix, name, suffix)
		if printer.isUniqueName(fullName, privateName) {
			tempFlags |= flags
			if privateName {
				printer.reservePrivateNameInNestedScopes(fullName)
			} else if reservedInNestedScopes {
				printer.reserveNameInNestedScopes(fullName)
			}
			printer.setTempFlags(key, tempFlags)
			return fullName
		}
	}

	for true {
		count := tempFlags & TempFlagsCountMask
		tempFlags++
		// Skip over 'i' and 'n'
		if count != 8 && count != 13 {
			var name string
			if count < 26 {
				name = "_" + String.fromCharCode(CharacterCodesa+count)
			} else {
				name = "_" + (count - 26)
			}
			fullName := formatGeneratedName(privateName, prefix, name, suffix)
			if printer.isUniqueName(fullName, privateName) {
				if privateName {
					printer.reservePrivateNameInNestedScopes(fullName)
				} else if reservedInNestedScopes {
					printer.reserveNameInNestedScopes(fullName)
				}
				printer.setTempFlags(key, tempFlags)
				return fullName
			}
		}
	}
}

/**
 * Generate a name that is unique within the current file and doesn't conflict with any names
 * in global scope. The name is formed by adding an '_n' suffix to the specified base name,
 * where n is a positive integer. Note that names generated by makeTempVariableName and
 * makeUniqueName are guaranteed to never conflict.
 * If `optimistic` is set, the first instance will use 'baseName' verbatim instead of 'baseName_1'
 */

func (printer *Printer) makeUniqueName(baseName string, checkFn func(name string, privateName bool) bool /*  = isUniqueName */, optimistic bool, scoped bool, privateName bool, prefix string, suffix string) string {
	if baseName.length > 0 && baseName.charCodeAt(0) == CharacterCodeshash {
		baseName = baseName.slice(1)
	}
	if prefix.length > 0 && prefix.charCodeAt(0) == CharacterCodeshash {
		prefix = prefix.slice(1)
	}
	if optimistic {
		fullName := formatGeneratedName(privateName, prefix, baseName, suffix)
		if checkFn(fullName, privateName) {
			if privateName {
				printer.reservePrivateNameInNestedScopes(fullName)
			} else if scoped {
				printer.reserveNameInNestedScopes(fullName)
			} else {
				printer.generatedNames.add(fullName)
			}
			return fullName
		}
	}
	// Find the first unique 'name_n', where n is a positive number
	if baseName.charCodeAt(baseName.length-1) != CharacterCodes_ {
		baseName += "_"
	}
	i := 1
	for true {
		fullName := formatGeneratedName(privateName, prefix, baseName+i, suffix)
		if checkFn(fullName, privateName) {
			if privateName {
				printer.reservePrivateNameInNestedScopes(fullName)
			} else if scoped {
				printer.reserveNameInNestedScopes(fullName)
			} else {
				printer.generatedNames.add(fullName)
			}
			return fullName
		}
		i++
	}
}

func (printer *Printer) makeFileLevelOptimisticUniqueName(name string) string {
	return printer.makeUniqueName(name, printer.isFileLevelUniqueNameInCurrentFile, true /*optimistic*/, false /*scoped*/, false /*privateName*/, "" /*prefix*/, "" /*suffix*/)
}

/**
 * Generates a unique name for a ModuleDeclaration or EnumDeclaration.
 */

func (printer *Printer) generateNameForModuleOrEnum(node Union[ModuleDeclaration, EnumDeclaration]) string {
	name := printer.getTextOfNode(node.name)
	// Use module/enum name itself if it is unique, otherwise make a unique variation
	if printer.isUniqueLocalName(name, tryCast(node, canHaveLocals)) {
		return name
	} else {
		return printer.makeUniqueName(name, printer.isUniqueName, false /*optimistic*/, false /*scoped*/, false /*privateName*/, "" /*prefix*/, "" /*suffix*/)
	}
}

/**
 * Generates a unique name for an ImportDeclaration or ExportDeclaration.
 */

func (printer *Printer) generateNameForImportOrExportDeclaration(node Union[ImportDeclaration, ExportDeclaration]) string {
	expr := getExternalModuleName(node)
	// TODO: GH#18217
	var baseName string
	if isStringLiteral(expr) {
		baseName = makeIdentifierFromModuleName(expr.text)
	} else {
		baseName = "module"
	}
	return printer.makeUniqueName(baseName, printer.isUniqueName, false /*optimistic*/, false /*scoped*/, false /*privateName*/, "" /*prefix*/, "" /*suffix*/)
}

/**
 * Generates a unique name for a default export.
 */

func (printer *Printer) generateNameForExportDefault() string {
	return printer.makeUniqueName("default", printer.isUniqueName, false /*optimistic*/, false /*scoped*/, false /*privateName*/, "" /*prefix*/, "" /*suffix*/)
}

/**
 * Generates a unique name for a class expression.
 */

func (printer *Printer) generateNameForClassExpression() string {
	return printer.makeUniqueName("class", printer.isUniqueName, false /*optimistic*/, false /*scoped*/, false /*privateName*/, "" /*prefix*/, "" /*suffix*/)
}

func (printer *Printer) generateNameForMethodOrAccessor(node Union[MethodDeclaration, AccessorDeclaration], privateName bool, prefix string, suffix string) string {
	if isIdentifier(node.name) {
		return printer.generateNameCached(node.name, privateName)
	}
	return printer.makeTempVariableName(TempFlagsAuto, false /*reservedInNestedScopes*/, privateName, prefix, suffix)
}

/**
 * Generates a unique name from a node.
 */

func (printer *Printer) generateNameForNode(node *Node, privateName bool, flags GeneratedIdentifierFlags, prefix string, suffix string) string {
	switch node.kind {
	case ast.KindIdentifier,
		ast.KindPrivateIdentifier:
		return printer.makeUniqueName(printer.getTextOfNode(node.AsIdentifier()), printer.isUniqueName, flags&GeneratedIdentifierFlagsOptimistic != 0, flags&GeneratedIdentifierFlagsReservedInNestedScopes != 0, privateName, prefix, suffix)
	case ast.KindModuleDeclaration,
		ast.KindEnumDeclaration:
		Debug.assert(prefix == "" && suffix == "" && !privateName)
		return printer.generateNameForModuleOrEnum(node /* as ModuleDeclaration | EnumDeclaration */)
	case ast.KindImportDeclaration,
		ast.KindExportDeclaration:
		Debug.assert(prefix == "" && suffix == "" && !privateName)
		return printer.generateNameForImportOrExportDeclaration(node /* as ImportDeclaration | ExportDeclaration */)
	case ast.KindFunctionDeclaration,
		ast.KindClassDeclaration:
		Debug.assert(prefix == "" && suffix == "" && !privateName)
		name := (node /* as ClassDeclaration | FunctionDeclaration */).name
		if name != nil && !isGeneratedIdentifier(name) {
			return printer.generateNameForNode(name, false /*privateName*/, flags, prefix, suffix)
		}
		return printer.generateNameForExportDefault()
	case ast.KindExportAssignment:
		Debug.assert(prefix == "" && suffix == "" && !privateName)
		return printer.generateNameForExportDefault()
	case ast.KindClassExpression:
		Debug.assert(prefix == "" && suffix == "" && !privateName)
		return printer.generateNameForClassExpression()
	case ast.KindMethodDeclaration,
		ast.KindGetAccessor,
		ast.KindSetAccessor:
		return printer.generateNameForMethodOrAccessor(node /* as MethodDeclaration | AccessorDeclaration */, privateName, prefix, suffix)
	case ast.KindComputedPropertyName:
		return printer.makeTempVariableName(TempFlagsAuto, true /*reservedInNestedScopes*/, privateName, prefix, suffix)
	default:
		return printer.makeTempVariableName(TempFlagsAuto, false /*reservedInNestedScopes*/, privateName, prefix, suffix)
	}
}

/**
 * Generates a unique identifier for a node.
 */

func (printer *Printer) makeName(name Union[GeneratedIdentifier, GeneratedPrivateIdentifier]) string {
	autoGenerate := name.emitNode.autoGenerate
	prefix := formatGeneratedNamePart(autoGenerate.prefix, printer.generateName)
	suffix := formatGeneratedNamePart(autoGenerate.suffix)
	switch autoGenerate.flags & GeneratedIdentifierFlagsKindMask {
	case GeneratedIdentifierFlagsAuto:
		return printer.makeTempVariableName(TempFlagsAuto, autoGenerate.flags&GeneratedIdentifierFlagsReservedInNestedScopes != 0, isPrivateIdentifier(name), prefix, suffix)
	case GeneratedIdentifierFlagsLoop:
		Debug.assertNode(name, isIdentifier)
		return printer.makeTempVariableName(TempFlags_i, autoGenerate.flags&GeneratedIdentifierFlagsReservedInNestedScopes != 0, false /*privateName*/, prefix, suffix)
	case GeneratedIdentifierFlagsUnique:
		return printer.makeUniqueName(idText(name), ifElse((autoGenerate.flags&GeneratedIdentifierFlagsFileLevel != 0), printer.isFileLevelUniqueNameInCurrentFile, printer.isUniqueName), autoGenerate.flags&GeneratedIdentifierFlagsOptimistic != 0, autoGenerate.flags&GeneratedIdentifierFlagsReservedInNestedScopes != 0, isPrivateIdentifier(name), prefix, suffix)
	}

	return Debug.fail(__TEMPLATE__("Unsupported GeneratedIdentifierKind: ", Debug.formatEnum(autoGenerate.flags&GeneratedIdentifierFlagsKindMask, (ts /* as any */).GeneratedIdentifierFlags, true /*isFlags*/), "."))
}

// Comments

func (printer *Printer) pipelineEmitWithComments(hint EmitHint, node *Node) {
	pipelinePhase := printer.getNextPipelinePhase(PipelinePhaseComments, hint, node)
	savedContainerPos := printer.containerPos
	savedContainerEnd := printer.containerEnd
	savedDeclarationListContainerEnd := printer.declarationListContainerEnd
	printer.emitCommentsBeforeNode(node)
	pipelinePhase(hint, node)
	printer.emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
}

func (printer *Printer) emitCommentsBeforeNode(node *Node) {
	emitFlags := getEmitFlags(node)
	commentRange := getCommentRange(node)

	// Emit leading comments
	printer.emitLeadingCommentsOfNode(node, emitFlags, commentRange.pos, commentRange.end)
	if emitFlags&EmitFlagsNoNestedComments != 0 {
		printer.commentsDisabled = true
	}
}

func (printer *Printer) emitCommentsAfterNode(node *Node, savedContainerPos number, savedContainerEnd number, savedDeclarationListContainerEnd number) {
	emitFlags := getEmitFlags(node)
	commentRange := getCommentRange(node)

	// Emit trailing comments
	if emitFlags&EmitFlagsNoNestedComments != 0 {
		printer.commentsDisabled = false
	}
	printer.emitTrailingCommentsOfNode(node, emitFlags, commentRange.pos, commentRange.end, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
	typeNode := getTypeNode(node)
	if typeNode != nil {
		printer.emitTrailingCommentsOfNode(node, emitFlags, typeNode.pos, typeNode.end, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
	}
}

func (printer *Printer) emitLeadingCommentsOfNode(node *Node, emitFlags EmitFlags, pos number, end number) {
	enterComment()
	printer.hasWrittenComment = false

	// We have to explicitly check that the node is JsxText because if the compilerOptions.jsx is "preserve" we will not do any transformation.
	// It is expensive to walk entire tree just to set one kind of node to have no comments.
	skipLeadingComments := pos < 0 || (emitFlags&EmitFlagsNoLeadingComments) != 0 || node.kind == ast.KindJsxText
	skipTrailingComments := end < 0 || (emitFlags&EmitFlagsNoTrailingComments) != 0 || node.kind == ast.KindJsxText

	// Save current container state on the stack.
	if (pos > 0 || end > 0) && pos != end {
		// Emit leading comments if the position is not synthesized and the node
		// has not opted out from emitting leading comments.
		if !skipLeadingComments {
			printer.emitLeadingComments(pos, node.kind != ast.KindNotEmittedStatement /*isEmittedNode*/)
		}

		if !skipLeadingComments || (pos >= 0 && (emitFlags&EmitFlagsNoLeadingComments) != 0) {
			// Advance the container position if comments get emitted or if they've been disabled explicitly using NoLeadingComments.
			printer.containerPos = pos
		}

		if !skipTrailingComments || (end >= 0 && (emitFlags&EmitFlagsNoTrailingComments) != 0) {
			// As above.
			printer.containerEnd = end

			// To avoid invalid comment emit in a down-level binding pattern, we
			// keep track of the last declaration list container's end
			if node.kind == ast.KindVariableDeclarationList {
				printer.declarationListContainerEnd = end
			}
		}
	}
	forEach(getSyntheticLeadingComments(node), printer.emitLeadingSynthesizedComment)
	exitComment()
}

func (printer *Printer) emitTrailingCommentsOfNode(node *Node, emitFlags EmitFlags, pos number, end number, savedContainerPos number, savedContainerEnd number, savedDeclarationListContainerEnd number) {
	enterComment()
	skipTrailingComments := end < 0 || (emitFlags&EmitFlagsNoTrailingComments) != 0 || node.kind == ast.KindJsxText
	forEach(getSyntheticTrailingComments(node), printer.emitTrailingSynthesizedComment)
	if (pos > 0 || end > 0) && pos != end {
		// Restore previous container state.
		printer.containerPos = savedContainerPos
		printer.containerEnd = savedContainerEnd
		printer.declarationListContainerEnd = savedDeclarationListContainerEnd

		// Emit trailing comments if the position is not synthesized and the node
		// has not opted out from emitting leading comments and is an emitted node.
		if !skipTrailingComments && node.kind != ast.KindNotEmittedStatement {
			printer.emitTrailingComments(end)
		}
	}
	exitComment()
}

func (printer *Printer) emitLeadingSynthesizedComment(comment SynthesizedComment) {
	if comment.hasLeadingNewline || comment.kind == ast.KindSingleLineCommentTrivia {
		printer.writer.writeLine()
	}
	printer.writeSynthesizedComment(comment)
	if comment.hasTrailingNewLine || comment.kind == ast.KindSingleLineCommentTrivia {
		printer.writer.writeLine()
	} else {
		printer.writer.writeSpace(" ")
	}
}

func (printer *Printer) emitTrailingSynthesizedComment(comment SynthesizedComment) {
	if !printer.writer.isAtStartOfLine() {
		printer.writer.writeSpace(" ")
	}
	printer.writeSynthesizedComment(comment)
	if comment.hasTrailingNewLine {
		printer.writer.writeLine()
	}
}

func (printer *Printer) writeSynthesizedComment(comment SynthesizedComment) {
	text := printer.formatSynthesizedComment(comment)
	var lineMap *[]number
	if comment.kind == ast.KindMultiLineCommentTrivia {
		lineMap = computeLineStarts(text)
	} else {
		lineMap = nil
	}
	writeCommentRange(text, lineMap, printer.writer, 0, text.length, printer.newLine)
}

func (printer *Printer) formatSynthesizedComment(comment SynthesizedComment) string {
	if comment.kind == ast.KindMultiLineCommentTrivia {
		return __TEMPLATE__("/*", comment.text, "*/")
	} else {
		return __TEMPLATE__("//", comment.text)
	}
}

func (printer *Printer) emitBodyWithDetachedComments(node T, detachedRange TextRange, emitCallback func(node T)) {
	enterComment()
	TODO_IDENTIFIER := detachedRange
	emitFlags := getEmitFlags(node)
	skipLeadingComments := pos < 0 || (emitFlags&EmitFlagsNoLeadingComments) != 0
	skipTrailingComments := printer.commentsDisabled || end < 0 || (emitFlags&EmitFlagsNoTrailingComments) != 0
	if !skipLeadingComments {
		printer.emitDetachedCommentsAndUpdateCommentsInfo(detachedRange)
	}

	exitComment()
	if emitFlags&EmitFlagsNoNestedComments != 0 && !printer.commentsDisabled {
		printer.commentsDisabled = true
		emitCallback(node)
		printer.commentsDisabled = false
	} else {
		emitCallback(node)
	}

	enterComment()
	if !skipTrailingComments {
		printer.emitLeadingComments(detachedRange.end, true /*isEmittedNode*/)
		if printer.hasWrittenComment && !printer.writer.isAtStartOfLine() {
			printer.writer.writeLine()
		}
	}
	exitComment()
}

func (printer *Printer) originalNodesHaveSameParent(nodeA *Node, nodeB *Node) bool {
	nodeA = getOriginalNode(nodeA)
	// For performance, do not call `getOriginalNode` for `nodeB` if `nodeA` doesn't even
	// have a parent node.
	return nodeA.parent && nodeA.parent == getOriginalNode(nodeB).parent
}

func (printer *Printer) siblingNodePositionsAreComparable(previousNode *Node, nextNode *Node) bool {
	if nextNode.pos < previousNode.end {
		return false
	}

	previousNode = getOriginalNode(previousNode)
	nextNode = getOriginalNode(nextNode)
	parent := previousNode.parent
	if !parent || parent != nextNode.parent {
		return false
	}

	parentNodeArray := getContainingNodeArray(previousNode)
	prevNodeIndex := parentNodeArray. /* ? */ indexOf(previousNode)
	return prevNodeIndex != nil && prevNodeIndex > -1 && parentNodeArray.indexOf(nextNode) == prevNodeIndex+1
}

func (printer *Printer) emitLeadingComments(pos number, isEmittedNode bool) {
	printer.hasWrittenComment = false

	if isEmittedNode {
		if pos == 0 && printer.currentSourceFile. /* ? */ isDeclarationFile {
			printer.forEachLeadingCommentToEmit(pos, printer.emitNonTripleSlashLeadingComment)
		} else {
			printer.forEachLeadingCommentToEmit(pos, printer.emitLeadingComment)
		}
	} else if pos == 0 {
		// If the node will not be emitted in JS, remove all the comments(normal, pinned and ///) associated with the node,
		// unless it is a triple slash comment at the top of the file.
		// For Example:
		//      /// <reference-path ...>
		//      declare var x;
		//      /// <reference-path ...>
		//      interface F {}
		//  The first /// will NOT be removed while the second one will be removed even though both node will not be emitted
		printer.forEachLeadingCommentToEmit(pos, printer.emitTripleSlashLeadingComment)
	}
}

func (printer *Printer) emitTripleSlashLeadingComment(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number) {
	if printer.isTripleSlashComment(commentPos, commentEnd) {
		printer.emitLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos)
	}
}

func (printer *Printer) emitNonTripleSlashLeadingComment(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number) {
	if !printer.isTripleSlashComment(commentPos, commentEnd) {
		printer.emitLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos)
	}
}

func (printer *Printer) shouldWriteComment(text string, pos number) bool {
	if printerOptions.onlyPrintJsDocStyle {
		return isJSDocLikeText(text, pos) || isPinnedComment(text, pos)
	}
	return true
}

func (printer *Printer) emitLeadingComment(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number) {
	if printer.currentSourceFile == nil || !printer.shouldWriteComment(printer.currentSourceFile.text, commentPos) {
		return
	}
	if !printer.hasWrittenComment {
		emitNewLineBeforeLeadingCommentOfPosition(printer.getCurrentLineMap(), printer.writer, rangePos, commentPos)
		printer.hasWrittenComment = true
	}

	// Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
	printer.emitPos(commentPos)
	writeCommentRange(printer.currentSourceFile.text, printer.getCurrentLineMap(), printer.writer, commentPos, commentEnd, printer.newLine)
	printer.emitPos(commentEnd)

	if hasTrailingNewLine {
		printer.writer.writeLine()
	} else if kind == ast.KindMultiLineCommentTrivia {
		printer.writer.writeSpace(" ")
	}
}

func (printer *Printer) emitLeadingCommentsOfPosition(pos number) {
	if printer.commentsDisabled || pos == -1 {
		return
	}

	printer.emitLeadingComments(pos, true /*isEmittedNode*/)
}

func (printer *Printer) emitTrailingComments(pos number) {
	printer.forEachTrailingCommentToEmit(pos, printer.emitTrailingComment)
}

func (printer *Printer) emitTrailingComment(commentPos number, commentEnd number, _kind SyntaxKind, hasTrailingNewLine bool) {
	if printer.currentSourceFile == nil || !printer.shouldWriteComment(printer.currentSourceFile.text, commentPos) {
		return
	}
	// trailing comments are emitted at space/*trailing comment1 */space/*trailing comment2*/
	if !printer.writer.isAtStartOfLine() {
		printer.writer.writeSpace(" ")
	}

	printer.emitPos(commentPos)
	writeCommentRange(printer.currentSourceFile.text, printer.getCurrentLineMap(), printer.writer, commentPos, commentEnd, printer.newLine)
	printer.emitPos(commentEnd)

	if hasTrailingNewLine {
		printer.writer.writeLine()
	}
}

func (printer *Printer) emitTrailingCommentsOfPosition(pos number, prefixSpace bool, forceNoNewline bool) {
	if printer.commentsDisabled {
		return
	}
	enterComment()
	printer.forEachTrailingCommentToEmit(pos, ifElse(prefixSpace, printer.emitTrailingComment, ifElse(forceNoNewline, printer.emitTrailingCommentOfPositionNoNewline, printer.emitTrailingCommentOfPosition)))
	exitComment()
}

func (printer *Printer) emitTrailingCommentOfPositionNoNewline(commentPos number, commentEnd number, kind SyntaxKind) {
	if printer.currentSourceFile == nil {
		return
	}
	// trailing comments of a position are emitted at /*trailing comment1 */space/*trailing comment*/space

	printer.emitPos(commentPos)
	writeCommentRange(printer.currentSourceFile.text, printer.getCurrentLineMap(), printer.writer, commentPos, commentEnd, printer.newLine)
	printer.emitPos(commentEnd)

	if kind == ast.KindSingleLineCommentTrivia {
		printer.writer.writeLine()
		// still write a newline for single-line comments, so closing tokens aren't written on the same line
	}
}

func (printer *Printer) emitTrailingCommentOfPosition(commentPos number, commentEnd number, _kind SyntaxKind, hasTrailingNewLine bool) {
	if printer.currentSourceFile == nil {
		return
	}
	// trailing comments of a position are emitted at /*trailing comment1 */space/*trailing comment*/space

	printer.emitPos(commentPos)
	writeCommentRange(printer.currentSourceFile.text, printer.getCurrentLineMap(), printer.writer, commentPos, commentEnd, printer.newLine)
	printer.emitPos(commentEnd)

	if hasTrailingNewLine {
		printer.writer.writeLine()
	} else {
		printer.writer.writeSpace(" ")
	}
}

func (printer *Printer) forEachLeadingCommentToEmit(pos number, cb func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number)) {
	// Emit the leading comments only if the container's pos doesn't match because the container should take care of emitting these comments
	if printer.currentSourceFile != nil && (printer.containerPos == -1 || pos != printer.containerPos) {
		if printer.hasDetachedComments(pos) {
			printer.forEachLeadingCommentWithoutDetachedComments(cb)
		} else {
			forEachLeadingCommentRange(printer.currentSourceFile.text, pos, cb, pos /*state*/)
		}
	}
}

func (printer *Printer) forEachTrailingCommentToEmit(end number, cb func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool)) {
	// Emit the trailing comments only if the container's end doesn't match because the container should take care of emitting these comments
	if printer.currentSourceFile != nil && (printer.containerEnd == -1 || (end != printer.containerEnd && end != printer.declarationListContainerEnd)) {
		forEachTrailingCommentRange(printer.currentSourceFile.text, end, cb)
	}
}

func (printer *Printer) hasDetachedComments(pos number) bool {
	return printer.detachedCommentsInfo != nil && last(printer.detachedCommentsInfo).nodePos == pos
}

func (printer *Printer) forEachLeadingCommentWithoutDetachedComments(cb func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number)) {
	if printer.currentSourceFile == nil {
		return
	}
	// get the leading comments from detachedPos
	pos := last(printer.detachedCommentsInfo).detachedCommentEndPos
	if printer.detachedCommentsInfo.length-1 != 0 {
		printer.detachedCommentsInfo.pop()
	} else {
		printer.detachedCommentsInfo = nil
	}

	forEachLeadingCommentRange(printer.currentSourceFile.text, pos, cb, pos /*state*/)
}

func (printer *Printer) emitDetachedCommentsAndUpdateCommentsInfo(range_ TextRange) {
	currentDetachedCommentInfo := printer.currentSourceFile && emitDetachedComments(printer.currentSourceFile.text, printer.getCurrentLineMap(), printer.writer, printer.emitComment, range_, printer.newLine, printer.commentsDisabled)
	if currentDetachedCommentInfo != nil {
		if printer.detachedCommentsInfo != nil {
			printer.detachedCommentsInfo.push(currentDetachedCommentInfo)
		} else {
			printer.detachedCommentsInfo = [] /* TODO(TS-TO-GO) inferred type ts.DetachedCommentInfo */ any{currentDetachedCommentInfo}
		}
	}
}

func (printer *Printer) emitComment(text string, lineMap []number, writer EmitTextWriter, commentPos number, commentEnd number, newLine string) {
	if printer.currentSourceFile == nil || !printer.shouldWriteComment(printer.currentSourceFile.text, commentPos) {
		return
	}
	printer.emitPos(commentPos)
	writeCommentRange(text, lineMap, printer.writer, commentPos, commentEnd, printer.newLine)
	printer.emitPos(commentEnd)
}

/**
 * Determine if the given comment is a triple-slash
 *
 * @return true if the comment is a triple-slash comment else false
 */

func (printer *Printer) isTripleSlashComment(commentPos number, commentEnd number) bool {
	return printer.currentSourceFile != nil && isRecognizedTripleSlashComment(printer.currentSourceFile.text, commentPos, commentEnd)
}

// Source Maps
func (printer *Printer) pipelineEmitWithSourceMaps(hint EmitHint, node *Node) {
	pipelinePhase := printer.getNextPipelinePhase(PipelinePhaseSourceMaps, hint, node)
	printer.emitSourceMapsBeforeNode(node)
	pipelinePhase(hint, node)
	printer.emitSourceMapsAfterNode(node)
}

func (printer *Printer) emitSourceMapsBeforeNode(node *Node) {
	emitFlags := getEmitFlags(node)
	sourceMapRange := getSourceMapRange(node)

	// Emit leading sourcemap
	source := sourceMapRange.source || printer.sourceMapSource
	if node.kind != ast.KindNotEmittedStatement && (emitFlags&EmitFlagsNoLeadingSourceMap) == 0 && sourceMapRange.pos >= 0 {
		printer.emitSourcePos(sourceMapRange.source || printer.sourceMapSource, printer.skipSourceTrivia(source, sourceMapRange.pos))
	}
	if emitFlags&EmitFlagsNoNestedSourceMaps != 0 {
		printer.sourceMapsDisabled = true
	}
}

func (printer *Printer) emitSourceMapsAfterNode(node *Node) {
	emitFlags := getEmitFlags(node)
	sourceMapRange := getSourceMapRange(node)

	// Emit trailing sourcemap
	if emitFlags&EmitFlagsNoNestedSourceMaps != 0 {
		printer.sourceMapsDisabled = false
	}
	if node.kind != ast.KindNotEmittedStatement && (emitFlags&EmitFlagsNoTrailingSourceMap) == 0 && sourceMapRange.end >= 0 {
		printer.emitSourcePos(sourceMapRange.source || printer.sourceMapSource, sourceMapRange.end)
	}
}

/**
 * Skips trivia such as comments and white-space that can be optionally overridden by the source-map source
 */

func (printer *Printer) skipSourceTrivia(source SourceMapSource, pos number) number {
	if source.skipTrivia != nil {
		return source.skipTrivia(pos)
	} else {
		return skipTrivia(source.text, pos)
	}
}

/**
 * Emits a mapping.
 *
 * If the position is synthetic (undefined or a negative value), no mapping will be
 * created.
 *
 * @param pos The position.
 */

func (printer *Printer) emitPos(pos number) {
	if printer.sourceMapsDisabled || positionIsSynthesized(pos) || printer.isJsonSourceMapSource(printer.sourceMapSource) {
		return
	}

	TODO_IDENTIFIER := getLineAndCharacterOfPosition(printer.sourceMapSource, pos)
	printer.sourceMapGenerator.addMapping(printer.writer.getLine(), printer.writer.getColumn(), printer.sourceMapSourceIndex, sourceLine, sourceCharacter, nil)
}

func (printer *Printer) emitSourcePos(source SourceMapSource, pos number) {
	if source != printer.sourceMapSource {
		savedSourceMapSource := printer.sourceMapSource
		savedSourceMapSourceIndex := printer.sourceMapSourceIndex
		printer.setSourceMapSource(source)
		printer.emitPos(pos)
		printer.resetSourceMapSource(savedSourceMapSource, savedSourceMapSourceIndex)
	} else {
		printer.emitPos(pos)
	}
}

/**
 * Emits a token of a node with possible leading and trailing source maps.
 *
 * @param node The node containing the token.
 * @param token The token to emit.
 * @param tokenStartPos The start pos of the token.
 * @param emitCallback The callback used to emit the token.
 */

func (printer *Printer) emitTokenWithSourceMap(node *Node, token SyntaxKind, writer func(s string), tokenPos number, emitCallback func(token SyntaxKind, writer func(s string), tokenStartPos number) number) number {
	if printer.sourceMapsDisabled || node != nil && isInJsonFile(node) {
		return emitCallback(token, printer.writer, tokenPos)
	}

	emitNode := node && node.emitNode
	emitFlags := emitNode && emitNode.flags || EmitFlagsNone
	range_ := emitNode && emitNode.tokenSourceMapRanges && emitNode.tokenSourceMapRanges[token]
	source := range_ && range_.source || printer.sourceMapSource

	tokenPos = printer.skipSourceTrivia(source, ifElse(range_ != nil, range_.pos, tokenPos))
	if (emitFlags&EmitFlagsNoTokenLeadingSourceMaps) == 0 && tokenPos >= 0 {
		printer.emitSourcePos(source, tokenPos)
	}

	tokenPos = emitCallback(token, printer.writer, tokenPos)

	if range_ != nil {
		tokenPos = range_.end
	}
	if (emitFlags&EmitFlagsNoTokenTrailingSourceMaps) == 0 && tokenPos >= 0 {
		printer.emitSourcePos(source, tokenPos)
	}

	return tokenPos
}

func (printer *Printer) setSourceMapSource(source SourceMapSource) {
	if printer.sourceMapsDisabled {
		return
	}

	printer.sourceMapSource = source

	if source == printer.mostRecentlyAddedSourceMapSource {
		// Fast path for when the new source map is the most recently added, in which case
		// we use its captured index without going through the source map generator.
		printer.sourceMapSourceIndex = printer.mostRecentlyAddedSourceMapSourceIndex
		return
	}

	if printer.isJsonSourceMapSource(source) {
		return
	}

	printer.sourceMapSourceIndex = printer.sourceMapGenerator.addSource(source.fileName)
	if printerOptions.inlineSources {
		printer.sourceMapGenerator.setSourceContent(printer.sourceMapSourceIndex, source.text)
	}

	printer.mostRecentlyAddedSourceMapSource = source
	printer.mostRecentlyAddedSourceMapSourceIndex = printer.sourceMapSourceIndex
}

func (printer *Printer) resetSourceMapSource(source SourceMapSource, sourceIndex number) {
	printer.sourceMapSource = source
	printer.sourceMapSourceIndex = sourceIndex
}

func (printer *Printer) isJsonSourceMapSource(sourceFile SourceMapSource) bool {
	return fileExtensionIs(sourceFile.fileName, ExtensionJson)
}

func createBracketsMap() [][]string {
	var brackets [][]string = []never{}
	brackets[ListFormatBraces] = []string{"{", "}"}
	brackets[ListFormatParenthesis] = []string{"(", ")"}
	brackets[ListFormatAngleBrackets] = []string{"<", ">"}
	brackets[ListFormatSquareBrackets] = []string{"[", "]"}
	return brackets
}

func getOpeningBracket(format ListFormat) string {
	return brackets[format&ListFormatBracketsMask][0]
}

func getClosingBracket(format ListFormat) string {
	return brackets[format&ListFormatBracketsMask][1]
}

// Flags enum to track count of temp variables and a few dedicated names
type TempFlags int32

const (
	TempFlagsAuto      TempFlags = 0x00000000
	TempFlagsCountMask TempFlags = 0x0FFFFFFF
	TempFlags_i        TempFlags = 0x10000000
)

type OrdinalParentheizerRuleSelector [T * Node]struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: interface OrdinalParentheizerRuleSelector<T extends Node> { select(index: number): ((node: T) => T) | undefined; } */
}

type ParenthesizerRule [T * Node]func(node T) T

type ParenthesizerRuleOrSelector [T * Node]Union[OrdinalParentheizerRuleSelector[T], ParenthesizerRule[T]]

type EmitFunction func(node T, parenthesizerRule ParenthesizerRule[T])
type EmitListItemFunction [T * Node]func(node *Node, emit EmitFunction, parenthesizerRule *ParenthesizerRuleOrSelector[T], index number)

func emitListItemNoParenthesizer(node *Node, emit EmitFunction, _parenthesizerRule *ParenthesizerRuleOrSelector[*Node], _index number) {
	emit(node)
}

func emitListItemWithParenthesizerRuleSelector(node *Node, emit EmitFunction, parenthesizerRuleSelector *OrdinalParentheizerRuleSelector[*Node], index number) {
	emit(node, parenthesizerRuleSelector.select_(index))
}

func emitListItemWithParenthesizerRule(node *Node, emit EmitFunction, parenthesizerRule *ParenthesizerRule[*Node], _index number) {
	emit(node, parenthesizerRule)
}

func getEmitListItem(emit EmitFunction, parenthesizerRule *ParenthesizerRuleOrSelector[T]) EmitListItemFunction[T] {
	switch {
	case emit.length == 1:
		return emitListItemNoParenthesizer.(EmitListItemFunction[T])
	case /* TODO(TS-TO-GO) Expression TypeOfExpression: typeof parenthesizerRule */ TODO == "object":
		return emitListItemWithParenthesizerRuleSelector.(EmitListItemFunction[T])
	default:
		return emitListItemWithParenthesizerRule.(EmitListItemFunction[T])
	}
}
