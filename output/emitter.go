// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

var brackets = createBracketsMap()

/** @internal */

func isBuildInfoFile(file string) bool {
	return fileExtensionIs(file, ExtensionTsBuildInfo)
}

/**
 * Iterates over the source files that are expected to have an emit output.
 *
 * @param host An EmitHost.
 * @param action The action to execute.
 * @param sourceFilesOrTargetSourceFile
 *   If an array, the full list of source files to emit.
 *   Else, calls `getSourceFilesToEmit` with the (optional) target source file to determine the list of source files to emit.
 *
 * @internal
 */

func forEachEmittedFile(host EmitHost, action func(emitFileNames EmitFileNames, sourceFileOrBundle /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | Bundle | undefined */ any) T, sourceFilesOrTargetSourceFile /* TODO(TS-TO-GO) TypeNode UnionType: readonly SourceFile[] | SourceFile */ any, forceDtsEmit bool /*  = false */, onlyBuildInfo bool, includeBuildInfo bool) *T {
	var sourceFiles [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
	if isArray(sourceFilesOrTargetSourceFile) {
		sourceFiles = sourceFilesOrTargetSourceFile
	} else {
		sourceFiles = getSourceFilesToEmit(host, sourceFilesOrTargetSourceFile, forceDtsEmit)
	}
	options := host.getCompilerOptions()
	if !onlyBuildInfo {
		if options.outFile {
			if sourceFiles.length {
				bundle := factory.createBundle(sourceFiles)
				result := action(getOutputPathsFor(bundle, host, forceDtsEmit), bundle)
				if result {
					return result
				}
			}
		} else {
			for _, sourceFile := range sourceFiles {
				result := action(getOutputPathsFor(sourceFile, host, forceDtsEmit), sourceFile)
				if result {
					return result
				}
			}
		}
	}
	if includeBuildInfo {
		buildInfoPath := getTsBuildInfoEmitOutputFilePath(options)
		if buildInfoPath {
			return action(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"buildInfoPath": buildInfoPath,
			}, /*sourceFileOrBundle*/ nil)
		}
	}
}

func getTsBuildInfoEmitOutputFilePath(options CompilerOptions) *string {
	configFile := options.configFilePath
	if !canEmitTsBuildInfo(options) {
		return nil
	}
	if options.tsBuildInfoFile {
		return options.tsBuildInfoFile
	}
	outPath := options.outFile
	var buildInfoExtensionLess string
	if outPath {
		buildInfoExtensionLess = removeFileExtension(outPath)
	} else {
		if !configFile {
			return nil
		}
		configFileExtensionLess := removeFileExtension(configFile)
		switch {
		case options.outDir:
			if options.rootDir {
				buildInfoExtensionLess = resolvePath(options.outDir, getRelativePathFromDirectory(options.rootDir, configFileExtensionLess /*ignoreCase*/, true))
			} else {
				buildInfoExtensionLess = combinePaths(options.outDir, getBaseFileName(configFileExtensionLess))
			}
		default:
			buildInfoExtensionLess = configFileExtensionLess
		}
	}
	return buildInfoExtensionLess + ExtensionTsBuildInfo
}

func canEmitTsBuildInfo(options CompilerOptions) bool {
	return isIncrementalCompilation(options) || !!options.tscBuild
}

func getOutputPathsForBundle(options CompilerOptions, forceDtsPaths bool) EmitFileNames {
	outPath := options.outFile
	var jsFilePath *string
	if options.emitDeclarationOnly {
		jsFilePath = nil
	} else {
		jsFilePath = outPath
	}
	sourceMapFilePath := jsFilePath && getSourceMapFilePath(jsFilePath, options)
	var declarationFilePath *string
	if forceDtsPaths || getEmitDeclarations(options) {
		declarationFilePath = removeFileExtension(outPath) + ExtensionDts
	} else {
		declarationFilePath = nil
	}
	var declarationMapPath *string
	if declarationFilePath && getAreDeclarationMapsEnabled(options) {
		declarationMapPath = declarationFilePath + ".map"
	} else {
		declarationMapPath = nil
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"jsFilePath":          jsFilePath,
		"sourceMapFilePath":   sourceMapFilePath,
		"declarationFilePath": declarationFilePath,
		"declarationMapPath":  declarationMapPath,
	}
}

/** @internal */

func getOutputPathsFor(sourceFile /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | Bundle */ any, host EmitHost, forceDtsPaths bool) EmitFileNames {
	options := host.getCompilerOptions()
	if sourceFile.kind == SyntaxKindBundle {
		return getOutputPathsForBundle(options, forceDtsPaths)
	} else {
		ownOutputFilePath := getOwnEmitOutputFilePath(sourceFile.fileName, host, getOutputExtension(sourceFile.fileName, options))
		isJsonFile := isJsonSourceFile(sourceFile)
		// If json file emits to the same location skip writing it, if emitDeclarationOnly skip writing it
		isJsonEmittedToSameLocation := isJsonFile && comparePaths(sourceFile.fileName, ownOutputFilePath, host.getCurrentDirectory(), !host.useCaseSensitiveFileNames()) == ComparisonEqualTo
		var jsFilePath *string
		if options.emitDeclarationOnly || isJsonEmittedToSameLocation {
			jsFilePath = nil
		} else {
			jsFilePath = ownOutputFilePath
		}
		var sourceMapFilePath *string
		if !jsFilePath || isJsonSourceFile(sourceFile) {
			sourceMapFilePath = nil
		} else {
			sourceMapFilePath = getSourceMapFilePath(jsFilePath, options)
		}
		var declarationFilePath *string
		if forceDtsPaths || (getEmitDeclarations(options) && !isJsonFile) {
			declarationFilePath = getDeclarationEmitOutputFilePath(sourceFile.fileName, host)
		} else {
			declarationFilePath = nil
		}
		var declarationMapPath *string
		if declarationFilePath && getAreDeclarationMapsEnabled(options) {
			declarationMapPath = declarationFilePath + ".map"
		} else {
			declarationMapPath = nil
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"jsFilePath":          jsFilePath,
			"sourceMapFilePath":   sourceMapFilePath,
			"declarationFilePath": declarationFilePath,
			"declarationMapPath":  declarationMapPath,
		}
	}
}

func getSourceMapFilePath(jsFilePath string, options CompilerOptions) *string {
	if options.sourceMap && !options.inlineSourceMap {
		return jsFilePath + ".map"
	} else {
		return nil
	}
}

/** @internal */

func getOutputExtension(fileName string, options Pick[CompilerOptions /* TODO(TS-TO-GO) TypeNode LiteralType: "jsx" */, any]) Extension {
	switch {
	case fileExtensionIs(fileName, ExtensionJson):
		return ExtensionJson
	case options.jsx == JsxEmitPreserve && fileExtensionIsOneOf(fileName, [] /* TODO(TS-TO-GO) inferred type ts.Extension */ any{ExtensionJsx, ExtensionTsx}):
		return ExtensionJsx
	case fileExtensionIsOneOf(fileName, [] /* TODO(TS-TO-GO) inferred type ts.Extension */ any{ExtensionMts, ExtensionMjs}):
		return ExtensionMjs
	case fileExtensionIsOneOf(fileName, [] /* TODO(TS-TO-GO) inferred type ts.Extension */ any{ExtensionCts, ExtensionCjs}):
		return ExtensionCjs
	default:
		return ExtensionJs
	}
}

func getOutputPathWithoutChangingExt(inputFileName string, ignoreCase bool, outputDir *string, getCommonSourceDirectory func() string) string {
	if outputDir {
		return resolvePath(outputDir, getRelativePathFromDirectory(getCommonSourceDirectory(), inputFileName, ignoreCase))
	} else {
		return inputFileName
	}
}

/** @internal */

func getOutputDeclarationFileName(inputFileName string, configFile ParsedCommandLine, ignoreCase bool, getCommonSourceDirectory /* TODO(TS-TO-GO) inferred type () => string */ any /*  = (): string => getCommonSourceDirectoryOfConfig(configFile, ignoreCase) */) string {
	return getOutputDeclarationFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory)
}

/** @internal */

func getOutputDeclarationFileNameWorker(inputFileName string, options CompilerOptions, ignoreCase bool, getCommonSourceDirectory func() string) string {
	return changeExtension(getOutputPathWithoutChangingExt(inputFileName, ignoreCase, options.declarationDir || options.outDir, getCommonSourceDirectory), getDeclarationEmitExtensionForPath(inputFileName))
}

func getOutputJSFileName(inputFileName string, configFile ParsedCommandLine, ignoreCase bool, getCommonSourceDirectory /* TODO(TS-TO-GO) inferred type () => string */ any /*  = () => getCommonSourceDirectoryOfConfig(configFile, ignoreCase) */) *string {
	if configFile.options.emitDeclarationOnly {
		return nil
	}
	isJsonFile := fileExtensionIs(inputFileName, ExtensionJson)
	outputFileName := getOutputJSFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory)
	if !isJsonFile || comparePaths(inputFileName, outputFileName, Debug.checkDefined(configFile.options.configFilePath), ignoreCase) != ComparisonEqualTo {
		return outputFileName
	} else {
		return nil
	}
}

/** @internal */

func getOutputJSFileNameWorker(inputFileName string, options CompilerOptions, ignoreCase bool, getCommonSourceDirectory func() string) string {
	return changeExtension(getOutputPathWithoutChangingExt(inputFileName, ignoreCase, options.outDir, getCommonSourceDirectory), getOutputExtension(inputFileName, options))
}

func createAddOutput() /* TODO(TS-TO-GO) inferred type { addOutput: (path: string | undefined) => void; getOutputs: () => readonly string[]; } */ any {
	var outputs *[]string
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"addOutput":  addOutput,
		"getOutputs": getOutputs,
	}
	addOutput := func(path *string) {
		if path {
			(outputs || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: outputs = [] */ TODO)).push(path)
		}
	}

	getOutputs := func() []string {
		return outputs || emptyArray
	}

}

func getSingleOutputFileNames(configFile ParsedCommandLine, addOutput /* TODO(TS-TO-GO) TypeNode IndexedAccessType: ReturnType<typeof createAddOutput>["addOutput"] */ any) {
	TODO_IDENTIFIER := getOutputPathsForBundle(configFile.options /*forceDtsPaths*/, false)
	addOutput(jsFilePath)
	addOutput(sourceMapFilePath)
	addOutput(declarationFilePath)
	addOutput(declarationMapPath)
}

func getOwnOutputFileNames(configFile ParsedCommandLine, inputFileName string, ignoreCase bool, addOutput /* TODO(TS-TO-GO) TypeNode IndexedAccessType: ReturnType<typeof createAddOutput>["addOutput"] */ any, getCommonSourceDirectory func() string) {
	if isDeclarationFileName(inputFileName) {
		return
	}
	js := getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
	addOutput(js)
	if fileExtensionIs(inputFileName, ExtensionJson) {
		return
	}
	if js && configFile.options.sourceMap {
		addOutput(__TEMPLATE__(js, ".map"))
	}
	if getEmitDeclarations(configFile.options) {
		dts := getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
		addOutput(dts)
		if configFile.options.declarationMap {
			addOutput(__TEMPLATE__(dts, ".map"))
		}
	}
}

/** @internal */

func getCommonSourceDirectory(options CompilerOptions, emittedFiles func() []string, currentDirectory string, getCanonicalFileName GetCanonicalFileName, checkSourceFilesBelongToPath func(commonSourceDirectory string)) string {
	var commonSourceDirectory TODO
	if options.rootDir {
		// If a rootDir is specified use it as the commonSourceDirectory
		commonSourceDirectory = getNormalizedAbsolutePath(options.rootDir, currentDirectory)
		checkSourceFilesBelongToPath(options.rootDir)
	} else if options.composite && options.configFilePath {
		// Project compilations never infer their root from the input source paths
		commonSourceDirectory = getDirectoryPath(normalizeSlashes(options.configFilePath))
		checkSourceFilesBelongToPath(commonSourceDirectory)
	} else {
		commonSourceDirectory = computeCommonSourceDirectoryOfFilenames(emittedFiles(), currentDirectory, getCanonicalFileName)
	}

	if commonSourceDirectory && commonSourceDirectory[commonSourceDirectory.length-1] != directorySeparator {
		// Make sure directory path ends with directory separator so this string can directly
		// used to replace with "" to get the relative path of the source file and the relative path doesn't
		// start with / making it rooted path
		commonSourceDirectory += directorySeparator
	}
	return commonSourceDirectory
}

/** @internal */

func getCommonSourceDirectoryOfConfig(TODO_IDENTIFIER ParsedCommandLine, ignoreCase bool) string {
	return getCommonSourceDirectory(options, func() []string {
		return filter(fileNames, func(file string) bool {
			return !(options.noEmitForJsFiles && fileExtensionIsOneOf(file, supportedJSExtensionsFlat)) && !isDeclarationFileName(file)
		})
	}, getDirectoryPath(normalizeSlashes(Debug.checkDefined(options.configFilePath))), createGetCanonicalFileName(!ignoreCase))
}

/** @internal */

func getAllProjectOutputs(configFile ParsedCommandLine, ignoreCase bool) []string {
	TODO_IDENTIFIER := createAddOutput()
	if configFile.options.outFile {
		getSingleOutputFileNames(configFile, addOutput)
	} else {
		getCommonSourceDirectory := memoize(func() string {
			return getCommonSourceDirectoryOfConfig(configFile, ignoreCase)
		})
		for _, inputFileName := range configFile.fileNames {
			getOwnOutputFileNames(configFile, inputFileName, ignoreCase, addOutput, getCommonSourceDirectory)
		}
	}
	addOutput(getTsBuildInfoEmitOutputFilePath(configFile.options))
	return getOutputs()
}

func getOutputFileNames(commandLine ParsedCommandLine, inputFileName string, ignoreCase bool) []string {
	inputFileName = normalizePath(inputFileName)
	Debug.assert(contains(commandLine.fileNames, inputFileName), `Expected fileName to be present in command line`)
	TODO_IDENTIFIER := createAddOutput()
	if commandLine.options.outFile {
		getSingleOutputFileNames(commandLine, addOutput)
	} else {
		getOwnOutputFileNames(commandLine, inputFileName, ignoreCase, addOutput)
	}
	return getOutputs()
}

/** @internal */

func getFirstProjectOutput(configFile ParsedCommandLine, ignoreCase bool) string {
	if configFile.options.outFile {
		TODO_IDENTIFIER := getOutputPathsForBundle(configFile.options /*forceDtsPaths*/, false)
		return Debug.checkDefined(jsFilePath || declarationFilePath, __TEMPLATE__("project ", configFile.options.configFilePath, " expected to have at least one output"))
	}

	getCommonSourceDirectory := memoize(func() string {
		return getCommonSourceDirectoryOfConfig(configFile, ignoreCase)
	})
	for _, inputFileName := range configFile.fileNames {
		if isDeclarationFileName(inputFileName) {
			continue
		}
		jsFilePath := getOutputJSFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
		if jsFilePath {
			return jsFilePath
		}
		if fileExtensionIs(inputFileName, ExtensionJson) {
			continue
		}
		if getEmitDeclarations(configFile.options) {
			return getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory)
		}
	}
	buildInfoPath := getTsBuildInfoEmitOutputFilePath(configFile.options)
	if buildInfoPath {
		return buildInfoPath
	}
	return Debug.fail(__TEMPLATE__("project ", configFile.options.configFilePath, " expected to have at least one output"))
}

/** @internal */

func emitResolverSkipsTypeChecking(emitOnly /* TODO(TS-TO-GO) TypeNode UnionType: boolean | EmitOnly | undefined */ any, forceDtsEmit *bool) bool {
	return !!forceDtsEmit && !!emitOnly
}

/** @internal */
// targetSourceFile is when users only want one file in entire project to be emitted. This is used in compileOnSave feature

func emitFiles(resolver EmitResolver, host EmitHost, targetSourceFile *SourceFile, TODO_IDENTIFIER EmitTransformers, emitOnly /* TODO(TS-TO-GO) TypeNode UnionType: boolean | EmitOnly | undefined */ any, onlyBuildInfo bool, forceDtsEmit bool, skipBuildInfo bool) EmitResult {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	compilerOptions := host.getCompilerOptions()
	var sourceMapDataList *[]SourceMapEmitResult
	if compilerOptions.sourceMap || compilerOptions.inlineSourceMap || getAreDeclarationMapsEnabled(compilerOptions) {
		sourceMapDataList = []never{}
	} else {
		sourceMapDataList = nil
	}
	var emittedFilesList *[]string
	if compilerOptions.listEmittedFiles {
		emittedFilesList = []never{}
	} else {
		emittedFilesList = nil
	}
	emitterDiagnostics := createDiagnosticCollection()
	newLine := getNewLineCharacter(compilerOptions)
	writer := createTextWriter(newLine)
	TODO_IDENTIFIER := performance.createTimer("printTime", "beforePrint", "afterPrint")
	emitSkipped := false
	/* eslint-enable no-var */

	// Emit each output file
	enter()
	forEachEmittedFile(host, emitSourceFileOrBundle, getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit), forceDtsEmit, onlyBuildInfo, !targetSourceFile && !skipBuildInfo)
	exit()

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"emitSkipped":  emitSkipped,
		"diagnostics":  emitterDiagnostics.getDiagnostics(),
		"emittedFiles": emittedFilesList,
		"sourceMaps":   sourceMapDataList,
	}

	emitSourceFileOrBundle := func(TODO_IDENTIFIER EmitFileNames, sourceFileOrBundle /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | Bundle | undefined */ any) {
		tracing. /* ? */ push(tracing.Phase.Emit, "emitJsFileOrBundle", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"jsFilePath": jsFilePath,
		})
		emitJsFileOrBundle(sourceFileOrBundle, jsFilePath, sourceMapFilePath)
		tracing. /* ? */ pop()

		tracing. /* ? */ push(tracing.Phase.Emit, "emitDeclarationFileOrBundle", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"declarationFilePath": declarationFilePath,
		})
		emitDeclarationFileOrBundle(sourceFileOrBundle, declarationFilePath, declarationMapPath)
		tracing. /* ? */ pop()

		tracing. /* ? */ push(tracing.Phase.Emit, "emitBuildInfo", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"buildInfoPath": buildInfoPath,
		})
		emitBuildInfo(buildInfoPath)
		tracing. /* ? */ pop()
	}

	emitBuildInfo := func(buildInfoPath *string) {
		// Write build information if applicable
		if !buildInfoPath || targetSourceFile {
			return
		}
		if host.isEmitBlocked(buildInfoPath) {
			emitSkipped = true
			return
		}
		buildInfo := host.getBuildInfo() || map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"version": version,
		}
		// Pass buildinfo as additional data to avoid having to reparse
		writeFile(host, emitterDiagnostics, buildInfoPath, getBuildInfoText(buildInfo) /*writeByteOrderMark*/, false /*sourceFiles*/, nil, map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"buildInfo": buildInfo,
		})
		emittedFilesList. /* ? */ push(buildInfoPath)
	}

	emitJsFileOrBundle := func(sourceFileOrBundle /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | Bundle | undefined */ any, jsFilePath *string, sourceMapFilePath *string) {
		if !sourceFileOrBundle || emitOnly || !jsFilePath {
			return
		}

		// Make sure not to write js file and source map file if any of them cannot be written
		if host.isEmitBlocked(jsFilePath) || compilerOptions.noEmit {
			emitSkipped = true
			return
		}

		(ifelse(isSourceFile(sourceFileOrBundle), [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any{sourceFileOrBundle}, filter(sourceFileOrBundle.sourceFiles, isSourceFileNotJson))).forEach(func(sourceFile /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any) {
			if compilerOptions.noCheck || !canIncludeBindAndCheckDiagnostics(sourceFile, compilerOptions) {
				markLinkedReferences(sourceFile)
			}
		})

		// Transform the source files
		transform := transformNodes(resolver, host, factory, compilerOptions, [] /* TODO(TS-TO-GO) inferred type ts.SourceFile | ts.Bundle */ any{sourceFileOrBundle}, scriptTransformers /*allowDtsFiles*/, false)

		var printerOptions PrinterOptions = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"removeComments":      compilerOptions.removeComments,
			"newLine":             compilerOptions.newLine,
			"noEmitHelpers":       compilerOptions.noEmitHelpers,
			"module":              getEmitModuleKind(compilerOptions),
			"moduleResolution":    getEmitModuleResolutionKind(compilerOptions),
			"target":              getEmitScriptTarget(compilerOptions),
			"sourceMap":           compilerOptions.sourceMap,
			"inlineSourceMap":     compilerOptions.inlineSourceMap,
			"inlineSources":       compilerOptions.inlineSources,
			"extendedDiagnostics": compilerOptions.extendedDiagnostics,
		}

		// Create a printer to print the nodes
		printer := createPrinter(printerOptions, map[any]any{ /* TODO(TS-TO-GO): was object literal */
			// resolver hooks
			"hasGlobalName": resolver.hasGlobalName,
			// transform hooks
			"onEmitNode":                transform.emitNodeWithNotification,
			"isEmitNotificationEnabled": transform.isEmitNotificationEnabled,
			"substituteNode":            transform.substituteNode,
		})

		Debug.assert(transform.transformed.length == 1, "Should only see one output from the transform")
		printSourceFileOrBundle(jsFilePath, sourceMapFilePath, transform, printer, compilerOptions)

		// Clean up emit nodes on parse tree
		transform.dispose()

		if emittedFilesList {
			emittedFilesList.push(jsFilePath)
			if sourceMapFilePath {
				emittedFilesList.push(sourceMapFilePath)
			}
		}
	}

	emitDeclarationFileOrBundle := func(sourceFileOrBundle /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | Bundle | undefined */ any, declarationFilePath *string, declarationMapPath *string) {
		if !sourceFileOrBundle || emitOnly == EmitOnlyJs {
			return
		}
		if !declarationFilePath {
			if emitOnly || compilerOptions.emitDeclarationOnly {
				emitSkipped = true
			}
			return
		}
		var sourceFiles [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if isSourceFile(sourceFileOrBundle) {
			sourceFiles = [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any{sourceFileOrBundle}
		} else {
			sourceFiles = sourceFileOrBundle.sourceFiles
		}
		var filesForEmit [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if forceDtsEmit {
			filesForEmit = sourceFiles
		} else {
			filesForEmit = filter(sourceFiles, isSourceFileNotJson)
		}
		// Setup and perform the transformation to retrieve declarations from the input files
		var inputListOrBundle [] /* TODO(TS-TO-GO) inferred type ts.SourceFile[] | ts.Bundle */ any
		if compilerOptions.outFile {
			inputListOrBundle = [] /* TODO(TS-TO-GO) inferred type ts.Bundle */ any{factory.createBundle(filesForEmit)}
		} else {
			inputListOrBundle = filesForEmit
		}
		// Checker wont collect the linked aliases since thats only done when declaration is enabled and checking is performed.
		// Do that here when emitting only dts files
		filesForEmit.forEach(func(sourceFile /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any) {
			if (emitOnly && !getEmitDeclarations(compilerOptions)) || compilerOptions.noCheck || emitResolverSkipsTypeChecking(emitOnly, forceDtsEmit) || !canIncludeBindAndCheckDiagnostics(sourceFile, compilerOptions) {
				collectLinkedAliases(sourceFile)
			}
		})

		declarationTransform := transformNodes(resolver, host, factory, compilerOptions, inputListOrBundle, declarationTransformers /*allowDtsFiles*/, false)
		if length(declarationTransform.diagnostics) {
			for _, diagnostic := range declarationTransform.diagnostics {
				emitterDiagnostics.add(diagnostic)
			}
		}

		declBlocked := (!!declarationTransform.diagnostics && !!declarationTransform.diagnostics.length) || !!host.isEmitBlocked(declarationFilePath) || !!compilerOptions.noEmit
		emitSkipped = emitSkipped || declBlocked
		if !declBlocked || forceDtsEmit {
			Debug.assert(declarationTransform.transformed.length == 1, "Should only see one output from the decl transform")
			var printerOptions PrinterOptions = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"removeComments":              compilerOptions.removeComments,
				"newLine":                     compilerOptions.newLine,
				"noEmitHelpers":               true,
				"module":                      compilerOptions.module,
				"moduleResolution":            compilerOptions.moduleResolution,
				"target":                      compilerOptions.target,
				"sourceMap":                   emitOnly != EmitOnlyBuilderSignature && compilerOptions.declarationMap,
				"inlineSourceMap":             compilerOptions.inlineSourceMap,
				"extendedDiagnostics":         compilerOptions.extendedDiagnostics,
				"onlyPrintJsDocStyle":         true,
				"omitBraceSourceMapPositions": true,
			}

			declarationPrinter := createPrinter(printerOptions, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				// resolver hooks
				"hasGlobalName": resolver.hasGlobalName,
				// transform hooks
				"onEmitNode":                declarationTransform.emitNodeWithNotification,
				"isEmitNotificationEnabled": declarationTransform.isEmitNotificationEnabled,
				"substituteNode":            declarationTransform.substituteNode,
			})
			dtsWritten := printSourceFileOrBundle(declarationFilePath, declarationMapPath, declarationTransform, declarationPrinter, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"sourceMap":           printerOptions.sourceMap,
				"sourceRoot":          compilerOptions.sourceRoot,
				"mapRoot":             compilerOptions.mapRoot,
				"extendedDiagnostics": compilerOptions.extendedDiagnostics,
			})
			if emittedFilesList {
				if dtsWritten {
					emittedFilesList.push(declarationFilePath)
				}
				if declarationMapPath {
					emittedFilesList.push(declarationMapPath)
				}
			}
		}
		declarationTransform.dispose()
	}

	collectLinkedAliases := func(node Node) {
		if isExportAssignment(node) {
			if node.expression.kind == SyntaxKindIdentifier {
				resolver.collectLinkedAliases(node.expression.(Identifier) /*setVisibility*/, true)
			}
			return
		} else if isExportSpecifier(node) {
			resolver.collectLinkedAliases(node.propertyName || node.name /*setVisibility*/, true)
			return
		}
		forEachChild(node, collectLinkedAliases)
	}

	markLinkedReferences := func(file SourceFile) {
		if ts.isSourceFileJS(file) {
			return
			// JS files don't use reference calculations as they don't do import ellision, no need to calculate it
		}
		// JS files don't use reference calculations as they don't do import ellision, no need to calculate it
		ts.forEachChildRecursively(file, func(n /* TODO(TS-TO-GO) inferred type ts.Node */ any) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
			if isImportEqualsDeclaration(n) && !(ts.getSyntacticModifierFlags(n) & ts.ModifierFlags.Export) {
				return "skip"
				// These are deferred and marked in a chain when referenced
			}
			// These are deferred and marked in a chain when referenced
			if ts.isImportDeclaration(n) {
				return "skip"
				// likewise, these are ultimately what get marked by calls on other nodes - we want to skip them
			}
			// likewise, these are ultimately what get marked by calls on other nodes - we want to skip them
			resolver.markLinkedReferences(n)
		})
	}

	printSourceFileOrBundle := func(jsFilePath string, sourceMapFilePath *string, transform TransformationResult[ /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | Bundle */ any], printer Printer, mapOptions SourceMapOptions) bool {
		sourceFileOrBundle := transform.transformed[0]
		var bundle * /* TODO(TS-TO-GO) inferred type ts.Bundle */ any
		if sourceFileOrBundle.kind == SyntaxKindBundle {
			bundle = sourceFileOrBundle
		} else {
			bundle = nil
		}
		var sourceFile * /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if sourceFileOrBundle.kind == SyntaxKindSourceFile {
			sourceFile = sourceFileOrBundle
		} else {
			sourceFile = nil
		}
		var sourceFiles [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
		if bundle {
			sourceFiles = bundle.sourceFiles
		} else {
			sourceFiles = [] /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any{sourceFile}
		}

		var sourceMapGenerator *SourceMapGenerator
		if shouldEmitSourceMaps(mapOptions, sourceFileOrBundle) {
			sourceMapGenerator = createSourceMapGenerator(host, getBaseFileName(normalizeSlashes(jsFilePath)), getSourceRoot(mapOptions), getSourceMapDirectory(mapOptions, jsFilePath, sourceFile), mapOptions)
		}

		if bundle {
			printer.writeBundle(bundle, writer, sourceMapGenerator)
		} else {
			printer.writeFile(sourceFile, writer, sourceMapGenerator)
		}

		var sourceMapUrlPos TODO
		if sourceMapGenerator {
			if sourceMapDataList {
				sourceMapDataList.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"inputSourceFileNames": sourceMapGenerator.getSources(),
					"sourceMap":            sourceMapGenerator.toJSON(),
				})
			}

			sourceMappingURL := getSourceMappingURL(mapOptions, sourceMapGenerator, jsFilePath, sourceMapFilePath, sourceFile)

			if sourceMappingURL {
				if !writer.isAtStartOfLine() {
					writer.rawWrite(newLine)
				}
				sourceMapUrlPos = writer.getTextPos()
				writer.writeComment(__TEMPLATE__("//# ", "sourceMappingURL", "=", sourceMappingURL))
				// Tools can sometimes see this line as a source mapping url comment
			}

			// Write the source map
			if sourceMapFilePath {
				sourceMap := sourceMapGenerator.toString()
				writeFile(host, emitterDiagnostics, sourceMapFilePath, sourceMap /*writeByteOrderMark*/, false, sourceFiles)
			}
		} else {
			writer.writeLine()
		}

		// Write the output file
		text := writer.getText()
		var data WriteFileCallbackData = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"sourceMapUrlPos": sourceMapUrlPos,
			"diagnostics":     transform.diagnostics,
		}
		writeFile(host, emitterDiagnostics, jsFilePath, text, !!compilerOptions.emitBOM, sourceFiles, data)

		// Reset state
		writer.clear()
		return !data.skippedDtsWrite
	}

	type SourceMapOptions struct {
		sourceMap           bool
		inlineSourceMap     bool
		inlineSources       bool
		sourceRoot          string
		mapRoot             string
		extendedDiagnostics bool
	}

	shouldEmitSourceMaps := func(mapOptions SourceMapOptions, sourceFileOrBundle /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | Bundle */ any) *bool {
		return (mapOptions.sourceMap || mapOptions.inlineSourceMap) && (sourceFileOrBundle.kind != SyntaxKindSourceFile || !fileExtensionIs(sourceFileOrBundle.fileName, ExtensionJson))
	}

	getSourceRoot := func(mapOptions SourceMapOptions) string {
		// Normalize source root and make sure it has trailing "/" so that it can be used to combine paths with the
		// relative paths of the sources list in the sourcemap
		sourceRoot := normalizeSlashes(mapOptions.sourceRoot || "")
		if sourceRoot {
			return ensureTrailingDirectorySeparator(sourceRoot)
		} else {
			return sourceRoot
		}
	}

	getSourceMapDirectory := func(mapOptions SourceMapOptions, filePath string, sourceFile *SourceFile) string {
		if mapOptions.sourceRoot {
			return host.getCommonSourceDirectory()
		}
		if mapOptions.mapRoot {
			sourceMapDir := normalizeSlashes(mapOptions.mapRoot)
			if sourceFile {
				// For modules or multiple emit files the mapRoot will have directory structure like the sources
				// So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
				sourceMapDir = getDirectoryPath(getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir))
			}
			if getRootLength(sourceMapDir) == 0 {
				// The relative paths are relative to the common directory
				sourceMapDir = combinePaths(host.getCommonSourceDirectory(), sourceMapDir)
			}
			return sourceMapDir
		}
		return getDirectoryPath(normalizePath(filePath))
	}

	getSourceMappingURL := func(mapOptions SourceMapOptions, sourceMapGenerator SourceMapGenerator, filePath string, sourceMapFilePath *string, sourceFile *SourceFile) string {
		if mapOptions.inlineSourceMap {
			// Encode the sourceMap into the sourceMap url
			sourceMapText := sourceMapGenerator.toString()
			base64SourceMapText := base64encode(sys, sourceMapText)
			return __TEMPLATE__("data:application/json;base64,", base64SourceMapText)
		}

		sourceMapFile := getBaseFileName(normalizeSlashes(Debug.checkDefined(sourceMapFilePath)))
		if mapOptions.mapRoot {
			sourceMapDir := normalizeSlashes(mapOptions.mapRoot)
			if sourceFile {
				// For modules or multiple emit files the mapRoot will have directory structure like the sources
				// So if src\a.ts and src\lib\b.ts are compiled together user would be moving the maps into mapRoot\a.js.map and mapRoot\lib\b.js.map
				sourceMapDir = getDirectoryPath(getSourceFilePathInNewDir(sourceFile.fileName, host, sourceMapDir))
			}
			if getRootLength(sourceMapDir) == 0 {
				// The relative paths are relative to the common directory
				sourceMapDir = combinePaths(host.getCommonSourceDirectory(), sourceMapDir)
				return encodeURI(getRelativePathToDirectoryOrUrl(getDirectoryPath(normalizePath(filePath)), combinePaths(sourceMapDir, sourceMapFile), host.getCurrentDirectory(), host.getCanonicalFileName, true))
			} else {
				return encodeURI(combinePaths(sourceMapDir, sourceMapFile))
			}
		}
		return encodeURI(sourceMapFile)
	}

}

/** @internal */

func getBuildInfoText(buildInfo BuildInfo) string {
	return JSON.stringify(buildInfo)
}

/** @internal */

func getBuildInfo(buildInfoFile string, buildInfoText string) * /* TODO(TS-TO-GO) inferred type ts.BuildInfo */ any {
	return readJsonOrUndefined(buildInfoFile, buildInfoText) /* as BuildInfo | undefined */
}

/** @internal */

var notImplementedResolver EmitResolver = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"hasGlobalName":                             notImplemented,
	"getReferencedExportContainer":              notImplemented,
	"getReferencedImportDeclaration":            notImplemented,
	"getReferencedDeclarationWithCollidingName": notImplemented,
	"isDeclarationWithCollidingName":            notImplemented,
	"isValueAliasDeclaration":                   notImplemented,
	"isReferencedAliasDeclaration":              notImplemented,
	"isTopLevelValueImportEqualsWithEntityName": notImplemented,
	"hasNodeCheckFlag":                          notImplemented,
	"isDeclarationVisible":                      notImplemented,
	"isLateBound": func(_node /* TODO(TS-TO-GO) inferred type ts.Declaration */ any) /* TODO(TS-TO-GO) TypeNode TypePredicate: _node is LateBoundDeclaration */ any {
		return false
	},
	"collectLinkedAliases":                   notImplemented,
	"markLinkedReferences":                   notImplemented,
	"isImplementationOfOverload":             notImplemented,
	"requiresAddingImplicitUndefined":        notImplemented,
	"isExpandoFunctionDeclaration":           notImplemented,
	"getPropertiesOfContainerFunction":       notImplemented,
	"createTypeOfDeclaration":                notImplemented,
	"createReturnTypeOfSignatureDeclaration": notImplemented,
	"createTypeOfExpression":                 notImplemented,
	"createLiteralConstValue":                notImplemented,
	"isSymbolAccessible":                     notImplemented,
	"isEntityNameVisible":                    notImplemented,
	// Returns the constant value this property access resolves to: notImplemented, or 'undefined' for a non-constant
	"getConstantValue":                          notImplemented,
	"getEnumMemberValue":                        notImplemented,
	"getReferencedValueDeclaration":             notImplemented,
	"getReferencedValueDeclarations":            notImplemented,
	"getTypeReferenceSerializationKind":         notImplemented,
	"isOptionalParameter":                       notImplemented,
	"isArgumentsLocalBinding":                   notImplemented,
	"getExternalModuleFileFromDeclaration":      notImplemented,
	"isLiteralConstDeclaration":                 notImplemented,
	"getJsxFactoryEntity":                       notImplemented,
	"getJsxFragmentFactoryEntity":               notImplemented,
	"isBindingCapturedByNode":                   notImplemented,
	"getDeclarationStatementsForSourceFile":     notImplemented,
	"isImportRequiredByAugmentation":            notImplemented,
	"isDefinitelyReferenceToGlobalSymbolObject": notImplemented,
	"createLateBoundIndexSignatures":            notImplemented,
}

type PipelinePhase int32

const (
	PipelinePhaseNotification PipelinePhase = iota
	PipelinePhaseSubstitution
	PipelinePhaseComments
	PipelinePhaseSourceMaps
	PipelinePhaseEmit
)

/** @internal */

var createPrinterWithDefaults func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	})
})

/** @internal */

var createPrinterWithRemoveComments func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"removeComments": true,
	})
})

/** @internal */

var createPrinterWithRemoveCommentsNeverAsciiEscape func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"removeComments":   true,
		"neverAsciiEscape": true,
	})
})

/** @internal */

var createPrinterWithRemoveCommentsOmitTrailingSemicolon func() Printer = memoize(func() /* TODO(TS-TO-GO) inferred type ts.Printer */ any {
	return createPrinter(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"removeComments":        true,
		"omitTrailingSemicolon": true,
	})
})

func createPrinter(printerOptions PrinterOptions /*  = {} */, handlers PrintHandlers /*  = {} */) Printer {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	TODO_IDENTIFIER := handlers

	extendedDiagnostics := !!printerOptions.extendedDiagnostics
	omitBraceSourcePositions := !!printerOptions.omitBraceSourceMapPositions
	newLine := getNewLineCharacter(printerOptions)
	moduleKind := getEmitModuleKind(printerOptions)
	bundledHelpers := NewMap[string, bool]()

	var currentSourceFile *SourceFile
	var nodeIdToGeneratedName []string
	// Map of generated names for specific nodes.
	var nodeIdToGeneratedPrivateName []string
	// Map of generated names for specific nodes.
	var autoGeneratedIdToGeneratedName []string
	// Map of generated names for temp and loop variables.
	var generatedNames Set[string]
	// Set of names generated by the NameGenerator.
	var formattedNameTempFlagsStack []*Map[string, TempFlags]
	var formattedNameTempFlags *Map[string, TempFlags]
	var privateNameTempFlagsStack []TempFlags
	// Stack of enclosing name generation scopes.
	var privateNameTempFlags TempFlags
	// TempFlags for the current name generation scope.
	var tempFlagsStack []TempFlags
	// Stack of enclosing name generation scopes.
	var tempFlags TempFlags
	// TempFlags for the current name generation scope.
	var reservedNamesStack []*Set[string]
	// Stack of reserved names in enclosing name generation scopes.
	var reservedNames *Set[string]
	// Names reserved in nested name generation scopes.
	var reservedPrivateNamesStack []*Set[string]
	// Stack of reserved member names in enclosing name generation scopes.
	var reservedPrivateNames *Set[string]
	// Member names reserved in nested name generation scopes.
	preserveSourceNewlines := printerOptions.preserveSourceNewlines
	// Can be overridden inside nodes with the `IgnoreSourceNewlines` emit flag.
	var nextListElementPos *number
	// See comment in `getLeadingLineTerminatorCount`.

	var writer EmitTextWriter
	var ownWriter EmitTextWriter
	// Reusable `EmitTextWriter` for basic printing.
	write := writeBase
	var isOwnFileEmit bool

	// Source Maps
	sourceMapsDisabled := true
	var sourceMapGenerator *SourceMapGenerator
	var sourceMapSource SourceMapSource
	sourceMapSourceIndex := -1
	var mostRecentlyAddedSourceMapSource SourceMapSource
	mostRecentlyAddedSourceMapSourceIndex := -1

	// Comments
	containerPos := -1
	containerEnd := -1
	declarationListContainerEnd := -1
	var currentLineMap *[]number
	var detachedCommentsInfo *[] /* TODO(TS-TO-GO) TypeNode TypeLiteral: { nodePos: number; detachedCommentEndPos: number; } */ any
	hasWrittenComment := false
	commentsDisabled := !!printerOptions.removeComments
	var lastSubstitution Node
	var currentParenthesizerRule *ParenthesizerRule[any]
	TODO_IDENTIFIER := performance.createTimerIf(extendedDiagnostics, "commentTime", "beforeComment", "afterComment")
	parenthesizer := factory.parenthesizer
	var typeArgumentParenthesizerRuleSelector OrdinalParentheizerRuleSelector[TypeNode] = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"select_": func(index number) * /* TODO(TS-TO-GO) inferred type ((typeNode: TypeNode) => TypeNode) */ any {
			if index == 0 {
				return parenthesizer.parenthesizeLeadingTypeArgument
			} else {
				return nil
			}
		},
	}
	emitBinaryExpression := createEmitBinaryExpression()
	/* eslint-enable no-var */

	reset()
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		// public API
		"printNode":   printNode,
		"printList":   printList,
		"printFile":   printFile,
		"printBundle": printBundle,
		// internal API
		"writeNode":   writeNode,
		"writeList":   writeList,
		"writeFile":   writeFile,
		"writeBundle": writeBundle,
	}

	printNode := func(hint EmitHint, node Node, sourceFile SourceFile) string {
		switch hint {
		case EmitHintSourceFile:
			Debug.assert(isSourceFile(node), "Expected a SourceFile node.")
		case EmitHintIdentifierName:
			Debug.assert(isIdentifier(node), "Expected an Identifier node.")
		case EmitHintExpression:
			Debug.assert(isExpression(node), "Expected an Expression node.")
		}
		switch node.kind {
		case SyntaxKindSourceFile:
			return printFile(node.(SourceFile))
		case SyntaxKindBundle:
			return printBundle(node.(Bundle))
		}
		writeNode(hint, node, sourceFile, beginPrint())
		return endPrint()
	}

	printList := func(format ListFormat, nodes NodeArray[T], sourceFile SourceFile) string {
		writeList(format, nodes, sourceFile, beginPrint())
		return endPrint()
	}

	printBundle := func(bundle Bundle) string {
		writeBundle(bundle, beginPrint() /*sourceMapGenerator*/, nil)
		return endPrint()
	}

	printFile := func(sourceFile SourceFile) string {
		writeFile(sourceFile, beginPrint() /*sourceMapGenerator*/, nil)
		return endPrint()
	}

	/**
	 * If `sourceFile` is `undefined`, `node` must be a synthesized `TypeNode`.
	 */

	/* OVERLOAD: function writeNode(hint: EmitHint, node: TypeNode, sourceFile: undefined, output: EmitTextWriter): void; */
	/* OVERLOAD: function writeNode(hint: EmitHint, node: Node, sourceFile: SourceFile, output: EmitTextWriter): void; */
	writeNode := func(hint EmitHint, node Node, sourceFile *SourceFile, output EmitTextWriter) {
		previousWriter := writer
		setWriter(output /*_sourceMapGenerator*/, nil)
		print(hint, node, sourceFile)
		reset()
		writer = previousWriter
	}

	writeList := func(format ListFormat, nodes NodeArray[T], sourceFile *SourceFile, output EmitTextWriter) {
		previousWriter := writer
		setWriter(output /*_sourceMapGenerator*/, nil)
		if sourceFile {
			setSourceFile(sourceFile)
		}
		emitList(nil, nodes, format)
		reset()
		writer = previousWriter
	}

	writeBundle := func(bundle Bundle, output EmitTextWriter, sourceMapGenerator *SourceMapGenerator) {
		isOwnFileEmit = false
		previousWriter := writer
		setWriter(output, sourceMapGenerator)
		emitShebangIfNeeded(bundle)
		emitPrologueDirectivesIfNeeded(bundle)
		emitHelpers(bundle)
		emitSyntheticTripleSlashReferencesIfNeeded(bundle)
		for _, sourceFile := range bundle.sourceFiles {
			print(EmitHintSourceFile, sourceFile, sourceFile)
		}
		reset()
		writer = previousWriter
	}

	writeFile := func(sourceFile SourceFile, output EmitTextWriter, sourceMapGenerator *SourceMapGenerator) {
		isOwnFileEmit = true
		previousWriter := writer
		setWriter(output, sourceMapGenerator)
		emitShebangIfNeeded(sourceFile)
		emitPrologueDirectivesIfNeeded(sourceFile)
		print(EmitHintSourceFile, sourceFile, sourceFile)
		reset()
		writer = previousWriter
	}

	beginPrint := func() /* TODO(TS-TO-GO) inferred type ts.EmitTextWriter */ any {
		return ownWriter || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: ownWriter = createTextWriter(newLine) */ TODO)
	}

	endPrint := func() string {
		text := ownWriter.getText()
		ownWriter.clear()
		return text
	}

	print := func(hint EmitHint, node Node, sourceFile *SourceFile) {
		if sourceFile {
			setSourceFile(sourceFile)
		}

		pipelineEmit(hint, node /*parenthesizerRule*/, nil)
	}

	setSourceFile := func(sourceFile *SourceFile) {
		currentSourceFile = sourceFile
		currentLineMap = nil
		detachedCommentsInfo = nil
		if sourceFile {
			setSourceMapSource(sourceFile)
		}
	}

	setWriter := func(_writer *EmitTextWriter, _sourceMapGenerator *SourceMapGenerator) {
		if _writer && printerOptions.omitTrailingSemicolon {
			_writer = getTrailingSemicolonDeferringWriter(_writer)
		}

		writer = _writer
		// TODO: GH#18217
		sourceMapGenerator = _sourceMapGenerator
		sourceMapsDisabled = !writer || !sourceMapGenerator
	}

	reset := func() {
		nodeIdToGeneratedName = []never{}
		nodeIdToGeneratedPrivateName = []never{}
		autoGeneratedIdToGeneratedName = []never{}
		generatedNames = NewSet()
		formattedNameTempFlagsStack = []never{}
		formattedNameTempFlags = NewMap()
		privateNameTempFlagsStack = []never{}
		privateNameTempFlags = TempFlagsAuto
		tempFlagsStack = []never{}
		tempFlags = TempFlagsAuto
		reservedNamesStack = []never{}
		reservedNames = nil
		reservedPrivateNamesStack = []never{}
		reservedPrivateNames = nil
		currentSourceFile = nil
		currentLineMap = nil
		detachedCommentsInfo = nil
		setWriter(nil /*_sourceMapGenerator*/, nil)
	}

	getCurrentLineMap := func() []number {
		return currentLineMap || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: currentLineMap = getLineStarts(Debug.checkDefined(currentSourceFile)) */ TODO)
	}

	/* OVERLOAD: function emit<T extends Node>(node: T, parenthesizerRule?: (node: T) => T): void; */
	/* OVERLOAD: function emit<T extends Node>(node: T | undefined, parenthesizerRule?: (node: T) => T): void; */
	emit := func(node *T, parenthesizerRule func(node T) T) {
		if node == nil {
			return
		}
		pipelineEmit(EmitHintUnspecified, node, parenthesizerRule)
	}

	/* OVERLOAD: function emitIdentifierName(node: Identifier): void; */
	/* OVERLOAD: function emitIdentifierName(node: Identifier | undefined): void; */
	emitIdentifierName := func(node *Identifier) {
		if node == nil {
			return
		}
		pipelineEmit(EmitHintIdentifierName, node /*parenthesizerRule*/, nil)
	}

	/* OVERLOAD: function emitExpression<T extends Expression>(node: T, parenthesizerRule?: (node: T) => T): void; */
	/* OVERLOAD: function emitExpression<T extends Expression>(node: T | undefined, parenthesizerRule?: (node: T) => T): void; */
	emitExpression := func(node *T, parenthesizerRule func(node T) T) {
		if node == nil {
			return
		}
		pipelineEmit(EmitHintExpression, node, parenthesizerRule)
	}

	emitJsxAttributeValue := func(node JsxAttributeValue) {
		pipelineEmit(ifelse(isStringLiteral(node), EmitHintJsxAttributeValue, EmitHintUnspecified), node)
	}

	beforeEmitNode := func(node Node) {
		if preserveSourceNewlines && (getInternalEmitFlags(node) & InternalEmitFlagsIgnoreSourceNewlines) {
			preserveSourceNewlines = false
		}
	}

	afterEmitNode := func(savedPreserveSourceNewlines *bool) {
		preserveSourceNewlines = savedPreserveSourceNewlines
	}

	pipelineEmit := func(emitHint EmitHint, node T, parenthesizerRule func(node T) T) {
		currentParenthesizerRule = parenthesizerRule
		pipelinePhase := getPipelinePhase(PipelinePhaseNotification, emitHint, node)
		pipelinePhase(emitHint, node)
		currentParenthesizerRule = nil
	}

	shouldEmitComments := func(node Node) bool {
		return !commentsDisabled && !isSourceFile(node)
	}

	shouldEmitSourceMaps := func(node Node) bool {
		return !sourceMapsDisabled && !isSourceFile(node) && !isInJsonFile(node)
	}

	getPipelinePhase := func(phase PipelinePhase, emitHint EmitHint, node Node) /* TODO(TS-TO-GO) inferred type (hint: EmitHint, node: Node) => void */ any {
		switch phase {
		case PipelinePhaseNotification:
			if onEmitNode != noEmitNotification && (!isEmitNotificationEnabled || isEmitNotificationEnabled(node)) {
				return pipelineEmitWithNotification
			}
			fallthrough
		case PipelinePhaseSubstitution:
			if substituteNode != noEmitSubstitution && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: lastSubstitution = substituteNode(emitHint, node) || node */ TODO) != node {
				if currentParenthesizerRule {
					lastSubstitution = currentParenthesizerRule(lastSubstitution)
				}
				return pipelineEmitWithSubstitution
			}
			fallthrough
		case PipelinePhaseComments:
			if shouldEmitComments(node) {
				return pipelineEmitWithComments
			}
			fallthrough
		case PipelinePhaseSourceMaps:
			if shouldEmitSourceMaps(node) {
				return pipelineEmitWithSourceMaps
			}
			fallthrough
		case PipelinePhaseEmit:
			return pipelineEmitWithHint
		default:
			return Debug.assertNever(phase)
		}
	}

	getNextPipelinePhase := func(currentPhase PipelinePhase, emitHint EmitHint, node Node) /* TODO(TS-TO-GO) inferred type (hint: EmitHint, node: Node) => void */ any {
		return getPipelinePhase(currentPhase+1, emitHint, node)
	}

	pipelineEmitWithNotification := func(hint EmitHint, node Node) {
		pipelinePhase := getNextPipelinePhase(PipelinePhaseNotification, hint, node)
		onEmitNode(hint, node, pipelinePhase)
	}

	pipelineEmitWithHint := func(hint EmitHint, node Node) {
		onBeforeEmitNode(node)
		if preserveSourceNewlines {
			savedPreserveSourceNewlines := preserveSourceNewlines
			beforeEmitNode(node)
			pipelineEmitWithHintWorker(hint, node)
			afterEmitNode(savedPreserveSourceNewlines)
		} else {
			pipelineEmitWithHintWorker(hint, node)
		}
		onAfterEmitNode(node)
		// clear the parenthesizer rule as we ascend
		currentParenthesizerRule = nil
	}

	pipelineEmitWithHintWorker := func(hint EmitHint, node Node, allowSnippets bool /*  = true */) {
		if allowSnippets {
			snippet := getSnippetElement(node)
			if snippet {
				return emitSnippetNode(hint, node, snippet)
			}
		}
		if hint == EmitHintSourceFile {
			return emitSourceFile(cast(node, isSourceFile))
		}
		if hint == EmitHintIdentifierName {
			return emitIdentifier(cast(node, isIdentifier))
		}
		if hint == EmitHintJsxAttributeValue {
			return emitLiteral(cast(node, isStringLiteral) /*jsxAttributeEscape*/, true)
		}
		if hint == EmitHintMappedTypeParameter {
			return emitMappedTypeParameter(cast(node, isTypeParameterDeclaration))
		}
		if hint == EmitHintImportTypeNodeAttributes {
			return emitImportTypeNodeAttributes(cast(node, isImportAttributes))
		}
		if hint == EmitHintEmbeddedStatement {
			Debug.assertNode(node, isEmptyStatement)
			return emitEmptyStatement(true)
		}
		if hint == EmitHintUnspecified {
			switch node.kind {
			case SyntaxKindTemplateHead,
				SyntaxKindTemplateMiddle,
				SyntaxKindTemplateTail:
				return emitLiteral(node.(LiteralExpression) /*jsxAttributeEscape*/, false)

				// Identifiers
			case SyntaxKindIdentifier:
				return emitIdentifier(node.(Identifier))

				// PrivateIdentifiers
			case SyntaxKindPrivateIdentifier:
				return emitPrivateIdentifier(node.(PrivateIdentifier))

				// Parse tree nodes
				// Names
			case SyntaxKindQualifiedName:
				return emitQualifiedName(node.(QualifiedName))
			case SyntaxKindComputedPropertyName:
				return emitComputedPropertyName(node.(ComputedPropertyName))

				// Signature elements
			case SyntaxKindTypeParameter:
				return emitTypeParameter(node.(TypeParameterDeclaration))
			case SyntaxKindParameter:
				return emitParameter(node.(ParameterDeclaration))
			case SyntaxKindDecorator:
				return emitDecorator(node.(Decorator))

				// Type members
			case SyntaxKindPropertySignature:
				return emitPropertySignature(node.(PropertySignature))
			case SyntaxKindPropertyDeclaration:
				return emitPropertyDeclaration(node.(PropertyDeclaration))
			case SyntaxKindMethodSignature:
				return emitMethodSignature(node.(MethodSignature))
			case SyntaxKindMethodDeclaration:
				return emitMethodDeclaration(node.(MethodDeclaration))
			case SyntaxKindClassStaticBlockDeclaration:
				return emitClassStaticBlockDeclaration(node.(ClassStaticBlockDeclaration))
			case SyntaxKindConstructor:
				return emitConstructor(node.(ConstructorDeclaration))
			case SyntaxKindGetAccessor,
				SyntaxKindSetAccessor:
				return emitAccessorDeclaration(node.(AccessorDeclaration))
			case SyntaxKindCallSignature:
				return emitCallSignature(node.(CallSignatureDeclaration))
			case SyntaxKindConstructSignature:
				return emitConstructSignature(node.(ConstructSignatureDeclaration))
			case SyntaxKindIndexSignature:
				return emitIndexSignature(node.(IndexSignatureDeclaration))

				// Types
			case SyntaxKindTypePredicate:
				return emitTypePredicate(node.(TypePredicateNode))
			case SyntaxKindTypeReference:
				return emitTypeReference(node.(TypeReferenceNode))
			case SyntaxKindFunctionType:
				return emitFunctionType(node.(FunctionTypeNode))
			case SyntaxKindConstructorType:
				return emitConstructorType(node.(ConstructorTypeNode))
			case SyntaxKindTypeQuery:
				return emitTypeQuery(node.(TypeQueryNode))
			case SyntaxKindTypeLiteral:
				return emitTypeLiteral(node.(TypeLiteralNode))
			case SyntaxKindArrayType:
				return emitArrayType(node.(ArrayTypeNode))
			case SyntaxKindTupleType:
				return emitTupleType(node.(TupleTypeNode))
			case SyntaxKindOptionalType:
				return emitOptionalType(node.(OptionalTypeNode))
				// SyntaxKind.RestType is handled below
			case SyntaxKindUnionType:
				return emitUnionType(node.(UnionTypeNode))
			case SyntaxKindIntersectionType:
				return emitIntersectionType(node.(IntersectionTypeNode))
			case SyntaxKindConditionalType:
				return emitConditionalType(node.(ConditionalTypeNode))
			case SyntaxKindInferType:
				return emitInferType(node.(InferTypeNode))
			case SyntaxKindParenthesizedType:
				return emitParenthesizedType(node.(ParenthesizedTypeNode))
			case SyntaxKindExpressionWithTypeArguments:
				return emitExpressionWithTypeArguments(node.(ExpressionWithTypeArguments))
			case SyntaxKindThisType:
				return emitThisType()
			case SyntaxKindTypeOperator:
				return emitTypeOperator(node.(TypeOperatorNode))
			case SyntaxKindIndexedAccessType:
				return emitIndexedAccessType(node.(IndexedAccessTypeNode))
			case SyntaxKindMappedType:
				return emitMappedType(node.(MappedTypeNode))
			case SyntaxKindLiteralType:
				return emitLiteralType(node.(LiteralTypeNode))
			case SyntaxKindNamedTupleMember:
				return emitNamedTupleMember(node.(NamedTupleMember))
			case SyntaxKindTemplateLiteralType:
				return emitTemplateType(node.(TemplateLiteralTypeNode))
			case SyntaxKindTemplateLiteralTypeSpan:
				return emitTemplateTypeSpan(node.(TemplateLiteralTypeSpan))
			case SyntaxKindImportType:
				return emitImportTypeNode(node.(ImportTypeNode))

				// Binding patterns
			case SyntaxKindObjectBindingPattern:
				return emitObjectBindingPattern(node.(ObjectBindingPattern))
			case SyntaxKindArrayBindingPattern:
				return emitArrayBindingPattern(node.(ArrayBindingPattern))
			case SyntaxKindBindingElement:
				return emitBindingElement(node.(BindingElement))

				// Misc
			case SyntaxKindTemplateSpan:
				return emitTemplateSpan(node.(TemplateSpan))
			case SyntaxKindSemicolonClassElement:
				return emitSemicolonClassElement()

				// Statements
			case SyntaxKindBlock:
				return emitBlock(node.(Block))
			case SyntaxKindVariableStatement:
				return emitVariableStatement(node.(VariableStatement))
			case SyntaxKindEmptyStatement:
				return emitEmptyStatement(false)
			case SyntaxKindExpressionStatement:
				return emitExpressionStatement(node.(ExpressionStatement))
			case SyntaxKindIfStatement:
				return emitIfStatement(node.(IfStatement))
			case SyntaxKindDoStatement:
				return emitDoStatement(node.(DoStatement))
			case SyntaxKindWhileStatement:
				return emitWhileStatement(node.(WhileStatement))
			case SyntaxKindForStatement:
				return emitForStatement(node.(ForStatement))
			case SyntaxKindForInStatement:
				return emitForInStatement(node.(ForInStatement))
			case SyntaxKindForOfStatement:
				return emitForOfStatement(node.(ForOfStatement))
			case SyntaxKindContinueStatement:
				return emitContinueStatement(node.(ContinueStatement))
			case SyntaxKindBreakStatement:
				return emitBreakStatement(node.(BreakStatement))
			case SyntaxKindReturnStatement:
				return emitReturnStatement(node.(ReturnStatement))
			case SyntaxKindWithStatement:
				return emitWithStatement(node.(WithStatement))
			case SyntaxKindSwitchStatement:
				return emitSwitchStatement(node.(SwitchStatement))
			case SyntaxKindLabeledStatement:
				return emitLabeledStatement(node.(LabeledStatement))
			case SyntaxKindThrowStatement:
				return emitThrowStatement(node.(ThrowStatement))
			case SyntaxKindTryStatement:
				return emitTryStatement(node.(TryStatement))
			case SyntaxKindDebuggerStatement:
				return emitDebuggerStatement(node.(DebuggerStatement))

				// Declarations
			case SyntaxKindVariableDeclaration:
				return emitVariableDeclaration(node.(VariableDeclaration))
			case SyntaxKindVariableDeclarationList:
				return emitVariableDeclarationList(node.(VariableDeclarationList))
			case SyntaxKindFunctionDeclaration:
				return emitFunctionDeclaration(node.(FunctionDeclaration))
			case SyntaxKindClassDeclaration:
				return emitClassDeclaration(node.(ClassDeclaration))
			case SyntaxKindInterfaceDeclaration:
				return emitInterfaceDeclaration(node.(InterfaceDeclaration))
			case SyntaxKindTypeAliasDeclaration:
				return emitTypeAliasDeclaration(node.(TypeAliasDeclaration))
			case SyntaxKindEnumDeclaration:
				return emitEnumDeclaration(node.(EnumDeclaration))
			case SyntaxKindModuleDeclaration:
				return emitModuleDeclaration(node.(ModuleDeclaration))
			case SyntaxKindModuleBlock:
				return emitModuleBlock(node.(ModuleBlock))
			case SyntaxKindCaseBlock:
				return emitCaseBlock(node.(CaseBlock))
			case SyntaxKindNamespaceExportDeclaration:
				return emitNamespaceExportDeclaration(node.(NamespaceExportDeclaration))
			case SyntaxKindImportEqualsDeclaration:
				return emitImportEqualsDeclaration(node.(ImportEqualsDeclaration))
			case SyntaxKindImportDeclaration:
				return emitImportDeclaration(node.(ImportDeclaration))
			case SyntaxKindImportClause:
				return emitImportClause(node.(ImportClause))
			case SyntaxKindNamespaceImport:
				return emitNamespaceImport(node.(NamespaceImport))
			case SyntaxKindNamespaceExport:
				return emitNamespaceExport(node.(NamespaceExport))
			case SyntaxKindNamedImports:
				return emitNamedImports(node.(NamedImports))
			case SyntaxKindImportSpecifier:
				return emitImportSpecifier(node.(ImportSpecifier))
			case SyntaxKindExportAssignment:
				return emitExportAssignment(node.(ExportAssignment))
			case SyntaxKindExportDeclaration:
				return emitExportDeclaration(node.(ExportDeclaration))
			case SyntaxKindNamedExports:
				return emitNamedExports(node.(NamedExports))
			case SyntaxKindExportSpecifier:
				return emitExportSpecifier(node.(ExportSpecifier))
			case SyntaxKindImportAttributes:
				return emitImportAttributes(node.(ImportAttributes))
			case SyntaxKindImportAttribute:
				return emitImportAttribute(node.(ImportAttribute))
			case SyntaxKindMissingDeclaration:
				return

				// Module references
			case SyntaxKindExternalModuleReference:
				return emitExternalModuleReference(node.(ExternalModuleReference))

				// JSX (non-expression)
			case SyntaxKindJsxText:
				return emitJsxText(node.(JsxText))
			case SyntaxKindJsxOpeningElement,
				SyntaxKindJsxOpeningFragment:
				return emitJsxOpeningElementOrFragment(node.(JsxOpeningElement))
			case SyntaxKindJsxClosingElement,
				SyntaxKindJsxClosingFragment:
				return emitJsxClosingElementOrFragment(node.(JsxClosingElement))
			case SyntaxKindJsxAttribute:
				return emitJsxAttribute(node.(JsxAttribute))
			case SyntaxKindJsxAttributes:
				return emitJsxAttributes(node.(JsxAttributes))
			case SyntaxKindJsxSpreadAttribute:
				return emitJsxSpreadAttribute(node.(JsxSpreadAttribute))
			case SyntaxKindJsxExpression:
				return emitJsxExpression(node.(JsxExpression))
			case SyntaxKindJsxNamespacedName:
				return emitJsxNamespacedName(node.(JsxNamespacedName))

				// Clauses
			case SyntaxKindCaseClause:
				return emitCaseClause(node.(CaseClause))
			case SyntaxKindDefaultClause:
				return emitDefaultClause(node.(DefaultClause))
			case SyntaxKindHeritageClause:
				return emitHeritageClause(node.(HeritageClause))
			case SyntaxKindCatchClause:
				return emitCatchClause(node.(CatchClause))

				// Property assignments
			case SyntaxKindPropertyAssignment:
				return emitPropertyAssignment(node.(PropertyAssignment))
			case SyntaxKindShorthandPropertyAssignment:
				return emitShorthandPropertyAssignment(node.(ShorthandPropertyAssignment))
			case SyntaxKindSpreadAssignment:
				return emitSpreadAssignment(node.(SpreadAssignment))

				// Enum
			case SyntaxKindEnumMember:
				return emitEnumMember(node.(EnumMember))

				// Top-level nodes
			case SyntaxKindSourceFile:
				return emitSourceFile(node.(SourceFile))
			case SyntaxKindBundle:
				return Debug.fail("Bundles should be printed using printBundle")

				// JSDoc nodes (only used in codefixes currently)
			case SyntaxKindJSDocTypeExpression:
				return emitJSDocTypeExpression(node.(JSDocTypeExpression))
			case SyntaxKindJSDocNameReference:
				return emitJSDocNameReference(node.(JSDocNameReference))
			case SyntaxKindJSDocAllType:
				return writePunctuation("*")
			case SyntaxKindJSDocUnknownType:
				return writePunctuation("?")
			case SyntaxKindJSDocNullableType:
				return emitJSDocNullableType(node.(JSDocNullableType))
			case SyntaxKindJSDocNonNullableType:
				return emitJSDocNonNullableType(node.(JSDocNonNullableType))
			case SyntaxKindJSDocOptionalType:
				return emitJSDocOptionalType(node.(JSDocOptionalType))
			case SyntaxKindJSDocFunctionType:
				return emitJSDocFunctionType(node.(JSDocFunctionType))
			case SyntaxKindRestType,
				SyntaxKindJSDocVariadicType:
				return emitRestOrJSDocVariadicType(node /* as RestTypeNode | JSDocVariadicType */)
			case SyntaxKindJSDocNamepathType:
				return
			case SyntaxKindJSDoc:
				return emitJSDoc(node.(JSDoc))
			case SyntaxKindJSDocTypeLiteral:
				return emitJSDocTypeLiteral(node.(JSDocTypeLiteral))
			case SyntaxKindJSDocSignature:
				return emitJSDocSignature(node.(JSDocSignature))
			case SyntaxKindJSDocTag,
				SyntaxKindJSDocClassTag,
				SyntaxKindJSDocOverrideTag:
				return emitJSDocSimpleTag(node.(JSDocTag))
			case SyntaxKindJSDocAugmentsTag,
				SyntaxKindJSDocImplementsTag:
				return emitJSDocHeritageTag(node /* as JSDocImplementsTag | JSDocAugmentsTag */)
			case SyntaxKindJSDocAuthorTag,
				SyntaxKindJSDocDeprecatedTag:
				return
				// SyntaxKind.JSDocClassTag (see JSDocTag, above)
			case SyntaxKindJSDocPublicTag,
				SyntaxKindJSDocPrivateTag,
				SyntaxKindJSDocProtectedTag,
				SyntaxKindJSDocReadonlyTag:
				return
			case SyntaxKindJSDocCallbackTag:
				return emitJSDocCallbackTag(node.(JSDocCallbackTag))
			case SyntaxKindJSDocOverloadTag:
				return emitJSDocOverloadTag(node.(JSDocOverloadTag))
				// SyntaxKind.JSDocEnumTag (see below)
			case SyntaxKindJSDocParameterTag,
				SyntaxKindJSDocPropertyTag:
				return emitJSDocPropertyLikeTag(node.(JSDocPropertyLikeTag))
			case SyntaxKindJSDocEnumTag,
				SyntaxKindJSDocReturnTag,
				SyntaxKindJSDocThisTag,
				SyntaxKindJSDocTypeTag,
				SyntaxKindJSDocThrowsTag,
				SyntaxKindJSDocSatisfiesTag:
				return emitJSDocSimpleTypedTag(node /* as JSDocTypeTag | JSDocReturnTag | JSDocThisTag | JSDocTypeTag | JSDocThrowsTag | JSDocSatisfiesTag */)
			case SyntaxKindJSDocTemplateTag:
				return emitJSDocTemplateTag(node.(JSDocTemplateTag))
			case SyntaxKindJSDocTypedefTag:
				return emitJSDocTypedefTag(node.(JSDocTypedefTag))
			case SyntaxKindJSDocSeeTag:
				return emitJSDocSeeTag(node.(JSDocSeeTag))
			case SyntaxKindJSDocImportTag:
				return emitJSDocImportTag(node.(JSDocImportTag))
				// SyntaxKind.JSDocPropertyTag (see JSDocParameterTag, above)

				// Transformation nodes
			case SyntaxKindNotEmittedStatement,
				SyntaxKindNotEmittedTypeElement:
				return
			}
			if isExpression(node) {
				hint = EmitHintExpression
				if substituteNode != noEmitSubstitution {
					substitute := substituteNode(hint, node) || node
					if substitute != node {
						node = substitute
						if currentParenthesizerRule {
							node = currentParenthesizerRule(node)
						}
					}
				}
			}
		}
		if hint == EmitHintExpression {
			switch node.kind {
			case SyntaxKindNumericLiteral,
				SyntaxKindBigIntLiteral:
				return emitNumericOrBigIntLiteral(node /* as NumericLiteral | BigIntLiteral */)
			case SyntaxKindStringLiteral,
				SyntaxKindRegularExpressionLiteral,
				SyntaxKindNoSubstitutionTemplateLiteral:
				return emitLiteral(node.(LiteralExpression) /*jsxAttributeEscape*/, false)

				// Identifiers
			case SyntaxKindIdentifier:
				return emitIdentifier(node.(Identifier))
			case SyntaxKindPrivateIdentifier:
				return emitPrivateIdentifier(node.(PrivateIdentifier))

				// Expressions
			case SyntaxKindArrayLiteralExpression:
				return emitArrayLiteralExpression(node.(ArrayLiteralExpression))
			case SyntaxKindObjectLiteralExpression:
				return emitObjectLiteralExpression(node.(ObjectLiteralExpression))
			case SyntaxKindPropertyAccessExpression:
				return emitPropertyAccessExpression(node.(PropertyAccessExpression))
			case SyntaxKindElementAccessExpression:
				return emitElementAccessExpression(node.(ElementAccessExpression))
			case SyntaxKindCallExpression:
				return emitCallExpression(node.(CallExpression))
			case SyntaxKindNewExpression:
				return emitNewExpression(node.(NewExpression))
			case SyntaxKindTaggedTemplateExpression:
				return emitTaggedTemplateExpression(node.(TaggedTemplateExpression))
			case SyntaxKindTypeAssertionExpression:
				return emitTypeAssertionExpression(node.(TypeAssertion))
			case SyntaxKindParenthesizedExpression:
				return emitParenthesizedExpression(node.(ParenthesizedExpression))
			case SyntaxKindFunctionExpression:
				return emitFunctionExpression(node.(FunctionExpression))
			case SyntaxKindArrowFunction:
				return emitArrowFunction(node.(ArrowFunction))
			case SyntaxKindDeleteExpression:
				return emitDeleteExpression(node.(DeleteExpression))
			case SyntaxKindTypeOfExpression:
				return emitTypeOfExpression(node.(TypeOfExpression))
			case SyntaxKindVoidExpression:
				return emitVoidExpression(node.(VoidExpression))
			case SyntaxKindAwaitExpression:
				return emitAwaitExpression(node.(AwaitExpression))
			case SyntaxKindPrefixUnaryExpression:
				return emitPrefixUnaryExpression(node.(PrefixUnaryExpression))
			case SyntaxKindPostfixUnaryExpression:
				return emitPostfixUnaryExpression(node.(PostfixUnaryExpression))
			case SyntaxKindBinaryExpression:
				return emitBinaryExpression(node.(BinaryExpression))
			case SyntaxKindConditionalExpression:
				return emitConditionalExpression(node.(ConditionalExpression))
			case SyntaxKindTemplateExpression:
				return emitTemplateExpression(node.(TemplateExpression))
			case SyntaxKindYieldExpression:
				return emitYieldExpression(node.(YieldExpression))
			case SyntaxKindSpreadElement:
				return emitSpreadElement(node.(SpreadElement))
			case SyntaxKindClassExpression:
				return emitClassExpression(node.(ClassExpression))
			case SyntaxKindOmittedExpression:
				return
			case SyntaxKindAsExpression:
				return emitAsExpression(node.(AsExpression))
			case SyntaxKindNonNullExpression:
				return emitNonNullExpression(node.(NonNullExpression))
			case SyntaxKindExpressionWithTypeArguments:
				return emitExpressionWithTypeArguments(node.(ExpressionWithTypeArguments))
			case SyntaxKindSatisfiesExpression:
				return emitSatisfiesExpression(node.(SatisfiesExpression))
			case SyntaxKindMetaProperty:
				return emitMetaProperty(node.(MetaProperty))
			case SyntaxKindSyntheticExpression:
				return Debug.fail("SyntheticExpression should never be printed.")
			case SyntaxKindMissingDeclaration:
				return

				// JSX
			case SyntaxKindJsxElement:
				return emitJsxElement(node.(JsxElement))
			case SyntaxKindJsxSelfClosingElement:
				return emitJsxSelfClosingElement(node.(JsxSelfClosingElement))
			case SyntaxKindJsxFragment:
				return emitJsxFragment(node.(JsxFragment))

				// Synthesized list
			case SyntaxKindSyntaxList:
				return Debug.fail("SyntaxList should not be printed")

				// Transformation nodes
			case SyntaxKindNotEmittedStatement:
				return
			case SyntaxKindPartiallyEmittedExpression:
				return emitPartiallyEmittedExpression(node.(PartiallyEmittedExpression))
			case SyntaxKindCommaListExpression:
				return emitCommaList(node.(CommaListExpression))
			case SyntaxKindSyntheticReferenceExpression:
				return Debug.fail("SyntheticReferenceExpression should not be printed")
			}
		}
		if isKeyword(node.kind) {
			return writeTokenNode(node, writeKeyword)
		}
		if isTokenKind(node.kind) {
			return writeTokenNode(node, writePunctuation)
		}
		Debug.fail(__TEMPLATE__("Unhandled SyntaxKind: ", Debug.formatSyntaxKind(node.kind), "."))
	}

	emitMappedTypeParameter := func(node TypeParameterDeclaration) {
		emit(node.name)
		writeSpace()
		writeKeyword("in")
		writeSpace()
		emit(node.constraint)
	}

	pipelineEmitWithSubstitution := func(hint EmitHint, node Node) {
		pipelinePhase := getNextPipelinePhase(PipelinePhaseSubstitution, hint, node)
		Debug.assertIsDefined(lastSubstitution)
		node = lastSubstitution
		lastSubstitution = nil
		pipelinePhase(hint, node)
	}

	emitHelpers := func(node Node) *bool {
		helpersEmitted := false
		var bundle * /* TODO(TS-TO-GO) inferred type ts.Bundle */ any
		if node.kind == SyntaxKindBundle {
			bundle = node.(Bundle)
		} else {
			bundle = nil
		}
		if bundle && moduleKind == ModuleKindNone {
			return
		}
		var numNodes number
		if bundle {
			numNodes = bundle.sourceFiles.length
		} else {
			numNodes = 1
		}
		for i := 0; i < numNodes; i++ {
			var currentNode /* TODO(TS-TO-GO) inferred type ts.Node */ any
			if bundle {
				currentNode = bundle.sourceFiles[i]
			} else {
				currentNode = node
			}
			var sourceFile * /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any
			if isSourceFile(currentNode) {
				sourceFile = currentNode
			} else {
				sourceFile = currentSourceFile
			}
			shouldSkip := printerOptions.noEmitHelpers || (!!sourceFile && hasRecordedExternalHelpers(sourceFile))
			shouldBundle := isSourceFile(currentNode) && !isOwnFileEmit
			helpers := getSortedEmitHelpers(currentNode)
			if helpers {
				for _, helper := range helpers {
					if !helper.scoped {
						// Skip the helper if it can be skipped and the noEmitHelpers compiler
						// option is set, or if it can be imported and the importHelpers compiler
						// option is set.
						if shouldSkip {
							continue
						}

						// Skip the helper if it can be bundled but hasn't already been emitted and we
						// are emitting a bundled module.
						if shouldBundle {
							if bundledHelpers.get(helper.name) {
								continue
							}

							bundledHelpers.set(helper.name, true)
						}
					} else if bundle {
						// Skip the helper if it is scoped and we are emitting bundled helpers
						continue
					}
					if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof helper.text */ TODO == "string" {
						writeLines(helper.text)
					} else {
						writeLines(helper.text(makeFileLevelOptimisticUniqueName))
					}
					helpersEmitted = true
				}
			}
		}

		return helpersEmitted
	}

	getSortedEmitHelpers := func(node Node) * /* TODO(TS-TO-GO) inferred type ts.SortedReadonlyArray<ts.EmitHelper> */ any {
		helpers := getEmitHelpers(node)
		return helpers && toSorted(helpers, compareEmitHelpers)
	}

	//
	// Literals/Pseudo-literals
	//

	// SyntaxKind.NumericLiteral
	// SyntaxKind.BigIntLiteral
	emitNumericOrBigIntLiteral := func(node /* TODO(TS-TO-GO) TypeNode UnionType: NumericLiteral | BigIntLiteral */ any) {
		emitLiteral(node /*jsxAttributeEscape*/, false)
	}

	// SyntaxKind.StringLiteral
	// SyntaxKind.RegularExpressionLiteral
	// SyntaxKind.NoSubstitutionTemplateLiteral
	// SyntaxKind.TemplateHead
	// SyntaxKind.TemplateMiddle
	// SyntaxKind.TemplateTail
	emitLiteral := func(node LiteralLikeNode, jsxAttributeEscape bool) {
		text := getLiteralTextOfNode(node /*sourceFile*/, nil, printerOptions.neverAsciiEscape, jsxAttributeEscape)
		if (printerOptions.sourceMap || printerOptions.inlineSourceMap) && (node.kind == SyntaxKindStringLiteral || isTemplateLiteralKind(node.kind)) {
			writeLiteral(text)
		} else {
			// Quick info expects all literals to be called with writeStringLiteral, as there's no specific type for numberLiterals
			writeStringLiteral(text)
		}
	}

	//
	// Snippet Elements
	//

	emitSnippetNode := func(hint EmitHint, node Node, snippet SnippetElement) {
		switch snippet.kind {
		case SnippetKindPlaceholder:
			emitPlaceholder(hint, node, snippet)
		case SnippetKindTabStop:
			emitTabStop(hint, node, snippet)
		}
	}

	emitPlaceholder := func(hint EmitHint, node Node, snippet Placeholder) {
		nonEscapingWrite(__TEMPLATE__("${", snippet.order, ":"))
		// `${2:`
		pipelineEmitWithHintWorker(hint, node /*allowSnippets*/, false)
		// `...`
		nonEscapingWrite(`}`)
		// `${2:...}`
	}

	emitTabStop := func(hint EmitHint, node Node, snippet TabStop) {
		// A tab stop should only be attached to an empty node, i.e. a node that doesn't emit any text.
		Debug.assert(node.kind == SyntaxKindEmptyStatement, __TEMPLATE__("A tab stop cannot be attached to a node of kind ", Debug.formatSyntaxKind(node.kind), "."))
		Debug.assert(hint != EmitHintEmbeddedStatement, `A tab stop cannot be attached to an embedded statement.`)
		nonEscapingWrite(__TEMPLATE__("$", snippet.order))
	}

	//
	// Identifiers
	//

	emitIdentifier := func(node Identifier) {
		var writeText /* TODO(TS-TO-GO) inferred type (s: string, sym: Symbol) => void */ any
		if node.symbol {
			writeText = writeSymbol
		} else {
			writeText = write
		}
		writeText(getTextOfNode(node /*includeTrivia*/, false), node.symbol)
		emitList(node, getIdentifierTypeArguments(node), ListFormatTypeParameters)
		// Call emitList directly since it could be an array of TypeParameterDeclarations _or_ type arguments
	}

	//
	// Names
	//

	emitPrivateIdentifier := func(node PrivateIdentifier) {
		write(getTextOfNode(node /*includeTrivia*/, false))
	}

	emitQualifiedName := func(node QualifiedName) {
		emitEntityName(node.left)
		writePunctuation(".")
		emit(node.right)
	}

	emitEntityName := func(node EntityName) {
		if node.kind == SyntaxKindIdentifier {
			emitExpression(node)
		} else {
			emit(node)
		}
	}

	emitComputedPropertyName := func(node ComputedPropertyName) {
		writePunctuation("[")
		emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfComputedPropertyName)
		writePunctuation("]")
	}

	//
	// Signature elements
	//

	emitTypeParameter := func(node TypeParameterDeclaration) {
		emitModifierList(node, node.modifiers)
		emit(node.name)
		if node.constraint {
			writeSpace()
			writeKeyword("extends")
			writeSpace()
			emit(node.constraint)
		}
		if node.default_ {
			writeSpace()
			writeOperator("=")
			writeSpace()
			emit(node.default_)
		}
	}

	emitParameter := func(node ParameterDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, true)
		emit(node.dotDotDotToken)
		emitNodeWithWriter(node.name, writeParameter)
		emit(node.questionToken)
		if node.parent && node.parent.kind == SyntaxKindJSDocFunctionType && !node.name {
			emit(node.type_)
		} else {
			emitTypeAnnotation(node.type_)
		}
		// The comment position has to fallback to any present node within the parameterdeclaration because as it turns out, the parser can make parameter declarations with _just_ an initializer.
		emitInitializer(node.initializer, ifelse(node.type_, node.type_.end, ifelse(node.questionToken, node.questionToken.end, ifelse(node.name, node.name.end, ifelse(node.modifiers, node.modifiers.end, node.pos)))), node, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	emitDecorator := func(decorator Decorator) {
		writePunctuation("@")
		emitExpression(decorator.expression, parenthesizer.parenthesizeLeftSideOfAccess)
	}

	//
	// Type members
	//

	emitPropertySignature := func(node PropertySignature) {
		emitModifierList(node, node.modifiers)
		emitNodeWithWriter(node.name, writeProperty)
		emit(node.questionToken)
		emitTypeAnnotation(node.type_)
		writeTrailingSemicolon()
	}

	emitPropertyDeclaration := func(node PropertyDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, true)
		emit(node.name)
		emit(node.questionToken)
		emit(node.exclamationToken)
		emitTypeAnnotation(node.type_)
		emitInitializer(node.initializer, ifelse(node.type_, node.type_.end, ifelse(node.questionToken, node.questionToken.end, node.name.end)), node)
		writeTrailingSemicolon()
	}

	emitMethodSignature := func(node MethodSignature) {
		emitModifierList(node, node.modifiers)
		emit(node.name)
		emit(node.questionToken)
		emitSignatureAndBody(node, emitSignatureHead, emitEmptyFunctionBody)
	}

	emitMethodDeclaration := func(node MethodDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, true)
		emit(node.asteriskToken)
		emit(node.name)
		emit(node.questionToken)
		emitSignatureAndBody(node, emitSignatureHead, emitFunctionBody)
	}

	emitClassStaticBlockDeclaration := func(node ClassStaticBlockDeclaration) {
		writeKeyword("static")
		pushNameGenerationScope(node)
		emitBlockFunctionBody(node.body)
		popNameGenerationScope(node)
	}

	emitConstructor := func(node ConstructorDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		writeKeyword("constructor")
		emitSignatureAndBody(node, emitSignatureHead, emitFunctionBody)
	}

	emitAccessorDeclaration := func(node AccessorDeclaration) {
		pos := emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, true)
		var token /* TODO(TS-TO-GO) inferred type ts.SyntaxKind.GetKeyword | ts.SyntaxKind.SetKeyword */ any
		if node.kind == SyntaxKindGetAccessor {
			token = SyntaxKindGetKeyword
		} else {
			token = SyntaxKindSetKeyword
		}
		emitTokenWithComment(token, pos, writeKeyword, node)
		writeSpace()
		emit(node.name)
		emitSignatureAndBody(node, emitSignatureHead, emitFunctionBody)
	}

	emitCallSignature := func(node CallSignatureDeclaration) {
		emitSignatureAndBody(node, emitSignatureHead, emitEmptyFunctionBody)
	}

	emitConstructSignature := func(node ConstructSignatureDeclaration) {
		writeKeyword("new")
		writeSpace()
		emitSignatureAndBody(node, emitSignatureHead, emitEmptyFunctionBody)
	}

	emitIndexSignature := func(node IndexSignatureDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		emitParametersForIndexSignature(node, node.parameters)
		emitTypeAnnotation(node.type_)
		writeTrailingSemicolon()
	}

	emitTemplateTypeSpan := func(node TemplateLiteralTypeSpan) {
		emit(node.type_)
		emit(node.literal)
	}

	emitSemicolonClassElement := func() {
		writeTrailingSemicolon()
	}

	//
	// Types
	//

	emitTypePredicate := func(node TypePredicateNode) {
		if node.assertsModifier {
			emit(node.assertsModifier)
			writeSpace()
		}
		emit(node.parameterName)
		if node.type_ {
			writeSpace()
			writeKeyword("is")
			writeSpace()
			emit(node.type_)
		}
	}

	emitTypeReference := func(node TypeReferenceNode) {
		emit(node.typeName)
		emitTypeArguments(node, node.typeArguments)
	}

	emitFunctionType := func(node FunctionTypeNode) {
		emitSignatureAndBody(node, emitFunctionTypeHead, emitFunctionTypeBody)
	}

	emitFunctionTypeHead := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionTypeNode | ConstructorTypeNode */ any) {
		emitTypeParameters(node, node.typeParameters)
		emitParametersForArrow(node, node.parameters)
		writeSpace()
		writePunctuation("=>")
	}

	emitFunctionTypeBody := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionTypeNode | ConstructorTypeNode */ any) {
		writeSpace()
		emit(node.type_)
	}

	emitJSDocFunctionType := func(node JSDocFunctionType) {
		writeKeyword("function")
		emitParameters(node, node.parameters)
		writePunctuation(":")
		emit(node.type_)
	}

	emitJSDocNullableType := func(node JSDocNullableType) {
		writePunctuation("?")
		emit(node.type_)
	}

	emitJSDocNonNullableType := func(node JSDocNonNullableType) {
		writePunctuation("!")
		emit(node.type_)
	}

	emitJSDocOptionalType := func(node JSDocOptionalType) {
		emit(node.type_)
		writePunctuation("=")
	}

	emitConstructorType := func(node ConstructorTypeNode) {
		emitModifierList(node, node.modifiers)
		writeKeyword("new")
		writeSpace()
		emitSignatureAndBody(node, emitFunctionTypeHead, emitFunctionTypeBody)
	}

	emitTypeQuery := func(node TypeQueryNode) {
		writeKeyword("typeof")
		writeSpace()
		emit(node.exprName)
		emitTypeArguments(node, node.typeArguments)
	}

	emitTypeLiteral := func(node TypeLiteralNode) {
		pushNameGenerationScope(node)
		forEach(node.members, generateMemberNames)

		writePunctuation("{")
		var flags /* TODO(TS-TO-GO) inferred type ts.ListFormat.SingleLineTypeLiteralMembers | ts.ListFormat.MultiLineTypeLiteralMembers */ any
		if getEmitFlags(node) & EmitFlagsSingleLine {
			flags = ListFormatSingleLineTypeLiteralMembers
		} else {
			flags = ListFormatMultiLineTypeLiteralMembers
		}
		emitList(node, node.members, flags|ListFormatNoSpaceIfEmpty)
		writePunctuation("}")

		popNameGenerationScope(node)
	}

	emitArrayType := func(node ArrayTypeNode) {
		emit(node.elementType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType)
		writePunctuation("[")
		writePunctuation("]")
	}

	emitRestOrJSDocVariadicType := func(node /* TODO(TS-TO-GO) TypeNode UnionType: RestTypeNode | JSDocVariadicType */ any) {
		writePunctuation("...")
		emit(node.type_)
	}

	emitTupleType := func(node TupleTypeNode) {
		emitTokenWithComment(SyntaxKindOpenBracketToken, node.pos, writePunctuation, node)
		var flags /* TODO(TS-TO-GO) inferred type ts.ListFormat.SingleLineTupleTypeElements | ts.ListFormat.MultiLineTupleTypeElements */ any
		if getEmitFlags(node) & EmitFlagsSingleLine {
			flags = ListFormatSingleLineTupleTypeElements
		} else {
			flags = ListFormatMultiLineTupleTypeElements
		}
		emitList(node, node.elements, flags|ListFormatNoSpaceIfEmpty, parenthesizer.parenthesizeElementTypeOfTupleType)
		emitTokenWithComment(SyntaxKindCloseBracketToken, node.elements.end, writePunctuation, node)
	}

	emitNamedTupleMember := func(node NamedTupleMember) {
		emit(node.dotDotDotToken)
		emit(node.name)
		emit(node.questionToken)
		emitTokenWithComment(SyntaxKindColonToken, node.name.end, writePunctuation, node)
		writeSpace()
		emit(node.type_)
	}

	emitOptionalType := func(node OptionalTypeNode) {
		emit(node.type_, parenthesizer.parenthesizeTypeOfOptionalType)
		writePunctuation("?")
	}

	emitUnionType := func(node UnionTypeNode) {
		emitList(node, node.types, ListFormatUnionTypeConstituents, parenthesizer.parenthesizeConstituentTypeOfUnionType)
	}

	emitIntersectionType := func(node IntersectionTypeNode) {
		emitList(node, node.types, ListFormatIntersectionTypeConstituents, parenthesizer.parenthesizeConstituentTypeOfIntersectionType)
	}

	emitConditionalType := func(node ConditionalTypeNode) {
		emit(node.checkType, parenthesizer.parenthesizeCheckTypeOfConditionalType)
		writeSpace()
		writeKeyword("extends")
		writeSpace()
		emit(node.extendsType, parenthesizer.parenthesizeExtendsTypeOfConditionalType)
		writeSpace()
		writePunctuation("?")
		writeSpace()
		emit(node.trueType)
		writeSpace()
		writePunctuation(":")
		writeSpace()
		emit(node.falseType)
	}

	emitInferType := func(node InferTypeNode) {
		writeKeyword("infer")
		writeSpace()
		emit(node.typeParameter)
	}

	emitParenthesizedType := func(node ParenthesizedTypeNode) {
		writePunctuation("(")
		emit(node.type_)
		writePunctuation(")")
	}

	emitThisType := func() {
		writeKeyword("this")
	}

	emitTypeOperator := func(node TypeOperatorNode) {
		writeTokenText(node.operator, writeKeyword)
		writeSpace()

		var parenthesizerRule /* TODO(TS-TO-GO) inferred type (type: TypeNode) => TypeNode */ any
		if node.operator == SyntaxKindReadonlyKeyword {
			parenthesizerRule = parenthesizer.parenthesizeOperandOfReadonlyTypeOperator
		} else {
			parenthesizerRule = parenthesizer.parenthesizeOperandOfTypeOperator
		}
		emit(node.type_, parenthesizerRule)
	}

	emitIndexedAccessType := func(node IndexedAccessTypeNode) {
		emit(node.objectType, parenthesizer.parenthesizeNonArrayTypeOfPostfixType)
		writePunctuation("[")
		emit(node.indexType)
		writePunctuation("]")
	}

	emitMappedType := func(node MappedTypeNode) {
		emitFlags := getEmitFlags(node)
		writePunctuation("{")
		if emitFlags & EmitFlagsSingleLine {
			writeSpace()
		} else {
			writeLine()
			increaseIndent()
		}
		if node.readonlyToken {
			emit(node.readonlyToken)
			if node.readonlyToken.kind != SyntaxKindReadonlyKeyword {
				writeKeyword("readonly")
			}
			writeSpace()
		}
		writePunctuation("[")

		pipelineEmit(EmitHintMappedTypeParameter, node.typeParameter)
		if node.nameType {
			writeSpace()
			writeKeyword("as")
			writeSpace()
			emit(node.nameType)
		}

		writePunctuation("]")
		if node.questionToken {
			emit(node.questionToken)
			if node.questionToken.kind != SyntaxKindQuestionToken {
				writePunctuation("?")
			}
		}
		writePunctuation(":")
		writeSpace()
		emit(node.type_)
		writeTrailingSemicolon()
		if emitFlags & EmitFlagsSingleLine {
			writeSpace()
		} else {
			writeLine()
			decreaseIndent()
		}
		emitList(node, node.members, ListFormatPreserveLines)
		writePunctuation("}")
	}

	emitLiteralType := func(node LiteralTypeNode) {
		emitExpression(node.literal)
	}

	emitTemplateType := func(node TemplateLiteralTypeNode) {
		emit(node.head)
		emitList(node, node.templateSpans, ListFormatTemplateExpressionSpans)
	}

	emitImportTypeNode := func(node ImportTypeNode) {
		if node.isTypeOf {
			writeKeyword("typeof")
			writeSpace()
		}
		writeKeyword("import")
		writePunctuation("(")
		emit(node.argument)
		if node.attributes {
			writePunctuation(",")
			writeSpace()
			pipelineEmit(EmitHintImportTypeNodeAttributes, node.attributes)
		}
		writePunctuation(")")
		if node.qualifier {
			writePunctuation(".")
			emit(node.qualifier)
		}
		emitTypeArguments(node, node.typeArguments)
	}

	//
	// Binding patterns
	//

	emitObjectBindingPattern := func(node ObjectBindingPattern) {
		writePunctuation("{")
		emitList(node, node.elements, ListFormatObjectBindingPatternElements)
		writePunctuation("}")
	}

	emitArrayBindingPattern := func(node ArrayBindingPattern) {
		writePunctuation("[")
		emitList(node, node.elements, ListFormatArrayBindingPatternElements)
		writePunctuation("]")
	}

	emitBindingElement := func(node BindingElement) {
		emit(node.dotDotDotToken)
		if node.propertyName {
			emit(node.propertyName)
			writePunctuation(":")
			writeSpace()
		}
		emit(node.name)
		emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	//
	// Expressions
	//

	emitArrayLiteralExpression := func(node ArrayLiteralExpression) {
		elements := node.elements
		var preferNewLine /* TODO(TS-TO-GO) inferred type ts.ListFormat.None | ts.ListFormat.PreferNewLine */ any
		if node.multiLine {
			preferNewLine = ListFormatPreferNewLine
		} else {
			preferNewLine = ListFormatNone
		}
		emitExpressionList(node, elements, ListFormatArrayLiteralExpressionElements|preferNewLine, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	emitObjectLiteralExpression := func(node ObjectLiteralExpression) {
		pushNameGenerationScope(node)
		forEach(node.properties, generateMemberNames)

		indentedFlag := getEmitFlags(node) & EmitFlagsIndented
		if indentedFlag {
			increaseIndent()
		}

		var preferNewLine /* TODO(TS-TO-GO) inferred type ts.ListFormat.None | ts.ListFormat.PreferNewLine */ any
		if node.multiLine {
			preferNewLine = ListFormatPreferNewLine
		} else {
			preferNewLine = ListFormatNone
		}
		var allowTrailingComma /* TODO(TS-TO-GO) inferred type ts.ListFormat.None | ts.ListFormat.AllowTrailingComma */ any
		if currentSourceFile && currentSourceFile.languageVersion >= ScriptTargetES5 && !isJsonSourceFile(currentSourceFile) {
			allowTrailingComma = ListFormatAllowTrailingComma
		} else {
			allowTrailingComma = ListFormatNone
		}
		emitList(node, node.properties, ListFormatObjectLiteralExpressionProperties|allowTrailingComma|preferNewLine)

		if indentedFlag {
			decreaseIndent()
		}

		popNameGenerationScope(node)
	}

	emitPropertyAccessExpression := func(node PropertyAccessExpression) {
		emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess)
		token := node.questionDotToken || setTextRangePosEnd(factory.createToken(SyntaxKindDotToken).(DotToken), node.expression.end, node.name.pos)
		linesBeforeDot := getLinesBetweenNodes(node, node.expression, token)
		linesAfterDot := getLinesBetweenNodes(node, token, node.name)

		writeLinesAndIndent(linesBeforeDot /*writeSpaceIfNotIndenting*/, false)

		shouldEmitDotDot := token.kind != SyntaxKindQuestionDotToken && mayNeedDotDotForPropertyAccess(node.expression) && !writer.hasTrailingComment() && !writer.hasTrailingWhitespace()

		if shouldEmitDotDot {
			writePunctuation(".")
		}

		if node.questionDotToken {
			emit(token)
		} else {
			emitTokenWithComment(token.kind, node.expression.end, writePunctuation, node)
		}
		writeLinesAndIndent(linesAfterDot /*writeSpaceIfNotIndenting*/, false)
		emit(node.name)
		decreaseIndentIf(linesBeforeDot, linesAfterDot)
	}

	// 1..toString is a valid property access, emit a dot after the literal
	// Also emit a dot if expression is a integer const enum value - it will appear in generated code as numeric literal
	mayNeedDotDotForPropertyAccess := func(expression Expression) *bool {
		expression = skipPartiallyEmittedExpressions(expression)
		if isNumericLiteral(expression) {
			// check if numeric literal is a decimal literal that was originally written with a dot
			text := getLiteralTextOfNode(expression.(LiteralExpression) /*sourceFile*/, nil /*neverAsciiEscape*/, true /*jsxAttributeEscape*/, false)
			// If the number will be printed verbatim and it doesn't already contain a dot or an exponent indicator, add one
			// if the expression doesn't have any comments that will be emitted.
			return !(expression.numericLiteralFlags & TokenFlagsWithSpecifier) && !text.includes(tokenToString(SyntaxKindDotToken)) && !text.includes(String.fromCharCode(CharacterCodesE)) && !text.includes(String.fromCharCode(CharacterCodese))
		} else if isAccessExpression(expression) {
			// check if constant enum value is a non-negative integer
			constantValue := getConstantValue(expression)
			// isFinite handles cases when constantValue is undefined
			return /* TODO(TS-TO-GO) Node TypeOfExpression: typeof constantValue */ TODO == "number" && isFinite(constantValue) && constantValue >= 0 && Math.floor(constantValue) == constantValue
		}
	}

	emitElementAccessExpression := func(node ElementAccessExpression) {
		emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess)
		emit(node.questionDotToken)
		emitTokenWithComment(SyntaxKindOpenBracketToken, node.expression.end, writePunctuation, node)
		emitExpression(node.argumentExpression)
		emitTokenWithComment(SyntaxKindCloseBracketToken, node.argumentExpression.end, writePunctuation, node)
	}

	emitCallExpression := func(node CallExpression) {
		indirectCall := getInternalEmitFlags(node) & InternalEmitFlagsIndirectCall
		if indirectCall {
			writePunctuation("(")
			writeLiteral("0")
			writePunctuation(",")
			writeSpace()
		}
		emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess)
		if indirectCall {
			writePunctuation(")")
		}
		emit(node.questionDotToken)
		emitTypeArguments(node, node.typeArguments)
		emitExpressionList(node, node.arguments, ListFormatCallExpressionArguments, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	emitNewExpression := func(node NewExpression) {
		emitTokenWithComment(SyntaxKindNewKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfNew)
		emitTypeArguments(node, node.typeArguments)
		emitExpressionList(node, node.arguments, ListFormatNewExpressionArguments, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	emitTaggedTemplateExpression := func(node TaggedTemplateExpression) {
		indirectCall := getInternalEmitFlags(node) & InternalEmitFlagsIndirectCall
		if indirectCall {
			writePunctuation("(")
			writeLiteral("0")
			writePunctuation(",")
			writeSpace()
		}
		emitExpression(node.tag, parenthesizer.parenthesizeLeftSideOfAccess)
		if indirectCall {
			writePunctuation(")")
		}
		emitTypeArguments(node, node.typeArguments)
		writeSpace()
		emitExpression(node.template)
	}

	emitTypeAssertionExpression := func(node TypeAssertion) {
		writePunctuation("<")
		emit(node.type_)
		writePunctuation(">")
		emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary)
	}

	emitParenthesizedExpression := func(node ParenthesizedExpression) {
		openParenPos := emitTokenWithComment(SyntaxKindOpenParenToken, node.pos, writePunctuation, node)
		indented := writeLineSeparatorsAndIndentBefore(node.expression, node)
		emitExpression(node.expression /*parenthesizerRule*/, nil)
		writeLineSeparatorsAfter(node.expression, node)
		decreaseIndentIf(indented)
		emitTokenWithComment(SyntaxKindCloseParenToken, ifelse(node.expression, node.expression.end, openParenPos), writePunctuation, node)
	}

	emitFunctionExpression := func(node FunctionExpression) {
		generateNameIfNeeded(node.name)
		emitFunctionDeclarationOrExpression(node)
	}

	emitArrowFunction := func(node ArrowFunction) {
		emitModifierList(node, node.modifiers)
		emitSignatureAndBody(node, emitArrowFunctionHead, emitArrowFunctionBody)
	}

	emitArrowFunctionHead := func(node ArrowFunction) {
		emitTypeParameters(node, node.typeParameters)
		emitParametersForArrow(node, node.parameters)
		emitTypeAnnotation(node.type_)
		writeSpace()
		emit(node.equalsGreaterThanToken)
	}

	emitArrowFunctionBody := func(node ArrowFunction) {
		if isBlock(node.body) {
			emitBlockFunctionBody(node.body)
		} else {
			writeSpace()
			emitExpression(node.body, parenthesizer.parenthesizeConciseBodyOfArrowFunction)
		}
	}

	emitDeleteExpression := func(node DeleteExpression) {
		emitTokenWithComment(SyntaxKindDeleteKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary)
	}

	emitTypeOfExpression := func(node TypeOfExpression) {
		emitTokenWithComment(SyntaxKindTypeOfKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary)
	}

	emitVoidExpression := func(node VoidExpression) {
		emitTokenWithComment(SyntaxKindVoidKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary)
	}

	emitAwaitExpression := func(node AwaitExpression) {
		emitTokenWithComment(SyntaxKindAwaitKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression, parenthesizer.parenthesizeOperandOfPrefixUnary)
	}

	emitPrefixUnaryExpression := func(node PrefixUnaryExpression) {
		writeTokenText(node.operator, writeOperator)
		if shouldEmitWhitespaceBeforeOperand(node) {
			writeSpace()
		}
		emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPrefixUnary)
	}

	shouldEmitWhitespaceBeforeOperand := func(node PrefixUnaryExpression) bool {
		// In some cases, we need to emit a space between the operator and the operand. One obvious case
		// is when the operator is an identifier, like delete or typeof. We also need to do this for plus
		// and minus expressions in certain cases. Specifically, consider the following two cases (parens
		// are just for clarity of exposition, and not part of the source code):
		//
		//  (+(+1))
		//  (+(++1))
		//
		// We need to emit a space in both cases. In the first case, the absence of a space will make
		// the resulting expression a prefix increment operation. And in the second, it will make the resulting
		// expression a prefix increment whose operand is a plus expression - (++(+x))
		// The same is true of minus of course.
		operand := node.operand
		return operand.kind == SyntaxKindPrefixUnaryExpression && ((node.operator == SyntaxKindPlusToken && ((operand.(PrefixUnaryExpression)).operator == SyntaxKindPlusToken || (operand.(PrefixUnaryExpression)).operator == SyntaxKindPlusPlusToken)) || (node.operator == SyntaxKindMinusToken && ((operand.(PrefixUnaryExpression)).operator == SyntaxKindMinusToken || (operand.(PrefixUnaryExpression)).operator == SyntaxKindMinusMinusToken)))
	}

	emitPostfixUnaryExpression := func(node PostfixUnaryExpression) {
		emitExpression(node.operand, parenthesizer.parenthesizeOperandOfPostfixUnary)
		writeTokenText(node.operator, writeOperator)
	}

	createEmitBinaryExpression := func() /* TODO(TS-TO-GO) inferred type (node: BinaryExpression) => void */ any {
		type WorkArea struct {
			stackIndex                       number
			preserveSourceNewlinesStack      []*bool
			containerPosStack                []number
			containerEndStack                []number
			declarationListContainerEndStack []number
			shouldEmitCommentsStack          []bool
			shouldEmitSourceMapsStack        []bool
		}

		return createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit /*foldState*/, nil)

		onEnter := func(node BinaryExpression, state *WorkArea) WorkArea {
			if state {
				state.stackIndex++
				state.preserveSourceNewlinesStack[state.stackIndex] = preserveSourceNewlines
				state.containerPosStack[state.stackIndex] = containerPos
				state.containerEndStack[state.stackIndex] = containerEnd
				state.declarationListContainerEndStack[state.stackIndex] = declarationListContainerEnd
				emitComments := /* TODO(TS-TO-GO) EqualsToken BinaryExpression: state.shouldEmitCommentsStack[state.stackIndex] = shouldEmitComments(node) */ TODO
				emitSourceMaps := /* TODO(TS-TO-GO) EqualsToken BinaryExpression: state.shouldEmitSourceMapsStack[state.stackIndex] = shouldEmitSourceMaps(node) */ TODO
				onBeforeEmitNode(node)
				if emitComments {
					emitCommentsBeforeNode(node)
				}
				if emitSourceMaps {
					emitSourceMapsBeforeNode(node)
				}
				beforeEmitNode(node)
			} else {
				state = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"stackIndex":                       0,
					"preserveSourceNewlinesStack":      []undefined{nil},
					"containerPosStack":                []number{-1},
					"containerEndStack":                []number{-1},
					"declarationListContainerEndStack": []number{-1},
					"shouldEmitCommentsStack":          []false{false},
					"shouldEmitSourceMapsStack":        []false{false},
				}
			}
			return state
		}

		onLeft := func(next Expression, _workArea WorkArea, parent BinaryExpression) * /* TODO(TS-TO-GO) inferred type ts.BinaryExpression */ any {
			return maybeEmitExpression(next, parent, "left")
		}

		onOperator := func(operatorToken BinaryOperatorToken, _state WorkArea, node BinaryExpression) {
			isCommaOperator := operatorToken.kind != SyntaxKindCommaToken
			linesBeforeOperator := getLinesBetweenNodes(node, node.left, operatorToken)
			linesAfterOperator := getLinesBetweenNodes(node, operatorToken, node.right)
			writeLinesAndIndent(linesBeforeOperator, isCommaOperator)
			emitLeadingCommentsOfPosition(operatorToken.pos)
			writeTokenNode(operatorToken, ifelse(operatorToken.kind == SyntaxKindInKeyword, writeKeyword, writeOperator))
			emitTrailingCommentsOfPosition(operatorToken.end /*prefixSpace*/, true)
			// Binary operators should have a space before the comment starts
			writeLinesAndIndent(linesAfterOperator /*writeSpaceIfNotIndenting*/, true)
		}

		onRight := func(next Expression, _workArea WorkArea, parent BinaryExpression) * /* TODO(TS-TO-GO) inferred type ts.BinaryExpression */ any {
			return maybeEmitExpression(next, parent, "right")
		}

		onExit := func(node BinaryExpression, state WorkArea) {
			linesBeforeOperator := getLinesBetweenNodes(node, node.left, node.operatorToken)
			linesAfterOperator := getLinesBetweenNodes(node, node.operatorToken, node.right)
			decreaseIndentIf(linesBeforeOperator, linesAfterOperator)
			if state.stackIndex > 0 {
				savedPreserveSourceNewlines := state.preserveSourceNewlinesStack[state.stackIndex]
				savedContainerPos := state.containerPosStack[state.stackIndex]
				savedContainerEnd := state.containerEndStack[state.stackIndex]
				savedDeclarationListContainerEnd := state.declarationListContainerEndStack[state.stackIndex]
				shouldEmitComments := state.shouldEmitCommentsStack[state.stackIndex]
				shouldEmitSourceMaps := state.shouldEmitSourceMapsStack[state.stackIndex]
				afterEmitNode(savedPreserveSourceNewlines)
				if shouldEmitSourceMaps {
					emitSourceMapsAfterNode(node)
				}
				if shouldEmitComments {
					emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
				}
				onAfterEmitNode(node)
				state.stackIndex--
			}
		}

		maybeEmitExpression := func(next Expression, parent BinaryExpression, side /* TODO(TS-TO-GO) TypeNode UnionType: "left" | "right" */ any) * /* TODO(TS-TO-GO) inferred type ts.BinaryExpression */ any {
			var parenthesizerRule /* TODO(TS-TO-GO) inferred type (leftSide: Expression) => Expression */ any
			if side == "left" {
				parenthesizerRule = parenthesizer.getParenthesizeLeftSideOfBinaryForOperator(parent.operatorToken.kind)
			} else {
				parenthesizerRule = parenthesizer.getParenthesizeRightSideOfBinaryForOperator(parent.operatorToken.kind)
			}

			pipelinePhase := getPipelinePhase(PipelinePhaseNotification, EmitHintExpression, next)
			if pipelinePhase == pipelineEmitWithSubstitution {
				Debug.assertIsDefined(lastSubstitution)
				next = parenthesizerRule(cast(lastSubstitution, isExpression))
				pipelinePhase = getNextPipelinePhase(PipelinePhaseSubstitution, EmitHintExpression, next)
				lastSubstitution = nil
			}

			if pipelinePhase == pipelineEmitWithComments || pipelinePhase == pipelineEmitWithSourceMaps || pipelinePhase == pipelineEmitWithHint {
				if isBinaryExpression(next) {
					return next
				}
			}

			currentParenthesizerRule = parenthesizerRule
			pipelinePhase(EmitHintExpression, next)
		}

	}

	emitConditionalExpression := func(node ConditionalExpression) {
		linesBeforeQuestion := getLinesBetweenNodes(node, node.condition, node.questionToken)
		linesAfterQuestion := getLinesBetweenNodes(node, node.questionToken, node.whenTrue)
		linesBeforeColon := getLinesBetweenNodes(node, node.whenTrue, node.colonToken)
		linesAfterColon := getLinesBetweenNodes(node, node.colonToken, node.whenFalse)

		emitExpression(node.condition, parenthesizer.parenthesizeConditionOfConditionalExpression)
		writeLinesAndIndent(linesBeforeQuestion /*writeSpaceIfNotIndenting*/, true)
		emit(node.questionToken)
		writeLinesAndIndent(linesAfterQuestion /*writeSpaceIfNotIndenting*/, true)
		emitExpression(node.whenTrue, parenthesizer.parenthesizeBranchOfConditionalExpression)
		decreaseIndentIf(linesBeforeQuestion, linesAfterQuestion)

		writeLinesAndIndent(linesBeforeColon /*writeSpaceIfNotIndenting*/, true)
		emit(node.colonToken)
		writeLinesAndIndent(linesAfterColon /*writeSpaceIfNotIndenting*/, true)
		emitExpression(node.whenFalse, parenthesizer.parenthesizeBranchOfConditionalExpression)
		decreaseIndentIf(linesBeforeColon, linesAfterColon)
	}

	emitTemplateExpression := func(node TemplateExpression) {
		emit(node.head)
		emitList(node, node.templateSpans, ListFormatTemplateExpressionSpans)
	}

	emitYieldExpression := func(node YieldExpression) {
		emitTokenWithComment(SyntaxKindYieldKeyword, node.pos, writeKeyword, node)
		emit(node.asteriskToken)
		emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsiAndDisallowedComma)
	}

	emitSpreadElement := func(node SpreadElement) {
		emitTokenWithComment(SyntaxKindDotDotDotToken, node.pos, writePunctuation, node)
		emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	emitClassExpression := func(node ClassExpression) {
		generateNameIfNeeded(node.name)
		emitClassDeclarationOrExpression(node)
	}

	emitExpressionWithTypeArguments := func(node ExpressionWithTypeArguments) {
		emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess)
		emitTypeArguments(node, node.typeArguments)
	}

	emitAsExpression := func(node AsExpression) {
		emitExpression(node.expression /*parenthesizerRule*/, nil)
		if node.type_ {
			writeSpace()
			writeKeyword("as")
			writeSpace()
			emit(node.type_)
		}
	}

	emitNonNullExpression := func(node NonNullExpression) {
		emitExpression(node.expression, parenthesizer.parenthesizeLeftSideOfAccess)
		writeOperator("!")
	}

	emitSatisfiesExpression := func(node SatisfiesExpression) {
		emitExpression(node.expression /*parenthesizerRule*/, nil)
		if node.type_ {
			writeSpace()
			writeKeyword("satisfies")
			writeSpace()
			emit(node.type_)
		}
	}

	emitMetaProperty := func(node MetaProperty) {
		writeToken(node.keywordToken, node.pos, writePunctuation)
		writePunctuation(".")
		emit(node.name)
	}

	//
	// Misc
	//

	emitTemplateSpan := func(node TemplateSpan) {
		emitExpression(node.expression)
		emit(node.literal)
	}

	//
	// Statements
	//

	emitBlock := func(node Block) {
		emitBlockStatements(node /*forceSingleLine*/, !node.multiLine && isEmptyBlock(node))
	}

	emitBlockStatements := func(node BlockLike, forceSingleLine bool) {
		emitTokenWithComment(SyntaxKindOpenBraceToken, node.pos, writePunctuation /*contextNode*/, node)
		var format /* TODO(TS-TO-GO) inferred type ts.ListFormat.SingleLineTypeLiteralMembers | ts.ListFormat.MultiLineBlockStatements */ any
		if forceSingleLine || getEmitFlags(node)&EmitFlagsSingleLine {
			format = ListFormatSingleLineBlockStatements
		} else {
			format = ListFormatMultiLineBlockStatements
		}
		emitList(node, node.statements, format)
		emitTokenWithComment(SyntaxKindCloseBraceToken, node.statements.end, writePunctuation /*contextNode*/, node /*indentLeading*/, !!(format & ListFormatMultiLine))
	}

	emitVariableStatement := func(node VariableStatement) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		emit(node.declarationList)
		writeTrailingSemicolon()
	}

	emitEmptyStatement := func(isEmbeddedStatement bool) {
		// While most trailing semicolons are possibly insignificant, an embedded "empty"
		// statement is significant and cannot be elided by a trailing-semicolon-omitting writer.
		if isEmbeddedStatement {
			writePunctuation(";")
		} else {
			writeTrailingSemicolon()
		}
	}

	emitExpressionStatement := func(node ExpressionStatement) {
		emitExpression(node.expression, parenthesizer.parenthesizeExpressionOfExpressionStatement)
		// Emit semicolon in non json files
		// or if json file that created synthesized expression(eg.define expression statement when --out and amd code generation)
		if !currentSourceFile || !isJsonSourceFile(currentSourceFile) || nodeIsSynthesized(node.expression) {
			writeTrailingSemicolon()
		}
	}

	emitIfStatement := func(node IfStatement) {
		openParenPos := emitTokenWithComment(SyntaxKindIfKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation, node)
		emitExpression(node.expression)
		emitTokenWithComment(SyntaxKindCloseParenToken, node.expression.end, writePunctuation, node)
		emitEmbeddedStatement(node, node.thenStatement)
		if node.elseStatement {
			writeLineOrSpace(node, node.thenStatement, node.elseStatement)
			emitTokenWithComment(SyntaxKindElseKeyword, node.thenStatement.end, writeKeyword, node)
			if node.elseStatement.kind == SyntaxKindIfStatement {
				writeSpace()
				emit(node.elseStatement)
			} else {
				emitEmbeddedStatement(node, node.elseStatement)
			}
		}
	}

	emitWhileClause := func(node /* TODO(TS-TO-GO) TypeNode UnionType: WhileStatement | DoStatement */ any, startPos number) {
		openParenPos := emitTokenWithComment(SyntaxKindWhileKeyword, startPos, writeKeyword, node)
		writeSpace()
		emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation, node)
		emitExpression(node.expression)
		emitTokenWithComment(SyntaxKindCloseParenToken, node.expression.end, writePunctuation, node)
	}

	emitDoStatement := func(node DoStatement) {
		emitTokenWithComment(SyntaxKindDoKeyword, node.pos, writeKeyword, node)
		emitEmbeddedStatement(node, node.statement)
		if isBlock(node.statement) && !preserveSourceNewlines {
			writeSpace()
		} else {
			writeLineOrSpace(node, node.statement, node.expression)
		}

		emitWhileClause(node, node.statement.end)
		writeTrailingSemicolon()
	}

	emitWhileStatement := func(node WhileStatement) {
		emitWhileClause(node, node.pos)
		emitEmbeddedStatement(node, node.statement)
	}

	emitForStatement := func(node ForStatement) {
		openParenPos := emitTokenWithComment(SyntaxKindForKeyword, node.pos, writeKeyword, node)
		writeSpace()
		pos := emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation /*contextNode*/, node)
		emitForBinding(node.initializer)
		pos = emitTokenWithComment(SyntaxKindSemicolonToken, ifelse(node.initializer, node.initializer.end, pos), writePunctuation, node)
		emitExpressionWithLeadingSpace(node.condition)
		pos = emitTokenWithComment(SyntaxKindSemicolonToken, ifelse(node.condition, node.condition.end, pos), writePunctuation, node)
		emitExpressionWithLeadingSpace(node.incrementor)
		emitTokenWithComment(SyntaxKindCloseParenToken, ifelse(node.incrementor, node.incrementor.end, pos), writePunctuation, node)
		emitEmbeddedStatement(node, node.statement)
	}

	emitForInStatement := func(node ForInStatement) {
		openParenPos := emitTokenWithComment(SyntaxKindForKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation, node)
		emitForBinding(node.initializer)
		writeSpace()
		emitTokenWithComment(SyntaxKindInKeyword, node.initializer.end, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression)
		emitTokenWithComment(SyntaxKindCloseParenToken, node.expression.end, writePunctuation, node)
		emitEmbeddedStatement(node, node.statement)
	}

	emitForOfStatement := func(node ForOfStatement) {
		openParenPos := emitTokenWithComment(SyntaxKindForKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitWithTrailingSpace(node.awaitModifier)
		emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation, node)
		emitForBinding(node.initializer)
		writeSpace()
		emitTokenWithComment(SyntaxKindOfKeyword, node.initializer.end, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression)
		emitTokenWithComment(SyntaxKindCloseParenToken, node.expression.end, writePunctuation, node)
		emitEmbeddedStatement(node, node.statement)
	}

	emitForBinding := func(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclarationList | Expression | undefined */ any) {
		if node != nil {
			if node.kind == SyntaxKindVariableDeclarationList {
				emit(node)
			} else {
				emitExpression(node)
			}
		}
	}

	emitContinueStatement := func(node ContinueStatement) {
		emitTokenWithComment(SyntaxKindContinueKeyword, node.pos, writeKeyword, node)
		emitWithLeadingSpace(node.label)
		writeTrailingSemicolon()
	}

	emitBreakStatement := func(node BreakStatement) {
		emitTokenWithComment(SyntaxKindBreakKeyword, node.pos, writeKeyword, node)
		emitWithLeadingSpace(node.label)
		writeTrailingSemicolon()
	}

	emitTokenWithComment := func(token SyntaxKind, pos number, writer func(s string), contextNode Node, indentLeading bool) number {
		node := getParseTreeNode(contextNode)
		isSimilarNode := node && node.kind == contextNode.kind
		startPos := pos
		if isSimilarNode && currentSourceFile {
			pos = skipTrivia(currentSourceFile.text, pos)
		}
		if isSimilarNode && contextNode.pos != startPos {
			needsIndent := indentLeading && currentSourceFile && !positionsAreOnSameLine(startPos, pos, currentSourceFile)
			if needsIndent {
				increaseIndent()
			}
			emitLeadingCommentsOfPosition(startPos)
			if needsIndent {
				decreaseIndent()
			}
		}

		// We don't emit source positions for most tokens as it tends to be quite noisy, however
		// we need to emit source positions for open and close braces so that tools like istanbul
		// can map branches for code coverage. However, we still omit brace source positions when
		// the output is a declaration file.
		if !omitBraceSourcePositions && (token == SyntaxKindOpenBraceToken || token == SyntaxKindCloseBraceToken) {
			pos = writeToken(token, pos, writer, contextNode)
		} else {
			pos = writeTokenText(token, writer, pos)
		}

		if isSimilarNode && contextNode.end != pos {
			isJsxExprContext := contextNode.kind == SyntaxKindJsxExpression
			emitTrailingCommentsOfPosition(pos /*prefixSpace*/, !isJsxExprContext /*forceNoNewline*/, isJsxExprContext)
		}
		return pos
	}

	commentWillEmitNewLine := func(node CommentRange) bool {
		return node.kind == SyntaxKindSingleLineCommentTrivia || !!node.hasTrailingNewLine
	}

	willEmitLeadingNewLine := func(node Expression) bool {
		if !currentSourceFile {
			return false
		}
		leadingCommentRanges := getLeadingCommentRanges(currentSourceFile.text, node.pos)
		if leadingCommentRanges {
			parseNode := getParseTreeNode(node)
			if parseNode && isParenthesizedExpression(parseNode.parent) {
				return true
			}
		}
		if some(leadingCommentRanges, commentWillEmitNewLine) {
			return true
		}
		if some(getSyntheticLeadingComments(node), commentWillEmitNewLine) {
			return true
		}
		if isPartiallyEmittedExpression(node) {
			if node.pos != node.expression.pos {
				if some(getTrailingCommentRanges(currentSourceFile.text, node.expression.pos), commentWillEmitNewLine) {
					return true
				}
			}
			return willEmitLeadingNewLine(node.expression)
		}
		return false
	}

	/**
	 * Wraps an expression in parens if we would emit a leading comment that would introduce a line separator
	 * between the node and its parent.
	 */

	parenthesizeExpressionForNoAsi := func(node Expression) /* TODO(TS-TO-GO) inferred type ts.Expression */ any {
		if !commentsDisabled && isPartiallyEmittedExpression(node) && willEmitLeadingNewLine(node) {
			parseNode := getParseTreeNode(node)
			if parseNode && isParenthesizedExpression(parseNode) {
				// If the original node was a parenthesized expression, restore it to preserve comment and source map emit
				parens := factory.createParenthesizedExpression(node.expression)
				setOriginalNode(parens, node)
				setTextRange(parens, parseNode)
				return parens
			}
			return factory.createParenthesizedExpression(node)
		}
		return node
	}

	parenthesizeExpressionForNoAsiAndDisallowedComma := func(node Expression) /* TODO(TS-TO-GO) inferred type ts.Expression */ any {
		return parenthesizeExpressionForNoAsi(parenthesizer.parenthesizeExpressionForDisallowedComma(node))
	}

	emitReturnStatement := func(node ReturnStatement) {
		emitTokenWithComment(SyntaxKindReturnKeyword, node.pos, writeKeyword /*contextNode*/, node)
		emitExpressionWithLeadingSpace(node.expression && parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi)
		writeTrailingSemicolon()
	}

	emitWithStatement := func(node WithStatement) {
		openParenPos := emitTokenWithComment(SyntaxKindWithKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation, node)
		emitExpression(node.expression)
		emitTokenWithComment(SyntaxKindCloseParenToken, node.expression.end, writePunctuation, node)
		emitEmbeddedStatement(node, node.statement)
	}

	emitSwitchStatement := func(node SwitchStatement) {
		openParenPos := emitTokenWithComment(SyntaxKindSwitchKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation, node)
		emitExpression(node.expression)
		emitTokenWithComment(SyntaxKindCloseParenToken, node.expression.end, writePunctuation, node)
		writeSpace()
		emit(node.caseBlock)
	}

	emitLabeledStatement := func(node LabeledStatement) {
		emit(node.label)
		emitTokenWithComment(SyntaxKindColonToken, node.label.end, writePunctuation, node)
		writeSpace()
		emit(node.statement)
	}

	emitThrowStatement := func(node ThrowStatement) {
		emitTokenWithComment(SyntaxKindThrowKeyword, node.pos, writeKeyword, node)
		emitExpressionWithLeadingSpace(parenthesizeExpressionForNoAsi(node.expression), parenthesizeExpressionForNoAsi)
		writeTrailingSemicolon()
	}

	emitTryStatement := func(node TryStatement) {
		emitTokenWithComment(SyntaxKindTryKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emit(node.tryBlock)
		if node.catchClause {
			writeLineOrSpace(node, node.tryBlock, node.catchClause)
			emit(node.catchClause)
		}
		if node.finallyBlock {
			writeLineOrSpace(node, node.catchClause || node.tryBlock, node.finallyBlock)
			emitTokenWithComment(SyntaxKindFinallyKeyword, (node.catchClause || node.tryBlock).end, writeKeyword, node)
			writeSpace()
			emit(node.finallyBlock)
		}
	}

	emitDebuggerStatement := func(node DebuggerStatement) {
		writeToken(SyntaxKindDebuggerKeyword, node.pos, writeKeyword)
		writeTrailingSemicolon()
	}

	//
	// Declarations
	//

	emitVariableDeclaration := func(node VariableDeclaration) {
		emit(node.name)
		emit(node.exclamationToken)
		emitTypeAnnotation(node.type_)
		emitInitializer(node.initializer /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: node.type?.end ?? node.name.emitNode?.typeNode?.end ?? node.name.end */, TODO, node, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	emitVariableDeclarationList := func(node VariableDeclarationList) {
		if isVarAwaitUsing(node) {
			writeKeyword("await")
			writeSpace()
			writeKeyword("using")
		} else {
			var head /* TODO(TS-TO-GO) inferred type "using" | "const" | "let" | "var" */ any
			switch {
			case isLet(node):
				head = "let"
			case isVarConst(node):
				head = "const"
			case isVarUsing(node):
				head = "using"
			default:
				head = "var"
			}
			writeKeyword(head)
		}
		writeSpace()
		emitList(node, node.declarations, ListFormatVariableDeclarationList)
	}

	emitFunctionDeclaration := func(node FunctionDeclaration) {
		emitFunctionDeclarationOrExpression(node)
	}

	emitFunctionDeclarationOrExpression := func(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionDeclaration | FunctionExpression */ any) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		writeKeyword("function")
		emit(node.asteriskToken)
		writeSpace()
		emitIdentifierName(node.name)
		emitSignatureAndBody(node, emitSignatureHead, emitFunctionBody)
	}

	emitSignatureAndBody := func(node T, emitSignatureHead func(node T), emitBody func(node T)) {
		indentedFlag := getEmitFlags(node) & EmitFlagsIndented
		if indentedFlag {
			increaseIndent()
		}

		pushNameGenerationScope(node)
		forEach(node.parameters, generateNames)
		emitSignatureHead(node)
		emitBody(node)
		popNameGenerationScope(node)

		if indentedFlag {
			decreaseIndent()
		}
	}

	emitFunctionBody := func(node T) {
		body := node.body
		if body {
			emitBlockFunctionBody(body)
		} else {
			writeTrailingSemicolon()
		}
	}

	emitEmptyFunctionBody := func(_node SignatureDeclaration) {
		writeTrailingSemicolon()
	}

	emitSignatureHead := func(node SignatureDeclaration) {
		emitTypeParameters(node, node.typeParameters)
		emitParameters(node, node.parameters)
		emitTypeAnnotation(node.type_)
	}

	shouldEmitBlockFunctionBodyOnSingleLine := func(body Block) bool {
		// We must emit a function body as a single-line body in the following case:
		// * The body has NodeEmitFlags.SingleLine specified.

		// We must emit a function body as a multi-line body in the following cases:
		// * The body is explicitly marked as multi-line.
		// * A non-synthesized body's start and end position are on different lines.
		// * Any statement in the body starts on a new line.

		if getEmitFlags(body) & EmitFlagsSingleLine {
			return true
		}

		if body.multiLine {
			return false
		}

		if !nodeIsSynthesized(body) && currentSourceFile && !rangeIsOnSingleLine(body, currentSourceFile) {
			return false
		}

		if getLeadingLineTerminatorCount(body, firstOrUndefined(body.statements), ListFormatPreserveLines) || getClosingLineTerminatorCount(body, lastOrUndefined(body.statements), ListFormatPreserveLines, body.statements) {
			return false
		}

		var previousStatement Statement
		for _, statement := range body.statements {
			if getSeparatingLineTerminatorCount(previousStatement, statement, ListFormatPreserveLines) > 0 {
				return false
			}

			previousStatement = statement
		}

		return true
	}

	emitBlockFunctionBody := func(body Block) {
		generateNames(body)
		onBeforeEmitNode(body)
		writeSpace()
		writePunctuation("{")
		increaseIndent()

		var emitBlockFunctionBody /* TODO(TS-TO-GO) inferred type (body: Block, emitBlockFunctionBodyOnSingleLine?: boolean) => void */ any
		if shouldEmitBlockFunctionBodyOnSingleLine(body) {
			emitBlockFunctionBody = emitBlockFunctionBodyOnSingleLine
		} else {
			emitBlockFunctionBody = emitBlockFunctionBodyWorker
		}

		emitBodyWithDetachedComments(body, body.statements, emitBlockFunctionBody)

		decreaseIndent()
		writeToken(SyntaxKindCloseBraceToken, body.statements.end, writePunctuation, body)
		onAfterEmitNode(body)
	}

	emitBlockFunctionBodyOnSingleLine := func(body Block) {
		emitBlockFunctionBodyWorker(body /*emitBlockFunctionBodyOnSingleLine*/, true)
	}

	emitBlockFunctionBodyWorker := func(body Block, emitBlockFunctionBodyOnSingleLine bool) {
		// Emit all the prologue directives (like "use strict").
		statementOffset := emitPrologueDirectives(body.statements)
		pos := writer.getTextPos()
		emitHelpers(body)
		if statementOffset == 0 && pos == writer.getTextPos() && emitBlockFunctionBodyOnSingleLine {
			decreaseIndent()
			emitList(body, body.statements, ListFormatSingleLineFunctionBodyStatements)
			increaseIndent()
		} else {
			emitList(body, body.statements, ListFormatMultiLineFunctionBodyStatements /*parenthesizerRule*/, nil, statementOffset)
		}
	}

	emitClassDeclaration := func(node ClassDeclaration) {
		emitClassDeclarationOrExpression(node)
	}

	emitClassDeclarationOrExpression := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassDeclaration | ClassExpression */ any) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, true)
		emitTokenWithComment(SyntaxKindClassKeyword, moveRangePastModifiers(node).pos, writeKeyword, node)
		if node.name {
			writeSpace()
			emitIdentifierName(node.name)
		}

		indentedFlag := getEmitFlags(node) & EmitFlagsIndented
		if indentedFlag {
			increaseIndent()
		}

		emitTypeParameters(node, node.typeParameters)
		emitList(node, node.heritageClauses, ListFormatClassHeritageClauses)
		writeSpace()
		writePunctuation("{")

		pushNameGenerationScope(node)
		forEach(node.members, generateMemberNames)
		emitList(node, node.members, ListFormatClassMembers)
		popNameGenerationScope(node)

		writePunctuation("}")

		if indentedFlag {
			decreaseIndent()
		}
	}

	emitInterfaceDeclaration := func(node InterfaceDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		writeKeyword("interface")
		writeSpace()
		emit(node.name)
		emitTypeParameters(node, node.typeParameters)
		emitList(node, node.heritageClauses, ListFormatHeritageClauses)
		writeSpace()
		writePunctuation("{")

		pushNameGenerationScope(node)
		forEach(node.members, generateMemberNames)
		emitList(node, node.members, ListFormatInterfaceMembers)
		popNameGenerationScope(node)

		writePunctuation("}")
	}

	emitTypeAliasDeclaration := func(node TypeAliasDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		writeKeyword("type")
		writeSpace()
		emit(node.name)
		emitTypeParameters(node, node.typeParameters)
		writeSpace()
		writePunctuation("=")
		writeSpace()
		emit(node.type_)
		writeTrailingSemicolon()
	}

	emitEnumDeclaration := func(node EnumDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		writeKeyword("enum")
		writeSpace()
		emit(node.name)

		writeSpace()
		writePunctuation("{")
		emitList(node, node.members, ListFormatEnumMembers)
		writePunctuation("}")
	}

	emitModuleDeclaration := func(node ModuleDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		if ~node.flags & NodeFlagsGlobalAugmentation {
			writeKeyword(ifelse(node.flags&NodeFlagsNamespace, "namespace", "module"))
			writeSpace()
		}
		emit(node.name)

		body := node.body
		if !body {
			return writeTrailingSemicolon()
		}
		for body && isModuleDeclaration(body) {
			writePunctuation(".")
			emit(body.name)
			body = body.body
		}

		writeSpace()
		emit(body)
	}

	emitModuleBlock := func(node ModuleBlock) {
		pushNameGenerationScope(node)
		forEach(node.statements, generateNames)
		emitBlockStatements(node /*forceSingleLine*/, isEmptyBlock(node))
		popNameGenerationScope(node)
	}

	emitCaseBlock := func(node CaseBlock) {
		emitTokenWithComment(SyntaxKindOpenBraceToken, node.pos, writePunctuation, node)
		emitList(node, node.clauses, ListFormatCaseBlockClauses)
		emitTokenWithComment(SyntaxKindCloseBraceToken, node.clauses.end, writePunctuation, node /*indentLeading*/, true)
	}

	emitImportEqualsDeclaration := func(node ImportEqualsDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		emitTokenWithComment(SyntaxKindImportKeyword, ifelse(node.modifiers, node.modifiers.end, node.pos), writeKeyword, node)
		writeSpace()
		if node.isTypeOnly {
			emitTokenWithComment(SyntaxKindTypeKeyword, node.pos, writeKeyword, node)
			writeSpace()
		}
		emit(node.name)
		writeSpace()
		emitTokenWithComment(SyntaxKindEqualsToken, node.name.end, writePunctuation, node)
		writeSpace()
		emitModuleReference(node.moduleReference)
		writeTrailingSemicolon()
	}

	emitModuleReference := func(node ModuleReference) {
		if node.kind == SyntaxKindIdentifier {
			emitExpression(node)
		} else {
			emit(node)
		}
	}

	emitImportDeclaration := func(node ImportDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		emitTokenWithComment(SyntaxKindImportKeyword, ifelse(node.modifiers, node.modifiers.end, node.pos), writeKeyword, node)
		writeSpace()
		if node.importClause {
			emit(node.importClause)
			writeSpace()
			emitTokenWithComment(SyntaxKindFromKeyword, node.importClause.end, writeKeyword, node)
			writeSpace()
		}
		emitExpression(node.moduleSpecifier)
		if node.attributes {
			emitWithLeadingSpace(node.attributes)
		}
		writeTrailingSemicolon()
	}

	emitImportClause := func(node ImportClause) {
		if node.isTypeOnly {
			emitTokenWithComment(SyntaxKindTypeKeyword, node.pos, writeKeyword, node)
			writeSpace()
		}
		emit(node.name)
		if node.name && node.namedBindings {
			emitTokenWithComment(SyntaxKindCommaToken, node.name.end, writePunctuation, node)
			writeSpace()
		}
		emit(node.namedBindings)
	}

	emitNamespaceImport := func(node NamespaceImport) {
		asPos := emitTokenWithComment(SyntaxKindAsteriskToken, node.pos, writePunctuation, node)
		writeSpace()
		emitTokenWithComment(SyntaxKindAsKeyword, asPos, writeKeyword, node)
		writeSpace()
		emit(node.name)
	}

	emitNamedImports := func(node NamedImports) {
		emitNamedImportsOrExports(node)
	}

	emitImportSpecifier := func(node ImportSpecifier) {
		emitImportOrExportSpecifier(node)
	}

	emitExportAssignment := func(node ExportAssignment) {
		nextPos := emitTokenWithComment(SyntaxKindExportKeyword, node.pos, writeKeyword, node)
		writeSpace()
		if node.isExportEquals {
			emitTokenWithComment(SyntaxKindEqualsToken, nextPos, writeOperator, node)
		} else {
			emitTokenWithComment(SyntaxKindDefaultKeyword, nextPos, writeKeyword, node)
		}
		writeSpace()
		emitExpression(node.expression, ifelse(node.isExportEquals, parenthesizer.getParenthesizeRightSideOfBinaryForOperator(SyntaxKindEqualsToken), parenthesizer.parenthesizeExpressionOfExportDefault))
		writeTrailingSemicolon()
	}

	emitExportDeclaration := func(node ExportDeclaration) {
		emitDecoratorsAndModifiers(node, node.modifiers /*allowDecorators*/, false)
		nextPos := emitTokenWithComment(SyntaxKindExportKeyword, node.pos, writeKeyword, node)
		writeSpace()
		if node.isTypeOnly {
			nextPos = emitTokenWithComment(SyntaxKindTypeKeyword, nextPos, writeKeyword, node)
			writeSpace()
		}
		if node.exportClause {
			emit(node.exportClause)
		} else {
			nextPos = emitTokenWithComment(SyntaxKindAsteriskToken, nextPos, writePunctuation, node)
		}
		if node.moduleSpecifier {
			writeSpace()
			var fromPos number
			if node.exportClause {
				fromPos = node.exportClause.end
			} else {
				fromPos = nextPos
			}
			emitTokenWithComment(SyntaxKindFromKeyword, fromPos, writeKeyword, node)
			writeSpace()
			emitExpression(node.moduleSpecifier)
		}
		if node.attributes {
			emitWithLeadingSpace(node.attributes)
		}
		writeTrailingSemicolon()
	}

	emitImportTypeNodeAttributes := func(node ImportAttributes) {
		writePunctuation("{")
		writeSpace()
		writeKeyword(ifelse(node.token == SyntaxKindAssertKeyword, "assert", "with"))
		writePunctuation(":")
		writeSpace()
		elements := node.elements
		emitList(node, elements, ListFormatImportAttributes)
		writeSpace()
		writePunctuation("}")
	}

	emitImportAttributes := func(node ImportAttributes) {
		emitTokenWithComment(node.token, node.pos, writeKeyword, node)
		writeSpace()
		elements := node.elements
		emitList(node, elements, ListFormatImportAttributes)
	}

	emitImportAttribute := func(node ImportAttribute) {
		emit(node.name)
		writePunctuation(":")
		writeSpace()

		value := node.value
		/** @see {emitPropertyAssignment} */

		if (getEmitFlags(value) & EmitFlagsNoLeadingComments) == 0 {
			commentRange := getCommentRange(value)
			emitTrailingCommentsOfPosition(commentRange.pos)
		}
		emit(value)
	}

	emitNamespaceExportDeclaration := func(node NamespaceExportDeclaration) {
		nextPos := emitTokenWithComment(SyntaxKindExportKeyword, node.pos, writeKeyword, node)
		writeSpace()
		nextPos = emitTokenWithComment(SyntaxKindAsKeyword, nextPos, writeKeyword, node)
		writeSpace()
		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		nextPos = emitTokenWithComment(SyntaxKindNamespaceKeyword, nextPos, writeKeyword, node)
		writeSpace()
		emit(node.name)
		writeTrailingSemicolon()
	}

	emitNamespaceExport := func(node NamespaceExport) {
		asPos := emitTokenWithComment(SyntaxKindAsteriskToken, node.pos, writePunctuation, node)
		writeSpace()
		emitTokenWithComment(SyntaxKindAsKeyword, asPos, writeKeyword, node)
		writeSpace()
		emit(node.name)
	}

	emitNamedExports := func(node NamedExports) {
		emitNamedImportsOrExports(node)
	}

	emitExportSpecifier := func(node ExportSpecifier) {
		emitImportOrExportSpecifier(node)
	}

	emitNamedImportsOrExports := func(node NamedImportsOrExports) {
		writePunctuation("{")
		emitList(node, node.elements, ListFormatNamedImportsOrExportsElements)
		writePunctuation("}")
	}

	emitImportOrExportSpecifier := func(node ImportOrExportSpecifier) {
		if node.isTypeOnly {
			writeKeyword("type")
			writeSpace()
		}
		if node.propertyName {
			emit(node.propertyName)
			writeSpace()
			emitTokenWithComment(SyntaxKindAsKeyword, node.propertyName.end, writeKeyword, node)
			writeSpace()
		}

		emit(node.name)
	}

	//
	// Module references
	//

	emitExternalModuleReference := func(node ExternalModuleReference) {
		writeKeyword("require")
		writePunctuation("(")
		emitExpression(node.expression)
		writePunctuation(")")
	}

	//
	// JSX
	//

	emitJsxElement := func(node JsxElement) {
		emit(node.openingElement)
		emitList(node, node.children, ListFormatJsxElementOrFragmentChildren)
		emit(node.closingElement)
	}

	emitJsxSelfClosingElement := func(node JsxSelfClosingElement) {
		writePunctuation("<")
		emitJsxTagName(node.tagName)
		emitTypeArguments(node, node.typeArguments)
		writeSpace()
		emit(node.attributes)
		writePunctuation("/>")
	}

	emitJsxFragment := func(node JsxFragment) {
		emit(node.openingFragment)
		emitList(node, node.children, ListFormatJsxElementOrFragmentChildren)
		emit(node.closingFragment)
	}

	emitJsxOpeningElementOrFragment := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningElement | JsxOpeningFragment */ any) {
		writePunctuation("<")

		if isJsxOpeningElement(node) {
			indented := writeLineSeparatorsAndIndentBefore(node.tagName, node)
			emitJsxTagName(node.tagName)
			emitTypeArguments(node, node.typeArguments)
			if node.attributes.properties && node.attributes.properties.length > 0 {
				writeSpace()
			}
			emit(node.attributes)
			writeLineSeparatorsAfter(node.attributes, node)
			decreaseIndentIf(indented)
		}

		writePunctuation(">")
	}

	emitJsxText := func(node JsxText) {
		writer.writeLiteral(node.text)
	}

	emitJsxClosingElementOrFragment := func(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxClosingElement | JsxClosingFragment */ any) {
		writePunctuation("</")
		if isJsxClosingElement(node) {
			emitJsxTagName(node.tagName)
		}
		writePunctuation(">")
	}

	emitJsxAttributes := func(node JsxAttributes) {
		emitList(node, node.properties, ListFormatJsxElementAttributes)
	}

	emitJsxAttribute := func(node JsxAttribute) {
		emit(node.name)
		emitNodeWithPrefix("=", writePunctuation, node.initializer, emitJsxAttributeValue)
	}

	emitJsxSpreadAttribute := func(node JsxSpreadAttribute) {
		writePunctuation("{...")
		emitExpression(node.expression)
		writePunctuation("}")
	}

	hasTrailingCommentsAtPosition := func(pos number) bool {
		result := false
		forEachTrailingCommentRange(currentSourceFile. /* ? */ text || "", pos+1, func() bool {
			return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = true */ TODO
		})
		return result
	}

	hasLeadingCommentsAtPosition := func(pos number) bool {
		result := false
		forEachLeadingCommentRange(currentSourceFile. /* ? */ text || "", pos+1, func() bool {
			return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = true */ TODO
		})
		return result
	}

	hasCommentsAtPosition := func(pos number) bool {
		return hasTrailingCommentsAtPosition(pos) || hasLeadingCommentsAtPosition(pos)
	}

	emitJsxExpression := func(node JsxExpression) {
		if node.expression || (!commentsDisabled && !nodeIsSynthesized(node) && hasCommentsAtPosition(node.pos)) {
			isMultiline := currentSourceFile && !nodeIsSynthesized(node) && getLineAndCharacterOfPosition(currentSourceFile, node.pos).line != getLineAndCharacterOfPosition(currentSourceFile, node.end).line
			if isMultiline {
				writer.increaseIndent()
			}
			end := emitTokenWithComment(SyntaxKindOpenBraceToken, node.pos, writePunctuation, node)
			emit(node.dotDotDotToken)
			emitExpression(node.expression)
			emitTokenWithComment(SyntaxKindCloseBraceToken, node.expression. /* ? */ end || end, writePunctuation, node)
			if isMultiline {
				writer.decreaseIndent()
			}
		}
	}

	emitJsxNamespacedName := func(node JsxNamespacedName) {
		emitIdentifierName(node.namespace)
		writePunctuation(":")
		emitIdentifierName(node.name)
	}

	emitJsxTagName := func(node JsxTagNameExpression) {
		if node.kind == SyntaxKindIdentifier {
			emitExpression(node)
		} else {
			emit(node)
		}
	}

	//
	// Clauses
	//

	emitCaseClause := func(node CaseClause) {
		emitTokenWithComment(SyntaxKindCaseKeyword, node.pos, writeKeyword, node)
		writeSpace()
		emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma)

		emitCaseOrDefaultClauseRest(node, node.statements, node.expression.end)
	}

	emitDefaultClause := func(node DefaultClause) {
		pos := emitTokenWithComment(SyntaxKindDefaultKeyword, node.pos, writeKeyword, node)
		emitCaseOrDefaultClauseRest(node, node.statements, pos)
	}

	emitCaseOrDefaultClauseRest := func(parentNode Node, statements NodeArray[Statement], colonPos number) {
		emitAsSingleStatement := statements.length == 1 && (!currentSourceFile || nodeIsSynthesized(parentNode) || nodeIsSynthesized(statements[0]) || rangeStartPositionsAreOnSameLine(parentNode, statements[0], currentSourceFile))

		format := ListFormatCaseOrDefaultClauseStatements
		if emitAsSingleStatement {
			writeToken(SyntaxKindColonToken, colonPos, writePunctuation, parentNode)
			writeSpace()
			format &= ~(ListFormatMultiLine | ListFormatIndented)
		} else {
			emitTokenWithComment(SyntaxKindColonToken, colonPos, writePunctuation, parentNode)
		}
		emitList(parentNode, statements, format)
	}

	emitHeritageClause := func(node HeritageClause) {
		writeSpace()
		writeTokenText(node.token, writeKeyword)
		writeSpace()
		emitList(node, node.types, ListFormatHeritageClauseTypes)
	}

	emitCatchClause := func(node CatchClause) {
		openParenPos := emitTokenWithComment(SyntaxKindCatchKeyword, node.pos, writeKeyword, node)
		writeSpace()
		if node.variableDeclaration {
			emitTokenWithComment(SyntaxKindOpenParenToken, openParenPos, writePunctuation, node)
			emit(node.variableDeclaration)
			emitTokenWithComment(SyntaxKindCloseParenToken, node.variableDeclaration.end, writePunctuation, node)
			writeSpace()
		}
		emit(node.block)
	}

	//
	// Property assignments
	//

	emitPropertyAssignment := func(node PropertyAssignment) {
		emit(node.name)
		writePunctuation(":")
		writeSpace()
		// This is to ensure that we emit comment in the following case:
		//      For example:
		//          obj = {
		//              id: /*comment1*/ ()=>void
		//          }
		// "comment1" is not considered to be leading comment for node.initializer
		// but rather a trailing comment on the previous node.
		initializer := node.initializer
		if (getEmitFlags(initializer) & EmitFlagsNoLeadingComments) == 0 {
			commentRange := getCommentRange(initializer)
			emitTrailingCommentsOfPosition(commentRange.pos)
		}
		emitExpression(initializer, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	emitShorthandPropertyAssignment := func(node ShorthandPropertyAssignment) {
		emit(node.name)
		if node.objectAssignmentInitializer {
			writeSpace()
			writePunctuation("=")
			writeSpace()
			emitExpression(node.objectAssignmentInitializer, parenthesizer.parenthesizeExpressionForDisallowedComma)
		}
	}

	emitSpreadAssignment := func(node SpreadAssignment) {
		if node.expression {
			emitTokenWithComment(SyntaxKindDotDotDotToken, node.pos, writePunctuation, node)
			emitExpression(node.expression, parenthesizer.parenthesizeExpressionForDisallowedComma)
		}
	}

	//
	// Enum
	//

	emitEnumMember := func(node EnumMember) {
		emit(node.name)
		emitInitializer(node.initializer, node.name.end, node, parenthesizer.parenthesizeExpressionForDisallowedComma)
	}

	//
	// JSDoc
	//
	emitJSDoc := func(node JSDoc) {
		write("/**")
		if node.comment {
			text := getTextOfJSDocComment(node.comment)
			if text {
				lines := text.split(regexp.MustParse(`\r\n?|\n`))
				for _, line := range lines {
					writeLine()
					writeSpace()
					writePunctuation("*")
					writeSpace()
					write(line)
				}
			}
		}
		if node.tags {
			if node.tags.length == 1 && node.tags[0].kind == SyntaxKindJSDocTypeTag && !node.comment {
				writeSpace()
				emit(node.tags[0])
			} else {
				emitList(node, node.tags, ListFormatJSDocComment)
			}
		}
		writeSpace()
		write("*/")
	}

	emitJSDocSimpleTypedTag := func(tag /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeTag | JSDocThisTag | JSDocEnumTag | JSDocReturnTag | JSDocThrowsTag | JSDocSatisfiesTag */ any) {
		emitJSDocTagName(tag.tagName)
		emitJSDocTypeExpression(tag.typeExpression)
		emitJSDocComment(tag.comment)
	}

	emitJSDocSeeTag := func(tag JSDocSeeTag) {
		emitJSDocTagName(tag.tagName)
		emit(tag.name)
		emitJSDocComment(tag.comment)
	}

	emitJSDocImportTag := func(tag JSDocImportTag) {
		emitJSDocTagName(tag.tagName)
		writeSpace()

		if tag.importClause {
			emit(tag.importClause)
			writeSpace()

			emitTokenWithComment(SyntaxKindFromKeyword, tag.importClause.end, writeKeyword, tag)
			writeSpace()
		}

		emitExpression(tag.moduleSpecifier)
		if tag.attributes {
			emitWithLeadingSpace(tag.attributes)
		}
		emitJSDocComment(tag.comment)
	}

	emitJSDocNameReference := func(node JSDocNameReference) {
		writeSpace()
		writePunctuation("{")
		emit(node.name)
		writePunctuation("}")
	}

	emitJSDocHeritageTag := func(tag /* TODO(TS-TO-GO) TypeNode UnionType: JSDocImplementsTag | JSDocAugmentsTag */ any) {
		emitJSDocTagName(tag.tagName)
		writeSpace()
		writePunctuation("{")
		emit(tag.class)
		writePunctuation("}")
		emitJSDocComment(tag.comment)
	}

	emitJSDocTemplateTag := func(tag JSDocTemplateTag) {
		emitJSDocTagName(tag.tagName)
		emitJSDocTypeExpression(tag.constraint)
		writeSpace()
		emitList(tag, tag.typeParameters, ListFormatCommaListElements)
		emitJSDocComment(tag.comment)
	}

	emitJSDocTypedefTag := func(tag JSDocTypedefTag) {
		emitJSDocTagName(tag.tagName)
		if tag.typeExpression {
			if tag.typeExpression.kind == SyntaxKindJSDocTypeExpression {
				emitJSDocTypeExpression(tag.typeExpression)
			} else {
				writeSpace()
				writePunctuation("{")
				write("Object")
				if tag.typeExpression.isArrayType {
					writePunctuation("[")
					writePunctuation("]")
				}
				writePunctuation("}")
			}
		}
		if tag.fullName {
			writeSpace()
			emit(tag.fullName)
		}
		emitJSDocComment(tag.comment)
		if tag.typeExpression && tag.typeExpression.kind == SyntaxKindJSDocTypeLiteral {
			emitJSDocTypeLiteral(tag.typeExpression)
		}
	}

	emitJSDocCallbackTag := func(tag JSDocCallbackTag) {
		emitJSDocTagName(tag.tagName)
		if tag.name {
			writeSpace()
			emit(tag.name)
		}
		emitJSDocComment(tag.comment)
		emitJSDocSignature(tag.typeExpression)
	}

	emitJSDocOverloadTag := func(tag JSDocOverloadTag) {
		emitJSDocComment(tag.comment)
		emitJSDocSignature(tag.typeExpression)
	}

	emitJSDocSimpleTag := func(tag JSDocTag) {
		emitJSDocTagName(tag.tagName)
		emitJSDocComment(tag.comment)
	}

	emitJSDocTypeLiteral := func(lit JSDocTypeLiteral) {
		emitList(lit, factory.createNodeArray(lit.jsDocPropertyTags), ListFormatJSDocComment)
	}

	emitJSDocSignature := func(sig JSDocSignature) {
		if sig.typeParameters {
			emitList(sig, factory.createNodeArray(sig.typeParameters), ListFormatJSDocComment)
		}
		if sig.parameters {
			emitList(sig, factory.createNodeArray(sig.parameters), ListFormatJSDocComment)
		}
		if sig.type_ {
			writeLine()
			writeSpace()
			writePunctuation("*")
			writeSpace()
			emit(sig.type_)
		}
	}

	emitJSDocPropertyLikeTag := func(param JSDocPropertyLikeTag) {
		emitJSDocTagName(param.tagName)
		emitJSDocTypeExpression(param.typeExpression)
		writeSpace()
		if param.isBracketed {
			writePunctuation("[")
		}
		emit(param.name)
		if param.isBracketed {
			writePunctuation("]")
		}
		emitJSDocComment(param.comment)
	}

	emitJSDocTagName := func(tagName Identifier) {
		writePunctuation("@")
		emit(tagName)
	}

	emitJSDocComment := func(comment /* TODO(TS-TO-GO) TypeNode UnionType: string | NodeArray<JSDocComment> | undefined */ any) {
		text := getTextOfJSDocComment(comment)
		if text {
			writeSpace()
			write(text)
		}
	}

	emitJSDocTypeExpression := func(typeExpression *JSDocTypeExpression) {
		if typeExpression {
			writeSpace()
			writePunctuation("{")
			emit(typeExpression.type_)
			writePunctuation("}")
		}
	}

	//
	// Top-level nodes
	//

	emitSourceFile := func(node SourceFile) {
		writeLine()
		statements := node.statements
		// Emit detached comment if there are no prologue directives or if the first node is synthesized.
		// The synthesized node will have no leading comment so some comments may be missed.
		shouldEmitDetachedComment := statements.length == 0 || !isPrologueDirective(statements[0]) || nodeIsSynthesized(statements[0])
		if shouldEmitDetachedComment {
			emitBodyWithDetachedComments(node, statements, emitSourceFileWorker)
			return
		}
		emitSourceFileWorker(node)
	}

	emitSyntheticTripleSlashReferencesIfNeeded := func(node Bundle) {
		emitTripleSlashDirectives(!!node.hasNoDefaultLib, node.syntheticFileReferences || []never{}, node.syntheticTypeReferences || []never{}, node.syntheticLibReferences || []never{})
	}

	emitTripleSlashDirectivesIfNeeded := func(node SourceFile) {
		if node.isDeclarationFile {
			emitTripleSlashDirectives(node.hasNoDefaultLib, node.referencedFiles, node.typeReferenceDirectives, node.libReferenceDirectives)
		}
	}

	emitTripleSlashDirectives := func(hasNoDefaultLib bool, files []FileReference, types []FileReference, libs []FileReference) {
		if hasNoDefaultLib {
			writeComment(`/// <reference no-default-lib="true"/>`)
			writeLine()
		}
		if currentSourceFile && currentSourceFile.moduleName {
			writeComment(__TEMPLATE__("/// <amd-module name=\"", currentSourceFile.moduleName, "\" />"))
			writeLine()
		}
		if currentSourceFile && currentSourceFile.amdDependencies {
			for _, dep := range currentSourceFile.amdDependencies {
				if dep.name {
					writeComment(__TEMPLATE__("/// <amd-dependency name=\"", dep.name, "\" path=\"", dep.path, "\" />"))
				} else {
					writeComment(__TEMPLATE__("/// <amd-dependency path=\"", dep.path, "\" />"))
				}
				writeLine()
			}
		}

		writeDirectives := func(kind /* TODO(TS-TO-GO) TypeNode UnionType: "path" | "types" | "lib" */ any, directives []FileReference) {
			for _, directive := range directives {
				var resolutionMode string
				if directive.resolutionMode {
					resolutionMode = __TEMPLATE__("resolution-mode=\"", ifelse(directive.resolutionMode == ModuleKindESNext, "import", "require"), "\" ")
				} else {
					resolutionMode = ""
				}
				var preserve /* TODO(TS-TO-GO) inferred type "" | "preserve=\"true\" " */ any
				if directive.preserve {
					preserve = `preserve="true" `
				} else {
					preserve = ""
				}
				writeComment(__TEMPLATE__("/// <reference ", kind, "=\"", directive.fileName, "\" ", resolutionMode, preserve, "/>"))
				writeLine()
			}
		}

		writeDirectives("path", files)
		writeDirectives("types", types)
		writeDirectives("lib", libs)
	}

	emitSourceFileWorker := func(node SourceFile) {
		statements := node.statements
		pushNameGenerationScope(node)
		forEach(node.statements, generateNames)
		emitHelpers(node)
		index := findIndex(statements, func(statement /* TODO(TS-TO-GO) inferred type ts.Statement */ any) bool {
			return !isPrologueDirective(statement)
		})
		emitTripleSlashDirectivesIfNeeded(node)
		emitList(node, statements, ListFormatMultiLine /*parenthesizerRule*/, nil, ifelse(index == -1, statements.length, index))
		popNameGenerationScope(node)
	}

	// Transformation nodes

	emitPartiallyEmittedExpression := func(node PartiallyEmittedExpression) {
		emitFlags := getEmitFlags(node)
		if !(emitFlags & EmitFlagsNoLeadingComments) && node.pos != node.expression.pos {
			emitTrailingCommentsOfPosition(node.expression.pos)
		}
		emitExpression(node.expression)
		if !(emitFlags & EmitFlagsNoTrailingComments) && node.end != node.expression.end {
			emitLeadingCommentsOfPosition(node.expression.end)
		}
	}

	emitCommaList := func(node CommaListExpression) {
		emitExpressionList(node, node.elements, ListFormatCommaListElements /*parenthesizerRule*/, nil)
	}

	/**
	 * Emits any prologue directives at the start of a Statement list, returning the
	 * number of prologue directives written to the output.
	 */

	emitPrologueDirectives := func(statements []Node, sourceFile SourceFile, seenPrologueDirectives Set[string]) number {
		needsToSetSourceFile := !!sourceFile
		for i := 0; i < statements.length; i++ {
			statement := statements[i]
			if isPrologueDirective(statement) {
				var shouldEmitPrologueDirective bool
				if seenPrologueDirectives {
					shouldEmitPrologueDirective = !seenPrologueDirectives.has(statement.expression.text)
				} else {
					shouldEmitPrologueDirective = true
				}
				if shouldEmitPrologueDirective {
					if needsToSetSourceFile {
						needsToSetSourceFile = false
						setSourceFile(sourceFile)
					}
					writeLine()
					emit(statement)
					if seenPrologueDirectives {
						seenPrologueDirectives.add(statement.expression.text)
					}
				}
			} else {
				// return index of the first non prologue directive
				return i
			}
		}

		return statements.length
	}

	emitPrologueDirectivesIfNeeded := func(sourceFileOrBundle /* TODO(TS-TO-GO) TypeNode UnionType: Bundle | SourceFile */ any) {
		if isSourceFile(sourceFileOrBundle) {
			emitPrologueDirectives(sourceFileOrBundle.statements, sourceFileOrBundle)
		} else {
			seenPrologueDirectives := NewSet[string]()
			for _, sourceFile := range sourceFileOrBundle.sourceFiles {
				emitPrologueDirectives(sourceFile.statements, sourceFile, seenPrologueDirectives)
			}
			setSourceFile(nil)
		}
	}

	emitShebangIfNeeded := func(sourceFileOrBundle /* TODO(TS-TO-GO) TypeNode UnionType: Bundle | SourceFile */ any) *true {
		if isSourceFile(sourceFileOrBundle) {
			shebang := getShebang(sourceFileOrBundle.text)
			if shebang {
				writeComment(shebang)
				writeLine()
				return true
			}
		} else {
			for _, sourceFile := range sourceFileOrBundle.sourceFiles {
				// Emit only the first encountered shebang
				if emitShebangIfNeeded(sourceFile) {
					return true
				}
			}
		}
	}

	//
	// Helpers
	//

	emitNodeWithWriter := func(node Node, writer /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof write */ any) {
		if !node {
			return
		}
		savedWrite := write
		write = writer
		emit(node)
		write = savedWrite
	}

	emitDecoratorsAndModifiers := func(node Node, modifiers *NodeArray[ModifierLike], allowDecorators bool) number {
		if modifiers. /* ? */ length {
			if every(modifiers, isModifier) {
				// if all modifier-likes are `Modifier`, simply emit the array as modifiers.
				return emitModifierList(node, modifiers.(NodeArray[Modifier]))
			}

			if every(modifiers, isDecorator) {
				if allowDecorators {
					// if all modifier-likes are `Decorator`, simply emit the array as decorators.
					return emitDecoratorList(node, modifiers.(NodeArray[Decorator]))
				}
				return node.pos
			}

			onBeforeEmitNodeArray(modifiers)

			// partition modifiers into contiguous chunks of `Modifier` or `Decorator`
			var lastMode /* TODO(TS-TO-GO) TypeNode UnionType: "modifiers" | "decorators" | undefined */ any
			var mode /* TODO(TS-TO-GO) TypeNode UnionType: "modifiers" | "decorators" | undefined */ any
			start := 0
			pos := 0
			var lastModifier *ModifierLike
			for start < modifiers.length {
				for pos < modifiers.length {
					lastModifier = modifiers[pos]
					if isDecorator(lastModifier) {
						mode = "decorators"
					} else {
						mode = "modifiers"
					}
					if lastMode == nil {
						lastMode = mode
					} else if mode != lastMode {
						break
					}

					pos++
				}

				var textRange TextRange = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"pos": -1,
					"end": -1,
				}
				if start == 0 {
					textRange.pos = modifiers.pos
				}
				if pos == modifiers.length-1 {
					textRange.end = modifiers.end
				}
				if lastMode == "modifiers" || allowDecorators {
					emitNodeListItems(emit, node, modifiers, ifelse(lastMode == "modifiers", ListFormatModifiers, ListFormatDecorators), nil, start, pos-start, false, textRange)
				}
				start = pos
				lastMode = mode
				pos++
			}

			onAfterEmitNodeArray(modifiers)

			if lastModifier && !positionIsSynthesized(lastModifier.end) {
				return lastModifier.end
			}
		}

		return node.pos
	}

	emitModifierList := func(node Node, modifiers *NodeArray[Modifier]) number {
		emitList(node, modifiers, ListFormatModifiers)
		lastModifier := lastOrUndefined(modifiers)
		if lastModifier && !positionIsSynthesized(lastModifier.end) {
			return lastModifier.end
		} else {
			return node.pos
		}
	}

	emitTypeAnnotation := func(node *TypeNode) {
		if node {
			writePunctuation(":")
			writeSpace()
			emit(node)
		}
	}

	emitInitializer := func(node Expression, equalCommentStartPos number, container Node, parenthesizerRule func(node Expression) Expression) {
		if node {
			writeSpace()
			emitTokenWithComment(SyntaxKindEqualsToken, equalCommentStartPos, writeOperator, container)
			writeSpace()
			emitExpression(node, parenthesizerRule)
		}
	}

	emitNodeWithPrefix := func(prefix string, prefixWriter func(s string), node *T, emit func(node T)) {
		if node {
			prefixWriter(prefix)
			emit(node)
		}
	}

	emitWithLeadingSpace := func(node Node) {
		if node {
			writeSpace()
			emit(node)
		}
	}

	emitExpressionWithLeadingSpace := func(node Expression, parenthesizerRule func(node Expression) Expression) {
		if node {
			writeSpace()
			emitExpression(node, parenthesizerRule)
		}
	}

	emitWithTrailingSpace := func(node Node) {
		if node {
			emit(node)
			writeSpace()
		}
	}

	emitEmbeddedStatement := func(parent Node, node Statement) {
		if isBlock(node) || getEmitFlags(parent)&EmitFlagsSingleLine || preserveSourceNewlines && !getLeadingLineTerminatorCount(parent, node, ListFormatNone) {
			writeSpace()
			emit(node)
		} else {
			writeLine()
			increaseIndent()
			if isEmptyStatement(node) {
				pipelineEmit(EmitHintEmbeddedStatement, node)
			} else {
				emit(node)
			}
			decreaseIndent()
		}
	}

	emitDecoratorList := func(parentNode Node, decorators *NodeArray[Decorator]) number {
		emitList(parentNode, decorators, ListFormatDecorators)
		lastDecorator := lastOrUndefined(decorators)
		if lastDecorator && !positionIsSynthesized(lastDecorator.end) {
			return lastDecorator.end
		} else {
			return parentNode.pos
		}
	}

	emitTypeArguments := func(parentNode Node, typeArguments *NodeArray[TypeNode]) {
		emitList(parentNode, typeArguments, ListFormatTypeArguments, typeArgumentParenthesizerRuleSelector)
	}

	emitTypeParameters := func(parentNode /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration | ClassDeclaration | ClassExpression */ any, typeParameters *NodeArray[TypeParameterDeclaration]) {
		if isFunctionLike(parentNode) && parentNode.typeArguments {
			return emitTypeArguments(parentNode, parentNode.typeArguments)
		}
		emitList(parentNode, typeParameters, ListFormatTypeParameters|(ifelse(isArrowFunction(parentNode), ListFormatAllowTrailingComma, ListFormatNone)))
	}

	emitParameters := func(parentNode Node, parameters NodeArray[ParameterDeclaration]) {
		emitList(parentNode, parameters, ListFormatParameters)
	}

	canEmitSimpleArrowHead := func(parentNode /* TODO(TS-TO-GO) TypeNode UnionType: FunctionTypeNode | ConstructorTypeNode | ArrowFunction */ any, parameters NodeArray[ParameterDeclaration]) *bool {
		parameter := singleOrUndefined(parameters)
		return parameter && parameter.pos == parentNode.pos && isArrowFunction(parentNode) && !parentNode.type_ && !some(parentNode.modifiers) && !some(parentNode.typeParameters) && !some(parameter.modifiers) && !parameter.dotDotDotToken && !parameter.questionToken && !parameter.type_ && !parameter.initializer && isIdentifier(parameter.name)
		// parameter name must be identifier
	}

	emitParametersForArrow := func(parentNode /* TODO(TS-TO-GO) TypeNode UnionType: FunctionTypeNode | ConstructorTypeNode | ArrowFunction */ any, parameters NodeArray[ParameterDeclaration]) {
		if canEmitSimpleArrowHead(parentNode, parameters) {
			emitList(parentNode, parameters, ListFormatParameters&~ListFormatParenthesis)
		} else {
			emitParameters(parentNode, parameters)
		}
	}

	emitParametersForIndexSignature := func(parentNode Node, parameters NodeArray[ParameterDeclaration]) {
		emitList(parentNode, parameters, ListFormatIndexSignatureParameters)
	}

	writeDelimiter := func(format ListFormat) {
		switch format & ListFormatDelimitersMask {
		case ListFormatNone:
		case ListFormatCommaDelimited:
			writePunctuation(",")
		case ListFormatBarDelimited:
			writeSpace()
			writePunctuation("|")
		case ListFormatAsteriskDelimited:
			writeSpace()
			writePunctuation("*")
			writeSpace()
		case ListFormatAmpersandDelimited:
			writeSpace()
			writePunctuation("&")
		}
	}

	emitList := func(parentNode Node, children *Children, format ListFormat, parenthesizerRule ParenthesizerRuleOrSelector[Child], start number, count number) {
		emitNodeList(emit, parentNode, children, format|(ifelse(parentNode && getEmitFlags(parentNode)&EmitFlagsMultiLine, ListFormatPreferNewLine, 0)), parenthesizerRule, start, count)
	}

	emitExpressionList := func(parentNode Node, children *Children, format ListFormat, parenthesizerRule ParenthesizerRuleOrSelector[Child], start number, count number) {
		emitNodeList(emitExpression, parentNode, children, format, parenthesizerRule, start, count)
	}

	emitNodeList := func(emit EmitFunction, parentNode Node, children *Children, format ListFormat, parenthesizerRule *ParenthesizerRuleOrSelector[Child], start number /*  = 0 */, count number /*  = children ? children.length - start : 0 */) {
		isUndefined := children == nil
		if isUndefined && format&ListFormatOptionalIfUndefined {
			return
		}

		isEmpty := children == nil || start >= children.length || count == 0
		if isEmpty && format&ListFormatOptionalIfEmpty {
			onBeforeEmitNodeArray(children)
			onAfterEmitNodeArray(children)
			return
		}

		if format & ListFormatBracketsMask {
			writePunctuation(getOpeningBracket(format))
			if isEmpty && children {
				emitTrailingCommentsOfPosition(children.pos /*prefixSpace*/, true)
				// Emit comments within empty bracketed lists
			}
		}

		onBeforeEmitNodeArray(children)

		if isEmpty {
			// Write a line terminator if the parent node was multi-line
			if format&ListFormatMultiLine && !(preserveSourceNewlines && (!parentNode || currentSourceFile && rangeIsOnSingleLine(parentNode, currentSourceFile))) {
				writeLine()
			} else if format&ListFormatSpaceBetweenBraces && !(format & ListFormatNoSpaceIfEmpty) {
				writeSpace()
			}
		} else {
			emitNodeListItems(emit, parentNode, children, format, parenthesizerRule, start, count, children.hasTrailingComma, children)
		}

		onAfterEmitNodeArray(children)

		if format & ListFormatBracketsMask {
			if isEmpty && children {
				emitLeadingCommentsOfPosition(children.end)
				// Emit leading comments within empty lists
			}
			writePunctuation(getClosingBracket(format))
		}
	}

	/**
	 * Emits a list without brackets or raising events.
	 *
	 * NOTE: You probably don't want to call this directly and should be using `emitList` or `emitExpressionList` instead.
	 */

	emitNodeListItems := func(emit EmitFunction, parentNode Node, children []Child, format ListFormat, parenthesizerRule *ParenthesizerRuleOrSelector[Child], start number, count number, hasTrailingComma bool, childrenTextRange *TextRange) {
		// Write the opening line terminator or leading whitespace.
		mayEmitInterveningComments := (format & ListFormatNoInterveningComments) == 0
		shouldEmitInterveningComments := mayEmitInterveningComments

		leadingLineTerminatorCount := getLeadingLineTerminatorCount(parentNode, children[start], format)
		if leadingLineTerminatorCount {
			writeLine(leadingLineTerminatorCount)
			shouldEmitInterveningComments = false
		} else if format & ListFormatSpaceBetweenBraces {
			writeSpace()
		}

		// Increase the indent, if requested.
		if format & ListFormatIndented {
			increaseIndent()
		}

		emitListItem := getEmitListItem(emit, parenthesizerRule)

		// Emit each child.
		var previousSibling Node
		shouldDecreaseIndentAfterEmit := false
		for i := 0; i < count; i++ {
			child := children[start+i]

			// Write the delimiter if this is not the first node.
			if format & ListFormatAsteriskDelimited {
				// always write JSDoc in the format "\n *"
				writeLine()
				writeDelimiter(format)
			} else if previousSibling {
				// i.e
				//      function commentedParameters(
				//          /* Parameter a */
				//          a
				//          /* End of parameter a */ -> this comment isn't considered to be trailing comment of parameter "a" due to newline
				//          ,
				if format&ListFormatDelimitersMask && previousSibling.end != (ifelse(parentNode, parentNode.end, -1)) {
					previousSiblingEmitFlags := getEmitFlags(previousSibling)
					if !(previousSiblingEmitFlags & EmitFlagsNoTrailingComments) {
						emitLeadingCommentsOfPosition(previousSibling.end)
					}
				}

				writeDelimiter(format)

				// Write either a line terminator or whitespace to separate the elements.
				separatingLineTerminatorCount := getSeparatingLineTerminatorCount(previousSibling, child, format)
				if separatingLineTerminatorCount > 0 {
					// If a synthesized node in a single-line list starts on a new
					// line, we should increase the indent.
					if (format & (ListFormatLinesMask | ListFormatIndented)) == ListFormatSingleLine {
						increaseIndent()
						shouldDecreaseIndentAfterEmit = true
					}

					if shouldEmitInterveningComments && format&ListFormatDelimitersMask && !positionIsSynthesized(child.pos) {
						commentRange := getCommentRange(child)
						emitTrailingCommentsOfPosition(commentRange.pos /*prefixSpace*/, !!(format & ListFormatSpaceBetweenSiblings) /*forceNoNewline*/, true)
					}

					writeLine(separatingLineTerminatorCount)
					shouldEmitInterveningComments = false
				} else if previousSibling && format&ListFormatSpaceBetweenSiblings {
					writeSpace()
				}
			}

			// Emit this child.
			if shouldEmitInterveningComments {
				commentRange := getCommentRange(child)
				emitTrailingCommentsOfPosition(commentRange.pos)
			} else {
				shouldEmitInterveningComments = mayEmitInterveningComments
			}

			nextListElementPos = child.pos
			emitListItem(child, emit, parenthesizerRule, i)

			if shouldDecreaseIndentAfterEmit {
				decreaseIndent()
				shouldDecreaseIndentAfterEmit = false
			}

			previousSibling = child
		}

		// Write a trailing comma, if requested.
		var emitFlags /* TODO(TS-TO-GO) inferred type 0 | ts.EmitFlags */ any
		if previousSibling {
			emitFlags = getEmitFlags(previousSibling)
		} else {
			emitFlags = 0
		}
		skipTrailingComments := commentsDisabled || !!(emitFlags & EmitFlagsNoTrailingComments)
		emitTrailingComma := hasTrailingComma && (format & ListFormatAllowTrailingComma) && (format & ListFormatCommaDelimited)
		if emitTrailingComma {
			if previousSibling && !skipTrailingComments {
				emitTokenWithComment(SyntaxKindCommaToken, previousSibling.end, writePunctuation, previousSibling)
			} else {
				writePunctuation(",")
			}
		}

		// Emit any trailing comment of the last element in the list
		// i.e
		//       var array = [...
		//          2
		//          /* end of element 2 */
		//       ];
		if previousSibling && (ifelse(parentNode, parentNode.end, -1)) != previousSibling.end && (format & ListFormatDelimitersMask) && !skipTrailingComments {
			emitLeadingCommentsOfPosition(ifelse(emitTrailingComma && childrenTextRange. /* ? */ end, childrenTextRange.end, previousSibling.end))
		}

		// Decrease the indent, if requested.
		if format & ListFormatIndented {
			decreaseIndent()
		}

		// Write the closing line terminator or closing whitespace.
		closingLineTerminatorCount := getClosingLineTerminatorCount(parentNode, children[start+count-1], format, childrenTextRange)
		if closingLineTerminatorCount {
			writeLine(closingLineTerminatorCount)
		} else if format & (ListFormatSpaceAfterList | ListFormatSpaceBetweenBraces) {
			writeSpace()
		}
	}

	// Writers

	writeLiteral := func(s string) {
		writer.writeLiteral(s)
	}

	writeStringLiteral := func(s string) {
		writer.writeStringLiteral(s)
	}

	writeBase := func(s string) {
		writer.write(s)
	}

	writeSymbol := func(s string, sym Symbol) {
		writer.writeSymbol(s, sym)
	}

	writePunctuation := func(s string) {
		writer.writePunctuation(s)
	}

	writeTrailingSemicolon := func() {
		writer.writeTrailingSemicolon(";")
	}

	writeKeyword := func(s string) {
		writer.writeKeyword(s)
	}

	writeOperator := func(s string) {
		writer.writeOperator(s)
	}

	writeParameter := func(s string) {
		writer.writeParameter(s)
	}

	writeComment := func(s string) {
		writer.writeComment(s)
	}

	writeSpace := func() {
		writer.writeSpace(" ")
	}

	writeProperty := func(s string) {
		writer.writeProperty(s)
	}

	nonEscapingWrite := func(s string) {
		// This should be defined in a snippet-escaping text writer.
		if writer.nonEscapingWrite {
			writer.nonEscapingWrite(s)
		} else {
			writer.write(s)
		}
	}

	writeLine := func(count number /*  = 1 */) {
		for i := 0; i < count; i++ {
			writer.writeLine(i > 0)
		}
	}

	increaseIndent := func() {
		writer.increaseIndent()
	}

	decreaseIndent := func() {
		writer.decreaseIndent()
	}

	writeToken := func(token SyntaxKind, pos number, writer func(s string), contextNode Node) number {
		if !sourceMapsDisabled {
			return emitTokenWithSourceMap(contextNode, token, writer, pos, writeTokenText)
		} else {
			return writeTokenText(token, writer, pos)
		}
	}

	writeTokenNode := func(node Node, writer func(s string)) {
		if onBeforeEmitToken {
			onBeforeEmitToken(node)
		}
		writer(tokenToString(node.kind))
		if onAfterEmitToken {
			onAfterEmitToken(node)
		}
	}

	/* OVERLOAD: function writeTokenText(token: SyntaxKind, writer: (s: string) => void): void; */
	/* OVERLOAD: function writeTokenText(token: SyntaxKind, writer: (s: string) => void, pos: number): number; */
	writeTokenText := func(token SyntaxKind, writer func(s string), pos number) number {
		tokenString := tokenToString(token)
		writer(tokenString)
		if pos < 0 {
			return pos
		} else {
			return pos + tokenString.length
		}
	}

	writeLineOrSpace := func(parentNode Node, prevChildNode Node, nextChildNode Node) {
		if getEmitFlags(parentNode) & EmitFlagsSingleLine {
			writeSpace()
		} else if preserveSourceNewlines {
			lines := getLinesBetweenNodes(parentNode, prevChildNode, nextChildNode)
			if lines {
				writeLine(lines)
			} else {
				writeSpace()
			}
		} else {
			writeLine()
		}
	}

	writeLines := func(text string) {
		lines := text.split(regexp.MustParse(`\r\n?|\n`))
		indentation := guessIndentation(lines)
		for _, lineText := range lines {
			var line string
			if indentation {
				line = lineText.slice(indentation)
			} else {
				line = lineText
			}
			if line.length {
				writeLine()
				write(line)
			}
		}
	}

	writeLinesAndIndent := func(lineCount number, writeSpaceIfNotIndenting bool) {
		if lineCount {
			increaseIndent()
			writeLine(lineCount)
		} else if writeSpaceIfNotIndenting {
			writeSpace()
		}
	}

	// Helper function to decrease the indent if we previously indented.  Allows multiple
	// previous indent values to be considered at a time.  This also allows caller to just
	// call this once, passing in all their appropriate indent values, instead of needing
	// to call this helper function multiple times.
	decreaseIndentIf := func(value1 /* TODO(TS-TO-GO) TypeNode UnionType: boolean | number | undefined */ any, value2 /* TODO(TS-TO-GO) TypeNode UnionType: boolean | number */ any) {
		if value1 {
			decreaseIndent()
		}
		if value2 {
			decreaseIndent()
		}
	}

	getLeadingLineTerminatorCount := func(parentNode Node, firstChild Node, format ListFormat) number {
		if format&ListFormatPreserveLines || preserveSourceNewlines {
			if format & ListFormatPreferNewLine {
				return 1
			}

			if firstChild == nil {
				if !parentNode || currentSourceFile && rangeIsOnSingleLine(parentNode, currentSourceFile) {
					return 0
				} else {
					return 1
				}
			}
			if firstChild.pos == nextListElementPos {
				// If this child starts at the beginning of a list item in a parent list, its leading
				// line terminators have already been written as the separating line terminators of the
				// parent list. Example:
				//
				// class Foo {
				//   constructor() {}
				//   public foo() {}
				// }
				//
				// The outer list is the list of class members, with one line terminator between the
				// constructor and the method. The constructor is written, the separating line terminator
				// is written, and then we start emitting the method. Its modifiers ([public]) constitute an inner
				// list, so we look for its leading line terminators. If we didn't know that we had already
				// written a newline as part of the parent list, it would appear that we need to write a
				// leading newline to start the modifiers.
				return 0
			}
			if firstChild.kind == SyntaxKindJsxText {
				// JsxText will be written with its leading whitespace, so don't add more manually.
				return 0
			}
			if currentSourceFile && parentNode && !positionIsSynthesized(parentNode.pos) && !nodeIsSynthesized(firstChild) && (!firstChild.parent || getOriginalNode(firstChild.parent) == getOriginalNode(parentNode)) {
				if preserveSourceNewlines {
					return getEffectiveLines(func(includeComments bool) number {
						return getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(firstChild.pos, parentNode.pos, currentSourceFile, includeComments)
					})
				}
				if rangeStartPositionsAreOnSameLine(parentNode, firstChild, currentSourceFile) {
					return 0
				} else {
					return 1
				}
			}
			if synthesizedNodeStartsOnNewLine(firstChild, format) {
				return 1
			}
		}
		if format & ListFormatMultiLine {
			return 1
		} else {
			return 0
		}
	}

	getSeparatingLineTerminatorCount := func(previousNode Node, nextNode Node, format ListFormat) number {
		if format&ListFormatPreserveLines || preserveSourceNewlines {
			if previousNode == nil || nextNode == nil {
				return 0
			}
			if nextNode.kind == SyntaxKindJsxText {
				// JsxText will be written with its leading whitespace, so don't add more manually.
				return 0
			} else if currentSourceFile && !nodeIsSynthesized(previousNode) && !nodeIsSynthesized(nextNode) {
				if preserveSourceNewlines && siblingNodePositionsAreComparable(previousNode, nextNode) {
					return getEffectiveLines(func(includeComments bool) number {
						return getLinesBetweenRangeEndAndRangeStart(previousNode, nextNode, currentSourceFile, includeComments)
					})
				} else if !preserveSourceNewlines && originalNodesHaveSameParent(previousNode, nextNode) {
					if rangeEndIsOnSameLineAsRangeStart(previousNode, nextNode, currentSourceFile) {
						return 0
					} else {
						return 1
					}
				}
				// If the two nodes are not comparable, add a line terminator based on the format that can indicate
				// whether new lines are preferred or not.
				if format & ListFormatPreferNewLine {
					return 1
				} else {
					return 0
				}
			} else if synthesizedNodeStartsOnNewLine(previousNode, format) || synthesizedNodeStartsOnNewLine(nextNode, format) {
				return 1
			}
		} else if getStartsOnNewLine(nextNode) {
			return 1
		}
		if format & ListFormatMultiLine {
			return 1
		} else {
			return 0
		}
	}

	getClosingLineTerminatorCount := func(parentNode Node, lastChild Node, format ListFormat, childrenTextRange *TextRange) number {
		if format&ListFormatPreserveLines || preserveSourceNewlines {
			if format & ListFormatPreferNewLine {
				return 1
			}

			if lastChild == nil {
				if !parentNode || currentSourceFile && rangeIsOnSingleLine(parentNode, currentSourceFile) {
					return 0
				} else {
					return 1
				}
			}
			if currentSourceFile && parentNode && !positionIsSynthesized(parentNode.pos) && !nodeIsSynthesized(lastChild) && (!lastChild.parent || lastChild.parent == parentNode) {
				if preserveSourceNewlines {
					var end number
					if childrenTextRange && !positionIsSynthesized(childrenTextRange.end) {
						end = childrenTextRange.end
					} else {
						end = lastChild.end
					}
					return getEffectiveLines(func(includeComments bool) number {
						return getLinesBetweenPositionAndNextNonWhitespaceCharacter(end, parentNode.end, currentSourceFile, includeComments)
					})
				}
				if rangeEndPositionsAreOnSameLine(parentNode, lastChild, currentSourceFile) {
					return 0
				} else {
					return 1
				}
			}
			if synthesizedNodeStartsOnNewLine(lastChild, format) {
				return 1
			}
		}
		if format&ListFormatMultiLine && !(format & ListFormatNoTrailingNewLine) {
			return 1
		}
		return 0
	}

	getEffectiveLines := func(getLineDifference func(includeComments bool) number) number {
		// If 'preserveSourceNewlines' is disabled, we should never call this function
		// because it could be more expensive than alternative approximations.
		Debug.assert(!!preserveSourceNewlines)
		// We start by measuring the line difference from a position to its adjacent comments,
		// so that this is counted as a one-line difference, not two:
		//
		//   node1;
		//   // NODE2 COMMENT
		//   node2;
		lines := getLineDifference(true)
		if lines == 0 {
			// However, if the line difference considering comments was 0, we might have this:
			//
			//   node1; // NODE2 COMMENT
			//   node2;
			//
			// in which case we should be ignoring node2's comment, so this too is counted as
			// a one-line difference, not zero.
			return getLineDifference(false)
		}
		return lines
	}

	writeLineSeparatorsAndIndentBefore := func(node Node, parent Node) bool {
		leadingNewlines := preserveSourceNewlines && getLeadingLineTerminatorCount(parent, node, ListFormatNone)
		if leadingNewlines {
			writeLinesAndIndent(leadingNewlines /*writeSpaceIfNotIndenting*/, false)
		}
		return !!leadingNewlines
	}

	writeLineSeparatorsAfter := func(node Node, parent Node) {
		trailingNewlines := preserveSourceNewlines && getClosingLineTerminatorCount(parent, node, ListFormatNone /*childrenTextRange*/, nil)
		if trailingNewlines {
			writeLine(trailingNewlines)
		}
	}

	synthesizedNodeStartsOnNewLine := func(node Node, format ListFormat) bool {
		if nodeIsSynthesized(node) {
			startsOnNewLine := getStartsOnNewLine(node)
			if startsOnNewLine == nil {
				return (format & ListFormatPreferNewLine) != 0
			}

			return startsOnNewLine
		}

		return (format & ListFormatPreferNewLine) != 0
	}

	getLinesBetweenNodes := func(parent Node, node1 Node, node2 Node) number {
		if getEmitFlags(parent) & EmitFlagsNoIndentation {
			return 0
		}

		parent = skipSynthesizedParentheses(parent)
		node1 = skipSynthesizedParentheses(node1)
		node2 = skipSynthesizedParentheses(node2)

		// Always use a newline for synthesized code if the synthesizer desires it.
		if getStartsOnNewLine(node2) {
			return 1
		}

		if currentSourceFile && !nodeIsSynthesized(parent) && !nodeIsSynthesized(node1) && !nodeIsSynthesized(node2) {
			if preserveSourceNewlines {
				return getEffectiveLines(func(includeComments bool) number {
					return getLinesBetweenRangeEndAndRangeStart(node1, node2, currentSourceFile, includeComments)
				})
			}
			if rangeEndIsOnSameLineAsRangeStart(node1, node2, currentSourceFile) {
				return 0
			} else {
				return 1
			}
		}

		return 0
	}

	isEmptyBlock := func(block BlockLike) bool {
		return block.statements.length == 0 && (!currentSourceFile || rangeEndIsOnSameLineAsRangeStart(block, block, currentSourceFile))
	}

	skipSynthesizedParentheses := func(node Node) /* TODO(TS-TO-GO) inferred type ts.Node */ any {
		for node.kind == SyntaxKindParenthesizedExpression && nodeIsSynthesized(node) {
			node = (node.(ParenthesizedExpression)).expression
		}

		return node
	}

	getTextOfNode := func(node /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | LiteralExpression | JsxNamespacedName */ any, includeTrivia bool) string {
		if isGeneratedIdentifier(node) || isGeneratedPrivateIdentifier(node) {
			return generateName(node)
		}
		if isStringLiteral(node) && node.textSourceNode {
			return getTextOfNode(node.textSourceNode, includeTrivia)
		}
		sourceFile := currentSourceFile
		// const needed for control flow
		canUseSourceFile := !!sourceFile && !!node.parent && !nodeIsSynthesized(node)
		if isMemberName(node) {
			if !canUseSourceFile || getSourceFileOfNode(node) != getOriginalNode(sourceFile) {
				return idText(node)
			}
		} else if isJsxNamespacedName(node) {
			if !canUseSourceFile || getSourceFileOfNode(node) != getOriginalNode(sourceFile) {
				return getTextOfJsxNamespacedName(node)
			}
		} else {
			Debug.assertNode(node, isLiteralExpression)
			// not strictly necessary
			if !canUseSourceFile {
				return node.text
			}
		}
		return getSourceTextOfNodeFromSourceFile(sourceFile, node, includeTrivia)
	}

	getLiteralTextOfNode := func(node LiteralLikeNode, sourceFile * /* TODO(TS-TO-GO) inferred type ts.SourceFile */ any /*  = currentSourceFile */, neverAsciiEscape *bool, jsxAttributeEscape bool) string {
		if node.kind == SyntaxKindStringLiteral && (node.(StringLiteral)).textSourceNode {
			textSourceNode := (node.(StringLiteral)).textSourceNode
			if isIdentifier(textSourceNode) || isPrivateIdentifier(textSourceNode) || isNumericLiteral(textSourceNode) || isJsxNamespacedName(textSourceNode) {
				var text string
				if isNumericLiteral(textSourceNode) {
					text = textSourceNode.text
				} else {
					text = getTextOfNode(textSourceNode)
				}
				switch {
				case jsxAttributeEscape:
					return __TEMPLATE__("\"", escapeJsxAttributeString(text), "\"")
				case neverAsciiEscape || (getEmitFlags(node) & EmitFlagsNoAsciiEscaping):
					return __TEMPLATE__("\"", escapeString(text), "\"")
				default:
					return __TEMPLATE__("\"", escapeNonAsciiString(text), "\"")
				}
			} else {
				return getLiteralTextOfNode(textSourceNode, getSourceFileOfNode(textSourceNode), neverAsciiEscape, jsxAttributeEscape)
			}
		}

		flags := (ifelse(neverAsciiEscape, GetLiteralTextFlagsNeverAsciiEscape, 0)) | (ifelse(jsxAttributeEscape, GetLiteralTextFlagsJsxAttributeEscape, 0)) | (ifelse(printerOptions.terminateUnterminatedLiterals, GetLiteralTextFlagsTerminateUnterminatedLiterals, 0)) | (ifelse(printerOptions.target && printerOptions.target >= ScriptTargetES2021, GetLiteralTextFlagsAllowNumericSeparator, 0))

		return getLiteralText(node, sourceFile, flags)
	}

	/**
	 * Push a new name generation scope.
	 */

	pushNameGenerationScope := func(node Node) {
		privateNameTempFlagsStack.push(privateNameTempFlags)
		privateNameTempFlags = TempFlagsAuto
		reservedPrivateNamesStack.push(reservedPrivateNames)

		if node && getEmitFlags(node)&EmitFlagsReuseTempVariableScope {
			return
		}

		tempFlagsStack.push(tempFlags)
		tempFlags = TempFlagsAuto
		formattedNameTempFlagsStack.push(formattedNameTempFlags)
		formattedNameTempFlags = nil
		reservedNamesStack.push(reservedNames)
	}

	/**
	 * Pop the current name generation scope.
	 */

	popNameGenerationScope := func(node Node) {
		privateNameTempFlags = privateNameTempFlagsStack.pop()
		reservedPrivateNames = reservedPrivateNamesStack.pop()

		if node && getEmitFlags(node)&EmitFlagsReuseTempVariableScope {
			return
		}

		tempFlags = tempFlagsStack.pop()
		formattedNameTempFlags = formattedNameTempFlagsStack.pop()
		reservedNames = reservedNamesStack.pop()
	}

	reserveNameInNestedScopes := func(name string) {
		if !reservedNames || reservedNames == lastOrUndefined(reservedNamesStack) {
			reservedNames = NewSet()
		}
		reservedNames.add(name)
	}

	reservePrivateNameInNestedScopes := func(name string) {
		if !reservedPrivateNames || reservedPrivateNames == lastOrUndefined(reservedPrivateNamesStack) {
			reservedPrivateNames = NewSet()
		}
		reservedPrivateNames.add(name)
	}

	generateNames := func(node Node) {
		if !node {
			return
		}
		switch node.kind {
		case SyntaxKindBlock:
			forEach((node.(Block)).statements, generateNames)
		case SyntaxKindLabeledStatement,
			SyntaxKindWithStatement,
			SyntaxKindDoStatement,
			SyntaxKindWhileStatement:
			generateNames((node /* as LabeledStatement | WithStatement | DoStatement | WhileStatement */).statement)
		case SyntaxKindIfStatement:
			generateNames((node.(IfStatement)).thenStatement)
			generateNames((node.(IfStatement)).elseStatement)
		case SyntaxKindForStatement,
			SyntaxKindForOfStatement,
			SyntaxKindForInStatement:
			generateNames((node /* as ForStatement | ForInOrOfStatement */).initializer)
			generateNames((node /* as ForStatement | ForInOrOfStatement */).statement)
		case SyntaxKindSwitchStatement:
			generateNames((node.(SwitchStatement)).caseBlock)
		case SyntaxKindCaseBlock:
			forEach((node.(CaseBlock)).clauses, generateNames)
		case SyntaxKindCaseClause,
			SyntaxKindDefaultClause:
			forEach((node.(CaseOrDefaultClause)).statements, generateNames)
		case SyntaxKindTryStatement:
			generateNames((node.(TryStatement)).tryBlock)
			generateNames((node.(TryStatement)).catchClause)
			generateNames((node.(TryStatement)).finallyBlock)
		case SyntaxKindCatchClause:
			generateNames((node.(CatchClause)).variableDeclaration)
			generateNames((node.(CatchClause)).block)
		case SyntaxKindVariableStatement:
			generateNames((node.(VariableStatement)).declarationList)
		case SyntaxKindVariableDeclarationList:
			forEach((node.(VariableDeclarationList)).declarations, generateNames)
		case SyntaxKindVariableDeclaration,
			SyntaxKindParameter,
			SyntaxKindBindingElement,
			SyntaxKindClassDeclaration:
			generateNameIfNeeded((node.(NamedDeclaration)).name)
		case SyntaxKindFunctionDeclaration:
			generateNameIfNeeded((node.(FunctionDeclaration)).name)
			if getEmitFlags(node) & EmitFlagsReuseTempVariableScope {
				forEach((node.(FunctionDeclaration)).parameters, generateNames)
				generateNames((node.(FunctionDeclaration)).body)
			}
		case SyntaxKindObjectBindingPattern,
			SyntaxKindArrayBindingPattern:
			forEach((node.(BindingPattern)).elements, generateNames)
		case SyntaxKindImportDeclaration:
			generateNames((node.(ImportDeclaration)).importClause)
		case SyntaxKindImportClause:
			generateNameIfNeeded((node.(ImportClause)).name)
			generateNames((node.(ImportClause)).namedBindings)
		case SyntaxKindNamespaceImport:
			generateNameIfNeeded((node.(NamespaceImport)).name)
		case SyntaxKindNamespaceExport:
			generateNameIfNeeded((node.(NamespaceExport)).name)
		case SyntaxKindNamedImports:
			forEach((node.(NamedImports)).elements, generateNames)
		case SyntaxKindImportSpecifier:
			generateNameIfNeeded((node.(ImportSpecifier)).propertyName || (node.(ImportSpecifier)).name)
		}
	}

	generateMemberNames := func(node Node) {
		if !node {
			return
		}
		switch node.kind {
		case SyntaxKindPropertyAssignment,
			SyntaxKindShorthandPropertyAssignment,
			SyntaxKindPropertyDeclaration,
			SyntaxKindPropertySignature,
			SyntaxKindMethodDeclaration,
			SyntaxKindMethodSignature,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			generateNameIfNeeded((node.(NamedDeclaration)).name)
		}
	}

	generateNameIfNeeded := func(name *DeclarationName) {
		if name {
			if isGeneratedIdentifier(name) || isGeneratedPrivateIdentifier(name) {
				generateName(name)
			} else if isBindingPattern(name) {
				generateNames(name)
			}
		}
	}

	/**
	 * Generate the text for a generated identifier.
	 */

	generateName := func(name /* TODO(TS-TO-GO) TypeNode UnionType: GeneratedIdentifier | GeneratedPrivateIdentifier */ any) string {
		autoGenerate := name.emitNode.autoGenerate
		if (autoGenerate.flags & GeneratedIdentifierFlagsKindMask) == GeneratedIdentifierFlagsNode {
			// Node names generate unique names based on their original node
			// and are cached based on that node's id.
			return generateNameCached(getNodeForGeneratedName(name), isPrivateIdentifier(name), autoGenerate.flags, autoGenerate.prefix, autoGenerate.suffix)
		} else {
			// Auto, Loop, and Unique names are cached based on their unique
			// autoGenerateId.
			autoGenerateId := autoGenerate.id
			return autoGeneratedIdToGeneratedName[autoGenerateId] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: autoGeneratedIdToGeneratedName[autoGenerateId] = makeName(name) */ TODO)
		}
	}

	generateNameCached := func(node Node, privateName bool, flags GeneratedIdentifierFlags, prefix /* TODO(TS-TO-GO) TypeNode UnionType: string | GeneratedNamePart */ any, suffix string) string {
		nodeId := getNodeId(node)
		var cache []string
		if privateName {
			cache = nodeIdToGeneratedPrivateName
		} else {
			cache = nodeIdToGeneratedName
		}
		return cache[nodeId] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: cache[nodeId] = generateNameForNode(node, privateName, flags ?? GeneratedIdentifierFlags.None, formatGeneratedNamePart(prefix, generateName), formatGeneratedNamePart(suffix)) */ TODO)
	}

	/**
	 * Returns a value indicating whether a name is unique globally, within the current file,
	 * or within the NameGenerator.
	 */

	isUniqueName := func(name string, privateName bool) bool {
		return isFileLevelUniqueNameInCurrentFile(name, privateName) && !isReservedName(name, privateName) && !generatedNames.has(name)
	}

	isReservedName := func(name string, privateName bool) bool {
		var set *Set[string]
		var stack []*Set[string]
		if privateName {
			set = reservedPrivateNames
			stack = reservedPrivateNamesStack
		} else {
			set = reservedNames
			stack = reservedNamesStack
		}

		if set. /* ? */ has(name) {
			return true
		}
		for i := stack.length - 1; i >= 0; i-- {
			if set == stack[i] {
				continue
			}
			set = stack[i]
			if set. /* ? */ has(name) {
				return true
			}
		}
		return false
	}

	/**
	 * Returns a value indicating whether a name is unique globally or within the current file.
	 *
	 * @param _isPrivate (unused) this parameter exists to avoid an unnecessary adaptor frame in v8
	 * when `isfileLevelUniqueName` is passed as a callback to `makeUniqueName`.
	 */

	isFileLevelUniqueNameInCurrentFile := func(name string, _isPrivate bool) bool {
		if currentSourceFile {
			return isFileLevelUniqueName(currentSourceFile, name, hasGlobalName)
		} else {
			return true
		}
	}

	/**
	 * Returns a value indicating whether a name is unique within a container.
	 */

	isUniqueLocalName := func(name string, container *HasLocals) bool {
		for node := container; node && isNodeDescendantOf(node, container); node = node.nextContainer {
			if canHaveLocals(node) && node.locals {
				local := node.locals.get(escapeLeadingUnderscores(name))
				// We conservatively include alias symbols to cover cases where they're emitted as locals
				if local && local.flags&(SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias) {
					return false
				}
			}
		}
		return true
	}

	getTempFlags := func(formattedNameKey string) TempFlags {
		switch formattedNameKey {
		case "":
			return tempFlags
		case "#":
			return privateNameTempFlags
		default:
			return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: formattedNameTempFlags?.get(formattedNameKey) ?? TempFlags.Auto */ TODO
		}
	}

	setTempFlags := func(formattedNameKey string, flags TempFlags) {
		switch formattedNameKey {
		case "":
			tempFlags = flags
		case "#":
			privateNameTempFlags = flags
		default:
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: formattedNameTempFlags ??= new Map() */ TODO
			formattedNameTempFlags.set(formattedNameKey, flags)
		}
	}

	/**
	 * Return the next available name in the pattern _a ... _z, _0, _1, ...
	 * TempFlags._i or TempFlags._n may be used to express a preference for that dedicated name.
	 * Note that names generated by makeTempVariableName and makeUniqueName will never conflict.
	 */

	makeTempVariableName := func(flags TempFlags, reservedInNestedScopes bool, privateName bool, prefix string, suffix string) string {
		if prefix.length > 0 && prefix.charCodeAt(0) == CharacterCodeshash {
			prefix = prefix.slice(1)
		}

		// Generate a key to use to acquire a TempFlags counter based on the fixed portions of the generated name.
		key := formatGeneratedName(privateName, prefix, "", suffix)
		tempFlags := getTempFlags(key)

		if flags && !(tempFlags & flags) {
			var name /* TODO(TS-TO-GO) inferred type "_i" | "_n" */ any
			if flags == TempFlags_i {
				name = "_i"
			} else {
				name = "_n"
			}
			fullName := formatGeneratedName(privateName, prefix, name, suffix)
			if isUniqueName(fullName, privateName) {
				tempFlags |= flags
				if privateName {
					reservePrivateNameInNestedScopes(fullName)
				} else if reservedInNestedScopes {
					reserveNameInNestedScopes(fullName)
				}
				setTempFlags(key, tempFlags)
				return fullName
			}
		}

		for true {
			count := tempFlags & TempFlagsCountMask
			tempFlags++
			// Skip over 'i' and 'n'
			if count != 8 && count != 13 {
				var name string
				if count < 26 {
					name = "_" + String.fromCharCode(CharacterCodesa+count)
				} else {
					name = "_" + (count - 26)
				}
				fullName := formatGeneratedName(privateName, prefix, name, suffix)
				if isUniqueName(fullName, privateName) {
					if privateName {
						reservePrivateNameInNestedScopes(fullName)
					} else if reservedInNestedScopes {
						reserveNameInNestedScopes(fullName)
					}
					setTempFlags(key, tempFlags)
					return fullName
				}
			}
		}
	}

	/**
	 * Generate a name that is unique within the current file and doesn't conflict with any names
	 * in global scope. The name is formed by adding an '_n' suffix to the specified base name,
	 * where n is a positive integer. Note that names generated by makeTempVariableName and
	 * makeUniqueName are guaranteed to never conflict.
	 * If `optimistic` is set, the first instance will use 'baseName' verbatim instead of 'baseName_1'
	 */

	makeUniqueName := func(baseName string, checkFn func(name string, privateName bool) bool /*  = isUniqueName */, optimistic bool, scoped bool, privateName bool, prefix string, suffix string) string {
		if baseName.length > 0 && baseName.charCodeAt(0) == CharacterCodeshash {
			baseName = baseName.slice(1)
		}
		if prefix.length > 0 && prefix.charCodeAt(0) == CharacterCodeshash {
			prefix = prefix.slice(1)
		}
		if optimistic {
			fullName := formatGeneratedName(privateName, prefix, baseName, suffix)
			if checkFn(fullName, privateName) {
				if privateName {
					reservePrivateNameInNestedScopes(fullName)
				} else if scoped {
					reserveNameInNestedScopes(fullName)
				} else {
					generatedNames.add(fullName)
				}
				return fullName
			}
		}
		// Find the first unique 'name_n', where n is a positive number
		if baseName.charCodeAt(baseName.length-1) != CharacterCodes_ {
			baseName += "_"
		}
		i := 1
		for true {
			fullName := formatGeneratedName(privateName, prefix, baseName+i, suffix)
			if checkFn(fullName, privateName) {
				if privateName {
					reservePrivateNameInNestedScopes(fullName)
				} else if scoped {
					reserveNameInNestedScopes(fullName)
				} else {
					generatedNames.add(fullName)
				}
				return fullName
			}
			i++
		}
	}

	makeFileLevelOptimisticUniqueName := func(name string) string {
		return makeUniqueName(name, isFileLevelUniqueNameInCurrentFile /*optimistic*/, true /*scoped*/, false /*privateName*/, false /*prefix*/, "" /*suffix*/, "")
	}

	/**
	 * Generates a unique name for a ModuleDeclaration or EnumDeclaration.
	 */

	generateNameForModuleOrEnum := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ModuleDeclaration | EnumDeclaration */ any) string {
		name := getTextOfNode(node.name)
		// Use module/enum name itself if it is unique, otherwise make a unique variation
		if isUniqueLocalName(name, tryCast(node, canHaveLocals)) {
			return name
		} else {
			return makeUniqueName(name, isUniqueName /*optimistic*/, false /*scoped*/, false /*privateName*/, false /*prefix*/, "" /*suffix*/, "")
		}
	}

	/**
	 * Generates a unique name for an ImportDeclaration or ExportDeclaration.
	 */

	generateNameForImportOrExportDeclaration := func(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ExportDeclaration */ any) string {
		expr := getExternalModuleName(node)
		// TODO: GH#18217
		var baseName string
		if isStringLiteral(expr) {
			baseName = makeIdentifierFromModuleName(expr.text)
		} else {
			baseName = "module"
		}
		return makeUniqueName(baseName, isUniqueName /*optimistic*/, false /*scoped*/, false /*privateName*/, false /*prefix*/, "" /*suffix*/, "")
	}

	/**
	 * Generates a unique name for a default export.
	 */

	generateNameForExportDefault := func() string {
		return makeUniqueName("default", isUniqueName /*optimistic*/, false /*scoped*/, false /*privateName*/, false /*prefix*/, "" /*suffix*/, "")
	}

	/**
	 * Generates a unique name for a class expression.
	 */

	generateNameForClassExpression := func() string {
		return makeUniqueName("class", isUniqueName /*optimistic*/, false /*scoped*/, false /*privateName*/, false /*prefix*/, "" /*suffix*/, "")
	}

	generateNameForMethodOrAccessor := func(node /* TODO(TS-TO-GO) TypeNode UnionType: MethodDeclaration | AccessorDeclaration */ any, privateName bool, prefix string, suffix string) string {
		if isIdentifier(node.name) {
			return generateNameCached(node.name, privateName)
		}
		return makeTempVariableName(TempFlagsAuto /*reservedInNestedScopes*/, false, privateName, prefix, suffix)
	}

	/**
	 * Generates a unique name from a node.
	 */

	generateNameForNode := func(node Node, privateName bool, flags GeneratedIdentifierFlags, prefix string, suffix string) string {
		switch node.kind {
		case SyntaxKindIdentifier,
			SyntaxKindPrivateIdentifier:
			return makeUniqueName(getTextOfNode(node.(Identifier)), isUniqueName, !!(flags & GeneratedIdentifierFlagsOptimistic), !!(flags & GeneratedIdentifierFlagsReservedInNestedScopes), privateName, prefix, suffix)
		case SyntaxKindModuleDeclaration,
			SyntaxKindEnumDeclaration:
			Debug.assert(!prefix && !suffix && !privateName)
			return generateNameForModuleOrEnum(node /* as ModuleDeclaration | EnumDeclaration */)
		case SyntaxKindImportDeclaration,
			SyntaxKindExportDeclaration:
			Debug.assert(!prefix && !suffix && !privateName)
			return generateNameForImportOrExportDeclaration(node /* as ImportDeclaration | ExportDeclaration */)
		case SyntaxKindFunctionDeclaration,
			SyntaxKindClassDeclaration:
			Debug.assert(!prefix && !suffix && !privateName)
			name := (node /* as ClassDeclaration | FunctionDeclaration */).name
			if name && !isGeneratedIdentifier(name) {
				return generateNameForNode(name /*privateName*/, false, flags, prefix, suffix)
			}
			return generateNameForExportDefault()
		case SyntaxKindExportAssignment:
			Debug.assert(!prefix && !suffix && !privateName)
			return generateNameForExportDefault()
		case SyntaxKindClassExpression:
			Debug.assert(!prefix && !suffix && !privateName)
			return generateNameForClassExpression()
		case SyntaxKindMethodDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			return generateNameForMethodOrAccessor(node /* as MethodDeclaration | AccessorDeclaration */, privateName, prefix, suffix)
		case SyntaxKindComputedPropertyName:
			return makeTempVariableName(TempFlagsAuto /*reservedInNestedScopes*/, true, privateName, prefix, suffix)
		default:
			return makeTempVariableName(TempFlagsAuto /*reservedInNestedScopes*/, false, privateName, prefix, suffix)
		}
	}

	/**
	 * Generates a unique identifier for a node.
	 */

	makeName := func(name /* TODO(TS-TO-GO) TypeNode UnionType: GeneratedIdentifier | GeneratedPrivateIdentifier */ any) string {
		autoGenerate := name.emitNode.autoGenerate
		prefix := formatGeneratedNamePart(autoGenerate.prefix, generateName)
		suffix := formatGeneratedNamePart(autoGenerate.suffix)
		switch autoGenerate.flags & GeneratedIdentifierFlagsKindMask {
		case GeneratedIdentifierFlagsAuto:
			return makeTempVariableName(TempFlagsAuto, !!(autoGenerate.flags & GeneratedIdentifierFlagsReservedInNestedScopes), isPrivateIdentifier(name), prefix, suffix)
		case GeneratedIdentifierFlagsLoop:
			Debug.assertNode(name, isIdentifier)
			return makeTempVariableName(TempFlags_i, !!(autoGenerate.flags & GeneratedIdentifierFlagsReservedInNestedScopes) /*privateName*/, false, prefix, suffix)
		case GeneratedIdentifierFlagsUnique:
			return makeUniqueName(idText(name), ifelse((autoGenerate.flags&GeneratedIdentifierFlagsFileLevel), isFileLevelUniqueNameInCurrentFile, isUniqueName), !!(autoGenerate.flags & GeneratedIdentifierFlagsOptimistic), !!(autoGenerate.flags & GeneratedIdentifierFlagsReservedInNestedScopes), isPrivateIdentifier(name), prefix, suffix)
		}

		return Debug.fail(__TEMPLATE__("Unsupported GeneratedIdentifierKind: ", Debug.formatEnum(autoGenerate.flags&GeneratedIdentifierFlagsKindMask, (ts /* as any */).GeneratedIdentifierFlags /*isFlags*/, true), "."))
	}

	// Comments

	pipelineEmitWithComments := func(hint EmitHint, node Node) {
		pipelinePhase := getNextPipelinePhase(PipelinePhaseComments, hint, node)
		savedContainerPos := containerPos
		savedContainerEnd := containerEnd
		savedDeclarationListContainerEnd := declarationListContainerEnd
		emitCommentsBeforeNode(node)
		pipelinePhase(hint, node)
		emitCommentsAfterNode(node, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
	}

	emitCommentsBeforeNode := func(node Node) {
		emitFlags := getEmitFlags(node)
		commentRange := getCommentRange(node)

		// Emit leading comments
		emitLeadingCommentsOfNode(node, emitFlags, commentRange.pos, commentRange.end)
		if emitFlags & EmitFlagsNoNestedComments {
			commentsDisabled = true
		}
	}

	emitCommentsAfterNode := func(node Node, savedContainerPos number, savedContainerEnd number, savedDeclarationListContainerEnd number) {
		emitFlags := getEmitFlags(node)
		commentRange := getCommentRange(node)

		// Emit trailing comments
		if emitFlags & EmitFlagsNoNestedComments {
			commentsDisabled = false
		}
		emitTrailingCommentsOfNode(node, emitFlags, commentRange.pos, commentRange.end, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
		typeNode := getTypeNode(node)
		if typeNode {
			emitTrailingCommentsOfNode(node, emitFlags, typeNode.pos, typeNode.end, savedContainerPos, savedContainerEnd, savedDeclarationListContainerEnd)
		}
	}

	emitLeadingCommentsOfNode := func(node Node, emitFlags EmitFlags, pos number, end number) {
		enterComment()
		hasWrittenComment = false

		// We have to explicitly check that the node is JsxText because if the compilerOptions.jsx is "preserve" we will not do any transformation.
		// It is expensive to walk entire tree just to set one kind of node to have no comments.
		skipLeadingComments := pos < 0 || (emitFlags&EmitFlagsNoLeadingComments) != 0 || node.kind == SyntaxKindJsxText
		skipTrailingComments := end < 0 || (emitFlags&EmitFlagsNoTrailingComments) != 0 || node.kind == SyntaxKindJsxText

		// Save current container state on the stack.
		if (pos > 0 || end > 0) && pos != end {
			// Emit leading comments if the position is not synthesized and the node
			// has not opted out from emitting leading comments.
			if !skipLeadingComments {
				emitLeadingComments(pos /*isEmittedNode*/, node.kind != SyntaxKindNotEmittedStatement)
			}

			if !skipLeadingComments || (pos >= 0 && (emitFlags&EmitFlagsNoLeadingComments) != 0) {
				// Advance the container position if comments get emitted or if they've been disabled explicitly using NoLeadingComments.
				containerPos = pos
			}

			if !skipTrailingComments || (end >= 0 && (emitFlags&EmitFlagsNoTrailingComments) != 0) {
				// As above.
				containerEnd = end

				// To avoid invalid comment emit in a down-level binding pattern, we
				// keep track of the last declaration list container's end
				if node.kind == SyntaxKindVariableDeclarationList {
					declarationListContainerEnd = end
				}
			}
		}
		forEach(getSyntheticLeadingComments(node), emitLeadingSynthesizedComment)
		exitComment()
	}

	emitTrailingCommentsOfNode := func(node Node, emitFlags EmitFlags, pos number, end number, savedContainerPos number, savedContainerEnd number, savedDeclarationListContainerEnd number) {
		enterComment()
		skipTrailingComments := end < 0 || (emitFlags&EmitFlagsNoTrailingComments) != 0 || node.kind == SyntaxKindJsxText
		forEach(getSyntheticTrailingComments(node), emitTrailingSynthesizedComment)
		if (pos > 0 || end > 0) && pos != end {
			// Restore previous container state.
			containerPos = savedContainerPos
			containerEnd = savedContainerEnd
			declarationListContainerEnd = savedDeclarationListContainerEnd

			// Emit trailing comments if the position is not synthesized and the node
			// has not opted out from emitting leading comments and is an emitted node.
			if !skipTrailingComments && node.kind != SyntaxKindNotEmittedStatement {
				emitTrailingComments(end)
			}
		}
		exitComment()
	}

	emitLeadingSynthesizedComment := func(comment SynthesizedComment) {
		if comment.hasLeadingNewline || comment.kind == SyntaxKindSingleLineCommentTrivia {
			writer.writeLine()
		}
		writeSynthesizedComment(comment)
		if comment.hasTrailingNewLine || comment.kind == SyntaxKindSingleLineCommentTrivia {
			writer.writeLine()
		} else {
			writer.writeSpace(" ")
		}
	}

	emitTrailingSynthesizedComment := func(comment SynthesizedComment) {
		if !writer.isAtStartOfLine() {
			writer.writeSpace(" ")
		}
		writeSynthesizedComment(comment)
		if comment.hasTrailingNewLine {
			writer.writeLine()
		}
	}

	writeSynthesizedComment := func(comment SynthesizedComment) {
		text := formatSynthesizedComment(comment)
		var lineMap *[]number
		if comment.kind == SyntaxKindMultiLineCommentTrivia {
			lineMap = computeLineStarts(text)
		} else {
			lineMap = nil
		}
		writeCommentRange(text, lineMap, writer, 0, text.length, newLine)
	}

	formatSynthesizedComment := func(comment SynthesizedComment) string {
		if comment.kind == SyntaxKindMultiLineCommentTrivia {
			return __TEMPLATE__("/*", comment.text, "*/")
		} else {
			return __TEMPLATE__("//", comment.text)
		}
	}

	emitBodyWithDetachedComments := func(node T, detachedRange TextRange, emitCallback func(node T)) {
		enterComment()
		TODO_IDENTIFIER := detachedRange
		emitFlags := getEmitFlags(node)
		skipLeadingComments := pos < 0 || (emitFlags&EmitFlagsNoLeadingComments) != 0
		skipTrailingComments := commentsDisabled || end < 0 || (emitFlags&EmitFlagsNoTrailingComments) != 0
		if !skipLeadingComments {
			emitDetachedCommentsAndUpdateCommentsInfo(detachedRange)
		}

		exitComment()
		if emitFlags&EmitFlagsNoNestedComments && !commentsDisabled {
			commentsDisabled = true
			emitCallback(node)
			commentsDisabled = false
		} else {
			emitCallback(node)
		}

		enterComment()
		if !skipTrailingComments {
			emitLeadingComments(detachedRange.end /*isEmittedNode*/, true)
			if hasWrittenComment && !writer.isAtStartOfLine() {
				writer.writeLine()
			}
		}
		exitComment()
	}

	originalNodesHaveSameParent := func(nodeA Node, nodeB Node) bool {
		nodeA = getOriginalNode(nodeA)
		// For performance, do not call `getOriginalNode` for `nodeB` if `nodeA` doesn't even
		// have a parent node.
		return nodeA.parent && nodeA.parent == getOriginalNode(nodeB).parent
	}

	siblingNodePositionsAreComparable := func(previousNode Node, nextNode Node) bool {
		if nextNode.pos < previousNode.end {
			return false
		}

		previousNode = getOriginalNode(previousNode)
		nextNode = getOriginalNode(nextNode)
		parent := previousNode.parent
		if !parent || parent != nextNode.parent {
			return false
		}

		parentNodeArray := getContainingNodeArray(previousNode)
		prevNodeIndex := parentNodeArray. /* ? */ indexOf(previousNode)
		return prevNodeIndex != nil && prevNodeIndex > -1 && parentNodeArray.indexOf(nextNode) == prevNodeIndex+1
	}

	emitLeadingComments := func(pos number, isEmittedNode bool) {
		hasWrittenComment = false

		if isEmittedNode {
			if pos == 0 && currentSourceFile. /* ? */ isDeclarationFile {
				forEachLeadingCommentToEmit(pos, emitNonTripleSlashLeadingComment)
			} else {
				forEachLeadingCommentToEmit(pos, emitLeadingComment)
			}
		} else if pos == 0 {
			// If the node will not be emitted in JS, remove all the comments(normal, pinned and ///) associated with the node,
			// unless it is a triple slash comment at the top of the file.
			// For Example:
			//      /// <reference-path ...>
			//      declare var x;
			//      /// <reference-path ...>
			//      interface F {}
			//  The first /// will NOT be removed while the second one will be removed even though both node will not be emitted
			forEachLeadingCommentToEmit(pos, emitTripleSlashLeadingComment)
		}
	}

	emitTripleSlashLeadingComment := func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number) {
		if isTripleSlashComment(commentPos, commentEnd) {
			emitLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos)
		}
	}

	emitNonTripleSlashLeadingComment := func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number) {
		if !isTripleSlashComment(commentPos, commentEnd) {
			emitLeadingComment(commentPos, commentEnd, kind, hasTrailingNewLine, rangePos)
		}
	}

	shouldWriteComment := func(text string, pos number) bool {
		if printerOptions.onlyPrintJsDocStyle {
			return (isJSDocLikeText(text, pos) || isPinnedComment(text, pos))
		}
		return true
	}

	emitLeadingComment := func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number) {
		if !currentSourceFile || !shouldWriteComment(currentSourceFile.text, commentPos) {
			return
		}
		if !hasWrittenComment {
			emitNewLineBeforeLeadingCommentOfPosition(getCurrentLineMap(), writer, rangePos, commentPos)
			hasWrittenComment = true
		}

		// Leading comments are emitted at /*leading comment1 */space/*leading comment*/space
		emitPos(commentPos)
		writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine)
		emitPos(commentEnd)

		if hasTrailingNewLine {
			writer.writeLine()
		} else if kind == SyntaxKindMultiLineCommentTrivia {
			writer.writeSpace(" ")
		}
	}

	emitLeadingCommentsOfPosition := func(pos number) {
		if commentsDisabled || pos == -1 {
			return
		}

		emitLeadingComments(pos /*isEmittedNode*/, true)
	}

	emitTrailingComments := func(pos number) {
		forEachTrailingCommentToEmit(pos, emitTrailingComment)
	}

	emitTrailingComment := func(commentPos number, commentEnd number, _kind SyntaxKind, hasTrailingNewLine bool) {
		if !currentSourceFile || !shouldWriteComment(currentSourceFile.text, commentPos) {
			return
		}
		// trailing comments are emitted at space/*trailing comment1 */space/*trailing comment2*/
		if !writer.isAtStartOfLine() {
			writer.writeSpace(" ")
		}

		emitPos(commentPos)
		writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine)
		emitPos(commentEnd)

		if hasTrailingNewLine {
			writer.writeLine()
		}
	}

	emitTrailingCommentsOfPosition := func(pos number, prefixSpace bool, forceNoNewline bool) {
		if commentsDisabled {
			return
		}
		enterComment()
		forEachTrailingCommentToEmit(pos, ifelse(prefixSpace, emitTrailingComment, ifelse(forceNoNewline, emitTrailingCommentOfPositionNoNewline, emitTrailingCommentOfPosition)))
		exitComment()
	}

	emitTrailingCommentOfPositionNoNewline := func(commentPos number, commentEnd number, kind SyntaxKind) {
		if !currentSourceFile {
			return
		}
		// trailing comments of a position are emitted at /*trailing comment1 */space/*trailing comment*/space

		emitPos(commentPos)
		writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine)
		emitPos(commentEnd)

		if kind == SyntaxKindSingleLineCommentTrivia {
			writer.writeLine()
			// still write a newline for single-line comments, so closing tokens aren't written on the same line
		}
	}

	emitTrailingCommentOfPosition := func(commentPos number, commentEnd number, _kind SyntaxKind, hasTrailingNewLine bool) {
		if !currentSourceFile {
			return
		}
		// trailing comments of a position are emitted at /*trailing comment1 */space/*trailing comment*/space

		emitPos(commentPos)
		writeCommentRange(currentSourceFile.text, getCurrentLineMap(), writer, commentPos, commentEnd, newLine)
		emitPos(commentEnd)

		if hasTrailingNewLine {
			writer.writeLine()
		} else {
			writer.writeSpace(" ")
		}
	}

	forEachLeadingCommentToEmit := func(pos number, cb func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number)) {
		// Emit the leading comments only if the container's pos doesn't match because the container should take care of emitting these comments
		if currentSourceFile && (containerPos == -1 || pos != containerPos) {
			if hasDetachedComments(pos) {
				forEachLeadingCommentWithoutDetachedComments(cb)
			} else {
				forEachLeadingCommentRange(currentSourceFile.text, pos, cb /*state*/, pos)
			}
		}
	}

	forEachTrailingCommentToEmit := func(end number, cb func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool)) {
		// Emit the trailing comments only if the container's end doesn't match because the container should take care of emitting these comments
		if currentSourceFile && (containerEnd == -1 || (end != containerEnd && end != declarationListContainerEnd)) {
			forEachTrailingCommentRange(currentSourceFile.text, end, cb)
		}
	}

	hasDetachedComments := func(pos number) bool {
		return detachedCommentsInfo != nil && last(detachedCommentsInfo).nodePos == pos
	}

	forEachLeadingCommentWithoutDetachedComments := func(cb func(commentPos number, commentEnd number, kind SyntaxKind, hasTrailingNewLine bool, rangePos number)) {
		if !currentSourceFile {
			return
		}
		// get the leading comments from detachedPos
		pos := last(detachedCommentsInfo).detachedCommentEndPos
		if detachedCommentsInfo.length - 1 {
			detachedCommentsInfo.pop()
		} else {
			detachedCommentsInfo = nil
		}

		forEachLeadingCommentRange(currentSourceFile.text, pos, cb /*state*/, pos)
	}

	emitDetachedCommentsAndUpdateCommentsInfo := func(range_ TextRange) {
		currentDetachedCommentInfo := currentSourceFile && emitDetachedComments(currentSourceFile.text, getCurrentLineMap(), writer, emitComment, range_, newLine, commentsDisabled)
		if currentDetachedCommentInfo {
			if detachedCommentsInfo {
				detachedCommentsInfo.push(currentDetachedCommentInfo)
			} else {
				detachedCommentsInfo = [] /* TODO(TS-TO-GO) inferred type ts.DetachedCommentInfo */ any{currentDetachedCommentInfo}
			}
		}
	}

	emitComment := func(text string, lineMap []number, writer EmitTextWriter, commentPos number, commentEnd number, newLine string) {
		if !currentSourceFile || !shouldWriteComment(currentSourceFile.text, commentPos) {
			return
		}
		emitPos(commentPos)
		writeCommentRange(text, lineMap, writer, commentPos, commentEnd, newLine)
		emitPos(commentEnd)
	}

	/**
	 * Determine if the given comment is a triple-slash
	 *
	 * @return true if the comment is a triple-slash comment else false
	 */

	isTripleSlashComment := func(commentPos number, commentEnd number) bool {
		return !!currentSourceFile && isRecognizedTripleSlashComment(currentSourceFile.text, commentPos, commentEnd)
	}

	// Source Maps
	pipelineEmitWithSourceMaps := func(hint EmitHint, node Node) {
		pipelinePhase := getNextPipelinePhase(PipelinePhaseSourceMaps, hint, node)
		emitSourceMapsBeforeNode(node)
		pipelinePhase(hint, node)
		emitSourceMapsAfterNode(node)
	}

	emitSourceMapsBeforeNode := func(node Node) {
		emitFlags := getEmitFlags(node)
		sourceMapRange := getSourceMapRange(node)

		// Emit leading sourcemap
		source := sourceMapRange.source || sourceMapSource
		if node.kind != SyntaxKindNotEmittedStatement && (emitFlags&EmitFlagsNoLeadingSourceMap) == 0 && sourceMapRange.pos >= 0 {
			emitSourcePos(sourceMapRange.source || sourceMapSource, skipSourceTrivia(source, sourceMapRange.pos))
		}
		if emitFlags & EmitFlagsNoNestedSourceMaps {
			sourceMapsDisabled = true
		}
	}

	emitSourceMapsAfterNode := func(node Node) {
		emitFlags := getEmitFlags(node)
		sourceMapRange := getSourceMapRange(node)

		// Emit trailing sourcemap
		if emitFlags & EmitFlagsNoNestedSourceMaps {
			sourceMapsDisabled = false
		}
		if node.kind != SyntaxKindNotEmittedStatement && (emitFlags&EmitFlagsNoTrailingSourceMap) == 0 && sourceMapRange.end >= 0 {
			emitSourcePos(sourceMapRange.source || sourceMapSource, sourceMapRange.end)
		}
	}

	/**
	 * Skips trivia such as comments and white-space that can be optionally overridden by the source-map source
	 */

	skipSourceTrivia := func(source SourceMapSource, pos number) number {
		if source.skipTrivia {
			return source.skipTrivia(pos)
		} else {
			return skipTrivia(source.text, pos)
		}
	}

	/**
	 * Emits a mapping.
	 *
	 * If the position is synthetic (undefined or a negative value), no mapping will be
	 * created.
	 *
	 * @param pos The position.
	 */

	emitPos := func(pos number) {
		if sourceMapsDisabled || positionIsSynthesized(pos) || isJsonSourceMapSource(sourceMapSource) {
			return
		}

		TODO_IDENTIFIER := getLineAndCharacterOfPosition(sourceMapSource, pos)
		sourceMapGenerator.addMapping(writer.getLine(), writer.getColumn(), sourceMapSourceIndex, sourceLine, sourceCharacter, nil)
	}

	emitSourcePos := func(source SourceMapSource, pos number) {
		if source != sourceMapSource {
			savedSourceMapSource := sourceMapSource
			savedSourceMapSourceIndex := sourceMapSourceIndex
			setSourceMapSource(source)
			emitPos(pos)
			resetSourceMapSource(savedSourceMapSource, savedSourceMapSourceIndex)
		} else {
			emitPos(pos)
		}
	}

	/**
	 * Emits a token of a node with possible leading and trailing source maps.
	 *
	 * @param node The node containing the token.
	 * @param token The token to emit.
	 * @param tokenStartPos The start pos of the token.
	 * @param emitCallback The callback used to emit the token.
	 */

	emitTokenWithSourceMap := func(node Node, token SyntaxKind, writer func(s string), tokenPos number, emitCallback func(token SyntaxKind, writer func(s string), tokenStartPos number) number) number {
		if sourceMapsDisabled || node && isInJsonFile(node) {
			return emitCallback(token, writer, tokenPos)
		}

		emitNode := node && node.emitNode
		emitFlags := emitNode && emitNode.flags || EmitFlagsNone
		range_ := emitNode && emitNode.tokenSourceMapRanges && emitNode.tokenSourceMapRanges[token]
		source := range_ && range_.source || sourceMapSource

		tokenPos = skipSourceTrivia(source, ifelse(range_, range_.pos, tokenPos))
		if (emitFlags&EmitFlagsNoTokenLeadingSourceMaps) == 0 && tokenPos >= 0 {
			emitSourcePos(source, tokenPos)
		}

		tokenPos = emitCallback(token, writer, tokenPos)

		if range_ {
			tokenPos = range_.end
		}
		if (emitFlags&EmitFlagsNoTokenTrailingSourceMaps) == 0 && tokenPos >= 0 {
			emitSourcePos(source, tokenPos)
		}

		return tokenPos
	}

	setSourceMapSource := func(source SourceMapSource) {
		if sourceMapsDisabled {
			return
		}

		sourceMapSource = source

		if source == mostRecentlyAddedSourceMapSource {
			// Fast path for when the new source map is the most recently added, in which case
			// we use its captured index without going through the source map generator.
			sourceMapSourceIndex = mostRecentlyAddedSourceMapSourceIndex
			return
		}

		if isJsonSourceMapSource(source) {
			return
		}

		sourceMapSourceIndex = sourceMapGenerator.addSource(source.fileName)
		if printerOptions.inlineSources {
			sourceMapGenerator.setSourceContent(sourceMapSourceIndex, source.text)
		}

		mostRecentlyAddedSourceMapSource = source
		mostRecentlyAddedSourceMapSourceIndex = sourceMapSourceIndex
	}

	resetSourceMapSource := func(source SourceMapSource, sourceIndex number) {
		sourceMapSource = source
		sourceMapSourceIndex = sourceIndex
	}

	isJsonSourceMapSource := func(sourceFile SourceMapSource) bool {
		return fileExtensionIs(sourceFile.fileName, ExtensionJson)
	}

}

func createBracketsMap() [][]string {
	var brackets [][]string = []never{}
	brackets[ListFormatBraces] = []string{"{", "}"}
	brackets[ListFormatParenthesis] = []string{"(", ")"}
	brackets[ListFormatAngleBrackets] = []string{"<", ">"}
	brackets[ListFormatSquareBrackets] = []string{"[", "]"}
	return brackets
}

func getOpeningBracket(format ListFormat) string {
	return brackets[format&ListFormatBracketsMask][0]
}

func getClosingBracket(format ListFormat) string {
	return brackets[format&ListFormatBracketsMask][1]
}

// Flags enum to track count of temp variables and a few dedicated names
type TempFlags int32

const (
	TempFlagsAuto      TempFlags = 0x00000000
	TempFlagsCountMask TempFlags = 0x0FFFFFFF
	TempFlags_i        TempFlags = 0x10000000
)

type OrdinalParentheizerRuleSelector[T Node] struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: interface OrdinalParentheizerRuleSelector<T extends Node> { select(index: number): ((node: T) => T) | undefined; } */
}

type ParenthesizerRule[T Node] func(node T) T

type ParenthesizerRuleOrSelector[T Node] /* TODO(TS-TO-GO) TypeNode UnionType: OrdinalParentheizerRuleSelector<T> | ParenthesizerRule<T> */ any

type EmitFunction func(node T, parenthesizerRule ParenthesizerRule[T])
type EmitListItemFunction[T Node] func(node Node, emit EmitFunction, parenthesizerRule *ParenthesizerRuleOrSelector[T], index number)

func emitListItemNoParenthesizer(node Node, emit EmitFunction, _parenthesizerRule *ParenthesizerRuleOrSelector[Node], _index number) {
	emit(node)
}

func emitListItemWithParenthesizerRuleSelector(node Node, emit EmitFunction, parenthesizerRuleSelector *OrdinalParentheizerRuleSelector[Node], index number) {
	emit(node, parenthesizerRuleSelector.select_(index))
}

func emitListItemWithParenthesizerRule(node Node, emit EmitFunction, parenthesizerRule *ParenthesizerRule[Node], _index number) {
	emit(node, parenthesizerRule)
}

func getEmitListItem(emit EmitFunction, parenthesizerRule *ParenthesizerRuleOrSelector[T]) EmitListItemFunction[T] {
	switch {
	case emit.length == 1:
		return emitListItemNoParenthesizer.(EmitListItemFunction[T])
	case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof parenthesizerRule */ TODO == "object":
		return emitListItemWithParenthesizerRuleSelector.(EmitListItemFunction[T])
	default:
		return emitListItemWithParenthesizerRule.(EmitListItemFunction[T])
	}
}
