// Code generated by ts-to-go at 52c59dbcbee274e523ef39e6c8be1bd5e110c2f1. DO NOT EDIT.

package output

type SignatureFlags int32

const (
	SignatureFlagsNone                   SignatureFlags = 0
	SignatureFlagsYield                  SignatureFlags = 1 << 0
	SignatureFlagsAwait                  SignatureFlags = 1 << 1
	SignatureFlagsType                   SignatureFlags = 1 << 2
	SignatureFlagsIgnoreMissingOpenBrace SignatureFlags = 1 << 4
	SignatureFlagsJSDoc                  SignatureFlags = 1 << 5
)

type SpeculationKind int32

const (
	SpeculationKindTryParse SpeculationKind = iota
	SpeculationKindLookahead
	SpeculationKindReparse
)

var NodeConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind, pos: number, end: number) => Node */ any
var TokenConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind, pos: number, end: number) => Node */ any
var IdentifierConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind.Identifier, pos: number, end: number) => Node */ any
var PrivateIdentifierConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => Node */ any
var SourceFileConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind.SourceFile, pos: number, end: number) => Node */ any

/**
 * NOTE: You should not use this, it is only exported to support `createNode` in `~/src/deprecatedCompat/deprecations.ts`.
 *
 * @internal
 * @knipignore
 */

var parseBaseNodeFactory BaseNodeFactory = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"createBaseSourceFileNode": func(kind /* TODO(TS-TO-GO) inferred type SyntaxKind.SourceFile */ any) Node {
		return /* TODO(TS-TO-GO) Node NewExpression: new (SourceFileConstructor || (SourceFileConstructor = objectAllocator.getSourceFileConstructor()))(kind, -1, -1) */ TODO
	},
	"createBaseIdentifierNode": func(kind /* TODO(TS-TO-GO) inferred type SyntaxKind.Identifier */ any) Node {
		return /* TODO(TS-TO-GO) Node NewExpression: new (IdentifierConstructor || (IdentifierConstructor = objectAllocator.getIdentifierConstructor()))(kind, -1, -1) */ TODO
	},
	"createBasePrivateIdentifierNode": func(kind /* TODO(TS-TO-GO) inferred type SyntaxKind.PrivateIdentifier */ any) Node {
		return /* TODO(TS-TO-GO) Node NewExpression: new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = objectAllocator.getPrivateIdentifierConstructor()))(kind, -1, -1) */ TODO
	},
	"createBaseTokenNode": func(kind SyntaxKind) Node {
		return /* TODO(TS-TO-GO) Node NewExpression: new (TokenConstructor || (TokenConstructor = objectAllocator.getTokenConstructor()))(kind, -1, -1) */ TODO
	},
	"createBaseNode": func(kind SyntaxKind) Node {
		return /* TODO(TS-TO-GO) Node NewExpression: new (NodeConstructor || (NodeConstructor = objectAllocator.getNodeConstructor()))(kind, -1, -1) */ TODO
	},
}

/** @internal */

var parseNodeFactory NodeFactory = createNodeFactory(NodeFactoryFlagsNoParenthesizerRules, parseBaseNodeFactory)

func visitNode(cbNode func(node Node) T, node Node) *T {
	return node && cbNode(node)
}

func visitNodes(cbNode func(node Node) T, cbNodes *func(node NodeArray[Node]) *T, nodes *NodeArray[Node]) *T {
	if nodes {
		if cbNodes {
			return cbNodes(nodes)
		}
		for _, node := range nodes {
			result := cbNode(node)
			if result {
				return result
			}
		}
	}
}

/** @internal */

func isJSDocLikeText(text string, start number) bool {
	return text.charCodeAt(start+1) == CharacterCodesasterisk && text.charCodeAt(start+2) == CharacterCodesasterisk && text.charCodeAt(start+3) != CharacterCodesslash
}

/** @internal */

func isFileProbablyExternalModule(sourceFile SourceFile) Node {
	// Try to use the first top-level import/export when available, then
	// fall back to looking for an 'import.meta' somewhere in the tree if necessary.
	return forEach(sourceFile.statements, isAnExternalModuleIndicatorNode) || getImportMetaIfNecessary(sourceFile)
}

func isAnExternalModuleIndicatorNode(node Node) *HasModifiers {
	if canHaveModifiers(node) && hasModifierOfKind(node, SyntaxKindExportKeyword) || isImportEqualsDeclaration(node) && isExternalModuleReference(node.moduleReference) || isImportDeclaration(node) || isExportAssignment(node) || isExportDeclaration(node) {
		return node
	} else {
		return nil
	}
}

func getImportMetaIfNecessary(sourceFile SourceFile) Node {
	if sourceFile.flags & NodeFlagsPossiblyContainsImportMeta {
		return walkTreeForImportMeta(sourceFile)
	} else {
		return nil
	}
}

func walkTreeForImportMeta(node Node) Node {
	if isImportMeta(node) {
		return node
	} else {
		return forEachChild(node, walkTreeForImportMeta)
	}
}

/** Do not use hasModifier inside the parser; it relies on parent pointers. Use this instead. */

func hasModifierOfKind(node HasModifiers, kind SyntaxKind) bool {
	return some(node.modifiers, func(m /* TODO(TS-TO-GO) inferred type Decorator | AbstractKeyword | AccessorKeyword | AsyncKeyword | ConstKeyword | DeclareKeyword | DefaultKeyword | ExportKeyword | InKeyword | PrivateKeyword | ProtectedKeyword | PublicKeyword | OutKeyword | OverrideKeyword | ReadonlyKeyword | StaticKeyword */ any) bool {
		return m.kind == kind
	})
}

func isImportMeta(node Node) bool {
	return isMetaProperty(node) && node.keywordToken == SyntaxKindImportKeyword && node.name.escapedText == "meta"
}

type ForEachChildFunction[TNode any] func(node TNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T
type ForEachChildTable /* TODO(TS-TO-GO) TypeNode MappedType: { [TNode in ForEachChildNodes as TNode["kind"]]: ForEachChildFunction<TNode>; } */ any

var forEachChildTable ForEachChildTable = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"TODO_IDENTIFIER": func /* forEachChildInQualifiedName */ (node QualifiedName, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.left) || visitNode(cbNode, node.right)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypeParameter */ (node TypeParameterDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.constraint) || visitNode(cbNode, node.default_) || visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInShorthandPropertyAssignment */ (node ShorthandPropertyAssignment, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.exclamationToken) || visitNode(cbNode, node.equalsToken) || visitNode(cbNode, node.objectAssignmentInitializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInSpreadAssignment */ (node SpreadAssignment, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInParameter */ (node ParameterDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.dotDotDotToken) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInPropertyDeclaration */ (node PropertyDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.exclamationToken) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInPropertySignature */ (node PropertySignature, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInPropertyAssignment */ (node PropertyAssignment, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.exclamationToken) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInVariableDeclaration */ (node VariableDeclaration, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name) || visitNode(cbNode, node.exclamationToken) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInBindingElement */ (node BindingElement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.dotDotDotToken) || visitNode(cbNode, node.propertyName) || visitNode(cbNode, node.name) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInIndexSignature */ (node IndexSignatureDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInConstructorType */ (node ConstructorTypeNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInFunctionType */ (node FunctionTypeNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": forEachChildInCallOrConstructSignature,
	"TODO_IDENTIFIER": forEachChildInCallOrConstructSignature,
	"TODO_IDENTIFIER": func /* forEachChildInMethodDeclaration */ (node MethodDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.asteriskToken) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.exclamationToken) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInMethodSignature */ (node MethodSignature, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInConstructor */ (node ConstructorDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInGetAccessor */ (node GetAccessorDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInSetAccessor */ (node SetAccessorDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInFunctionDeclaration */ (node FunctionDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.asteriskToken) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInFunctionExpression */ (node FunctionExpression, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.asteriskToken) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInArrowFunction */ (node ArrowFunction, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_) || visitNode(cbNode, node.equalsGreaterThanToken) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInClassStaticBlockDeclaration */ (node ClassStaticBlockDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypeReference */ (node TypeReferenceNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.typeName) || visitNodes(cbNode, cbNodes, node.typeArguments)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypePredicate */ (node TypePredicateNode, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.assertsModifier) || visitNode(cbNode, node.parameterName) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypeQuery */ (node TypeQueryNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.exprName) || visitNodes(cbNode, cbNodes, node.typeArguments)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypeLiteral */ (node TypeLiteralNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.members)
	},
	"TODO_IDENTIFIER": func /* forEachChildInArrayType */ (node ArrayTypeNode, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.elementType)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTupleType */ (node TupleTypeNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.elements)
	},
	"TODO_IDENTIFIER": forEachChildInUnionOrIntersectionType,
	"TODO_IDENTIFIER": forEachChildInUnionOrIntersectionType,
	"TODO_IDENTIFIER": func /* forEachChildInConditionalType */ (node ConditionalTypeNode, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.checkType) || visitNode(cbNode, node.extendsType) || visitNode(cbNode, node.trueType) || visitNode(cbNode, node.falseType)
	},
	"TODO_IDENTIFIER": func /* forEachChildInInferType */ (node InferTypeNode, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.typeParameter)
	},
	"TODO_IDENTIFIER": func /* forEachChildInImportType */ (node ImportTypeNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.argument) || visitNode(cbNode, node.attributes) || visitNode(cbNode, node.qualifier) || visitNodes(cbNode, cbNodes, node.typeArguments)
	},
	"TODO_IDENTIFIER": func /* forEachChildInImportTypeAssertionContainer */ (node ImportTypeAssertionContainer, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.assertClause)
	},
	"TODO_IDENTIFIER": forEachChildInParenthesizedTypeOrTypeOperator,
	"TODO_IDENTIFIER": forEachChildInParenthesizedTypeOrTypeOperator,
	"TODO_IDENTIFIER": func /* forEachChildInIndexedAccessType */ (node IndexedAccessTypeNode, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.objectType) || visitNode(cbNode, node.indexType)
	},
	"TODO_IDENTIFIER": func /* forEachChildInMappedType */ (node MappedTypeNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.readonlyToken) || visitNode(cbNode, node.typeParameter) || visitNode(cbNode, node.nameType) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.type_) || visitNodes(cbNode, cbNodes, node.members)
	},
	"TODO_IDENTIFIER": func /* forEachChildInLiteralType */ (node LiteralTypeNode, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.literal)
	},
	"TODO_IDENTIFIER": func /* forEachChildInNamedTupleMember */ (node NamedTupleMember, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.dotDotDotToken) || visitNode(cbNode, node.name) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": forEachChildInObjectOrArrayBindingPattern,
	"TODO_IDENTIFIER": forEachChildInObjectOrArrayBindingPattern,
	"TODO_IDENTIFIER": func /* forEachChildInArrayLiteralExpression */ (node ArrayLiteralExpression, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.elements)
	},
	"TODO_IDENTIFIER": func /* forEachChildInObjectLiteralExpression */ (node ObjectLiteralExpression, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.properties)
	},
	"TODO_IDENTIFIER": func /* forEachChildInPropertyAccessExpression */ (node PropertyAccessExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.questionDotToken) || visitNode(cbNode, node.name)
	},
	"TODO_IDENTIFIER": func /* forEachChildInElementAccessExpression */ (node ElementAccessExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.questionDotToken) || visitNode(cbNode, node.argumentExpression)
	},
	"TODO_IDENTIFIER": forEachChildInCallOrNewExpression,
	"TODO_IDENTIFIER": forEachChildInCallOrNewExpression,
	"TODO_IDENTIFIER": func /* forEachChildInTaggedTemplateExpression */ (node TaggedTemplateExpression, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tag) || visitNode(cbNode, node.questionDotToken) || visitNodes(cbNode, cbNodes, node.typeArguments) || visitNode(cbNode, node.template)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypeAssertionExpression */ (node TypeAssertion, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.type_) || visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInParenthesizedExpression */ (node ParenthesizedExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInDeleteExpression */ (node DeleteExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypeOfExpression */ (node TypeOfExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInVoidExpression */ (node VoidExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInPrefixUnaryExpression */ (node PrefixUnaryExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.operand)
	},
	"TODO_IDENTIFIER": func /* forEachChildInYieldExpression */ (node YieldExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.asteriskToken) || visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInAwaitExpression */ (node AwaitExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInPostfixUnaryExpression */ (node PostfixUnaryExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.operand)
	},
	"TODO_IDENTIFIER": func /* forEachChildInBinaryExpression */ (node BinaryExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.left) || visitNode(cbNode, node.operatorToken) || visitNode(cbNode, node.right)
	},
	"TODO_IDENTIFIER": func /* forEachChildInAsExpression */ (node AsExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInNonNullExpression */ (node NonNullExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInSatisfiesExpression */ (node SatisfiesExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInMetaProperty */ (node MetaProperty, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name)
	},
	"TODO_IDENTIFIER": func /* forEachChildInConditionalExpression */ (node ConditionalExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.condition) || visitNode(cbNode, node.questionToken) || visitNode(cbNode, node.whenTrue) || visitNode(cbNode, node.colonToken) || visitNode(cbNode, node.whenFalse)
	},
	"TODO_IDENTIFIER": func /* forEachChildInSpreadElement */ (node SpreadElement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": forEachChildInBlock,
	"TODO_IDENTIFIER": forEachChildInBlock,
	"TODO_IDENTIFIER": func /* forEachChildInSourceFile */ (node SourceFile, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.statements) || visitNode(cbNode, node.endOfFileToken)
	},
	"TODO_IDENTIFIER": func /* forEachChildInVariableStatement */ (node VariableStatement, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.declarationList)
	},
	"TODO_IDENTIFIER": func /* forEachChildInVariableDeclarationList */ (node VariableDeclarationList, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.declarations)
	},
	"TODO_IDENTIFIER": func /* forEachChildInExpressionStatement */ (node ExpressionStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInIfStatement */ (node IfStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.thenStatement) || visitNode(cbNode, node.elseStatement)
	},
	"TODO_IDENTIFIER": func /* forEachChildInDoStatement */ (node DoStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.statement) || visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInWhileStatement */ (node WhileStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.statement)
	},
	"TODO_IDENTIFIER": func /* forEachChildInForStatement */ (node ForStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.initializer) || visitNode(cbNode, node.condition) || visitNode(cbNode, node.incrementor) || visitNode(cbNode, node.statement)
	},
	"TODO_IDENTIFIER": func /* forEachChildInForInStatement */ (node ForInStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.initializer) || visitNode(cbNode, node.expression) || visitNode(cbNode, node.statement)
	},
	"TODO_IDENTIFIER": func /* forEachChildInForOfStatement */ (node ForOfStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.awaitModifier) || visitNode(cbNode, node.initializer) || visitNode(cbNode, node.expression) || visitNode(cbNode, node.statement)
	},
	"TODO_IDENTIFIER": forEachChildInContinueOrBreakStatement,
	"TODO_IDENTIFIER": forEachChildInContinueOrBreakStatement,
	"TODO_IDENTIFIER": func /* forEachChildInReturnStatement */ (node ReturnStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInWithStatement */ (node WithStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.statement)
	},
	"TODO_IDENTIFIER": func /* forEachChildInSwitchStatement */ (node SwitchStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.caseBlock)
	},
	"TODO_IDENTIFIER": func /* forEachChildInCaseBlock */ (node CaseBlock, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.clauses)
	},
	"TODO_IDENTIFIER": func /* forEachChildInCaseClause */ (node CaseClause, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNodes(cbNode, cbNodes, node.statements)
	},
	"TODO_IDENTIFIER": func /* forEachChildInDefaultClause */ (node DefaultClause, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.statements)
	},
	"TODO_IDENTIFIER": func /* forEachChildInLabeledStatement */ (node LabeledStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.label) || visitNode(cbNode, node.statement)
	},
	"TODO_IDENTIFIER": func /* forEachChildInThrowStatement */ (node ThrowStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTryStatement */ (node TryStatement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tryBlock) || visitNode(cbNode, node.catchClause) || visitNode(cbNode, node.finallyBlock)
	},
	"TODO_IDENTIFIER": func /* forEachChildInCatchClause */ (node CatchClause, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.variableDeclaration) || visitNode(cbNode, node.block)
	},
	"TODO_IDENTIFIER": func /* forEachChildInDecorator */ (node Decorator, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": forEachChildInClassDeclarationOrExpression,
	"TODO_IDENTIFIER": forEachChildInClassDeclarationOrExpression,
	"TODO_IDENTIFIER": func /* forEachChildInInterfaceDeclaration */ (node InterfaceDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.heritageClauses) || visitNodes(cbNode, cbNodes, node.members)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTypeAliasDeclaration */ (node TypeAliasDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInEnumDeclaration */ (node EnumDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.members)
	},
	"TODO_IDENTIFIER": func /* forEachChildInEnumMember */ (node EnumMember, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInModuleDeclaration */ (node ModuleDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.body)
	},
	"TODO_IDENTIFIER": func /* forEachChildInImportEqualsDeclaration */ (node ImportEqualsDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNode(cbNode, node.moduleReference)
	},
	"TODO_IDENTIFIER": func /* forEachChildInImportDeclaration */ (node ImportDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.importClause) || visitNode(cbNode, node.moduleSpecifier) || visitNode(cbNode, node.attributes)
	},
	"TODO_IDENTIFIER": func /* forEachChildInImportClause */ (node ImportClause, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name) || visitNode(cbNode, node.namedBindings)
	},
	"TODO_IDENTIFIER": func /* forEachChildInImportAttributes */ (node ImportAttributes, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.elements)
	},
	"TODO_IDENTIFIER": func /* forEachChildInImportAttribute */ (node ImportAttribute, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name) || visitNode(cbNode, node.value)
	},
	"TODO_IDENTIFIER": func /* forEachChildInNamespaceExportDeclaration */ (node NamespaceExportDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name)
	},
	"TODO_IDENTIFIER": func /* forEachChildInNamespaceImport */ (node NamespaceImport, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name)
	},
	"TODO_IDENTIFIER": func /* forEachChildInNamespaceExport */ (node NamespaceExport, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name)
	},
	"TODO_IDENTIFIER": forEachChildInNamedImportsOrExports,
	"TODO_IDENTIFIER": forEachChildInNamedImportsOrExports,
	"TODO_IDENTIFIER": func /* forEachChildInExportDeclaration */ (node ExportDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.exportClause) || visitNode(cbNode, node.moduleSpecifier) || visitNode(cbNode, node.attributes)
	},
	"TODO_IDENTIFIER": forEachChildInImportOrExportSpecifier,
	"TODO_IDENTIFIER": forEachChildInImportOrExportSpecifier,
	"TODO_IDENTIFIER": func /* forEachChildInExportAssignment */ (node ExportAssignment, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTemplateExpression */ (node TemplateExpression, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTemplateSpan */ (node TemplateSpan, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNode(cbNode, node.literal)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTemplateLiteralType */ (node TemplateLiteralTypeNode, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.head) || visitNodes(cbNode, cbNodes, node.templateSpans)
	},
	"TODO_IDENTIFIER": func /* forEachChildInTemplateLiteralTypeSpan */ (node TemplateLiteralTypeSpan, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.type_) || visitNode(cbNode, node.literal)
	},
	"TODO_IDENTIFIER": func /* forEachChildInComputedPropertyName */ (node ComputedPropertyName, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInHeritageClause */ (node HeritageClause, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.types)
	},
	"TODO_IDENTIFIER": func /* forEachChildInExpressionWithTypeArguments */ (node ExpressionWithTypeArguments, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression) || visitNodes(cbNode, cbNodes, node.typeArguments)
	},
	"TODO_IDENTIFIER": func /* forEachChildInExternalModuleReference */ (node ExternalModuleReference, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInMissingDeclaration */ (node MissingDeclaration, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.modifiers)
	},
	"TODO_IDENTIFIER": func /* forEachChildInCommaListExpression */ (node CommaListExpression, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.elements)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJsxElement */ (node JsxElement, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.openingElement) || visitNodes(cbNode, cbNodes, node.children) || visitNode(cbNode, node.closingElement)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJsxFragment */ (node JsxFragment, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.openingFragment) || visitNodes(cbNode, cbNodes, node.children) || visitNode(cbNode, node.closingFragment)
	},
	"TODO_IDENTIFIER": forEachChildInJsxOpeningOrSelfClosingElement,
	"TODO_IDENTIFIER": forEachChildInJsxOpeningOrSelfClosingElement,
	"TODO_IDENTIFIER": func /* forEachChildInJsxAttributes */ (node JsxAttributes, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.properties)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJsxAttribute */ (node JsxAttribute, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name) || visitNode(cbNode, node.initializer)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJsxSpreadAttribute */ (node JsxSpreadAttribute, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJsxExpression */ (node JsxExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.dotDotDotToken) || visitNode(cbNode, node.expression)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJsxClosingElement */ (node JsxClosingElement, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJsxNamespacedName */ (node JsxNamespacedName, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.namespace) || visitNode(cbNode, node.name)
	},
	"TODO_IDENTIFIER": forEachChildInOptionalRestOrJSDocParameterModifier,
	"TODO_IDENTIFIER": forEachChildInOptionalRestOrJSDocParameterModifier,
	"TODO_IDENTIFIER": forEachChildInOptionalRestOrJSDocParameterModifier,
	"TODO_IDENTIFIER": forEachChildInOptionalRestOrJSDocParameterModifier,
	"TODO_IDENTIFIER": forEachChildInOptionalRestOrJSDocParameterModifier,
	"TODO_IDENTIFIER": forEachChildInOptionalRestOrJSDocParameterModifier,
	"TODO_IDENTIFIER": forEachChildInOptionalRestOrJSDocParameterModifier,
	"TODO_IDENTIFIER": func /* forEachChildInJSDocFunctionType */ (node JSDocFunctionType, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDoc */ (node JSDoc, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment))) || visitNodes(cbNode, cbNodes, node.tags)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocSeeTag */ (node JSDocSeeTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName) || visitNode(cbNode, node.name) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocNameReference */ (node JSDocNameReference, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.name)
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocMemberName */ (node JSDocMemberName, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.left) || visitNode(cbNode, node.right)
	},
	"TODO_IDENTIFIER": forEachChildInJSDocParameterOrPropertyTag,
	"TODO_IDENTIFIER": forEachChildInJSDocParameterOrPropertyTag,
	"TODO_IDENTIFIER": func /* forEachChildInJSDocAuthorTag */ (node JSDocAuthorTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocImplementsTag */ (node JSDocImplementsTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName) || visitNode(cbNode, node.class) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocAugmentsTag */ (node JSDocAugmentsTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName) || visitNode(cbNode, node.class) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocTemplateTag */ (node JSDocTemplateTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName) || visitNode(cbNode, node.constraint) || visitNodes(cbNode, cbNodes, node.typeParameters) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocTypedefTag */ (node JSDocTypedefTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName) || (ifelse(node.typeExpression && node.typeExpression.kind == SyntaxKindJSDocTypeExpression, visitNode(cbNode, node.typeExpression) || visitNode(cbNode, node.fullName) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment))), visitNode(cbNode, node.fullName) || visitNode(cbNode, node.typeExpression) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))))
	},
	"TODO_IDENTIFIER": func /* forEachChildInJSDocCallbackTag */ (node JSDocCallbackTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
		return visitNode(cbNode, node.tagName) || visitNode(cbNode, node.fullName) || visitNode(cbNode, node.typeExpression) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
	},
	"TODO_IDENTIFIER": forEachChildInJSDocTypeLikeTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTypeLikeTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTypeLikeTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTypeLikeTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTypeLikeTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTypeLikeTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTypeLikeTag,
	"TODO_IDENTIFIER": func /* forEachChildInJSDocSignature */ (node JSDocSignature, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return forEach(node.typeParameters, cbNode) || forEach(node.parameters, cbNode) || visitNode(cbNode, node.type_)
	},
	"TODO_IDENTIFIER": forEachChildInJSDocLinkCodeOrPlain,
	"TODO_IDENTIFIER": forEachChildInJSDocLinkCodeOrPlain,
	"TODO_IDENTIFIER": forEachChildInJSDocLinkCodeOrPlain,
	"TODO_IDENTIFIER": func /* forEachChildInJSDocTypeLiteral */ (node JSDocTypeLiteral, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
		return forEach(node.jsDocPropertyTags, cbNode)
	},
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocTag,
	"TODO_IDENTIFIER": forEachChildInJSDocImportTag,
	"TODO_IDENTIFIER": forEachChildInPartiallyEmittedExpression,
}

// shared

func forEachChildInCallOrConstructSignature(node /* TODO(TS-TO-GO) TypeNode UnionType: CallSignatureDeclaration | ConstructSignatureDeclaration */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.parameters) || visitNode(cbNode, node.type_)
}

func forEachChildInUnionOrIntersectionType(node /* TODO(TS-TO-GO) TypeNode UnionType: UnionTypeNode | IntersectionTypeNode */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNodes(cbNode, cbNodes, node.types)
}

func forEachChildInParenthesizedTypeOrTypeOperator(node /* TODO(TS-TO-GO) TypeNode UnionType: ParenthesizedTypeNode | TypeOperatorNode */ any, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.type_)
}

func forEachChildInObjectOrArrayBindingPattern(node BindingPattern, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNodes(cbNode, cbNodes, node.elements)
}

func forEachChildInCallOrNewExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | NewExpression */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.expression) || visitNode(cbNode, (node.(CallExpression)).questionDotToken) || visitNodes(cbNode, cbNodes, node.typeArguments) || visitNodes(cbNode, cbNodes, node.arguments)
}

func forEachChildInBlock(node /* TODO(TS-TO-GO) TypeNode UnionType: Block | ModuleBlock */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNodes(cbNode, cbNodes, node.statements)
}

func forEachChildInContinueOrBreakStatement(node /* TODO(TS-TO-GO) TypeNode UnionType: ContinueStatement | BreakStatement */ any, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.label)
}

func forEachChildInClassDeclarationOrExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassDeclaration | ClassExpression */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNodes(cbNode, cbNodes, node.modifiers) || visitNode(cbNode, node.name) || visitNodes(cbNode, cbNodes, node.typeParameters) || visitNodes(cbNode, cbNodes, node.heritageClauses) || visitNodes(cbNode, cbNodes, node.members)
}

func forEachChildInNamedImportsOrExports(node /* TODO(TS-TO-GO) TypeNode UnionType: NamedImports | NamedExports */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNodes(cbNode, cbNodes, node.elements)
}

func forEachChildInImportOrExportSpecifier(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportSpecifier | ExportSpecifier */ any, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.propertyName) || visitNode(cbNode, node.name)
}

func forEachChildInJsxOpeningOrSelfClosingElement(node JsxOpeningLikeElement, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.tagName) || visitNodes(cbNode, cbNodes, node.typeArguments) || visitNode(cbNode, node.attributes)
}

func forEachChildInOptionalRestOrJSDocParameterModifier(node /* TODO(TS-TO-GO) TypeNode UnionType: OptionalTypeNode | RestTypeNode | JSDocTypeExpression | JSDocNullableType | JSDocNonNullableType | JSDocOptionalType | JSDocVariadicType */ any, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.type_)
}

func forEachChildInJSDocParameterOrPropertyTag(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocParameterTag | JSDocPropertyTag */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.tagName) || (ifelse(node.isNameFirst, visitNode(cbNode, node.name) || visitNode(cbNode, node.typeExpression), visitNode(cbNode, node.typeExpression) || visitNode(cbNode, node.name))) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
}

func forEachChildInJSDocTypeLikeTag(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocReturnTag | JSDocTypeTag | JSDocThisTag | JSDocEnumTag | JSDocThrowsTag | JSDocOverloadTag | JSDocSatisfiesTag */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.tagName) || visitNode(cbNode, node.typeExpression) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
}

func forEachChildInJSDocLinkCodeOrPlain(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.name)
}

func forEachChildInJSDocTag(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocUnknownTag | JSDocClassTag | JSDocPublicTag | JSDocPrivateTag | JSDocProtectedTag | JSDocReadonlyTag | JSDocDeprecatedTag | JSDocOverrideTag */ any, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.tagName) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
}

func forEachChildInJSDocImportTag(node JSDocImportTag, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.tagName) || visitNode(cbNode, node.importClause) || visitNode(cbNode, node.moduleSpecifier) || visitNode(cbNode, node.attributes) || (ifelse( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.comment */ TODO == "string", nil, visitNodes(cbNode, cbNodes, node.comment)))
}

func forEachChildInPartiallyEmittedExpression(node PartiallyEmittedExpression, cbNode func(node Node) *T, _cbNodes func(nodes NodeArray[Node]) *T) *T {
	return visitNode(cbNode, node.expression)
}

/**
 * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
 * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
 * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
 * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
 *
 * @param node a given node to visit its children
 * @param cbNode a callback to be invoked for all child nodes
 * @param cbNodes a callback to be invoked for embedded array
 *
 * @remarks `forEachChild` must visit the children of a node in the order
 * that they appear in the source code. The language service depends on this property to locate nodes by position.
 */

func forEachChild(node Node, cbNode func(node Node) *T, cbNodes func(nodes NodeArray[Node]) *T) *T {
	if node == nil || node.kind <= SyntaxKindLastToken {
		return
	}
	fn := (forEachChildTable.(Record[SyntaxKind, ForEachChildFunction[any]]))[node.kind]
	if fn == nil {
		return nil
	} else {
		return fn(node, cbNode, cbNodes)
	}
}

/**
 * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
 * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; additionally,
 * unlike `forEachChild`, embedded arrays are flattened and the 'cbNode' callback is invoked for each element.
 *  If a callback returns a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
 *
 * @param node a given node to visit its children
 * @param cbNode a callback to be invoked for all child nodes
 * @param cbNodes a callback to be invoked for embedded array
 *
 * @remarks Unlike `forEachChild`, `forEachChildRecursively` handles recursively invoking the traversal on each child node found,
 * and while doing so, handles traversing the structure without relying on the callstack to encode the tree structure.
 *
 * @internal
 */

func forEachChildRecursively(rootNode Node, cbNode func(node Node, parent Node) /* TODO(TS-TO-GO) TypeNode UnionType: T | "skip" | undefined */ any, cbNodes func(nodes NodeArray[Node], parent Node) /* TODO(TS-TO-GO) TypeNode UnionType: T | "skip" | undefined */ any) *T {
	var queue [] /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any = gatherPossibleChildren(rootNode)
	var parents []Node = []never{}
	// tracks parent references for elements in queue
	for parents.length < queue.length {
		parents.push(rootNode)
	}
	for queue.length != 0 {
		current := queue.pop()
		parent := parents.pop()
		if isArray(current) {
			if cbNodes {
				res := cbNodes(current, parent)
				if res {
					if res == "skip" {
						continue
					}
					return res
				}
			}
			for i := current.length - 1; i >= 0; i-- {
				queue.push(current[i])
				parents.push(parent)
			}
		} else {
			res := cbNode(current, parent)
			if res {
				if res == "skip" {
					continue
				}
				return res
			}
			if current.kind >= SyntaxKindFirstNode {
				// add children in reverse order to the queue, so popping gives the first child
				for _, child := range gatherPossibleChildren(current) {
					queue.push(child)
					parents.push(current)
				}
			}
		}
	}
}

func gatherPossibleChildren(node Node) [] /* TODO(TS-TO-GO) inferred type (Node | NodeArray<Node>) */ any {
	var children [] /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any = []never{}
	forEachChild(node, addWorkItem, addWorkItem)
	// By using a stack above and `unshift` here, we emulate a depth-first preorder traversal
	return children

	addWorkItem := func(n /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any) {
		children.unshift(n)
	}

}

type CreateSourceFileOptions struct {
	languageVersion            ScriptTarget
	impliedNodeFormat          ResolutionMode
	setExternalModuleIndicator func(file SourceFile)
	packageJsonLocations       []string
	packageJsonScope           PackageJsonInfo
	jsDocParsingMode           JSDocParsingMode
}

func setExternalModuleIndicator(sourceFile SourceFile) {
	sourceFile.externalModuleIndicator = isFileProbablyExternalModule(sourceFile)
}

func createSourceFile(fileName string, sourceText string, languageVersionOrOptions /* TODO(TS-TO-GO) TypeNode UnionType: ScriptTarget | CreateSourceFileOptions */ any, setParentNodes bool /*  = false */, scriptKind ScriptKind) SourceFile {
	tracing. /* ? */ push(tracing.Phase.Parse, "createSourceFile", map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"path": fileName,
	}, /*separateBeginAndEnd*/ true)
	performance.mark("beforeParse")
	var result SourceFile

	var TODO_IDENTIFIER any
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof languageVersionOrOptions */ TODO == "object" {
		TODO_IDENTIFIER = languageVersionOrOptions
	} else {
		TODO_IDENTIFIER = (map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"languageVersion": languageVersionOrOptions,
		}.(CreateSourceFileOptions))
	}
	if languageVersion == ScriptTargetJSON {
		result = Parser.parseSourceFile(fileName, sourceText, languageVersion /*syntaxCursor*/, nil, setParentNodes, ScriptKindJSON, noop, jsDocParsingMode)
	} else {
		var setIndicator * /* TODO(TS-TO-GO) inferred type ((file: SourceFile) => void) */ any
		if format == nil {
			setIndicator = overrideSetExternalModuleIndicator
		} else {
			setIndicator = func(file SourceFile) {
				file.impliedNodeFormat = format
				return (overrideSetExternalModuleIndicator || setExternalModuleIndicator)(file)
			}
		}
		result = Parser.parseSourceFile(fileName, sourceText, languageVersion /*syntaxCursor*/, nil, setParentNodes, scriptKind, setIndicator, jsDocParsingMode)
	}

	performance.mark("afterParse")
	performance.measure("Parse", "beforeParse", "afterParse")
	tracing. /* ? */ pop()
	return result
}

func parseIsolatedEntityName(text string, languageVersion ScriptTarget) *EntityName {
	return Parser.parseIsolatedEntityName(text, languageVersion)
}

/**
 * Parse json text into SyntaxTree and return node and parse errors if any
 * @param fileName
 * @param sourceText
 */

func parseJsonText(fileName string, sourceText string) JsonSourceFile {
	return Parser.parseJsonText(fileName, sourceText)
}

// See also `isExternalOrCommonJsModule` in utilities.ts
func isExternalModule(file SourceFile) bool {
	return file.externalModuleIndicator != nil
}

// Produces a new SourceFile for the 'newText' provided. The 'textChangeRange' parameter
// indicates what changed between the 'text' that this SourceFile has and the 'newText'.
// The SourceFile will be created with the compiler attempting to reuse as many nodes from
// this file as possible.
//
// Note: this function mutates nodes from this SourceFile. That means any existing nodes
// from this SourceFile that are being held onto may change as a result (including
// becoming detached from any SourceFile).  It is recommended that this SourceFile not
// be used once 'update' is called on it.
func updateSourceFile(sourceFile SourceFile, newText string, textChangeRange TextChangeRange, aggressiveChecks bool /*  = false */) SourceFile {
	newSourceFile := IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks)
	// Because new source file node is created, it may not have the flag PossiblyContainDynamicImport. This is the case if there is no new edit to add dynamic import.
	// We will manually port the flag to the new source file.
	(newSourceFile.(Mutable[SourceFile])).flags |= sourceFile.flags & NodeFlagsPermanentlySetIncrementalFlags
	return newSourceFile
}

/** @internal */

type JsDocWithDiagnostics struct {
	jsDoc       JSDoc
	diagnostics []Diagnostic
}

/** @internal */

func parseIsolatedJSDocComment(content string, start number, length number) *JsDocWithDiagnostics {
	result := Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length)
	if result && result.jsDoc {
		// because the jsDocComment was parsed out of the source file, it might
		// not be covered by the fixupParentReferences.
		Parser.fixupParentReferences(result.jsDoc)
	}

	return result
}

/** @internal */
// Exposed only for testing.

func parseJSDocTypeExpressionForTests(content string, start number, length number) * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { jsDocTypeExpression: JSDocTypeExpression; diagnostics: Diagnostic[]; } */ any {
	return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length)
}

// Implement the parser as a singleton module.  We do this for perf reasons because creating
// parser instances can actually be expensive enough to impact us on projects with many source
// files.
// #region Parser

// Why var? It avoids TDZ checks in the runtime which can be costly.
// See: https://github.com/microsoft/TypeScript/issues/52924
/* eslint-disable no-var */

// Share a single scanner across all calls to parse a source file.  This helps speed things
// up by avoiding the cost of creating/compiling scanners over and over again.
var scanner = createScanner(ScriptTargetLatest /*skipTrivia*/, true)

var disallowInAndDecoratorContext = NodeFlagsDisallowInContext | NodeFlagsDecoratorContext

// capture constructors in 'initializeState' to avoid null checks
var NodeConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind, pos: number, end: number) => Node */ any
var TokenConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind, pos: number, end: number) => Node */ any
var IdentifierConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind.Identifier, pos: number, end: number) => Identifier */ any
var PrivateIdentifierConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind.PrivateIdentifier, pos: number, end: number) => PrivateIdentifier */ any
var SourceFileConstructor /* TODO(TS-TO-GO) TypeNode ConstructorType: new (kind: SyntaxKind.SourceFile, pos: number, end: number) => SourceFile */ any

func countNode(node Node) Node {
	nodeCount++
	return node
}

// Rather than using `createBaseNodeFactory` here, we establish a `BaseNodeFactory` that closes over the
// constructors above, which are reset each time `initializeState` is called.
var baseNodeFactory BaseNodeFactory = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"createBaseSourceFileNode": func(kind /* TODO(TS-TO-GO) inferred type SyntaxKind.SourceFile */ any) Node {
		return countNode(NewSourceFileConstructor(kind, 0, 0))
	},
	"createBaseIdentifierNode": func(kind /* TODO(TS-TO-GO) inferred type SyntaxKind.Identifier */ any) Node {
		return countNode(NewIdentifierConstructor(kind, 0, 0))
	},
	"createBasePrivateIdentifierNode": func(kind /* TODO(TS-TO-GO) inferred type SyntaxKind.PrivateIdentifier */ any) Node {
		return countNode(NewPrivateIdentifierConstructor(kind, 0, 0))
	},
	"createBaseTokenNode": func(kind SyntaxKind) Node {
		return countNode(NewTokenConstructor(kind, 0, 0))
	},
	"createBaseNode": func(kind SyntaxKind) Node {
		return countNode(NewNodeConstructor(kind, 0, 0))
	},
}

var factory = createNodeFactory(NodeFactoryFlagsNoParenthesizerRules|NodeFactoryFlagsNoNodeConverters|NodeFactoryFlagsNoOriginalNode, baseNodeFactory)

var TODO_IDENTIFIER = factory

var fileName string
var sourceFlags NodeFlags
var sourceText string
var languageVersion ScriptTarget
var scriptKind ScriptKind
var languageVariant LanguageVariant
var parseDiagnostics []DiagnosticWithDetachedLocation
var jsDocDiagnostics []DiagnosticWithDetachedLocation
var syntaxCursor * /* TODO(TS-TO-GO) Node QualifiedName: IncrementalParser.SyntaxCursor */ any

var currentToken SyntaxKind
var nodeCount number
var identifiers Map[string, string]
var identifierCount number

// TODO(jakebailey): This type is a lie; this value actually contains the result
// of ORing a bunch of `1 << ParsingContext.XYZ`.
var parsingContext ParsingContext

var notParenthesizedArrow *Set[number]

// Flags that dictate what parsing context we're in.  For example:
// Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
// that some tokens that would be considered identifiers may be considered keywords.
//
// When adding more parser context flags, consider which is the more common case that the
// flag will be in.  This should be the 'false' state for that flag.  The reason for this is
// that we don't store data in our nodes unless the value is in the *non-default* state.  So,
// for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for
// 'disallow-in' set to 'false'.  Otherwise, if we had 'allowsIn' set to 'true', then almost
// all nodes would need extra state on them to store this info.
//
// Note: 'allowIn' and 'allowYield' track 1:1 with the [in] and [yield] concepts in the ES6
// grammar specification.
//
// An important thing about these context concepts.  By default they are effectively inherited
// while parsing through every grammar production.  i.e. if you don't change them, then when
// you parse a sub-production, it will have the same context values as the parent production.
// This is great most of the time.  After all, consider all the 'expression' grammar productions
// and how nearly all of them pass along the 'in' and 'yield' context values:
//
// EqualityExpression[In, Yield] :
//
//	RelationalExpression[?In, ?Yield]
//	EqualityExpression[?In, ?Yield] == RelationalExpression[?In, ?Yield]
//	EqualityExpression[?In, ?Yield] != RelationalExpression[?In, ?Yield]
//	EqualityExpression[?In, ?Yield] === RelationalExpression[?In, ?Yield]
//	EqualityExpression[?In, ?Yield] !== RelationalExpression[?In, ?Yield]
//
// Where you have to be careful is then understanding what the points are in the grammar
// where the values are *not* passed along.  For example:
//
// SingleNameBinding[Yield,GeneratorParameter]
//
//	[+GeneratorParameter]BindingIdentifier[Yield] Initializer[In]opt
//	[~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt
//
// Here this is saying that if the GeneratorParameter context flag is set, that we should
// explicitly set the 'yield' context flag to false before calling into the BindingIdentifier
// and we should explicitly unset the 'yield' context flag before calling into the Initializer.
// production.  Conversely, if the GeneratorParameter context flag is not set, then we
// should leave the 'yield' context flag alone.
//
// Getting this all correct is tricky and requires careful reading of the grammar to
// understand when these values should be changed versus when they should be inherited.
//
// Note: it should not be necessary to save/restore these flags during speculative/lookahead
// parsing.  These context flags are naturally stored and restored through normal recursive
// descent parsing and unwinding.
var contextFlags NodeFlags

// Indicates whether we are currently parsing top-level statements.
var topLevel = true

// Whether or not we've had a parse error since creating the last AST node.  If we have
// encountered an error, it will be stored on the next AST node we create.  Parse errors
// can be broken down into three categories:
//
//  1. An error that occurred during scanning.  For example, an unterminated literal, or a
//     character that was completely not understood.
//
//  2. A token was expected, but was not present.  This type of error is commonly produced
//     by the 'parseExpected' function.
//
//  3. A token was present that no parsing function was able to consume.  This type of error
//     only occurs in the 'abortParsingListOrMoveToNextToken' function when the parser
//     decides to skip the token.
//
// In all of these cases, we want to mark the next node as having had an error before it.
// With this mark, we can know in incremental settings if this node can be reused, or if
// we have to reparse it.  If we don't keep this information around, we may just reuse the
// node.  in that event we would then not produce the same errors as we did before, causing
// significant confusion problems.
//
// Note: it is necessary that this value be saved/restored during speculative/lookahead
// parsing.  During lookahead parsing, we will often create a node.  That node will have
// this value attached, and then this value will be set back to 'false'.  If we decide to
// rewind, we must get back to the same value we had prior to the lookahead.
//
// Note: any errors at the end of the file that do not precede a regular node, should get
// attached to the EOF token.
var parseErrorBeforeNextFinishedNode = false

/* eslint-enable no-var */

func parseSourceFile(fileName string, sourceText string, languageVersion ScriptTarget, syntaxCursor * /* TODO(TS-TO-GO) Node QualifiedName: IncrementalParser.SyntaxCursor */ any, setParentNodes bool /*  = false */, scriptKind ScriptKind, setExternalModuleIndicatorOverride func(file SourceFile), jsDocParsingMode JSDocParsingMode /*  = JSDocParsingMode.ParseAll */) SourceFile {
	scriptKind = ensureScriptKind(fileName, scriptKind)
	if scriptKind == ScriptKindJSON {
		result := parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes)
		convertToJson(result, result.statements[0]. /* ? */ expression, result.parseDiagnostics /*returnValue*/, false /*jsonConversionNotifier*/, nil)
		result.referencedFiles = emptyArray
		result.typeReferenceDirectives = emptyArray
		result.libReferenceDirectives = emptyArray
		result.amdDependencies = emptyArray
		result.hasNoDefaultLib = false
		result.pragmas = emptyMap.(ReadonlyPragmaMap)
		return result
	}

	initializeState(fileName, sourceText, languageVersion, syntaxCursor, scriptKind, jsDocParsingMode)

	result := parseSourceFileWorker(languageVersion, setParentNodes, scriptKind, setExternalModuleIndicatorOverride || setExternalModuleIndicator, jsDocParsingMode)

	clearState()

	return result
}

func parseIsolatedEntityName(content string, languageVersion ScriptTarget) *EntityName {
	// Choice of `isDeclarationFile` should be arbitrary
	initializeState("", content, languageVersion /*syntaxCursor*/, nil, ScriptKindJS, JSDocParsingModeParseAll)
	// Prime the scanner.
	nextToken()
	entityName := parseEntityName(true)
	isValid := token() == SyntaxKindEndOfFileToken && !parseDiagnostics.length
	clearState()
	if isValid {
		return entityName
	} else {
		return nil
	}
}

func parseJsonText(fileName string, sourceText string, languageVersion ScriptTarget /*  = ScriptTarget.ES2015 */, syntaxCursor /* TODO(TS-TO-GO) Node QualifiedName: IncrementalParser.SyntaxCursor */ any, setParentNodes bool /*  = false */) JsonSourceFile {
	initializeState(fileName, sourceText, languageVersion, syntaxCursor, ScriptKindJSON, JSDocParsingModeParseAll)
	sourceFlags = contextFlags

	// Prime the scanner.
	nextToken()
	pos := getNodePos()
	var statements TODO
	var endOfFileToken TODO
	if token() == SyntaxKindEndOfFileToken {
		statements = createNodeArray([]never{}, pos, pos)
		endOfFileToken = parseTokenNode()
	} else {
		// Loop and synthesize an ArrayLiteralExpression if there are more than
		// one top-level expressions to ensure all input text is consumed.
		var expressions /* TODO(TS-TO-GO) TypeNode UnionType: Expression[] | Expression | undefined */ any
		for token() != SyntaxKindEndOfFileToken {
			var expression TODO
			switch token() {
			case SyntaxKindOpenBracketToken:
				expression = parseArrayLiteralExpression()
			case SyntaxKindTrueKeyword,
				SyntaxKindFalseKeyword,
				SyntaxKindNullKeyword:
				expression = parseTokenNode()
			case SyntaxKindMinusToken:
				if lookAhead(func() bool {
					return nextToken() == SyntaxKindNumericLiteral && nextToken() != SyntaxKindColonToken
				}) {
					expression = parsePrefixUnaryExpression().(JsonMinusNumericLiteral)
				} else {
					expression = parseObjectLiteralExpression()
				}
			case SyntaxKindNumericLiteral,
				SyntaxKindStringLiteral:
				if lookAhead(func() bool {
					return nextToken() != SyntaxKindColonToken
				}) {
					expression = parseLiteralNode() /* as StringLiteral | NumericLiteral */
					break
				}
				fallthrough
			default:
				expression = parseObjectLiteralExpression()
			}

			// Error recovery: collect multiple top-level expressions
			if expressions && isArray(expressions) {
				expressions.push(expression)
			} else if expressions {
				expressions = []Expression{expressions, expression}
			} else {
				expressions = expression
				if token() != SyntaxKindEndOfFileToken {
					parseErrorAtCurrentToken(Diagnostics.Unexpected_token)
				}
			}
		}

		var expression Expression
		if isArray(expressions) {
			expression = finishNode(factoryCreateArrayLiteralExpression(expressions), pos)
		} else {
			expression = Debug.checkDefined(expressions)
		}
		statement := factoryCreateExpressionStatement(expression).(JsonObjectExpressionStatement)
		finishNode(statement, pos)
		statements = createNodeArray([]JsonObjectExpressionStatement{statement}, pos)
		endOfFileToken = parseExpectedToken(SyntaxKindEndOfFileToken, Diagnostics.Unexpected_token).(EndOfFileToken)
	}

	// Set source file so that errors will be reported with this file name
	sourceFile := createSourceFile(fileName, ScriptTargetES2015, ScriptKindJSON /*isDeclarationFile*/, false, statements, endOfFileToken, sourceFlags, noop)

	if setParentNodes {
		fixupParentReferences(sourceFile)
	}

	sourceFile.nodeCount = nodeCount
	sourceFile.identifierCount = identifierCount
	sourceFile.identifiers = identifiers
	sourceFile.parseDiagnostics = attachFileToDiagnostics(parseDiagnostics, sourceFile)
	if jsDocDiagnostics {
		sourceFile.jsDocDiagnostics = attachFileToDiagnostics(jsDocDiagnostics, sourceFile)
	}

	result := sourceFile.(JsonSourceFile)
	clearState()
	return result
}

func initializeState(_fileName string, _sourceText string, _languageVersion ScriptTarget, _syntaxCursor * /* TODO(TS-TO-GO) Node QualifiedName: IncrementalParser.SyntaxCursor */ any, _scriptKind ScriptKind, _jsDocParsingMode JSDocParsingMode) {
	NodeConstructor = objectAllocator.getNodeConstructor()
	TokenConstructor = objectAllocator.getTokenConstructor()
	IdentifierConstructor = objectAllocator.getIdentifierConstructor()
	PrivateIdentifierConstructor = objectAllocator.getPrivateIdentifierConstructor()
	SourceFileConstructor = objectAllocator.getSourceFileConstructor()

	fileName = normalizePath(_fileName)
	sourceText = _sourceText
	languageVersion = _languageVersion
	syntaxCursor = _syntaxCursor
	scriptKind = _scriptKind
	languageVariant = getLanguageVariant(_scriptKind)

	parseDiagnostics = []never{}
	parsingContext = 0
	identifiers = NewMap[string, string]()
	identifierCount = 0
	nodeCount = 0
	sourceFlags = 0
	topLevel = true

	switch scriptKind {
	case ScriptKindJS,
		ScriptKindJSX:
		contextFlags = NodeFlagsJavaScriptFile
	case ScriptKindJSON:
		contextFlags = NodeFlagsJavaScriptFile | NodeFlagsJsonFile
	default:
		contextFlags = NodeFlagsNone
	}
	parseErrorBeforeNextFinishedNode = false

	// Initialize and prime the scanner before parsing the source elements.
	scanner.setText(sourceText)
	scanner.setOnError(scanError)
	scanner.setScriptTarget(languageVersion)
	scanner.setLanguageVariant(languageVariant)
	scanner.setScriptKind(scriptKind)
	scanner.setJSDocParsingMode(_jsDocParsingMode)
}

func clearState() {
	// Clear out the text the scanner is pointing at, so it doesn't keep anything alive unnecessarily.
	scanner.clearCommentDirectives()
	scanner.setText("")
	scanner.setOnError(nil)
	scanner.setScriptKind(ScriptKindUnknown)
	scanner.setJSDocParsingMode(JSDocParsingModeParseAll)

	// Clear any data.  We don't want to accidentally hold onto it for too long.
	sourceText = nil
	languageVersion = nil
	syntaxCursor = nil
	scriptKind = nil
	languageVariant = nil
	sourceFlags = 0
	parseDiagnostics = nil
	jsDocDiagnostics = nil
	parsingContext = 0
	identifiers = nil
	notParenthesizedArrow = nil
	topLevel = true
}

func parseSourceFileWorker(languageVersion ScriptTarget, setParentNodes bool, scriptKind ScriptKind, setExternalModuleIndicator func(file SourceFile), jsDocParsingMode JSDocParsingMode) SourceFile {
	isDeclarationFile := isDeclarationFileName(fileName)
	if isDeclarationFile {
		contextFlags |= NodeFlagsAmbient
	}

	sourceFlags = contextFlags

	// Prime the scanner.
	nextToken()

	statements := parseList(ParsingContextSourceElements, parseStatement)
	Debug.assert(token() == SyntaxKindEndOfFileToken)
	endHasJSDoc := hasPrecedingJSDocComment()
	endOfFileToken := withJSDoc(parseTokenNode(), endHasJSDoc)

	sourceFile := createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile, statements, endOfFileToken, sourceFlags, setExternalModuleIndicator)

	// A member of ReadonlyArray<T> isn't assignable to a member of T[] (and prevents a direct cast) - but this is where we set up those members so they can be readonly in the future
	processCommentPragmas(sourceFile. /* as {} */ (PragmaContext), sourceText)
	processPragmasIntoFields(sourceFile. /* as {} */ (PragmaContext), reportPragmaDiagnostic)

	sourceFile.commentDirectives = scanner.getCommentDirectives()
	sourceFile.nodeCount = nodeCount
	sourceFile.identifierCount = identifierCount
	sourceFile.identifiers = identifiers
	sourceFile.parseDiagnostics = attachFileToDiagnostics(parseDiagnostics, sourceFile)
	sourceFile.jsDocParsingMode = jsDocParsingMode
	if jsDocDiagnostics {
		sourceFile.jsDocDiagnostics = attachFileToDiagnostics(jsDocDiagnostics, sourceFile)
	}

	if setParentNodes {
		fixupParentReferences(sourceFile)
	}

	return sourceFile

	reportPragmaDiagnostic := func(pos number, end number, diagnostic DiagnosticMessage) {
		parseDiagnostics.push(createDetachedDiagnostic(fileName, sourceText, pos, end, diagnostic))
	}

}

var hasDeprecatedTag = false

func withJSDoc(node T, hasJSDoc bool) T {
	if !hasJSDoc {
		return node
	}

	Debug.assert(!node.jsDoc)
	// Should only be called once per node
	jsDoc := mapDefined(getJSDocCommentRanges(node, sourceText), func(comment CommentRange) *JSDoc {
		return JSDocParser.parseJSDocComment(node, comment.pos, comment.end-comment.pos)
	})
	if jsDoc.length {
		node.jsDoc = jsDoc
	}
	if hasDeprecatedTag {
		hasDeprecatedTag = false
		(node.(Mutable[T])).flags |= NodeFlagsDeprecated
	}
	return node
}

func reparseTopLevelAwait(sourceFile SourceFile) SourceFile {
	savedSyntaxCursor := syntaxCursor
	baseSyntaxCursor := IncrementalParser.createSyntaxCursor(sourceFile)
	syntaxCursor = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"currentNode": currentNode,
	}

	var statements []Statement = []never{}
	savedParseDiagnostics := parseDiagnostics

	parseDiagnostics = []never{}

	pos := 0
	start := findNextStatementWithAwait(sourceFile.statements, 0)
	for start != -1 {
		// append all statements between pos and start
		prevStatement := sourceFile.statements[pos]
		nextStatement := sourceFile.statements[start]
		addRange(statements, sourceFile.statements, pos, start)
		pos = findNextStatementWithoutAwait(sourceFile.statements, start)

		// append all diagnostics associated with the copied range
		diagnosticStart := findIndex(savedParseDiagnostics, func(diagnostic DiagnosticWithDetachedLocation) bool {
			return diagnostic.start >= prevStatement.pos
		})
		var diagnosticEnd number
		if diagnosticStart >= 0 {
			diagnosticEnd = findIndex(savedParseDiagnostics, func(diagnostic DiagnosticWithDetachedLocation) bool {
				return diagnostic.start >= nextStatement.pos
			}, diagnosticStart)
		} else {
			diagnosticEnd = -1
		}
		if diagnosticStart >= 0 {
			addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart, ifelse(diagnosticEnd >= 0, diagnosticEnd, nil))
		}

		// reparse all statements between start and pos. We skip existing diagnostics for the same range and allow the parser to generate new ones.
		speculationHelper(func() {
			savedContextFlags := contextFlags
			contextFlags |= NodeFlagsAwaitContext
			scanner.resetTokenState(nextStatement.pos)
			nextToken()

			for token() != SyntaxKindEndOfFileToken {
				startPos := scanner.getTokenFullStart()
				statement := parseListElement(ParsingContextSourceElements, parseStatement)
				statements.push(statement)
				if startPos == scanner.getTokenFullStart() {
					nextToken()
				}

				if pos >= 0 {
					nonAwaitStatement := sourceFile.statements[pos]
					if statement.end == nonAwaitStatement.pos {
						// done reparsing this section
						break
					}
					if statement.end > nonAwaitStatement.pos {
						// we ate into the next statement, so we must reparse it.
						pos = findNextStatementWithoutAwait(sourceFile.statements, pos+1)
					}
				}
			}

			contextFlags = savedContextFlags
		}, SpeculationKindReparse)

		// find the next statement containing an `await`
		if pos >= 0 {
			start = findNextStatementWithAwait(sourceFile.statements, pos)
		} else {
			start = -1
		}
	}

	// append all statements between pos and the end of the list
	if pos >= 0 {
		prevStatement := sourceFile.statements[pos]
		addRange(statements, sourceFile.statements, pos)

		// append all diagnostics associated with the copied range
		diagnosticStart := findIndex(savedParseDiagnostics, func(diagnostic DiagnosticWithDetachedLocation) bool {
			return diagnostic.start >= prevStatement.pos
		})
		if diagnosticStart >= 0 {
			addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart)
		}
	}

	syntaxCursor = savedSyntaxCursor
	return factory.updateSourceFile(sourceFile, setTextRange(factoryCreateNodeArray(statements), sourceFile.statements))

	containsPossibleTopLevelAwait := func(node Node) bool {
		return !(node.flags & NodeFlagsAwaitContext) && !!(node.transformFlags & TransformFlagsContainsPossibleTopLevelAwait)
	}

	findNextStatementWithAwait := func(statements NodeArray[Statement], start number) number {
		for i := start; i < statements.length; i++ {
			if containsPossibleTopLevelAwait(statements[i]) {
				return i
			}
		}
		return -1
	}

	findNextStatementWithoutAwait := func(statements NodeArray[Statement], start number) number {
		for i := start; i < statements.length; i++ {
			if !containsPossibleTopLevelAwait(statements[i]) {
				return i
			}
		}
		return -1
	}

	currentNode := func(position number) Node {
		node := baseSyntaxCursor.currentNode(position)
		if topLevel && node && containsPossibleTopLevelAwait(node) {
			markAsIntersectingIncrementalChange(node)
		}
		return node
	}

}

func fixupParentReferences(rootNode Node) {
	// normally parent references are set during binding. However, for clients that only need
	// a syntax tree, and no semantic features, then the binding process is an unnecessary
	// overhead.  This functions allows us to set all the parents, without all the expense of
	// binding.
	setParentRecursive(rootNode /*incremental*/, true)
}

func createSourceFile(fileName string, languageVersion ScriptTarget, scriptKind ScriptKind, isDeclarationFile bool, statements []Statement, endOfFileToken EndOfFileToken, flags NodeFlags, setExternalModuleIndicator func(sourceFile SourceFile)) SourceFile {
	// code from createNode is inlined here so createNode won't have to deal with special case of creating source files
	// this is quite rare comparing to other nodes and createNode should be as fast as possible
	sourceFile := factory.createSourceFile(statements, endOfFileToken, flags)
	setTextRangePosWidth(sourceFile, 0, sourceText.length)
	setFields(sourceFile)

	// If we parsed this as an external module, it may contain top-level await
	if !isDeclarationFile && isExternalModule(sourceFile) && sourceFile.transformFlags&TransformFlagsContainsPossibleTopLevelAwait {
		oldSourceFile := sourceFile
		sourceFile = reparseTopLevelAwait(sourceFile)
		if oldSourceFile != sourceFile {
			setFields(sourceFile)
		}
	}

	return sourceFile

	setFields := func(sourceFile SourceFile) {
		sourceFile.text = sourceText
		sourceFile.bindDiagnostics = []never{}
		sourceFile.bindSuggestionDiagnostics = nil
		sourceFile.languageVersion = languageVersion
		sourceFile.fileName = fileName
		sourceFile.languageVariant = getLanguageVariant(scriptKind)
		sourceFile.isDeclarationFile = isDeclarationFile
		sourceFile.scriptKind = scriptKind

		setExternalModuleIndicator(sourceFile)
		sourceFile.setExternalModuleIndicator = setExternalModuleIndicator
	}

}

func setContextFlag(val bool, flag NodeFlags) {
	if val {
		contextFlags |= flag
	} else {
		contextFlags &^= flag
	}
}

func setDisallowInContext(val bool) {
	setContextFlag(val, NodeFlagsDisallowInContext)
}

func setYieldContext(val bool) {
	setContextFlag(val, NodeFlagsYieldContext)
}

func setDecoratorContext(val bool) {
	setContextFlag(val, NodeFlagsDecoratorContext)
}

func setAwaitContext(val bool) {
	setContextFlag(val, NodeFlagsAwaitContext)
}

func doOutsideOfContext(context NodeFlags, func_ func() T) T {
	// contextFlagsToClear will contain only the context flags that are
	// currently set that we need to temporarily clear
	// We don't just blindly reset to the previous flags to ensure
	// that we do not mutate cached flags for the incremental
	// parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and
	// HasAggregatedChildData).
	contextFlagsToClear := context & contextFlags
	if contextFlagsToClear {
		// clear the requested context flags
		setContextFlag(false, contextFlagsToClear)
		result := func_()
		// restore the context flags we just cleared
		setContextFlag(true, contextFlagsToClear)
		return result
	}

	// no need to do anything special as we are not in any of the requested contexts
	return func_()
}

func doInsideOfContext(context NodeFlags, func_ func() T) T {
	// contextFlagsToSet will contain only the context flags that
	// are not currently set that we need to temporarily enable.
	// We don't just blindly reset to the previous flags to ensure
	// that we do not mutate cached flags for the incremental
	// parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and
	// HasAggregatedChildData).
	contextFlagsToSet := context & ^contextFlags
	if contextFlagsToSet {
		// set the requested context flags
		setContextFlag(true, contextFlagsToSet)
		result := func_()
		// reset the context flags we just set
		setContextFlag(false, contextFlagsToSet)
		return result
	}

	// no need to do anything special as we are already in all of the requested contexts
	return func_()
}

func allowInAnd(func_ func() T) T {
	return doOutsideOfContext(NodeFlagsDisallowInContext, func_)
}

func disallowInAnd(func_ func() T) T {
	return doInsideOfContext(NodeFlagsDisallowInContext, func_)
}

func allowConditionalTypesAnd(func_ func() T) T {
	return doOutsideOfContext(NodeFlagsDisallowConditionalTypesContext, func_)
}

func disallowConditionalTypesAnd(func_ func() T) T {
	return doInsideOfContext(NodeFlagsDisallowConditionalTypesContext, func_)
}

func doInYieldContext(func_ func() T) T {
	return doInsideOfContext(NodeFlagsYieldContext, func_)
}

func doInDecoratorContext(func_ func() T) T {
	return doInsideOfContext(NodeFlagsDecoratorContext, func_)
}

func doInAwaitContext(func_ func() T) T {
	return doInsideOfContext(NodeFlagsAwaitContext, func_)
}

func doOutsideOfAwaitContext(func_ func() T) T {
	return doOutsideOfContext(NodeFlagsAwaitContext, func_)
}

func doInYieldAndAwaitContext(func_ func() T) T {
	return doInsideOfContext(NodeFlagsYieldContext|NodeFlagsAwaitContext, func_)
}

func doOutsideOfYieldAndAwaitContext(func_ func() T) T {
	return doOutsideOfContext(NodeFlagsYieldContext|NodeFlagsAwaitContext, func_)
}

func inContext(flags NodeFlags) bool {
	return (contextFlags & flags) != 0
}

func inYieldContext() bool {
	return inContext(NodeFlagsYieldContext)
}

func inDisallowInContext() bool {
	return inContext(NodeFlagsDisallowInContext)
}

func inDisallowConditionalTypesContext() bool {
	return inContext(NodeFlagsDisallowConditionalTypesContext)
}

func inDecoratorContext() bool {
	return inContext(NodeFlagsDecoratorContext)
}

func inAwaitContext() bool {
	return inContext(NodeFlagsAwaitContext)
}

func parseErrorAtCurrentToken(message DiagnosticMessage, args DiagnosticArguments) *DiagnosticWithDetachedLocation {
	return parseErrorAt(scanner.getTokenStart(), scanner.getTokenEnd(), message, args...)
}

func parseErrorAtPosition(start number, length number, message DiagnosticMessage, args DiagnosticArguments) *DiagnosticWithDetachedLocation {
	// Don't report another error if it would just be at the same position as the last error.
	lastError := lastOrUndefined(parseDiagnostics)
	var result *DiagnosticWithDetachedLocation
	if !lastError || start != lastError.start {
		result = createDetachedDiagnostic(fileName, sourceText, start, length, message, args...)
		parseDiagnostics.push(result)
	}

	// Mark that we've encountered an error.  We'll set an appropriate bit on the next
	// node we finish so that it can't be reused incrementally.
	parseErrorBeforeNextFinishedNode = true
	return result
}

func parseErrorAt(start number, end number, message DiagnosticMessage, args DiagnosticArguments) *DiagnosticWithDetachedLocation {
	return parseErrorAtPosition(start, end-start, message, args...)
}

func parseErrorAtRange(range_ TextRange, message DiagnosticMessage, args DiagnosticArguments) {
	parseErrorAt(range_.pos, range_.end, message, args...)
}

func scanError(message DiagnosticMessage, length number, arg0 any) {
	parseErrorAtPosition(scanner.getTokenEnd(), length, message, arg0)
}

func getNodePos() number {
	return scanner.getTokenFullStart()
}

func hasPrecedingJSDocComment() bool {
	return scanner.hasPrecedingJSDocComment()
}

// Use this function to access the current token instead of reading the currentToken
// variable. Since function results aren't narrowed in control flow analysis, this ensures
// that the type checker doesn't make wrong assumptions about the type of the current
// token (e.g. a call to nextToken() changes the current token but the checker doesn't
// reason about this side effect).  Mainstream VMs inline simple functions like this, so
// there is no performance penalty.
func token() SyntaxKind {
	return currentToken
}

func nextTokenWithoutCheck() SyntaxKind {
	currentToken = scanner.scan()
	return currentToken
}

func nextTokenAnd(func_ func() T) T {
	nextToken()
	return func_()
}

func nextToken() SyntaxKind {
	// if the keyword had an escape
	if isKeyword(currentToken) && (scanner.hasUnicodeEscape() || scanner.hasExtendedUnicodeEscape()) {
		// issue a parse error for the escape
		parseErrorAt(scanner.getTokenStart(), scanner.getTokenEnd(), Diagnostics.Keywords_cannot_contain_escape_characters)
	}
	return nextTokenWithoutCheck()
}

func nextTokenJSDoc() JSDocSyntaxKind {
	currentToken = scanner.scanJsDocToken()
	return currentToken
}

func nextJSDocCommentTextToken(inBackticks bool) /* TODO(TS-TO-GO) TypeNode UnionType: JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken */ any {
	currentToken = scanner.scanJSDocCommentTextToken(inBackticks)
	return currentToken
}

func reScanGreaterToken() SyntaxKind {
	currentToken = scanner.reScanGreaterToken()
	return currentToken
}

func reScanSlashToken() SyntaxKind {
	currentToken = scanner.reScanSlashToken()
	return currentToken
}

func reScanTemplateToken(isTaggedTemplate bool) SyntaxKind {
	currentToken = scanner.reScanTemplateToken(isTaggedTemplate)
	return currentToken
}

func reScanLessThanToken() SyntaxKind {
	currentToken = scanner.reScanLessThanToken()
	return currentToken
}

func reScanHashToken() SyntaxKind {
	currentToken = scanner.reScanHashToken()
	return currentToken
}

func scanJsxIdentifier() SyntaxKind {
	currentToken = scanner.scanJsxIdentifier()
	return currentToken
}

func scanJsxText() SyntaxKind {
	currentToken = scanner.scanJsxToken()
	return currentToken
}

func scanJsxAttributeValue() SyntaxKind {
	currentToken = scanner.scanJsxAttributeValue()
	return currentToken
}

func speculationHelper(callback func() T, speculationKind SpeculationKind) T {
	// Keep track of the state we'll need to rollback to if lookahead fails (or if the
	// caller asked us to always reset our state).
	saveToken := currentToken
	saveParseDiagnosticsLength := parseDiagnostics.length
	saveParseErrorBeforeNextFinishedNode := parseErrorBeforeNextFinishedNode

	// Note: it is not actually necessary to save/restore the context flags here.  That's
	// because the saving/restoring of these flags happens naturally through the recursive
	// descent nature of our parser.  However, we still store this here just so we can
	// assert that invariant holds.
	saveContextFlags := contextFlags

	// If we're only looking ahead, then tell the scanner to only lookahead as well.
	// Otherwise, if we're actually speculatively parsing, then tell the scanner to do the
	// same.
	var result T
	if speculationKind != SpeculationKindTryParse {
		result = scanner.lookAhead(callback)
	} else {
		result = scanner.tryScan(callback)
	}

	Debug.assert(saveContextFlags == contextFlags)

	// If our callback returned something 'falsy' or we're just looking ahead,
	// then unconditionally restore us to where we were.
	if !result || speculationKind != SpeculationKindTryParse {
		currentToken = saveToken
		if speculationKind != SpeculationKindReparse {
			parseDiagnostics.length = saveParseDiagnosticsLength
		}
		parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode
	}

	return result
}

/** Invokes the provided callback then unconditionally restores the parser to the state it
 * was in immediately prior to invoking the callback.  The result of invoking the callback
 * is returned from this function.
 */

func lookAhead(callback func() T) T {
	return speculationHelper(callback, SpeculationKindLookahead)
}

/** Invokes the provided callback.  If the callback returns something falsy, then it restores
 * the parser to the state it was in immediately prior to invoking the callback.  If the
 * callback returns something truthy, then the parser state is not rolled back.  The result
 * of invoking the callback is returned from this function.
 */

func tryParse(callback func() T) T {
	return speculationHelper(callback, SpeculationKindTryParse)
}

func isBindingIdentifier() bool {
	if token() == SyntaxKindIdentifier {
		return true
	}

	// `let await`/`let yield` in [Yield] or [Await] are allowed here and disallowed in the binder.
	return token() > SyntaxKindLastReservedWord
}

// Ignore strict mode flag because we will report an error in type checker instead.
func isIdentifier() bool {
	if token() == SyntaxKindIdentifier {
		return true
	}

	// If we have a 'yield' keyword, and we're in the [yield] context, then 'yield' is
	// considered a keyword and is not an identifier.
	if token() == SyntaxKindYieldKeyword && inYieldContext() {
		return false
	}

	// If we have a 'await' keyword, and we're in the [Await] context, then 'await' is
	// considered a keyword and is not an identifier.
	if token() == SyntaxKindAwaitKeyword && inAwaitContext() {
		return false
	}

	return token() > SyntaxKindLastReservedWord
}

func parseExpected(kind PunctuationOrKeywordSyntaxKind, diagnosticMessage DiagnosticMessage, shouldAdvance bool /*  = true */) bool {
	if token() == kind {
		if shouldAdvance {
			nextToken()
		}
		return true
	}

	// Report specific message if provided with one.  Otherwise, report generic fallback message.
	if diagnosticMessage {
		parseErrorAtCurrentToken(diagnosticMessage)
	} else {
		parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(kind))
	}
	return false
}

var viableKeywordSuggestions = Object.keys(textToKeywordObj).filter(func(keyword string) bool {
	return keyword.length > 2
})

/**
 * Provides a better error message than the generic "';' expected" if possible for
 * known common variants of a missing semicolon, such as from a mispelled names.
 *
 * @param node Node preceding the expected semicolon location.
 */

func parseErrorForMissingSemicolonAfter(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | PropertyName */ any) {
	// Tagged template literals are sometimes used in places where only simple strings are allowed, i.e.:
	//   module `M1` {
	//   ^^^^^^^^^^^ This block is parsed as a template literal like module`M1`.
	if isTaggedTemplateExpression(node) {
		parseErrorAt(skipTrivia(sourceText, node.template.pos), node.template.end, Diagnostics.Module_declaration_names_may_only_use_or_quoted_strings)
		return
	}

	// Otherwise, if this isn't a well-known keyword-like identifier, give the generic fallback message.
	var expressionText *string
	if isIdentifierNode(node) {
		expressionText = idText(node)
	} else {
		expressionText = nil
	}
	if !expressionText || !isIdentifierText(expressionText, languageVersion) {
		parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKindSemicolonToken))
		return
	}

	pos := skipTrivia(sourceText, node.pos)

	// Some known keywords are likely signs of syntax being used improperly.
	switch expressionText {
	case "const",
		"let",
		"var":
		parseErrorAt(pos, node.end, Diagnostics.Variable_declaration_not_allowed_at_this_location)
		return
	case "declare":
		// If a declared node failed to parse, it would have emitted a diagnostic already.
		return
	case "interface":
		parseErrorForInvalidName(Diagnostics.Interface_name_cannot_be_0, Diagnostics.Interface_must_be_given_a_name, SyntaxKindOpenBraceToken)
		return
	case "is":
		parseErrorAt(pos, scanner.getTokenStart(), Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods)
		return
	case "module",
		"namespace":
		parseErrorForInvalidName(Diagnostics.Namespace_name_cannot_be_0, Diagnostics.Namespace_must_be_given_a_name, SyntaxKindOpenBraceToken)
		return
	case "type":
		parseErrorForInvalidName(Diagnostics.Type_alias_name_cannot_be_0, Diagnostics.Type_alias_must_be_given_a_name, SyntaxKindEqualsToken)
		return
	}

	// The user alternatively might have misspelled or forgotten to add a space after a common keyword.
	suggestion := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getSpellingSuggestion(expressionText, viableKeywordSuggestions, identity) ?? getSpaceSuggestion(expressionText) */ TODO
	if suggestion {
		parseErrorAt(pos, node.end, Diagnostics.Unknown_keyword_or_identifier_Did_you_mean_0, suggestion)
		return
	}

	// Unknown tokens are handled with their own errors in the scanner
	if token() == SyntaxKindUnknown {
		return
	}

	// Otherwise, we know this some kind of unknown word, not just a missing expected semicolon.
	parseErrorAt(pos, node.end, Diagnostics.Unexpected_keyword_or_identifier)
}

/**
 * Reports a diagnostic error for the current token being an invalid name.
 *
 * @param blankDiagnostic Diagnostic to report for the case of the name being blank (matched tokenIfBlankName).
 * @param nameDiagnostic Diagnostic to report for all other cases.
 * @param tokenIfBlankName Current token if the name was invalid for being blank (not provided / skipped).
 */

func parseErrorForInvalidName(nameDiagnostic DiagnosticMessage, blankDiagnostic DiagnosticMessage, tokenIfBlankName SyntaxKind) {
	if token() == tokenIfBlankName {
		parseErrorAtCurrentToken(blankDiagnostic)
	} else {
		parseErrorAtCurrentToken(nameDiagnostic, scanner.getTokenValue())
	}
}

func getSpaceSuggestion(expressionText string) *string {
	for _, keyword := range viableKeywordSuggestions {
		if expressionText.length > keyword.length+2 && startsWith(expressionText, keyword) {
			return __TEMPLATE__(keyword, " ", expressionText.slice(keyword.length))
		}
	}

	return nil
}

func parseSemicolonAfterPropertyName(name PropertyName, type_ *TypeNode, initializer Expression) {
	if token() == SyntaxKindAtToken && !scanner.hasPrecedingLineBreak() {
		parseErrorAtCurrentToken(Diagnostics.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations)
		return
	}

	if token() == SyntaxKindOpenParenToken {
		parseErrorAtCurrentToken(Diagnostics.Cannot_start_a_function_call_in_a_type_annotation)
		nextToken()
		return
	}

	if type_ && !canParseSemicolon() {
		if initializer {
			parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKindSemicolonToken))
		} else {
			parseErrorAtCurrentToken(Diagnostics.Expected_for_property_initializer)
		}
		return
	}

	if tryParseSemicolon() {
		return
	}

	if initializer {
		parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKindSemicolonToken))
		return
	}

	parseErrorForMissingSemicolonAfter(name)
}

func parseExpectedJSDoc(kind JSDocSyntaxKind) bool {
	if token() == kind {
		nextTokenJSDoc()
		return true
	}
	Debug.assert(isKeywordOrPunctuation(kind))
	parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(kind))
	return false
}

func parseExpectedMatchingBrackets(openKind PunctuationSyntaxKind, closeKind PunctuationSyntaxKind, openParsed bool, openPosition number) {
	if token() == closeKind {
		nextToken()
		return
	}
	lastError := parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(closeKind))
	if !openParsed {
		return
	}
	if lastError {
		addRelatedInfo(lastError, createDetachedDiagnostic(fileName, sourceText, openPosition, 1, Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, tokenToString(openKind), tokenToString(closeKind)))
	}
}

func parseOptional(t SyntaxKind) bool {
	if token() == t {
		nextToken()
		return true
	}
	return false
}

/* OVERLOAD: function parseOptionalToken<TKind extends SyntaxKind>(t: TKind): Token<TKind>; */
func parseOptionalToken(t SyntaxKind) Node {
	if token() == t {
		return parseTokenNode()
	}
	return nil
}

/* OVERLOAD: function parseOptionalTokenJSDoc<TKind extends JSDocSyntaxKind>(t: TKind): Token<TKind>; */
func parseOptionalTokenJSDoc(t JSDocSyntaxKind) Node {
	if token() == t {
		return parseTokenNodeJSDoc()
	}
	return nil
}

/* OVERLOAD: function parseExpectedToken<TKind extends SyntaxKind>(t: TKind, diagnosticMessage?: DiagnosticMessage, arg0?: string): Token<TKind>; */
func parseExpectedToken(t SyntaxKind, diagnosticMessage DiagnosticMessage, arg0 string) Node {
	return parseOptionalToken(t) || createMissingNode(t /*reportAtCurrentPosition*/, false, diagnosticMessage || Diagnostics._0_expected, arg0 || tokenToString(t))
}

/* OVERLOAD: function parseExpectedTokenJSDoc<TKind extends JSDocSyntaxKind>(t: TKind): Token<TKind>; */
func parseExpectedTokenJSDoc(t JSDocSyntaxKind) Node {
	optional := parseOptionalTokenJSDoc(t)
	if optional {
		return optional
	}
	Debug.assert(isKeywordOrPunctuation(t))
	return createMissingNode(t /*reportAtCurrentPosition*/, false, Diagnostics._0_expected, tokenToString(t))
}

func parseTokenNode() T {
	pos := getNodePos()
	kind := token()
	nextToken()
	return finishNode(factoryCreateToken(kind), pos).(T)
}

func parseTokenNodeJSDoc() T {
	pos := getNodePos()
	kind := token()
	nextTokenJSDoc()
	return finishNode(factoryCreateToken(kind), pos).(T)
}

func canParseSemicolon() bool {
	// If there's a real semicolon, then we can always parse it out.
	if token() == SyntaxKindSemicolonToken {
		return true
	}

	// We can parse out an optional semicolon in ASI cases in the following cases.
	return token() == SyntaxKindCloseBraceToken || token() == SyntaxKindEndOfFileToken || scanner.hasPrecedingLineBreak()
}

func tryParseSemicolon() bool {
	if !canParseSemicolon() {
		return false
	}

	if token() == SyntaxKindSemicolonToken {
		// consume the semicolon if it was explicitly provided.
		nextToken()
	}

	return true
}

func parseSemicolon() bool {
	return tryParseSemicolon() || parseExpected(SyntaxKindSemicolonToken)
}

func createNodeArray(elements []T, pos number, end number, hasTrailingComma bool) NodeArray[T] {
	array := factoryCreateNodeArray(elements, hasTrailingComma)
	setTextRangePosEnd(array, pos /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: end ?? scanner.getTokenFullStart() */, TODO)
	return array
}

func finishNode(node T, pos number, end number) T {
	setTextRangePosEnd(node, pos /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: end ?? scanner.getTokenFullStart() */, TODO)
	if contextFlags {
		(node.(Mutable[T])).flags |= contextFlags
	}

	// Keep track on the node if we encountered an error while parsing it.  If we did, then
	// we cannot reuse the node incrementally.  Once we've marked this node, clear out the
	// flag so that we don't mark any subsequent nodes.
	if parseErrorBeforeNextFinishedNode {
		parseErrorBeforeNextFinishedNode = false
		(node.(Mutable[T])).flags |= NodeFlagsThisNodeHasError
	}

	return node
}

/* OVERLOAD: function createMissingNode<T extends Node>(kind: T["kind"], reportAtCurrentPosition: false, diagnosticMessage?: DiagnosticMessage, ...args: DiagnosticArguments): T; */
/* OVERLOAD: function createMissingNode<T extends Node>(kind: T["kind"], reportAtCurrentPosition: boolean, diagnosticMessage: DiagnosticMessage, ...args: DiagnosticArguments): T; */
func createMissingNode(kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: T["kind"] */ any, reportAtCurrentPosition bool, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) T {
	if reportAtCurrentPosition {
		parseErrorAtPosition(scanner.getTokenFullStart(), 0, diagnosticMessage, args...)
	} else if diagnosticMessage {
		parseErrorAtCurrentToken(diagnosticMessage, args...)
	}

	pos := getNodePos()
	var result /* TODO(TS-TO-GO) inferred type StringLiteral | Identifier | TemplateLiteralLikeNode | NumericLiteral | MissingDeclaration | Token<T["kind"]> */ any
	switch {
	case kind == SyntaxKindIdentifier:
		result = factoryCreateIdentifier("" /*originalKeywordKind*/, nil)
	case isTemplateLiteralKind(kind):
		result = factory.createTemplateLiteralLikeNode(kind, "", "" /*templateFlags*/, nil)
	case kind == SyntaxKindNumericLiteral:
		result = factoryCreateNumericLiteral("" /*numericLiteralFlags*/, nil)
	case kind == SyntaxKindStringLiteral:
		result = factoryCreateStringLiteral("" /*isSingleQuote*/, nil)
	case kind == SyntaxKindMissingDeclaration:
		result = factory.createMissingDeclaration()
	default:
		result = factoryCreateToken(kind)
	}
	return finishNode(result, pos).(T)
}

func internIdentifier(text string) string {
	identifier := identifiers.get(text)
	if identifier == nil {
		identifiers.set(text /* TODO(TS-TO-GO) EqualsToken BinaryExpression: identifier = text */, TODO)
	}
	return identifier
}

// An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues
// with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for
// each identifier in order to reduce memory consumption.
func createIdentifier(isIdentifier bool, diagnosticMessage DiagnosticMessage, privateIdentifierDiagnosticMessage DiagnosticMessage) Identifier {
	if isIdentifier {
		identifierCount++
		var pos number
		if scanner.hasPrecedingJSDocLeadingAsterisks() {
			pos = scanner.getTokenStart()
		} else {
			pos = getNodePos()
		}
		// Store original token kind if it is not just an Identifier so we can report appropriate error later in type checker
		originalKeywordKind := token()
		text := internIdentifier(scanner.getTokenValue())
		hasExtendedUnicodeEscape := scanner.hasExtendedUnicodeEscape()
		nextTokenWithoutCheck()
		return finishNode(factoryCreateIdentifier(text, originalKeywordKind, hasExtendedUnicodeEscape), pos)
	}

	if token() == SyntaxKindPrivateIdentifier {
		parseErrorAtCurrentToken(privateIdentifierDiagnosticMessage || Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		return createIdentifier(true)
	}

	if token() == SyntaxKindUnknown && scanner.tryScan(func() bool {
		return scanner.reScanInvalidIdentifier() == SyntaxKindIdentifier
	}) {
		// Scanner has already recorded an 'Invalid character' error, so no need to add another from the parser.
		return createIdentifier(true)
	}

	identifierCount++
	// Only for end of file because the error gets reported incorrectly on embedded script tags.
	reportAtCurrentPosition := token() == SyntaxKindEndOfFileToken

	isReservedWord := scanner.isReservedWord()
	msgArg := scanner.getTokenText()

	var defaultMessage any
	if isReservedWord {
		defaultMessage = Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here
	} else {
		defaultMessage = Diagnostics.Identifier_expected
	}

	return createMissingNode(SyntaxKindIdentifier, reportAtCurrentPosition, diagnosticMessage || defaultMessage, msgArg)
}

func parseBindingIdentifier(privateIdentifierDiagnosticMessage DiagnosticMessage) Identifier {
	return createIdentifier(isBindingIdentifier() /*diagnosticMessage*/, nil, privateIdentifierDiagnosticMessage)
}

func parseIdentifier(diagnosticMessage DiagnosticMessage, privateIdentifierDiagnosticMessage DiagnosticMessage) Identifier {
	return createIdentifier(isIdentifier(), diagnosticMessage, privateIdentifierDiagnosticMessage)
}

func parseIdentifierName(diagnosticMessage DiagnosticMessage) Identifier {
	return createIdentifier(tokenIsIdentifierOrKeyword(token()), diagnosticMessage)
}

func parseIdentifierNameErrorOnUnicodeEscapeSequence() Identifier {
	if scanner.hasUnicodeEscape() || scanner.hasExtendedUnicodeEscape() {
		parseErrorAtCurrentToken(Diagnostics.Unicode_escape_sequence_cannot_appear_here)
	}
	return createIdentifier(tokenIsIdentifierOrKeyword(token()))
}

func isLiteralPropertyName() bool {
	return tokenIsIdentifierOrKeyword(token()) || token() == SyntaxKindStringLiteral || token() == SyntaxKindNumericLiteral || token() == SyntaxKindBigIntLiteral
}

func isImportAttributeName() bool {
	return tokenIsIdentifierOrKeyword(token()) || token() == SyntaxKindStringLiteral
}

func parsePropertyNameWorker(allowComputedPropertyNames bool) PropertyName {
	if token() == SyntaxKindStringLiteral || token() == SyntaxKindNumericLiteral || token() == SyntaxKindBigIntLiteral {
		node := parseLiteralNode() /* as StringLiteral | NumericLiteral | BigIntLiteral */
		node.text = internIdentifier(node.text)
		return node
	}
	if allowComputedPropertyNames && token() == SyntaxKindOpenBracketToken {
		return parseComputedPropertyName()
	}
	if token() == SyntaxKindPrivateIdentifier {
		return parsePrivateIdentifier()
	}
	return parseIdentifierName()
}

func parsePropertyName() PropertyName {
	return parsePropertyNameWorker(true)
}

func parseComputedPropertyName() ComputedPropertyName {
	// PropertyName [Yield]:
	//      LiteralPropertyName
	//      ComputedPropertyName[?Yield]
	pos := getNodePos()
	parseExpected(SyntaxKindOpenBracketToken)
	// We parse any expression (including a comma expression). But the grammar
	// says that only an assignment expression is allowed, so the grammar checker
	// will error if it sees a comma expression.
	expression := allowInAnd(parseExpression)
	parseExpected(SyntaxKindCloseBracketToken)
	return finishNode(factory.createComputedPropertyName(expression), pos)
}

func parsePrivateIdentifier() PrivateIdentifier {
	pos := getNodePos()
	node := factoryCreatePrivateIdentifier(internIdentifier(scanner.getTokenValue()))
	nextToken()
	return finishNode(node, pos)
}

func parseContextualModifier(t SyntaxKind) bool {
	return token() == t && tryParse(nextTokenCanFollowModifier)
}

func nextTokenIsOnSameLineAndCanFollowModifier() bool {
	nextToken()
	if scanner.hasPrecedingLineBreak() {
		return false
	}
	return canFollowModifier()
}

func nextTokenCanFollowModifier() bool {
	switch token() {
	case SyntaxKindConstKeyword:
		// 'const' is only a modifier if followed by 'enum'.
		return nextToken() == SyntaxKindEnumKeyword
	case SyntaxKindExportKeyword:
		nextToken()
		if token() == SyntaxKindDefaultKeyword {
			return lookAhead(nextTokenCanFollowDefaultKeyword)
		}
		if token() == SyntaxKindTypeKeyword {
			return lookAhead(nextTokenCanFollowExportModifier)
		}
		return canFollowExportModifier()
	case SyntaxKindDefaultKeyword:
		return nextTokenCanFollowDefaultKeyword()
	case SyntaxKindStaticKeyword,
		SyntaxKindGetKeyword,
		SyntaxKindSetKeyword:
		nextToken()
		return canFollowModifier()
	default:
		return nextTokenIsOnSameLineAndCanFollowModifier()
	}
}

func canFollowExportModifier() bool {
	return token() == SyntaxKindAtToken || token() != SyntaxKindAsteriskToken && token() != SyntaxKindAsKeyword && token() != SyntaxKindOpenBraceToken && canFollowModifier()
}

func nextTokenCanFollowExportModifier() bool {
	nextToken()
	return canFollowExportModifier()
}

func parseAnyContextualModifier() bool {
	return isModifierKind(token()) && tryParse(nextTokenCanFollowModifier)
}

func canFollowModifier() bool {
	return token() == SyntaxKindOpenBracketToken || token() == SyntaxKindOpenBraceToken || token() == SyntaxKindAsteriskToken || token() == SyntaxKindDotDotDotToken || isLiteralPropertyName()
}

func nextTokenCanFollowDefaultKeyword() bool {
	nextToken()
	return token() == SyntaxKindClassKeyword || token() == SyntaxKindFunctionKeyword || token() == SyntaxKindInterfaceKeyword || token() == SyntaxKindAtToken || (token() == SyntaxKindAbstractKeyword && lookAhead(nextTokenIsClassKeywordOnSameLine)) || (token() == SyntaxKindAsyncKeyword && lookAhead(nextTokenIsFunctionKeywordOnSameLine))
}

// True if positioned at the start of a list element
func isListElement(parsingContext ParsingContext, inErrorRecovery bool) bool {
	node := currentNode(parsingContext)
	if node {
		return true
	}

	switch parsingContext {
	case ParsingContextSourceElements,
		ParsingContextBlockStatements,
		ParsingContextSwitchClauseStatements:
		// If we're in error recovery, then we don't want to treat ';' as an empty statement.
		// The problem is that ';' can show up in far too many contexts, and if we see one
		// and assume it's a statement, then we may bail out inappropriately from whatever
		// we're parsing.  For example, if we have a semicolon in the middle of a class, then
		// we really don't want to assume the class is over and we're on a statement in the
		// outer module.  We just want to consume and move on.
		return !(token() == SyntaxKindSemicolonToken && inErrorRecovery) && isStartOfStatement()
	case ParsingContextSwitchClauses:
		return token() == SyntaxKindCaseKeyword || token() == SyntaxKindDefaultKeyword
	case ParsingContextTypeMembers:
		return lookAhead(isTypeMemberStart)
	case ParsingContextClassMembers:
		// We allow semicolons as class elements (as specified by ES6) as long as we're
		// not in error recovery.  If we're in error recovery, we don't want an errant
		// semicolon to be treated as a class member (since they're almost always used
		// for statements.
		return lookAhead(isClassMemberStart) || (token() == SyntaxKindSemicolonToken && !inErrorRecovery)
	case ParsingContextEnumMembers:
		// Include open bracket computed properties. This technically also lets in indexers,
		// which would be a candidate for improved error reporting.
		return token() == SyntaxKindOpenBracketToken || isLiteralPropertyName()
	case ParsingContextObjectLiteralMembers:
		switch token() {
		case SyntaxKindOpenBracketToken,
			SyntaxKindAsteriskToken,
			SyntaxKindDotDotDotToken,
			SyntaxKindDotToken:
			return true
		default:
			return isLiteralPropertyName()
		}
		fallthrough
	case ParsingContextRestProperties:
		return isLiteralPropertyName()
	case ParsingContextObjectBindingElements:
		return token() == SyntaxKindOpenBracketToken || token() == SyntaxKindDotDotDotToken || isLiteralPropertyName()
	case ParsingContextImportAttributes:
		return isImportAttributeName()
	case ParsingContextHeritageClauseElement:
		// If we see `{ ... }` then only consume it as an expression if it is followed by `,` or `{`
		// That way we won't consume the body of a class in its heritage clause.
		if token() == SyntaxKindOpenBraceToken {
			return lookAhead(isValidHeritageClauseObjectLiteral)
		}

		if !inErrorRecovery {
			return isStartOfLeftHandSideExpression() && !isHeritageClauseExtendsOrImplementsKeyword()
		} else {
			// If we're in error recovery we tighten up what we're willing to match.
			// That way we don't treat something like "this" as a valid heritage clause
			// element during recovery.
			return isIdentifier() && !isHeritageClauseExtendsOrImplementsKeyword()
		}
		fallthrough
	case ParsingContextVariableDeclarations:
		return isBindingIdentifierOrPrivateIdentifierOrPattern()
	case ParsingContextArrayBindingElements:
		return token() == SyntaxKindCommaToken || token() == SyntaxKindDotDotDotToken || isBindingIdentifierOrPrivateIdentifierOrPattern()
	case ParsingContextTypeParameters:
		return token() == SyntaxKindInKeyword || token() == SyntaxKindConstKeyword || isIdentifier()
	case ParsingContextArrayLiteralMembers:
		switch token() {
		case SyntaxKindCommaToken,
			SyntaxKindDotToken:
			return true
		}
		fallthrough
	case ParsingContextArgumentExpressions:
		return token() == SyntaxKindDotDotDotToken || isStartOfExpression()
	case ParsingContextParameters:
		return isStartOfParameter(false)
	case ParsingContextJSDocParameters:
		return isStartOfParameter(true)
	case ParsingContextTypeArguments,
		ParsingContextTupleElementTypes:
		return token() == SyntaxKindCommaToken || isStartOfType()
	case ParsingContextHeritageClauses:
		return isHeritageClause()
	case ParsingContextImportOrExportSpecifiers:
		// bail out if the next token is [FromKeyword StringLiteral].
		// That means we're in something like `import { from "mod"`. Stop here can give better error message.
		if token() == SyntaxKindFromKeyword && lookAhead(nextTokenIsStringLiteral) {
			return false
		}
		if token() == SyntaxKindStringLiteral {
			return true
			// For "arbitrary module namespace identifiers"
		}
		return tokenIsIdentifierOrKeyword(token())
	case ParsingContextJsxAttributes:
		return tokenIsIdentifierOrKeyword(token()) || token() == SyntaxKindOpenBraceToken
	case ParsingContextJsxChildren:
		return true
	case ParsingContextJSDocComment:
		return true
	case ParsingContextCount:
		return Debug.fail("ParsingContext.Count used as a context")
		// Not a real context, only a marker.
	default:
		Debug.assertNever(parsingContext, "Non-exhaustive case in 'isListElement'.")
	}
}

func isValidHeritageClauseObjectLiteral() bool {
	Debug.assert(token() == SyntaxKindOpenBraceToken)
	if nextToken() == SyntaxKindCloseBraceToken {
		// if we see "extends {}" then only treat the {} as what we're extending (and not
		// the class body) if we have:
		//
		//      extends {} {
		//      extends {},
		//      extends {} extends
		//      extends {} implements

		next := nextToken()
		return next == SyntaxKindCommaToken || next == SyntaxKindOpenBraceToken || next == SyntaxKindExtendsKeyword || next == SyntaxKindImplementsKeyword
	}

	return true
}

func nextTokenIsIdentifier() bool {
	nextToken()
	return isIdentifier()
}

func nextTokenIsIdentifierOrKeyword() bool {
	nextToken()
	return tokenIsIdentifierOrKeyword(token())
}

func nextTokenIsIdentifierOrKeywordOrGreaterThan() bool {
	nextToken()
	return tokenIsIdentifierOrKeywordOrGreaterThan(token())
}

func isHeritageClauseExtendsOrImplementsKeyword() bool {
	if token() == SyntaxKindImplementsKeyword || token() == SyntaxKindExtendsKeyword {
		return lookAhead(nextTokenIsStartOfExpression)
	}

	return false
}

func nextTokenIsStartOfExpression() bool {
	nextToken()
	return isStartOfExpression()
}

func nextTokenIsStartOfType() bool {
	nextToken()
	return isStartOfType()
}

// True if positioned at a list terminator
func isListTerminator(kind ParsingContext) bool {
	if token() == SyntaxKindEndOfFileToken {
		// Being at the end of the file ends all lists.
		return true
	}

	switch kind {
	case ParsingContextBlockStatements,
		ParsingContextSwitchClauses,
		ParsingContextTypeMembers,
		ParsingContextClassMembers,
		ParsingContextEnumMembers,
		ParsingContextObjectLiteralMembers,
		ParsingContextObjectBindingElements,
		ParsingContextImportOrExportSpecifiers,
		ParsingContextImportAttributes:
		return token() == SyntaxKindCloseBraceToken
	case ParsingContextSwitchClauseStatements:
		return token() == SyntaxKindCloseBraceToken || token() == SyntaxKindCaseKeyword || token() == SyntaxKindDefaultKeyword
	case ParsingContextHeritageClauseElement:
		return token() == SyntaxKindOpenBraceToken || token() == SyntaxKindExtendsKeyword || token() == SyntaxKindImplementsKeyword
	case ParsingContextVariableDeclarations:
		return isVariableDeclaratorListTerminator()
	case ParsingContextTypeParameters:
		// Tokens other than '>' are here for better error recovery
		return token() == SyntaxKindGreaterThanToken || token() == SyntaxKindOpenParenToken || token() == SyntaxKindOpenBraceToken || token() == SyntaxKindExtendsKeyword || token() == SyntaxKindImplementsKeyword
	case ParsingContextArgumentExpressions:
		// Tokens other than ')' are here for better error recovery
		return token() == SyntaxKindCloseParenToken || token() == SyntaxKindSemicolonToken
	case ParsingContextArrayLiteralMembers,
		ParsingContextTupleElementTypes,
		ParsingContextArrayBindingElements:
		return token() == SyntaxKindCloseBracketToken
	case ParsingContextJSDocParameters,
		ParsingContextParameters,
		ParsingContextRestProperties:
		// Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery
		return token() == SyntaxKindCloseParenToken || token() == SyntaxKindCloseBracketToken
	case ParsingContextTypeArguments:
		// All other tokens should cause the type-argument to terminate except comma token
		return token() != SyntaxKindCommaToken
	case ParsingContextHeritageClauses:
		return token() == SyntaxKindOpenBraceToken || token() == SyntaxKindCloseBraceToken
	case ParsingContextJsxAttributes:
		return token() == SyntaxKindGreaterThanToken || token() == SyntaxKindSlashToken
	case ParsingContextJsxChildren:
		return token() == SyntaxKindLessThanToken && lookAhead(nextTokenIsSlash)
	default:
		return false
	}
}

func isVariableDeclaratorListTerminator() bool {
	// If we can consume a semicolon (either explicitly, or with ASI), then consider us done
	// with parsing the list of variable declarators.
	if canParseSemicolon() {
		return true
	}

	// in the case where we're parsing the variable declarator of a 'for-in' statement, we
	// are done if we see an 'in' keyword in front of us. Same with for-of
	if isInOrOfKeyword(token()) {
		return true
	}

	// ERROR RECOVERY TWEAK:
	// For better error recovery, if we see an '=>' then we just stop immediately.  We've got an
	// arrow function here and it's going to be very unlikely that we'll resynchronize and get
	// another variable declaration.
	if token() == SyntaxKindEqualsGreaterThanToken {
		return true
	}

	// Keep trying to parse out variable declarators.
	return false
}

// True if positioned at element or terminator of the current list or any enclosing list
func isInSomeParsingContext() bool {
	// We should be in at least one parsing context, be it SourceElements while parsing
	// a SourceFile, or JSDocComment when lazily parsing JSDoc.
	Debug.assert(parsingContext, "Missing parsing context")
	for kind := 0; kind < ParsingContextCount; kind++ {
		if parsingContext & ( /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: 1 << kind */ TODO) {
			if isListElement(kind /*inErrorRecovery*/, true) || isListTerminator(kind) {
				return true
			}
		}
	}

	return false
}

// Parses a list of elements
func parseList(kind ParsingContext, parseElement func() T) NodeArray[T] {
	saveParsingContext := parsingContext
	parsingContext |= /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: 1 << kind */ TODO
	list := []never{}
	listPos := getNodePos()

	for !isListTerminator(kind) {
		if isListElement(kind /*inErrorRecovery*/, false) {
			list.push(parseListElement(kind, parseElement))

			continue
		}

		if abortParsingListOrMoveToNextToken(kind) {
			break
		}
	}

	parsingContext = saveParsingContext
	return createNodeArray(list, listPos)
}

func parseListElement(parsingContext ParsingContext, parseElement func() T) T {
	node := currentNode(parsingContext)
	if node {
		return consumeNode(node).(T)
	}

	return parseElement()
}

func currentNode(parsingContext ParsingContext, pos number) Node {
	// If we don't have a cursor or the parsing context isn't reusable, there's nothing to reuse.
	//
	// If there is an outstanding parse error that we've encountered, but not attached to
	// some node, then we cannot get a node from the old source tree.  This is because we
	// want to mark the next node we encounter as being unusable.
	//
	// Note: This may be too conservative.  Perhaps we could reuse the node and set the bit
	// on it (or its leftmost child) as having the error.  For now though, being conservative
	// is nice and likely won't ever affect perf.
	if !syntaxCursor || !isReusableParsingContext(parsingContext) || parseErrorBeforeNextFinishedNode {
		return nil
	}

	node := syntaxCursor.currentNode( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: pos ?? scanner.getTokenFullStart() */ TODO)

	// Can't reuse a missing node.
	// Can't reuse a node that intersected the change range.
	// Can't reuse a node that contains a parse error.  This is necessary so that we
	// produce the same set of errors again.
	if nodeIsMissing(node) || intersectsIncrementalChange(node) || containsParseError(node) {
		return nil
	}

	// We can only reuse a node if it was parsed under the same strict mode that we're
	// currently in.  i.e. if we originally parsed a node in non-strict mode, but then
	// the user added 'using strict' at the top of the file, then we can't use that node
	// again as the presence of strict mode may cause us to parse the tokens in the file
	// differently.
	//
	// Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
	// are unaffected by strict mode.  It's just the parser will decide what to do with it
	// differently depending on what mode it is in.
	//
	// This also applies to all our other context flags as well.
	nodeContextFlags := node.flags & NodeFlagsContextFlags
	if nodeContextFlags != contextFlags {
		return nil
	}

	// Ok, we have a node that looks like it could be reused.  Now verify that it is valid
	// in the current list parsing context that we're currently at.
	if !canReuseNode(node, parsingContext) {
		return nil
	}

	if canHaveJSDoc(node) && node.jsDoc. /* ? */ jsDocCache {
		// jsDocCache may include tags from parent nodes, which might have been modified.
		node.jsDoc.jsDocCache = nil
	}

	return node
}

func consumeNode(node Node) Node {
	// Move the scanner so it is after the node we just consumed.
	scanner.resetTokenState(node.end)
	nextToken()
	return node
}

func isReusableParsingContext(parsingContext ParsingContext) bool {
	switch parsingContext {
	case ParsingContextClassMembers,
		ParsingContextSwitchClauses,
		ParsingContextSourceElements,
		ParsingContextBlockStatements,
		ParsingContextSwitchClauseStatements,
		ParsingContextEnumMembers,
		ParsingContextTypeMembers,
		ParsingContextVariableDeclarations,
		ParsingContextJSDocParameters,
		ParsingContextParameters:
		return true
	}
	return false
}

func canReuseNode(node Node, parsingContext ParsingContext) bool {
	switch parsingContext {
	case ParsingContextClassMembers:
		return isReusableClassMember(node)
	case ParsingContextSwitchClauses:
		return isReusableSwitchClause(node)
	case ParsingContextSourceElements,
		ParsingContextBlockStatements,
		ParsingContextSwitchClauseStatements:
		return isReusableStatement(node)
	case ParsingContextEnumMembers:
		return isReusableEnumMember(node)
	case ParsingContextTypeMembers:
		return isReusableTypeMember(node)
	case ParsingContextVariableDeclarations:
		return isReusableVariableDeclaration(node)
	case ParsingContextJSDocParameters,
		ParsingContextParameters:
		return isReusableParameter(node)

		// Any other lists we do not care about reusing nodes in.  But feel free to add if
		// you can do so safely.  Danger areas involve nodes that may involve speculative
		// parsing.  If speculative parsing is involved with the node, then the range the
		// parser reached while looking ahead might be in the edited range (see the example
		// in canReuseVariableDeclaratorNode for a good case of this).

		// case ParsingContext.HeritageClauses:
		// This would probably be safe to reuse.  There is no speculative parsing with
		// heritage clauses.

		// case ParsingContext.TypeParameters:
		// This would probably be safe to reuse.  There is no speculative parsing with
		// type parameters.  Note that that's because type *parameters* only occur in
		// unambiguous *type* contexts.  While type *arguments* occur in very ambiguous
		// *expression* contexts.

		// case ParsingContext.TupleElementTypes:
		// This would probably be safe to reuse.  There is no speculative parsing with
		// tuple types.

		// Technically, type argument list types are probably safe to reuse.  While
		// speculative parsing is involved with them (since type argument lists are only
		// produced from speculative parsing a < as a type argument list), we only have
		// the types because speculative parsing succeeded.  Thus, the lookahead never
		// went past the end of the list and rewound.
		// case ParsingContext.TypeArguments:

		// Note: these are almost certainly not safe to ever reuse.  Expressions commonly
		// need a large amount of lookahead, and we should not reuse them as they may
		// have actually intersected the edit.
		// case ParsingContext.ArgumentExpressions:

		// This is not safe to reuse for the same reason as the 'AssignmentExpression'
		// cases.  i.e. a property assignment may end with an expression, and thus might
		// have lookahead far beyond it's old node.
		// case ParsingContext.ObjectLiteralMembers:

		// This is probably not safe to reuse.  There can be speculative parsing with
		// type names in a heritage clause.  There can be generic names in the type
		// name list, and there can be left hand side expressions (which can have type
		// arguments.)
		// case ParsingContext.HeritageClauseElement:

		// Perhaps safe to reuse, but it's unlikely we'd see more than a dozen attributes
		// on any given element. Same for children.
		// case ParsingContext.JsxAttributes:
		// case ParsingContext.JsxChildren:
	}

	return false
}

func isReusableClassMember(node Node) bool {
	if node {
		switch node.kind {
		case SyntaxKindConstructor,
			SyntaxKindIndexSignature,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor,
			SyntaxKindPropertyDeclaration,
			SyntaxKindSemicolonClassElement:
			return true
		case SyntaxKindMethodDeclaration:
			// Method declarations are not necessarily reusable.  An object-literal
			// may have a method calls "constructor(...)" and we must reparse that
			// into an actual .ConstructorDeclaration.
			methodDeclaration := node.(MethodDeclaration)
			nameIsConstructor := methodDeclaration.name.kind == SyntaxKindIdentifier && methodDeclaration.name.escapedText == "constructor"

			return !nameIsConstructor
		}
	}

	return false
}

func isReusableSwitchClause(node Node) bool {
	if node {
		switch node.kind {
		case SyntaxKindCaseClause,
			SyntaxKindDefaultClause:
			return true
		}
	}

	return false
}

func isReusableStatement(node Node) bool {
	if node {
		switch node.kind {
		case SyntaxKindFunctionDeclaration,
			SyntaxKindVariableStatement,
			SyntaxKindBlock,
			SyntaxKindIfStatement,
			SyntaxKindExpressionStatement,
			SyntaxKindThrowStatement,
			SyntaxKindReturnStatement,
			SyntaxKindSwitchStatement,
			SyntaxKindBreakStatement,
			SyntaxKindContinueStatement,
			SyntaxKindForInStatement,
			SyntaxKindForOfStatement,
			SyntaxKindForStatement,
			SyntaxKindWhileStatement,
			SyntaxKindWithStatement,
			SyntaxKindEmptyStatement,
			SyntaxKindTryStatement,
			SyntaxKindLabeledStatement,
			SyntaxKindDoStatement,
			SyntaxKindDebuggerStatement,
			SyntaxKindImportDeclaration,
			SyntaxKindImportEqualsDeclaration,
			SyntaxKindExportDeclaration,
			SyntaxKindExportAssignment,
			SyntaxKindModuleDeclaration,
			SyntaxKindClassDeclaration,
			SyntaxKindInterfaceDeclaration,
			SyntaxKindEnumDeclaration,
			SyntaxKindTypeAliasDeclaration:
			return true
		}
	}

	return false
}

func isReusableEnumMember(node Node) bool {
	return node.kind == SyntaxKindEnumMember
}

func isReusableTypeMember(node Node) bool {
	if node {
		switch node.kind {
		case SyntaxKindConstructSignature,
			SyntaxKindMethodSignature,
			SyntaxKindIndexSignature,
			SyntaxKindPropertySignature,
			SyntaxKindCallSignature:
			return true
		}
	}

	return false
}

func isReusableVariableDeclaration(node Node) bool {
	if node.kind != SyntaxKindVariableDeclaration {
		return false
	}

	// Very subtle incremental parsing bug.  Consider the following code:
	//
	//      let v = new List < A, B
	//
	// This is actually legal code.  It's a list of variable declarators "v = new List<A"
	// on one side and "B" on the other. If you then change that to:
	//
	//      let v = new List < A, B >()
	//
	// then we have a problem.  "v = new List<A" doesn't intersect the change range, so we
	// start reparsing at "B" and we completely fail to handle this properly.
	//
	// In order to prevent this, we do not allow a variable declarator to be reused if it
	// has an initializer.
	variableDeclarator := node.(VariableDeclaration)
	return variableDeclarator.initializer == nil
}

func isReusableParameter(node Node) bool {
	if node.kind != SyntaxKindParameter {
		return false
	}

	// See the comment in isReusableVariableDeclaration for why we do this.
	parameter := node.(ParameterDeclaration)
	return parameter.initializer == nil
}

// Returns true if we should abort parsing.
func abortParsingListOrMoveToNextToken(kind ParsingContext) bool {
	parsingContextErrors(kind)
	if isInSomeParsingContext() {
		return true
	}

	nextToken()
	return false
}

func parsingContextErrors(context ParsingContext) *DiagnosticWithDetachedLocation {
	switch context {
	case ParsingContextSourceElements:
		if token() == SyntaxKindDefaultKeyword {
			return parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKindExportKeyword))
		} else {
			return parseErrorAtCurrentToken(Diagnostics.Declaration_or_statement_expected)
		}
	case ParsingContextBlockStatements:
		return parseErrorAtCurrentToken(Diagnostics.Declaration_or_statement_expected)
	case ParsingContextSwitchClauses:
		return parseErrorAtCurrentToken(Diagnostics.case_or_default_expected)
	case ParsingContextSwitchClauseStatements:
		return parseErrorAtCurrentToken(Diagnostics.Statement_expected)
	case ParsingContextRestProperties,
		ParsingContextTypeMembers:
		return parseErrorAtCurrentToken(Diagnostics.Property_or_signature_expected)
	case ParsingContextClassMembers:
		return parseErrorAtCurrentToken(Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected)
	case ParsingContextEnumMembers:
		return parseErrorAtCurrentToken(Diagnostics.Enum_member_expected)
	case ParsingContextHeritageClauseElement:
		return parseErrorAtCurrentToken(Diagnostics.Expression_expected)
	case ParsingContextVariableDeclarations:
		if isKeyword(token()) {
			return parseErrorAtCurrentToken(Diagnostics._0_is_not_allowed_as_a_variable_declaration_name, tokenToString(token()))
		} else {
			return parseErrorAtCurrentToken(Diagnostics.Variable_declaration_expected)
		}
	case ParsingContextObjectBindingElements:
		return parseErrorAtCurrentToken(Diagnostics.Property_destructuring_pattern_expected)
	case ParsingContextArrayBindingElements:
		return parseErrorAtCurrentToken(Diagnostics.Array_element_destructuring_pattern_expected)
	case ParsingContextArgumentExpressions:
		return parseErrorAtCurrentToken(Diagnostics.Argument_expression_expected)
	case ParsingContextObjectLiteralMembers:
		return parseErrorAtCurrentToken(Diagnostics.Property_assignment_expected)
	case ParsingContextArrayLiteralMembers:
		return parseErrorAtCurrentToken(Diagnostics.Expression_or_comma_expected)
	case ParsingContextJSDocParameters:
		return parseErrorAtCurrentToken(Diagnostics.Parameter_declaration_expected)
	case ParsingContextParameters:
		if isKeyword(token()) {
			return parseErrorAtCurrentToken(Diagnostics._0_is_not_allowed_as_a_parameter_name, tokenToString(token()))
		} else {
			return parseErrorAtCurrentToken(Diagnostics.Parameter_declaration_expected)
		}
	case ParsingContextTypeParameters:
		return parseErrorAtCurrentToken(Diagnostics.Type_parameter_declaration_expected)
	case ParsingContextTypeArguments:
		return parseErrorAtCurrentToken(Diagnostics.Type_argument_expected)
	case ParsingContextTupleElementTypes:
		return parseErrorAtCurrentToken(Diagnostics.Type_expected)
	case ParsingContextHeritageClauses:
		return parseErrorAtCurrentToken(Diagnostics.Unexpected_token_expected)
	case ParsingContextImportOrExportSpecifiers:
		if token() == SyntaxKindFromKeyword {
			return parseErrorAtCurrentToken(Diagnostics._0_expected, "}")
		}
		return parseErrorAtCurrentToken(Diagnostics.Identifier_expected)
	case ParsingContextJsxAttributes:
		return parseErrorAtCurrentToken(Diagnostics.Identifier_expected)
	case ParsingContextJsxChildren:
		return parseErrorAtCurrentToken(Diagnostics.Identifier_expected)
	case ParsingContextImportAttributes:
		return parseErrorAtCurrentToken(Diagnostics.Identifier_or_string_literal_expected)
	case ParsingContextJSDocComment:
		return parseErrorAtCurrentToken(Diagnostics.Identifier_expected)
	case ParsingContextCount:
		return Debug.fail("ParsingContext.Count used as a context")
		// Not a real context, only a marker.
	default:
		Debug.assertNever(context)
	}
}

// Parses a comma-delimited list of elements
/* OVERLOAD: function parseDelimitedList<T extends Node>(kind: ParsingContext, parseElement: () => T, considerSemicolonAsDelimiter?: boolean): NodeArray<T>; */
/* OVERLOAD: function parseDelimitedList<T extends Node | undefined>(kind: ParsingContext, parseElement: () => T, considerSemicolonAsDelimiter?: boolean): NodeArray<NonNullable<T>> | undefined; */
func parseDelimitedList(kind ParsingContext, parseElement func() T, considerSemicolonAsDelimiter bool) *NodeArray[NonNullable[T]] {
	saveParsingContext := parsingContext
	parsingContext |= /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: 1 << kind */ TODO
	var list []NonNullable[T] = []never{}
	listPos := getNodePos()

	commaStart := -1
	// Meaning the previous token was not a comma
	for true {
		if isListElement(kind /*inErrorRecovery*/, false) {
			startPos := scanner.getTokenFullStart()
			result := parseListElement(kind, parseElement)
			if !result {
				parsingContext = saveParsingContext
				return nil
			}
			list.push(result)
			commaStart = scanner.getTokenStart()

			if parseOptional(SyntaxKindCommaToken) {
				// No need to check for a zero length node since we know we parsed a comma
				continue
			}

			commaStart = -1
			// Back to the state where the last token was not a comma
			if isListTerminator(kind) {
				break
			}

			// We didn't get a comma, and the list wasn't terminated, explicitly parse
			// out a comma so we give a good error message.
			parseExpected(SyntaxKindCommaToken, getExpectedCommaDiagnostic(kind))

			// If the token was a semicolon, and the caller allows that, then skip it and
			// continue.  This ensures we get back on track and don't result in tons of
			// parse errors.  For example, this can happen when people do things like use
			// a semicolon to delimit object literal members.   Note: we'll have already
			// reported an error when we called parseExpected above.
			if considerSemicolonAsDelimiter && token() == SyntaxKindSemicolonToken && !scanner.hasPrecedingLineBreak() {
				nextToken()
			}
			if startPos == scanner.getTokenFullStart() {
				// What we're parsing isn't actually remotely recognizable as a element and we've consumed no tokens whatsoever
				// Consume a token to advance the parser in some way and avoid an infinite loop
				// This can happen when we're speculatively parsing parenthesized expressions which we think may be arrow functions,
				// or when a modifier keyword which is disallowed as a parameter name (ie, `static` in strict mode) is supplied
				nextToken()
			}
			continue
		}

		if isListTerminator(kind) {
			break
		}

		if abortParsingListOrMoveToNextToken(kind) {
			break
		}
	}

	parsingContext = saveParsingContext
	// Recording the trailing comma is deliberately done after the previous
	// loop, and not just if we see a list terminator. This is because the list
	// may have ended incorrectly, but it is still important to know if there
	// was a trailing comma.
	// Check if the last token was a comma.
	// Always preserve a trailing comma by marking it on the NodeArray
	return createNodeArray(list, listPos /*end*/, nil, commaStart >= 0)
}

func getExpectedCommaDiagnostic(kind ParsingContext) any {
	if kind == ParsingContextEnumMembers {
		return Diagnostics.An_enum_member_name_must_be_followed_by_a_or
	} else {
		return nil
	}
}

type MissingList[T Node] struct {
	isMissingList /* TODO(TS-TO-GO) TypeNode LiteralType: true */ any
}

func createMissingList() MissingList[T] {
	list := createNodeArray([]never{}, getNodePos()).(MissingList[T])
	list.isMissingList = true
	return list
}

func isMissingList(arr NodeArray[Node]) bool {
	return !!(arr.(MissingList[Node])).isMissingList
}

func parseBracketedList(kind ParsingContext, parseElement func() T, open PunctuationSyntaxKind, close PunctuationSyntaxKind) NodeArray[T] {
	if parseExpected(open) {
		result := parseDelimitedList(kind, parseElement)
		parseExpected(close)
		return result
	}

	return createMissingList()
}

func parseEntityName(allowReservedWords bool, diagnosticMessage DiagnosticMessage) EntityName {
	pos := getNodePos()
	var entity EntityName
	if allowReservedWords {
		entity = parseIdentifierName(diagnosticMessage)
	} else {
		entity = parseIdentifier(diagnosticMessage)
	}
	for parseOptional(SyntaxKindDotToken) {
		if token() == SyntaxKindLessThanToken {
			// The entity is part of a JSDoc-style generic. We will use the gap between `typeName` and
			// `typeArguments` to report it as a grammar error in the checker.
			break
		}
		entity = finishNode(factory.createQualifiedName(entity, parseRightSideOfDot(allowReservedWords /*allowPrivateIdentifiers*/, false /*allowUnicodeEscapeSequenceInIdentifierName*/, true).(Identifier)), pos)
	}
	return entity
}

func createQualifiedName(entity EntityName, name Identifier) QualifiedName {
	return finishNode(factory.createQualifiedName(entity, name), entity.pos)
}

func parseRightSideOfDot(allowIdentifierNames bool, allowPrivateIdentifiers bool, allowUnicodeEscapeSequenceInIdentifierName bool) /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any {
	// Technically a keyword is valid here as all identifiers and keywords are identifier names.
	// However, often we'll encounter this in error situations when the identifier or keyword
	// is actually starting another valid construct.
	//
	// So, we check for the following specific case:
	//
	//      name.
	//      identifierOrKeyword identifierNameOrKeyword
	//
	// Note: the newlines are important here.  For example, if that above code
	// were rewritten into:
	//
	//      name.identifierOrKeyword
	//      identifierNameOrKeyword
	//
	// Then we would consider it valid.  That's because ASI would take effect and
	// the code would be implicitly: "name.identifierOrKeyword; identifierNameOrKeyword".
	// In the first case though, ASI will not take effect because there is not a
	// line terminator after the identifier or keyword.
	if scanner.hasPrecedingLineBreak() && tokenIsIdentifierOrKeyword(token()) {
		matchesPattern := lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine)

		if matchesPattern {
			// Report that we need an identifier.  However, report it right after the dot,
			// and not on the next token.  This is because the next token might actually
			// be an identifier and the error would be quite confusing.
			return createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, true, Diagnostics.Identifier_expected)
		}
	}

	if token() == SyntaxKindPrivateIdentifier {
		node := parsePrivateIdentifier()
		if allowPrivateIdentifiers {
			return node
		} else {
			return createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, true, Diagnostics.Identifier_expected)
		}
	}

	if allowIdentifierNames {
		if allowUnicodeEscapeSequenceInIdentifierName {
			return parseIdentifierName()
		} else {
			return parseIdentifierNameErrorOnUnicodeEscapeSequence()
		}
	}

	return parseIdentifier()
}

func parseTemplateSpans(isTaggedTemplate bool) NodeArray[TemplateSpan] {
	pos := getNodePos()
	list := []never{}
	var node TemplateSpan
	for ok := true; ok; ok = node.literal.kind == SyntaxKindTemplateMiddle { // do-while loop
		node = parseTemplateSpan(isTaggedTemplate)
		list.push(node)
	}
	return createNodeArray(list, pos)
}

func parseTemplateExpression(isTaggedTemplate bool) TemplateExpression {
	pos := getNodePos()
	return finishNode(factory.createTemplateExpression(parseTemplateHead(isTaggedTemplate), parseTemplateSpans(isTaggedTemplate)), pos)
}

func parseTemplateType() TemplateLiteralTypeNode {
	pos := getNodePos()
	return finishNode(factory.createTemplateLiteralType(parseTemplateHead(false), parseTemplateTypeSpans()), pos)
}

func parseTemplateTypeSpans() NodeArray[TemplateLiteralTypeSpan] {
	pos := getNodePos()
	list := []never{}
	var node TemplateLiteralTypeSpan
	for ok := true; ok; ok = node.literal.kind == SyntaxKindTemplateMiddle { // do-while loop
		node = parseTemplateTypeSpan()
		list.push(node)
	}
	return createNodeArray(list, pos)
}

func parseTemplateTypeSpan() TemplateLiteralTypeSpan {
	pos := getNodePos()
	return finishNode(factory.createTemplateLiteralTypeSpan(parseType(), parseLiteralOfTemplateSpan(false)), pos)
}

func parseLiteralOfTemplateSpan(isTaggedTemplate bool) /* TODO(TS-TO-GO) inferred type TemplateMiddle | TemplateTail */ any {
	if token() == SyntaxKindCloseBraceToken {
		reScanTemplateToken(isTaggedTemplate)
		return parseTemplateMiddleOrTemplateTail()
	} else {
		// TODO(rbuckton): Do we need to call `parseExpectedToken` or can we just call `createMissingNode` directly?
		return parseExpectedToken(SyntaxKindTemplateTail, Diagnostics._0_expected, tokenToString(SyntaxKindCloseBraceToken)).(TemplateTail)
	}
}

func parseTemplateSpan(isTaggedTemplate bool) TemplateSpan {
	pos := getNodePos()
	return finishNode(factory.createTemplateSpan(allowInAnd(parseExpression), parseLiteralOfTemplateSpan(isTaggedTemplate)), pos)
}

func parseLiteralNode() LiteralExpression {
	return parseLiteralLikeNode(token()).(LiteralExpression)
}

func parseTemplateHead(isTaggedTemplate bool) TemplateHead {
	if !isTaggedTemplate && scanner.getTokenFlags()&TokenFlagsIsInvalid {
		reScanTemplateToken(false)
	}
	fragment := parseLiteralLikeNode(token())
	Debug.assert(fragment.kind == SyntaxKindTemplateHead, "Template head has wrong token kind")
	return fragment.(TemplateHead)
}

func parseTemplateMiddleOrTemplateTail() /* TODO(TS-TO-GO) TypeNode UnionType: TemplateMiddle | TemplateTail */ any {
	fragment := parseLiteralLikeNode(token())
	Debug.assert(fragment.kind == SyntaxKindTemplateMiddle || fragment.kind == SyntaxKindTemplateTail, "Template fragment has wrong token kind")
	return fragment /* as TemplateMiddle | TemplateTail */
}

func getTemplateLiteralRawText(kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: TemplateLiteralToken["kind"] */ any) string {
	isLast := kind == SyntaxKindNoSubstitutionTemplateLiteral || kind == SyntaxKindTemplateTail
	tokenText := scanner.getTokenText()
	return tokenText.substring(1, tokenText.length-(ifelse(scanner.isUnterminated(), 0, ifelse(isLast, 1, 2))))
}

func parseLiteralLikeNode(kind SyntaxKind) LiteralLikeNode {
	pos := getNodePos()
	var node /* TODO(TS-TO-GO) inferred type StringLiteral | TemplateLiteralLikeNode | NumericLiteral | BigIntLiteral | JsxText | RegularExpressionLiteral */ any
	switch {
	case isTemplateLiteralKind(kind):
		node = factory.createTemplateLiteralLikeNode(kind, scanner.getTokenValue(), getTemplateLiteralRawText(kind), scanner.getTokenFlags()&TokenFlagsTemplateLiteralLikeFlags)
	case kind == SyntaxKindNumericLiteral:
		node = factoryCreateNumericLiteral(scanner.getTokenValue(), scanner.getNumericLiteralFlags())
	case kind == SyntaxKindStringLiteral:
		node = factoryCreateStringLiteral(scanner.getTokenValue() /*isSingleQuote*/, nil, scanner.hasExtendedUnicodeEscape())
	case isLiteralKind(kind):
		node = factoryCreateLiteralLikeNode(kind, scanner.getTokenValue())
	default:
		node = Debug.fail()
	}

	if scanner.hasExtendedUnicodeEscape() {
		node.hasExtendedUnicodeEscape = true
	}

	if scanner.isUnterminated() {
		node.isUnterminated = true
	}

	nextToken()
	return finishNode(node, pos)
}

// TYPES

func parseEntityNameOfTypeReference() EntityName {
	return parseEntityName(true, Diagnostics.Type_expected)
}

func parseTypeArgumentsOfTypeReference() *NodeArray[TypeNode] {
	if !scanner.hasPrecedingLineBreak() && reScanLessThanToken() == SyntaxKindLessThanToken {
		return parseBracketedList(ParsingContextTypeArguments, parseType, SyntaxKindLessThanToken, SyntaxKindGreaterThanToken)
	}
}

func parseTypeReference() TypeReferenceNode {
	pos := getNodePos()
	return finishNode(factory.createTypeReferenceNode(parseEntityNameOfTypeReference(), parseTypeArgumentsOfTypeReference()), pos)
}

// If true, we should abort parsing an error function.
func typeHasArrowFunctionBlockingParseError(node TypeNode) bool {
	switch node.kind {
	case SyntaxKindTypeReference:
		return nodeIsMissing((node.(TypeReferenceNode)).typeName)
	case SyntaxKindFunctionType,
		SyntaxKindConstructorType:
		TODO_IDENTIFIER := node.(FunctionOrConstructorTypeNode)
		return isMissingList(parameters) || typeHasArrowFunctionBlockingParseError(type_)
	case SyntaxKindParenthesizedType:
		return typeHasArrowFunctionBlockingParseError((node.(ParenthesizedTypeNode)).type_)
	default:
		return false
	}
}

func parseThisTypePredicate(lhs ThisTypeNode) TypePredicateNode {
	nextToken()
	return finishNode(factory.createTypePredicateNode(nil, lhs, parseType()), lhs.pos)
}

func parseThisTypeNode() ThisTypeNode {
	pos := getNodePos()
	nextToken()
	return finishNode(factory.createThisTypeNode(), pos)
}

func parseJSDocAllType() /* TODO(TS-TO-GO) TypeNode UnionType: JSDocAllType | JSDocOptionalType */ any {
	pos := getNodePos()
	nextToken()
	return finishNode(factory.createJSDocAllType(), pos)
}

func parseJSDocNonNullableType() TypeNode {
	pos := getNodePos()
	nextToken()
	return finishNode(factory.createJSDocNonNullableType(parseNonArrayType() /*postfix*/, false), pos)
}

func parseJSDocUnknownOrNullableType() /* TODO(TS-TO-GO) TypeNode UnionType: JSDocUnknownType | JSDocNullableType */ any {
	pos := getNodePos()
	// skip the ?
	nextToken()

	// Need to lookahead to decide if this is a nullable or unknown type.

	// Here are cases where we'll pick the unknown type:
	//
	//      Foo(?,
	//      { a: ? }
	//      Foo(?)
	//      Foo<?>
	//      Foo(?=
	//      (?|
	if token() == SyntaxKindCommaToken || token() == SyntaxKindCloseBraceToken || token() == SyntaxKindCloseParenToken || token() == SyntaxKindGreaterThanToken || token() == SyntaxKindEqualsToken || token() == SyntaxKindBarToken {
		return finishNode(factory.createJSDocUnknownType(), pos)
	} else {
		return finishNode(factory.createJSDocNullableType(parseType() /*postfix*/, false), pos)
	}
}

func parseJSDocFunctionType() /* TODO(TS-TO-GO) TypeNode UnionType: JSDocFunctionType | TypeReferenceNode */ any {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	if tryParse(nextTokenIsOpenParen) {
		parameters := parseParameters(SignatureFlagsType | SignatureFlagsJSDoc)
		type_ := parseReturnType(SyntaxKindColonToken /*isType*/, false)
		return withJSDoc(finishNode(factory.createJSDocFunctionType(parameters, type_), pos), hasJSDoc)
	}
	return finishNode(factory.createTypeReferenceNode(parseIdentifierName() /*typeArguments*/, nil), pos)
}

func parseJSDocParameter() ParameterDeclaration {
	pos := getNodePos()
	var name *Identifier
	if token() == SyntaxKindThisKeyword || token() == SyntaxKindNewKeyword {
		name = parseIdentifierName()
		parseExpected(SyntaxKindColonToken)
	}
	return finishNode(factory.createParameterDeclaration(nil, nil, name, nil, parseJSDocType(), nil), pos)
}

func parseJSDocType() TypeNode {
	scanner.setSkipJsDocLeadingAsterisks(true)
	pos := getNodePos()
	if parseOptional(SyntaxKindModuleKeyword) {
		// TODO(rbuckton): We never set the type for a JSDocNamepathType. What should we put here?
		moduleTag := factory.createJSDocNamepathType(nil)
	terminate:
		for true {
			switch token() {
			case SyntaxKindCloseBraceToken,
				SyntaxKindEndOfFileToken,
				SyntaxKindCommaToken,
				SyntaxKindWhitespaceTrivia:
			default:
				nextTokenJSDoc()
			}
		}

		scanner.setSkipJsDocLeadingAsterisks(false)
		return finishNode(moduleTag, pos)
	}

	hasDotDotDot := parseOptional(SyntaxKindDotDotDotToken)
	type_ := parseTypeOrTypePredicate()
	scanner.setSkipJsDocLeadingAsterisks(false)
	if hasDotDotDot {
		type_ = finishNode(factory.createJSDocVariadicType(type_), pos)
	}
	if token() == SyntaxKindEqualsToken {
		nextToken()
		return finishNode(factory.createJSDocOptionalType(type_), pos)
	}
	return type_
}

func parseTypeQuery() TypeQueryNode {
	pos := getNodePos()
	parseExpected(SyntaxKindTypeOfKeyword)
	entityName := parseEntityName(true)
	// Make sure we perform ASI to prevent parsing the next line's type arguments as part of an instantiation expression.
	var typeArguments *NodeArray[TypeNode]
	if !scanner.hasPrecedingLineBreak() {
		typeArguments = tryParseTypeArguments()
	} else {
		typeArguments = nil
	}
	return finishNode(factory.createTypeQueryNode(entityName, typeArguments), pos)
}

func parseTypeParameter() TypeParameterDeclaration {
	pos := getNodePos()
	modifiers := parseModifiers(false /*permitConstAsModifier*/, true)
	name := parseIdentifier()
	var constraint *TypeNode
	var expression Expression
	if parseOptional(SyntaxKindExtendsKeyword) {
		// It's not uncommon for people to write improper constraints to a generic.  If the
		// user writes a constraint that is an expression and not an actual type, then parse
		// it out as an expression (so we can recover well), but report that a type is needed
		// instead.
		if isStartOfType() || !isStartOfExpression() {
			constraint = parseType()
		} else {
			// It was not a type, and it looked like an expression.  Parse out an expression
			// here so we recover well.  Note: it is important that we call parseUnaryExpression
			// and not parseExpression here.  If the user has:
			//
			//      <T extends "">
			//
			// We do *not* want to consume the `>` as we're consuming the expression for "".
			expression = parseUnaryExpressionOrHigher()
		}
	}

	var defaultType *TypeNode
	if parseOptional(SyntaxKindEqualsToken) {
		defaultType = parseType()
	} else {
		defaultType = nil
	}
	node := factory.createTypeParameterDeclaration(modifiers, name, constraint, defaultType)
	node.expression = expression
	return finishNode(node, pos)
}

func parseTypeParameters() *NodeArray[TypeParameterDeclaration] {
	if token() == SyntaxKindLessThanToken {
		return parseBracketedList(ParsingContextTypeParameters, parseTypeParameter, SyntaxKindLessThanToken, SyntaxKindGreaterThanToken)
	}
}

func isStartOfParameter(isJSDocParameter bool) bool {
	return token() == SyntaxKindDotDotDotToken || isBindingIdentifierOrPrivateIdentifierOrPattern() || isModifierKind(token()) || token() == SyntaxKindAtToken || isStartOfType(!isJSDocParameter)
}

func parseNameOfParameter(modifiers *NodeArray[ModifierLike]) /* TODO(TS-TO-GO) inferred type BindingPattern | Identifier */ any {
	// FormalParameter [Yield,Await]:
	//      BindingElement[?Yield,?Await]
	name := parseIdentifierOrPattern(Diagnostics.Private_identifiers_cannot_be_used_as_parameters)
	if getFullWidth(name) == 0 && !some(modifiers) && isModifierKind(token()) {
		// in cases like
		// 'use strict'
		// function foo(static)
		// isParameter('static') === true, because of isModifier('static')
		// however 'static' is not a legal identifier in a strict mode.
		// so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)
		// and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)
		// to avoid this we'll advance cursor to the next token.
		nextToken()
	}
	return name
}

func isParameterNameStart() bool {
	// Be permissive about await and yield by calling isBindingIdentifier instead of isIdentifier; disallowing
	// them during a speculative parse leads to many more follow-on errors than allowing the function to parse then later
	// complaining about the use of the keywords.
	return isBindingIdentifier() || token() == SyntaxKindOpenBracketToken || token() == SyntaxKindOpenBraceToken
}

func parseParameter(inOuterAwaitContext bool) ParameterDeclaration {
	return parseParameterWorker(inOuterAwaitContext)
}

func parseParameterForSpeculation(inOuterAwaitContext bool) *ParameterDeclaration {
	return parseParameterWorker(inOuterAwaitContext /*allowAmbiguity*/, false)
}

/* OVERLOAD: function parseParameterWorker(inOuterAwaitContext: boolean): ParameterDeclaration; */
/* OVERLOAD: function parseParameterWorker(inOuterAwaitContext: boolean, allowAmbiguity: false): ParameterDeclaration | undefined; */
func parseParameterWorker(inOuterAwaitContext bool, allowAmbiguity bool /*  = true */) *ParameterDeclaration {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()

	// FormalParameter [Yield,Await]:
	//      BindingElement[?Yield,?Await]

	// Decorators are parsed in the outer [Await] context, the rest of the parameter is parsed in the function's [Await] context.
	var modifiers *NodeArray[ModifierLike]
	if inOuterAwaitContext {
		modifiers = doInAwaitContext(func() *NodeArray[ModifierLike] {
			return parseModifiers(true)
		})
	} else {
		modifiers = doOutsideOfAwaitContext(func() *NodeArray[ModifierLike] {
			return parseModifiers(true)
		})
	}

	if token() == SyntaxKindThisKeyword {
		node := factory.createParameterDeclaration(modifiers, nil, createIdentifier(true), nil, parseTypeAnnotation(), nil)

		modifier := firstOrUndefined(modifiers)
		if modifier {
			parseErrorAtRange(modifier, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters)
		}

		return withJSDoc(finishNode(node, pos), hasJSDoc)
	}

	savedTopLevel := topLevel
	topLevel = false

	dotDotDotToken := parseOptionalToken(SyntaxKindDotDotDotToken)

	if !allowAmbiguity && !isParameterNameStart() {
		return nil
	}

	node := withJSDoc(finishNode(factory.createParameterDeclaration(modifiers, dotDotDotToken, parseNameOfParameter(modifiers), parseOptionalToken(SyntaxKindQuestionToken), parseTypeAnnotation(), parseInitializer()), pos), hasJSDoc)
	topLevel = savedTopLevel
	return node
}

/* OVERLOAD: function parseReturnType(returnToken: SyntaxKind.EqualsGreaterThanToken, isType: boolean): TypeNode; */
/* OVERLOAD: function parseReturnType(returnToken: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken, isType: boolean): TypeNode | undefined; */
func parseReturnType(returnToken /* TODO(TS-TO-GO) TypeNode UnionType: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken */ any, isType bool) *TypeNode {
	if shouldParseReturnType(returnToken, isType) {
		return allowConditionalTypesAnd(parseTypeOrTypePredicate)
	}
}

func shouldParseReturnType(returnToken /* TODO(TS-TO-GO) TypeNode UnionType: SyntaxKind.ColonToken | SyntaxKind.EqualsGreaterThanToken */ any, isType bool) bool {
	if returnToken == SyntaxKindEqualsGreaterThanToken {
		parseExpected(returnToken)
		return true
	} else if parseOptional(SyntaxKindColonToken) {
		return true
	} else if isType && token() == SyntaxKindEqualsGreaterThanToken {
		// This is easy to get backward, especially in type contexts, so parse the type anyway
		parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKindColonToken))
		nextToken()
		return true
	}
	return false
}

/* OVERLOAD: function parseParametersWorker(flags: SignatureFlags, allowAmbiguity: true): NodeArray<ParameterDeclaration>; */
/* OVERLOAD: function parseParametersWorker(flags: SignatureFlags, allowAmbiguity: false): NodeArray<ParameterDeclaration> | undefined; */
func parseParametersWorker(flags SignatureFlags, allowAmbiguity bool) *NodeArray[ParameterDeclaration] {
	// FormalParameters [Yield,Await]: (modified)
	//      [empty]
	//      FormalParameterList[?Yield,Await]
	//
	// FormalParameter[Yield,Await]: (modified)
	//      BindingElement[?Yield,Await]
	//
	// BindingElement [Yield,Await]: (modified)
	//      SingleNameBinding[?Yield,?Await]
	//      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
	//
	// SingleNameBinding [Yield,Await]:
	//      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
	savedYieldContext := inYieldContext()
	savedAwaitContext := inAwaitContext()

	setYieldContext(!!(flags & SignatureFlagsYield))
	setAwaitContext(!!(flags & SignatureFlagsAwait))

	var parameters *NodeArray[ParameterDeclaration]
	if flags & SignatureFlagsJSDoc {
		parameters = parseDelimitedList(ParsingContextJSDocParameters, parseJSDocParameter)
	} else {
		parameters = parseDelimitedList(ParsingContextParameters, func() *ParameterDeclaration {
			if allowAmbiguity {
				return parseParameter(savedAwaitContext)
			} else {
				return parseParameterForSpeculation(savedAwaitContext)
			}
		})
	}

	setYieldContext(savedYieldContext)
	setAwaitContext(savedAwaitContext)

	return parameters
}

func parseParameters(flags SignatureFlags) NodeArray[ParameterDeclaration] {
	// FormalParameters [Yield,Await]: (modified)
	//      [empty]
	//      FormalParameterList[?Yield,Await]
	//
	// FormalParameter[Yield,Await]: (modified)
	//      BindingElement[?Yield,Await]
	//
	// BindingElement [Yield,Await]: (modified)
	//      SingleNameBinding[?Yield,?Await]
	//      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
	//
	// SingleNameBinding [Yield,Await]:
	//      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
	if !parseExpected(SyntaxKindOpenParenToken) {
		return createMissingList()
	}

	parameters := parseParametersWorker(flags /*allowAmbiguity*/, true)
	parseExpected(SyntaxKindCloseParenToken)
	return parameters
}

func parseTypeMemberSemicolon() {
	// We allow type members to be separated by commas or (possibly ASI) semicolons.
	// First check if it was a comma.  If so, we're done with the member.
	if parseOptional(SyntaxKindCommaToken) {
		return
	}

	// Didn't have a comma.  We must have a (possible ASI) semicolon.
	parseSemicolon()
}

func parseSignatureMember(kind /* TODO(TS-TO-GO) TypeNode UnionType: SyntaxKind.CallSignature | SyntaxKind.ConstructSignature */ any) /* TODO(TS-TO-GO) TypeNode UnionType: CallSignatureDeclaration | ConstructSignatureDeclaration */ any {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	if kind == SyntaxKindConstructSignature {
		parseExpected(SyntaxKindNewKeyword)
	}

	typeParameters := parseTypeParameters()
	parameters := parseParameters(SignatureFlagsType)
	type_ := parseReturnType(SyntaxKindColonToken /*isType*/, true)
	parseTypeMemberSemicolon()
	var node /* TODO(TS-TO-GO) inferred type CallSignatureDeclaration | ConstructSignatureDeclaration */ any
	if kind == SyntaxKindCallSignature {
		node = factory.createCallSignature(typeParameters, parameters, type_)
	} else {
		node = factory.createConstructSignature(typeParameters, parameters, type_)
	}
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func isIndexSignature() bool {
	return token() == SyntaxKindOpenBracketToken && lookAhead(isUnambiguouslyIndexSignature)
}

func isUnambiguouslyIndexSignature() bool {
	// The only allowed sequence is:
	//
	//   [id:
	//
	// However, for error recovery, we also check the following cases:
	//
	//   [...
	//   [id,
	//   [id?,
	//   [id?:
	//   [id?]
	//   [public id
	//   [private id
	//   [protected id
	//   []
	//
	nextToken()
	if token() == SyntaxKindDotDotDotToken || token() == SyntaxKindCloseBracketToken {
		return true
	}

	if isModifierKind(token()) {
		nextToken()
		if isIdentifier() {
			return true
		}
	} else if !isIdentifier() {
		return false
	} else {
		// Skip the identifier
		nextToken()
	}

	// A colon signifies a well formed indexer
	// A comma should be a badly formed indexer because comma expressions are not allowed
	// in computed properties.
	if token() == SyntaxKindColonToken || token() == SyntaxKindCommaToken {
		return true
	}

	// Question mark could be an indexer with an optional property,
	// or it could be a conditional expression in a computed property.
	if token() != SyntaxKindQuestionToken {
		return false
	}

	// If any of the following tokens are after the question mark, it cannot
	// be a conditional expression, so treat it as an indexer.
	nextToken()
	return token() == SyntaxKindColonToken || token() == SyntaxKindCommaToken || token() == SyntaxKindCloseBracketToken
}

func parseIndexSignatureDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) IndexSignatureDeclaration {
	parameters := parseBracketedList(ParsingContextParameters, func() ParameterDeclaration {
		return parseParameter(false)
	}, SyntaxKindOpenBracketToken, SyntaxKindCloseBracketToken)
	type_ := parseTypeAnnotation()
	parseTypeMemberSemicolon()
	node := factory.createIndexSignature(modifiers, parameters, type_)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parsePropertyOrMethodSignature(pos number, hasJSDoc bool, modifiers *NodeArray[Modifier]) /* TODO(TS-TO-GO) TypeNode UnionType: PropertySignature | MethodSignature */ any {
	name := parsePropertyName()
	questionToken := parseOptionalToken(SyntaxKindQuestionToken)
	var node /* TODO(TS-TO-GO) TypeNode UnionType: PropertySignature | MethodSignature */ any
	if token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken {
		// Method signatures don't exist in expression contexts.  So they have neither
		// [Yield] nor [Await]
		typeParameters := parseTypeParameters()
		parameters := parseParameters(SignatureFlagsType)
		type_ := parseReturnType(SyntaxKindColonToken /*isType*/, true)
		node = factory.createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type_)
	} else {
		type_ := parseTypeAnnotation()
		node = factory.createPropertySignature(modifiers, name, questionToken, type_)
		// Although type literal properties cannot not have initializers, we attempt
		// to parse an initializer so we can report in the checker that an interface
		// property or type literal property cannot have an initializer.
		if token() == SyntaxKindEqualsToken {
			(node.(Mutable[PropertySignature])).initializer = parseInitializer()
		}
	}
	parseTypeMemberSemicolon()
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func isTypeMemberStart() bool {
	// Return true if we have the start of a signature member
	if token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken || token() == SyntaxKindGetKeyword || token() == SyntaxKindSetKeyword {
		return true
	}
	idToken := false
	// Eat up all modifiers, but hold on to the last one in case it is actually an identifier
	for isModifierKind(token()) {
		idToken = true
		nextToken()
	}
	// Index signatures and computed property names are type members
	if token() == SyntaxKindOpenBracketToken {
		return true
	}
	// Try to get the first property-like token following all modifiers
	if isLiteralPropertyName() {
		idToken = true
		nextToken()
	}
	// If we were able to get any potential identifier, check that it is
	// the start of a member declaration
	if idToken {
		return token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken || token() == SyntaxKindQuestionToken || token() == SyntaxKindColonToken || token() == SyntaxKindCommaToken || canParseSemicolon()
	}
	return false
}

func parseTypeMember() TypeElement {
	if token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken {
		return parseSignatureMember(SyntaxKindCallSignature)
	}
	if token() == SyntaxKindNewKeyword && lookAhead(nextTokenIsOpenParenOrLessThan) {
		return parseSignatureMember(SyntaxKindConstructSignature)
	}
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	modifiers := parseModifiers(false)
	if parseContextualModifier(SyntaxKindGetKeyword) {
		return parseAccessorDeclaration(pos, hasJSDoc, modifiers, SyntaxKindGetAccessor, SignatureFlagsType)
	}

	if parseContextualModifier(SyntaxKindSetKeyword) {
		return parseAccessorDeclaration(pos, hasJSDoc, modifiers, SyntaxKindSetAccessor, SignatureFlagsType)
	}

	if isIndexSignature() {
		return parseIndexSignatureDeclaration(pos, hasJSDoc, modifiers)
	}
	return parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers)
}

func nextTokenIsOpenParenOrLessThan() bool {
	nextToken()
	return token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken
}

func nextTokenIsDot() bool {
	return nextToken() == SyntaxKindDotToken
}

func nextTokenIsOpenParenOrLessThanOrDot() bool {
	switch nextToken() {
	case SyntaxKindOpenParenToken,
		SyntaxKindLessThanToken,
		SyntaxKindDotToken:
		return true
	}
	return false
}

func parseTypeLiteral() TypeLiteralNode {
	pos := getNodePos()
	return finishNode(factory.createTypeLiteralNode(parseObjectTypeMembers()), pos)
}

func parseObjectTypeMembers() NodeArray[TypeElement] {
	var members NodeArray[TypeElement]
	if parseExpected(SyntaxKindOpenBraceToken) {
		members = parseList(ParsingContextTypeMembers, parseTypeMember)
		parseExpected(SyntaxKindCloseBraceToken)
	} else {
		members = createMissingList()
	}

	return members
}

func isStartOfMappedType() bool {
	nextToken()
	if token() == SyntaxKindPlusToken || token() == SyntaxKindMinusToken {
		return nextToken() == SyntaxKindReadonlyKeyword
	}
	if token() == SyntaxKindReadonlyKeyword {
		nextToken()
	}
	return token() == SyntaxKindOpenBracketToken && nextTokenIsIdentifier() && nextToken() == SyntaxKindInKeyword
}

func parseMappedTypeParameter() TypeParameterDeclaration {
	pos := getNodePos()
	name := parseIdentifierName()
	parseExpected(SyntaxKindInKeyword)
	type_ := parseType()
	return finishNode(factory.createTypeParameterDeclaration(nil, name, type_ /*defaultType*/, nil), pos)
}

func parseMappedType() MappedTypeNode {
	pos := getNodePos()
	parseExpected(SyntaxKindOpenBraceToken)
	var readonlyToken /* TODO(TS-TO-GO) TypeNode UnionType: ReadonlyKeyword | PlusToken | MinusToken | undefined */ any
	if token() == SyntaxKindReadonlyKeyword || token() == SyntaxKindPlusToken || token() == SyntaxKindMinusToken {
		readonlyToken = parseTokenNode()
		if readonlyToken.kind != SyntaxKindReadonlyKeyword {
			parseExpected(SyntaxKindReadonlyKeyword)
		}
	}
	parseExpected(SyntaxKindOpenBracketToken)
	typeParameter := parseMappedTypeParameter()
	var nameType *TypeNode
	if parseOptional(SyntaxKindAsKeyword) {
		nameType = parseType()
	} else {
		nameType = nil
	}
	parseExpected(SyntaxKindCloseBracketToken)
	var questionToken /* TODO(TS-TO-GO) TypeNode UnionType: QuestionToken | PlusToken | MinusToken | undefined */ any
	if token() == SyntaxKindQuestionToken || token() == SyntaxKindPlusToken || token() == SyntaxKindMinusToken {
		questionToken = parseTokenNode()
		if questionToken.kind != SyntaxKindQuestionToken {
			parseExpected(SyntaxKindQuestionToken)
		}
	}
	type_ := parseTypeAnnotation()
	parseSemicolon()
	members := parseList(ParsingContextTypeMembers, parseTypeMember)
	parseExpected(SyntaxKindCloseBraceToken)
	return finishNode(factory.createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type_, members), pos)
}

func parseTupleElementType() TypeNode {
	pos := getNodePos()
	if parseOptional(SyntaxKindDotDotDotToken) {
		return finishNode(factory.createRestTypeNode(parseType()), pos)
	}
	type_ := parseType()
	if isJSDocNullableType(type_) && type_.pos == type_.type_.pos {
		node := factory.createOptionalTypeNode(type_.type_)
		setTextRange(node, type_)
		(node.(Mutable[Node])).flags = type_.flags
		return node
	}
	return type_
}

func isNextTokenColonOrQuestionColon() bool {
	return nextToken() == SyntaxKindColonToken || (token() == SyntaxKindQuestionToken && nextToken() == SyntaxKindColonToken)
}

func isTupleElementName() bool {
	if token() == SyntaxKindDotDotDotToken {
		return tokenIsIdentifierOrKeyword(nextToken()) && isNextTokenColonOrQuestionColon()
	}
	return tokenIsIdentifierOrKeyword(token()) && isNextTokenColonOrQuestionColon()
}

func parseTupleElementNameOrTupleElementType() TypeNode {
	if lookAhead(isTupleElementName) {
		pos := getNodePos()
		hasJSDoc := hasPrecedingJSDocComment()
		dotDotDotToken := parseOptionalToken(SyntaxKindDotDotDotToken)
		name := parseIdentifierName()
		questionToken := parseOptionalToken(SyntaxKindQuestionToken)
		parseExpected(SyntaxKindColonToken)
		type_ := parseTupleElementType()
		node := factory.createNamedTupleMember(dotDotDotToken, name, questionToken, type_)
		return withJSDoc(finishNode(node, pos), hasJSDoc)
	}
	return parseTupleElementType()
}

func parseTupleType() TupleTypeNode {
	pos := getNodePos()
	return finishNode(factory.createTupleTypeNode(parseBracketedList(ParsingContextTupleElementTypes, parseTupleElementNameOrTupleElementType, SyntaxKindOpenBracketToken, SyntaxKindCloseBracketToken)), pos)
}

func parseParenthesizedType() TypeNode {
	pos := getNodePos()
	parseExpected(SyntaxKindOpenParenToken)
	type_ := parseType()
	parseExpected(SyntaxKindCloseParenToken)
	return finishNode(factory.createParenthesizedType(type_), pos)
}

func parseModifiersForConstructorType() *NodeArray[Modifier] {
	var modifiers *NodeArray[Modifier]
	if token() == SyntaxKindAbstractKeyword {
		pos := getNodePos()
		nextToken()
		modifier := finishNode(factoryCreateToken(SyntaxKindAbstractKeyword), pos)
		modifiers = createNodeArray([] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.AbstractKeyword> */ any{modifier}, pos)
	}
	return modifiers
}

func parseFunctionOrConstructorType() TypeNode {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	modifiers := parseModifiersForConstructorType()
	isConstructorType := parseOptional(SyntaxKindNewKeyword)
	Debug.assert(!modifiers || isConstructorType, "Per isStartOfFunctionOrConstructorType, a function type cannot have modifiers.")
	typeParameters := parseTypeParameters()
	parameters := parseParameters(SignatureFlagsType)
	type_ := parseReturnType(SyntaxKindEqualsGreaterThanToken /*isType*/, false)
	var node /* TODO(TS-TO-GO) inferred type FunctionTypeNode | ConstructorTypeNode */ any
	if isConstructorType {
		node = factory.createConstructorTypeNode(modifiers, typeParameters, parameters, type_)
	} else {
		node = factory.createFunctionTypeNode(typeParameters, parameters, type_)
	}
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseKeywordAndNoDot() *TypeNode {
	node := parseTokenNode()
	if token() == SyntaxKindDotToken {
		return nil
	} else {
		return node
	}
}

func parseLiteralTypeNode(negative bool) LiteralTypeNode {
	pos := getNodePos()
	if negative {
		nextToken()
	}
	var expression /* TODO(TS-TO-GO) TypeNode UnionType: BooleanLiteral | NullLiteral | LiteralExpression | PrefixUnaryExpression */ any
	if token() == SyntaxKindTrueKeyword || token() == SyntaxKindFalseKeyword || token() == SyntaxKindNullKeyword {
		expression = parseTokenNode()
	} else {
		expression = parseLiteralLikeNode(token()).(LiteralExpression)
	}
	if negative {
		expression = finishNode(factory.createPrefixUnaryExpression(SyntaxKindMinusToken, expression), pos)
	}
	return finishNode(factory.createLiteralTypeNode(expression), pos)
}

func isStartOfTypeOfImportType() bool {
	nextToken()
	return token() == SyntaxKindImportKeyword
}

func parseImportType() ImportTypeNode {
	sourceFlags |= NodeFlagsPossiblyContainsDynamicImport
	pos := getNodePos()
	isTypeOf := parseOptional(SyntaxKindTypeOfKeyword)
	parseExpected(SyntaxKindImportKeyword)
	parseExpected(SyntaxKindOpenParenToken)
	type_ := parseType()
	var attributes *ImportAttributes
	if parseOptional(SyntaxKindCommaToken) {
		openBracePosition := scanner.getTokenStart()
		parseExpected(SyntaxKindOpenBraceToken)
		currentToken := token()
		if currentToken == SyntaxKindWithKeyword || currentToken == SyntaxKindAssertKeyword {
			nextToken()
		} else {
			parseErrorAtCurrentToken(Diagnostics._0_expected, tokenToString(SyntaxKindWithKeyword))
		}
		parseExpected(SyntaxKindColonToken)
		attributes = parseImportAttributes(currentToken /* as SyntaxKind.WithKeyword | SyntaxKind.AssertKeyword */ /*skipKeyword*/, true)
		if !parseExpected(SyntaxKindCloseBraceToken) {
			lastError := lastOrUndefined(parseDiagnostics)
			if lastError && lastError.code == Diagnostics._0_expected.code {
				addRelatedInfo(lastError, createDetachedDiagnostic(fileName, sourceText, openBracePosition, 1, Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"))
			}
		}
	}
	parseExpected(SyntaxKindCloseParenToken)
	var qualifier *EntityName
	if parseOptional(SyntaxKindDotToken) {
		qualifier = parseEntityNameOfTypeReference()
	} else {
		qualifier = nil
	}
	typeArguments := parseTypeArgumentsOfTypeReference()
	return finishNode(factory.createImportTypeNode(type_, attributes, qualifier, typeArguments, isTypeOf), pos)
}

func nextTokenIsNumericOrBigIntLiteral() bool {
	nextToken()
	return token() == SyntaxKindNumericLiteral || token() == SyntaxKindBigIntLiteral
}

func parseNonArrayType() TypeNode {
	switch token() {
	case SyntaxKindAnyKeyword,
		SyntaxKindUnknownKeyword,
		SyntaxKindStringKeyword,
		SyntaxKindNumberKeyword,
		SyntaxKindBigIntKeyword,
		SyntaxKindSymbolKeyword,
		SyntaxKindBooleanKeyword,
		SyntaxKindUndefinedKeyword,
		SyntaxKindNeverKeyword,
		SyntaxKindObjectKeyword:
		// If these are followed by a dot, then parse these out as a dotted type reference instead.
		return tryParse(parseKeywordAndNoDot) || parseTypeReference()
	case SyntaxKindAsteriskEqualsToken:
		// If there is '*=', treat it as * followed by postfix =
		scanner.reScanAsteriskEqualsToken()
		fallthrough
	case SyntaxKindAsteriskToken:
		return parseJSDocAllType()
	case SyntaxKindQuestionQuestionToken:
		// If there is '??', treat it as prefix-'?' in JSDoc type.
		scanner.reScanQuestionToken()
		fallthrough
	case SyntaxKindQuestionToken:
		return parseJSDocUnknownOrNullableType()
	case SyntaxKindFunctionKeyword:
		return parseJSDocFunctionType()
	case SyntaxKindExclamationToken:
		return parseJSDocNonNullableType()
	case SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindStringLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindNullKeyword:
		return parseLiteralTypeNode()
	case SyntaxKindMinusToken:
		if lookAhead(nextTokenIsNumericOrBigIntLiteral) {
			return parseLiteralTypeNode(true)
		} else {
			return parseTypeReference()
		}
	case SyntaxKindVoidKeyword:
		return parseTokenNode()
	case SyntaxKindThisKeyword:
		thisKeyword := parseThisTypeNode()
		if token() == SyntaxKindIsKeyword && !scanner.hasPrecedingLineBreak() {
			return parseThisTypePredicate(thisKeyword)
		} else {
			return thisKeyword
		}
		fallthrough
	case SyntaxKindTypeOfKeyword:
		if lookAhead(isStartOfTypeOfImportType) {
			return parseImportType()
		} else {
			return parseTypeQuery()
		}
	case SyntaxKindOpenBraceToken:
		if lookAhead(isStartOfMappedType) {
			return parseMappedType()
		} else {
			return parseTypeLiteral()
		}
	case SyntaxKindOpenBracketToken:
		return parseTupleType()
	case SyntaxKindOpenParenToken:
		return parseParenthesizedType()
	case SyntaxKindImportKeyword:
		return parseImportType()
	case SyntaxKindAssertsKeyword:
		if lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) {
			return parseAssertsTypePredicate()
		} else {
			return parseTypeReference()
		}
	case SyntaxKindTemplateHead:
		return parseTemplateType()
	default:
		return parseTypeReference()
	}
}

func isStartOfType(inStartOfParameter bool) bool {
	switch token() {
	case SyntaxKindAnyKeyword,
		SyntaxKindUnknownKeyword,
		SyntaxKindStringKeyword,
		SyntaxKindNumberKeyword,
		SyntaxKindBigIntKeyword,
		SyntaxKindBooleanKeyword,
		SyntaxKindReadonlyKeyword,
		SyntaxKindSymbolKeyword,
		SyntaxKindUniqueKeyword,
		SyntaxKindVoidKeyword,
		SyntaxKindUndefinedKeyword,
		SyntaxKindNullKeyword,
		SyntaxKindThisKeyword,
		SyntaxKindTypeOfKeyword,
		SyntaxKindNeverKeyword,
		SyntaxKindOpenBraceToken,
		SyntaxKindOpenBracketToken,
		SyntaxKindLessThanToken,
		SyntaxKindBarToken,
		SyntaxKindAmpersandToken,
		SyntaxKindNewKeyword,
		SyntaxKindStringLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindObjectKeyword,
		SyntaxKindAsteriskToken,
		SyntaxKindQuestionToken,
		SyntaxKindExclamationToken,
		SyntaxKindDotDotDotToken,
		SyntaxKindInferKeyword,
		SyntaxKindImportKeyword,
		SyntaxKindAssertsKeyword,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindTemplateHead:
		return true
	case SyntaxKindFunctionKeyword:
		return !inStartOfParameter
	case SyntaxKindMinusToken:
		return !inStartOfParameter && lookAhead(nextTokenIsNumericOrBigIntLiteral)
	case SyntaxKindOpenParenToken:
		// Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,
		// or something that starts a type. We don't want to consider things like '(1)' a type.
		return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType)
	default:
		return isIdentifier()
	}
}

func isStartOfParenthesizedOrFunctionType() bool {
	nextToken()
	return token() == SyntaxKindCloseParenToken || isStartOfParameter(false) || isStartOfType()
}

func parsePostfixTypeOrHigher() TypeNode {
	pos := getNodePos()
	type_ := parseNonArrayType()
	for !scanner.hasPrecedingLineBreak() {
		switch token() {
		case SyntaxKindExclamationToken:
			nextToken()
			type_ = finishNode(factory.createJSDocNonNullableType(type_ /*postfix*/, true), pos)
		case SyntaxKindQuestionToken:
			// If next token is start of a type we have a conditional type
			if lookAhead(nextTokenIsStartOfType) {
				return type_
			}
			nextToken()
			type_ = finishNode(factory.createJSDocNullableType(type_ /*postfix*/, true), pos)
		case SyntaxKindOpenBracketToken:
			parseExpected(SyntaxKindOpenBracketToken)
			if isStartOfType() {
				indexType := parseType()
				parseExpected(SyntaxKindCloseBracketToken)
				type_ = finishNode(factory.createIndexedAccessTypeNode(type_, indexType), pos)
			} else {
				parseExpected(SyntaxKindCloseBracketToken)
				type_ = finishNode(factory.createArrayTypeNode(type_), pos)
			}
		default:
			return type_
		}
	}
	return type_
}

func parseTypeOperator(operator /* TODO(TS-TO-GO) TypeNode UnionType: SyntaxKind.KeyOfKeyword | SyntaxKind.UniqueKeyword | SyntaxKind.ReadonlyKeyword */ any) TypeOperatorNode {
	pos := getNodePos()
	parseExpected(operator)
	return finishNode(factory.createTypeOperatorNode(operator, parseTypeOperatorOrHigher()), pos)
}

func tryParseConstraintOfInferType() *TypeNode {
	if parseOptional(SyntaxKindExtendsKeyword) {
		constraint := disallowConditionalTypesAnd(parseType)
		if inDisallowConditionalTypesContext() || token() != SyntaxKindQuestionToken {
			return constraint
		}
	}
}

func parseTypeParameterOfInferType() TypeParameterDeclaration {
	pos := getNodePos()
	name := parseIdentifier()
	constraint := tryParse(tryParseConstraintOfInferType)
	node := factory.createTypeParameterDeclaration(nil, name, constraint)
	return finishNode(node, pos)
}

func parseInferType() InferTypeNode {
	pos := getNodePos()
	parseExpected(SyntaxKindInferKeyword)
	return finishNode(factory.createInferTypeNode(parseTypeParameterOfInferType()), pos)
}

func parseTypeOperatorOrHigher() TypeNode {
	operator := token()
	switch operator {
	case SyntaxKindKeyOfKeyword,
		SyntaxKindUniqueKeyword,
		SyntaxKindReadonlyKeyword:
		return parseTypeOperator(operator)
	case SyntaxKindInferKeyword:
		return parseInferType()
	}
	return allowConditionalTypesAnd(parsePostfixTypeOrHigher)
}

func parseFunctionOrConstructorTypeToError(isInUnionType bool) *TypeNode {
	// the function type and constructor type shorthand notation
	// are not allowed directly in unions and intersections, but we'll
	// try to parse them gracefully and issue a helpful message.
	if isStartOfFunctionTypeOrConstructorType() {
		type_ := parseFunctionOrConstructorType()
		var diagnostic DiagnosticMessage
		if isFunctionTypeNode(type_) {
			if isInUnionType {
				diagnostic = Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type
			} else {
				diagnostic = Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type
			}
		} else {
			if isInUnionType {
				diagnostic = Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type
			} else {
				diagnostic = Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type
			}
		}
		parseErrorAtRange(type_, diagnostic)
		return type_
	}
	return nil
}

func parseUnionOrIntersectionType(operator /* TODO(TS-TO-GO) TypeNode UnionType: SyntaxKind.BarToken | SyntaxKind.AmpersandToken */ any, parseConstituentType func() TypeNode, createTypeNode func(types NodeArray[TypeNode]) UnionOrIntersectionTypeNode) TypeNode {
	pos := getNodePos()
	isUnionType := operator == SyntaxKindBarToken
	hasLeadingOperator := parseOptional(operator)
	type_ := hasLeadingOperator && parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType()
	if token() == operator || hasLeadingOperator {
		types := []TypeNode{type_}
		for parseOptional(operator) {
			types.push(parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType())
		}
		type_ = finishNode(createTypeNode(createNodeArray(types, pos)), pos)
	}
	return type_
}

func parseIntersectionTypeOrHigher() TypeNode {
	return parseUnionOrIntersectionType(SyntaxKindAmpersandToken, parseTypeOperatorOrHigher, factory.createIntersectionTypeNode)
}

func parseUnionTypeOrHigher() TypeNode {
	return parseUnionOrIntersectionType(SyntaxKindBarToken, parseIntersectionTypeOrHigher, factory.createUnionTypeNode)
}

func nextTokenIsNewKeyword() bool {
	nextToken()
	return token() == SyntaxKindNewKeyword
}

func isStartOfFunctionTypeOrConstructorType() bool {
	if token() == SyntaxKindLessThanToken {
		return true
	}
	if token() == SyntaxKindOpenParenToken && lookAhead(isUnambiguouslyStartOfFunctionType) {
		return true
	}
	return token() == SyntaxKindNewKeyword || token() == SyntaxKindAbstractKeyword && lookAhead(nextTokenIsNewKeyword)
}

func skipParameterStart() bool {
	if isModifierKind(token()) {
		// Skip modifiers
		parseModifiers(false)
	}
	if isIdentifier() || token() == SyntaxKindThisKeyword {
		nextToken()
		return true
	}
	if token() == SyntaxKindOpenBracketToken || token() == SyntaxKindOpenBraceToken {
		// Return true if we can parse an array or object binding pattern with no errors
		previousErrorCount := parseDiagnostics.length
		parseIdentifierOrPattern()
		return previousErrorCount == parseDiagnostics.length
	}
	return false
}

func isUnambiguouslyStartOfFunctionType() bool {
	nextToken()
	if token() == SyntaxKindCloseParenToken || token() == SyntaxKindDotDotDotToken {
		// ( )
		// ( ...
		return true
	}
	if skipParameterStart() {
		// We successfully skipped modifiers (if any) and an identifier or binding pattern,
		// now see if we have something that indicates a parameter declaration
		if token() == SyntaxKindColonToken || token() == SyntaxKindCommaToken || token() == SyntaxKindQuestionToken || token() == SyntaxKindEqualsToken {
			// ( xxx :
			// ( xxx ,
			// ( xxx ?
			// ( xxx =
			return true
		}
		if token() == SyntaxKindCloseParenToken {
			nextToken()
			if token() == SyntaxKindEqualsGreaterThanToken {
				// ( xxx ) =>
				return true
			}
		}
	}
	return false
}

func parseTypeOrTypePredicate() TypeNode {
	pos := getNodePos()
	typePredicateVariable := isIdentifier() && tryParse(parseTypePredicatePrefix)
	type_ := parseType()
	if typePredicateVariable {
		return finishNode(factory.createTypePredicateNode(nil, typePredicateVariable, type_), pos)
	} else {
		return type_
	}
}

func parseTypePredicatePrefix() *Identifier {
	id := parseIdentifier()
	if token() == SyntaxKindIsKeyword && !scanner.hasPrecedingLineBreak() {
		nextToken()
		return id
	}
}

func parseAssertsTypePredicate() TypeNode {
	pos := getNodePos()
	assertsModifier := parseExpectedToken(SyntaxKindAssertsKeyword)
	var parameterName /* TODO(TS-TO-GO) inferred type Identifier | ThisTypeNode */ any
	if token() == SyntaxKindThisKeyword {
		parameterName = parseThisTypeNode()
	} else {
		parameterName = parseIdentifier()
	}
	var type_ *TypeNode
	if parseOptional(SyntaxKindIsKeyword) {
		type_ = parseType()
	} else {
		type_ = nil
	}
	return finishNode(factory.createTypePredicateNode(assertsModifier, parameterName, type_), pos)
}

func parseType() TypeNode {
	if contextFlags & NodeFlagsTypeExcludesFlags {
		return doOutsideOfContext(NodeFlagsTypeExcludesFlags, parseType)
	}
	if isStartOfFunctionTypeOrConstructorType() {
		return parseFunctionOrConstructorType()
	}
	pos := getNodePos()
	type_ := parseUnionTypeOrHigher()
	if !inDisallowConditionalTypesContext() && !scanner.hasPrecedingLineBreak() && parseOptional(SyntaxKindExtendsKeyword) {
		// The type following 'extends' is not permitted to be another conditional type
		extendsType := disallowConditionalTypesAnd(parseType)
		parseExpected(SyntaxKindQuestionToken)
		trueType := allowConditionalTypesAnd(parseType)
		parseExpected(SyntaxKindColonToken)
		falseType := allowConditionalTypesAnd(parseType)
		return finishNode(factory.createConditionalTypeNode(type_, extendsType, trueType, falseType), pos)
	}
	return type_
}

func parseTypeAnnotation() *TypeNode {
	if parseOptional(SyntaxKindColonToken) {
		return parseType()
	} else {
		return nil
	}
}

// EXPRESSIONS
func isStartOfLeftHandSideExpression() bool {
	switch token() {
	case SyntaxKindThisKeyword,
		SyntaxKindSuperKeyword,
		SyntaxKindNullKeyword,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindTemplateHead,
		SyntaxKindOpenParenToken,
		SyntaxKindOpenBracketToken,
		SyntaxKindOpenBraceToken,
		SyntaxKindFunctionKeyword,
		SyntaxKindClassKeyword,
		SyntaxKindNewKeyword,
		SyntaxKindSlashToken,
		SyntaxKindSlashEqualsToken,
		SyntaxKindIdentifier:
		return true
	case SyntaxKindImportKeyword:
		return lookAhead(nextTokenIsOpenParenOrLessThanOrDot)
	default:
		return isIdentifier()
	}
}

func isStartOfExpression() bool {
	if isStartOfLeftHandSideExpression() {
		return true
	}

	switch token() {
	case SyntaxKindPlusToken,
		SyntaxKindMinusToken,
		SyntaxKindTildeToken,
		SyntaxKindExclamationToken,
		SyntaxKindDeleteKeyword,
		SyntaxKindTypeOfKeyword,
		SyntaxKindVoidKeyword,
		SyntaxKindPlusPlusToken,
		SyntaxKindMinusMinusToken,
		SyntaxKindLessThanToken,
		SyntaxKindAwaitKeyword,
		SyntaxKindYieldKeyword,
		SyntaxKindPrivateIdentifier,
		SyntaxKindAtToken:
		// Yield/await always starts an expression.  Either it is an identifier (in which case
		// it is definitely an expression).  Or it's a keyword (either because we're in
		// a generator or async function, or in strict mode (or both)) and it started a yield or await expression.
		return true
	default:
		// Error tolerance.  If we see the start of some binary operator, we consider
		// that the start of an expression.  That way we'll parse out a missing identifier,
		// give a good message about an identifier being missing, and then consume the
		// rest of the binary expression.
		if isBinaryOperator() {
			return true
		}

		return isIdentifier()
	}
}

func isStartOfExpressionStatement() bool {
	// As per the grammar, none of '{' or 'function' or 'class' can start an expression statement.
	return token() != SyntaxKindOpenBraceToken && token() != SyntaxKindFunctionKeyword && token() != SyntaxKindClassKeyword && token() != SyntaxKindAtToken && isStartOfExpression()
}

func parseExpression() Expression {
	// Expression[in]:
	//      AssignmentExpression[in]
	//      Expression[in] , AssignmentExpression[in]

	// clear the decorator context when parsing Expression, as it should be unambiguous when parsing a decorator
	saveDecoratorContext := inDecoratorContext()
	if saveDecoratorContext {
		setDecoratorContext(false)
	}

	pos := getNodePos()
	expr := parseAssignmentExpressionOrHigher(true)
	var operatorToken BinaryOperatorToken
	for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: operatorToken = parseOptionalToken(SyntaxKind.CommaToken) */ TODO {
		expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher(true), pos)
	}

	if saveDecoratorContext {
		setDecoratorContext(true)
	}
	return expr
}

func parseInitializer() Expression {
	if parseOptional(SyntaxKindEqualsToken) {
		return parseAssignmentExpressionOrHigher(true)
	} else {
		return nil
	}
}

func parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction bool) Expression {
	//  AssignmentExpression[in,yield]:
	//      1) ConditionalExpression[?in,?yield]
	//      2) LeftHandSideExpression = AssignmentExpression[?in,?yield]
	//      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[?in,?yield]
	//      4) ArrowFunctionExpression[?in,?yield]
	//      5) AsyncArrowFunctionExpression[in,yield,await]
	//      6) [+Yield] YieldExpression[?In]
	//
	// Note: for ease of implementation we treat productions '2' and '3' as the same thing.
	// (i.e. they're both BinaryExpressions with an assignment operator in it).

	// First, do the simple check if we have a YieldExpression (production '6').
	if isYieldExpression() {
		return parseYieldExpression()
	}

	// Then, check if we have an arrow function (production '4' and '5') that starts with a parenthesized
	// parameter list or is an async arrow function.
	// AsyncArrowFunctionExpression:
	//      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]
	//      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]
	// Production (1) of AsyncArrowFunctionExpression is parsed in "tryParseAsyncSimpleArrowFunctionExpression".
	// And production (2) is parsed in "tryParseParenthesizedArrowFunctionExpression".
	//
	// If we do successfully parse arrow-function, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is
	// not a LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done
	// with AssignmentExpression if we see one.
	arrowExpression := tryParseParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction) || tryParseAsyncSimpleArrowFunctionExpression(allowReturnTypeInArrowFunction)
	if arrowExpression {
		return arrowExpression
	}

	// Now try to see if we're in production '1', '2' or '3'.  A conditional expression can
	// start with a LogicalOrExpression, while the assignment productions can only start with
	// LeftHandSideExpressions.
	//
	// So, first, we try to just parse out a BinaryExpression.  If we get something that is a
	// LeftHandSide or higher, then we can try to parse out the assignment expression part.
	// Otherwise, we try to parse out the conditional expression bit.  We want to allow any
	// binary expression here, so we pass in the 'lowest' precedence here so that it matches
	// and consumes anything.
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	expr := parseBinaryExpressionOrHigher(OperatorPrecedenceLowest)

	// To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized
	// parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single
	// identifier and the current token is an arrow.
	if expr.kind == SyntaxKindIdentifier && token() == SyntaxKindEqualsGreaterThanToken {
		return parseSimpleArrowFunctionExpression(pos, expr.(Identifier), allowReturnTypeInArrowFunction, hasJSDoc /*asyncModifier*/, nil)
	}

	// Now see if we might be in cases '2' or '3'.
	// If the expression was a LHS expression, and we have an assignment operator, then
	// we're in '2' or '3'. Consume the assignment and return.
	//
	// Note: we call reScanGreaterToken so that we get an appropriately merged token
	// for cases like `> > =` becoming `>>=`
	if isLeftHandSideExpression(expr) && isAssignmentOperator(reScanGreaterToken()) {
		return makeBinaryExpression(expr, parseTokenNode(), parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction), pos)
	}

	// It wasn't an assignment or a lambda.  This is a conditional expression:
	return parseConditionalExpressionRest(expr, pos, allowReturnTypeInArrowFunction)
}

func isYieldExpression() bool {
	if token() == SyntaxKindYieldKeyword {
		// If we have a 'yield' keyword, and this is a context where yield expressions are
		// allowed, then definitely parse out a yield expression.
		if inYieldContext() {
			return true
		}

		// We're in a context where 'yield expr' is not allowed.  However, if we can
		// definitely tell that the user was trying to parse a 'yield expr' and not
		// just a normal expr that start with a 'yield' identifier, then parse out
		// a 'yield expr'.  We can then report an error later that they are only
		// allowed in generator expressions.
		//
		// for example, if we see 'yield(foo)', then we'll have to treat that as an
		// invocation expression of something called 'yield'.  However, if we have
		// 'yield foo' then that is not legal as a normal expression, so we can
		// definitely recognize this as a yield expression.
		//
		// for now we just check if the next token is an identifier.  More heuristics
		// can be added here later as necessary.  We just need to make sure that we
		// don't accidentally consume something legal.
		return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine)
	}

	return false
}

func nextTokenIsIdentifierOnSameLine() bool {
	nextToken()
	return !scanner.hasPrecedingLineBreak() && isIdentifier()
}

func parseYieldExpression() YieldExpression {
	pos := getNodePos()

	// YieldExpression[In] :
	//      yield
	//      yield [no LineTerminator here] [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]
	//      yield [no LineTerminator here] * [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]
	nextToken()

	if !scanner.hasPrecedingLineBreak() && (token() == SyntaxKindAsteriskToken || isStartOfExpression()) {
		return finishNode(factory.createYieldExpression(parseOptionalToken(SyntaxKindAsteriskToken), parseAssignmentExpressionOrHigher(true)), pos)
	} else {
		// if the next token is not on the same line as yield.  or we don't have an '*' or
		// the start of an expression, then this is just a simple "yield" expression.
		return finishNode(factory.createYieldExpression(nil /*expression*/, nil), pos)
	}
}

func parseSimpleArrowFunctionExpression(pos number, identifier Identifier, allowReturnTypeInArrowFunction bool, hasJSDoc bool, asyncModifier *NodeArray[Modifier]) ArrowFunction {
	Debug.assert(token() == SyntaxKindEqualsGreaterThanToken, "parseSimpleArrowFunctionExpression should only have been called if we had a =>")
	parameter := factory.createParameterDeclaration(nil, nil, identifier, nil, nil, nil)
	finishNode(parameter, identifier.pos)

	parameters := createNodeArray([]ParameterDeclaration{parameter}, parameter.pos, parameter.end)
	equalsGreaterThanToken := parseExpectedToken(SyntaxKindEqualsGreaterThanToken)
	body := parseArrowFunctionExpressionBody(!!asyncModifier, allowReturnTypeInArrowFunction)
	node := factory.createArrowFunction(asyncModifier /*typeParameters*/, nil, parameters /*type*/, nil, equalsGreaterThanToken, body)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func tryParseParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction bool) Expression {
	triState := isParenthesizedArrowFunctionExpression()
	if triState == TristateFalse {
		// It's definitely not a parenthesized arrow function expression.
		return nil
	}

	// If we definitely have an arrow function, then we can just parse one, not requiring a
	// following => or { token. Otherwise, we *might* have an arrow function.  Try to parse
	// it out, but don't allow any ambiguity, and return 'undefined' if this could be an
	// expression instead.
	if triState == TristateTrue {
		return parseParenthesizedArrowFunctionExpression(true /*allowReturnTypeInArrowFunction*/, true)
	} else {
		return tryParse(func() *ArrowFunction {
			return parsePossibleParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction)
		})
	}
}

// True        -> We definitely expect a parenthesized arrow function here.
// False       -> There *cannot* be a parenthesized arrow function here.
// Unknown     -> There *might* be a parenthesized arrow function here.
//
//	Speculatively look ahead to be sure, and rollback if not.
func isParenthesizedArrowFunctionExpression() Tristate {
	if token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken || token() == SyntaxKindAsyncKeyword {
		return lookAhead(isParenthesizedArrowFunctionExpressionWorker)
	}

	if token() == SyntaxKindEqualsGreaterThanToken {
		// ERROR RECOVERY TWEAK:
		// If we see a standalone => try to parse it as an arrow function expression as that's
		// likely what the user intended to write.
		return TristateTrue
	}
	// Definitely not a parenthesized arrow function.
	return TristateFalse
}

func isParenthesizedArrowFunctionExpressionWorker() Tristate {
	if token() == SyntaxKindAsyncKeyword {
		nextToken()
		if scanner.hasPrecedingLineBreak() {
			return TristateFalse
		}
		if token() != SyntaxKindOpenParenToken && token() != SyntaxKindLessThanToken {
			return TristateFalse
		}
	}

	first := token()
	second := nextToken()

	if first == SyntaxKindOpenParenToken {
		if second == SyntaxKindCloseParenToken {
			// Simple cases: "() =>", "(): ", and "() {".
			// This is an arrow function with no parameters.
			// The last one is not actually an arrow function,
			// but this is probably what the user intended.
			third := nextToken()
			switch third {
			case SyntaxKindEqualsGreaterThanToken,
				SyntaxKindColonToken,
				SyntaxKindOpenBraceToken:
				return TristateTrue
			default:
				return TristateFalse
			}
		}

		// If encounter "([" or "({", this could be the start of a binding pattern.
		// Examples:
		//      ([ x ]) => { }
		//      ({ x }) => { }
		//      ([ x ])
		//      ({ x })
		if second == SyntaxKindOpenBracketToken || second == SyntaxKindOpenBraceToken {
			return TristateUnknown
		}

		// Simple case: "(..."
		// This is an arrow function with a rest parameter.
		if second == SyntaxKindDotDotDotToken {
			return TristateTrue
		}

		// Check for "(xxx yyy", where xxx is a modifier and yyy is an identifier. This
		// isn't actually allowed, but we want to treat it as a lambda so we can provide
		// a good error message.
		if isModifierKind(second) && second != SyntaxKindAsyncKeyword && lookAhead(nextTokenIsIdentifier) {
			if nextToken() == SyntaxKindAsKeyword {
				// https://github.com/microsoft/TypeScript/issues/44466
				return TristateFalse
			}
			return TristateTrue
		}

		// If we had "(" followed by something that's not an identifier,
		// then this definitely doesn't look like a lambda.  "this" is not
		// valid, but we want to parse it and then give a semantic error.
		if !isIdentifier() && second != SyntaxKindThisKeyword {
			return TristateFalse
		}

		switch nextToken() {
		case SyntaxKindColonToken:
			// If we have something like "(a:", then we must have a
			// type-annotated parameter in an arrow function expression.
			return TristateTrue
		case SyntaxKindQuestionToken:
			nextToken()
			// If we have "(a?:" or "(a?," or "(a?=" or "(a?)" then it is definitely a lambda.
			if token() == SyntaxKindColonToken || token() == SyntaxKindCommaToken || token() == SyntaxKindEqualsToken || token() == SyntaxKindCloseParenToken {
				return TristateTrue
			}
			// Otherwise it is definitely not a lambda.
			return TristateFalse
		case SyntaxKindCommaToken,
			SyntaxKindEqualsToken,
			SyntaxKindCloseParenToken:
			// If we have "(a," or "(a=" or "(a)" this *could* be an arrow function
			return TristateUnknown
		}
		// It is definitely not an arrow function
		return TristateFalse
	} else {
		Debug.assert(first == SyntaxKindLessThanToken)

		// If we have "<" not followed by an identifier,
		// then this definitely is not an arrow function.
		if !isIdentifier() && token() != SyntaxKindConstKeyword {
			return TristateFalse
		}

		// JSX overrides
		if languageVariant == LanguageVariantJSX {
			isArrowFunctionInJsx := lookAhead(func() bool {
				parseOptional(SyntaxKindConstKeyword)
				third := nextToken()
				if third == SyntaxKindExtendsKeyword {
					fourth := nextToken()
					switch fourth {
					case SyntaxKindEqualsToken,
						SyntaxKindGreaterThanToken,
						SyntaxKindSlashToken:
						return false
					default:
						return true
					}
				} else if third == SyntaxKindCommaToken || third == SyntaxKindEqualsToken {
					return true
				}
				return false
			})

			if isArrowFunctionInJsx {
				return TristateTrue
			}

			return TristateFalse
		}

		// This *could* be a parenthesized arrow function.
		return TristateUnknown
	}
}

func parsePossibleParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction bool) *ArrowFunction {
	tokenPos := scanner.getTokenStart()
	if notParenthesizedArrow. /* ? */ has(tokenPos) {
		return nil
	}

	result := parseParenthesizedArrowFunctionExpression(false, allowReturnTypeInArrowFunction)
	if !result {
		(notParenthesizedArrow || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: notParenthesizedArrow = new Set() */ TODO)).add(tokenPos)
	}

	return result
}

func tryParseAsyncSimpleArrowFunctionExpression(allowReturnTypeInArrowFunction bool) *ArrowFunction {
	// We do a check here so that we won't be doing unnecessarily call to "lookAhead"
	if token() == SyntaxKindAsyncKeyword {
		if lookAhead(isUnParenthesizedAsyncArrowFunctionWorker) == TristateTrue {
			pos := getNodePos()
			hasJSDoc := hasPrecedingJSDocComment()
			asyncModifier := parseModifiersForArrowFunction()
			expr := parseBinaryExpressionOrHigher(OperatorPrecedenceLowest)
			return parseSimpleArrowFunctionExpression(pos, expr.(Identifier), allowReturnTypeInArrowFunction, hasJSDoc, asyncModifier)
		}
	}
	return nil
}

func isUnParenthesizedAsyncArrowFunctionWorker() Tristate {
	// AsyncArrowFunctionExpression:
	//      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]
	//      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]
	if token() == SyntaxKindAsyncKeyword {
		nextToken()
		// If the "async" is followed by "=>" token then it is not a beginning of an async arrow-function
		// but instead a simple arrow-function which will be parsed inside "parseAssignmentExpressionOrHigher"
		if scanner.hasPrecedingLineBreak() || token() == SyntaxKindEqualsGreaterThanToken {
			return TristateFalse
		}
		// Check for un-parenthesized AsyncArrowFunction
		expr := parseBinaryExpressionOrHigher(OperatorPrecedenceLowest)
		if !scanner.hasPrecedingLineBreak() && expr.kind == SyntaxKindIdentifier && token() == SyntaxKindEqualsGreaterThanToken {
			return TristateTrue
		}
	}

	return TristateFalse
}

func parseParenthesizedArrowFunctionExpression(allowAmbiguity bool, allowReturnTypeInArrowFunction bool) *ArrowFunction {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	modifiers := parseModifiersForArrowFunction()
	var isAsync /* TODO(TS-TO-GO) inferred type SignatureFlags.None | SignatureFlags.Await */ any
	if some(modifiers, isAsyncModifier) {
		isAsync = SignatureFlagsAwait
	} else {
		isAsync = SignatureFlagsNone
	}
	// Arrow functions are never generators.
	//
	// If we're speculatively parsing a signature for a parenthesized arrow function, then
	// we have to have a complete parameter list.  Otherwise we might see something like
	// a => (b => c)
	// And think that "(b =>" was actually a parenthesized arrow function with a missing
	// close paren.
	typeParameters := parseTypeParameters()

	var parameters NodeArray[ParameterDeclaration]
	if !parseExpected(SyntaxKindOpenParenToken) {
		if !allowAmbiguity {
			return nil
		}
		parameters = createMissingList()
	} else {
		if !allowAmbiguity {
			maybeParameters := parseParametersWorker(isAsync, allowAmbiguity)
			if !maybeParameters {
				return nil
			}
			parameters = maybeParameters
		} else {
			parameters = parseParametersWorker(isAsync, allowAmbiguity)
		}
		if !parseExpected(SyntaxKindCloseParenToken) && !allowAmbiguity {
			return nil
		}
	}

	hasReturnColon := token() == SyntaxKindColonToken
	type_ := parseReturnType(SyntaxKindColonToken /*isType*/, false)
	if type_ && !allowAmbiguity && typeHasArrowFunctionBlockingParseError(type_) {
		return nil
	}

	// Parsing a signature isn't enough.
	// Parenthesized arrow signatures often look like other valid expressions.
	// For instance:
	//  - "(x = 10)" is an assignment expression parsed as a signature with a default parameter value.
	//  - "(x,y)" is a comma expression parsed as a signature with two parameters.
	//  - "a ? (b): c" will have "(b):" parsed as a signature with a return type annotation.
	//  - "a ? (b): function() {}" will too, since function() is a valid JSDoc function type.
	//  - "a ? (b): (function() {})" as well, but inside of a parenthesized type with an arbitrary amount of nesting.
	//
	// So we need just a bit of lookahead to ensure that it can only be a signature.

	unwrappedType := type_
	for unwrappedType. /* ? */ kind == SyntaxKindParenthesizedType {
		unwrappedType = (unwrappedType.(ParenthesizedTypeNode)).type_
		// Skip parens if need be
	}

	hasJSDocFunctionType := unwrappedType && isJSDocFunctionType(unwrappedType)
	if !allowAmbiguity && token() != SyntaxKindEqualsGreaterThanToken && (hasJSDocFunctionType || token() != SyntaxKindOpenBraceToken) {
		// Returning undefined here will cause our caller to rewind to where we started from.
		return nil
	}

	// If we have an arrow, then try to parse the body. Even if not, try to parse if we
	// have an opening brace, just in case we're in an error state.
	lastToken := token()
	equalsGreaterThanToken := parseExpectedToken(SyntaxKindEqualsGreaterThanToken)
	var body /* TODO(TS-TO-GO) inferred type Expression | Block */ any
	if lastToken == SyntaxKindEqualsGreaterThanToken || lastToken == SyntaxKindOpenBraceToken {
		body = parseArrowFunctionExpressionBody(some(modifiers, isAsyncModifier), allowReturnTypeInArrowFunction)
	} else {
		body = parseIdentifier()
	}

	// Given:
	//     x ? y => ({ y }) : z => ({ z })
	// We try to parse the body of the first arrow function by looking at:
	//     ({ y }) : z => ({ z })
	// This is a valid arrow function with "z" as the return type.
	//
	// But, if we're in the true side of a conditional expression, this colon
	// terminates the expression, so we cannot allow a return type if we aren't
	// certain whether or not the preceding text was parsed as a parameter list.
	//
	// For example,
	//     a() ? (b: number, c?: string): void => d() : e
	// is determined by isParenthesizedArrowFunctionExpression to unambiguously
	// be an arrow expression, so we allow a return type.
	if !allowReturnTypeInArrowFunction && hasReturnColon {
		// However, if the arrow function we were able to parse is followed by another colon
		// as in:
		//     a ? (x): string => x : null
		// Then allow the arrow function, and treat the second colon as terminating
		// the conditional expression. It's okay to do this because this code would
		// be a syntax error in JavaScript (as the second colon shouldn't be there).
		if token() != SyntaxKindColonToken {
			return nil
		}
	}

	node := factory.createArrowFunction(modifiers, typeParameters, parameters, type_, equalsGreaterThanToken, body)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseArrowFunctionExpressionBody(isAsync bool, allowReturnTypeInArrowFunction bool) /* TODO(TS-TO-GO) TypeNode UnionType: Block | Expression */ any {
	if token() == SyntaxKindOpenBraceToken {
		return parseFunctionBlock(ifelse(isAsync, SignatureFlagsAwait, SignatureFlagsNone))
	}

	if token() != SyntaxKindSemicolonToken && token() != SyntaxKindFunctionKeyword && token() != SyntaxKindClassKeyword && isStartOfStatement() && !isStartOfExpressionStatement() {
		// Check if we got a plain statement (i.e. no expression-statements, no function/class expressions/declarations)
		//
		// Here we try to recover from a potential error situation in the case where the
		// user meant to supply a block. For example, if the user wrote:
		//
		//  a =>
		//      let v = 0;
		//  }
		//
		// they may be missing an open brace.  Check to see if that's the case so we can
		// try to recover better.  If we don't do this, then the next close curly we see may end
		// up preemptively closing the containing construct.
		//
		// Note: even when 'IgnoreMissingOpenBrace' is passed, parseBody will still error.
		return parseFunctionBlock(SignatureFlagsIgnoreMissingOpenBrace | (ifelse(isAsync, SignatureFlagsAwait, SignatureFlagsNone)))
	}

	savedTopLevel := topLevel
	topLevel = false
	var node Expression
	if isAsync {
		node = doInAwaitContext(func() Expression {
			return parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction)
		})
	} else {
		node = doOutsideOfAwaitContext(func() Expression {
			return parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction)
		})
	}
	topLevel = savedTopLevel
	return node
}

func parseConditionalExpressionRest(leftOperand Expression, pos number, allowReturnTypeInArrowFunction bool) Expression {
	// Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.
	questionToken := parseOptionalToken(SyntaxKindQuestionToken)
	if !questionToken {
		return leftOperand
	}

	// Note: we explicitly 'allowIn' in the whenTrue part of the condition expression, and
	// we do not that for the 'whenFalse' part.
	var colonToken TODO
	return finishNode(factory.createConditionalExpression(leftOperand, questionToken, doOutsideOfContext(disallowInAndDecoratorContext, func() Expression {
		return parseAssignmentExpressionOrHigher(false)
	}), /* TODO(TS-TO-GO) EqualsToken BinaryExpression: colonToken = parseExpectedToken(SyntaxKind.ColonToken) */ TODO, ifelse(nodeIsPresent(colonToken), parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction), createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, false, Diagnostics._0_expected, tokenToString(SyntaxKindColonToken)))), pos)
}

func parseBinaryExpressionOrHigher(precedence OperatorPrecedence) Expression {
	pos := getNodePos()
	leftOperand := parseUnaryExpressionOrHigher()
	return parseBinaryExpressionRest(precedence, leftOperand, pos)
}

func isInOrOfKeyword(t SyntaxKind) bool {
	return t == SyntaxKindInKeyword || t == SyntaxKindOfKeyword
}

func parseBinaryExpressionRest(precedence OperatorPrecedence, leftOperand Expression, pos number) Expression {
	for true {
		// We either have a binary operator here, or we're finished.  We call
		// reScanGreaterToken so that we merge token sequences like > and = into >=

		reScanGreaterToken()
		newPrecedence := getBinaryOperatorPrecedence(token())

		// Check the precedence to see if we should "take" this operator
		// - For left associative operator (all operator but **), consume the operator,
		//   recursively call the function below, and parse binaryExpression as a rightOperand
		//   of the caller if the new precedence of the operator is greater then or equal to the current precedence.
		//   For example:
		//      a - b - c;
		//            ^token; leftOperand = b. Return b to the caller as a rightOperand
		//      a * b - c
		//            ^token; leftOperand = b. Return b to the caller as a rightOperand
		//      a - b * c;
		//            ^token; leftOperand = b. Return b * c to the caller as a rightOperand
		// - For right associative operator (**), consume the operator, recursively call the function
		//   and parse binaryExpression as a rightOperand of the caller if the new precedence of
		//   the operator is strictly grater than the current precedence
		//   For example:
		//      a ** b ** c;
		//             ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand
		//      a - b ** c;
		//            ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand
		//      a ** b - c
		//             ^token; leftOperand = b. Return b to the caller as a rightOperand
		var consumeCurrentOperator bool
		if token() == SyntaxKindAsteriskAsteriskToken {
			consumeCurrentOperator = newPrecedence >= precedence
		} else {
			consumeCurrentOperator = newPrecedence > precedence
		}

		if !consumeCurrentOperator {
			break
		}

		if token() == SyntaxKindInKeyword && inDisallowInContext() {
			break
		}

		if token() == SyntaxKindAsKeyword || token() == SyntaxKindSatisfiesKeyword {
			// Make sure we *do* perform ASI for constructs like this:
			//    var x = foo
			//    as (Bar)
			// This should be parsed as an initialized variable, followed
			// by a function call to 'as' with the argument 'Bar'
			if scanner.hasPrecedingLineBreak() {
				break
			} else {
				keywordKind := token()
				nextToken()
				if keywordKind == SyntaxKindSatisfiesKeyword {
					leftOperand = makeSatisfiesExpression(leftOperand, parseType())
				} else {
					leftOperand = makeAsExpression(leftOperand, parseType())
				}
			}
		} else {
			leftOperand = makeBinaryExpression(leftOperand, parseTokenNode(), parseBinaryExpressionOrHigher(newPrecedence), pos)
		}
	}

	return leftOperand
}

func isBinaryOperator() bool {
	if inDisallowInContext() && token() == SyntaxKindInKeyword {
		return false
	}

	return getBinaryOperatorPrecedence(token()) > 0
}

func makeSatisfiesExpression(left Expression, right TypeNode) SatisfiesExpression {
	return finishNode(factory.createSatisfiesExpression(left, right), left.pos)
}

func makeBinaryExpression(left Expression, operatorToken BinaryOperatorToken, right Expression, pos number) BinaryExpression {
	return finishNode(factory.createBinaryExpression(left, operatorToken, right), pos)
}

func makeAsExpression(left Expression, right TypeNode) AsExpression {
	return finishNode(factory.createAsExpression(left, right), left.pos)
}

func parsePrefixUnaryExpression() PrefixUnaryExpression {
	pos := getNodePos()
	return finishNode(factory.createPrefixUnaryExpression(token().(PrefixUnaryOperator), nextTokenAnd(parseSimpleUnaryExpression)), pos)
}

func parseDeleteExpression() DeleteExpression {
	pos := getNodePos()
	return finishNode(factory.createDeleteExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos)
}

func parseTypeOfExpression() TypeOfExpression {
	pos := getNodePos()
	return finishNode(factory.createTypeOfExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos)
}

func parseVoidExpression() VoidExpression {
	pos := getNodePos()
	return finishNode(factory.createVoidExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos)
}

func isAwaitExpression() bool {
	if token() == SyntaxKindAwaitKeyword {
		if inAwaitContext() {
			return true
		}

		// here we are using similar heuristics as 'isYieldExpression'
		return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine)
	}

	return false
}

func parseAwaitExpression() AwaitExpression {
	pos := getNodePos()
	return finishNode(factory.createAwaitExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos)
}

/**
 * Parse ES7 exponential expression and await expression
 *
 * ES7 ExponentiationExpression:
 *      1) UnaryExpression[?Yield]
 *      2) UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
 */

func parseUnaryExpressionOrHigher() /* TODO(TS-TO-GO) TypeNode UnionType: UnaryExpression | BinaryExpression */ any {
	/**
	 * ES7 UpdateExpression:
	 *      1) LeftHandSideExpression[?Yield]
	 *      2) LeftHandSideExpression[?Yield][no LineTerminator here]++
	 *      3) LeftHandSideExpression[?Yield][no LineTerminator here]--
	 *      4) ++UnaryExpression[?Yield]
	 *      5) --UnaryExpression[?Yield]
	 */
	if isUpdateExpression() {
		pos := getNodePos()
		updateExpression := parseUpdateExpression()
		if token() == SyntaxKindAsteriskAsteriskToken {
			return parseBinaryExpressionRest(getBinaryOperatorPrecedence(token()), updateExpression, pos).(BinaryExpression)
		} else {
			return updateExpression
		}
	}
	/**
	 * ES7 UnaryExpression:
	 *      1) UpdateExpression[?yield]
	 *      2) delete UpdateExpression[?yield]
	 *      3) void UpdateExpression[?yield]
	 *      4) typeof UpdateExpression[?yield]
	 *      5) + UpdateExpression[?yield]
	 *      6) - UpdateExpression[?yield]
	 *      7) ~ UpdateExpression[?yield]
	 *      8) ! UpdateExpression[?yield]
	 */

	unaryOperator := token()
	simpleUnaryExpression := parseSimpleUnaryExpression()
	if token() == SyntaxKindAsteriskAsteriskToken {
		pos := skipTrivia(sourceText, simpleUnaryExpression.pos)
		TODO_IDENTIFIER := simpleUnaryExpression
		if simpleUnaryExpression.kind == SyntaxKindTypeAssertionExpression {
			parseErrorAt(pos, end, Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses)
		} else {
			Debug.assert(isKeywordOrPunctuation(unaryOperator))
			parseErrorAt(pos, end, Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, tokenToString(unaryOperator))
		}
	}
	return simpleUnaryExpression
}

/**
 * Parse ES7 simple-unary expression or higher:
 *
 * ES7 UnaryExpression:
 *      1) UpdateExpression[?yield]
 *      2) delete UnaryExpression[?yield]
 *      3) void UnaryExpression[?yield]
 *      4) typeof UnaryExpression[?yield]
 *      5) + UnaryExpression[?yield]
 *      6) - UnaryExpression[?yield]
 *      7) ~ UnaryExpression[?yield]
 *      8) ! UnaryExpression[?yield]
 *      9) [+Await] await UnaryExpression[?yield]
 */

func parseSimpleUnaryExpression() UnaryExpression {
	switch token() {
	case SyntaxKindPlusToken,
		SyntaxKindMinusToken,
		SyntaxKindTildeToken,
		SyntaxKindExclamationToken:
		return parsePrefixUnaryExpression()
	case SyntaxKindDeleteKeyword:
		return parseDeleteExpression()
	case SyntaxKindTypeOfKeyword:
		return parseTypeOfExpression()
	case SyntaxKindVoidKeyword:
		return parseVoidExpression()
	case SyntaxKindLessThanToken:
		// Just like in parseUpdateExpression, we need to avoid parsing type assertions when
		// in JSX and we see an expression like "+ <foo> bar".
		if languageVariant == LanguageVariantJSX {
			return parseJsxElementOrSelfClosingElementOrFragment(true /*topInvalidNodePosition*/, nil /*openingTag*/, nil /*mustBeUnary*/, true)
		}
		// This is modified UnaryExpression grammar in TypeScript
		//  UnaryExpression (modified):
		//      < type > UnaryExpression
		return parseTypeAssertion()
	case SyntaxKindAwaitKeyword:
		if isAwaitExpression() {
			return parseAwaitExpression()
		}
		fallthrough
	default:
		return parseUpdateExpression()
	}
}

/**
 * Check if the current token can possibly be an ES7 increment expression.
 *
 * ES7 UpdateExpression:
 *      LeftHandSideExpression[?Yield]
 *      LeftHandSideExpression[?Yield][no LineTerminator here]++
 *      LeftHandSideExpression[?Yield][no LineTerminator here]--
 *      ++LeftHandSideExpression[?Yield]
 *      --LeftHandSideExpression[?Yield]
 */

func isUpdateExpression() bool {
	// This function is called inside parseUnaryExpression to decide
	// whether to call parseSimpleUnaryExpression or call parseUpdateExpression directly
	switch token() {
	case SyntaxKindPlusToken,
		SyntaxKindMinusToken,
		SyntaxKindTildeToken,
		SyntaxKindExclamationToken,
		SyntaxKindDeleteKeyword,
		SyntaxKindTypeOfKeyword,
		SyntaxKindVoidKeyword,
		SyntaxKindAwaitKeyword:
		return false
	case SyntaxKindLessThanToken:
		// If we are not in JSX context, we are parsing TypeAssertion which is an UnaryExpression
		if languageVariant != LanguageVariantJSX {
			return false
		}
		// We are in JSX context and the token is part of JSXElement.
		fallthrough
	default:
		return true
	}
}

/**
 * Parse ES7 UpdateExpression. UpdateExpression is used instead of ES6's PostFixExpression.
 *
 * ES7 UpdateExpression[yield]:
 *      1) LeftHandSideExpression[?yield]
 *      2) LeftHandSideExpression[?yield] [[no LineTerminator here]]++
 *      3) LeftHandSideExpression[?yield] [[no LineTerminator here]]--
 *      4) ++LeftHandSideExpression[?yield]
 *      5) --LeftHandSideExpression[?yield]
 * In TypeScript (2), (3) are parsed as PostfixUnaryExpression. (4), (5) are parsed as PrefixUnaryExpression
 */

func parseUpdateExpression() UpdateExpression {
	if token() == SyntaxKindPlusPlusToken || token() == SyntaxKindMinusMinusToken {
		pos := getNodePos()
		return finishNode(factory.createPrefixUnaryExpression(token().(PrefixUnaryOperator), nextTokenAnd(parseLeftHandSideExpressionOrHigher)), pos)
	} else if languageVariant == LanguageVariantJSX && token() == SyntaxKindLessThanToken && lookAhead(nextTokenIsIdentifierOrKeywordOrGreaterThan) {
		// JSXElement is part of primaryExpression
		return parseJsxElementOrSelfClosingElementOrFragment(true)
	}

	expression := parseLeftHandSideExpressionOrHigher()

	Debug.assert(isLeftHandSideExpression(expression))
	if (token() == SyntaxKindPlusPlusToken || token() == SyntaxKindMinusMinusToken) && !scanner.hasPrecedingLineBreak() {
		operator := token().(PostfixUnaryOperator)
		nextToken()
		return finishNode(factory.createPostfixUnaryExpression(expression, operator), expression.pos)
	}

	return expression
}

func parseLeftHandSideExpressionOrHigher() LeftHandSideExpression {
	// Original Ecma:
	// LeftHandSideExpression: See 11.2
	//      NewExpression
	//      CallExpression
	//
	// Our simplification:
	//
	// LeftHandSideExpression: See 11.2
	//      MemberExpression
	//      CallExpression
	//
	// See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with
	// MemberExpression to make our lives easier.
	//
	// to best understand the below code, it's important to see how CallExpression expands
	// out into its own productions:
	//
	// CallExpression:
	//      MemberExpression Arguments
	//      CallExpression Arguments
	//      CallExpression[Expression]
	//      CallExpression.IdentifierName
	//      import (AssignmentExpression)
	//      super Arguments
	//      super.IdentifierName
	//
	// Because of the recursion in these calls, we need to bottom out first. There are three
	// bottom out states we can run into: 1) We see 'super' which must start either of
	// the last two CallExpression productions. 2) We see 'import' which must start import call.
	// 3)we have a MemberExpression which either completes the LeftHandSideExpression,
	// or starts the beginning of the first four CallExpression productions.
	pos := getNodePos()
	var expression MemberExpression
	if token() == SyntaxKindImportKeyword {
		if lookAhead(nextTokenIsOpenParenOrLessThan) {
			// We don't want to eagerly consume all import keyword as import call expression so we look ahead to find "("
			// For example:
			//      var foo3 = require("subfolder
			//      import * as foo1 from "module-from-node
			// We want this import to be a statement rather than import call expression
			sourceFlags |= NodeFlagsPossiblyContainsDynamicImport
			expression = parseTokenNode()
		} else if lookAhead(nextTokenIsDot) {
			// This is an 'import.*' metaproperty (i.e. 'import.meta')
			nextToken()
			// advance past the 'import'
			nextToken()
			// advance past the dot
			expression = finishNode(factory.createMetaProperty(SyntaxKindImportKeyword, parseIdentifierName()), pos)
			sourceFlags |= NodeFlagsPossiblyContainsImportMeta
		} else {
			expression = parseMemberExpressionOrHigher()
		}
	} else {
		if token() == SyntaxKindSuperKeyword {
			expression = parseSuperExpression()
		} else {
			expression = parseMemberExpressionOrHigher()
		}
	}

	// Now, we *may* be complete.  However, we might have consumed the start of a
	// CallExpression or OptionalExpression.  As such, we need to consume the rest
	// of it here to be complete.
	return parseCallExpressionRest(pos, expression)
}

func parseMemberExpressionOrHigher() MemberExpression {
	// Note: to make our lives simpler, we decompose the NewExpression productions and
	// place ObjectCreationExpression and FunctionExpression into PrimaryExpression.
	// like so:
	//
	//   PrimaryExpression : See 11.1
	//      this
	//      Identifier
	//      Literal
	//      ArrayLiteral
	//      ObjectLiteral
	//      (Expression)
	//      FunctionExpression
	//      new MemberExpression Arguments?
	//
	//   MemberExpression : See 11.2
	//      PrimaryExpression
	//      MemberExpression[Expression]
	//      MemberExpression.IdentifierName
	//
	//   CallExpression : See 11.2
	//      MemberExpression
	//      CallExpression Arguments
	//      CallExpression[Expression]
	//      CallExpression.IdentifierName
	//
	// Technically this is ambiguous.  i.e. CallExpression defines:
	//
	//   CallExpression:
	//      CallExpression Arguments
	//
	// If you see: "new Foo()"
	//
	// Then that could be treated as a single ObjectCreationExpression, or it could be
	// treated as the invocation of "new Foo".  We disambiguate that in code (to match
	// the original grammar) by making sure that if we see an ObjectCreationExpression
	// we always consume arguments if they are there. So we treat "new Foo()" as an
	// object creation only, and not at all as an invocation.  Another way to think
	// about this is that for every "new" that we see, we will consume an argument list if
	// it is there as part of the *associated* object creation node.  Any additional
	// argument lists we see, will become invocation expressions.
	//
	// Because there are no other places in the grammar now that refer to FunctionExpression
	// or ObjectCreationExpression, it is safe to push down into the PrimaryExpression
	// production.
	//
	// Because CallExpression and MemberExpression are left recursive, we need to bottom out
	// of the recursion immediately.  So we parse out a primary expression to start with.
	pos := getNodePos()
	expression := parsePrimaryExpression()
	return parseMemberExpressionRest(pos, expression /*allowOptionalChain*/, true)
}

func parseSuperExpression() MemberExpression {
	pos := getNodePos()
	expression := parseTokenNode()
	if token() == SyntaxKindLessThanToken {
		startPos := getNodePos()
		typeArguments := tryParse(parseTypeArgumentsInExpression)
		if typeArguments != nil {
			parseErrorAt(startPos, getNodePos(), Diagnostics.super_may_not_use_type_arguments)
			if !isTemplateStartOfTaggedTemplate() {
				expression = factory.createExpressionWithTypeArguments(expression, typeArguments)
			}
		}
	}

	if token() == SyntaxKindOpenParenToken || token() == SyntaxKindDotToken || token() == SyntaxKindOpenBracketToken {
		return expression
	}

	// If we have seen "super" it must be followed by '(' or '.'.
	// If it wasn't then just try to parse out a '.' and report an error.
	parseExpectedToken(SyntaxKindDotToken, Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access)
	// private names will never work with `super` (`super.#foo`), but that's a semantic error, not syntactic
	return finishNode(factoryCreatePropertyAccessExpression(expression, parseRightSideOfDot(true /*allowPrivateIdentifiers*/, true /*allowUnicodeEscapeSequenceInIdentifierName*/, true)), pos)
}

func parseJsxElementOrSelfClosingElementOrFragment(inExpressionContext bool, topInvalidNodePosition number, openingTag /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningElement | JsxOpeningFragment */ any, mustBeUnary bool /*  = false */) /* TODO(TS-TO-GO) TypeNode UnionType: JsxElement | JsxSelfClosingElement | JsxFragment */ any {
	pos := getNodePos()
	opening := parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext)
	var result /* TODO(TS-TO-GO) TypeNode UnionType: JsxElement | JsxSelfClosingElement | JsxFragment */ any
	if opening.kind == SyntaxKindJsxOpeningElement {
		children := parseJsxChildren(opening)
		var closingElement JsxClosingElement

		var lastChild *JsxChild = children[children.length-1]
		if lastChild. /* ? */ kind == SyntaxKindJsxElement && !tagNamesAreEquivalent(lastChild.openingElement.tagName, lastChild.closingElement.tagName) && tagNamesAreEquivalent(opening.tagName, lastChild.closingElement.tagName) {
			// when an unclosed JsxOpeningElement incorrectly parses its parent's JsxClosingElement,
			// restructure (<div>(...<span>...</div>)) --> (<div>(...<span>...</>)</div>)
			// (no need to error; the parent will error)
			end := lastChild.children.end
			newLast := finishNode(factory.createJsxElement(lastChild.openingElement, lastChild.children, finishNode(factory.createJsxClosingElement(finishNode(factoryCreateIdentifier(""), end, end)), end, end)), lastChild.openingElement.pos, end)

			children = createNodeArray([]JsxChild{ /* TODO(TS-TO-GO) Node SpreadElement: ...children.slice(0, children.length - 1) */ newLast}, children.pos, end)
			closingElement = lastChild.closingElement
		} else {
			closingElement = parseJsxClosingElement(opening, inExpressionContext)
			if !tagNamesAreEquivalent(opening.tagName, closingElement.tagName) {
				if openingTag && isJsxOpeningElement(openingTag) && tagNamesAreEquivalent(closingElement.tagName, openingTag.tagName) {
					// opening incorrectly matched with its parent's closing -- put error on opening
					parseErrorAtRange(opening.tagName, Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, getTextOfNodeFromSourceText(sourceText, opening.tagName))
				} else {
					// other opening/closing mismatches -- put error on closing
					parseErrorAtRange(closingElement.tagName, Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, getTextOfNodeFromSourceText(sourceText, opening.tagName))
				}
			}
		}
		result = finishNode(factory.createJsxElement(opening, children, closingElement), pos)
	} else if opening.kind == SyntaxKindJsxOpeningFragment {
		result = finishNode(factory.createJsxFragment(opening, parseJsxChildren(opening), parseJsxClosingFragment(inExpressionContext)), pos)
	} else {
		Debug.assert(opening.kind == SyntaxKindJsxSelfClosingElement)
		// Nothing else to do for self-closing elements
		result = opening
	}

	// If the user writes the invalid code '<div></div><div></div>' in an expression context (i.e. not wrapped in
	// an enclosing tag), we'll naively try to parse   ^ this as a 'less than' operator and the remainder of the tag
	// as garbage, which will cause the formatter to badly mangle the JSX. Perform a speculative parse of a JSX
	// element if we see a < token so that we can wrap it in a synthetic binary expression so the formatter
	// does less damage and we can report a better error.
	// Since JSX elements are invalid < operands anyway, this lookahead parse will only occur in error scenarios
	// of one sort or another.
	// If we are in a unary context, we can't do this recovery; the binary expression we return here is not
	// a valid UnaryExpression and will cause problems later.
	if !mustBeUnary && inExpressionContext && token() == SyntaxKindLessThanToken {
		var topBadPos number
		if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof topInvalidNodePosition */ TODO == "undefined" {
			topBadPos = result.pos
		} else {
			topBadPos = topInvalidNodePosition
		}
		invalidElement := tryParse(func() /* TODO(TS-TO-GO) inferred type JsxElement | JsxSelfClosingElement | JsxFragment */ any {
			return parseJsxElementOrSelfClosingElementOrFragment(true, topBadPos)
		})
		if invalidElement {
			operatorToken := createMissingNode(SyntaxKindCommaToken /*reportAtCurrentPosition*/, false)
			setTextRangePosWidth(operatorToken, invalidElement.pos, 0)
			parseErrorAt(skipTrivia(sourceText, topBadPos), invalidElement.end, Diagnostics.JSX_expressions_must_have_one_parent_element)
			return finishNode(factory.createBinaryExpression(result, operatorToken.(Token[ /* TODO(TS-TO-GO) Node QualifiedName: SyntaxKind.CommaToken */ any]), invalidElement), pos).(Node).(JsxElement)
		}
	}

	return result
}

func parseJsxText() JsxText {
	pos := getNodePos()
	node := factory.createJsxText(scanner.getTokenValue(), currentToken == SyntaxKindJsxTextAllWhiteSpaces)
	currentToken = scanner.scanJsxToken()
	return finishNode(node, pos)
}

func parseJsxChild(openingTag /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningElement | JsxOpeningFragment */ any, token JsxTokenSyntaxKind) *JsxChild {
	switch token {
	case SyntaxKindEndOfFileToken:
		// If we hit EOF, issue the error at the tag that lacks the closing element
		// rather than at the end of the file (which is useless)
		if isJsxOpeningFragment(openingTag) {
			parseErrorAtRange(openingTag, Diagnostics.JSX_fragment_has_no_corresponding_closing_tag)
		} else {
			// We want the error span to cover only 'Foo.Bar' in < Foo.Bar >
			// or to cover only 'Foo' in < Foo >
			tag := openingTag.tagName
			start := min(skipTrivia(sourceText, tag.pos), tag.end)
			parseErrorAt(start, tag.end, Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, getTextOfNodeFromSourceText(sourceText, openingTag.tagName))
		}
		return nil
	case SyntaxKindLessThanSlashToken,
		SyntaxKindConflictMarkerTrivia:
		return nil
	case SyntaxKindJsxText,
		SyntaxKindJsxTextAllWhiteSpaces:
		return parseJsxText()
	case SyntaxKindOpenBraceToken:
		return parseJsxExpression(false)
	case SyntaxKindLessThanToken:
		return parseJsxElementOrSelfClosingElementOrFragment(false /*topInvalidNodePosition*/, nil, openingTag)
	default:
		return Debug.assertNever(token)
	}
}

func parseJsxChildren(openingTag /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningElement | JsxOpeningFragment */ any) NodeArray[JsxChild] {
	list := []never{}
	listPos := getNodePos()
	saveParsingContext := parsingContext
	parsingContext |= /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: 1 << ParsingContext.JsxChildren */ TODO

	for true {
		child := parseJsxChild(openingTag /* TODO(TS-TO-GO) EqualsToken BinaryExpression: currentToken = scanner.reScanJsxToken() */, TODO)
		if !child {
			break
		}
		list.push(child)
		if isJsxOpeningElement(openingTag) && child. /* ? */ kind == SyntaxKindJsxElement && !tagNamesAreEquivalent(child.openingElement.tagName, child.closingElement.tagName) && tagNamesAreEquivalent(openingTag.tagName, child.closingElement.tagName) {
			// stop after parsing a mismatched child like <div>...(<span></div>) in order to reattach the </div> higher
			break
		}
	}

	parsingContext = saveParsingContext
	return createNodeArray(list, listPos)
}

func parseJsxAttributes() JsxAttributes {
	pos := getNodePos()
	return finishNode(factory.createJsxAttributes(parseList(ParsingContextJsxAttributes, parseJsxAttribute)), pos)
}

func parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext bool) /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningElement | JsxSelfClosingElement | JsxOpeningFragment */ any {
	pos := getNodePos()

	parseExpected(SyntaxKindLessThanToken)

	if token() == SyntaxKindGreaterThanToken {
		// See below for explanation of scanJsxText
		scanJsxText()
		return finishNode(factory.createJsxOpeningFragment(), pos)
	}
	tagName := parseJsxElementName()
	var typeArguments *NodeArray[TypeNode]
	if (contextFlags & NodeFlagsJavaScriptFile) == 0 {
		typeArguments = tryParseTypeArguments()
	} else {
		typeArguments = nil
	}
	attributes := parseJsxAttributes()

	var node JsxOpeningLikeElement

	if token() == SyntaxKindGreaterThanToken {
		// Closing tag, so scan the immediately-following text with the JSX scanning instead
		// of regular scanning to avoid treating illegal characters (e.g. '#') as immediate
		// scanning errors
		scanJsxText()
		node = factory.createJsxOpeningElement(tagName, typeArguments, attributes)
	} else {
		parseExpected(SyntaxKindSlashToken)
		if parseExpected(SyntaxKindGreaterThanToken /*diagnosticMessage*/, nil /*shouldAdvance*/, false) {
			// manually advance the scanner in order to look for jsx text inside jsx
			if inExpressionContext {
				nextToken()
			} else {
				scanJsxText()
			}
		}
		node = factory.createJsxSelfClosingElement(tagName, typeArguments, attributes)
	}

	return finishNode(node, pos)
}

func parseJsxElementName() JsxTagNameExpression {
	pos := getNodePos()
	// JsxElement can have name in the form of
	//      propertyAccessExpression
	//      primaryExpression in the form of an identifier and "this" keyword
	// We can't just simply use parseLeftHandSideExpressionOrHigher because then we will start consider class,function etc as a keyword
	// We only want to consider "this" as a primaryExpression
	initialExpression := parseJsxTagName()
	if isJsxNamespacedName(initialExpression) {
		return initialExpression
		// `a:b.c` is invalid syntax, don't even look for the `.` if we parse `a:b`, and let `parseAttribute` report "unexpected :" instead.
	}
	var expression /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | Identifier | ThisExpression */ any = initialExpression
	for parseOptional(SyntaxKindDotToken) {
		expression = finishNode(factoryCreatePropertyAccessExpression(expression, parseRightSideOfDot(true /*allowPrivateIdentifiers*/, false /*allowUnicodeEscapeSequenceInIdentifierName*/, false)), pos)
	}
	return expression.(JsxTagNameExpression)
}

func parseJsxTagName() /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | JsxNamespacedName | ThisExpression */ any {
	pos := getNodePos()
	scanJsxIdentifier()

	isThis := token() == SyntaxKindThisKeyword
	tagName := parseIdentifierNameErrorOnUnicodeEscapeSequence()
	if parseOptional(SyntaxKindColonToken) {
		scanJsxIdentifier()
		return finishNode(factory.createJsxNamespacedName(tagName, parseIdentifierNameErrorOnUnicodeEscapeSequence()), pos)
	}
	if isThis {
		return finishNode(factory.createToken(SyntaxKindThisKeyword), pos)
	} else {
		return tagName
	}
}

func parseJsxExpression(inExpressionContext bool) *JsxExpression {
	pos := getNodePos()
	if !parseExpected(SyntaxKindOpenBraceToken) {
		return nil
	}

	var dotDotDotToken *DotDotDotToken
	var expression Expression
	if token() != SyntaxKindCloseBraceToken {
		if !inExpressionContext {
			dotDotDotToken = parseOptionalToken(SyntaxKindDotDotDotToken)
		}
		// Only an AssignmentExpression is valid here per the JSX spec,
		// but we can unambiguously parse a comma sequence and provide
		// a better error message in grammar checking.
		expression = parseExpression()
	}
	if inExpressionContext {
		parseExpected(SyntaxKindCloseBraceToken)
	} else {
		if parseExpected(SyntaxKindCloseBraceToken /*diagnosticMessage*/, nil /*shouldAdvance*/, false) {
			scanJsxText()
		}
	}

	return finishNode(factory.createJsxExpression(dotDotDotToken, expression), pos)
}

func parseJsxAttribute() /* TODO(TS-TO-GO) TypeNode UnionType: JsxAttribute | JsxSpreadAttribute */ any {
	if token() == SyntaxKindOpenBraceToken {
		return parseJsxSpreadAttribute()
	}

	pos := getNodePos()
	return finishNode(factory.createJsxAttribute(parseJsxAttributeName(), parseJsxAttributeValue()), pos)
}

func parseJsxAttributeValue() *JsxAttributeValue {
	if token() == SyntaxKindEqualsToken {
		if scanJsxAttributeValue() == SyntaxKindStringLiteral {
			return parseLiteralNode().(StringLiteral)
		}
		if token() == SyntaxKindOpenBraceToken {
			return parseJsxExpression(true)
		}
		if token() == SyntaxKindLessThanToken {
			return parseJsxElementOrSelfClosingElementOrFragment(true)
		}
		parseErrorAtCurrentToken(Diagnostics.or_JSX_element_expected)
	}
	return nil
}

func parseJsxAttributeName() /* TODO(TS-TO-GO) inferred type Identifier | JsxNamespacedName */ any {
	pos := getNodePos()
	scanJsxIdentifier()

	attrName := parseIdentifierNameErrorOnUnicodeEscapeSequence()
	if parseOptional(SyntaxKindColonToken) {
		scanJsxIdentifier()
		return finishNode(factory.createJsxNamespacedName(attrName, parseIdentifierNameErrorOnUnicodeEscapeSequence()), pos)
	}
	return attrName
}

func parseJsxSpreadAttribute() JsxSpreadAttribute {
	pos := getNodePos()
	parseExpected(SyntaxKindOpenBraceToken)
	parseExpected(SyntaxKindDotDotDotToken)
	expression := parseExpression()
	parseExpected(SyntaxKindCloseBraceToken)
	return finishNode(factory.createJsxSpreadAttribute(expression), pos)
}

func parseJsxClosingElement(open JsxOpeningElement, inExpressionContext bool) JsxClosingElement {
	pos := getNodePos()
	parseExpected(SyntaxKindLessThanSlashToken)
	tagName := parseJsxElementName()
	if parseExpected(SyntaxKindGreaterThanToken /*diagnosticMessage*/, nil /*shouldAdvance*/, false) {
		// manually advance the scanner in order to look for jsx text inside jsx
		if inExpressionContext || !tagNamesAreEquivalent(open.tagName, tagName) {
			nextToken()
		} else {
			scanJsxText()
		}
	}
	return finishNode(factory.createJsxClosingElement(tagName), pos)
}

func parseJsxClosingFragment(inExpressionContext bool) JsxClosingFragment {
	pos := getNodePos()
	parseExpected(SyntaxKindLessThanSlashToken)
	if parseExpected(SyntaxKindGreaterThanToken, Diagnostics.Expected_corresponding_closing_tag_for_JSX_fragment /*shouldAdvance*/, false) {
		// manually advance the scanner in order to look for jsx text inside jsx
		if inExpressionContext {
			nextToken()
		} else {
			scanJsxText()
		}
	}
	return finishNode(factory.createJsxJsxClosingFragment(), pos)
}

func parseTypeAssertion() TypeAssertion {
	Debug.assert(languageVariant != LanguageVariantJSX, "Type assertions should never be parsed in JSX; they should be parsed as comparisons or JSX elements/fragments.")
	pos := getNodePos()
	parseExpected(SyntaxKindLessThanToken)
	type_ := parseType()
	parseExpected(SyntaxKindGreaterThanToken)
	expression := parseSimpleUnaryExpression()
	return finishNode(factory.createTypeAssertion(type_, expression), pos)
}

func nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate() bool {
	nextToken()
	return tokenIsIdentifierOrKeyword(token()) || token() == SyntaxKindOpenBracketToken || isTemplateStartOfTaggedTemplate()
}

func isStartOfOptionalPropertyOrElementAccessChain() bool {
	return token() == SyntaxKindQuestionDotToken && lookAhead(nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate)
}

func tryReparseOptionalChain(node Expression) bool {
	if node.flags & NodeFlagsOptionalChain {
		return true
	}
	// check for an optional chain in a non-null expression
	if isNonNullExpression(node) {
		expr := node.expression
		for isNonNullExpression(expr) && !(expr.flags & NodeFlagsOptionalChain) {
			expr = expr.expression
		}
		if expr.flags & NodeFlagsOptionalChain {
			// this is part of an optional chain. Walk down from `node` to `expression` and set the flag.
			for isNonNullExpression(node) {
				(node.(Mutable[NonNullExpression])).flags |= NodeFlagsOptionalChain
				node = node.expression
			}
			return true
		}
	}
	return false
}

func parsePropertyAccessExpressionRest(pos number, expression LeftHandSideExpression, questionDotToken *QuestionDotToken) PropertyAccessExpression {
	name := parseRightSideOfDot(true /*allowPrivateIdentifiers*/, true /*allowUnicodeEscapeSequenceInIdentifierName*/, true)
	isOptionalChain := questionDotToken || tryReparseOptionalChain(expression)
	var propertyAccess PropertyAccessExpression
	if isOptionalChain {
		propertyAccess = factoryCreatePropertyAccessChain(expression, questionDotToken, name)
	} else {
		propertyAccess = factoryCreatePropertyAccessExpression(expression, name)
	}
	if isOptionalChain && isPrivateIdentifier(propertyAccess.name) {
		parseErrorAtRange(propertyAccess.name, Diagnostics.An_optional_chain_cannot_contain_private_identifiers)
	}
	if isExpressionWithTypeArguments(expression) && expression.typeArguments {
		pos := expression.typeArguments.pos - 1
		end := skipTrivia(sourceText, expression.typeArguments.end) + 1
		parseErrorAt(pos, end, Diagnostics.An_instantiation_expression_cannot_be_followed_by_a_property_access)
	}
	return finishNode(propertyAccess, pos)
}

func parseElementAccessExpressionRest(pos number, expression LeftHandSideExpression, questionDotToken *QuestionDotToken) ElementAccessExpression {
	var argumentExpression Expression
	if token() == SyntaxKindCloseBracketToken {
		argumentExpression = createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, true, Diagnostics.An_element_access_expression_should_take_an_argument)
	} else {
		argument := allowInAnd(parseExpression)
		if isStringOrNumericLiteralLike(argument) {
			argument.text = internIdentifier(argument.text)
		}
		argumentExpression = argument
	}

	parseExpected(SyntaxKindCloseBracketToken)

	var indexedAccess ElementAccessExpression
	if questionDotToken || tryReparseOptionalChain(expression) {
		indexedAccess = factoryCreateElementAccessChain(expression, questionDotToken, argumentExpression)
	} else {
		indexedAccess = factoryCreateElementAccessExpression(expression, argumentExpression)
	}
	return finishNode(indexedAccess, pos)
}

func parseMemberExpressionRest(pos number, expression LeftHandSideExpression, allowOptionalChain bool) MemberExpression {
	for true {
		var questionDotToken *QuestionDotToken
		isPropertyAccess := false
		if allowOptionalChain && isStartOfOptionalPropertyOrElementAccessChain() {
			questionDotToken = parseExpectedToken(SyntaxKindQuestionDotToken)
			isPropertyAccess = tokenIsIdentifierOrKeyword(token())
		} else {
			isPropertyAccess = parseOptional(SyntaxKindDotToken)
		}

		if isPropertyAccess {
			expression = parsePropertyAccessExpressionRest(pos, expression, questionDotToken)
			continue
		}

		// when in the [Decorator] context, we do not parse ElementAccess as it could be part of a ComputedPropertyName
		if (questionDotToken || !inDecoratorContext()) && parseOptional(SyntaxKindOpenBracketToken) {
			expression = parseElementAccessExpressionRest(pos, expression, questionDotToken)
			continue
		}

		if isTemplateStartOfTaggedTemplate() {
			// Absorb type arguments into TemplateExpression when preceding expression is ExpressionWithTypeArguments
			if !questionDotToken && expression.kind == SyntaxKindExpressionWithTypeArguments {
				expression = parseTaggedTemplateRest(pos, (expression.(ExpressionWithTypeArguments)).expression, questionDotToken, (expression.(ExpressionWithTypeArguments)).typeArguments)
			} else {
				expression = parseTaggedTemplateRest(pos, expression, questionDotToken /*typeArguments*/, nil)
			}
			continue
		}

		if !questionDotToken {
			if token() == SyntaxKindExclamationToken && !scanner.hasPrecedingLineBreak() {
				nextToken()
				expression = finishNode(factory.createNonNullExpression(expression), pos)
				continue
			}
			typeArguments := tryParse(parseTypeArgumentsInExpression)
			if typeArguments {
				expression = finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos)
				continue
			}
		}

		return expression.(MemberExpression)
	}
}

func isTemplateStartOfTaggedTemplate() bool {
	return token() == SyntaxKindNoSubstitutionTemplateLiteral || token() == SyntaxKindTemplateHead
}

func parseTaggedTemplateRest(pos number, tag LeftHandSideExpression, questionDotToken *QuestionDotToken, typeArguments *NodeArray[TypeNode]) TaggedTemplateExpression {
	tagExpression := factory.createTaggedTemplateExpression(tag, typeArguments, ifelse(token() == SyntaxKindNoSubstitutionTemplateLiteral, ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: reScanTemplateToken(/*isTaggedTemplate* / true), parseLiteralNode() as NoSubstitutionTemplateLiteral */ TODO), parseTemplateExpression(true)))
	if questionDotToken || tag.flags&NodeFlagsOptionalChain {
		(tagExpression.(Mutable[Node])).flags |= NodeFlagsOptionalChain
	}
	tagExpression.questionDotToken = questionDotToken
	return finishNode(tagExpression, pos)
}

func parseCallExpressionRest(pos number, expression LeftHandSideExpression) LeftHandSideExpression {
	for true {
		expression = parseMemberExpressionRest(pos, expression /*allowOptionalChain*/, true)
		var typeArguments *NodeArray[TypeNode]
		questionDotToken := parseOptionalToken(SyntaxKindQuestionDotToken)
		if questionDotToken {
			typeArguments = tryParse(parseTypeArgumentsInExpression)
			if isTemplateStartOfTaggedTemplate() {
				expression = parseTaggedTemplateRest(pos, expression, questionDotToken, typeArguments)
				continue
			}
		}
		if typeArguments || token() == SyntaxKindOpenParenToken {
			// Absorb type arguments into CallExpression when preceding expression is ExpressionWithTypeArguments
			if !questionDotToken && expression.kind == SyntaxKindExpressionWithTypeArguments {
				typeArguments = (expression.(ExpressionWithTypeArguments)).typeArguments
				expression = (expression.(ExpressionWithTypeArguments)).expression
			}
			argumentList := parseArgumentList()
			var callExpr CallExpression
			if questionDotToken || tryReparseOptionalChain(expression) {
				callExpr = factoryCreateCallChain(expression, questionDotToken, typeArguments, argumentList)
			} else {
				callExpr = factoryCreateCallExpression(expression, typeArguments, argumentList)
			}
			expression = finishNode(callExpr, pos)
			continue
		}
		if questionDotToken {
			// We parsed `?.` but then failed to parse anything, so report a missing identifier here.
			name := createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, false, Diagnostics.Identifier_expected)
			expression = finishNode(factoryCreatePropertyAccessChain(expression, questionDotToken, name), pos)
		}
		break
	}
	return expression
}

func parseArgumentList() NodeArray[Expression] {
	parseExpected(SyntaxKindOpenParenToken)
	result := parseDelimitedList(ParsingContextArgumentExpressions, parseArgumentExpression)
	parseExpected(SyntaxKindCloseParenToken)
	return result
}

func parseTypeArgumentsInExpression() *NodeArray[TypeNode] {
	if (contextFlags & NodeFlagsJavaScriptFile) != 0 {
		// TypeArguments must not be parsed in JavaScript files to avoid ambiguity with binary operators.
		return nil
	}

	if reScanLessThanToken() != SyntaxKindLessThanToken {
		return nil
	}
	nextToken()

	typeArguments := parseDelimitedList(ParsingContextTypeArguments, parseType)
	if reScanGreaterToken() != SyntaxKindGreaterThanToken {
		// If it doesn't have the closing `>` then it's definitely not an type argument list.
		return nil
	}
	nextToken()

	// We successfully parsed a type argument list. The next token determines whether we want to
	// treat it as such. If the type argument list is followed by `(` or a template literal, as in
	// `f<number>(42)`, we favor the type argument interpretation even though JavaScript would view
	// it as a relational expression.
	if typeArguments && canFollowTypeArgumentsInExpression() {
		return typeArguments
	} else {
		return nil
	}
}

func canFollowTypeArgumentsInExpression() bool {
	switch token() {
	case SyntaxKindOpenParenToken,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindTemplateHead:
		return true
		// A type argument list followed by `<` never makes sense, and a type argument list followed
		// by `>` is ambiguous with a (re-scanned) `>>` operator, so we disqualify both. Also, in
		// this context, `+` and `-` are unary operators, not binary operators.
	case SyntaxKindLessThanToken,
		SyntaxKindGreaterThanToken,
		SyntaxKindPlusToken,
		SyntaxKindMinusToken:
		return false
	}
	// We favor the type argument list interpretation when it is immediately followed by
	// a line break, a binary operator, or something that can't start an expression.
	return scanner.hasPrecedingLineBreak() || isBinaryOperator() || !isStartOfExpression()
}

func parsePrimaryExpression() PrimaryExpression {
	switch token() {
	case SyntaxKindNoSubstitutionTemplateLiteral:
		if scanner.getTokenFlags() & TokenFlagsIsInvalid {
			reScanTemplateToken(false)
		}
		fallthrough
	case SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindStringLiteral:
		return parseLiteralNode()
	case SyntaxKindThisKeyword,
		SyntaxKindSuperKeyword,
		SyntaxKindNullKeyword,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword:
		return parseTokenNode()
	case SyntaxKindOpenParenToken:
		return parseParenthesizedExpression()
	case SyntaxKindOpenBracketToken:
		return parseArrayLiteralExpression()
	case SyntaxKindOpenBraceToken:
		return parseObjectLiteralExpression()
	case SyntaxKindAsyncKeyword:
		// Async arrow functions are parsed earlier in parseAssignmentExpressionOrHigher.
		// If we encounter `async [no LineTerminator here] function` then this is an async
		// function; otherwise, its an identifier.
		if !lookAhead(nextTokenIsFunctionKeywordOnSameLine) {
			break
		}

		return parseFunctionExpression()
	case SyntaxKindAtToken:
		return parseDecoratedExpression()
	case SyntaxKindClassKeyword:
		return parseClassExpression()
	case SyntaxKindFunctionKeyword:
		return parseFunctionExpression()
	case SyntaxKindNewKeyword:
		return parseNewExpressionOrNewDotTarget()
	case SyntaxKindSlashToken,
		SyntaxKindSlashEqualsToken:
		if reScanSlashToken() == SyntaxKindRegularExpressionLiteral {
			return parseLiteralNode()
		}
	case SyntaxKindTemplateHead:
		return parseTemplateExpression(false)
	case SyntaxKindPrivateIdentifier:
		return parsePrivateIdentifier()
	}

	return parseIdentifier(Diagnostics.Expression_expected)
}

func parseParenthesizedExpression() ParenthesizedExpression {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindOpenParenToken)
	expression := allowInAnd(parseExpression)
	parseExpected(SyntaxKindCloseParenToken)
	return withJSDoc(finishNode(factoryCreateParenthesizedExpression(expression), pos), hasJSDoc)
}

func parseSpreadElement() Expression {
	pos := getNodePos()
	parseExpected(SyntaxKindDotDotDotToken)
	expression := parseAssignmentExpressionOrHigher(true)
	return finishNode(factory.createSpreadElement(expression), pos)
}

func parseArgumentOrArrayLiteralElement() Expression {
	switch {
	case token() == SyntaxKindDotDotDotToken:
		return parseSpreadElement()
	case token() == SyntaxKindCommaToken:
		return finishNode(factory.createOmittedExpression(), getNodePos())
	default:
		return parseAssignmentExpressionOrHigher(true)
	}
}

func parseArgumentExpression() Expression {
	return doOutsideOfContext(disallowInAndDecoratorContext, parseArgumentOrArrayLiteralElement)
}

func parseArrayLiteralExpression() ArrayLiteralExpression {
	pos := getNodePos()
	openBracketPosition := scanner.getTokenStart()
	openBracketParsed := parseExpected(SyntaxKindOpenBracketToken)
	multiLine := scanner.hasPrecedingLineBreak()
	elements := parseDelimitedList(ParsingContextArrayLiteralMembers, parseArgumentOrArrayLiteralElement)
	parseExpectedMatchingBrackets(SyntaxKindOpenBracketToken, SyntaxKindCloseBracketToken, openBracketParsed, openBracketPosition)
	return finishNode(factoryCreateArrayLiteralExpression(elements, multiLine), pos)
}

func parseObjectLiteralElement() ObjectLiteralElementLike {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()

	if parseOptionalToken(SyntaxKindDotDotDotToken) {
		expression := parseAssignmentExpressionOrHigher(true)
		return withJSDoc(finishNode(factory.createSpreadAssignment(expression), pos), hasJSDoc)
	}

	modifiers := parseModifiers(true)
	if parseContextualModifier(SyntaxKindGetKeyword) {
		return parseAccessorDeclaration(pos, hasJSDoc, modifiers, SyntaxKindGetAccessor, SignatureFlagsNone)
	}
	if parseContextualModifier(SyntaxKindSetKeyword) {
		return parseAccessorDeclaration(pos, hasJSDoc, modifiers, SyntaxKindSetAccessor, SignatureFlagsNone)
	}

	asteriskToken := parseOptionalToken(SyntaxKindAsteriskToken)
	tokenIsIdentifier := isIdentifier()
	name := parsePropertyName()

	// Disallowing of optional property assignments and definite assignment assertion happens in the grammar checker.
	questionToken := parseOptionalToken(SyntaxKindQuestionToken)
	exclamationToken := parseOptionalToken(SyntaxKindExclamationToken)

	if asteriskToken || token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken {
		return parseMethodDeclaration(pos, hasJSDoc, modifiers, asteriskToken, name, questionToken, exclamationToken)
	}

	// check if it is short-hand property assignment or normal property assignment
	// NOTE: if token is EqualsToken it is interpreted as CoverInitializedName production
	// CoverInitializedName[Yield] :
	//     IdentifierReference[?Yield] Initializer[In, ?Yield]
	// this is necessary because ObjectLiteral productions are also used to cover grammar for ObjectAssignmentPattern
	var node Mutable[ /* TODO(TS-TO-GO) TypeNode UnionType: ShorthandPropertyAssignment | PropertyAssignment */ any]
	isShorthandPropertyAssignment := tokenIsIdentifier && (token() != SyntaxKindColonToken)
	if isShorthandPropertyAssignment {
		equalsToken := parseOptionalToken(SyntaxKindEqualsToken)
		var objectAssignmentInitializer Expression
		if equalsToken {
			objectAssignmentInitializer = allowInAnd(func() Expression {
				return parseAssignmentExpressionOrHigher(true)
			})
		} else {
			objectAssignmentInitializer = nil
		}
		node = factory.createShorthandPropertyAssignment(name.(Identifier), objectAssignmentInitializer)
		// Save equals token for error reporting.
		// TODO(rbuckton): Consider manufacturing this when we need to report an error as it is otherwise not useful.
		node.equalsToken = equalsToken
	} else {
		parseExpected(SyntaxKindColonToken)
		initializer := allowInAnd(func() Expression {
			return parseAssignmentExpressionOrHigher(true)
		})
		node = factory.createPropertyAssignment(name, initializer)
	}
	// Decorators, Modifiers, questionToken, and exclamationToken are not supported by property assignments and are reported in the grammar checker
	node.modifiers = modifiers
	node.questionToken = questionToken
	node.exclamationToken = exclamationToken
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseObjectLiteralExpression() ObjectLiteralExpression {
	pos := getNodePos()
	openBracePosition := scanner.getTokenStart()
	openBraceParsed := parseExpected(SyntaxKindOpenBraceToken)
	multiLine := scanner.hasPrecedingLineBreak()
	properties := parseDelimitedList(ParsingContextObjectLiteralMembers, parseObjectLiteralElement /*considerSemicolonAsDelimiter*/, true)
	parseExpectedMatchingBrackets(SyntaxKindOpenBraceToken, SyntaxKindCloseBraceToken, openBraceParsed, openBracePosition)
	return finishNode(factoryCreateObjectLiteralExpression(properties, multiLine), pos)
}

func parseFunctionExpression() FunctionExpression {
	// GeneratorExpression:
	//      function* BindingIdentifier [Yield][opt](FormalParameters[Yield]){ GeneratorBody }
	//
	// FunctionExpression:
	//      function BindingIdentifier[opt](FormalParameters){ FunctionBody }
	savedDecoratorContext := inDecoratorContext()
	setDecoratorContext(false)

	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	modifiers := parseModifiers(false)
	parseExpected(SyntaxKindFunctionKeyword)
	asteriskToken := parseOptionalToken(SyntaxKindAsteriskToken)
	var isGenerator /* TODO(TS-TO-GO) inferred type SignatureFlags.None | SignatureFlags.Yield */ any
	if asteriskToken {
		isGenerator = SignatureFlagsYield
	} else {
		isGenerator = SignatureFlagsNone
	}
	var isAsync /* TODO(TS-TO-GO) inferred type SignatureFlags.None | SignatureFlags.Await */ any
	if some(modifiers, isAsyncModifier) {
		isAsync = SignatureFlagsAwait
	} else {
		isAsync = SignatureFlagsNone
	}
	var name *Identifier
	switch {
	case isGenerator && isAsync:
		name = doInYieldAndAwaitContext(parseOptionalBindingIdentifier)
	case isGenerator:
		name = doInYieldContext(parseOptionalBindingIdentifier)
	case isAsync:
		name = doInAwaitContext(parseOptionalBindingIdentifier)
	default:
		name = parseOptionalBindingIdentifier()
	}

	typeParameters := parseTypeParameters()
	parameters := parseParameters(isGenerator | isAsync)
	type_ := parseReturnType(SyntaxKindColonToken /*isType*/, false)
	body := parseFunctionBlock(isGenerator | isAsync)

	setDecoratorContext(savedDecoratorContext)

	node := factory.createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type_, body)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseOptionalBindingIdentifier() *Identifier {
	if isBindingIdentifier() {
		return parseBindingIdentifier()
	} else {
		return nil
	}
}

func parseNewExpressionOrNewDotTarget() /* TODO(TS-TO-GO) TypeNode UnionType: NewExpression | MetaProperty */ any {
	pos := getNodePos()
	parseExpected(SyntaxKindNewKeyword)
	if parseOptional(SyntaxKindDotToken) {
		name := parseIdentifierName()
		return finishNode(factory.createMetaProperty(SyntaxKindNewKeyword, name), pos)
	}
	expressionPos := getNodePos()
	var expression LeftHandSideExpression = parseMemberExpressionRest(expressionPos, parsePrimaryExpression() /*allowOptionalChain*/, false)
	var typeArguments *NodeArray[TypeNode]
	// Absorb type arguments into NewExpression when preceding expression is ExpressionWithTypeArguments
	if expression.kind == SyntaxKindExpressionWithTypeArguments {
		typeArguments = (expression.(ExpressionWithTypeArguments)).typeArguments
		expression = (expression.(ExpressionWithTypeArguments)).expression
	}
	if token() == SyntaxKindQuestionDotToken {
		parseErrorAtCurrentToken(Diagnostics.Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0, getTextOfNodeFromSourceText(sourceText, expression))
	}
	var argumentList *NodeArray[Expression]
	if token() == SyntaxKindOpenParenToken {
		argumentList = parseArgumentList()
	} else {
		argumentList = nil
	}
	return finishNode(factoryCreateNewExpression(expression, typeArguments, argumentList), pos)
}

// STATEMENTS
func parseBlock(ignoreMissingOpenBrace bool, diagnosticMessage DiagnosticMessage) Block {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	openBracePosition := scanner.getTokenStart()
	openBraceParsed := parseExpected(SyntaxKindOpenBraceToken, diagnosticMessage)
	if openBraceParsed || ignoreMissingOpenBrace {
		multiLine := scanner.hasPrecedingLineBreak()
		statements := parseList(ParsingContextBlockStatements, parseStatement)
		parseExpectedMatchingBrackets(SyntaxKindOpenBraceToken, SyntaxKindCloseBraceToken, openBraceParsed, openBracePosition)
		result := withJSDoc(finishNode(factoryCreateBlock(statements, multiLine), pos), hasJSDoc)
		if token() == SyntaxKindEqualsToken {
			parseErrorAtCurrentToken(Diagnostics.Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses)
			nextToken()
		}

		return result
	} else {
		statements := createMissingList()
		return withJSDoc(finishNode(factoryCreateBlock(statements /*multiLine*/, nil), pos), hasJSDoc)
	}
}

func parseFunctionBlock(flags SignatureFlags, diagnosticMessage DiagnosticMessage) Block {
	savedYieldContext := inYieldContext()
	setYieldContext(!!(flags & SignatureFlagsYield))

	savedAwaitContext := inAwaitContext()
	setAwaitContext(!!(flags & SignatureFlagsAwait))

	savedTopLevel := topLevel
	topLevel = false

	// We may be in a [Decorator] context when parsing a function expression or
	// arrow function. The body of the function is not in [Decorator] context.
	saveDecoratorContext := inDecoratorContext()
	if saveDecoratorContext {
		setDecoratorContext(false)
	}

	block := parseBlock(!!(flags & SignatureFlagsIgnoreMissingOpenBrace), diagnosticMessage)

	if saveDecoratorContext {
		setDecoratorContext(true)
	}

	topLevel = savedTopLevel
	setYieldContext(savedYieldContext)
	setAwaitContext(savedAwaitContext)

	return block
}

func parseEmptyStatement() Statement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindSemicolonToken)
	return withJSDoc(finishNode(factory.createEmptyStatement(), pos), hasJSDoc)
}

func parseIfStatement() IfStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindIfKeyword)
	openParenPosition := scanner.getTokenStart()
	openParenParsed := parseExpected(SyntaxKindOpenParenToken)
	expression := allowInAnd(parseExpression)
	parseExpectedMatchingBrackets(SyntaxKindOpenParenToken, SyntaxKindCloseParenToken, openParenParsed, openParenPosition)
	thenStatement := parseStatement()
	var elseStatement Statement
	if parseOptional(SyntaxKindElseKeyword) {
		elseStatement = parseStatement()
	} else {
		elseStatement = nil
	}
	return withJSDoc(finishNode(factoryCreateIfStatement(expression, thenStatement, elseStatement), pos), hasJSDoc)
}

func parseDoStatement() DoStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindDoKeyword)
	statement := parseStatement()
	parseExpected(SyntaxKindWhileKeyword)
	openParenPosition := scanner.getTokenStart()
	openParenParsed := parseExpected(SyntaxKindOpenParenToken)
	expression := allowInAnd(parseExpression)
	parseExpectedMatchingBrackets(SyntaxKindOpenParenToken, SyntaxKindCloseParenToken, openParenParsed, openParenPosition)

	// From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
	// 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in
	// spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
	//  do;while(0)x will have a semicolon inserted before x.
	parseOptional(SyntaxKindSemicolonToken)
	return withJSDoc(finishNode(factory.createDoStatement(statement, expression), pos), hasJSDoc)
}

func parseWhileStatement() WhileStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindWhileKeyword)
	openParenPosition := scanner.getTokenStart()
	openParenParsed := parseExpected(SyntaxKindOpenParenToken)
	expression := allowInAnd(parseExpression)
	parseExpectedMatchingBrackets(SyntaxKindOpenParenToken, SyntaxKindCloseParenToken, openParenParsed, openParenPosition)
	statement := parseStatement()
	return withJSDoc(finishNode(factoryCreateWhileStatement(expression, statement), pos), hasJSDoc)
}

func parseForOrForInOrForOfStatement() Statement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindForKeyword)
	awaitToken := parseOptionalToken(SyntaxKindAwaitKeyword)
	parseExpected(SyntaxKindOpenParenToken)

	var initializer /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclarationList | Expression */ any
	if token() != SyntaxKindSemicolonToken {
		if token() == SyntaxKindVarKeyword || token() == SyntaxKindLetKeyword || token() == SyntaxKindConstKeyword || token() == SyntaxKindUsingKeyword && lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLineDisallowOf) || token() == SyntaxKindAwaitKeyword && lookAhead(nextTokenIsUsingKeywordThenBindingIdentifierOrStartOfObjectDestructuringOnSameLine) {
			initializer = parseVariableDeclarationList(true)
		} else {
			initializer = disallowInAnd(parseExpression)
		}
	}

	var node IterationStatement
	if ifelse(awaitToken, parseExpected(SyntaxKindOfKeyword), parseOptional(SyntaxKindOfKeyword)) {
		expression := allowInAnd(func() Expression {
			return parseAssignmentExpressionOrHigher(true)
		})
		parseExpected(SyntaxKindCloseParenToken)
		node = factoryCreateForOfStatement(awaitToken, initializer, expression, parseStatement())
	} else if parseOptional(SyntaxKindInKeyword) {
		expression := allowInAnd(parseExpression)
		parseExpected(SyntaxKindCloseParenToken)
		node = factory.createForInStatement(initializer, expression, parseStatement())
	} else {
		parseExpected(SyntaxKindSemicolonToken)
		var condition Expression
		if token() != SyntaxKindSemicolonToken && token() != SyntaxKindCloseParenToken {
			condition = allowInAnd(parseExpression)
		} else {
			condition = nil
		}
		parseExpected(SyntaxKindSemicolonToken)
		var incrementor Expression
		if token() != SyntaxKindCloseParenToken {
			incrementor = allowInAnd(parseExpression)
		} else {
			incrementor = nil
		}
		parseExpected(SyntaxKindCloseParenToken)
		node = factoryCreateForStatement(initializer, condition, incrementor, parseStatement())
	}

	return withJSDoc(finishNode(node, pos) /* as ForStatement | ForInOrOfStatement */, hasJSDoc)
}

func parseBreakOrContinueStatement(kind SyntaxKind) BreakOrContinueStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()

	parseExpected(ifelse(kind == SyntaxKindBreakStatement, SyntaxKindBreakKeyword, SyntaxKindContinueKeyword))
	var label *Identifier
	if canParseSemicolon() {
		label = nil
	} else {
		label = parseIdentifier()
	}

	parseSemicolon()
	var node /* TODO(TS-TO-GO) inferred type BreakStatement | ContinueStatement */ any
	if kind == SyntaxKindBreakStatement {
		node = factory.createBreakStatement(label)
	} else {
		node = factory.createContinueStatement(label)
	}
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseReturnStatement() ReturnStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindReturnKeyword)
	var expression Expression
	if canParseSemicolon() {
		expression = nil
	} else {
		expression = allowInAnd(parseExpression)
	}
	parseSemicolon()
	return withJSDoc(finishNode(factory.createReturnStatement(expression), pos), hasJSDoc)
}

func parseWithStatement() WithStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindWithKeyword)
	openParenPosition := scanner.getTokenStart()
	openParenParsed := parseExpected(SyntaxKindOpenParenToken)
	expression := allowInAnd(parseExpression)
	parseExpectedMatchingBrackets(SyntaxKindOpenParenToken, SyntaxKindCloseParenToken, openParenParsed, openParenPosition)
	statement := doInsideOfContext(NodeFlagsInWithStatement, parseStatement)
	return withJSDoc(finishNode(factory.createWithStatement(expression, statement), pos), hasJSDoc)
}

func parseCaseClause() CaseClause {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindCaseKeyword)
	expression := allowInAnd(parseExpression)
	parseExpected(SyntaxKindColonToken)
	statements := parseList(ParsingContextSwitchClauseStatements, parseStatement)
	return withJSDoc(finishNode(factory.createCaseClause(expression, statements), pos), hasJSDoc)
}

func parseDefaultClause() DefaultClause {
	pos := getNodePos()
	parseExpected(SyntaxKindDefaultKeyword)
	parseExpected(SyntaxKindColonToken)
	statements := parseList(ParsingContextSwitchClauseStatements, parseStatement)
	return finishNode(factory.createDefaultClause(statements), pos)
}

func parseCaseOrDefaultClause() CaseOrDefaultClause {
	if token() == SyntaxKindCaseKeyword {
		return parseCaseClause()
	} else {
		return parseDefaultClause()
	}
}

func parseCaseBlock() CaseBlock {
	pos := getNodePos()
	parseExpected(SyntaxKindOpenBraceToken)
	clauses := parseList(ParsingContextSwitchClauses, parseCaseOrDefaultClause)
	parseExpected(SyntaxKindCloseBraceToken)
	return finishNode(factory.createCaseBlock(clauses), pos)
}

func parseSwitchStatement() SwitchStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindSwitchKeyword)
	parseExpected(SyntaxKindOpenParenToken)
	expression := allowInAnd(parseExpression)
	parseExpected(SyntaxKindCloseParenToken)
	caseBlock := parseCaseBlock()
	return withJSDoc(finishNode(factory.createSwitchStatement(expression, caseBlock), pos), hasJSDoc)
}

func parseThrowStatement() ThrowStatement {
	// ThrowStatement[Yield] :
	//      throw [no LineTerminator here]Expression[In, ?Yield];

	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindThrowKeyword)

	// Because of automatic semicolon insertion, we need to report error if this
	// throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
	// directly as that might consume an expression on the following line.
	// Instead, we create a "missing" identifier, but don't report an error. The actual error
	// will be reported in the grammar walker.
	var expression Expression
	if scanner.hasPrecedingLineBreak() {
		expression = nil
	} else {
		expression = allowInAnd(parseExpression)
	}
	if expression == nil {
		identifierCount++
		expression = finishNode(factoryCreateIdentifier(""), getNodePos())
	}
	if !tryParseSemicolon() {
		parseErrorForMissingSemicolonAfter(expression)
	}
	return withJSDoc(finishNode(factory.createThrowStatement(expression), pos), hasJSDoc)
}

// TODO: Review for error recovery
func parseTryStatement() TryStatement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()

	parseExpected(SyntaxKindTryKeyword)
	tryBlock := parseBlock(false)
	var catchClause *CatchClause
	if token() == SyntaxKindCatchKeyword {
		catchClause = parseCatchClause()
	} else {
		catchClause = nil
	}

	// If we don't have a catch clause, then we must have a finally clause.  Try to parse
	// one out no matter what.
	var finallyBlock *Block
	if !catchClause || token() == SyntaxKindFinallyKeyword {
		parseExpected(SyntaxKindFinallyKeyword, Diagnostics.catch_or_finally_expected)
		finallyBlock = parseBlock(false)
	}

	return withJSDoc(finishNode(factory.createTryStatement(tryBlock, catchClause, finallyBlock), pos), hasJSDoc)
}

func parseCatchClause() CatchClause {
	pos := getNodePos()
	parseExpected(SyntaxKindCatchKeyword)

	var variableDeclaration TODO
	if parseOptional(SyntaxKindOpenParenToken) {
		variableDeclaration = parseVariableDeclaration()
		parseExpected(SyntaxKindCloseParenToken)
	} else {
		// Keep shape of node to avoid degrading performance.
		variableDeclaration = nil
	}

	block := parseBlock(false)
	return finishNode(factory.createCatchClause(variableDeclaration, block), pos)
}

func parseDebuggerStatement() Statement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	parseExpected(SyntaxKindDebuggerKeyword)
	parseSemicolon()
	return withJSDoc(finishNode(factory.createDebuggerStatement(), pos), hasJSDoc)
}

func parseExpressionOrLabeledStatement() /* TODO(TS-TO-GO) TypeNode UnionType: ExpressionStatement | LabeledStatement */ any {
	// Avoiding having to do the lookahead for a labeled statement by just trying to parse
	// out an expression, seeing if it is identifier and then seeing if it is followed by
	// a colon.
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	var node /* TODO(TS-TO-GO) TypeNode UnionType: ExpressionStatement | LabeledStatement */ any
	hasParen := token() == SyntaxKindOpenParenToken
	expression := allowInAnd(parseExpression)
	if isIdentifierNode(expression) && parseOptional(SyntaxKindColonToken) {
		node = factory.createLabeledStatement(expression, parseStatement())
	} else {
		if !tryParseSemicolon() {
			parseErrorForMissingSemicolonAfter(expression)
		}
		node = factoryCreateExpressionStatement(expression)
		if hasParen {
			// do not parse the same jsdoc twice
			hasJSDoc = false
		}
	}
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func nextTokenIsIdentifierOrKeywordOnSameLine() bool {
	nextToken()
	return tokenIsIdentifierOrKeyword(token()) && !scanner.hasPrecedingLineBreak()
}

func nextTokenIsClassKeywordOnSameLine() bool {
	nextToken()
	return token() == SyntaxKindClassKeyword && !scanner.hasPrecedingLineBreak()
}

func nextTokenIsFunctionKeywordOnSameLine() bool {
	nextToken()
	return token() == SyntaxKindFunctionKeyword && !scanner.hasPrecedingLineBreak()
}

func nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine() bool {
	nextToken()
	return (tokenIsIdentifierOrKeyword(token()) || token() == SyntaxKindNumericLiteral || token() == SyntaxKindBigIntLiteral || token() == SyntaxKindStringLiteral) && !scanner.hasPrecedingLineBreak()
}

func isDeclaration() bool {
	for true {
		switch token() {
		case SyntaxKindVarKeyword,
			SyntaxKindLetKeyword,
			SyntaxKindConstKeyword,
			SyntaxKindFunctionKeyword,
			SyntaxKindClassKeyword,
			SyntaxKindEnumKeyword:
			return true
		case SyntaxKindUsingKeyword:
			return isUsingDeclaration()
		case SyntaxKindAwaitKeyword:
			return isAwaitUsingDeclaration()

			// 'declare', 'module', 'namespace', 'interface'* and 'type' are all legal JavaScript identifiers;
			// however, an identifier cannot be followed by another identifier on the same line. This is what we
			// count on to parse out the respective declarations. For instance, we exploit this to say that
			//
			//    namespace n
			//
			// can be none other than the beginning of a namespace declaration, but need to respect that JavaScript sees
			//
			//    namespace
			//    n
			//
			// as the identifier 'namespace' on one line followed by the identifier 'n' on another.
			// We need to look one token ahead to see if it permissible to try parsing a declaration.
			//
			// *Note*: 'interface' is actually a strict mode reserved word. So while
			//
			//   "use strict"
			//   interface
			//   I {}
			//
			// could be legal, it would add complexity for very little gain.
		case SyntaxKindInterfaceKeyword,
			SyntaxKindTypeKeyword:
			return nextTokenIsIdentifierOnSameLine()
		case SyntaxKindModuleKeyword,
			SyntaxKindNamespaceKeyword:
			return nextTokenIsIdentifierOrStringLiteralOnSameLine()
		case SyntaxKindAbstractKeyword,
			SyntaxKindAccessorKeyword,
			SyntaxKindAsyncKeyword,
			SyntaxKindDeclareKeyword,
			SyntaxKindPrivateKeyword,
			SyntaxKindProtectedKeyword,
			SyntaxKindPublicKeyword,
			SyntaxKindReadonlyKeyword:
			previousToken := token()
			nextToken()
			// ASI takes effect for this modifier.
			if scanner.hasPrecedingLineBreak() {
				return false
			}
			if previousToken == SyntaxKindDeclareKeyword && token() == SyntaxKindTypeKeyword {
				// If we see 'declare type', then commit to parsing a type alias. parseTypeAliasDeclaration will
				// report Line_break_not_permitted_here if needed.
				return true
			}
			continue
		case SyntaxKindGlobalKeyword:
			nextToken()
			return token() == SyntaxKindOpenBraceToken || token() == SyntaxKindIdentifier || token() == SyntaxKindExportKeyword
		case SyntaxKindImportKeyword:
			nextToken()
			return token() == SyntaxKindStringLiteral || token() == SyntaxKindAsteriskToken || token() == SyntaxKindOpenBraceToken || tokenIsIdentifierOrKeyword(token())
		case SyntaxKindExportKeyword:
			currentToken := nextToken()
			if currentToken == SyntaxKindTypeKeyword {
				currentToken = lookAhead(nextToken)
			}
			if currentToken == SyntaxKindEqualsToken || currentToken == SyntaxKindAsteriskToken || currentToken == SyntaxKindOpenBraceToken || currentToken == SyntaxKindDefaultKeyword || currentToken == SyntaxKindAsKeyword || currentToken == SyntaxKindAtToken {
				return true
			}
			continue
		case SyntaxKindStaticKeyword:
			nextToken()
			continue
		default:
			return false
		}
	}
}

func isStartOfDeclaration() bool {
	return lookAhead(isDeclaration)
}

func isStartOfStatement() bool {
	switch token() {
	case SyntaxKindAtToken,
		SyntaxKindSemicolonToken,
		SyntaxKindOpenBraceToken,
		SyntaxKindVarKeyword,
		SyntaxKindLetKeyword,
		SyntaxKindUsingKeyword,
		SyntaxKindFunctionKeyword,
		SyntaxKindClassKeyword,
		SyntaxKindEnumKeyword,
		SyntaxKindIfKeyword,
		SyntaxKindDoKeyword,
		SyntaxKindWhileKeyword,
		SyntaxKindForKeyword,
		SyntaxKindContinueKeyword,
		SyntaxKindBreakKeyword,
		SyntaxKindReturnKeyword,
		SyntaxKindWithKeyword,
		SyntaxKindSwitchKeyword,
		SyntaxKindThrowKeyword,
		SyntaxKindTryKeyword,
		SyntaxKindDebuggerKeyword,
		SyntaxKindCatchKeyword,
		SyntaxKindFinallyKeyword:
		return true
	case SyntaxKindImportKeyword:
		return isStartOfDeclaration() || lookAhead(nextTokenIsOpenParenOrLessThanOrDot)
	case SyntaxKindConstKeyword,
		SyntaxKindExportKeyword:
		return isStartOfDeclaration()
	case SyntaxKindAsyncKeyword,
		SyntaxKindDeclareKeyword,
		SyntaxKindInterfaceKeyword,
		SyntaxKindModuleKeyword,
		SyntaxKindNamespaceKeyword,
		SyntaxKindTypeKeyword,
		SyntaxKindGlobalKeyword:
		// When these don't start a declaration, they're an identifier in an expression statement
		return true
	case SyntaxKindAccessorKeyword,
		SyntaxKindPublicKeyword,
		SyntaxKindPrivateKeyword,
		SyntaxKindProtectedKeyword,
		SyntaxKindStaticKeyword,
		SyntaxKindReadonlyKeyword:
		// When these don't start a declaration, they may be the start of a class member if an identifier
		// immediately follows. Otherwise they're an identifier in an expression statement.
		return isStartOfDeclaration() || !lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine)
	default:
		return isStartOfExpression()
	}
}

func nextTokenIsBindingIdentifierOrStartOfDestructuring() bool {
	nextToken()
	return isBindingIdentifier() || token() == SyntaxKindOpenBraceToken || token() == SyntaxKindOpenBracketToken
}

func isLetDeclaration() bool {
	// In ES6 'let' always starts a lexical declaration if followed by an identifier or {
	// or [.
	return lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuring)
}

func nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLineDisallowOf() bool {
	return nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine(true)
}

func nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine(disallowOf bool) bool {
	nextToken()
	if disallowOf && token() == SyntaxKindOfKeyword {
		return false
	}
	return (isBindingIdentifier() || token() == SyntaxKindOpenBraceToken) && !scanner.hasPrecedingLineBreak()
}

func isUsingDeclaration() bool {
	// 'using' always starts a lexical declaration if followed by an identifier. We also eagerly parse
	// |ObjectBindingPattern| so that we can report a grammar error during check. We don't parse out
	// |ArrayBindingPattern| since it potentially conflicts with element access (i.e., `using[x]`).
	return lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine)
}

func nextTokenIsUsingKeywordThenBindingIdentifierOrStartOfObjectDestructuringOnSameLine(disallowOf bool) bool {
	if nextToken() == SyntaxKindUsingKeyword {
		return nextTokenIsBindingIdentifierOrStartOfDestructuringOnSameLine(disallowOf)
	}
	return false
}

func isAwaitUsingDeclaration() bool {
	// 'await using' always starts a lexical declaration if followed by an identifier. We also eagerly parse
	// |ObjectBindingPattern| so that we can report a grammar error during check. We don't parse out
	// |ArrayBindingPattern| since it potentially conflicts with element access (i.e., `await using[x]`).
	return lookAhead(nextTokenIsUsingKeywordThenBindingIdentifierOrStartOfObjectDestructuringOnSameLine)
}

func parseStatement() Statement {
	switch token() {
	case SyntaxKindSemicolonToken:
		return parseEmptyStatement()
	case SyntaxKindOpenBraceToken:
		return parseBlock(false)
	case SyntaxKindVarKeyword:
		return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment() /*modifiers*/, nil)
	case SyntaxKindLetKeyword:
		if isLetDeclaration() {
			return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment() /*modifiers*/, nil)
		}
	case SyntaxKindAwaitKeyword:
		if isAwaitUsingDeclaration() {
			return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment() /*modifiers*/, nil)
		}
	case SyntaxKindUsingKeyword:
		if isUsingDeclaration() {
			return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment() /*modifiers*/, nil)
		}
	case SyntaxKindFunctionKeyword:
		return parseFunctionDeclaration(getNodePos(), hasPrecedingJSDocComment() /*modifiers*/, nil)
	case SyntaxKindClassKeyword:
		return parseClassDeclaration(getNodePos(), hasPrecedingJSDocComment() /*modifiers*/, nil)
	case SyntaxKindIfKeyword:
		return parseIfStatement()
	case SyntaxKindDoKeyword:
		return parseDoStatement()
	case SyntaxKindWhileKeyword:
		return parseWhileStatement()
	case SyntaxKindForKeyword:
		return parseForOrForInOrForOfStatement()
	case SyntaxKindContinueKeyword:
		return parseBreakOrContinueStatement(SyntaxKindContinueStatement)
	case SyntaxKindBreakKeyword:
		return parseBreakOrContinueStatement(SyntaxKindBreakStatement)
	case SyntaxKindReturnKeyword:
		return parseReturnStatement()
	case SyntaxKindWithKeyword:
		return parseWithStatement()
	case SyntaxKindSwitchKeyword:
		return parseSwitchStatement()
	case SyntaxKindThrowKeyword:
		return parseThrowStatement()
	case SyntaxKindTryKeyword,
		SyntaxKindCatchKeyword,
		SyntaxKindFinallyKeyword:
		return parseTryStatement()
	case SyntaxKindDebuggerKeyword:
		return parseDebuggerStatement()
	case SyntaxKindAtToken:
		return parseDeclaration()
	case SyntaxKindAsyncKeyword,
		SyntaxKindInterfaceKeyword,
		SyntaxKindTypeKeyword,
		SyntaxKindModuleKeyword,
		SyntaxKindNamespaceKeyword,
		SyntaxKindDeclareKeyword,
		SyntaxKindConstKeyword,
		SyntaxKindEnumKeyword,
		SyntaxKindExportKeyword,
		SyntaxKindImportKeyword,
		SyntaxKindPrivateKeyword,
		SyntaxKindProtectedKeyword,
		SyntaxKindPublicKeyword,
		SyntaxKindAbstractKeyword,
		SyntaxKindAccessorKeyword,
		SyntaxKindStaticKeyword,
		SyntaxKindReadonlyKeyword,
		SyntaxKindGlobalKeyword:
		if isStartOfDeclaration() {
			return parseDeclaration()
		}
	}
	return parseExpressionOrLabeledStatement()
}

func isDeclareModifier(modifier ModifierLike) bool {
	return modifier.kind == SyntaxKindDeclareKeyword
}

func parseDeclaration() Statement {
	// `parseListElement` attempted to get the reused node at this position,
	// but the ambient context flag was not yet set, so the node appeared
	// not reusable in that context.
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	modifiers := parseModifiers(true)
	isAmbient := some(modifiers, isDeclareModifier)
	if isAmbient {
		node := tryReuseAmbientDeclaration(pos)
		if node {
			return node
		}

		for _, m := range modifiers {
			(m.(Mutable[Node])).flags |= NodeFlagsAmbient
		}
		return doInsideOfContext(NodeFlagsAmbient, func() Statement {
			return parseDeclarationWorker(pos, hasJSDoc, modifiers)
		})
	} else {
		return parseDeclarationWorker(pos, hasJSDoc, modifiers)
	}
}

func tryReuseAmbientDeclaration(pos number) Statement {
	return doInsideOfContext(NodeFlagsAmbient, func() Statement {
		// TODO(jakebailey): this is totally wrong; `parsingContext` is the result of ORing a bunch of `1 << ParsingContext.XYZ`.
		// The enum should really be a bunch of flags.
		node := currentNode(parsingContext, pos)
		if node {
			return consumeNode(node).(Statement)
		}
	})
}

func parseDeclarationWorker(pos number, hasJSDoc bool, modifiersIn *NodeArray[ModifierLike]) Statement {
	switch token() {
	case SyntaxKindVarKeyword,
		SyntaxKindLetKeyword,
		SyntaxKindConstKeyword,
		SyntaxKindUsingKeyword,
		SyntaxKindAwaitKeyword:
		return parseVariableStatement(pos, hasJSDoc, modifiersIn)
	case SyntaxKindFunctionKeyword:
		return parseFunctionDeclaration(pos, hasJSDoc, modifiersIn)
	case SyntaxKindClassKeyword:
		return parseClassDeclaration(pos, hasJSDoc, modifiersIn)
	case SyntaxKindInterfaceKeyword:
		return parseInterfaceDeclaration(pos, hasJSDoc, modifiersIn)
	case SyntaxKindTypeKeyword:
		return parseTypeAliasDeclaration(pos, hasJSDoc, modifiersIn)
	case SyntaxKindEnumKeyword:
		return parseEnumDeclaration(pos, hasJSDoc, modifiersIn)
	case SyntaxKindGlobalKeyword,
		SyntaxKindModuleKeyword,
		SyntaxKindNamespaceKeyword:
		return parseModuleDeclaration(pos, hasJSDoc, modifiersIn)
	case SyntaxKindImportKeyword:
		return parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, modifiersIn)
	case SyntaxKindExportKeyword:
		nextToken()
		switch token() {
		case SyntaxKindDefaultKeyword,
			SyntaxKindEqualsToken:
			return parseExportAssignment(pos, hasJSDoc, modifiersIn)
		case SyntaxKindAsKeyword:
			return parseNamespaceExportDeclaration(pos, hasJSDoc, modifiersIn)
		default:
			return parseExportDeclaration(pos, hasJSDoc, modifiersIn)
		}
		fallthrough
	default:
		if modifiersIn {
			// We reached this point because we encountered decorators and/or modifiers and assumed a declaration
			// would follow. For recovery and error reporting purposes, return an incomplete declaration.
			missing := createMissingNode(SyntaxKindMissingDeclaration /*reportAtCurrentPosition*/, true, Diagnostics.Declaration_expected)
			setTextRangePos(missing, pos)
			(missing.(Mutable[MissingDeclaration])).modifiers = modifiersIn
			return missing
		}
		return nil
		// TODO: GH#18217
	}
}

func nextTokenIsStringLiteral() bool {
	return nextToken() == SyntaxKindStringLiteral
}

func nextTokenIsFromKeywordOrEqualsToken() bool {
	nextToken()
	return token() == SyntaxKindFromKeyword || token() == SyntaxKindEqualsToken
}

func nextTokenIsIdentifierOrStringLiteralOnSameLine() bool {
	nextToken()
	return !scanner.hasPrecedingLineBreak() && (isIdentifier() || token() == SyntaxKindStringLiteral)
}

func parseFunctionBlockOrSemicolon(flags SignatureFlags, diagnosticMessage DiagnosticMessage) *Block {
	if token() != SyntaxKindOpenBraceToken {
		if flags & SignatureFlagsType {
			parseTypeMemberSemicolon()
			return
		}
		if canParseSemicolon() {
			parseSemicolon()
			return
		}
	}
	return parseFunctionBlock(flags, diagnosticMessage)
}

// DECLARATIONS

func parseArrayBindingElement() ArrayBindingElement {
	pos := getNodePos()
	if token() == SyntaxKindCommaToken {
		return finishNode(factory.createOmittedExpression(), pos)
	}
	dotDotDotToken := parseOptionalToken(SyntaxKindDotDotDotToken)
	name := parseIdentifierOrPattern()
	initializer := parseInitializer()
	return finishNode(factory.createBindingElement(dotDotDotToken /*propertyName*/, nil, name, initializer), pos)
}

func parseObjectBindingElement() BindingElement {
	pos := getNodePos()
	dotDotDotToken := parseOptionalToken(SyntaxKindDotDotDotToken)
	tokenIsIdentifier := isBindingIdentifier()
	var propertyName *PropertyName = parsePropertyName()
	var name BindingName
	if tokenIsIdentifier && token() != SyntaxKindColonToken {
		name = propertyName.(Identifier)
		propertyName = nil
	} else {
		parseExpected(SyntaxKindColonToken)
		name = parseIdentifierOrPattern()
	}
	initializer := parseInitializer()
	return finishNode(factory.createBindingElement(dotDotDotToken, propertyName, name, initializer), pos)
}

func parseObjectBindingPattern() ObjectBindingPattern {
	pos := getNodePos()
	parseExpected(SyntaxKindOpenBraceToken)
	elements := allowInAnd(func() NodeArray[BindingElement] {
		return parseDelimitedList(ParsingContextObjectBindingElements, parseObjectBindingElement)
	})
	parseExpected(SyntaxKindCloseBraceToken)
	return finishNode(factory.createObjectBindingPattern(elements), pos)
}

func parseArrayBindingPattern() ArrayBindingPattern {
	pos := getNodePos()
	parseExpected(SyntaxKindOpenBracketToken)
	elements := allowInAnd(func() NodeArray[ArrayBindingElement] {
		return parseDelimitedList(ParsingContextArrayBindingElements, parseArrayBindingElement)
	})
	parseExpected(SyntaxKindCloseBracketToken)
	return finishNode(factory.createArrayBindingPattern(elements), pos)
}

func isBindingIdentifierOrPrivateIdentifierOrPattern() bool {
	return token() == SyntaxKindOpenBraceToken || token() == SyntaxKindOpenBracketToken || token() == SyntaxKindPrivateIdentifier || isBindingIdentifier()
}

func parseIdentifierOrPattern(privateIdentifierDiagnosticMessage DiagnosticMessage) /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | BindingPattern */ any {
	if token() == SyntaxKindOpenBracketToken {
		return parseArrayBindingPattern()
	}
	if token() == SyntaxKindOpenBraceToken {
		return parseObjectBindingPattern()
	}
	return parseBindingIdentifier(privateIdentifierDiagnosticMessage)
}

func parseVariableDeclarationAllowExclamation() VariableDeclaration {
	return parseVariableDeclaration(true)
}

func parseVariableDeclaration(allowExclamation bool) VariableDeclaration {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	name := parseIdentifierOrPattern(Diagnostics.Private_identifiers_are_not_allowed_in_variable_declarations)
	var exclamationToken *ExclamationToken
	if allowExclamation && name.kind == SyntaxKindIdentifier && token() == SyntaxKindExclamationToken && !scanner.hasPrecedingLineBreak() {
		exclamationToken = parseTokenNode()
	}
	type_ := parseTypeAnnotation()
	var initializer Expression
	if isInOrOfKeyword(token()) {
		initializer = nil
	} else {
		initializer = parseInitializer()
	}
	node := factoryCreateVariableDeclaration(name, exclamationToken, type_, initializer)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseVariableDeclarationList(inForStatementInitializer bool) VariableDeclarationList {
	pos := getNodePos()

	var flags NodeFlags = 0
	switch token() {
	case SyntaxKindVarKeyword:
	case SyntaxKindLetKeyword:
		flags |= NodeFlagsLet
	case SyntaxKindConstKeyword:
		flags |= NodeFlagsConst
	case SyntaxKindUsingKeyword:
		flags |= NodeFlagsUsing
	case SyntaxKindAwaitKeyword:
		Debug.assert(isAwaitUsingDeclaration())
		flags |= NodeFlagsAwaitUsing
		nextToken()
	default:
		Debug.fail()
	}

	nextToken()

	// The user may have written the following:
	//
	//    for (let of X) { }
	//
	// In this case, we want to parse an empty declaration list, and then parse 'of'
	// as a keyword. The reason this is not automatic is that 'of' is a valid identifier.
	// So we need to look ahead to determine if 'of' should be treated as a keyword in
	// this context.
	// The checker will then give an error that there is an empty declaration list.
	var declarations []VariableDeclaration
	if token() == SyntaxKindOfKeyword && lookAhead(canFollowContextualOfKeyword) {
		declarations = createMissingList()
	} else {
		savedDisallowIn := inDisallowInContext()
		setDisallowInContext(inForStatementInitializer)

		declarations = parseDelimitedList(ParsingContextVariableDeclarations, ifelse(inForStatementInitializer, parseVariableDeclaration, parseVariableDeclarationAllowExclamation))

		setDisallowInContext(savedDisallowIn)
	}

	return finishNode(factoryCreateVariableDeclarationList(declarations, flags), pos)
}

func canFollowContextualOfKeyword() bool {
	return nextTokenIsIdentifier() && nextToken() == SyntaxKindCloseParenToken
}

func parseVariableStatement(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) VariableStatement {
	declarationList := parseVariableDeclarationList(false)
	parseSemicolon()
	node := factoryCreateVariableStatement(modifiers, declarationList)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseFunctionDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) FunctionDeclaration {
	savedAwaitContext := inAwaitContext()
	modifierFlags := modifiersToFlags(modifiers)
	parseExpected(SyntaxKindFunctionKeyword)
	asteriskToken := parseOptionalToken(SyntaxKindAsteriskToken)
	// We don't parse the name here in await context, instead we will report a grammar error in the checker.
	var name *Identifier
	if modifierFlags & ModifierFlagsDefault {
		name = parseOptionalBindingIdentifier()
	} else {
		name = parseBindingIdentifier()
	}
	var isGenerator /* TODO(TS-TO-GO) inferred type SignatureFlags.None | SignatureFlags.Yield */ any
	if asteriskToken {
		isGenerator = SignatureFlagsYield
	} else {
		isGenerator = SignatureFlagsNone
	}
	var isAsync /* TODO(TS-TO-GO) inferred type SignatureFlags.None | SignatureFlags.Await */ any
	if modifierFlags & ModifierFlagsAsync {
		isAsync = SignatureFlagsAwait
	} else {
		isAsync = SignatureFlagsNone
	}
	typeParameters := parseTypeParameters()
	if modifierFlags & ModifierFlagsExport {
		setAwaitContext(true)
	}
	parameters := parseParameters(isGenerator | isAsync)
	type_ := parseReturnType(SyntaxKindColonToken /*isType*/, false)
	body := parseFunctionBlockOrSemicolon(isGenerator|isAsync, Diagnostics.or_expected)
	setAwaitContext(savedAwaitContext)
	node := factory.createFunctionDeclaration(modifiers, asteriskToken, name, typeParameters, parameters, type_, body)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseConstructorName() * /* TODO(TS-TO-GO) inferred type boolean | LiteralExpression */ any {
	if token() == SyntaxKindConstructorKeyword {
		return parseExpected(SyntaxKindConstructorKeyword)
	}
	if token() == SyntaxKindStringLiteral && lookAhead(nextToken) == SyntaxKindOpenParenToken {
		return tryParse(func() *LiteralExpression {
			literalNode := parseLiteralNode()
			if literalNode.text == "constructor" {
				return literalNode
			} else {
				return nil
			}
		})
	}
}

func tryParseConstructorDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) *ConstructorDeclaration {
	return tryParse(func() *ConstructorDeclaration {
		if parseConstructorName() {
			typeParameters := parseTypeParameters()
			parameters := parseParameters(SignatureFlagsNone)
			type_ := parseReturnType(SyntaxKindColonToken /*isType*/, false)
			body := parseFunctionBlockOrSemicolon(SignatureFlagsNone, Diagnostics.or_expected)
			node := factory.createConstructorDeclaration(modifiers, parameters, body)

			// Attach invalid nodes if they exist so that we can report them in the grammar checker.
			(node.(Mutable[ConstructorDeclaration])).typeParameters = typeParameters
			(node.(Mutable[ConstructorDeclaration])).type_ = type_
			return withJSDoc(finishNode(node, pos), hasJSDoc)
		}
	})
}

func parseMethodDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike], asteriskToken *AsteriskToken, name PropertyName, questionToken *QuestionToken, exclamationToken *ExclamationToken, diagnosticMessage DiagnosticMessage) MethodDeclaration {
	var isGenerator /* TODO(TS-TO-GO) inferred type SignatureFlags.None | SignatureFlags.Yield */ any
	if asteriskToken {
		isGenerator = SignatureFlagsYield
	} else {
		isGenerator = SignatureFlagsNone
	}
	var isAsync /* TODO(TS-TO-GO) inferred type SignatureFlags.None | SignatureFlags.Await */ any
	if some(modifiers, isAsyncModifier) {
		isAsync = SignatureFlagsAwait
	} else {
		isAsync = SignatureFlagsNone
	}
	typeParameters := parseTypeParameters()
	parameters := parseParameters(isGenerator | isAsync)
	type_ := parseReturnType(SyntaxKindColonToken /*isType*/, false)
	body := parseFunctionBlockOrSemicolon(isGenerator|isAsync, diagnosticMessage)
	node := factory.createMethodDeclaration(modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type_, body)

	// An exclamation token on a method is invalid syntax and will be handled by the grammar checker
	(node.(Mutable[MethodDeclaration])).exclamationToken = exclamationToken
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parsePropertyDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike], name PropertyName, questionToken *QuestionToken) PropertyDeclaration {
	var exclamationToken * /* TODO(TS-TO-GO) inferred type Token<SyntaxKind.ExclamationToken> */ any
	if !questionToken && !scanner.hasPrecedingLineBreak() {
		exclamationToken = parseOptionalToken(SyntaxKindExclamationToken)
	} else {
		exclamationToken = nil
	}
	type_ := parseTypeAnnotation()
	initializer := doOutsideOfContext(NodeFlagsYieldContext|NodeFlagsAwaitContext|NodeFlagsDisallowInContext, parseInitializer)
	parseSemicolonAfterPropertyName(name, type_, initializer)
	node := factory.createPropertyDeclaration(modifiers, name, questionToken || exclamationToken, type_, initializer)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parsePropertyOrMethodDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | MethodDeclaration */ any {
	asteriskToken := parseOptionalToken(SyntaxKindAsteriskToken)
	name := parsePropertyName()
	// Note: this is not legal as per the grammar.  But we allow it in the parser and
	// report an error in the grammar checker.
	questionToken := parseOptionalToken(SyntaxKindQuestionToken)
	if asteriskToken || token() == SyntaxKindOpenParenToken || token() == SyntaxKindLessThanToken {
		return parseMethodDeclaration(pos, hasJSDoc, modifiers, asteriskToken, name, questionToken /*exclamationToken*/, nil, Diagnostics.or_expected)
	}
	return parsePropertyDeclaration(pos, hasJSDoc, modifiers, name, questionToken)
}

func parseAccessorDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike], kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: AccessorDeclaration["kind"] */ any, flags SignatureFlags) AccessorDeclaration {
	name := parsePropertyName()
	typeParameters := parseTypeParameters()
	parameters := parseParameters(SignatureFlagsNone)
	type_ := parseReturnType(SyntaxKindColonToken /*isType*/, false)
	body := parseFunctionBlockOrSemicolon(flags)
	var node /* TODO(TS-TO-GO) inferred type GetAccessorDeclaration | SetAccessorDeclaration */ any
	if kind == SyntaxKindGetAccessor {
		node = factory.createGetAccessorDeclaration(modifiers, name, parameters, type_, body)
	} else {
		node = factory.createSetAccessorDeclaration(modifiers, name, parameters, body)
	}
	// Keep track of `typeParameters` (for both) and `type` (for setters) if they were parsed those indicate grammar errors
	(node.(Mutable[AccessorDeclaration])).typeParameters = typeParameters
	if isSetAccessorDeclaration(node) {
		(node.(Mutable[SetAccessorDeclaration])).type_ = type_
	}
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func isClassMemberStart() bool {
	var idToken *SyntaxKind

	if token() == SyntaxKindAtToken {
		return true
	}

	// Eat up all modifiers, but hold on to the last one in case it is actually an identifier.
	for isModifierKind(token()) {
		idToken = token()
		// If the idToken is a class modifier (protected, private, public, and static), it is
		// certain that we are starting to parse class member. This allows better error recovery
		// Example:
		//      public foo() ...     // true
		//      public @dec blah ... // true; we will then report an error later
		//      export public ...    // true; we will then report an error later
		if isClassMemberModifier(idToken) {
			return true
		}

		nextToken()
	}

	if token() == SyntaxKindAsteriskToken {
		return true
	}

	// Try to get the first property-like token following all modifiers.
	// This can either be an identifier or the 'get' or 'set' keywords.
	if isLiteralPropertyName() {
		idToken = token()
		nextToken()
	}

	// Index signatures and computed properties are class members; we can parse.
	if token() == SyntaxKindOpenBracketToken {
		return true
	}

	// If we were able to get any potential identifier...
	if idToken != nil {
		// If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.
		if !isKeyword(idToken) || idToken == SyntaxKindSetKeyword || idToken == SyntaxKindGetKeyword {
			return true
		}

		// If it *is* a keyword, but not an accessor, check a little farther along
		// to see if it should actually be parsed as a class member.
		switch token() {
		case SyntaxKindOpenParenToken,
			SyntaxKindLessThanToken,
			SyntaxKindExclamationToken,
			SyntaxKindColonToken,
			SyntaxKindEqualsToken,
			SyntaxKindQuestionToken:
			return true
		default:
			// Covers
			//  - Semicolons     (declaration termination)
			//  - Closing braces (end-of-class, must be declaration)
			//  - End-of-files   (not valid, but permitted so that it gets caught later on)
			//  - Line-breaks    (enabling *automatic semicolon insertion*)
			return canParseSemicolon()
		}
	}

	return false
}

func parseClassStaticBlockDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) ClassStaticBlockDeclaration {
	parseExpectedToken(SyntaxKindStaticKeyword)
	body := parseClassStaticBlockBody()
	node := withJSDoc(finishNode(factory.createClassStaticBlockDeclaration(body), pos), hasJSDoc)
	(node.(Mutable[ClassStaticBlockDeclaration])).modifiers = modifiers
	return node
}

func parseClassStaticBlockBody() Block {
	savedYieldContext := inYieldContext()
	savedAwaitContext := inAwaitContext()

	setYieldContext(false)
	setAwaitContext(true)

	body := parseBlock(false)

	setYieldContext(savedYieldContext)
	setAwaitContext(savedAwaitContext)

	return body
}

func parseDecoratorExpression() LeftHandSideExpression {
	if inAwaitContext() && token() == SyntaxKindAwaitKeyword {
		// `@await` is is disallowed in an [Await] context, but can cause parsing to go off the rails
		// This simply parses the missing identifier and moves on.
		pos := getNodePos()
		awaitExpression := parseIdentifier(Diagnostics.Expression_expected)
		nextToken()
		memberExpression := parseMemberExpressionRest(pos, awaitExpression /*allowOptionalChain*/, true)
		return parseCallExpressionRest(pos, memberExpression)
	}
	return parseLeftHandSideExpressionOrHigher()
}

func tryParseDecorator() *Decorator {
	pos := getNodePos()
	if !parseOptional(SyntaxKindAtToken) {
		return nil
	}
	expression := doInDecoratorContext(parseDecoratorExpression)
	return finishNode(factory.createDecorator(expression), pos)
}

func tryParseModifier(hasSeenStaticModifier bool, permitConstAsModifier bool, stopOnStartOfClassStaticBlock bool) *Modifier {
	pos := getNodePos()
	kind := token()

	if token() == SyntaxKindConstKeyword && permitConstAsModifier {
		// We need to ensure that any subsequent modifiers appear on the same line
		// so that when 'const' is a standalone declaration, we don't issue an error.
		if !tryParse(nextTokenIsOnSameLineAndCanFollowModifier) {
			return nil
		}
	} else if stopOnStartOfClassStaticBlock && token() == SyntaxKindStaticKeyword && lookAhead(nextTokenIsOpenBrace) {
		return nil
	} else if hasSeenStaticModifier && token() == SyntaxKindStaticKeyword {
		return nil
	} else {
		if !parseAnyContextualModifier() {
			return nil
		}
	}

	return finishNode(factoryCreateToken(kind /* as Modifier["kind"] */), pos)
}

/*
 * There are situations in which a modifier like 'const' will appear unexpectedly, such as on a class member.
 * In those situations, if we are entirely sure that 'const' is not valid on its own (such as when ASI takes effect
 * and turns it into a standalone declaration), then it is better to parse it and report an error later.
 *
 * In such situations, 'permitConstAsModifier' should be set to true.
 */
/* OVERLOAD: function parseModifiers(allowDecorators: false, permitConstAsModifier?: boolean, stopOnStartOfClassStaticBlock?: boolean): NodeArray<Modifier> | undefined; */
/* OVERLOAD: function parseModifiers(allowDecorators: true, permitConstAsModifier?: boolean, stopOnStartOfClassStaticBlock?: boolean): NodeArray<ModifierLike> | undefined; */
func parseModifiers(allowDecorators bool, permitConstAsModifier bool, stopOnStartOfClassStaticBlock bool) *NodeArray[ModifierLike] {
	pos := getNodePos()
	var list *[]ModifierLike
	var decorator TODO
	var modifier TODO
	hasSeenStaticModifier := false
	hasLeadingModifier := false
	hasTrailingDecorator := false

	// Decorators should be contiguous in a list of modifiers but can potentially appear in two places (i.e., `[...leadingDecorators, ...leadingModifiers, ...trailingDecorators, ...trailingModifiers]`).
	// The leading modifiers *should* only contain `export` and `default` when trailingDecorators are present, but we'll handle errors for any other leading modifiers in the checker.
	// It is illegal to have both leadingDecorators and trailingDecorators, but we will report that as a grammar check in the checker.

	// parse leading decorators
	if allowDecorators && token() == SyntaxKindAtToken {
		for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: decorator = tryParseDecorator() */ TODO {
			list = append(list, decorator)
		}
	}

	// parse leading modifiers
	for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: modifier = tryParseModifier(hasSeenStaticModifier, permitConstAsModifier, stopOnStartOfClassStaticBlock) */ TODO {
		if modifier.kind == SyntaxKindStaticKeyword {
			hasSeenStaticModifier = true
		}
		list = append(list, modifier)
		hasLeadingModifier = true
	}

	// parse trailing decorators, but only if we parsed any leading modifiers
	if hasLeadingModifier && allowDecorators && token() == SyntaxKindAtToken {
		for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: decorator = tryParseDecorator() */ TODO {
			list = append(list, decorator)
			hasTrailingDecorator = true
		}
	}

	// parse trailing modifiers, but only if we parsed any trailing decorators
	if hasTrailingDecorator {
		for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: modifier = tryParseModifier(hasSeenStaticModifier, permitConstAsModifier, stopOnStartOfClassStaticBlock) */ TODO {
			if modifier.kind == SyntaxKindStaticKeyword {
				hasSeenStaticModifier = true
			}
			list = append(list, modifier)
		}
	}

	return list && createNodeArray(list, pos)
}

func parseModifiersForArrowFunction() *NodeArray[Modifier] {
	var modifiers *NodeArray[Modifier]
	if token() == SyntaxKindAsyncKeyword {
		pos := getNodePos()
		nextToken()
		modifier := finishNode(factoryCreateToken(SyntaxKindAsyncKeyword), pos)
		modifiers = createNodeArray([] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.AsyncKeyword> */ any{modifier}, pos)
	}
	return modifiers
}

func parseClassElement() ClassElement {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	if token() == SyntaxKindSemicolonToken {
		nextToken()
		return withJSDoc(finishNode(factory.createSemicolonClassElement(), pos), hasJSDoc)
	}

	modifiers := parseModifiers(true /*permitConstAsModifier*/, true /*stopOnStartOfClassStaticBlock*/, true)
	if token() == SyntaxKindStaticKeyword && lookAhead(nextTokenIsOpenBrace) {
		return parseClassStaticBlockDeclaration(pos, hasJSDoc, modifiers)
	}

	if parseContextualModifier(SyntaxKindGetKeyword) {
		return parseAccessorDeclaration(pos, hasJSDoc, modifiers, SyntaxKindGetAccessor, SignatureFlagsNone)
	}

	if parseContextualModifier(SyntaxKindSetKeyword) {
		return parseAccessorDeclaration(pos, hasJSDoc, modifiers, SyntaxKindSetAccessor, SignatureFlagsNone)
	}

	if token() == SyntaxKindConstructorKeyword || token() == SyntaxKindStringLiteral {
		constructorDeclaration := tryParseConstructorDeclaration(pos, hasJSDoc, modifiers)
		if constructorDeclaration {
			return constructorDeclaration
		}
	}

	if isIndexSignature() {
		return parseIndexSignatureDeclaration(pos, hasJSDoc, modifiers)
	}

	// It is very important that we check this *after* checking indexers because
	// the [ token can start an index signature or a computed property name
	if tokenIsIdentifierOrKeyword(token()) || token() == SyntaxKindStringLiteral || token() == SyntaxKindNumericLiteral || token() == SyntaxKindBigIntLiteral || token() == SyntaxKindAsteriskToken || token() == SyntaxKindOpenBracketToken {
		isAmbient := some(modifiers, isDeclareModifier)
		if isAmbient {
			for _, m := range modifiers {
				(m.(Mutable[Node])).flags |= NodeFlagsAmbient
			}
			return doInsideOfContext(NodeFlagsAmbient, func() /* TODO(TS-TO-GO) inferred type MethodDeclaration | PropertyDeclaration */ any {
				return parsePropertyOrMethodDeclaration(pos, hasJSDoc, modifiers)
			})
		} else {
			return parsePropertyOrMethodDeclaration(pos, hasJSDoc, modifiers)
		}
	}

	if modifiers {
		// treat this as a property declaration with a missing name.
		name := createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, true, Diagnostics.Declaration_expected)
		return parsePropertyDeclaration(pos, hasJSDoc, modifiers, name /*questionToken*/, nil)
	}

	// 'isClassMemberStart' should have hinted not to attempt parsing.
	return Debug.fail("Should not have attempted to parse class member declaration.")
}

func parseDecoratedExpression() PrimaryExpression {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	modifiers := parseModifiers(true)
	if token() == SyntaxKindClassKeyword {
		return parseClassDeclarationOrExpression(pos, hasJSDoc, modifiers, SyntaxKindClassExpression).(ClassExpression)
	}

	missing := createMissingNode(SyntaxKindMissingDeclaration /*reportAtCurrentPosition*/, true, Diagnostics.Expression_expected)
	setTextRangePos(missing, pos)
	(missing.(Mutable[MissingDeclaration])).modifiers = modifiers
	return missing
}

func parseClassExpression() ClassExpression {
	return parseClassDeclarationOrExpression(getNodePos(), hasPrecedingJSDocComment() /*modifiers*/, nil, SyntaxKindClassExpression).(ClassExpression)
}

func parseClassDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) ClassDeclaration {
	return parseClassDeclarationOrExpression(pos, hasJSDoc, modifiers, SyntaxKindClassDeclaration).(ClassDeclaration)
}

func parseClassDeclarationOrExpression(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike], kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: ClassLikeDeclaration["kind"] */ any) ClassLikeDeclaration {
	savedAwaitContext := inAwaitContext()
	parseExpected(SyntaxKindClassKeyword)

	// We don't parse the name here in await context, instead we will report a grammar error in the checker.
	name := parseNameOfClassDeclarationOrExpression()
	typeParameters := parseTypeParameters()
	if some(modifiers, isExportModifier) {
		setAwaitContext(true)
	}
	heritageClauses := parseHeritageClauses()

	var members TODO
	if parseExpected(SyntaxKindOpenBraceToken) {
		// ClassTail[Yield,Await] : (Modified) See 14.5
		//      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }
		members = parseClassMembers()
		parseExpected(SyntaxKindCloseBraceToken)
	} else {
		members = createMissingList()
	}
	setAwaitContext(savedAwaitContext)
	var node /* TODO(TS-TO-GO) inferred type ClassDeclaration | ClassExpression */ any
	if kind == SyntaxKindClassDeclaration {
		node = factory.createClassDeclaration(modifiers, name, typeParameters, heritageClauses, members)
	} else {
		node = factory.createClassExpression(modifiers, name, typeParameters, heritageClauses, members)
	}
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseNameOfClassDeclarationOrExpression() *Identifier {
	// implements is a future reserved word so
	// 'class implements' might mean either
	// - class expression with omitted name, 'implements' starts heritage clause
	// - class with name 'implements'
	// 'isImplementsClause' helps to disambiguate between these two cases
	if isBindingIdentifier() && !isImplementsClause() {
		return createIdentifier(isBindingIdentifier())
	} else {
		return nil
	}
}

func isImplementsClause() bool {
	return token() == SyntaxKindImplementsKeyword && lookAhead(nextTokenIsIdentifierOrKeyword)
}

func parseHeritageClauses() *NodeArray[HeritageClause] {
	// ClassTail[Yield,Await] : (Modified) See 14.5
	//      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }

	if isHeritageClause() {
		return parseList(ParsingContextHeritageClauses, parseHeritageClause)
	}

	return nil
}

func parseHeritageClause() HeritageClause {
	pos := getNodePos()
	tok := token()
	Debug.assert(tok == SyntaxKindExtendsKeyword || tok == SyntaxKindImplementsKeyword)
	// isListElement() should ensure this.
	nextToken()
	types := parseDelimitedList(ParsingContextHeritageClauseElement, parseExpressionWithTypeArguments)
	return finishNode(factory.createHeritageClause(tok, types), pos)
}

func parseExpressionWithTypeArguments() ExpressionWithTypeArguments {
	pos := getNodePos()
	expression := parseLeftHandSideExpressionOrHigher()
	if expression.kind == SyntaxKindExpressionWithTypeArguments {
		return expression.(ExpressionWithTypeArguments)
	}
	typeArguments := tryParseTypeArguments()
	return finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos)
}

func tryParseTypeArguments() *NodeArray[TypeNode] {
	if token() == SyntaxKindLessThanToken {
		return parseBracketedList(ParsingContextTypeArguments, parseType, SyntaxKindLessThanToken, SyntaxKindGreaterThanToken)
	} else {
		return nil
	}
}

func isHeritageClause() bool {
	return token() == SyntaxKindExtendsKeyword || token() == SyntaxKindImplementsKeyword
}

func parseClassMembers() NodeArray[ClassElement] {
	return parseList(ParsingContextClassMembers, parseClassElement)
}

func parseInterfaceDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) InterfaceDeclaration {
	parseExpected(SyntaxKindInterfaceKeyword)
	name := parseIdentifier()
	typeParameters := parseTypeParameters()
	heritageClauses := parseHeritageClauses()
	members := parseObjectTypeMembers()
	node := factory.createInterfaceDeclaration(modifiers, name, typeParameters, heritageClauses, members)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseTypeAliasDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) TypeAliasDeclaration {
	parseExpected(SyntaxKindTypeKeyword)
	if scanner.hasPrecedingLineBreak() {
		parseErrorAtCurrentToken(Diagnostics.Line_break_not_permitted_here)
	}
	name := parseIdentifier()
	typeParameters := parseTypeParameters()
	parseExpected(SyntaxKindEqualsToken)
	type_ := token() == SyntaxKindIntrinsicKeyword && tryParse(parseKeywordAndNoDot) || parseType()
	parseSemicolon()
	node := factory.createTypeAliasDeclaration(modifiers, name, typeParameters, type_)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

// In an ambient declaration, the grammar only allows integer literals as initializers.
// In a non-ambient declaration, the grammar allows uninitialized members only in a
// ConstantEnumMemberSection, which starts at the beginning of an enum declaration
// or any time an integer literal initializer is encountered.
func parseEnumMember() EnumMember {
	pos := getNodePos()
	hasJSDoc := hasPrecedingJSDocComment()
	name := parsePropertyName()
	initializer := allowInAnd(parseInitializer)
	return withJSDoc(finishNode(factory.createEnumMember(name, initializer), pos), hasJSDoc)
}

func parseEnumDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) EnumDeclaration {
	parseExpected(SyntaxKindEnumKeyword)
	name := parseIdentifier()
	var members TODO
	if parseExpected(SyntaxKindOpenBraceToken) {
		members = doOutsideOfYieldAndAwaitContext(func() NodeArray[EnumMember] {
			return parseDelimitedList(ParsingContextEnumMembers, parseEnumMember)
		})
		parseExpected(SyntaxKindCloseBraceToken)
	} else {
		members = createMissingList()
	}
	node := factory.createEnumDeclaration(modifiers, name, members)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseModuleBlock() ModuleBlock {
	pos := getNodePos()
	var statements TODO
	if parseExpected(SyntaxKindOpenBraceToken) {
		statements = parseList(ParsingContextBlockStatements, parseStatement)
		parseExpected(SyntaxKindCloseBraceToken)
	} else {
		statements = createMissingList()
	}
	return finishNode(factory.createModuleBlock(statements), pos)
}

func parseModuleOrNamespaceDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike], flags NodeFlags) ModuleDeclaration {
	// If we are parsing a dotted namespace name, we want to
	// propagate the 'Namespace' flag across the names if set.
	namespaceFlag := flags & NodeFlagsNamespace
	var name Identifier
	if flags & NodeFlagsNestedNamespace {
		name = parseIdentifierName()
	} else {
		name = parseIdentifier()
	}
	var body /* TODO(TS-TO-GO) inferred type ModuleBlock | NamespaceDeclaration */ any
	if parseOptional(SyntaxKindDotToken) {
		body = parseModuleOrNamespaceDeclaration(getNodePos() /*hasJSDoc*/, false /*modifiers*/, nil, NodeFlagsNestedNamespace|namespaceFlag).(NamespaceDeclaration)
	} else {
		body = parseModuleBlock()
	}
	node := factory.createModuleDeclaration(modifiers, name, body, flags)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseAmbientExternalModuleDeclaration(pos number, hasJSDoc bool, modifiersIn *NodeArray[ModifierLike]) ModuleDeclaration {
	var flags NodeFlags = 0
	var name TODO
	if token() == SyntaxKindGlobalKeyword {
		// parse 'global' as name of global scope augmentation
		name = parseIdentifier()
		flags |= NodeFlagsGlobalAugmentation
	} else {
		name = parseLiteralNode().(StringLiteral)
		name.text = internIdentifier(name.text)
	}
	var body *ModuleBlock
	if token() == SyntaxKindOpenBraceToken {
		body = parseModuleBlock()
	} else {
		parseSemicolon()
	}
	node := factory.createModuleDeclaration(modifiersIn, name, body, flags)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseModuleDeclaration(pos number, hasJSDoc bool, modifiersIn *NodeArray[ModifierLike]) ModuleDeclaration {
	var flags NodeFlags = 0
	if token() == SyntaxKindGlobalKeyword {
		// global augmentation
		return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, modifiersIn)
	} else if parseOptional(SyntaxKindNamespaceKeyword) {
		flags |= NodeFlagsNamespace
	} else {
		parseExpected(SyntaxKindModuleKeyword)
		if token() == SyntaxKindStringLiteral {
			return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, modifiersIn)
		}
	}
	return parseModuleOrNamespaceDeclaration(pos, hasJSDoc, modifiersIn, flags)
}

func isExternalModuleReference() bool {
	return token() == SyntaxKindRequireKeyword && lookAhead(nextTokenIsOpenParen)
}

func nextTokenIsOpenParen() bool {
	return nextToken() == SyntaxKindOpenParenToken
}

func nextTokenIsOpenBrace() bool {
	return nextToken() == SyntaxKindOpenBraceToken
}

func nextTokenIsSlash() bool {
	return nextToken() == SyntaxKindSlashToken
}

func parseNamespaceExportDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) NamespaceExportDeclaration {
	parseExpected(SyntaxKindAsKeyword)
	parseExpected(SyntaxKindNamespaceKeyword)
	name := parseIdentifier()
	parseSemicolon()
	node := factory.createNamespaceExportDeclaration(name)
	// NamespaceExportDeclaration nodes cannot have decorators or modifiers, so we attach them here so we can report them in the grammar checker
	(node.(Mutable[NamespaceExportDeclaration])).modifiers = modifiers
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseImportDeclarationOrImportEqualsDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ImportDeclaration */ any {
	parseExpected(SyntaxKindImportKeyword)

	afterImportPos := scanner.getTokenFullStart()

	// We don't parse the identifier here in await context, instead we will report a grammar error in the checker.
	var identifier *Identifier
	if isIdentifier() {
		identifier = parseIdentifier()
	}

	isTypeOnly := false
	if identifier. /* ? */ escapedText == "type" && (token() != SyntaxKindFromKeyword || isIdentifier() && lookAhead(nextTokenIsFromKeywordOrEqualsToken)) && (isIdentifier() || tokenAfterImportDefinitelyProducesImportDeclaration()) {
		isTypeOnly = true
		if isIdentifier() {
			identifier = parseIdentifier()
		} else {
			identifier = nil
		}
	}

	if identifier && !tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration() {
		return parseImportEqualsDeclaration(pos, hasJSDoc, modifiers, identifier, isTypeOnly)
	}

	importClause := tryParseImportClause(identifier, afterImportPos, isTypeOnly)
	moduleSpecifier := parseModuleSpecifier()
	attributes := tryParseImportAttributes()

	parseSemicolon()
	node := factory.createImportDeclaration(modifiers, importClause, moduleSpecifier, attributes)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func tryParseImportClause(identifier *Identifier, pos number, isTypeOnly bool, skipJsDocLeadingAsterisks bool /*  = false */) *ImportClause {
	// ImportDeclaration:
	//  import ImportClause from ModuleSpecifier ;
	//  import ModuleSpecifier;
	var importClause *ImportClause
	if identifier || token() == SyntaxKindAsteriskToken || token() == SyntaxKindOpenBraceToken {
		importClause = parseImportClause(identifier, pos, isTypeOnly, skipJsDocLeadingAsterisks)
		parseExpected(SyntaxKindFromKeyword)
	}
	return importClause
}

func tryParseImportAttributes() *ImportAttributes {
	currentToken := token()
	if (currentToken == SyntaxKindWithKeyword || currentToken == SyntaxKindAssertKeyword) && !scanner.hasPrecedingLineBreak() {
		return parseImportAttributes(currentToken)
	}
}

func parseImportAttribute() ImportAttribute {
	pos := getNodePos()
	var name /* TODO(TS-TO-GO) inferred type StringLiteral | Identifier */ any
	if tokenIsIdentifierOrKeyword(token()) {
		name = parseIdentifierName()
	} else {
		name = parseLiteralLikeNode(SyntaxKindStringLiteral).(StringLiteral)
	}
	parseExpected(SyntaxKindColonToken)
	value := parseAssignmentExpressionOrHigher(true)
	return finishNode(factory.createImportAttribute(name, value), pos)
}

func parseImportAttributes(token /* TODO(TS-TO-GO) TypeNode UnionType: SyntaxKind.AssertKeyword | SyntaxKind.WithKeyword */ any, skipKeyword /* TODO(TS-TO-GO) TypeNode LiteralType: true */ any) ImportAttributes {
	pos := getNodePos()
	if !skipKeyword {
		parseExpected(token)
	}
	openBracePosition := scanner.getTokenStart()
	if parseExpected(SyntaxKindOpenBraceToken) {
		multiLine := scanner.hasPrecedingLineBreak()
		elements := parseDelimitedList(ParsingContextImportAttributes, parseImportAttribute /*considerSemicolonAsDelimiter*/, true)
		if !parseExpected(SyntaxKindCloseBraceToken) {
			lastError := lastOrUndefined(parseDiagnostics)
			if lastError && lastError.code == Diagnostics._0_expected.code {
				addRelatedInfo(lastError, createDetachedDiagnostic(fileName, sourceText, openBracePosition, 1, Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"))
			}
		}
		return finishNode(factory.createImportAttributes(elements, multiLine, token), pos)
	} else {
		elements := createNodeArray([]never{}, getNodePos() /*end*/, nil /*hasTrailingComma*/, false)
		return finishNode(factory.createImportAttributes(elements /*multiLine*/, false, token), pos)
	}
}

func tokenAfterImportDefinitelyProducesImportDeclaration() bool {
	return token() == SyntaxKindAsteriskToken || token() == SyntaxKindOpenBraceToken
}

func tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration() bool {
	// In `import id ___`, the current token decides whether to produce
	// an ImportDeclaration or ImportEqualsDeclaration.
	return token() == SyntaxKindCommaToken || token() == SyntaxKindFromKeyword
}

func parseImportEqualsDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike], identifier Identifier, isTypeOnly bool) ImportEqualsDeclaration {
	parseExpected(SyntaxKindEqualsToken)
	moduleReference := parseModuleReference()
	parseSemicolon()
	node := factory.createImportEqualsDeclaration(modifiers, isTypeOnly, identifier, moduleReference)
	finished := withJSDoc(finishNode(node, pos), hasJSDoc)
	return finished
}

func parseImportClause(identifier *Identifier, pos number, isTypeOnly bool, skipJsDocLeadingAsterisks bool) ImportClause {
	// ImportClause:
	//  ImportedDefaultBinding
	//  NameSpaceImport
	//  NamedImports
	//  ImportedDefaultBinding, NameSpaceImport
	//  ImportedDefaultBinding, NamedImports

	// If there was no default import or if there is comma token after default import
	// parse namespace or named imports
	var namedBindings /* TODO(TS-TO-GO) TypeNode UnionType: NamespaceImport | NamedImports | undefined */ any
	if !identifier || parseOptional(SyntaxKindCommaToken) {
		if skipJsDocLeadingAsterisks {
			scanner.setSkipJsDocLeadingAsterisks(true)
		}
		if token() == SyntaxKindAsteriskToken {
			namedBindings = parseNamespaceImport()
		} else {
			namedBindings = parseNamedImportsOrExports(SyntaxKindNamedImports)
		}
		if skipJsDocLeadingAsterisks {
			scanner.setSkipJsDocLeadingAsterisks(false)
		}
	}

	return finishNode(factory.createImportClause(isTypeOnly, identifier, namedBindings), pos)
}

func parseModuleReference() /* TODO(TS-TO-GO) inferred type EntityName | ExternalModuleReference */ any {
	if isExternalModuleReference() {
		return parseExternalModuleReference()
	} else {
		return parseEntityName(false)
	}
}

func parseExternalModuleReference() ExternalModuleReference {
	pos := getNodePos()
	parseExpected(SyntaxKindRequireKeyword)
	parseExpected(SyntaxKindOpenParenToken)
	expression := parseModuleSpecifier()
	parseExpected(SyntaxKindCloseParenToken)
	return finishNode(factory.createExternalModuleReference(expression), pos)
}

func parseModuleSpecifier() Expression {
	if token() == SyntaxKindStringLiteral {
		result := parseLiteralNode()
		result.text = internIdentifier(result.text)
		return result
	} else {
		// We allow arbitrary expressions here, even though the grammar only allows string
		// literals.  We check to ensure that it is only a string literal later in the grammar
		// check pass.
		return parseExpression()
	}
}

func parseNamespaceImport() NamespaceImport {
	// NameSpaceImport:
	//  * as ImportedBinding
	pos := getNodePos()
	parseExpected(SyntaxKindAsteriskToken)
	parseExpected(SyntaxKindAsKeyword)
	name := parseIdentifier()
	return finishNode(factory.createNamespaceImport(name), pos)
}

func canParseModuleExportName() bool {
	return tokenIsIdentifierOrKeyword(token()) || token() == SyntaxKindStringLiteral
}

func parseModuleExportName(parseName func() Identifier) ModuleExportName {
	if token() == SyntaxKindStringLiteral {
		return parseLiteralNode().(StringLiteral)
	} else {
		return parseName()
	}
}

/* OVERLOAD: function parseNamedImportsOrExports(kind: SyntaxKind.NamedImports): NamedImports; */
/* OVERLOAD: function parseNamedImportsOrExports(kind: SyntaxKind.NamedExports): NamedExports; */
func parseNamedImportsOrExports(kind SyntaxKind) NamedImportsOrExports {
	pos := getNodePos()

	// NamedImports:
	//  { }
	//  { ImportsList }
	//  { ImportsList, }

	// ImportsList:
	//  ImportSpecifier
	//  ImportsList, ImportSpecifier
	var node /* TODO(TS-TO-GO) inferred type NamedExports | NamedImports */ any
	if kind == SyntaxKindNamedImports {
		node = factory.createNamedImports(parseBracketedList(ParsingContextImportOrExportSpecifiers, parseImportSpecifier, SyntaxKindOpenBraceToken, SyntaxKindCloseBraceToken))
	} else {
		node = factory.createNamedExports(parseBracketedList(ParsingContextImportOrExportSpecifiers, parseExportSpecifier, SyntaxKindOpenBraceToken, SyntaxKindCloseBraceToken))
	}
	return finishNode(node, pos)
}

func parseExportSpecifier() ExportSpecifier {
	hasJSDoc := hasPrecedingJSDocComment()
	return withJSDoc(parseImportOrExportSpecifier(SyntaxKindExportSpecifier).(ExportSpecifier), hasJSDoc)
}

func parseImportSpecifier() ImportSpecifier {
	return parseImportOrExportSpecifier(SyntaxKindImportSpecifier).(ImportSpecifier)
}

func parseImportOrExportSpecifier(kind SyntaxKind) ImportOrExportSpecifier {
	pos := getNodePos()
	// ImportSpecifier:
	//   BindingIdentifier
	//   ModuleExportName as BindingIdentifier
	// ExportSpecifier:
	//   ModuleExportName
	//   ModuleExportName as ModuleExportName
	checkIdentifierIsKeyword := isKeyword(token()) && !isIdentifier()
	checkIdentifierStart := scanner.getTokenStart()
	checkIdentifierEnd := scanner.getTokenEnd()
	isTypeOnly := false
	var propertyName *ModuleExportName
	canParseAsKeyword := true
	name := parseModuleExportName(parseIdentifierName)
	if name.kind == SyntaxKindIdentifier && name.escapedText == "type" {
		// If the first token of an import specifier is 'type', there are a lot of possibilities,
		// especially if we see 'as' afterwards:
		//
		// import { type } from "mod";          - isTypeOnly: false,   name: type
		// import { type as } from "mod";       - isTypeOnly: true,    name: as
		// import { type as as } from "mod";    - isTypeOnly: false,   name: as,    propertyName: type
		// import { type as as as } from "mod"; - isTypeOnly: true,    name: as,    propertyName: as
		if token() == SyntaxKindAsKeyword {
			// { type as ...? }
			firstAs := parseIdentifierName()
			if token() == SyntaxKindAsKeyword {
				// { type as as ...? }
				secondAs := parseIdentifierName()
				if canParseModuleExportName() {
					// { type as as something }
					// { type as as "something" }
					isTypeOnly = true
					propertyName = firstAs
					name = parseModuleExportName(parseNameWithKeywordCheck)
					canParseAsKeyword = false
				} else {
					// { type as as }
					propertyName = name
					name = secondAs
					canParseAsKeyword = false
				}
			} else if canParseModuleExportName() {
				// { type as something }
				// { type as "something" }
				propertyName = name
				canParseAsKeyword = false
				name = parseModuleExportName(parseNameWithKeywordCheck)
			} else {
				// { type as }
				isTypeOnly = true
				name = firstAs
			}
		} else if canParseModuleExportName() {
			// { type something ...? }
			// { type "something" ...? }
			isTypeOnly = true
			name = parseModuleExportName(parseNameWithKeywordCheck)
		}
	}

	if canParseAsKeyword && token() == SyntaxKindAsKeyword {
		propertyName = name
		parseExpected(SyntaxKindAsKeyword)
		name = parseModuleExportName(parseNameWithKeywordCheck)
	}
	if kind == SyntaxKindImportSpecifier {
		if name.kind != SyntaxKindIdentifier {
			// ImportSpecifier casts "name" to Identifier below, so make sure it's an identifier
			parseErrorAt(skipTrivia(sourceText, name.pos), name.end, Diagnostics.Identifier_expected)
			name = setTextRangePosEnd(createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, false), name.pos, name.pos)
		} else if checkIdentifierIsKeyword {
			parseErrorAt(checkIdentifierStart, checkIdentifierEnd, Diagnostics.Identifier_expected)
		}
	}
	var node /* TODO(TS-TO-GO) inferred type ExportSpecifier | ImportSpecifier */ any
	if kind == SyntaxKindImportSpecifier {
		node = factory.createImportSpecifier(isTypeOnly, propertyName, name.(Identifier))
	} else {
		node = factory.createExportSpecifier(isTypeOnly, propertyName, name)
	}
	return finishNode(node, pos)

	parseNameWithKeywordCheck := func() Identifier {
		checkIdentifierIsKeyword = isKeyword(token()) && !isIdentifier()
		checkIdentifierStart = scanner.getTokenStart()
		checkIdentifierEnd = scanner.getTokenEnd()
		return parseIdentifierName()
	}

}

func parseNamespaceExport(pos number) NamespaceExport {
	return finishNode(factory.createNamespaceExport(parseModuleExportName(parseIdentifierName)), pos)
}

func parseExportDeclaration(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) ExportDeclaration {
	savedAwaitContext := inAwaitContext()
	setAwaitContext(true)
	var exportClause *NamedExportBindings
	var moduleSpecifier Expression
	var attributes *ImportAttributes
	isTypeOnly := parseOptional(SyntaxKindTypeKeyword)
	namespaceExportPos := getNodePos()
	if parseOptional(SyntaxKindAsteriskToken) {
		if parseOptional(SyntaxKindAsKeyword) {
			exportClause = parseNamespaceExport(namespaceExportPos)
		}
		parseExpected(SyntaxKindFromKeyword)
		moduleSpecifier = parseModuleSpecifier()
	} else {
		exportClause = parseNamedImportsOrExports(SyntaxKindNamedExports)
		// It is not uncommon to accidentally omit the 'from' keyword. Additionally, in editing scenarios,
		// the 'from' keyword can be parsed as a named export when the export clause is unterminated (i.e. `export { from "moduleName";`)
		// If we don't have a 'from' keyword, see if we have a string literal such that ASI won't take effect.
		if token() == SyntaxKindFromKeyword || (token() == SyntaxKindStringLiteral && !scanner.hasPrecedingLineBreak()) {
			parseExpected(SyntaxKindFromKeyword)
			moduleSpecifier = parseModuleSpecifier()
		}
	}
	currentToken := token()
	if moduleSpecifier && (currentToken == SyntaxKindWithKeyword || currentToken == SyntaxKindAssertKeyword) && !scanner.hasPrecedingLineBreak() {
		attributes = parseImportAttributes(currentToken)
	}
	parseSemicolon()
	setAwaitContext(savedAwaitContext)
	node := factory.createExportDeclaration(modifiers, isTypeOnly, exportClause, moduleSpecifier, attributes)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

func parseExportAssignment(pos number, hasJSDoc bool, modifiers *NodeArray[ModifierLike]) ExportAssignment {
	savedAwaitContext := inAwaitContext()
	setAwaitContext(true)
	var isExportEquals *bool
	if parseOptional(SyntaxKindEqualsToken) {
		isExportEquals = true
	} else {
		parseExpected(SyntaxKindDefaultKeyword)
	}
	expression := parseAssignmentExpressionOrHigher(true)
	parseSemicolon()
	setAwaitContext(savedAwaitContext)
	node := factory.createExportAssignment(modifiers, isExportEquals, expression)
	return withJSDoc(finishNode(node, pos), hasJSDoc)
}

// dprint-ignore
type ParsingContext int32

const (
	ParsingContextSourceElements ParsingContext = iota
	ParsingContextBlockStatements
	ParsingContextSwitchClauses
	ParsingContextSwitchClauseStatements
	ParsingContextTypeMembers
	ParsingContextClassMembers
	ParsingContextEnumMembers
	ParsingContextHeritageClauseElement
	ParsingContextVariableDeclarations
	ParsingContextObjectBindingElements
	ParsingContextArrayBindingElements
	ParsingContextArgumentExpressions
	ParsingContextObjectLiteralMembers
	ParsingContextJsxAttributes
	ParsingContextJsxChildren
	ParsingContextArrayLiteralMembers
	ParsingContextParameters
	ParsingContextJSDocParameters
	ParsingContextRestProperties
	ParsingContextTypeParameters
	ParsingContextTypeArguments
	ParsingContextTupleElementTypes
	ParsingContextHeritageClauses
	ParsingContextImportOrExportSpecifiers
	ParsingContextImportAttributes
	ParsingContextJSDocComment
	ParsingContextCount
)

type Tristate int32

const (
	TristateFalse Tristate = iota
	TristateTrue
	TristateUnknown
)

// #region JSDocParser

func parseJSDocTypeExpressionForTests(content string, start *number, length *number) * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { jsDocTypeExpression: JSDocTypeExpression; diagnostics: Diagnostic[]; } */ any {
	initializeState("file.js", content, ScriptTargetLatest /*syntaxCursor*/, nil, ScriptKindJS, JSDocParsingModeParseAll)
	scanner.setText(content, start, length)
	currentToken = scanner.scan()
	jsDocTypeExpression := parseJSDocTypeExpression()

	sourceFile := createSourceFile("file.js", ScriptTargetLatest, ScriptKindJS /*isDeclarationFile*/, false, []never{}, factoryCreateToken(SyntaxKindEndOfFileToken), NodeFlagsNone, noop)
	diagnostics := attachFileToDiagnostics(parseDiagnostics, sourceFile)
	if jsDocDiagnostics {
		sourceFile.jsDocDiagnostics = attachFileToDiagnostics(jsDocDiagnostics, sourceFile)
	}

	clearState()

	if jsDocTypeExpression {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"jsDocTypeExpression": jsDocTypeExpression,
			"diagnostics":         diagnostics,
		}
	} else {
		return nil
	}
}

// Parses out a JSDoc type expression.
func parseJSDocTypeExpression(mayOmitBraces bool) JSDocTypeExpression {
	pos := getNodePos()
	hasBrace := (ifelse(mayOmitBraces, parseOptional, parseExpected))(SyntaxKindOpenBraceToken)
	type_ := doInsideOfContext(NodeFlagsJSDoc, parseJSDocType)
	if !mayOmitBraces || hasBrace {
		parseExpectedJSDoc(SyntaxKindCloseBraceToken)
	}

	result := factory.createJSDocTypeExpression(type_)
	fixupParentReferences(result)
	return finishNode(result, pos)
}

func parseJSDocNameReference() JSDocNameReference {
	pos := getNodePos()
	hasBrace := parseOptional(SyntaxKindOpenBraceToken)
	p2 := getNodePos()
	var entityName /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | JSDocMemberName */ any = parseEntityName(false)
	for token() == SyntaxKindPrivateIdentifier {
		reScanHashToken()
		// rescan #id as # id
		nextTokenJSDoc()
		// then skip the #
		entityName = finishNode(factory.createJSDocMemberName(entityName, parseIdentifier()), p2)
	}
	if hasBrace {
		parseExpectedJSDoc(SyntaxKindCloseBraceToken)
	}

	result := factory.createJSDocNameReference(entityName)
	fixupParentReferences(result)
	return finishNode(result, pos)
}

func parseIsolatedJSDocComment(content string, start *number, length *number) * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { jsDoc: JSDoc; diagnostics: Diagnostic[]; } */ any {
	initializeState("", content, ScriptTargetLatest /*syntaxCursor*/, nil, ScriptKindJS, JSDocParsingModeParseAll)
	jsDoc := doInsideOfContext(NodeFlagsJSDoc, func() *JSDoc {
		return parseJSDocCommentWorker(start, length)
	})

	sourceFile := map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"languageVariant": LanguageVariantStandard,
		"text":            content,
	}.(SourceFile)
	diagnostics := attachFileToDiagnostics(parseDiagnostics, sourceFile)
	clearState()

	if jsDoc {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"jsDoc":       jsDoc,
			"diagnostics": diagnostics,
		}
	} else {
		return nil
	}
}

func parseJSDocComment(parent HasJSDoc, start number, length number) *JSDoc {
	saveToken := currentToken
	saveParseDiagnosticsLength := parseDiagnostics.length
	saveParseErrorBeforeNextFinishedNode := parseErrorBeforeNextFinishedNode

	comment := doInsideOfContext(NodeFlagsJSDoc, func() *JSDoc {
		return parseJSDocCommentWorker(start, length)
	})
	setParent(comment, parent)

	if contextFlags & NodeFlagsJavaScriptFile {
		if !jsDocDiagnostics {
			jsDocDiagnostics = []never{}
		}
		addRange(jsDocDiagnostics, parseDiagnostics, saveParseDiagnosticsLength)
	}
	currentToken = saveToken
	parseDiagnostics.length = saveParseDiagnosticsLength
	parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode
	return comment
}

type JSDocState int32

const (
	JSDocStateBeginningOfLine JSDocState = iota
	JSDocStateSawAsterisk
	JSDocStateSavingComments
	JSDocStateSavingBackticks
)

type PropertyLikeParse int32

const (
	PropertyLikeParseProperty          PropertyLikeParse = 1 << 0
	PropertyLikeParseParameter         PropertyLikeParse = 1 << 1
	PropertyLikeParseCallbackParameter PropertyLikeParse = 1 << 2
)

func parseJSDocCommentWorker(start number /*  = 0 */, length *number) *JSDoc {
	content := sourceText
	var end number
	if length == nil {
		end = content.length
	} else {
		end = start + length
	}
	length = end - start

	Debug.assert(start >= 0)
	Debug.assert(start <= end)
	Debug.assert(end <= content.length)

	// Check for /** (JSDoc opening part)
	if !isJSDocLikeText(content, start) {
		return nil
	}

	var tags []JSDocTag
	var tagsPos number
	var tagsEnd number
	var linkEnd number
	var commentsPos *number
	var comments []string = []never{}
	var parts []JSDocComment = []never{}

	saveParsingContext := parsingContext
	parsingContext |= /* TODO(TS-TO-GO) LessThanLessThanToken BinaryExpression: 1 << ParsingContext.JSDocComment */ TODO

	// + 3 for leading /**, - 5 in total for /** */
	result := scanner.scanRange(start+3, length-5, doJSDocScan)
	parsingContext = saveParsingContext
	return result

	doJSDocScan := func() JSDoc {
		// Initially we can parse out a tag.  We also have seen a starting asterisk.
		// This is so that /** * @type */ doesn't parse.
		state := JSDocStateSawAsterisk
		var margin *number
		// + 4 for leading '/** '
		// + 1 because the last index of \n is always one index before the first character in the line and coincidentally, if there is no \n before start, it is -1, which is also one index before the first character
		indent := start - (content.lastIndexOf("\n", start) + 1) + 4
		pushComment := func(text string) {
			if !margin {
				margin = indent
			}
			comments.push(text)
			indent += text.length
		}

		nextTokenJSDoc()
		for parseOptionalJsdoc(SyntaxKindWhitespaceTrivia) {
			/* TODO(TS-TO-GO) Node EmptyStatement: ; */
		}
		if parseOptionalJsdoc(SyntaxKindNewLineTrivia) {
			state = JSDocStateBeginningOfLine
			indent = 0
		}
	loop:
		for true {
			switch token() {
			case SyntaxKindAtToken:
				removeTrailingWhitespace(comments)
				if !commentsPos {
					commentsPos = getNodePos()
				}
				addTag(parseTag(indent))
				// NOTE: According to usejsdoc.org, a tag goes to end of line, except the last tag.
				// Real-world comments may break this rule, so "BeginningOfLine" will not be a real line beginning
				// for malformed examples like `/** @param {string} x @returns {number} the length */`
				state = JSDocStateBeginningOfLine
				margin = nil
			case SyntaxKindNewLineTrivia:
				comments.push(scanner.getTokenText())
				state = JSDocStateBeginningOfLine
				indent = 0
			case SyntaxKindAsteriskToken:
				asterisk := scanner.getTokenText()
				if state == JSDocStateSawAsterisk {
					// If we've already seen an asterisk, then we can no longer parse a tag on this line
					state = JSDocStateSavingComments
					pushComment(asterisk)
				} else {
					Debug.assert(state == JSDocStateBeginningOfLine)
					// Ignore the first asterisk on a line
					state = JSDocStateSawAsterisk
					indent += asterisk.length
				}
			case SyntaxKindWhitespaceTrivia:
				Debug.assert(state != JSDocStateSavingComments, "whitespace shouldn't come from the scanner while saving top-level comment text")
				// only collect whitespace if we're already saving comments or have just crossed the comment indent margin
				whitespace := scanner.getTokenText()
				if margin != nil && indent+whitespace.length > margin {
					comments.push(whitespace.slice(margin - indent))
				}
				indent += whitespace.length
			case SyntaxKindEndOfFileToken:
			case SyntaxKindJSDocCommentTextToken:
				state = JSDocStateSavingComments
				pushComment(scanner.getTokenValue())
			case SyntaxKindOpenBraceToken:
				state = JSDocStateSavingComments
				commentEnd := scanner.getTokenFullStart()
				linkStart := scanner.getTokenEnd() - 1
				link := parseJSDocLink(linkStart)
				if link {
					if !linkEnd {
						removeLeadingNewlines(comments)
					}
					parts.push(finishNode(factory.createJSDocText(comments.join("")) /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: linkEnd ?? start */, TODO, commentEnd))
					parts.push(link)
					comments = []never{}
					linkEnd = scanner.getTokenEnd()
					break
				}
				fallthrough
			default:
				// Anything else is doc comment text. We just save it. Because it
				// wasn't a tag, we can no longer parse a tag on this line until we hit the next
				// line break.
				state = JSDocStateSavingComments
				pushComment(scanner.getTokenText())
			}
			if state == JSDocStateSavingComments {
				nextJSDocCommentTextToken(false)
			} else {
				nextTokenJSDoc()
			}
		}
		trimmedComments := comments.join("").trimEnd()
		if parts.length && trimmedComments.length {
			parts.push(finishNode(factory.createJSDocText(trimmedComments) /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: linkEnd ?? start */, TODO, commentsPos))
		}
		if parts.length && tags {
			Debug.assertIsDefined(commentsPos, "having parsed tags implies that the end of the comment span should be set")
		}
		tagsArray := tags && createNodeArray(tags, tagsPos, tagsEnd)
		return finishNode(factory.createJSDocComment(ifelse(parts.length, createNodeArray(parts, start, commentsPos), ifelse(trimmedComments.length, trimmedComments, nil)), tagsArray), start, end)
	}

	removeLeadingNewlines := func(comments []string) {
		for comments.length && (comments[0] == "\n" || comments[0] == "\r") {
			comments.shift()
		}
	}

	removeTrailingWhitespace := func(comments []string) {
		for comments.length {
			trimmed := comments[comments.length-1].trimEnd()
			if trimmed == "" {
				comments.pop()
			} else if trimmed.length < comments[comments.length-1].length {
				comments[comments.length-1] = trimmed
				break
			} else {
				break
			}
		}
	}

	isNextNonwhitespaceTokenEndOfFile := func() bool {
		// We must use infinite lookahead, as there could be any number of newlines :(
		for true {
			nextTokenJSDoc()
			if token() == SyntaxKindEndOfFileToken {
				return true
			}
			if !(token() == SyntaxKindWhitespaceTrivia || token() == SyntaxKindNewLineTrivia) {
				return false
			}
		}
	}

	skipWhitespace := func() {
		if token() == SyntaxKindWhitespaceTrivia || token() == SyntaxKindNewLineTrivia {
			if lookAhead(isNextNonwhitespaceTokenEndOfFile) {
				return
				// Don't skip whitespace prior to EoF (or end of comment) - that shouldn't be included in any node's range
			}
		}
		for token() == SyntaxKindWhitespaceTrivia || token() == SyntaxKindNewLineTrivia {
			nextTokenJSDoc()
		}
	}

	skipWhitespaceOrAsterisk := func() string {
		if token() == SyntaxKindWhitespaceTrivia || token() == SyntaxKindNewLineTrivia {
			if lookAhead(isNextNonwhitespaceTokenEndOfFile) {
				return ""
				// Don't skip whitespace prior to EoF (or end of comment) - that shouldn't be included in any node's range
			}
		}

		precedingLineBreak := scanner.hasPrecedingLineBreak()
		seenLineBreak := false
		indentText := ""
		for (precedingLineBreak && token() == SyntaxKindAsteriskToken) || token() == SyntaxKindWhitespaceTrivia || token() == SyntaxKindNewLineTrivia {
			indentText += scanner.getTokenText()
			if token() == SyntaxKindNewLineTrivia {
				precedingLineBreak = true
				seenLineBreak = true
				indentText = ""
			} else if token() == SyntaxKindAsteriskToken {
				precedingLineBreak = false
			}
			nextTokenJSDoc()
		}
		if seenLineBreak {
			return indentText
		} else {
			return ""
		}
	}

	parseTag := func(margin number) JSDocTag {
		Debug.assert(token() == SyntaxKindAtToken)
		start := scanner.getTokenStart()
		nextTokenJSDoc()

		tagName := parseJSDocIdentifierName(nil)
		indentText := skipWhitespaceOrAsterisk()

		var tag *JSDocTag
		switch tagName.escapedText {
		case "author":
			tag = parseAuthorTag(start, tagName, margin, indentText)
		case "implements":
			tag = parseImplementsTag(start, tagName, margin, indentText)
		case "augments",
			"extends":
			tag = parseAugmentsTag(start, tagName, margin, indentText)
		case "class",
			"constructor":
			tag = parseSimpleTag(start, factory.createJSDocClassTag, tagName, margin, indentText)
		case "public":
			tag = parseSimpleTag(start, factory.createJSDocPublicTag, tagName, margin, indentText)
		case "private":
			tag = parseSimpleTag(start, factory.createJSDocPrivateTag, tagName, margin, indentText)
		case "protected":
			tag = parseSimpleTag(start, factory.createJSDocProtectedTag, tagName, margin, indentText)
		case "readonly":
			tag = parseSimpleTag(start, factory.createJSDocReadonlyTag, tagName, margin, indentText)
		case "override":
			tag = parseSimpleTag(start, factory.createJSDocOverrideTag, tagName, margin, indentText)
		case "deprecated":
			hasDeprecatedTag = true
			tag = parseSimpleTag(start, factory.createJSDocDeprecatedTag, tagName, margin, indentText)
		case "this":
			tag = parseThisTag(start, tagName, margin, indentText)
		case "enum":
			tag = parseEnumTag(start, tagName, margin, indentText)
		case "arg",
			"argument",
			"param":
			return parseParameterOrPropertyTag(start, tagName, PropertyLikeParseParameter, margin)
		case "return",
			"returns":
			tag = parseReturnTag(start, tagName, margin, indentText)
		case "template":
			tag = parseTemplateTag(start, tagName, margin, indentText)
		case "type":
			tag = parseTypeTag(start, tagName, margin, indentText)
		case "typedef":
			tag = parseTypedefTag(start, tagName, margin, indentText)
		case "callback":
			tag = parseCallbackTag(start, tagName, margin, indentText)
		case "overload":
			tag = parseOverloadTag(start, tagName, margin, indentText)
		case "satisfies":
			tag = parseSatisfiesTag(start, tagName, margin, indentText)
		case "see":
			tag = parseSeeTag(start, tagName, margin, indentText)
		case "exception",
			"throws":
			tag = parseThrowsTag(start, tagName, margin, indentText)
		case "import":
			tag = parseImportTag(start, tagName, margin, indentText)
		default:
			tag = parseUnknownTag(start, tagName, margin, indentText)
		}
		return tag
	}

	parseTrailingTagComments := func(pos number, end number, margin number, indentText string) * /* TODO(TS-TO-GO) inferred type string | NodeArray<JSDocComment> */ any {
		// some tags, like typedef and callback, have already parsed their comments earlier
		if !indentText {
			margin += end - pos
		}
		return parseTagComments(margin, indentText.slice(margin))
	}

	parseTagComments := func(indent number, initialMargin string) /* TODO(TS-TO-GO) TypeNode UnionType: string | NodeArray<JSDocComment> | undefined */ any {
		commentsPos := getNodePos()
		var comments []string = []never{}
		var parts []JSDocComment = []never{}
		var linkEnd TODO
		state := JSDocStateBeginningOfLine
		var margin *number
		pushComment := func(text string) {
			if !margin {
				margin = indent
			}
			comments.push(text)
			indent += text.length
		}

		if initialMargin != nil {
			// jump straight to saving comments if there is some initial indentation
			if initialMargin != "" {
				pushComment(initialMargin)
			}
			state = JSDocStateSawAsterisk
		}
		tok := token() /* as JSDocSyntaxKind | SyntaxKind.JSDocCommentTextToken */
	loop:
		for true {
			switch tok {
			case SyntaxKindNewLineTrivia:
				state = JSDocStateBeginningOfLine
				// don't use pushComment here because we want to keep the margin unchanged
				comments.push(scanner.getTokenText())
				indent = 0
			case SyntaxKindAtToken:
				scanner.resetTokenState(scanner.getTokenEnd() - 1)
			case SyntaxKindEndOfFileToken:
				// Done
			case SyntaxKindWhitespaceTrivia:
				Debug.assert(state != JSDocStateSavingComments && state != JSDocStateSavingBackticks, "whitespace shouldn't come from the scanner while saving comment text")
				whitespace := scanner.getTokenText()
				// if the whitespace crosses the margin, take only the whitespace that passes the margin
				if margin != nil && indent+whitespace.length > margin {
					comments.push(whitespace.slice(margin - indent))
					state = JSDocStateSavingComments
				}
				indent += whitespace.length
			case SyntaxKindOpenBraceToken:
				state = JSDocStateSavingComments
				commentEnd := scanner.getTokenFullStart()
				linkStart := scanner.getTokenEnd() - 1
				link := parseJSDocLink(linkStart)
				if link {
					parts.push(finishNode(factory.createJSDocText(comments.join("")) /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: linkEnd ?? commentsPos */, TODO, commentEnd))
					parts.push(link)
					comments = []never{}
					linkEnd = scanner.getTokenEnd()
				} else {
					pushComment(scanner.getTokenText())
				}
			case SyntaxKindBacktickToken:
				if state == JSDocStateSavingBackticks {
					state = JSDocStateSavingComments
				} else {
					state = JSDocStateSavingBackticks
				}
				pushComment(scanner.getTokenText())
			case SyntaxKindJSDocCommentTextToken:
				if state != JSDocStateSavingBackticks {
					state = JSDocStateSavingComments
					// leading identifiers start recording as well
				}
				pushComment(scanner.getTokenValue())
			case SyntaxKindAsteriskToken:
				if state == JSDocStateBeginningOfLine {
					// leading asterisks start recording on the *next* (non-whitespace) token
					state = JSDocStateSawAsterisk
					indent += 1
					break
				}
				// record the * as a comment
				fallthrough
			default:
				if state != JSDocStateSavingBackticks {
					state = JSDocStateSavingComments
					// leading identifiers start recording as well
				}
				pushComment(scanner.getTokenText())
			}
			if state == JSDocStateSavingComments || state == JSDocStateSavingBackticks {
				tok = nextJSDocCommentTextToken(state == JSDocStateSavingBackticks)
			} else {
				tok = nextTokenJSDoc()
			}
		}

		removeLeadingNewlines(comments)
		trimmedComments := comments.join("").trimEnd()
		if parts.length {
			if trimmedComments.length {
				parts.push(finishNode(factory.createJSDocText(trimmedComments) /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: linkEnd ?? commentsPos */, TODO))
			}
			return createNodeArray(parts, commentsPos, scanner.getTokenEnd())
		} else if trimmedComments.length {
			return trimmedComments
		}
	}

	parseJSDocLink := func(start number) * /* TODO(TS-TO-GO) inferred type JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any {
		linkType := tryParse(parseJSDocLinkPrefix)
		if !linkType {
			return nil
		}
		nextTokenJSDoc()
		// start at token after link, then skip any whitespace
		skipWhitespace()
		name := parseJSDocLinkName()
		text := []never{}
		for token() != SyntaxKindCloseBraceToken && token() != SyntaxKindNewLineTrivia && token() != SyntaxKindEndOfFileToken {
			text.push(scanner.getTokenText())
			nextTokenJSDoc()
		}
		var create /* TODO(TS-TO-GO) inferred type ((name: EntityName | JSDocMemberName | undefined, text: string) => JSDocLink) | ((name: EntityName | JSDocMemberName | undefined, text: string) => JSDocLinkCode) | ((name: EntityName | JSDocMemberName | undefined, text: string) => JSDocLinkPlain) */ any
		switch {
		case linkType == "link":
			create = factory.createJSDocLink
		case linkType == "linkcode":
			create = factory.createJSDocLinkCode
		default:
			create = factory.createJSDocLinkPlain
		}
		return finishNode(create(name, text.join("")), start, scanner.getTokenEnd())
	}

	parseJSDocLinkName := func() * /* TODO(TS-TO-GO) inferred type EntityName | JSDocMemberName */ any {
		if tokenIsIdentifierOrKeyword(token()) {
			pos := getNodePos()

			var name /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | JSDocMemberName */ any = parseIdentifierName()
			for parseOptional(SyntaxKindDotToken) {
				name = finishNode(factory.createQualifiedName(name, ifelse(token() == SyntaxKindPrivateIdentifier, createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, false), parseIdentifierName())), pos)
			}
			for token() == SyntaxKindPrivateIdentifier {
				reScanHashToken()
				nextTokenJSDoc()
				name = finishNode(factory.createJSDocMemberName(name, parseIdentifier()), pos)
			}
			return name
		}
		return nil
	}

	parseJSDocLinkPrefix := func() * /* TODO(TS-TO-GO) inferred type "link" | "linkcode" | "linkplain" */ any {
		skipWhitespaceOrAsterisk()
		if token() == SyntaxKindOpenBraceToken && nextTokenJSDoc() == SyntaxKindAtToken && tokenIsIdentifierOrKeyword(nextTokenJSDoc()) {
			kind := scanner.getTokenValue()
			if isJSDocLinkTag(kind) {
				return kind
			}
		}
	}

	isJSDocLinkTag := func(kind string) bool {
		return kind == "link" || kind == "linkcode" || kind == "linkplain"
	}

	parseUnknownTag := func(start number, tagName Identifier, indent number, indentText string) JSDocUnknownTag {
		return finishNode(factory.createJSDocUnknownTag(tagName, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start)
	}

	addTag := func(tag *JSDocTag) {
		if !tag {
			return
		}
		if !tags {
			tags = []JSDocTag{tag}
			tagsPos = tag.pos
		} else {
			tags.push(tag)
		}
		tagsEnd = tag.end
	}

	tryParseTypeExpression := func() *JSDocTypeExpression {
		skipWhitespaceOrAsterisk()
		if token() == SyntaxKindOpenBraceToken {
			return parseJSDocTypeExpression()
		} else {
			return nil
		}
	}

	parseBracketNameInPropertyAndParamTag := func() /* TODO(TS-TO-GO) TypeNode TypeLiteral: { name: EntityName; isBracketed: boolean; } */ any {
		// Looking for something like '[foo]', 'foo', '[foo.bar]' or 'foo.bar'
		isBracketed := parseOptionalJsdoc(SyntaxKindOpenBracketToken)
		if isBracketed {
			skipWhitespace()
		}
		// a markdown-quoted name: `arg` is not legal jsdoc, but occurs in the wild
		isBackquoted := parseOptionalJsdoc(SyntaxKindBacktickToken)
		name := parseJSDocEntityName()
		if isBackquoted {
			parseExpectedTokenJSDoc(SyntaxKindBacktickToken)
		}
		if isBracketed {
			skipWhitespace()
			// May have an optional default, e.g. '[foo = 42]'
			if parseOptionalToken(SyntaxKindEqualsToken) {
				parseExpression()
			}

			parseExpected(SyntaxKindCloseBracketToken)
		}

		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"name":        name,
			"isBracketed": isBracketed,
		}
	}

	isObjectOrObjectArrayTypeReference := func(node TypeNode) bool {
		switch node.kind {
		case SyntaxKindObjectKeyword:
			return true
		case SyntaxKindArrayType:
			return isObjectOrObjectArrayTypeReference((node.(ArrayTypeNode)).elementType)
		default:
			return isTypeReferenceNode(node) && isIdentifierNode(node.typeName) && node.typeName.escapedText == "Object" && !node.typeArguments
		}
	}

	parseParameterOrPropertyTag := func(start number, tagName Identifier, target PropertyLikeParse, indent number) /* TODO(TS-TO-GO) TypeNode UnionType: JSDocParameterTag | JSDocPropertyTag */ any {
		typeExpression := tryParseTypeExpression()
		isNameFirst := !typeExpression
		skipWhitespaceOrAsterisk()

		TODO_IDENTIFIER := parseBracketNameInPropertyAndParamTag()
		indentText := skipWhitespaceOrAsterisk()

		if isNameFirst && !lookAhead(parseJSDocLinkPrefix) {
			typeExpression = tryParseTypeExpression()
		}

		comment := parseTrailingTagComments(start, getNodePos(), indent, indentText)

		nestedTypeLiteral := parseNestedTypeLiteral(typeExpression, name, target, indent)
		if nestedTypeLiteral {
			typeExpression = nestedTypeLiteral
			isNameFirst = true
		}
		var result /* TODO(TS-TO-GO) inferred type JSDocParameterTag | JSDocPropertyTag */ any
		if target == PropertyLikeParseProperty {
			result = factory.createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment)
		} else {
			result = factory.createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment)
		}
		return finishNode(result, start)
	}

	parseNestedTypeLiteral := func(typeExpression *JSDocTypeExpression, name EntityName, target PropertyLikeParse, indent number) *JSDocTypeExpression {
		if typeExpression && isObjectOrObjectArrayTypeReference(typeExpression.type_) {
			pos := getNodePos()
			var child /* TODO(TS-TO-GO) TypeNode UnionType: JSDocPropertyLikeTag | JSDocTypeTag | JSDocTemplateTag | JSDocThisTag | false */ any
			var children *[]JSDocPropertyLikeTag
			for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: child = tryParse(() => parseChildParameterOrPropertyTag(target, indent, name)) */ TODO {
				if child.kind == SyntaxKindJSDocParameterTag || child.kind == SyntaxKindJSDocPropertyTag {
					children = append(children, child)
				} else if child.kind == SyntaxKindJSDocTemplateTag {
					parseErrorAtRange(child.tagName, Diagnostics.A_JSDoc_template_tag_may_not_follow_a_typedef_callback_or_overload_tag)
				}
			}
			if children {
				literal := finishNode(factory.createJSDocTypeLiteral(children, typeExpression.type_.kind == SyntaxKindArrayType), pos)
				return finishNode(factory.createJSDocTypeExpression(literal), pos)
			}
		}
	}

	parseReturnTag := func(start number, tagName Identifier, indent number, indentText string) JSDocReturnTag {
		if some(tags, isJSDocReturnTag) {
			parseErrorAt(tagName.pos, scanner.getTokenStart(), Diagnostics._0_tag_already_specified, unescapeLeadingUnderscores(tagName.escapedText))
		}

		typeExpression := tryParseTypeExpression()
		return finishNode(factory.createJSDocReturnTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start)
	}

	parseTypeTag := func(start number, tagName Identifier, indent number, indentText string) JSDocTypeTag {
		if some(tags, isJSDocTypeTag) {
			parseErrorAt(tagName.pos, scanner.getTokenStart(), Diagnostics._0_tag_already_specified, unescapeLeadingUnderscores(tagName.escapedText))
		}

		typeExpression := parseJSDocTypeExpression(true)
		var comments * /* TODO(TS-TO-GO) inferred type string | NodeArray<JSDocComment> */ any
		if indent != nil && indentText != nil {
			comments = parseTrailingTagComments(start, getNodePos(), indent, indentText)
		} else {
			comments = nil
		}
		return finishNode(factory.createJSDocTypeTag(tagName, typeExpression, comments), start)
	}

	parseSeeTag := func(start number, tagName Identifier, indent number, indentText string) JSDocSeeTag {
		isMarkdownOrJSDocLink := token() == SyntaxKindOpenBracketToken || lookAhead(func() bool {
			return nextTokenJSDoc() == SyntaxKindAtToken && tokenIsIdentifierOrKeyword(nextTokenJSDoc()) && isJSDocLinkTag(scanner.getTokenValue())
		})
		var nameExpression *JSDocNameReference
		if isMarkdownOrJSDocLink {
			nameExpression = nil
		} else {
			nameExpression = parseJSDocNameReference()
		}
		var comments * /* TODO(TS-TO-GO) inferred type string | NodeArray<JSDocComment> */ any
		if indent != nil && indentText != nil {
			comments = parseTrailingTagComments(start, getNodePos(), indent, indentText)
		} else {
			comments = nil
		}
		return finishNode(factory.createJSDocSeeTag(tagName, nameExpression, comments), start)
	}

	parseThrowsTag := func(start number, tagName Identifier, indent number, indentText string) JSDocThrowsTag {
		typeExpression := tryParseTypeExpression()
		comment := parseTrailingTagComments(start, getNodePos(), indent, indentText)
		return finishNode(factory.createJSDocThrowsTag(tagName, typeExpression, comment), start)
	}

	parseAuthorTag := func(start number, tagName Identifier, indent number, indentText string) JSDocAuthorTag {
		commentStart := getNodePos()
		textOnly := parseAuthorNameAndEmail()
		commentEnd := scanner.getTokenFullStart()
		comments := parseTrailingTagComments(start, commentEnd, indent, indentText)
		if !comments {
			commentEnd = scanner.getTokenFullStart()
		}
		var allParts /* TODO(TS-TO-GO) inferred type string | NodeArray<JSDocComment> */ any
		if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof comments */ TODO != "string" {
			allParts = createNodeArray(concatenate([]JSDocText{finishNode(textOnly, commentStart, commentEnd)}, comments) /* as JSDocComment[] */, commentStart)
		} else {
			allParts = textOnly.text + comments
		}
		return finishNode(factory.createJSDocAuthorTag(tagName, allParts), start)
	}

	parseAuthorNameAndEmail := func() JSDocText {
		var comments []string = []never{}
		inEmail := false
		token := scanner.getToken()
		for token != SyntaxKindEndOfFileToken && token != SyntaxKindNewLineTrivia {
			if token == SyntaxKindLessThanToken {
				inEmail = true
			} else if token == SyntaxKindAtToken && !inEmail {
				break
			} else if token == SyntaxKindGreaterThanToken && inEmail {
				comments.push(scanner.getTokenText())
				scanner.resetTokenState(scanner.getTokenEnd())
				break
			}
			comments.push(scanner.getTokenText())
			token = nextTokenJSDoc()
		}

		return factory.createJSDocText(comments.join(""))
	}

	parseImplementsTag := func(start number, tagName Identifier, margin number, indentText string) JSDocImplementsTag {
		className := parseExpressionWithTypeArgumentsForAugments()
		return finishNode(factory.createJSDocImplementsTag(tagName, className, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start)
	}

	parseAugmentsTag := func(start number, tagName Identifier, margin number, indentText string) JSDocAugmentsTag {
		className := parseExpressionWithTypeArgumentsForAugments()
		return finishNode(factory.createJSDocAugmentsTag(tagName, className, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start)
	}

	parseSatisfiesTag := func(start number, tagName Identifier, margin number, indentText string) JSDocSatisfiesTag {
		typeExpression := parseJSDocTypeExpression(false)
		var comments * /* TODO(TS-TO-GO) inferred type string | NodeArray<JSDocComment> */ any
		if margin != nil && indentText != nil {
			comments = parseTrailingTagComments(start, getNodePos(), margin, indentText)
		} else {
			comments = nil
		}
		return finishNode(factory.createJSDocSatisfiesTag(tagName, typeExpression, comments), start)
	}

	parseImportTag := func(start number, tagName Identifier, margin number, indentText string) JSDocImportTag {
		afterImportTagPos := scanner.getTokenFullStart()

		var identifier *Identifier
		if isIdentifier() {
			identifier = parseIdentifier()
		}

		importClause := tryParseImportClause(identifier, afterImportTagPos /*isTypeOnly*/, true /*skipJsDocLeadingAsterisks*/, true)
		moduleSpecifier := parseModuleSpecifier()
		attributes := tryParseImportAttributes()

		var comments * /* TODO(TS-TO-GO) inferred type string | NodeArray<JSDocComment> */ any
		if margin != nil && indentText != nil {
			comments = parseTrailingTagComments(start, getNodePos(), margin, indentText)
		} else {
			comments = nil
		}
		return finishNode(factory.createJSDocImportTag(tagName, importClause, moduleSpecifier, attributes, comments), start)
	}

	parseExpressionWithTypeArgumentsForAugments := func() /* TODO(TS-TO-GO) TypeNode IntersectionType: ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression; } */ any {
		usedBrace := parseOptional(SyntaxKindOpenBraceToken)
		pos := getNodePos()
		expression := parsePropertyAccessEntityNameExpression()
		scanner.setSkipJsDocLeadingAsterisks(true)
		typeArguments := tryParseTypeArguments()
		scanner.setSkipJsDocLeadingAsterisks(false)
		node := factory.createExpressionWithTypeArguments(expression, typeArguments) /* as ExpressionWithTypeArguments & { expression: Identifier | PropertyAccessEntityNameExpression; } */
		res := finishNode(node, pos)
		if usedBrace {
			parseExpected(SyntaxKindCloseBraceToken)
		}
		return res
	}

	parsePropertyAccessEntityNameExpression := func() /* TODO(TS-TO-GO) inferred type Identifier | PropertyAccessEntityNameExpression */ any {
		pos := getNodePos()
		var node /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PropertyAccessEntityNameExpression */ any = parseJSDocIdentifierName()
		for parseOptional(SyntaxKindDotToken) {
			name := parseJSDocIdentifierName()
			node = finishNode(factoryCreatePropertyAccessExpression(node, name), pos).(PropertyAccessEntityNameExpression)
		}
		return node
	}

	parseSimpleTag := func(start number, createTag func(tagName *Identifier, comment /* TODO(TS-TO-GO) TypeNode UnionType: string | NodeArray<JSDocComment> */ any) JSDocTag, tagName Identifier, margin number, indentText string) JSDocTag {
		return finishNode(createTag(tagName, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start)
	}

	parseThisTag := func(start number, tagName Identifier, margin number, indentText string) JSDocThisTag {
		typeExpression := parseJSDocTypeExpression(true)
		skipWhitespace()
		return finishNode(factory.createJSDocThisTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start)
	}

	parseEnumTag := func(start number, tagName Identifier, margin number, indentText string) JSDocEnumTag {
		typeExpression := parseJSDocTypeExpression(true)
		skipWhitespace()
		return finishNode(factory.createJSDocEnumTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start)
	}

	parseTypedefTag := func(start number, tagName Identifier, indent number, indentText string) JSDocTypedefTag {
		var typeExpression /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeExpression | JSDocTypeLiteral | undefined */ any = tryParseTypeExpression()
		skipWhitespaceOrAsterisk()

		fullName := parseJSDocTypeNameWithNamespace()
		skipWhitespace()
		comment := parseTagComments(indent)

		var end *number
		if !typeExpression || isObjectOrObjectArrayTypeReference(typeExpression.type_) {
			var child /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeTag | JSDocPropertyTag | JSDocTemplateTag | false */ any
			var childTypeTag *JSDocTypeTag
			var jsDocPropertyTags *[]JSDocPropertyTag
			hasChildren := false
			for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: child = tryParse(() => parseChildPropertyTag(indent)) */ TODO {
				if child.kind == SyntaxKindJSDocTemplateTag {
					break
				}
				hasChildren = true
				if child.kind == SyntaxKindJSDocTypeTag {
					if childTypeTag {
						lastError := parseErrorAtCurrentToken(Diagnostics.A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags)
						if lastError {
							addRelatedInfo(lastError, createDetachedDiagnostic(fileName, sourceText, 0, 0, Diagnostics.The_tag_was_first_specified_here))
						}
						break
					} else {
						childTypeTag = child
					}
				} else {
					jsDocPropertyTags = append(jsDocPropertyTags, child)
				}
			}
			if hasChildren {
				isArrayType := typeExpression && typeExpression.type_.kind == SyntaxKindArrayType
				jsdocTypeLiteral := factory.createJSDocTypeLiteral(jsDocPropertyTags, isArrayType)
				if childTypeTag && childTypeTag.typeExpression && !isObjectOrObjectArrayTypeReference(childTypeTag.typeExpression.type_) {
					typeExpression = childTypeTag.typeExpression
				} else {
					typeExpression = finishNode(jsdocTypeLiteral, start)
				}
				end = typeExpression.end
			}
		}

		// Only include the characters between the name end and the next token if a comment was actually parsed out - otherwise it's just whitespace
		if end || comment != nil {
			end = getNodePos()
		} else {
			end = ( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: fullName ?? typeExpression ?? tagName */ TODO).end
		}

		if !comment {
			comment = parseTrailingTagComments(start, end, indent, indentText)
		}

		typedefTag := factory.createJSDocTypedefTag(tagName, typeExpression, fullName, comment)
		return finishNode(typedefTag, start, end)
	}

	parseJSDocTypeNameWithNamespace := func(nested bool) * /* TODO(TS-TO-GO) inferred type Identifier | JSDocNamespaceDeclaration */ any {
		start := scanner.getTokenStart()
		if !tokenIsIdentifierOrKeyword(token()) {
			return nil
		}
		typeNameOrNamespaceName := parseJSDocIdentifierName()
		if parseOptional(SyntaxKindDotToken) {
			body := parseJSDocTypeNameWithNamespace(true)
			jsDocNamespaceNode := factory.createModuleDeclaration(nil, typeNameOrNamespaceName, body, ifelse(nested, NodeFlagsNestedNamespace, nil)).(JSDocNamespaceDeclaration)
			return finishNode(jsDocNamespaceNode, start)
		}

		if nested {
			(typeNameOrNamespaceName.(Mutable[Identifier])).flags |= NodeFlagsIdentifierIsInJSDocNamespace
		}
		return typeNameOrNamespaceName
	}

	parseCallbackTagParameters := func(indent number) NodeArray[JSDocParameterTag] {
		pos := getNodePos()
		var child /* TODO(TS-TO-GO) TypeNode UnionType: JSDocParameterTag | JSDocTemplateTag | false */ any
		var parameters TODO
		for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: child = tryParse(() => parseChildParameterOrPropertyTag(PropertyLikeParse.CallbackParameter, indent) as JSDocParameterTag | JSDocTemplateTag) */ TODO {
			if child.kind == SyntaxKindJSDocTemplateTag {
				parseErrorAtRange(child.tagName, Diagnostics.A_JSDoc_template_tag_may_not_follow_a_typedef_callback_or_overload_tag)
				break
			}
			parameters = append(parameters, child)
		}
		return createNodeArray(parameters || []never{}, pos)
	}

	parseJSDocSignature := func(start number, indent number) JSDocSignature {
		parameters := parseCallbackTagParameters(indent)
		returnTag := tryParse(func() *JSDocReturnTag {
			if parseOptionalJsdoc(SyntaxKindAtToken) {
				tag := parseTag(indent)
				if tag && tag.kind == SyntaxKindJSDocReturnTag {
					return tag.(JSDocReturnTag)
				}
			}
		})
		return finishNode(factory.createJSDocSignature(nil, parameters, returnTag), start)
	}

	parseCallbackTag := func(start number, tagName Identifier, indent number, indentText string) JSDocCallbackTag {
		fullName := parseJSDocTypeNameWithNamespace()
		skipWhitespace()
		comment := parseTagComments(indent)
		typeExpression := parseJSDocSignature(start, indent)
		if !comment {
			comment = parseTrailingTagComments(start, getNodePos(), indent, indentText)
		}
		var end number
		if comment != nil {
			end = getNodePos()
		} else {
			end = typeExpression.end
		}
		return finishNode(factory.createJSDocCallbackTag(tagName, typeExpression, fullName, comment), start, end)
	}

	parseOverloadTag := func(start number, tagName Identifier, indent number, indentText string) JSDocOverloadTag {
		skipWhitespace()
		comment := parseTagComments(indent)
		typeExpression := parseJSDocSignature(start, indent)
		if !comment {
			comment = parseTrailingTagComments(start, getNodePos(), indent, indentText)
		}
		var end number
		if comment != nil {
			end = getNodePos()
		} else {
			end = typeExpression.end
		}
		return finishNode(factory.createJSDocOverloadTag(tagName, typeExpression, comment), start, end)
	}

	escapedTextsEqual := func(a EntityName, b EntityName) bool {
		for !isIdentifierNode(a) || !isIdentifierNode(b) {
			if !isIdentifierNode(a) && !isIdentifierNode(b) && a.right.escapedText == b.right.escapedText {
				a = a.left
				b = b.left
			} else {
				return false
			}
		}
		return a.escapedText == b.escapedText
	}

	parseChildPropertyTag := func(indent number) /* TODO(TS-TO-GO) inferred type false | JSDocTemplateTag | JSDocPropertyTag | JSDocTypeTag */ any {
		return parseChildParameterOrPropertyTag(PropertyLikeParseProperty, indent) /* as JSDocTypeTag | JSDocPropertyTag | JSDocTemplateTag | false */
	}

	parseChildParameterOrPropertyTag := func(target PropertyLikeParse, indent number, name EntityName) /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeTag | JSDocPropertyTag | JSDocParameterTag | JSDocTemplateTag | JSDocThisTag | false */ any {
		canParseTag := true
		seenAsterisk := false
		for true {
			switch nextTokenJSDoc() {
			case SyntaxKindAtToken:
				if canParseTag {
					child := tryParseChildTag(target, indent)
					if child && (child.kind == SyntaxKindJSDocParameterTag || child.kind == SyntaxKindJSDocPropertyTag) && name && (isIdentifierNode(child.name) || !escapedTextsEqual(name, child.name.left)) {
						return false
					}
					return child
				}
				seenAsterisk = false
			case SyntaxKindNewLineTrivia:
				canParseTag = true
				seenAsterisk = false
			case SyntaxKindAsteriskToken:
				if seenAsterisk {
					canParseTag = false
				}
				seenAsterisk = true
			case SyntaxKindIdentifier:
				canParseTag = false
			case SyntaxKindEndOfFileToken:
				return false
			}
		}
	}

	tryParseChildTag := func(target PropertyLikeParse, indent number) /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeTag | JSDocPropertyTag | JSDocParameterTag | JSDocTemplateTag | JSDocThisTag | false */ any {
		Debug.assert(token() == SyntaxKindAtToken)
		start := scanner.getTokenFullStart()
		nextTokenJSDoc()

		tagName := parseJSDocIdentifierName()
		indentText := skipWhitespaceOrAsterisk()
		var t PropertyLikeParse
		switch tagName.escapedText {
		case "type":
			return target == PropertyLikeParseProperty && parseTypeTag(start, tagName)
		case "prop",
			"property":
			t = PropertyLikeParseProperty
		case "arg",
			"argument",
			"param":
			t = PropertyLikeParseParameter | PropertyLikeParseCallbackParameter
		case "template":
			return parseTemplateTag(start, tagName, indent, indentText)
		case "this":
			return parseThisTag(start, tagName, indent, indentText)
		default:
			return false
		}
		if !(target & t) {
			return false
		}
		return parseParameterOrPropertyTag(start, tagName, target, indent)
	}

	parseTemplateTagTypeParameter := func() *TypeParameterDeclaration {
		typeParameterPos := getNodePos()
		isBracketed := parseOptionalJsdoc(SyntaxKindOpenBracketToken)
		if isBracketed {
			skipWhitespace()
		}

		modifiers := parseModifiers(false /*permitConstAsModifier*/, true)
		name := parseJSDocIdentifierName(Diagnostics.Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces)
		var defaultType *TypeNode
		if isBracketed {
			skipWhitespace()
			parseExpected(SyntaxKindEqualsToken)
			defaultType = doInsideOfContext(NodeFlagsJSDoc, parseJSDocType)
			parseExpected(SyntaxKindCloseBracketToken)
		}

		if nodeIsMissing(name) {
			return nil
		}
		return finishNode(factory.createTypeParameterDeclaration(modifiers, name /*constraint*/, nil, defaultType), typeParameterPos)
	}

	parseTemplateTagTypeParameters := func() NodeArray[TypeParameterDeclaration] {
		pos := getNodePos()
		typeParameters := []never{}
		for ok := true; ok; ok = parseOptionalJsdoc(SyntaxKindCommaToken) { // do-while loop
			skipWhitespace()
			node := parseTemplateTagTypeParameter()
			if node != nil {
				typeParameters.push(node)
			}
			skipWhitespaceOrAsterisk()
		}
		return createNodeArray(typeParameters, pos)
	}

	parseTemplateTag := func(start number, tagName Identifier, indent number, indentText string) JSDocTemplateTag {
		// The template tag looks like one of the following:
		//   @template T,U,V
		//   @template {Constraint} T
		//
		// According to the [closure docs](https://github.com/google/closure-compiler/wiki/Generic-Types#multiple-bounded-template-types):
		//   > Multiple bounded generics cannot be declared on the same line. For the sake of clarity, if multiple templates share the same
		//   > type bound they must be declared on separate lines.
		//
		// TODO: Determine whether we should enforce this in the checker.
		// TODO: Consider moving the `constraint` to the first type parameter as we could then remove `getEffectiveConstraintOfTypeParameter`.
		// TODO: Consider only parsing a single type parameter if there is a constraint.
		var constraint *JSDocTypeExpression
		if token() == SyntaxKindOpenBraceToken {
			constraint = parseJSDocTypeExpression()
		} else {
			constraint = nil
		}
		typeParameters := parseTemplateTagTypeParameters()
		return finishNode(factory.createJSDocTemplateTag(tagName, constraint, typeParameters, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start)
	}

	parseOptionalJsdoc := func(t JSDocSyntaxKind) bool {
		if token() == t {
			nextTokenJSDoc()
			return true
		}
		return false
	}

	parseJSDocEntityName := func() EntityName {
		var entity EntityName = parseJSDocIdentifierName()
		if parseOptional(SyntaxKindOpenBracketToken) {
			parseExpected(SyntaxKindCloseBracketToken)
			// Note that y[] is accepted as an entity name, but the postfix brackets are not saved for checking.
			// Technically usejsdoc.org requires them for specifying a property of a type equivalent to Array<{ x: ...}>
			// but it's not worth it to enforce that restriction.
		}
		for parseOptional(SyntaxKindDotToken) {
			name := parseJSDocIdentifierName()
			if parseOptional(SyntaxKindOpenBracketToken) {
				parseExpected(SyntaxKindCloseBracketToken)
			}
			entity = createQualifiedName(entity, name)
		}
		return entity
	}

	parseJSDocIdentifierName := func(message DiagnosticMessage) Identifier {
		if !tokenIsIdentifierOrKeyword(token()) {
			return createMissingNode(SyntaxKindIdentifier /*reportAtCurrentPosition*/, !message, message || Diagnostics.Identifier_expected)
		}

		identifierCount++
		start := scanner.getTokenStart()
		end := scanner.getTokenEnd()
		originalKeywordKind := token()
		text := internIdentifier(scanner.getTokenValue())
		result := finishNode(factoryCreateIdentifier(text, originalKeywordKind), start, end)
		nextTokenJSDoc()
		return result
	}

}

// #endregion JSDocParser

// #endregion Parser

var incrementallyParsedFiles = NewWeakSet[SourceFile]()

func markAsIncrementallyParsed(sourceFile SourceFile) {
	if incrementallyParsedFiles.has(sourceFile) {
		Debug.fail("Source file has already been incrementally parsed")
	}
	incrementallyParsedFiles.add(sourceFile)
}

var intersectingChangeSet = NewWeakSet[ /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any]()

func intersectsIncrementalChange(node /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any) bool {
	return intersectingChangeSet.has(node)
}

func markAsIntersectingIncrementalChange(node /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any) {
	intersectingChangeSet.add(node)
}

// #region IncrementalParser

func updateSourceFile(sourceFile SourceFile, newText string, textChangeRange TextChangeRange, aggressiveChecks bool) SourceFile {
	aggressiveChecks = aggressiveChecks || Debug.shouldAssert(AssertionLevelAggressive)

	checkChangeRange(sourceFile, newText, textChangeRange, aggressiveChecks)
	if textChangeRangeIsUnchanged(textChangeRange) {
		// if the text didn't change, then we can just return our current source file as-is.
		return sourceFile
	}

	if sourceFile.statements.length == 0 {
		// If we don't have any statements in the current source file, then there's no real
		// way to incrementally parse.  So just do a full parse instead.
		return Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion /*syntaxCursor*/, nil /*setParentNodes*/, true, sourceFile.scriptKind, sourceFile.setExternalModuleIndicator, sourceFile.jsDocParsingMode)
	}

	// Make sure we're not trying to incrementally update a source file more than once.  Once
	// we do an update the original source file is considered unusable from that point onwards.
	//
	// This is because we do incremental parsing in-place.  i.e. we take nodes from the old
	// tree and give them new positions and parents.  From that point on, trusting the old
	// tree at all is not possible as far too much of it may violate invariants.
	markAsIncrementallyParsed(sourceFile)
	Parser.fixupParentReferences(sourceFile)
	oldText := sourceFile.text
	syntaxCursor := createSyntaxCursor(sourceFile)

	// Make the actual change larger so that we know to reparse anything whose lookahead
	// might have intersected the change.
	changeRange := extendToAffectedRange(sourceFile, textChangeRange)
	checkChangeRange(sourceFile, newText, changeRange, aggressiveChecks)

	// Ensure that extending the affected range only moved the start of the change range
	// earlier in the file.
	Debug.assert(changeRange.span.start <= textChangeRange.span.start)
	Debug.assert(textSpanEnd(changeRange.span) == textSpanEnd(textChangeRange.span))
	Debug.assert(textSpanEnd(textChangeRangeNewSpan(changeRange)) == textSpanEnd(textChangeRangeNewSpan(textChangeRange)))

	// The is the amount the nodes after the edit range need to be adjusted.  It can be
	// positive (if the edit added characters), negative (if the edit deleted characters)
	// or zero (if this was a pure overwrite with nothing added/removed).
	delta := textChangeRangeNewSpan(changeRange).length - changeRange.span.length

	// If we added or removed characters during the edit, then we need to go and adjust all
	// the nodes after the edit.  Those nodes may move forward (if we inserted chars) or they
	// may move backward (if we deleted chars).
	//
	// Doing this helps us out in two ways.  First, it means that any nodes/tokens we want
	// to reuse are already at the appropriate position in the new text.  That way when we
	// reuse them, we don't have to figure out if they need to be adjusted.  Second, it makes
	// it very easy to determine if we can reuse a node.  If the node's position is at where
	// we are in the text, then we can reuse it.  Otherwise we can't.  If the node's position
	// is ahead of us, then we'll need to rescan tokens.  If the node's position is behind
	// us, then we'll need to skip it or crumble it as appropriate
	//
	// We will also adjust the positions of nodes that intersect the change range as well.
	// By doing this, we ensure that all the positions in the old tree are consistent, not
	// just the positions of nodes entirely before/after the change range.  By being
	// consistent, we can then easily map from positions to nodes in the old tree easily.
	//
	// Also, mark any syntax elements that intersect the changed span.  We know, up front,
	// that we cannot reuse these elements.
	updateTokenPositionsAndMarkElements(sourceFile, changeRange.span.start, textSpanEnd(changeRange.span), textSpanEnd(textChangeRangeNewSpan(changeRange)), delta, oldText, newText, aggressiveChecks)

	// Now that we've set up our internal incremental state just proceed and parse the
	// source file in the normal fashion.  When possible the parser will retrieve and
	// reuse nodes from the old tree.
	//
	// Note: passing in 'true' for setNodeParents is very important.  When incrementally
	// parsing, we will be reusing nodes from the old tree, and placing it into new
	// parents.  If we don't set the parents now, we'll end up with an observably
	// inconsistent tree.  Setting the parents on the new tree should be very fast.  We
	// will immediately bail out of walking any subtrees when we can see that their parents
	// are already correct.
	result := Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, syntaxCursor /*setParentNodes*/, true, sourceFile.scriptKind, sourceFile.setExternalModuleIndicator, sourceFile.jsDocParsingMode)
	result.commentDirectives = getNewCommentDirectives(sourceFile.commentDirectives, result.commentDirectives, changeRange.span.start, textSpanEnd(changeRange.span), delta, oldText, newText, aggressiveChecks)
	result.impliedNodeFormat = sourceFile.impliedNodeFormat
	transferSourceFileChildren(sourceFile, result)
	return result
}

func getNewCommentDirectives(oldDirectives *[]CommentDirective, newDirectives *[]CommentDirective, changeStart number, changeRangeOldEnd number, delta number, oldText string, newText string, aggressiveChecks bool) *[]CommentDirective {
	if !oldDirectives {
		return newDirectives
	}
	var commentDirectives *[]CommentDirective
	addedNewlyScannedDirectives := false
	for _, directive := range oldDirectives {
		TODO_IDENTIFIER := directive
		// Range before the change
		if range_.end < changeStart {
			commentDirectives = append(commentDirectives, directive)
		} else if range_.pos > changeRangeOldEnd {
			addNewlyScannedDirectives()
			// Node is entirely past the change range.  We need to move both its pos and
			// end, forward or backward appropriately.
			var updatedDirective CommentDirective = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"range_": map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"pos": range_.pos + delta,
					"end": range_.end + delta,
				},
				"type_": type_,
			}
			commentDirectives = append(commentDirectives, updatedDirective)
			if aggressiveChecks {
				Debug.assert(oldText.substring(range_.pos, range_.end) == newText.substring(updatedDirective.range_.pos, updatedDirective.range_.end))
			}
		}
		// Ignore ranges that fall in change range
	}
	addNewlyScannedDirectives()
	return commentDirectives

	addNewlyScannedDirectives := func() {
		if addedNewlyScannedDirectives {
			return
		}
		addedNewlyScannedDirectives = true
		if !commentDirectives {
			commentDirectives = newDirectives
		} else if newDirectives {
			commentDirectives.push(newDirectives...)
		}
	}

}

/* OVERLOAD: function moveElementEntirelyPastChangeRange(element: Node, origSourceFile: SourceFile, isArray: false, delta: number, oldText: string, newText: string, aggressiveChecks: boolean): void; */
/* OVERLOAD: function moveElementEntirelyPastChangeRange(element: NodeArray<Node>, origSourceFile: SourceFile, isArray: true, delta: number, oldText: string, newText: string, aggressiveChecks: boolean): void; */
func moveElementEntirelyPastChangeRange(element /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any, origSourceFile SourceFile, isArray bool, delta number, oldText string, newText string, aggressiveChecks bool) {
	if isArray {
		visitArray(element.(NodeArray[Node]))
	} else {
		visitNode(element.(Node))
	}
	return

	visitNode := func(node Node) {
		text := ""
		if aggressiveChecks && shouldCheckNode(node) {
			text = oldText.substring(node.pos, node.end)
		}

		// Ditch any existing LS children we may have created.  This way we can avoid
		// moving them forward.
		unsetNodeChildren(node, origSourceFile)

		setTextRangePosEnd(node, node.pos+delta, node.end+delta)

		if aggressiveChecks && shouldCheckNode(node) {
			Debug.assert(text == newText.substring(node.pos, node.end))
		}

		forEachChild(node, visitNode /* as (node: Node) => void */, visitArray /* as (nodes: NodeArray<Node>) => void */)
		if hasJSDocNodes(node) {
			for _, jsDocComment := range node.jsDoc {
				visitNode(jsDocComment)
			}
		}
		checkNodePositions(node, aggressiveChecks)
	}

	visitArray := func(array NodeArray[Node]) {
		setTextRangePosEnd(array, array.pos+delta, array.end+delta)

		for _, node := range array {
			visitNode(node)
		}
	}

}

func shouldCheckNode(node Node) bool {
	switch node.kind {
	case SyntaxKindStringLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindIdentifier:
		return true
	}

	return false
}

func adjustIntersectingElement(element /* TODO(TS-TO-GO) TypeNode UnionType: Node | NodeArray<Node> */ any, changeStart number, changeRangeOldEnd number, changeRangeNewEnd number, delta number) {
	Debug.assert(element.end >= changeStart, "Adjusting an element that was entirely before the change range")
	Debug.assert(element.pos <= changeRangeOldEnd, "Adjusting an element that was entirely after the change range")
	Debug.assert(element.pos <= element.end)

	// We have an element that intersects the change range in some way.  It may have its
	// start, or its end (or both) in the changed range.  We want to adjust any part
	// that intersects such that the final tree is in a consistent state.  i.e. all
	// children have spans within the span of their parent, and all siblings are ordered
	// properly.

	// We may need to update both the 'pos' and the 'end' of the element.

	// If the 'pos' is before the start of the change, then we don't need to touch it.
	// If it isn't, then the 'pos' must be inside the change.  How we update it will
	// depend if delta is positive or negative. If delta is positive then we have
	// something like:
	//
	//  -------------------AAA-----------------
	//  -------------------BBBCCCCCCC-----------------
	//
	// In this case, we consider any node that started in the change range to still be
	// starting at the same position.
	//
	// however, if the delta is negative, then we instead have something like this:
	//
	//  -------------------XXXYYYYYYY-----------------
	//  -------------------ZZZ-----------------
	//
	// In this case, any element that started in the 'X' range will keep its position.
	// However any element that started after that will have their pos adjusted to be
	// at the end of the new range.  i.e. any node that started in the 'Y' range will
	// be adjusted to have their start at the end of the 'Z' range.
	//
	// The element will keep its position if possible.  Or Move backward to the new-end
	// if it's in the 'Y' range.
	pos := min(element.pos, changeRangeNewEnd)

	// If the 'end' is after the change range, then we always adjust it by the delta
	// amount.  However, if the end is in the change range, then how we adjust it
	// will depend on if delta is positive or negative.  If delta is positive then we
	// have something like:
	//
	//  -------------------AAA-----------------
	//  -------------------BBBCCCCCCC-----------------
	//
	// In this case, we consider any node that ended inside the change range to keep its
	// end position.
	//
	// however, if the delta is negative, then we instead have something like this:
	//
	//  -------------------XXXYYYYYYY-----------------
	//  -------------------ZZZ-----------------
	//
	// In this case, any element that ended in the 'X' range will keep its position.
	// However any element that ended after that will have their pos adjusted to be
	// at the end of the new range.  i.e. any node that ended in the 'Y' range will
	// be adjusted to have their end at the end of the 'Z' range.
	var end number
	if element.end >= changeRangeOldEnd {
		end = element.end + delta
	} else {
		end = min(element.end, changeRangeNewEnd)
	}

	Debug.assert(pos <= end)
	if (element /* as any */).parent {
		parent := (element /* as any */).parent.(Node)
		Debug.assertGreaterThanOrEqual(pos, parent.pos)
		Debug.assertLessThanOrEqual(end, parent.end)
	}

	setTextRangePosEnd(element, pos, end)
}

func checkNodePositions(node Node, aggressiveChecks bool) {
	if aggressiveChecks {
		pos := node.pos
		visitNode := func(child Node) {
			Debug.assert(child.pos >= pos)
			pos = child.end
		}
		if hasJSDocNodes(node) {
			for _, jsDocComment := range node.jsDoc {
				visitNode(jsDocComment)
			}
		}
		forEachChild(node, visitNode)
		Debug.assert(pos <= node.end)
	}
}

func updateTokenPositionsAndMarkElements(sourceFile SourceFile, changeStart number, changeRangeOldEnd number, changeRangeNewEnd number, delta number, oldText string, newText string, aggressiveChecks bool) {
	visitNode(sourceFile)
	return

	visitNode := func(child Node) {
		Debug.assert(child.pos <= child.end)
		if child.pos > changeRangeOldEnd {
			// Node is entirely past the change range.  We need to move both its pos and
			// end, forward or backward appropriately.
			moveElementEntirelyPastChangeRange(child, sourceFile /*isArray*/, false, delta, oldText, newText, aggressiveChecks)
			return
		}

		// Check if the element intersects the change range.  If it does, then it is not
		// reusable.  Also, we'll need to recurse to see what constituent portions we may
		// be able to use.
		fullEnd := child.end
		if fullEnd >= changeStart {
			markAsIntersectingIncrementalChange(child)
			unsetNodeChildren(child, sourceFile)

			// Adjust the pos or end (or both) of the intersecting element accordingly.
			adjustIntersectingElement(child, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta)
			forEachChild(child, visitNode /* as (node: Node) => void */, visitArray /* as (nodes: NodeArray<Node>) => void */)
			if hasJSDocNodes(child) {
				for _, jsDocComment := range child.jsDoc {
					visitNode(jsDocComment)
				}
			}
			checkNodePositions(child, aggressiveChecks)
			return
		}

		// Otherwise, the node is entirely before the change range.  No need to do anything with it.
		Debug.assert(fullEnd < changeStart)
	}

	visitArray := func(array NodeArray[Node]) {
		Debug.assert(array.pos <= array.end)
		if array.pos > changeRangeOldEnd {
			// Array is entirely after the change range.  We need to move it, and move any of
			// its children.
			moveElementEntirelyPastChangeRange(array, sourceFile /*isArray*/, true, delta, oldText, newText, aggressiveChecks)
			return
		}

		// Check if the element intersects the change range.  If it does, then it is not
		// reusable.  Also, we'll need to recurse to see what constituent portions we may
		// be able to use.
		fullEnd := array.end
		if fullEnd >= changeStart {
			markAsIntersectingIncrementalChange(array)

			// Adjust the pos or end (or both) of the intersecting array accordingly.
			adjustIntersectingElement(array, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta)
			for _, node := range array {
				visitNode(node)
			}
			return
		}

		// Otherwise, the array is entirely before the change range.  No need to do anything with it.
		Debug.assert(fullEnd < changeStart)
	}

}

func extendToAffectedRange(sourceFile SourceFile, changeRange TextChangeRange) TextChangeRange {
	// Consider the following code:
	//      void foo() { /; }
	//
	// If the text changes with an insertion of / just before the semicolon then we end up with:
	//      void foo() { //; }
	//
	// If we were to just use the changeRange a is, then we would not rescan the { token
	// (as it does not intersect the actual original change range).  Because an edit may
	// change the token touching it, we actually need to look back *at least* one token so
	// that the prior token sees that change.
	maxLookahead := 1

	start := changeRange.span.start

	// the first iteration aligns us with the change start. subsequent iteration move us to
	// the left by maxLookahead tokens.  We only need to do this as long as we're not at the
	// start of the tree.
	for i := 0; start > 0 && i <= maxLookahead; i++ {
		nearestNode := findNearestNodeStartingBeforeOrAtPosition(sourceFile, start)
		Debug.assert(nearestNode.pos <= start)
		position := nearestNode.pos

		start = max(0, position-1)
	}

	finalSpan := createTextSpanFromBounds(start, textSpanEnd(changeRange.span))
	finalLength := changeRange.newLength + (changeRange.span.start - start)

	return createTextChangeRange(finalSpan, finalLength)
}

func findNearestNodeStartingBeforeOrAtPosition(sourceFile SourceFile, position number) Node {
	var bestResult Node = sourceFile
	var lastNodeEntirelyBeforePosition Node

	forEachChild(sourceFile, visit)

	if lastNodeEntirelyBeforePosition {
		lastChildOfLastEntireNodeBeforePosition := getLastDescendant(lastNodeEntirelyBeforePosition)
		if lastChildOfLastEntireNodeBeforePosition.pos > bestResult.pos {
			bestResult = lastChildOfLastEntireNodeBeforePosition
		}
	}

	return bestResult

	getLastDescendant := func(node Node) Node {
		for true {
			lastChild := getLastChild(node)
			if lastChild {
				node = lastChild
			} else {
				return node
			}
		}
	}

	visit := func(child Node) *true {
		if nodeIsMissing(child) {
			// Missing nodes are effectively invisible to us.  We never even consider them
			// When trying to find the nearest node before us.
			return
		}

		// If the child intersects this position, then this node is currently the nearest
		// node that starts before the position.
		if child.pos <= position {
			if child.pos >= bestResult.pos {
				// This node starts before the position, and is closer to the position than
				// the previous best node we found.  It is now the new best node.
				bestResult = child
			}

			// Now, the node may overlap the position, or it may end entirely before the
			// position.  If it overlaps with the position, then either it, or one of its
			// children must be the nearest node before the position.  So we can just
			// recurse into this child to see if we can find something better.
			if position < child.end {
				// The nearest node is either this child, or one of the children inside
				// of it.  We've already marked this child as the best so far.  Recurse
				// in case one of the children is better.
				forEachChild(child, visit)

				// Once we look at the children of this node, then there's no need to
				// continue any further.
				return true
			} else {
				Debug.assert(child.end <= position)
				// The child ends entirely before this position.  Say you have the following
				// (where $ is the position)
				//
				//      <complex expr 1> ? <complex expr 2> $ : <...> <...>
				//
				// We would want to find the nearest preceding node in "complex expr 2".
				// To support that, we keep track of this node, and once we're done searching
				// for a best node, we recurse down this node to see if we can find a good
				// result in it.
				//
				// This approach allows us to quickly skip over nodes that are entirely
				// before the position, while still allowing us to find any nodes in the
				// last one that might be what we want.
				lastNodeEntirelyBeforePosition = child
			}
		} else {
			Debug.assert(child.pos > position)
			// We're now at a node that is entirely past the position we're searching for.
			// This node (and all following nodes) could never contribute to the result,
			// so just skip them by returning 'true' here.
			return true
		}
	}

}

func checkChangeRange(sourceFile SourceFile, newText string, textChangeRange TextChangeRange, aggressiveChecks bool) {
	oldText := sourceFile.text
	if textChangeRange {
		Debug.assert((oldText.length - textChangeRange.span.length + textChangeRange.newLength) == newText.length)

		if aggressiveChecks || Debug.shouldAssert(AssertionLevelVeryAggressive) {
			oldTextPrefix := oldText.substr(0, textChangeRange.span.start)
			newTextPrefix := newText.substr(0, textChangeRange.span.start)
			Debug.assert(oldTextPrefix == newTextPrefix)

			oldTextSuffix := oldText.substring(textSpanEnd(textChangeRange.span), oldText.length)
			newTextSuffix := newText.substring(textSpanEnd(textChangeRangeNewSpan(textChangeRange)), newText.length)
			Debug.assert(oldTextSuffix == newTextSuffix)
		}
	}
}

// Allows finding nodes in the source file at a certain position in an efficient manner.
// The implementation takes advantage of the calling pattern it knows the parser will
// make in order to optimize finding nodes as quickly as possible.
type SyntaxCursor struct {
	/* TODO(TS-TO-GO) Node InterfaceDeclaration: export interface SyntaxCursor { currentNode(position: number): Node; } */
}

func createSyntaxCursor(sourceFile SourceFile) SyntaxCursor {
	var currentArray NodeArray[Node] = sourceFile.statements
	currentArrayIndex := 0

	Debug.assert(currentArrayIndex < currentArray.length)
	current := currentArray[currentArrayIndex]
	lastQueriedPosition := InvalidPositionValue

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"currentNode": func(position number) Node {
			// Only compute the current node if the position is different than the last time
			// we were asked.  The parser commonly asks for the node at the same position
			// twice.  Once to know if can read an appropriate list element at a certain point,
			// and then to actually read and consume the node.
			if position != lastQueriedPosition {
				// Much of the time the parser will need the very next node in the array that
				// we just returned a node from.So just simply check for that case and move
				// forward in the array instead of searching for the node again.
				if current && current.end == position && currentArrayIndex < (currentArray.length-1) {
					currentArrayIndex++
					current = currentArray[currentArrayIndex]
				}

				// If we don't have a node, or the node we have isn't in the right position,
				// then try to find a viable node at the position requested.
				if !current || current.pos != position {
					findHighestListElementThatStartsAtPosition(position)
				}
			}

			// Cache this query so that we don't do any extra work if the parser calls back
			// into us.  Note: this is very common as the parser will make pairs of calls like
			// 'isListElement -> parseListElement'.  If we were unable to find a node when
			// called with 'isListElement', we don't want to redo the work when parseListElement
			// is called immediately after.
			lastQueriedPosition = position

			// Either we don'd have a node, or we have a node at the position being asked for.
			Debug.assert(!current || current.pos == position)
			return current
		},
	}

	// Finds the highest element in the tree we can find that starts at the provided position.
	// The element must be a direct child of some node list in the tree.  This way after we
	// return it, we can easily return its next sibling in the list.
	findHighestListElementThatStartsAtPosition := func(position number) {
		// Clear out any cached state about the last node we found.
		currentArray = nil
		currentArrayIndex = InvalidPositionValue
		current = nil

		// Recurse into the source file to find the highest node at this position.
		forEachChild(sourceFile, visitNode, visitArray)
		return

		visitNode := func(node Node) bool {
			if position >= node.pos && position < node.end {
				// Position was within this node.  Keep searching deeper to find the node.
				forEachChild(node, visitNode, visitArray)

				// don't proceed any further in the search.
				return true
			}

			// position wasn't in this node, have to keep searching.
			return false
		}

		visitArray := func(array NodeArray[Node]) bool {
			if position >= array.pos && position < array.end {
				// position was in this array.  Search through this array to see if we find a
				// viable element.
				for i := 0; i < array.length; i++ {
					child := array[i]
					if child {
						if child.pos == position {
							// Found the right node.  We're done.
							currentArray = array
							currentArrayIndex = i
							current = child
							return true
						} else {
							if child.pos < position && position < child.end {
								// Position in somewhere within this child.  Search in it and
								// stop searching in this array.
								forEachChild(child, visitNode, visitArray)
								return true
							}
						}
					}
				}
			}

			// position wasn't in this array, have to keep searching.
			return false
		}

	}

}

type InvalidPosition int32

const (
	InvalidPositionValue InvalidPosition = -1
)

// #endregion IncrementalParser

/** @internal */

func isDeclarationFileName(fileName string) bool {
	return getDeclarationFileExtension(fileName) != nil
}

/** @internal */

func getDeclarationFileExtension(fileName string) *string {
	standardExtension := getAnyExtensionFromPath(fileName, supportedDeclarationExtensions /*ignoreCase*/, false)
	if standardExtension {
		return standardExtension
	}
	if fileExtensionIs(fileName, ExtensionTs) {
		baseName := getBaseFileName(fileName)
		index := baseName.lastIndexOf(".d.")
		if index >= 0 {
			return baseName.substring(index)
		}
	}
	return nil
}

func parseResolutionMode(mode *string, pos number, end number, reportDiagnostic PragmaDiagnosticReporter) ResolutionMode {
	if !mode {
		return nil
	}
	if mode == "import" {
		return ModuleKindESNext
	}
	if mode == "require" {
		return ModuleKindCommonJS
	}
	reportDiagnostic(pos, end-pos, Diagnostics.resolution_mode_should_be_either_require_or_import)
	return nil
}

/** @internal */

func processCommentPragmas(context PragmaContext, sourceText string) {
	var pragmas []PragmaPseudoMapEntry = []never{}

	for _, range_ := range getLeadingCommentRanges(sourceText, 0) || emptyArray {
		comment := sourceText.substring(range_.pos, range_.end)
		extractPragmas(pragmas, range_, comment)
	}

	context.pragmas = NewMap().(PragmaMap)
	for _, pragma := range pragmas {
		if context.pragmas.has(pragma.name) {
			currentValue := context.pragmas.get(pragma.name)
			if /* TODO(TS-TO-GO) InstanceOfKeyword BinaryExpression: currentValue instanceof Array */ TODO {
				currentValue.push(pragma.args)
			} else {
				context.pragmas.set(pragma.name, [] /* TODO(TS-TO-GO) inferred type { arguments: { types?: { value: string; pos: number; end: number; } | undefined; } & { lib?: { value: string; pos: number; end: number; } | undefined; } & { path?: { value: string; pos: number; end: number; } | undefined; } & { "no-default-lib"?: string | undefined; } & { "resolution-mode"?: string | undefined; } & { preserve?: string | undefined; }; range: CommentRange; } | { arguments: { path: string; } & { name?: string | undefined; }; range: CommentRange; } | { arguments: { name: string; }; range: CommentRange; } | { arguments: { factory: string; }; range: CommentRange; } */ any{currentValue, pragma.args})
			}
			continue
		}
		context.pragmas.set(pragma.name, pragma.args)
	}
}

/** @internal */

type PragmaDiagnosticReporter func(pos number, length number, message DiagnosticMessage)

/** @internal */

func processPragmasIntoFields(context PragmaContext, reportDiagnostic PragmaDiagnosticReporter) {
	context.checkJsDirective = nil
	context.referencedFiles = []never{}
	context.typeReferenceDirectives = []never{}
	context.libReferenceDirectives = []never{}
	context.amdDependencies = []never{}
	context.hasNoDefaultLib = false
	context.pragmas.forEach(func(entryOrList [] /* TODO(TS-TO-GO) inferred type PragmaPseudoMap[TKey] | PragmaPseudoMap[TKey] */ any, key TKey) {
		// TODO: The below should be strongly type-guarded and not need casts/explicit annotations, since entryOrList is related to
		// key and key is constrained to a union; but it's not (see GH#21483 for at least partial fix) :(
		switch key {
		case "reference":
			referencedFiles := context.referencedFiles
			typeReferenceDirectives := context.typeReferenceDirectives
			libReferenceDirectives := context.libReferenceDirectives
			forEach(toArray(entryOrList) /* as PragmaPseudoMap["reference"][] */, func(arg /* TODO(TS-TO-GO) inferred type { arguments: { types?: { value: string; pos: number; end: number; } | undefined; } & { lib?: { value: string; pos: number; end: number; } | undefined; } & { path?: { value: string; pos: number; end: number; } | undefined; } & { "no-default-lib"?: string | undefined; } & { "resolution-mode"?: string | undefined; } & { preserve?: string | undefined; }; range: CommentRange; } */ any) {
				TODO_IDENTIFIER := arg.arguments
				var preserve *true
				if _preserve == "true" {
					preserve = true
				} else {
					preserve = nil
				}
				if arg.arguments["no-default-lib"] == "true" {
					context.hasNoDefaultLib = true
				} else if types {
					parsed := parseResolutionMode(res, types.pos, types.end, reportDiagnostic)
					typeReferenceDirectives.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"pos":      types.pos,
						"end":      types.end,
						"fileName": types.value,
						/* TODO(TS-TO-GO) Node SpreadAssignment: ...(parsed ? { resolutionMode: parsed } : {}) */
						/* TODO(TS-TO-GO) Node SpreadAssignment: ...(preserve ? { preserve } : {}) */
					})
				} else if lib {
					libReferenceDirectives.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"pos":      lib.pos,
						"end":      lib.end,
						"fileName": lib.value,
						/* TODO(TS-TO-GO) Node SpreadAssignment: ...(preserve ? { preserve } : {}) */
					})
				} else if path {
					referencedFiles.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"pos":      path.pos,
						"end":      path.end,
						"fileName": path.value,
						/* TODO(TS-TO-GO) Node SpreadAssignment: ...(preserve ? { preserve } : {}) */
					})
				} else {
					reportDiagnostic(arg.range_.pos, arg.range_.end-arg.range_.pos, Diagnostics.Invalid_reference_directive_syntax)
				}
			})
		case "amd-dependency":
			context.amdDependencies = map_(toArray(entryOrList) /* as PragmaPseudoMap["amd-dependency"][] */, func(x /* TODO(TS-TO-GO) inferred type { arguments: { path: string; } & { name?: string | undefined; }; range: CommentRange; } */ any) /* TODO(TS-TO-GO) inferred type { name: string | undefined; path: string; } */ any {
				return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"name": x.arguments.name,
					"path": x.arguments.path,
				})
			})
		case "amd-module":
			if /* TODO(TS-TO-GO) InstanceOfKeyword BinaryExpression: entryOrList instanceof Array */ TODO {
				for _, entry := range entryOrList {
					if context.moduleName {
						// TODO: It's probably fine to issue this diagnostic on all instances of the pragma
						reportDiagnostic(entry.range_.pos, entry.range_.end-entry.range_.pos, Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments)
					}
					context.moduleName = (entry /* as PragmaPseudoMap["amd-module"] */).arguments.name
				}
			} else {
				context.moduleName = (entryOrList /* as PragmaPseudoMap["amd-module"] */).arguments.name
			}
		case "ts-nocheck",
			"ts-check":
			// _last_ of either nocheck or check in a file is the "winner"
			forEach(toArray(entryOrList), func(entry /* TODO(TS-TO-GO) inferred type PragmaPseudoMap[TKey] */ any) {
				if !context.checkJsDirective || entry.range_.pos > context.checkJsDirective.pos {
					context.checkJsDirective = map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"enabled": key == "ts-check",
						"end":     entry.range_.end,
						"pos":     entry.range_.pos,
					}
				}
			})
		case "jsx",
			"jsxfrag",
			"jsximportsource",
			"jsxruntime":
			return
			// Accessed directly
		default:
			Debug.fail("Unhandled pragma kind")
			// Can this be made into an assertNever in the future?
		}
	})
}

var namedArgRegExCache = NewMap[string, RegExp]()

func getNamedArgRegEx(name string) RegExp {
	if namedArgRegExCache.has(name) {
		return namedArgRegExCache.get(name)
	}
	result := NewRegExp(__TEMPLATE__("(\\s", name, "\\s*=\\s*)(?:(?:'([^']*)')|(?:\"([^\"]*)\"))"), "im")
	namedArgRegExCache.set(name, result)
	return result
}

var tripleSlashXMLCommentStartRegEx = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /^\/\/\/\s*<(\S+)\s.*?\/>/m */ TODO
var singleLinePragmaRegEx = /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /^\/\/\/?\s*@([^\s:]+)((?:[^\S\r\n]|:).*)?$/m */ TODO

func extractPragmas(pragmas []PragmaPseudoMapEntry, range_ CommentRange, text string) {
	tripleSlash := range_.kind == SyntaxKindSingleLineCommentTrivia && tripleSlashXMLCommentStartRegEx.exec(text)
	if tripleSlash {
		name := tripleSlash[1].toLowerCase() /* as keyof PragmaPseudoMap */
		// Technically unsafe cast, but we do it so the below check to make it safe typechecks
		pragma := commentPragmas[name].(PragmaDefinition)
		if !pragma || !(pragma.kind & PragmaKindFlagsTripleSlashXML) {
			return
		}
		if pragma.args {
			var argument /* TODO(TS-TO-GO) TypeNode TypeLiteral: { [index: string]: string | { value: string; pos: number; end: number; }; } */ any = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			}
			for _, arg := range pragma.args {
				matcher := getNamedArgRegEx(arg.name)
				matchResult := matcher.exec(text)
				if !matchResult && !arg.optional {
					return
					// Missing required argument, don't parse
				} else if matchResult {
					value := matchResult[2] || matchResult[3]
					if arg.captureSpan {
						startPos := range_.pos + matchResult.index + matchResult[1].length + 1
						argument[arg.name] = map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"value": value,
							"pos":   startPos,
							"end":   startPos + value.length,
						}
					} else {
						argument[arg.name] = value
					}
				}
			}
			pragmas.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"name": name,
				"args": map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"arguments": argument,
					"range_":    range_,
				},
			}.(PragmaPseudoMapEntry))
		} else {
			pragmas.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"name": name,
				"args": map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"arguments": map[any]any{ /* TODO(TS-TO-GO): was object literal */
					},
					"range_": range_,
				},
			}.(PragmaPseudoMapEntry))
		}
		return
	}

	singleLine := range_.kind == SyntaxKindSingleLineCommentTrivia && singleLinePragmaRegEx.exec(text)
	if singleLine {
		return addPragmaForMatch(pragmas, range_, PragmaKindFlagsSingleLine, singleLine)
	}

	if range_.kind == SyntaxKindMultiLineCommentTrivia {
		multiLinePragmaRegEx := /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /@(\S+)(\s+(?:\S.*)?)?$/gm */ TODO
		// Defined inline since it uses the "g" flag, which keeps a persistent index (for iterating)
		var multiLineMatch /* TODO(TS-TO-GO) TypeNode UnionType: RegExpExecArray | null */ any
		// eslint-disable-line no-restricted-syntax
		for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: multiLineMatch = multiLinePragmaRegEx.exec(text) */ TODO {
			addPragmaForMatch(pragmas, range_, PragmaKindFlagsMultiLine, multiLineMatch)
		}
	}
}

func addPragmaForMatch(pragmas []PragmaPseudoMapEntry, range_ CommentRange, kind PragmaKindFlags, match RegExpExecArray) {
	if !match {
		return
	}
	name := match[1].toLowerCase() /* as keyof PragmaPseudoMap */
	// Technically unsafe cast, but we do it so they below check to make it safe typechecks
	pragma := commentPragmas[name].(PragmaDefinition)
	if !pragma || !(pragma.kind & kind) {
		return
	}
	args := match[2]
	// Split on spaces and match up positionally with definition
	argument := getNamedPragmaArguments(pragma, args)
	if argument == "fail" {
		return
		// Missing required argument, fail to parse it
	}
	// Missing required argument, fail to parse it
	pragmas.push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"name": name,
		"args": map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"arguments": argument,
			"range_":    range_,
		},
	}.(PragmaPseudoMapEntry))
	return
}

func getNamedPragmaArguments(pragma PragmaDefinition, text *string) /* TODO(TS-TO-GO) TypeNode UnionType: { [index: string]: string; } | "fail" */ any {
	if !text {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		}
	}
	if !pragma.args {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		}
	}
	args := text.trim().split(regexp.MustParse(`\s+`))
	var argMap /* TODO(TS-TO-GO) TypeNode TypeLiteral: { [index: string]: string; } */ any = map[any]any{ /* TODO(TS-TO-GO): was object literal */
	}
	for i := 0; i < pragma.args.length; i++ {
		argument := pragma.args[i]
		if !args[i] && !argument.optional {
			return "fail"
		}
		if argument.captureSpan {
			return Debug.fail("Capture spans not yet implemented for non-xml pragmas")
		}
		argMap[argument.name] = args[i]
	}
	return argMap
}

/** @internal */

func tagNamesAreEquivalent(lhs JsxTagNameExpression, rhs JsxTagNameExpression) bool {
	if lhs.kind != rhs.kind {
		return false
	}

	if lhs.kind == SyntaxKindIdentifier {
		return lhs.escapedText == (rhs.(Identifier)).escapedText
	}

	if lhs.kind == SyntaxKindThisKeyword {
		return true
	}

	if lhs.kind == SyntaxKindJsxNamespacedName {
		return lhs.namespace.escapedText == (rhs.(JsxNamespacedName)).namespace.escapedText && lhs.name.escapedText == (rhs.(JsxNamespacedName)).name.escapedText
	}

	// If we are at this statement then we must have PropertyAccessExpression and because tag name in Jsx element can only
	// take forms of JsxTagNameExpression which includes an identifier, "this" expression, or another propertyAccessExpression
	// it is safe to case the expression property as such. See parseJsxElementName for how we parse tag name in Jsx element
	return (lhs.(PropertyAccessExpression)).name.escapedText == (rhs.(PropertyAccessExpression)).name.escapedText && tagNamesAreEquivalent((lhs.(PropertyAccessExpression)).expression.(JsxTagNameExpression), (rhs.(PropertyAccessExpression)).expression.(JsxTagNameExpression))
}
