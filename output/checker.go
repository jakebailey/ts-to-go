// Code generated by ts-to-go at 31afb988d1c6857ce4d1ab3b2558385e68a565a8. DO NOT EDIT.

package output

func __COND__[C comparable, T any](cond C, a T, b T) T {
	var zero C
	if cond != zero {
		return a
	}
	return b
}

type TypeChecker struct {
	deferredDiagnosticsCallbacks []func()
	addLazyDiagnostic/* TODO(TS-TO-GO) inferred type (arg: () => void) => void */ any
	cancellationToken CancellationToken
	scanner           *Scanner
	Symbol/* TODO(TS-TO-GO) inferred type new (flags: SymbolFlags, name: __String) => Symbol */ any
	Type/* TODO(TS-TO-GO) inferred type new (checker: TypeChecker, flags: TypeFlags) => Type */ any
	Signature/* TODO(TS-TO-GO) inferred type new (checker: TypeChecker, flags: SignatureFlags) => Signature */ any
	typeCount                    number
	symbolCount                  number
	totalInstantiationCount      number
	instantiationCount           number
	instantiationDepth           number
	inlineLevel                  number
	currentNode                  Node
	varianceTypeParameter        *TypeParameter
	isInferencePartiallyBlocked  bool
	emptySymbols                 SymbolTable
	arrayVariances               []VarianceFlags
	compilerOptions              CompilerOptions
	languageVersion              ScriptTarget
	moduleKind                   ModuleKind
	legacyDecorators             bool
	useDefineForClassFields      bool
	emitStandardClassFields      bool
	allowSyntheticDefaultImports bool
	strictNullChecks             bool
	strictFunctionTypes          bool
	strictBindCallApply          bool
	strictPropertyInitialization bool
	strictBuiltinIteratorReturn  bool
	noImplicitAny                bool
	noImplicitThis               bool
	useUnknownInCatchVariables   bool
	exactOptionalPropertyTypes   *bool
	noUncheckedSideEffectImports bool
	checkBinaryExpression/* TODO(TS-TO-GO) inferred type (node: BinaryExpression, checkMode: CheckMode | undefined) => Type */ any
	emitResolver EmitResolver
	nodeBuilder/* TODO(TS-TO-GO) inferred type { typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => SignatureDeclaration | undefined; symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => EntityName | undefined; symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | undefined; symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => NodeArray<TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Statement[] | undefined; symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | ComputedPropertyName | undefined; } */ any
	syntacticNodeBuilder/* TODO(TS-TO-GO) inferred type { typeFromExpression: (node: Expression, context: SyntacticTypeNodeBuilderContext, isConstContext?: boolean, requiresAddingUndefined?: boolean, preserveLiterals?: boolean) => boolean | undefined; serializeTypeOfDeclaration: (node: HasInferredType, context: SyntacticTypeNodeBuilderContext) => boolean | undefined; serializeReturnTypeForSignature: (node: SignatureDeclaration | JSDocSignature, context: SyntacticTypeNodeBuilderContext) => boolean | undefined; serializeTypeOfExpression: (expr: Expression, context: SyntacticTypeNodeBuilderContext, addUndefined?: boolean, preserveLiterals?: boolean) => boolean; } */ any
	evaluate/* TODO(TS-TO-GO) inferred type { (expr: TemplateExpression, location?: Declaration): EvaluatorResult<string | undefined>; (expr: Expression, location?: Declaration): EvaluatorResult; } */ any
	globals                                         SymbolTable
	undefinedSymbol                                 TransientSymbol
	globalThisSymbol                                TransientSymbol
	argumentsSymbol                                 TransientSymbol
	requireSymbol                                   TransientSymbol
	isolatedModulesLikeFlagName                     string
	canCollectSymbolAliasAccessabilityData          bool
	apparentArgumentCount                           *number
	lastGetCombinedNodeFlagsNode                    Node
	lastGetCombinedNodeFlagsResult                  NodeFlags
	lastGetCombinedModifierFlagsNode                Declaration
	lastGetCombinedModifierFlagsResult              ModifierFlags
	resolveName                                     * /* TODO(TS-TO-GO) inferred type (location: Node | undefined, nameArg: __String | Identifier, meaning: SymbolFlags, nameNotFoundMessage: DiagnosticMessage | undefined, isUse: boolean, excludeGlobals?: boolean) => Symbol */ any
	resolveNameForSymbolSuggestion                  * /* TODO(TS-TO-GO) inferred type (location: Node | undefined, nameArg: __String | Identifier, meaning: SymbolFlags, nameNotFoundMessage: DiagnosticMessage | undefined, isUse: boolean, excludeGlobals?: boolean) => Symbol */ any
	checker                                         TypeChecker
	tupleTypes                                      Map[string, GenericType]
	unionTypes                                      Map[string, UnionType]
	unionOfUnionTypes                               Map[string, Type]
	intersectionTypes                               Map[string, Type]
	stringLiteralTypes                              Map[string, StringLiteralType]
	numberLiteralTypes                              Map[number, NumberLiteralType]
	bigIntLiteralTypes                              Map[string, BigIntLiteralType]
	enumLiteralTypes                                Map[string, LiteralType]
	indexedAccessTypes                              Map[string, IndexedAccessType]
	templateLiteralTypes                            Map[string, TemplateLiteralType]
	stringMappingTypes                              Map[string, StringMappingType]
	substitutionTypes                               Map[string, SubstitutionType]
	subtypeReductionCache                           Map[string, []Type]
	decoratorContextOverrideTypeCache               Map[string, Type]
	cachedTypes                                     Map[string, Type]
	evolvingArrayTypes                              []EvolvingArrayType
	undefinedProperties                             SymbolTable
	markerTypes                                     Set[number]
	unknownSymbol                                   TransientSymbol
	resolvingSymbol                                 TransientSymbol
	unresolvedSymbols                               Map[string, TransientSymbol]
	errorTypes                                      Map[string, Type]
	seenIntrinsicNames                              Set[string]
	anyType                                         IntrinsicType
	autoType                                        IntrinsicType
	wildcardType                                    IntrinsicType
	blockedStringType                               IntrinsicType
	errorType                                       IntrinsicType
	unresolvedType                                  IntrinsicType
	nonInferrableAnyType                            IntrinsicType
	intrinsicMarkerType                             IntrinsicType
	unknownType                                     IntrinsicType
	undefinedType                                   IntrinsicType
	undefinedWideningType                           IntrinsicType
	missingType                                     IntrinsicType
	undefinedOrMissingType                          IntrinsicType
	optionalType                                    IntrinsicType
	nullType                                        IntrinsicType
	nullWideningType                                IntrinsicType
	stringType                                      IntrinsicType
	numberType                                      IntrinsicType
	bigintType                                      IntrinsicType
	falseType                                       FreshableIntrinsicType
	regularFalseType                                FreshableIntrinsicType
	trueType                                        FreshableIntrinsicType
	regularTrueType                                 FreshableIntrinsicType
	booleanType                                     Type
	esSymbolType                                    IntrinsicType
	voidType                                        IntrinsicType
	neverType                                       IntrinsicType
	silentNeverType                                 IntrinsicType
	implicitNeverType                               IntrinsicType
	unreachableNeverType                            IntrinsicType
	nonPrimitiveType                                IntrinsicType
	stringOrNumberType                              Type
	stringNumberSymbolType                          Type
	numberOrBigIntType                              Type
	templateConstraintType                          UnionType
	numericStringType                               Type
	restrictiveMapper                               TypeMapper
	permissiveMapper                                TypeMapper
	uniqueLiteralType                               IntrinsicType
	uniqueLiteralMapper                             TypeMapper
	outofbandVarianceMarkerHandler                  *func(onlyUnreliable bool)
	reportUnreliableMapper                          TypeMapper
	reportUnmeasurableMapper                        TypeMapper
	emptyObjectType                                 ResolvedType
	emptyJsxObjectType                              ResolvedType
	emptyTypeLiteralSymbol                          TransientSymbol
	emptyTypeLiteralType                            ResolvedType
	unknownEmptyObjectType                          ResolvedType
	unknownUnionType                                Type
	emptyGenericType                                GenericType
	anyFunctionType                                 ResolvedType
	noConstraintType                                ResolvedType
	circularConstraintType                          ResolvedType
	resolvingDefaultType                            ResolvedType
	markerSuperType                                 TypeParameter
	markerSubType                                   TypeParameter
	markerOtherType                                 TypeParameter
	markerSuperTypeForCheck                         TypeParameter
	markerSubTypeForCheck                           TypeParameter
	noTypePredicate                                 TypePredicate
	anySignature                                    Signature
	unknownSignature                                Signature
	resolvingSignature                              Signature
	silentNeverSignature                            Signature
	enumNumberIndexInfo                             IndexInfo
	iterationTypesCache                             Map[string, IterationTypes]
	noIterationTypes                                IterationTypes
	anyIterationTypes                               IterationTypes
	asyncIterationTypesResolver                     IterationTypesResolver
	syncIterationTypesResolver                      IterationTypesResolver
	amalgamatedDuplicates                           *Map[string, DuplicateInfoForFiles]
	reverseMappedCache                              Map[string, Type]
	reverseHomomorphicMappedCache                   Map[string, Type]
	ambientModulesCache                             *[]Symbol
	patternAmbientModules                           []PatternAmbientModule
	patternAmbientModuleAugmentations               *Map[string, Symbol]
	globalObjectType                                ObjectType
	globalFunctionType                              ObjectType
	globalCallableFunctionType                      ObjectType
	globalNewableFunctionType                       ObjectType
	globalArrayType                                 GenericType
	globalReadonlyArrayType                         GenericType
	globalStringType                                ObjectType
	globalNumberType                                ObjectType
	globalBooleanType                               ObjectType
	globalRegExpType                                ObjectType
	globalThisType                                  GenericType
	anyArrayType                                    Type
	autoArrayType                                   Type
	anyReadonlyArrayType                            Type
	deferredGlobalNonNullableTypeAlias              Symbol
	deferredGlobalESSymbolConstructorSymbol         Symbol
	deferredGlobalESSymbolConstructorTypeSymbol     Symbol
	deferredGlobalESSymbolType                      *ObjectType
	deferredGlobalTypedPropertyDescriptorType       GenericType
	deferredGlobalPromiseType                       *GenericType
	deferredGlobalPromiseLikeType                   *GenericType
	deferredGlobalPromiseConstructorSymbol          Symbol
	deferredGlobalPromiseConstructorLikeType        *ObjectType
	deferredGlobalIterableType                      *GenericType
	deferredGlobalIteratorType                      *GenericType
	deferredGlobalIterableIteratorType              *GenericType
	deferredGlobalIteratorObjectType                *GenericType
	deferredGlobalGeneratorType                     *GenericType
	deferredGlobalIteratorYieldResultType           *GenericType
	deferredGlobalIteratorReturnResultType          *GenericType
	deferredGlobalAsyncIterableType                 *GenericType
	deferredGlobalAsyncIteratorType                 *GenericType
	deferredGlobalAsyncIterableIteratorType         *GenericType
	deferredGlobalBuiltinIteratorTypes              *[]GenericType
	deferredGlobalBuiltinAsyncIteratorTypes         *[]GenericType
	deferredGlobalAsyncIteratorObjectType           *GenericType
	deferredGlobalAsyncGeneratorType                *GenericType
	deferredGlobalTemplateStringsArrayType          *ObjectType
	deferredGlobalImportMetaType                    ObjectType
	deferredGlobalImportMetaExpressionType          ObjectType
	deferredGlobalImportCallOptionsType             *ObjectType
	deferredGlobalImportAttributesType              *ObjectType
	deferredGlobalDisposableType                    *ObjectType
	deferredGlobalAsyncDisposableType               *ObjectType
	deferredGlobalExtractSymbol                     Symbol
	deferredGlobalOmitSymbol                        Symbol
	deferredGlobalAwaitedSymbol                     Symbol
	deferredGlobalBigIntType                        *ObjectType
	deferredGlobalNaNSymbol                         Symbol
	deferredGlobalRecordSymbol                      Symbol
	deferredGlobalClassDecoratorContextType         *GenericType
	deferredGlobalClassMethodDecoratorContextType   *GenericType
	deferredGlobalClassGetterDecoratorContextType   *GenericType
	deferredGlobalClassSetterDecoratorContextType   *GenericType
	deferredGlobalClassAccessorDecoratorContextType *GenericType
	deferredGlobalClassAccessorDecoratorTargetType  *GenericType
	deferredGlobalClassAccessorDecoratorResultType  *GenericType
	deferredGlobalClassFieldDecoratorContextType    *GenericType
	allPotentiallyUnusedIdentifiers                 Map[Path, [] /* TODO(TS-TO-GO) inferred type (SourceFile | CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | FunctionTypeNode | ConstructorTypeNode | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | AccessorDeclaration | FunctionExpression | ArrowFunction | ForStatement | ForOfStatement | ForInStatement | InterfaceDeclaration | ClassLikeDeclaration | Block | ModuleDeclaration | TypeAliasDeclaration | CaseBlock | InferTypeNode) */ any]
	flowLoopStart                                   number
	flowLoopCount                                   number
	sharedFlowCount                                 number
	flowAnalysisDisabled                            bool
	flowInvocationCount                             number
	lastFlowNode                                    *FlowNode
	lastFlowNodeReachable                           bool
	flowTypeCache                                   *[]Type
	contextualTypeNodes                             []Node
	contextualTypes                                 []Type
	contextualIsCache                               []bool
	contextualTypeCount                             number
	contextualBindingPatterns                       []BindingPattern
	inferenceContextNodes                           []Node
	inferenceContexts                               []*InferenceContext
	inferenceContextCount                           number
	emptyStringType                                 StringLiteralType
	zeroType                                        NumberLiteralType
	zeroBigIntType                                  BigIntLiteralType
	resolutionTargets                               []TypeSystemEntity
	resolutionResults                               []bool
	resolutionPropertyNames                         []TypeSystemPropertyName
	resolutionStart                                 number
	inVarianceComputation                           bool
	suggestionCount                                 number
	maximumSuggestionCount                          number
	mergedSymbols                                   []Symbol
	symbolLinks                                     []SymbolLinks
	nodeLinks                                       []NodeLinks
	flowLoopCaches                                  []Map[string, Type]
	flowLoopNodes                                   []FlowNode
	flowLoopKeys                                    []string
	flowLoopTypes                                   [][]Type
	sharedFlowNodes                                 []FlowNode
	sharedFlowTypes                                 []FlowType
	flowNodeReachable                               []*bool
	flowNodePostSuper                               []*bool
	potentialThisCollisions                         []Node
	potentialNewTargetCollisions                    []Node
	potentialWeakMapSetCollisions                   []Node
	potentialReflectCollisions                      []Node
	potentialUnusedRenamedBindingElementsInTypes    []BindingElement
	awaitedTypeStack                                []number
	reverseMappedSourceStack                        []Type
	reverseMappedTargetStack                        []Type
	reverseExpandingFlags                           ExpandingFlags
	diagnostics                                     DiagnosticCollection
	suggestionDiagnostics                           DiagnosticCollection
	typeofType                                      Type
	_jsxNamespace                                   __String
	_jsxFactoryEntity                               *EntityName
	subtypeRelation                                 Map[string, RelationComparisonResult]
	strictSubtypeRelation                           Map[string, RelationComparisonResult]
	assignableRelation                              Map[string, RelationComparisonResult]
	comparableRelation                              Map[string, RelationComparisonResult]
	identityRelation                                Map[string, RelationComparisonResult]
	enumRelation                                    Map[string, RelationComparisonResult]
	suggestedExtensions                             [] /* TODO(TS-TO-GO) TypeNode TupleType: [string, string] */ any
}

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)" /* as __String & string */

type ReferenceHint int32

const (
	ReferenceHintUnspecified ReferenceHint = iota
	ReferenceHintIdentifier
	ReferenceHintProperty
	ReferenceHintExportAssignment
	ReferenceHintJsx
	ReferenceHintAsyncFunction
	ReferenceHintExportImportEquals
	ReferenceHintExportSpecifier
	ReferenceHintDecorator
)

var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1

type IterationUse int32

const (
	IterationUseAllowsSyncIterablesFlag  IterationUse = 1 << 0
	IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
	IterationUseAllowsStringInputFlag    IterationUse = 1 << 2
	IterationUseForOfFlag                IterationUse = 1 << 3
	IterationUseYieldStarFlag            IterationUse = 1 << 4
	IterationUseSpreadFlag               IterationUse = 1 << 5
	IterationUseDestructuringFlag        IterationUse = 1 << 6
	IterationUsePossiblyOutOfBounds      IterationUse = 1 << 7
	// Spread, Destructuring, Array element assignment
	IterationUseElement                  IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseSpread                   IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
	IterationUseDestructuring            IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
	IterationUseForOf                    IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseForAwaitOf               IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseYieldStar                IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseAsyncYieldStar           IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseGeneratorReturnType      IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)

type IterationTypeKind int32

const (
	IterationTypeKindYield IterationTypeKind = iota
	IterationTypeKindReturn
	IterationTypeKindNext
)

type IterationTypesResolver struct {
	iterableCacheKey/* TODO(TS-TO-GO) TypeNode UnionType: "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
	iteratorCacheKey/* TODO(TS-TO-GO) TypeNode UnionType: "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */ any
	iteratorSymbolName/* TODO(TS-TO-GO) TypeNode UnionType: "asyncIterator" | "iterator" */ any
	getGlobalIteratorType         func(reportErrors bool) GenericType
	getGlobalIterableType         func(reportErrors bool) GenericType
	getGlobalIterableIteratorType func(reportErrors bool) GenericType
	getGlobalIteratorObjectType   func(reportErrors bool) GenericType
	getGlobalGeneratorType        func(reportErrors bool) GenericType
	getGlobalBuiltinIteratorTypes func() []GenericType
	resolveIterationType          func(type_ Type, errorNode Node) Type
	mustHaveANextMethodDiagnostic DiagnosticMessage
	mustBeAMethodDiagnostic       DiagnosticMessage
	mustHaveAValueDiagnostic      DiagnosticMessage
}

type WideningKind int32

const (
	WideningKindNormal WideningKind = iota
	WideningKindFunctionReturn
	WideningKindGeneratorNext
	WideningKindGeneratorYield
)

// dprint-ignore

type TypeFacts int32

const (
	TypeFactsNone               TypeFacts = 0
	TypeFactsTypeofEQString     TypeFacts = 1 << 0
	TypeFactsTypeofEQNumber     TypeFacts = 1 << 1
	TypeFactsTypeofEQBigInt     TypeFacts = 1 << 2
	TypeFactsTypeofEQBoolean    TypeFacts = 1 << 3
	TypeFactsTypeofEQSymbol     TypeFacts = 1 << 4
	TypeFactsTypeofEQObject     TypeFacts = 1 << 5
	TypeFactsTypeofEQFunction   TypeFacts = 1 << 6
	TypeFactsTypeofEQHostObject TypeFacts = 1 << 7
	TypeFactsTypeofNEString     TypeFacts = 1 << 8
	TypeFactsTypeofNENumber     TypeFacts = 1 << 9
	TypeFactsTypeofNEBigInt     TypeFacts = 1 << 10
	TypeFactsTypeofNEBoolean    TypeFacts = 1 << 11
	TypeFactsTypeofNESymbol     TypeFacts = 1 << 12
	TypeFactsTypeofNEObject     TypeFacts = 1 << 13
	TypeFactsTypeofNEFunction   TypeFacts = 1 << 14
	TypeFactsTypeofNEHostObject TypeFacts = 1 << 15
	TypeFactsEQUndefined        TypeFacts = 1 << 16
	TypeFactsEQNull             TypeFacts = 1 << 17
	TypeFactsEQUndefinedOrNull  TypeFacts = 1 << 18
	TypeFactsNEUndefined        TypeFacts = 1 << 19
	TypeFactsNENull             TypeFacts = 1 << 20
	TypeFactsNEUndefinedOrNull  TypeFacts = 1 << 21
	TypeFactsTruthy             TypeFacts = 1 << 22
	TypeFactsFalsy              TypeFacts = 1 << 23
	TypeFactsIsUndefined        TypeFacts = 1 << 24
	TypeFactsIsNull             TypeFacts = 1 << 25
	TypeFactsIsUndefinedOrNull  TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
	TypeFactsAll                TypeFacts = (1 << 27) - 1
	// The following members encode facts about particular kinds of types for use in the getTypeFacts function.
	// The presence of a particular fact means that the given test is true for some (and possibly all) values
	// of that kind of type.
	TypeFactsBaseStringStrictFacts     TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseStringFacts           TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsStringStrictFacts         TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsStringFacts               TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsEmptyStringStrictFacts    TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
	TypeFactsEmptyStringFacts          TypeFacts = TypeFactsBaseTypeFactsStringFacts
	TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
	TypeFactsNonEmptyStringFacts       TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsBaseNumberStrictFacts     TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsNumberStrictFacts         TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsNumberFacts               TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsZeroNumberStrictFacts     TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
	TypeFactsZeroNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberFacts
	TypeFactsNonZeroNumberStrictFacts  TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroNumberFacts        TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsBaseBigIntStrictFacts     TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBigIntStrictFacts         TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBigIntFacts               TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsZeroBigIntStrictFacts     TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
	TypeFactsZeroBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
	TypeFactsNonZeroBigIntStrictFacts  TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroBigIntFacts        TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsBaseBooleanStrictFacts    TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBooleanFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBooleanStrictFacts        TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBooleanFacts              TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsFalseStrictFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
	TypeFactsFalseFacts                TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
	TypeFactsTrueStrictFacts           TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
	TypeFactsTrueFacts                 TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsSymbolStrictFacts         TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsSymbolFacts               TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsObjectStrictFacts         TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsObjectFacts               TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsFunctionStrictFacts       TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsFunctionFacts             TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsVoidFacts                 TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
	TypeFactsUndefinedFacts            TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
	TypeFactsNullFacts                 TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
	TypeFactsEmptyObjectStrictFacts    TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
	TypeFactsEmptyObjectFacts          TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsUnknownFacts              TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsAllTypeofNE               TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
	// Masks
	TypeFactsOrFactsMask  TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
	TypeFactsAndFactsMask TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)

var typeofNEFacts ReadonlyMap[string, TypeFacts] = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"string":    TypeFactsTypeofNEString,
	"number":    TypeFactsTypeofNENumber,
	"bigint":    TypeFactsTypeofNEBigInt,
	"boolean":   TypeFactsTypeofNEBoolean,
	"symbol":    TypeFactsTypeofNESymbol,
	"undefined": TypeFactsNEUndefined,
	"object":    TypeFactsTypeofNEObject,
	"function":  TypeFactsTypeofNEFunction,
}))

type TypeSystemEntity /* TODO(TS-TO-GO) TypeNode UnionType: Node | Symbol | Type | Signature */ any

type TypeSystemPropertyName int32

const (
	TypeSystemPropertyNameType TypeSystemPropertyName = iota
	TypeSystemPropertyNameResolvedBaseConstructorType
	TypeSystemPropertyNameDeclaredType
	TypeSystemPropertyNameResolvedReturnType
	TypeSystemPropertyNameImmediateBaseConstraint
	TypeSystemPropertyNameResolvedTypeArguments
	TypeSystemPropertyNameResolvedBaseTypes
	TypeSystemPropertyNameWriteType
	TypeSystemPropertyNameParameterInitializerContainsUndefined
)

// dprint-ignore

type CheckMode int32

const (
	CheckModeNormal               CheckMode = 0
	CheckModeContextual           CheckMode = 1 << 0
	CheckModeInferential          CheckMode = 1 << 1
	CheckModeSkipContextSensitive CheckMode = 1 << 2
	CheckModeSkipGenericFunctions CheckMode = 1 << 3
	CheckModeIsForSignatureHelp   CheckMode = 1 << 4
	CheckModeRestBindingElement   CheckMode = 1 << 5
	//   e.g. in `const { a, ...rest } = foo`, when checking the type of `foo` to determine the type of `rest`,
	//   we need to preserve generic types instead of substituting them for constraints
	CheckModeTypeOnly CheckMode = 1 << 6
)

/** @internal */

type SignatureCheckMode int32

const (
	SignatureCheckModeNone               SignatureCheckMode = 0
	SignatureCheckModeBivariantCallback  SignatureCheckMode = 1 << 0
	SignatureCheckModeStrictCallback     SignatureCheckMode = 1 << 1
	SignatureCheckModeIgnoreReturnTypes  SignatureCheckMode = 1 << 2
	SignatureCheckModeStrictArity        SignatureCheckMode = 1 << 3
	SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
	SignatureCheckModeCallback           SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)

type IntersectionState int32

const (
	IntersectionStateNone   IntersectionState = 0
	IntersectionStateSource IntersectionState = 1 << 0
	IntersectionStateTarget IntersectionState = 1 << 1
)

type RecursionFlags int32

const (
	RecursionFlagsNone   RecursionFlags = 0
	RecursionFlagsSource RecursionFlags = 1 << 0
	RecursionFlagsTarget RecursionFlags = 1 << 1
	RecursionFlagsBoth   RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)

type MappedTypeModifiers int32

const (
	MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
	MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
	MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
	MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)

type MappedTypeNameTypeKind int32

const (
	MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
	MappedTypeNameTypeKindFiltering
	MappedTypeNameTypeKindRemapping
)

type ExpandingFlags int32

const (
	ExpandingFlagsNone   ExpandingFlags = 0
	ExpandingFlagsSource ExpandingFlags = 1
	ExpandingFlagsTarget ExpandingFlags = 1 << 1
	ExpandingFlagsBoth   ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)

type MembersOrExportsResolutionKind string

const (
	MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
	MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)

type UnusedKind int32

const (
	UnusedKindLocal UnusedKind = iota
	UnusedKindParameter
)

/** @param containingNode Node to check for parse error */

type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation)

var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)

type DeclarationMeaning int32

const (
	DeclarationMeaningGetAccessor                DeclarationMeaning = 1
	DeclarationMeaningSetAccessor                DeclarationMeaning = 2
	DeclarationMeaningPropertyAssignment         DeclarationMeaning = 4
	DeclarationMeaningMethod                     DeclarationMeaning = 8
	DeclarationMeaningPrivateStatic              DeclarationMeaning = 16
	DeclarationMeaningGetOrSetAccessor           DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
	DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)

type DeclarationSpaces int32

const (
	DeclarationSpacesNone            DeclarationSpaces = 0
	DeclarationSpacesExportValue     DeclarationSpaces = 1 << 0
	DeclarationSpacesExportType      DeclarationSpaces = 1 << 1
	DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)

type MinArgumentCountFlags int32

const (
	MinArgumentCountFlagsNone                    MinArgumentCountFlags = 0
	MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
	MinArgumentCountFlagsVoidIsNonOptional       MinArgumentCountFlags = 1 << 1
)

type IntrinsicTypeKind int32

const (
	IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
	IntrinsicTypeKindLowercase
	IntrinsicTypeKindCapitalize
	IntrinsicTypeKindUncapitalize
	IntrinsicTypeKindNoInfer
)

var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = NewMap(Object.entries(map[any]any{ /* TODO(TS-TO-GO): was object literal */
	"Uppercase":    IntrinsicTypeKindUppercase,
	"Lowercase":    IntrinsicTypeKindLowercase,
	"Capitalize":   IntrinsicTypeKindCapitalize,
	"Uncapitalize": IntrinsicTypeKindUncapitalize,
	"NoInfer":      IntrinsicTypeKindNoInfer,
}))

var SymbolLinks = /* TODO(TS-TO-GO) Node ClassExpression: class implements SymbolLinks { declare _symbolLinksBrand: any; } */ TODO

func NodeLinks(this NodeLinks) {
	this.flags = NodeCheckFlagsNone
}

/** @internal */

func getNodeId(node Node) number {
	if !node.id {
		node.id = nextNodeId
		nextNodeId++
	}
	return node.id
}

/** @internal */

func getSymbolId(symbol Symbol) SymbolId {
	if !symbol.id {
		symbol.id = nextSymbolId
		nextSymbolId++
	}

	return symbol.id
}

/** @internal */

func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) bool {
	moduleState := getModuleInstanceState(node)
	return moduleState == ModuleInstanceStateInstantiated || (preserveConstEnums && moduleState == ModuleInstanceStateConstEnumOnly)
}

/** @internal */

func createTypeChecker(host TypeCheckerHost) TypeChecker {
	// Why var? It avoids TDZ checks in the runtime which can be costly.
	// See: https://github.com/microsoft/TypeScript/issues/52924
	/* eslint-disable no-var */
	tc.deferredDiagnosticsCallbacks = []never{}

	tc.addLazyDiagnostic = func(arg func()) {
		tc.deferredDiagnosticsCallbacks.push(arg)
	}

	// Cancellation that controls whether or not we can cancel in the middle of type checking.
	// In general cancelling is *not* safe for the type checker.  We might be in the middle of
	// computing something, and we will leave our internals in an inconsistent state.  Callers
	// who set the cancellation token should catch if a cancellation exception occurs, and
	// should throw away and create a new TypeChecker.
	//
	// Currently we only support setting the cancellation token when getting diagnostics.  This
	// is because diagnostics can be quite expensive, and we want to allow hosts to bail out if
	// they no longer need the information (for example, if the user started editing again).

	tc.Symbol = objectAllocator.getSymbolConstructor()
	tc.Type = objectAllocator.getTypeConstructor()
	tc.Signature = objectAllocator.getSignatureConstructor()

	tc.typeCount = 0
	tc.symbolCount = 0
	tc.totalInstantiationCount = 0
	tc.instantiationCount = 0
	tc.instantiationDepth = 0
	tc.inlineLevel = 0
	tc.isInferencePartiallyBlocked = false

	tc.emptySymbols = createSymbolTable()
	tc.arrayVariances = []VarianceFlags{VarianceFlagsCovariant}

	tc.compilerOptions = host.getCompilerOptions()
	tc.languageVersion = getEmitScriptTarget(tc.compilerOptions)
	tc.moduleKind = getEmitModuleKind(tc.compilerOptions)
	tc.legacyDecorators = !!tc.compilerOptions.experimentalDecorators
	tc.useDefineForClassFields = getUseDefineForClassFields(tc.compilerOptions)
	tc.emitStandardClassFields = getEmitStandardClassFields(tc.compilerOptions)
	tc.allowSyntheticDefaultImports = getAllowSyntheticDefaultImports(tc.compilerOptions)
	tc.strictNullChecks = getStrictOptionValue(tc.compilerOptions, "strictNullChecks")
	tc.strictFunctionTypes = getStrictOptionValue(tc.compilerOptions, "strictFunctionTypes")
	tc.strictBindCallApply = getStrictOptionValue(tc.compilerOptions, "strictBindCallApply")
	tc.strictPropertyInitialization = getStrictOptionValue(tc.compilerOptions, "strictPropertyInitialization")
	tc.strictBuiltinIteratorReturn = getStrictOptionValue(tc.compilerOptions, "strictBuiltinIteratorReturn")
	tc.noImplicitAny = getStrictOptionValue(tc.compilerOptions, "noImplicitAny")
	tc.noImplicitThis = getStrictOptionValue(tc.compilerOptions, "noImplicitThis")
	tc.useUnknownInCatchVariables = getStrictOptionValue(tc.compilerOptions, "useUnknownInCatchVariables")
	tc.exactOptionalPropertyTypes = tc.compilerOptions.exactOptionalPropertyTypes
	tc.noUncheckedSideEffectImports = !!tc.compilerOptions.noUncheckedSideEffectImports

	tc.checkBinaryExpression = tc.createCheckBinaryExpression()
	tc.emitResolver = tc.createResolver()
	tc.nodeBuilder = tc.createNodeBuilder()
	tc.syntacticNodeBuilder = createSyntacticTypeNodeBuilder(tc.compilerOptions, map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"isEntityNameVisible":             isEntityNameVisible,
		"isExpandoFunctionDeclaration":    isExpandoFunctionDeclaration,
		"getAllAccessorDeclarations":      tc.getAllAccessorDeclarationsForDeclaration,
		"requiresAddingImplicitUndefined": requiresAddingImplicitUndefined,
		"isUndefinedIdentifierExpression": func(node Identifier) bool {
			Debug.assert(isExpressionNode(node))
			return tc.getSymbolAtLocation(node) == tc.undefinedSymbol
		},
		"isDefinitelyReferenceToGlobalSymbolObject": isDefinitelyReferenceToGlobalSymbolObject,
	})
	tc.evaluate = createEvaluator(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"evaluateElementAccessExpression": evaluateElementAccessExpression,
		"evaluateEntityNameExpression":    evaluateEntityNameExpression,
	})

	tc.globals = createSymbolTable()
	tc.undefinedSymbol = tc.createSymbol(SymbolFlagsProperty, "undefined" /* as __String */)
	tc.undefinedSymbol.declarations = []never{}

	tc.globalThisSymbol = tc.createSymbol(SymbolFlagsModule, "globalThis" /* as __String */, CheckFlagsReadonly)
	tc.globalThisSymbol.exports = tc.globals
	tc.globalThisSymbol.declarations = []never{}
	tc.globals.set(tc.globalThisSymbol.escapedName, tc.globalThisSymbol)

	tc.argumentsSymbol = tc.createSymbol(SymbolFlagsProperty, "arguments" /* as __String */)
	tc.requireSymbol = tc.createSymbol(SymbolFlagsProperty, "require" /* as __String */)
	tc.isolatedModulesLikeFlagName = __COND__(tc.compilerOptions.verbatimModuleSyntax, "verbatimModuleSyntax", "isolatedModules")
	tc.canCollectSymbolAliasAccessabilityData = !tc.compilerOptions.verbatimModuleSyntax
	/** This will be set during calls to `getResolvedSignature` where services determines an apparent number of arguments greater than what is actually provided. */

	tc.lastGetCombinedNodeFlagsResult = NodeFlagsNone
	tc.lastGetCombinedModifierFlagsResult = ModifierFlagsNone
	tc.resolveName = createNameResolver(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"compilerOptions":                  compilerOptions,
		"requireSymbol":                    requireSymbol,
		"argumentsSymbol":                  argumentsSymbol,
		"globals":                          globals,
		"getSymbolOfDeclaration":           getSymbolOfDeclaration,
		"error":                            error,
		"getRequiresScopeChangeCache":      getRequiresScopeChangeCache,
		"setRequiresScopeChangeCache":      setRequiresScopeChangeCache,
		"lookup":                           tc.getSymbol,
		"onPropertyWithInvalidInitializer": tc.checkAndReportErrorForInvalidInitializer,
		"onFailedToResolveSymbol":          onFailedToResolveSymbol,
		"onSuccessfullyResolvedSymbol":     onSuccessfullyResolvedSymbol,
	})

	tc.resolveNameForSymbolSuggestion = createNameResolver(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"compilerOptions":             compilerOptions,
		"requireSymbol":               requireSymbol,
		"argumentsSymbol":             argumentsSymbol,
		"globals":                     globals,
		"getSymbolOfDeclaration":      getSymbolOfDeclaration,
		"error":                       error,
		"getRequiresScopeChangeCache": getRequiresScopeChangeCache,
		"setRequiresScopeChangeCache": setRequiresScopeChangeCache,
		"lookup":                      tc.getSuggestionForSymbolNameLookup,
	})
	// for public members that accept a Node or one of its subtypes, we must guard against
	// synthetic nodes created during transformations by calling `getParseTreeNode`.
	// for most of these, we perform the guard only on `checker` to avoid any possible
	// extra cost of calling `getParseTreeNode` when calling these functions from inside the
	// checker.
	tc.checker = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getNodeCount": func() number {
			return reduceLeft(host.getSourceFiles(), func(n number, s SourceFile) number {
				return n + s.nodeCount
			}, 0)
		},
		"getIdentifierCount": func() number {
			return reduceLeft(host.getSourceFiles(), func(n number, s SourceFile) number {
				return n + s.identifierCount
			}, 0)
		},
		"getSymbolCount": func() number {
			return reduceLeft(host.getSourceFiles(), func(n number, s SourceFile) number {
				return n + s.symbolCount
			}, tc.symbolCount)
		},
		"getTypeCount": func() number {
			return tc.typeCount
		},
		"getInstantiationCount": func() number {
			return tc.totalInstantiationCount
		},
		"getRelationCacheSizes": func() /* TODO(TS-TO-GO) inferred type { assignable: number; identity: number; subtype: number; strictSubtype: number; } */ any {
			return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"assignable":    tc.assignableRelation.size,
				"identity":      tc.identityRelation.size,
				"subtype":       tc.subtypeRelation.size,
				"strictSubtype": tc.strictSubtypeRelation.size,
			})
		},
		"isUndefinedSymbol": func(symbol Symbol) bool {
			return symbol == tc.undefinedSymbol
		},
		"isArgumentsSymbol": func(symbol Symbol) bool {
			return symbol == tc.argumentsSymbol
		},
		"isUnknownSymbol": func(symbol Symbol) bool {
			return symbol == tc.unknownSymbol
		},
		"getMergedSymbol":        getMergedSymbol,
		"symbolIsValue":          symbolIsValue,
		"getDiagnostics":         getDiagnostics,
		"getGlobalDiagnostics":   getGlobalDiagnostics,
		"getRecursionIdentity":   getRecursionIdentity,
		"getUnmatchedProperties": getUnmatchedProperties,
		"getTypeOfSymbolAtLocation": func(symbol Symbol, locationIn Node) Type {
			location := getParseTreeNode(locationIn)
			if location {
				return tc.getTypeOfSymbolAtLocation(symbol, location)
			} else {
				return tc.errorType
			}
		},
		"getTypeOfSymbol": getTypeOfSymbol,
		"getSymbolsOfParameterPropertyDeclaration": func(parameterIn ParameterDeclaration, parameterName string) /* TODO(TS-TO-GO) inferred type [Symbol, Symbol] */ any {
			parameter := getParseTreeNode(parameterIn, isParameter)
			if parameter == nil {
				return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.")
			}
			Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent))
			return tc.getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName))
		},
		"getDeclaredTypeOfSymbol": getDeclaredTypeOfSymbol,
		"getPropertiesOfType":     getPropertiesOfType,
		"getPropertyOfType": func(type_ Type, name string) Symbol {
			return tc.getPropertyOfType(type_, escapeLeadingUnderscores(name))
		},
		"getPrivateIdentifierPropertyOfType": func(leftType Type, name string, location Node) Symbol {
			node := getParseTreeNode(location)
			if !node {
				return nil
			}
			propName := escapeLeadingUnderscores(name)
			lexicallyScopedIdentifier := tc.lookupSymbolForPrivateIdentifierDeclaration(propName, node)
			if lexicallyScopedIdentifier {
				return tc.getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier)
			} else {
				return nil
			}
		},
		"getTypeOfPropertyOfType": func(type_ Type, name string) Type {
			return tc.getTypeOfPropertyOfType(type_, escapeLeadingUnderscores(name))
		},
		"getIndexInfoOfType": func(type_ Type, kind IndexKind) *IndexInfo {
			return tc.getIndexInfoOfType(type_, __COND__(kind == IndexKindString, tc.stringType, tc.numberType))
		},
		"getIndexInfosOfType":        getIndexInfosOfType,
		"getIndexInfosOfIndexSymbol": getIndexInfosOfIndexSymbol,
		"getSignaturesOfType":        getSignaturesOfType,
		"getIndexTypeOfType": func(type_ Type, kind IndexKind) Type {
			return tc.getIndexTypeOfType(type_, __COND__(kind == IndexKindString, tc.stringType, tc.numberType))
		},
		"getIndexType": func(type_ Type) Type {
			return tc.getIndexType(type_)
		},
		"getBaseTypes":             getBaseTypes,
		"getBaseTypeOfLiteralType": getBaseTypeOfLiteralType,
		"getWidenedType":           getWidenedType,
		"getWidenedLiteralType":    getWidenedLiteralType,
		"getTypeFromTypeNode": func(nodeIn TypeNode) Type {
			node := getParseTreeNode(nodeIn, isTypeNode)
			if node {
				return tc.getTypeFromTypeNode(node)
			} else {
				return tc.errorType
			}
		},
		"getParameterType":                     tc.getTypeAtPosition,
		"getParameterIdentifierInfoAtPosition": getParameterIdentifierInfoAtPosition,
		"getPromisedTypeOfPromise":             getPromisedTypeOfPromise,
		"getAwaitedType": func(type_ Type) Type {
			return tc.getAwaitedType(type_)
		},
		"getReturnTypeOfSignature":             getReturnTypeOfSignature,
		"isNullableType":                       isNullableType,
		"getNullableType":                      getNullableType,
		"getNonNullableType":                   getNonNullableType,
		"getNonOptionalType":                   tc.removeOptionalTypeMarker,
		"getTypeArguments":                     getTypeArguments,
		"typeToTypeNode":                       tc.nodeBuilder.typeToTypeNode,
		"typePredicateToTypePredicateNode":     tc.nodeBuilder.typePredicateToTypePredicateNode,
		"indexInfoToIndexSignatureDeclaration": tc.nodeBuilder.indexInfoToIndexSignatureDeclaration,
		"signatureToSignatureDeclaration":      tc.nodeBuilder.signatureToSignatureDeclaration,
		"symbolToEntityName":                   tc.nodeBuilder.symbolToEntityName,
		"symbolToExpression":                   tc.nodeBuilder.symbolToExpression,
		"symbolToNode":                         tc.nodeBuilder.symbolToNode,
		"symbolToTypeParameterDeclarations":    tc.nodeBuilder.symbolToTypeParameterDeclarations,
		"symbolToParameterDeclaration":         tc.nodeBuilder.symbolToParameterDeclaration,
		"typeParameterToDeclaration":           tc.nodeBuilder.typeParameterToDeclaration,
		"getSymbolsInScope": func(locationIn Node, meaning SymbolFlags) []Symbol {
			location := getParseTreeNode(locationIn)
			if location {
				return tc.getSymbolsInScope(location, meaning)
			} else {
				return []never{}
			}
		},
		"getSymbolAtLocation": func(nodeIn Node) Symbol {
			node := getParseTreeNode(nodeIn)
			// set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors
			if node {
				return tc.getSymbolAtLocation(node /*ignoreErrors*/, true)
			} else {
				return nil
			}
		},
		"getIndexInfosAtLocation": func(nodeIn Node) *[]IndexInfo {
			node := getParseTreeNode(nodeIn)
			if node {
				return tc.getIndexInfosAtLocation(node)
			} else {
				return nil
			}
		},
		"getShorthandAssignmentValueSymbol": func(nodeIn Node) Symbol {
			node := getParseTreeNode(nodeIn)
			if node {
				return tc.getShorthandAssignmentValueSymbol(node)
			} else {
				return nil
			}
		},
		"getExportSpecifierLocalTargetSymbol": func(nodeIn /* TODO(TS-TO-GO) inferred type ExportSpecifier | Identifier */ any) Symbol {
			node := getParseTreeNode(nodeIn, isExportSpecifier)
			if node {
				return tc.getExportSpecifierLocalTargetSymbol(node)
			} else {
				return nil
			}
		},
		"getExportSymbolOfSymbol": func(symbol Symbol) Symbol {
			return tc.getMergedSymbol(symbol.exportSymbol || symbol)
		},
		"getTypeAtLocation": func(nodeIn Node) Type {
			node := getParseTreeNode(nodeIn)
			if node {
				return tc.getTypeOfNode(node)
			} else {
				return tc.errorType
			}
		},
		"getTypeOfAssignmentPattern": func(nodeIn AssignmentPattern) Type {
			node := getParseTreeNode(nodeIn, isAssignmentPattern)
			return node && tc.getTypeOfAssignmentPattern(node) || tc.errorType
		},
		"getPropertySymbolOfDestructuringAssignment": func(locationIn Identifier) Symbol {
			location := getParseTreeNode(locationIn, isIdentifier)
			if location {
				return tc.getPropertySymbolOfDestructuringAssignment(location)
			} else {
				return nil
			}
		},
		"signatureToString": func(signature Signature, enclosingDeclaration Node, flags *TypeFormatFlags, kind *SignatureKind) string {
			return tc.signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind)
		},
		"typeToString": func(type_ Type, enclosingDeclaration Node, flags *TypeFormatFlags) string {
			return tc.typeToString(type_, getParseTreeNode(enclosingDeclaration), flags)
		},
		"symbolToString": func(symbol Symbol, enclosingDeclaration Node, meaning *SymbolFlags, flags *SymbolFormatFlags) string {
			return tc.symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags)
		},
		"typePredicateToString": func(predicate TypePredicate, enclosingDeclaration Node, flags *TypeFormatFlags) string {
			return tc.typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags)
		},
		"writeSignature": func(signature Signature, enclosingDeclaration Node, flags *TypeFormatFlags, kind *SignatureKind, writer *EmitTextWriter) string {
			return tc.signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer)
		},
		"writeType": func(type_ Type, enclosingDeclaration Node, flags *TypeFormatFlags, writer *EmitTextWriter) string {
			return tc.typeToString(type_, getParseTreeNode(enclosingDeclaration), flags, writer)
		},
		"writeSymbol": func(symbol Symbol, enclosingDeclaration Node, meaning *SymbolFlags, flags *SymbolFormatFlags, writer *EmitTextWriter) string {
			return tc.symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer)
		},
		"writeTypePredicate": func(predicate TypePredicate, enclosingDeclaration Node, flags *TypeFormatFlags, writer *EmitTextWriter) string {
			return tc.typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer)
		},
		"getAugmentedPropertiesOfType": getAugmentedPropertiesOfType,
		"getRootSymbols":               getRootSymbols,
		"getSymbolOfExpando":           getSymbolOfExpando,
		"getContextualType": func(nodeIn Expression, contextFlags ContextFlags) Type {
			node := getParseTreeNode(nodeIn, isExpression)
			if !node {
				return nil
			}
			if contextFlags & ContextFlagsCompletions {
				return runWithInferenceBlockedFromSourceNode(node, func() Type {
					return tc.getContextualType(node, contextFlags)
				})
			}
			return tc.getContextualType(node, contextFlags)
		},
		"getContextualTypeForObjectLiteralElement": func(nodeIn ObjectLiteralElementLike) Type {
			node := getParseTreeNode(nodeIn, isObjectLiteralElementLike)
			if node {
				return tc.getContextualTypeForObjectLiteralElement(node /*contextFlags*/, nil)
			} else {
				return nil
			}
		},
		"getContextualTypeForArgumentAtIndex": func(nodeIn CallLikeExpression, argIndex number) Type {
			node := getParseTreeNode(nodeIn, isCallLikeExpression)
			return node && tc.getContextualTypeForArgumentAtIndex(node, argIndex)
		},
		"getContextualTypeForJsxAttribute": func(nodeIn /* TODO(TS-TO-GO) inferred type JsxAttribute | JsxSpreadAttribute */ any) Type {
			node := getParseTreeNode(nodeIn, isJsxAttributeLike)
			return node && tc.getContextualTypeForJsxAttribute(node /*contextFlags*/, nil)
		},
		"isContextSensitive":                isContextSensitive,
		"getTypeOfPropertyOfContextualType": getTypeOfPropertyOfContextualType,
		"getFullyQualifiedName":             getFullyQualifiedName,
		"getResolvedSignature": func(node CallLikeExpression, candidatesOutArray *[]Signature, argumentCount *number) *Signature {
			return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckModeNormal)
		},
		"getCandidateSignaturesForStringLiteralCompletions": getCandidateSignaturesForStringLiteralCompletions,
		"getResolvedSignatureForSignatureHelp": func(node CallLikeExpression, candidatesOutArray *[]Signature, argumentCount *number) *Signature {
			return runWithoutResolvedSignatureCaching(node, func() *Signature {
				return getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckModeIsForSignatureHelp)
			})
		},
		"getExpandedParameters":      getExpandedParameters,
		"hasEffectiveRestParameter":  hasEffectiveRestParameter,
		"containsArgumentsReference": containsArgumentsReference,
		"getConstantValue": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | ElementAccessExpression | EnumMember */ any) * /* TODO(TS-TO-GO) inferred type string | number */ any {
			node := getParseTreeNode(nodeIn, tc.canHaveConstantValue)
			if node {
				return tc.getConstantValue(node)
			} else {
				return nil
			}
		},
		"isValidPropertyAccess": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName string) bool {
			node := getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode)
			return !!node && tc.isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName))
		},
		"isValidPropertyAccessForCompletions": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, type_ Type, property Symbol) bool {
			node := getParseTreeNode(nodeIn, isPropertyAccessExpression)
			return !!node && tc.isValidPropertyAccessForCompletions(node, type_, property)
		},
		"getSignatureFromDeclaration": func(declarationIn SignatureDeclaration) *Signature {
			declaration := getParseTreeNode(declarationIn, isFunctionLike)
			if declaration {
				return tc.getSignatureFromDeclaration(declaration)
			} else {
				return nil
			}
		},
		"isImplementationOfOverload": func(nodeIn SignatureDeclaration) *bool {
			node := getParseTreeNode(nodeIn, isFunctionLike)
			if node {
				return tc.isImplementationOfOverload(node)
			} else {
				return nil
			}
		},
		"getImmediateAliasedSymbol":        getImmediateAliasedSymbol,
		"getAliasedSymbol":                 tc.resolveAlias,
		"getEmitResolver":                  getEmitResolver,
		"requiresAddingImplicitUndefined":  requiresAddingImplicitUndefined,
		"getExportsOfModule":               tc.getExportsOfModuleAsArray,
		"getExportsAndPropertiesOfModule":  getExportsAndPropertiesOfModule,
		"forEachExportAndPropertyOfModule": forEachExportAndPropertyOfModule,
		"getSymbolWalker":                  createGetSymbolWalker(tc.getRestTypeOfSignature, tc.getTypePredicateOfSignature, tc.getReturnTypeOfSignature, tc.getBaseTypes, tc.resolveStructuredTypeMembers, tc.getTypeOfSymbol, tc.getResolvedSymbol, tc.getConstraintOfTypeParameter, getFirstIdentifier, tc.getTypeArguments),
		"getAmbientModules":                getAmbientModules,
		"getJsxIntrinsicTagNamesAt":        getJsxIntrinsicTagNamesAt,
		"isOptionalParameter": func(nodeIn ParameterDeclaration) bool {
			node := getParseTreeNode(nodeIn, isParameter)
			if node {
				return tc.isOptionalParameter(node)
			} else {
				return false
			}
		},
		"tryGetMemberInModuleExports": func(name string, symbol Symbol) Symbol {
			return tc.tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol)
		},
		"tryGetMemberInModuleExportsAndProperties": func(name string, symbol Symbol) Symbol {
			return tc.tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol)
		},
		"tryFindAmbientModule": func(moduleName string) Symbol {
			return tc.tryFindAmbientModule(moduleName /*withAugmentations*/, true)
		},
		"getApparentType":     getApparentType,
		"getUnionType":        getUnionType,
		"isTypeAssignableTo":  isTypeAssignableTo,
		"createAnonymousType": createAnonymousType,
		"createSignature":     createSignature,
		"createSymbol":        createSymbol,
		"createIndexInfo":     createIndexInfo,
		"getAnyType": func() IntrinsicType {
			return tc.anyType
		},
		"getStringType": func() IntrinsicType {
			return tc.stringType
		},
		"getStringLiteralType": getStringLiteralType,
		"getNumberType": func() IntrinsicType {
			return tc.numberType
		},
		"getNumberLiteralType": getNumberLiteralType,
		"getBigIntType": func() IntrinsicType {
			return tc.bigintType
		},
		"getBigIntLiteralType":      getBigIntLiteralType,
		"createPromiseType":         createPromiseType,
		"createArrayType":           createArrayType,
		"getElementTypeOfArrayType": getElementTypeOfArrayType,
		"getBooleanType": func() Type {
			return tc.booleanType
		},
		"getFalseType": func(fresh any) FreshableIntrinsicType {
			if fresh {
				return tc.falseType
			} else {
				return tc.regularFalseType
			}
		},
		"getTrueType": func(fresh any) FreshableIntrinsicType {
			if fresh {
				return tc.trueType
			} else {
				return tc.regularTrueType
			}
		},
		"getVoidType": func() IntrinsicType {
			return tc.voidType
		},
		"getUndefinedType": func() IntrinsicType {
			return tc.undefinedType
		},
		"getNullType": func() IntrinsicType {
			return tc.nullType
		},
		"getESSymbolType": func() IntrinsicType {
			return tc.esSymbolType
		},
		"getNeverType": func() IntrinsicType {
			return tc.neverType
		},
		"getOptionalType": func() IntrinsicType {
			return tc.optionalType
		},
		"getPromiseType": func() GenericType {
			return tc.getGlobalPromiseType(false)
		},
		"getPromiseLikeType": func() GenericType {
			return tc.getGlobalPromiseLikeType(false)
		},
		"getAnyAsyncIterableType": func() *TypeReference {
			type_ := tc.getGlobalAsyncIterableType(false)
			if type_ == tc.emptyGenericType {
				return nil
			}
			return tc.createTypeReference(type_, []IntrinsicType{tc.anyType, tc.anyType, tc.anyType})
		},
		"isSymbolAccessible":                           isSymbolAccessible,
		"isArrayType":                                  isArrayType,
		"isTupleType":                                  isTupleType,
		"isArrayLikeType":                              isArrayLikeType,
		"isEmptyAnonymousObjectType":                   isEmptyAnonymousObjectType,
		"isTypeInvalidDueToUnionDiscriminant":          isTypeInvalidDueToUnionDiscriminant,
		"getExactOptionalProperties":                   getExactOptionalProperties,
		"getAllPossiblePropertiesOfTypes":              getAllPossiblePropertiesOfTypes,
		"getSuggestedSymbolForNonexistentProperty":     getSuggestedSymbolForNonexistentProperty,
		"getSuggestedSymbolForNonexistentJSXAttribute": getSuggestedSymbolForNonexistentJSXAttribute,
		"getSuggestedSymbolForNonexistentSymbol": func(location Node, name string, meaning SymbolFlags) Symbol {
			return tc.getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning)
		},
		"getSuggestedSymbolForNonexistentModule":      getSuggestedSymbolForNonexistentModule,
		"getSuggestedSymbolForNonexistentClassMember": getSuggestedSymbolForNonexistentClassMember,
		"getBaseConstraintOfType":                     getBaseConstraintOfType,
		"getDefaultFromTypeParameter": func(type_ Type) Type {
			if type_ && type_.flags&TypeFlagsTypeParameter {
				return tc.getDefaultFromTypeParameter(type_ /* as TypeParameter */)
			} else {
				return nil
			}
		},
		"resolveName": func(name string, location Node, meaning SymbolFlags, excludeGlobals bool) Symbol {
			return tc.resolveName(location, escapeLeadingUnderscores(name), meaning /*nameNotFoundMessage*/, nil /*isUse*/, false, excludeGlobals)
		},
		"getJsxNamespace": func(n Node) string {
			return unescapeLeadingUnderscores(tc.getJsxNamespace(n))
		},
		"getJsxFragmentFactory": func(n Node) *string {
			jsxFragmentFactory := tc.getJsxFragmentFactoryEntity(n)
			return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText)
		},
		"getAccessibleSymbolChain":    getAccessibleSymbolChain,
		"getTypePredicateOfSignature": getTypePredicateOfSignature,
		"resolveExternalModuleName": func(moduleSpecifierIn Expression) Symbol {
			moduleSpecifier := getParseTreeNode(moduleSpecifierIn, isExpression)
			return moduleSpecifier && tc.resolveExternalModuleName(moduleSpecifier, moduleSpecifier /*ignoreErrors*/, true)
		},
		"resolveExternalModuleSymbol": resolveExternalModuleSymbol,
		"tryGetThisTypeAt": func(nodeIn Node, includeGlobalThis *bool, container *ThisContainer) Type {
			node := getParseTreeNode(nodeIn)
			return node && tc.tryGetThisTypeAt(node, includeGlobalThis, container)
		},
		"getTypeArgumentConstraint": func(nodeIn TypeNode) Type {
			node := getParseTreeNode(nodeIn, isTypeNode)
			return node && tc.getTypeArgumentConstraint(node)
		},
		"getSuggestionDiagnostics": func(fileIn SourceFile, ct CancellationToken) []DiagnosticWithLocation {
			file := getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.")
			if skipTypeChecking(file, tc.compilerOptions, host) {
				return emptyArray
			}

			var diagnostics *[]DiagnosticWithLocation
			{ // try
				// Record the cancellation token so it can be checked later on during checkSourceElement.
				// Do this in a finally block so we can ensure that it gets reset back to nothing after
				// this call is done.
				tc.cancellationToken = ct

				// Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused
				tc.checkSourceFileWithEagerDiagnostics(file)
				Debug.assert(!!(tc.getNodeLinks(file).flags & NodeCheckFlagsTypeChecked))

				diagnostics = addRange(diagnostics, tc.suggestionDiagnostics.getDiagnostics(file.fileName))
				tc.checkUnusedIdentifiers(tc.getPotentiallyUnusedIdentifiers(file), func(containingNode Node, kind UnusedKind, diag DiagnosticWithLocation) {
					if !containsParseError(containingNode) && !tc.unusedIsError(kind, !!(containingNode.flags&NodeFlagsAmbient)) {
						(diagnostics || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: diagnostics = [] */ TODO)).push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
							/* TODO(TS-TO-GO) Node SpreadAssignment: ...diag */
							"category": DiagnosticCategorySuggestion,
						})
					}
				})

				return diagnostics || emptyArray
			}
			{ // finally
				tc.cancellationToken = nil
			}
		},
		"runWithCancellationToken": func(token CancellationToken, callback /* TODO(TS-TO-GO) inferred type ((checker: TypeChecker) => T) | ((checker: TypeChecker) => T) */ any) T {
			{ // try
				tc.cancellationToken = token
				return callback(tc.checker)
			}
			{ // finally
				tc.cancellationToken = nil
			}
		},
		"getLocalTypeParametersOfClassOrInterfaceOrTypeAlias": getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
		"isDeclarationVisible":                                isDeclarationVisible,
		"isPropertyAccessible":                                isPropertyAccessible,
		"getTypeOnlyAliasDeclaration":                         getTypeOnlyAliasDeclaration,
		"getMemberOverrideModifierStatus":                     getMemberOverrideModifierStatus,
		"isTypeParameterPossiblyReferenced":                   isTypeParameterPossiblyReferenced,
		"typeHasCallOrConstructSignatures":                    typeHasCallOrConstructSignatures,
		"getSymbolFlags":                                      getSymbolFlags,
	}

	getCandidateSignaturesForStringLiteralCompletions := func(call CallLikeExpression, editingArgument Node) []Signature {
		candidatesSet := NewSet[Signature]()
		var candidates []Signature = []never{}

		// first, get candidates when inference is blocked from the source node.
		runWithInferenceBlockedFromSourceNode(editingArgument, func() *Signature {
			return getResolvedSignatureWorker(call, candidates /*argumentCount*/, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}

		// reset candidates for second pass
		candidates.length = 0

		// next, get candidates where the source node is considered for inference.
		runWithoutResolvedSignatureCaching(editingArgument, func() *Signature {
			return getResolvedSignatureWorker(call, candidates /*argumentCount*/, nil, CheckModeNormal)
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}

		return arrayFrom(candidatesSet)
	}

	runWithoutResolvedSignatureCaching := func(node Node, fn func() T) T {
		node = findAncestor(node, isCallLikeOrFunctionLikeExpression)
		if node {
			cachedResolvedSignatures := []never{}
			cachedTypes := []never{}
			for node {
				nodeLinks := tc.getNodeLinks(node)
				cachedResolvedSignatures.push([]any{nodeLinks, nodeLinks.resolvedSignature} /* as const */)
				nodeLinks.resolvedSignature = nil
				if isFunctionExpressionOrArrowFunction(node) {
					symbolLinks := tc.getSymbolLinks(tc.getSymbolOfDeclaration(node))
					type_ := symbolLinks.type_
					cachedTypes.push([]any{symbolLinks, type_} /* as const */)
					symbolLinks.type_ = nil
				}
				node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression)
			}
			result := fn()
			for _, TODO_IDENTIFIER := range cachedResolvedSignatures {
				nodeLinks.resolvedSignature = resolvedSignature
			}
			for _, TODO_IDENTIFIER := range cachedTypes {
				symbolLinks.type_ = type_
			}
			return result
		}
		return fn()
	}

	runWithInferenceBlockedFromSourceNode := func(node Node, fn func() T) T {
		containingCall := findAncestor(node, isCallLikeExpression)
		if containingCall {
			toMarkSkip := node
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall { // do-while loop
				tc.getNodeLinks(toMarkSkip).skipDirectInference = true
				toMarkSkip = toMarkSkip.parent
			}
		}

		tc.isInferencePartiallyBlocked = true
		result := runWithoutResolvedSignatureCaching(node, fn)
		tc.isInferencePartiallyBlocked = false

		if containingCall {
			toMarkSkip := node
			for ok := true; ok; ok = toMarkSkip && toMarkSkip != containingCall { // do-while loop
				tc.getNodeLinks(toMarkSkip).skipDirectInference = nil
				toMarkSkip = toMarkSkip.parent
			}
		}
		return result
	}

	getResolvedSignatureWorker := func(nodeIn CallLikeExpression, candidatesOutArray *[]Signature, argumentCount *number, checkMode CheckMode) *Signature {
		node := getParseTreeNode(nodeIn, isCallLikeExpression)
		tc.apparentArgumentCount = argumentCount
		var res *Signature
		if !node {
			res = nil
		} else {
			res = tc.getResolvedSignature(node, candidatesOutArray, checkMode)
		}
		tc.apparentArgumentCount = nil
		return res
	}

	tc.tupleTypes = NewMap[string, GenericType]()
	tc.unionTypes = NewMap[string, UnionType]()
	tc.unionOfUnionTypes = NewMap[string, Type]()
	tc.intersectionTypes = NewMap[string, Type]()
	tc.stringLiteralTypes = NewMap[string, StringLiteralType]()
	tc.numberLiteralTypes = NewMap[number, NumberLiteralType]()
	tc.bigIntLiteralTypes = NewMap[string, BigIntLiteralType]()
	tc.enumLiteralTypes = NewMap[string, LiteralType]()
	tc.indexedAccessTypes = NewMap[string, IndexedAccessType]()
	tc.templateLiteralTypes = NewMap[string, TemplateLiteralType]()
	tc.stringMappingTypes = NewMap[string, StringMappingType]()
	tc.substitutionTypes = NewMap[string, SubstitutionType]()
	tc.subtypeReductionCache = NewMap[string, []Type]()
	tc.decoratorContextOverrideTypeCache = NewMap[string, Type]()
	tc.cachedTypes = NewMap[string, Type]()
	tc.evolvingArrayTypes = []never{}
	tc.undefinedProperties = NewMap()
	tc.markerTypes = NewSet[number]()

	tc.unknownSymbol = tc.createSymbol(SymbolFlagsProperty, "unknown" /* as __String */)
	tc.resolvingSymbol = tc.createSymbol(0, InternalSymbolNameResolving)
	tc.unresolvedSymbols = NewMap[string, TransientSymbol]()
	tc.errorTypes = NewMap[string, Type]()

	// We specifically create the `undefined` and `null` types before any other types that can occur in
	// unions such that they are given low type IDs and occur first in the sorted list of union constituents.
	// We can then just examine the first constituent(s) of a union to check for their presence.

	tc.seenIntrinsicNames = NewSet[string]()

	tc.anyType = tc.createIntrinsicType(TypeFlagsAny, "any")
	tc.autoType = tc.createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsNonInferrableType, "auto")
	tc.wildcardType = tc.createIntrinsicType(TypeFlagsAny, "any" /*objectFlags*/, nil, "wildcard")
	tc.blockedStringType = tc.createIntrinsicType(TypeFlagsAny, "any" /*objectFlags*/, nil, "blocked string")
	tc.errorType = tc.createIntrinsicType(TypeFlagsAny, "error")
	tc.unresolvedType = tc.createIntrinsicType(TypeFlagsAny, "unresolved")
	tc.nonInferrableAnyType = tc.createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsContainsWideningType, "non-inferrable")
	tc.intrinsicMarkerType = tc.createIntrinsicType(TypeFlagsAny, "intrinsic")
	tc.unknownType = tc.createIntrinsicType(TypeFlagsUnknown, "unknown")
	tc.undefinedType = tc.createIntrinsicType(TypeFlagsUndefined, "undefined")
	tc.undefinedWideningType = __COND__(tc.strictNullChecks, tc.undefinedType, tc.createIntrinsicType(TypeFlagsUndefined, "undefined", ObjectFlagsContainsWideningType, "widening"))
	tc.missingType = tc.createIntrinsicType(TypeFlagsUndefined, "undefined" /*objectFlags*/, nil, "missing")
	tc.undefinedOrMissingType = __COND__(tc.exactOptionalPropertyTypes, tc.missingType, tc.undefinedType)
	tc.optionalType = tc.createIntrinsicType(TypeFlagsUndefined, "undefined" /*objectFlags*/, nil, "optional")
	tc.nullType = tc.createIntrinsicType(TypeFlagsNull, "null")
	tc.nullWideningType = __COND__(tc.strictNullChecks, tc.nullType, tc.createIntrinsicType(TypeFlagsNull, "null", ObjectFlagsContainsWideningType, "widening"))
	tc.stringType = tc.createIntrinsicType(TypeFlagsString, "string")
	tc.numberType = tc.createIntrinsicType(TypeFlagsNumber, "number")
	tc.bigintType = tc.createIntrinsicType(TypeFlagsBigInt, "bigint")
	tc.falseType = tc.createIntrinsicType(TypeFlagsBooleanLiteral, "false" /*objectFlags*/, nil, "fresh") /* as FreshableIntrinsicType */
	tc.regularFalseType = tc.createIntrinsicType(TypeFlagsBooleanLiteral, "false")                        /* as FreshableIntrinsicType */
	tc.trueType = tc.createIntrinsicType(TypeFlagsBooleanLiteral, "true" /*objectFlags*/, nil, "fresh")   /* as FreshableIntrinsicType */
	tc.regularTrueType = tc.createIntrinsicType(TypeFlagsBooleanLiteral, "true")                          /* as FreshableIntrinsicType */
	tc.trueType.regularType = tc.regularTrueType
	tc.trueType.freshType = tc.trueType
	tc.regularTrueType.regularType = tc.regularTrueType
	tc.regularTrueType.freshType = tc.trueType
	tc.falseType.regularType = tc.regularFalseType
	tc.falseType.freshType = tc.falseType
	tc.regularFalseType.regularType = tc.regularFalseType
	tc.regularFalseType.freshType = tc.falseType
	tc.booleanType = tc.getUnionType([]FreshableIntrinsicType{tc.regularFalseType, tc.regularTrueType})
	tc.esSymbolType = tc.createIntrinsicType(TypeFlagsESSymbol, "symbol")
	tc.voidType = tc.createIntrinsicType(TypeFlagsVoid, "void")
	tc.neverType = tc.createIntrinsicType(TypeFlagsNever, "never")
	tc.silentNeverType = tc.createIntrinsicType(TypeFlagsNever, "never", ObjectFlagsNonInferrableType, "silent")
	tc.implicitNeverType = tc.createIntrinsicType(TypeFlagsNever, "never" /*objectFlags*/, nil, "implicit")
	tc.unreachableNeverType = tc.createIntrinsicType(TypeFlagsNever, "never" /*objectFlags*/, nil, "unreachable")
	tc.nonPrimitiveType = tc.createIntrinsicType(TypeFlagsNonPrimitive, "object")
	tc.stringOrNumberType = tc.getUnionType([]IntrinsicType{tc.stringType, tc.numberType})
	tc.stringNumberSymbolType = tc.getUnionType([]IntrinsicType{tc.stringType, tc.numberType, tc.esSymbolType})
	tc.numberOrBigIntType = tc.getUnionType([]IntrinsicType{tc.numberType, tc.bigintType})
	tc.templateConstraintType = tc.getUnionType([]Type{tc.stringType, tc.numberType, tc.booleanType, tc.bigintType, tc.nullType, tc.undefinedType}) /* as UnionType */
	tc.numericStringType = tc.getTemplateLiteralType([]string{"", ""}, []IntrinsicType{tc.numberType})
	// The `${number}` type

	tc.restrictiveMapper = tc.makeFunctionTypeMapper(func(t Type) Type {
		if t.flags & TypeFlagsTypeParameter {
			return tc.getRestrictiveTypeParameter(t /* as TypeParameter */)
		} else {
			return t
		}
	}, func() string {
		return "(restrictive mapper)"
	})
	tc.permissiveMapper = tc.makeFunctionTypeMapper(func(t Type) Type {
		if t.flags & TypeFlagsTypeParameter {
			return tc.wildcardType
		} else {
			return t
		}
	}, func() string {
		return "(permissive mapper)"
	})
	tc.uniqueLiteralType = tc.createIntrinsicType(TypeFlagsNever, "never" /*objectFlags*/, nil, "unique literal")
	// `uniqueLiteralType` is a special `never` flagged by union reduction to behave as a literal
	tc.uniqueLiteralMapper = tc.makeFunctionTypeMapper(func(t Type) Type {
		if t.flags & TypeFlagsTypeParameter {
			return tc.uniqueLiteralType
		} else {
			return t
		}
	}, func() string {
		return "(unique literal mapper)"
	})
	// replace all type parameters with the unique literal type (disregarding constraints)
	tc.reportUnreliableMapper = tc.makeFunctionTypeMapper(func(t Type) Type {
		if tc.outofbandVarianceMarkerHandler && (t == tc.markerSuperType || t == tc.markerSubType || t == tc.markerOtherType) {
			tc.outofbandVarianceMarkerHandler(true)
		}
		return t
	}, func() string {
		return "(unmeasurable reporter)"
	})
	tc.reportUnmeasurableMapper = tc.makeFunctionTypeMapper(func(t Type) Type {
		if tc.outofbandVarianceMarkerHandler && (t == tc.markerSuperType || t == tc.markerSubType || t == tc.markerOtherType) {
			tc.outofbandVarianceMarkerHandler(false)
		}
		return t
	}, func() string {
		return "(unreliable reporter)"
	})

	tc.emptyObjectType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	tc.emptyJsxObjectType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	tc.emptyJsxObjectType.objectFlags |= ObjectFlagsJsxAttributes

	tc.emptyTypeLiteralSymbol = tc.createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
	tc.emptyTypeLiteralSymbol.members = createSymbolTable()
	tc.emptyTypeLiteralType = tc.createAnonymousType(tc.emptyTypeLiteralSymbol, tc.emptySymbols, emptyArray, emptyArray, emptyArray)

	tc.unknownEmptyObjectType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	tc.unknownUnionType = __COND__(tc.strictNullChecks, tc.getUnionType([] /* TODO(TS-TO-GO) inferred type IntrinsicType | ResolvedType */ any{tc.undefinedType, tc.nullType, tc.unknownEmptyObjectType}), tc.unknownType)

	tc.emptyGenericType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray) /* as ObjectType */ /* as GenericType */
	tc.emptyGenericType.instantiations = NewMap[string, TypeReference]()

	tc.anyFunctionType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	// The anyFunctionType contains the anyFunctionType by definition. The flag is further propagated
	// in getPropagatingFlagsOfTypes, and it is checked in inferFromTypes.
	tc.anyFunctionType.objectFlags |= ObjectFlagsNonInferrableType

	tc.noConstraintType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	tc.circularConstraintType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	tc.resolvingDefaultType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)

	tc.markerSuperType = tc.createTypeParameter()
	tc.markerSubType = tc.createTypeParameter()
	tc.markerSubType.constraint = tc.markerSuperType
	tc.markerOtherType = tc.createTypeParameter()

	tc.markerSuperTypeForCheck = tc.createTypeParameter()
	tc.markerSubTypeForCheck = tc.createTypeParameter()
	tc.markerSubTypeForCheck.constraint = tc.markerSuperTypeForCheck

	tc.noTypePredicate = tc.createTypePredicate(TypePredicateKindIdentifier, "<<unresolved>>", 0, tc.anyType)

	tc.anySignature = tc.createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, tc.anyType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)
	tc.unknownSignature = tc.createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, tc.errorType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)
	tc.resolvingSignature = tc.createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, tc.anyType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)
	tc.silentNeverSignature = tc.createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, tc.silentNeverType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsNone)

	tc.enumNumberIndexInfo = tc.createIndexInfo(tc.numberType, tc.stringType /*isReadonly*/, true)

	tc.iterationTypesCache = NewMap[string, IterationTypes]()
	// cache for common IterationTypes instances
	tc.noIterationTypes = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		/* TODO(TS-TO-GO) Node GetAccessor: get yieldType(): Type { return Debug.fail("Not supported"); } */
		/* TODO(TS-TO-GO) Node GetAccessor: get returnType(): Type { return Debug.fail("Not supported"); } */
		/* TODO(TS-TO-GO) Node GetAccessor: get nextType(): Type { return Debug.fail("Not supported"); } */
	}

	tc.anyIterationTypes = tc.createIterationTypes(tc.anyType, tc.anyType, tc.anyType)

	tc.asyncIterationTypesResolver = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"iterableCacheKey":              "iterationTypesOfAsyncIterable",
		"iteratorCacheKey":              "iterationTypesOfAsyncIterator",
		"iteratorSymbolName":            "asyncIterator",
		"getGlobalIteratorType":         tc.getGlobalAsyncIteratorType,
		"getGlobalIterableType":         tc.getGlobalAsyncIterableType,
		"getGlobalIterableIteratorType": tc.getGlobalAsyncIterableIteratorType,
		"getGlobalIteratorObjectType":   tc.getGlobalAsyncIteratorObjectType,
		"getGlobalGeneratorType":        tc.getGlobalAsyncGeneratorType,
		"getGlobalBuiltinIteratorTypes": tc.getGlobalBuiltinAsyncIteratorTypes,
		"resolveIterationType": func(type_ Type, errorNode Node) Type {
			return tc.getAwaitedType(type_, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		},
		"mustHaveANextMethodDiagnostic": Diagnostics.An_async_iterator_must_have_a_next_method,
		"mustBeAMethodDiagnostic":       Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
		"mustHaveAValueDiagnostic":      Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,
	}

	tc.syncIterationTypesResolver = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"iterableCacheKey":              "iterationTypesOfIterable",
		"iteratorCacheKey":              "iterationTypesOfIterator",
		"iteratorSymbolName":            "iterator",
		"getGlobalIteratorType":         getGlobalIteratorType,
		"getGlobalIterableType":         getGlobalIterableType,
		"getGlobalIterableIteratorType": getGlobalIterableIteratorType,
		"getGlobalIteratorObjectType":   getGlobalIteratorObjectType,
		"getGlobalGeneratorType":        getGlobalGeneratorType,
		"getGlobalBuiltinIteratorTypes": getGlobalBuiltinIteratorTypes,
		"resolveIterationType": func(type_ Type, _errorNode Node) Type {
			return type_
		},
		"mustHaveANextMethodDiagnostic": Diagnostics.An_iterator_must_have_a_next_method,
		"mustBeAMethodDiagnostic":       Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
		"mustHaveAValueDiagnostic":      Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,
	}

	type DuplicateInfoForSymbol struct {
		firstFileLocations  []Declaration
		secondFileLocations []Declaration
		isBlockScoped       bool
	}
	type DuplicateInfoForFiles struct {
		firstFile          SourceFile
		secondFile         SourceFile
		conflictingSymbols Map[string, DuplicateInfoForSymbol]
	}
	/** Key is "/path/to/a.ts|/path/to/b.ts". */

	tc.reverseMappedCache = NewMap[string, Type]()
	tc.reverseHomomorphicMappedCache = NewMap[string, Type]()
	/**
	 * List of every ambient module with a "*" wildcard.
	 * Unlike other ambient modules, these can't be stored in `globals` because symbol tables only deal with exact matches.
	 * This is only used if there is no exact match.
	 */

	// The library files are only loaded when the feature is used.
	// This allows users to just specify library files they want to used through --lib
	// and they will not get an error from not having unrelated library files

	tc.allPotentiallyUnusedIdentifiers = NewMap[Path, []PotentiallyUnusedIdentifier]()
	// key is file name

	tc.flowLoopStart = 0
	tc.flowLoopCount = 0
	tc.sharedFlowCount = 0
	tc.flowAnalysisDisabled = false
	tc.flowInvocationCount = 0

	tc.contextualTypeNodes = []never{}
	tc.contextualTypes = []never{}
	tc.contextualIsCache = []never{}
	tc.contextualTypeCount = 0
	tc.contextualBindingPatterns = []never{}

	tc.inferenceContextNodes = []never{}
	tc.inferenceContexts = []never{}
	tc.inferenceContextCount = 0

	tc.emptyStringType = tc.getStringLiteralType("")
	tc.zeroType = tc.getNumberLiteralType(0)
	tc.zeroBigIntType = tc.getBigIntLiteralType(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"negative":    false,
		"base10Value": "0",
	})

	tc.resolutionTargets = []never{}
	tc.resolutionResults = []never{}
	tc.resolutionPropertyNames = []never{}
	tc.resolutionStart = 0
	tc.inVarianceComputation = false

	tc.suggestionCount = 0
	tc.maximumSuggestionCount = 10
	tc.mergedSymbols = []never{}
	tc.symbolLinks = []never{}
	tc.nodeLinks = []never{}
	tc.flowLoopCaches = []never{}
	tc.flowLoopNodes = []never{}
	tc.flowLoopKeys = []never{}
	tc.flowLoopTypes = []never{}
	tc.sharedFlowNodes = []never{}
	tc.sharedFlowTypes = []never{}
	tc.flowNodeReachable = []never{}
	tc.flowNodePostSuper = []never{}
	tc.potentialThisCollisions = []never{}
	tc.potentialNewTargetCollisions = []never{}
	tc.potentialWeakMapSetCollisions = []never{}
	tc.potentialReflectCollisions = []never{}
	tc.potentialUnusedRenamedBindingElementsInTypes = []never{}
	tc.awaitedTypeStack = []never{}
	tc.reverseMappedSourceStack = []never{}
	tc.reverseMappedTargetStack = []never{}
	tc.reverseExpandingFlags = ExpandingFlagsNone

	tc.diagnostics = createDiagnosticCollection()
	tc.suggestionDiagnostics = createDiagnosticCollection()

	tc.typeofType = tc.createTypeofType()

	tc.subtypeRelation = NewMap[string, RelationComparisonResult]()
	tc.strictSubtypeRelation = NewMap[string, RelationComparisonResult]()
	tc.assignableRelation = NewMap[string, RelationComparisonResult]()
	tc.comparableRelation = NewMap[string, RelationComparisonResult]()
	tc.identityRelation = NewMap[string, RelationComparisonResult]()
	tc.enumRelation = NewMap[string, RelationComparisonResult]()

	// Extensions suggested for path imports when module resolution is node16 or higher.
	// The first element of each tuple is the extension a file has.
	// The second element of each tuple is the extension that should be used in a path import.
	// e.g. if we want to import file `foo.mts`, we should write `import {} from "./foo.mjs".
	tc.suggestedExtensions = [] /* TODO(TS-TO-GO) inferred type [string, string] */ any{[]any{".mts", ".mjs"}, []any{".ts", ".js"}, []any{".cts", ".cjs"}, []any{".mjs", ".mjs"}, []any{".js", ".js"}, []any{".cjs", ".cjs"}, []any{".tsx", __COND__(tc.compilerOptions.jsx == JsxEmitPreserve, ".jsx", ".js")}, []any{".jsx", ".jsx"}, []any{".json", ".json"}}
	/* eslint-enable no-var */

	tc.initializeTypeChecker()

	return tc.checker

	type ExportCollisionTracker struct {
		specifierText        string
		exportsWithDuplicate []ExportDeclaration
	}

	type ExportCollisionTrackerTable Map[__String, ExportCollisionTracker]

	type ReplaceableIndexedAccessType /* TODO(TS-TO-GO) TypeNode IntersectionType: IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; } */ any

	type ElaborationIterator IterableIterator[ /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; } */ any]

	type ErrorReporter func(message DiagnosticMessage, args DiagnosticArguments)

	type AwaitedTypeInstantiation struct {
		_awaitedTypeBrand  never
		aliasSymbol        Symbol
		aliasTypeArguments []Type
	}

	type PotentiallyUnusedIdentifier /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode */ any

	type ImportedDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: ImportClause | ImportSpecifier | NamespaceImport */ any

	type DeclarationWithPotentialInnerNodeReuse /* TODO(TS-TO-GO) TypeNode UnionType: | SignatureDeclaration | JSDocSignature | AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression | ExportAssignment */ any
}

func (tc *TypeChecker) isDefinitelyReferenceToGlobalSymbolObject(node Node) bool {
	if !isPropertyAccessExpression(node) {
		return false
	}
	if !isIdentifier(node.name) {
		return false
	}
	if !isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression) {
		return false
	}
	if isIdentifier(node.expression) {
		// Exactly `Symbol.something` and `Symbol` either does not resolve or definitely resolves to the global Symbol
		return idText(node.expression) == "Symbol" && tc.getResolvedSymbol(node.expression) == (tc.getGlobalSymbol("Symbol" /* as __String */, SymbolFlagsValue|SymbolFlagsExportValue /*diagnostic*/, nil) || tc.unknownSymbol)
	}
	if !isIdentifier(node.expression.expression) {
		return false
	}
	// Exactly `globalThis.Symbol.something` and `globalThis` resolves to the global `globalThis`
	return idText(node.expression.name) == "Symbol" && idText(node.expression.expression) == "globalThis" && tc.getResolvedSymbol(node.expression.expression) == tc.globalThisSymbol
}

func (tc *TypeChecker) getCachedType(key *string) Type {
	if key {
		return tc.cachedTypes.get(key)
	} else {
		return nil
	}
}

func (tc *TypeChecker) setCachedType(key *string, type_ Type) Type {
	if key {
		tc.cachedTypes.set(key, type_)
	}
	return type_
}

func (tc *TypeChecker) getJsxNamespace(location Node) __String {
	if location {
		file := getSourceFileOfNode(location)
		if file {
			if isJsxOpeningFragment(location) {
				if file.localJsxFragmentNamespace {
					return file.localJsxFragmentNamespace
				}
				jsxFragmentPragma := file.pragmas.get("jsxfrag")
				if jsxFragmentPragma {
					var chosenPragma /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
					if isArray(jsxFragmentPragma) {
						chosenPragma = jsxFragmentPragma[0]
					} else {
						chosenPragma = jsxFragmentPragma
					}
					file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, tc.languageVersion)
					visitNode(file.localJsxFragmentFactory, tc.markAsSynthetic, isEntityName)
					if file.localJsxFragmentFactory {
						file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText
						return file.localJsxFragmentNamespace
					}
				}
				entity := tc.getJsxFragmentFactoryEntity(location)
				if entity {
					file.localJsxFragmentFactory = entity
					file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText
					return file.localJsxFragmentNamespace
				}
			} else {
				localJsxNamespace := tc.getLocalJsxNamespace(file)
				if localJsxNamespace {
					file.localJsxNamespace = localJsxNamespace
					return file.localJsxNamespace
				}
			}
		}
	}
	if !tc._jsxNamespace {
		tc._jsxNamespace = "React" /* as __String */
		if tc.compilerOptions.jsxFactory {
			tc._jsxFactoryEntity = parseIsolatedEntityName(tc.compilerOptions.jsxFactory, tc.languageVersion)
			visitNode(tc._jsxFactoryEntity, tc.markAsSynthetic)
			if tc._jsxFactoryEntity {
				tc._jsxNamespace = getFirstIdentifier(tc._jsxFactoryEntity).escapedText
			}
		} else if tc.compilerOptions.reactNamespace {
			tc._jsxNamespace = escapeLeadingUnderscores(tc.compilerOptions.reactNamespace)
		}
	}
	if !tc._jsxFactoryEntity {
		tc._jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(tc._jsxNamespace)), "createElement")
	}
	return tc._jsxNamespace
}

func (tc *TypeChecker) getLocalJsxNamespace(file SourceFile) *__String {
	if file.localJsxNamespace {
		return file.localJsxNamespace
	}
	jsxPragma := file.pragmas.get("jsx")
	if jsxPragma {
		var chosenPragma /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
		if isArray(jsxPragma) {
			chosenPragma = jsxPragma[0]
		} else {
			chosenPragma = jsxPragma
		}
		file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, tc.languageVersion)
		visitNode(file.localJsxFactory, tc.markAsSynthetic, isEntityName)
		if file.localJsxFactory {
			file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText
			return file.localJsxNamespace
		}
	}
}

func (tc *TypeChecker) markAsSynthetic(node T) VisitResult[T] {
	setTextRangePosEnd(node, -1, -1)
	return visitEachChildWorker(node, tc.markAsSynthetic /*context*/, nil)
}

func (tc *TypeChecker) getEmitResolver(sourceFile SourceFile, cancellationToken CancellationToken, skipDiagnostics bool) EmitResolver {
	// Ensure we have all the type information in place for this file so that all the
	// emitter questions of this resolver will return the right information.
	if !skipDiagnostics {
		tc.getDiagnostics(sourceFile, tc.cancellationToken)
	}
	return tc.emitResolver
}

func (tc *TypeChecker) lookupOrIssueError(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
	var diagnostic Diagnostic
	if location {
		diagnostic = createDiagnosticForNode(location, message, args...)
	} else {
		diagnostic = createCompilerDiagnostic(message, args...)
	}
	existing := tc.diagnostics.lookup(diagnostic)
	if existing {
		return existing
	} else {
		tc.diagnostics.add(diagnostic)
		return diagnostic
	}
}

func (tc *TypeChecker) errorSkippedOn(key CompilerOptions, location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
	diagnostic := tc.error(location, message, args...)
	diagnostic.skippedOn = key
	return diagnostic
}

func (tc *TypeChecker) createError(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
	if location {
		return createDiagnosticForNode(location, message, args...)
	} else {
		return createCompilerDiagnostic(message, args...)
	}
}

func (tc *TypeChecker) error(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
	diagnostic := tc.createError(location, message, args...)
	tc.diagnostics.add(diagnostic)
	return diagnostic
}

func (tc *TypeChecker) addErrorOrSuggestion(isError bool, diagnostic Diagnostic) {
	if isError {
		tc.diagnostics.add(diagnostic)
	} else {
		tc.suggestionDiagnostics.add(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			/* TODO(TS-TO-GO) Node SpreadAssignment: ...diagnostic */
			"category": DiagnosticCategorySuggestion,
		})
	}
}

func (tc *TypeChecker) errorOrSuggestion(isError bool, location Node, message /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
	// Pseudo-synthesized input node
	if location.pos < 0 || location.end < 0 {
		if !isError {
			return
			// Drop suggestions (we have no span to suggest on)
		}
		// Issue errors globally
		file := getSourceFileOfNode(location)
		tc.addErrorOrSuggestion(isError, __COND__( /* TODO(TS-TO-GO) InKeyword BinaryExpression: "message" in message */ TODO, createFileDiagnostic(file, 0, 0, message, args...), createDiagnosticForFileFromMessageChain(file, message)))
		// eslint-disable-line local/no-in-operator
		return
	}
	tc.addErrorOrSuggestion(isError, __COND__( /* TODO(TS-TO-GO) InKeyword BinaryExpression: "message" in message */ TODO, createDiagnosticForNode(location, message, args...), createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message)))
	// eslint-disable-line local/no-in-operator
}

func (tc *TypeChecker) errorAndMaybeSuggestAwait(location Node, maybeMissingAwait bool, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
	diagnostic := tc.error(location, message, args...)
	if maybeMissingAwait {
		related := createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await)
		addRelatedInfo(diagnostic, related)
	}
	return diagnostic
}

func (tc *TypeChecker) addDeprecatedSuggestionWorker(declarations /* TODO(TS-TO-GO) TypeNode UnionType: Node | Node[] */ any, diagnostic DiagnosticWithLocation) DiagnosticWithLocation {
	var deprecatedTag *JSDocDeprecatedTag
	if Array.isArray(declarations) {
		deprecatedTag = forEach(declarations, getJSDocDeprecatedTag)
	} else {
		deprecatedTag = getJSDocDeprecatedTag(declarations)
	}
	if deprecatedTag {
		addRelatedInfo(diagnostic, createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here))
	}
	// We call `addRelatedInfo()` before adding the diagnostic to prevent duplicates.
	tc.suggestionDiagnostics.add(diagnostic)
	return diagnostic
}

func (tc *TypeChecker) isDeprecatedSymbol(symbol Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
	parentSymbol := tc.getParentOfSymbol(symbol)
	if parentSymbol && length(symbol.declarations) > 1 {
		if parentSymbol.flags & SymbolFlagsInterface {
			return some(symbol.declarations, tc.isDeprecatedDeclaration)
		} else {
			return every(symbol.declarations, tc.isDeprecatedDeclaration)
		}
	}
	return !!symbol.valueDeclaration && tc.isDeprecatedDeclaration(symbol.valueDeclaration) || length(symbol.declarations) && every(symbol.declarations, tc.isDeprecatedDeclaration)
}

func (tc *TypeChecker) isDeprecatedDeclaration(declaration Declaration) bool {
	return !!(tc.getCombinedNodeFlagsCached(declaration) & NodeFlagsDeprecated)
}

func (tc *TypeChecker) addDeprecatedSuggestion(location Node, declarations []Node, deprecatedEntity string) DiagnosticWithLocation {
	diagnostic := createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity)
	return tc.addDeprecatedSuggestionWorker(declarations, diagnostic)
}

func (tc *TypeChecker) addDeprecatedSuggestionWithSignature(location Node, declaration Node, deprecatedEntity *string, signatureString string) DiagnosticWithLocation {
	var diagnostic DiagnosticWithLocation
	if deprecatedEntity {
		diagnostic = createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)
	} else {
		diagnostic = createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString)
	}
	return tc.addDeprecatedSuggestionWorker(declaration, diagnostic)
}

func (tc *TypeChecker) createSymbol(flags SymbolFlags, name __String, checkFlags CheckFlags) TransientSymbol {
	tc.symbolCount++
	symbol := NewSymbol(flags|SymbolFlagsTransient, name) /* as TransientSymbol */
	symbol.links = NewSymbolLinks()                       /* as TransientSymbolLinks */
	symbol.links.checkFlags = checkFlags || CheckFlagsNone
	return symbol
}

func (tc *TypeChecker) createParameter(name __String, type_ Type) TransientSymbol {
	symbol := tc.createSymbol(SymbolFlagsFunctionScopedVariable, name)
	symbol.links.type_ = type_
	return symbol
}

func (tc *TypeChecker) createProperty(name __String, type_ Type) TransientSymbol {
	symbol := tc.createSymbol(SymbolFlagsProperty, name)
	symbol.links.type_ = type_
	return symbol
}

func (tc *TypeChecker) getExcludedSymbolFlags(flags SymbolFlags) SymbolFlags {
	var result SymbolFlags = 0
	if flags & SymbolFlagsBlockScopedVariable {
		result |= SymbolFlagsBlockScopedVariableExcludes
	}
	if flags & SymbolFlagsFunctionScopedVariable {
		result |= SymbolFlagsFunctionScopedVariableExcludes
	}
	if flags & SymbolFlagsProperty {
		result |= SymbolFlagsPropertyExcludes
	}
	if flags & SymbolFlagsEnumMember {
		result |= SymbolFlagsEnumMemberExcludes
	}
	if flags & SymbolFlagsFunction {
		result |= SymbolFlagsFunctionExcludes
	}
	if flags & SymbolFlagsClass {
		result |= SymbolFlagsClassExcludes
	}
	if flags & SymbolFlagsInterface {
		result |= SymbolFlagsInterfaceExcludes
	}
	if flags & SymbolFlagsRegularEnum {
		result |= SymbolFlagsRegularEnumExcludes
	}
	if flags & SymbolFlagsConstEnum {
		result |= SymbolFlagsConstEnumExcludes
	}
	if flags & SymbolFlagsValueModule {
		result |= SymbolFlagsValueModuleExcludes
	}
	if flags & SymbolFlagsMethod {
		result |= SymbolFlagsMethodExcludes
	}
	if flags & SymbolFlagsGetAccessor {
		result |= SymbolFlagsGetAccessorExcludes
	}
	if flags & SymbolFlagsSetAccessor {
		result |= SymbolFlagsSetAccessorExcludes
	}
	if flags & SymbolFlagsTypeParameter {
		result |= SymbolFlagsTypeParameterExcludes
	}
	if flags & SymbolFlagsTypeAlias {
		result |= SymbolFlagsTypeAliasExcludes
	}
	if flags & SymbolFlagsAlias {
		result |= SymbolFlagsAliasExcludes
	}
	return result
}

func (tc *TypeChecker) recordMergedSymbol(target Symbol, source Symbol) {
	if !source.mergeId {
		source.mergeId = nextMergeId
		nextMergeId++
	}
	tc.mergedSymbols[source.mergeId] = target
}

func (tc *TypeChecker) cloneSymbol(symbol Symbol) TransientSymbol {
	result := tc.createSymbol(symbol.flags, symbol.escapedName)
	if symbol.declarations {
		result.declarations = symbol.declarations.slice()
	} else {
		result.declarations = []never{}
	}
	result.parent = symbol.parent
	if symbol.valueDeclaration {
		result.valueDeclaration = symbol.valueDeclaration
	}
	if symbol.constEnumOnlyModule {
		result.constEnumOnlyModule = true
	}
	if symbol.members {
		result.members = NewMap(symbol.members)
	}
	if symbol.exports {
		result.exports = NewMap(symbol.exports)
	}
	tc.recordMergedSymbol(result, symbol)
	return result
}

/**
 * Note: if target is transient, then it is mutable, and mergeSymbol with both mutate and return it.
 * If target is not transient, mergeSymbol will produce a transient clone, mutate that and return it.
 */

func (tc *TypeChecker) mergeSymbol(target Symbol, source Symbol, unidirectional bool /*  = false */) Symbol {
	if !(target.flags & tc.getExcludedSymbolFlags(source.flags)) || (source.flags|target.flags)&SymbolFlagsAssignment {
		if source == target {
			// This can happen when an export assigned namespace exports something also erroneously exported at the top level
			// See `declarationFileNoCrashOnExtraExportModifier` for an example
			return target
		}
		if !(target.flags & SymbolFlagsTransient) {
			resolvedTarget := tc.resolveSymbol(target)
			if resolvedTarget == tc.unknownSymbol {
				return source
			}
			if !(resolvedTarget.flags & tc.getExcludedSymbolFlags(source.flags)) || (source.flags|resolvedTarget.flags)&SymbolFlagsAssignment {
				target = tc.cloneSymbol(resolvedTarget)
			} else {
				reportMergeSymbolError(target, source)
				return source
			}
		}
		// Javascript static-property-assignment declarations always merge, even though they are also values
		if source.flags&SymbolFlagsValueModule && target.flags&SymbolFlagsValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule {
			// reset flag when merging instantiated module into value module that has only const enums
			target.constEnumOnlyModule = false
		}
		target.flags |= source.flags
		if source.valueDeclaration {
			setValueDeclaration(target, source.valueDeclaration)
		}
		addRange(target.declarations, source.declarations)
		if source.members {
			if !target.members {
				target.members = createSymbolTable()
			}
			tc.mergeSymbolTable(target.members, source.members, unidirectional)
		}
		if source.exports {
			if !target.exports {
				target.exports = createSymbolTable()
			}
			tc.mergeSymbolTable(target.exports, source.exports, unidirectional, target)
		}
		if !unidirectional {
			tc.recordMergedSymbol(target, source)
		}
	} else if target.flags & SymbolFlagsNamespaceModule {
		// Do not report an error when merging `var globalThis` with the built-in `globalThis`,
		// as we will already report a "Declaration name conflicts..." error, and this error
		// won't make much sense.
		if target != tc.globalThisSymbol {
			tc.error(source.declarations && getNameOfDeclaration(source.declarations[0]), Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, tc.symbolToString(target))
		}
	} else {
		reportMergeSymbolError(target, source)
	}
	return target

	reportMergeSymbolError := func(target Symbol, source Symbol) {
		isEitherEnum := !!(target.flags&SymbolFlagsEnum || source.flags&SymbolFlagsEnum)
		isEitherBlockScoped := !!(target.flags&SymbolFlagsBlockScopedVariable || source.flags&SymbolFlagsBlockScopedVariable)
		var message DiagnosticMessage
		switch {
		case isEitherEnum:
			message = Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations
		case isEitherBlockScoped:
			message = Diagnostics.Cannot_redeclare_block_scoped_variable_0
		default:
			message = Diagnostics.Duplicate_identifier_0
		}
		sourceSymbolFile := source.declarations && getSourceFileOfNode(source.declarations[0])
		targetSymbolFile := target.declarations && getSourceFileOfNode(target.declarations[0])

		isSourcePlainJs := isPlainJsFile(sourceSymbolFile, tc.compilerOptions.checkJs)
		isTargetPlainJs := isPlainJsFile(targetSymbolFile, tc.compilerOptions.checkJs)
		symbolName := tc.symbolToString(source)

		// Collect top-level duplicate identifier errors into one mapping, so we can then merge their diagnostics if there are a bunch
		if sourceSymbolFile && targetSymbolFile && tc.amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile != targetSymbolFile {
			var firstFile SourceFile
			if comparePaths(sourceSymbolFile.path, targetSymbolFile.path) == ComparisonLessThan {
				firstFile = sourceSymbolFile
			} else {
				firstFile = targetSymbolFile
			}
			var secondFile SourceFile
			if firstFile == sourceSymbolFile {
				secondFile = targetSymbolFile
			} else {
				secondFile = sourceSymbolFile
			}
			filesDuplicates := getOrUpdate(tc.amalgamatedDuplicates, __TEMPLATE__(firstFile.path, "|", secondFile.path), func() DuplicateInfoForFiles {
				return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"firstFile":          firstFile,
					"secondFile":         secondFile,
					"conflictingSymbols": NewMap(),
				})
			})
			conflictingSymbolInfo := getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, func() DuplicateInfoForSymbol {
				return (map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"isBlockScoped":       isEitherBlockScoped,
					"firstFileLocations":  []never{},
					"secondFileLocations": []never{},
				})
			})
			if !isSourcePlainJs {
				addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source)
			}
			if !isTargetPlainJs {
				addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target)
			}
		} else {
			if !isSourcePlainJs {
				tc.addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target)
			}
			if !isTargetPlainJs {
				tc.addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source)
			}
		}
	}

	addDuplicateLocations := func(locs []Declaration, symbol Symbol) {
		if symbol.declarations {
			for _, decl := range symbol.declarations {
				pushIfUnique(locs, decl)
			}
		}
	}

}

func (tc *TypeChecker) addDuplicateDeclarationErrorsForSymbols(target Symbol, message DiagnosticMessage, symbolName string, source Symbol) {
	forEach(target.declarations, func(node Declaration) {
		tc.addDuplicateDeclarationError(node, message, symbolName, source.declarations)
	})
}

func (tc *TypeChecker) addDuplicateDeclarationError(node Declaration, message DiagnosticMessage, symbolName string, relatedNodes *[]Declaration) {
	errorNode := (__COND__(getExpandoInitializer(node /*isPrototypeAssignment*/, false), getNameOfExpando(node), getNameOfDeclaration(node))) || node
	err := tc.lookupOrIssueError(errorNode, message, symbolName)
	for _, relatedNode := range relatedNodes || emptyArray {
		adjustedNode := (__COND__(getExpandoInitializer(relatedNode /*isPrototypeAssignment*/, false), getNameOfExpando(relatedNode), getNameOfDeclaration(relatedNode))) || relatedNode
		if adjustedNode == errorNode {
			continue
		}
		err.relatedInformation = err.relatedInformation || []never{}
		leadingMessage := createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName)
		followOnMessage := createDiagnosticForNode(adjustedNode, Diagnostics.and_here)
		if length(err.relatedInformation) >= 5 || some(err.relatedInformation, func(r DiagnosticRelatedInformation) bool {
			return compareDiagnostics(r, followOnMessage) == ComparisonEqualTo || compareDiagnostics(r, leadingMessage) == ComparisonEqualTo
		}) {
			continue
		}
		addRelatedInfo(err, __COND__(!length(err.relatedInformation), leadingMessage, followOnMessage))
	}
}

func (tc *TypeChecker) combineSymbolTables(first *SymbolTable, second *SymbolTable) *SymbolTable {
	if !first. /* ? */ size {
		return second
	}
	if !second. /* ? */ size {
		return first
	}
	combined := createSymbolTable()
	tc.mergeSymbolTable(combined, first)
	tc.mergeSymbolTable(combined, second)
	return combined
}

func (tc *TypeChecker) mergeSymbolTable(target SymbolTable, source SymbolTable, unidirectional bool /*  = false */, mergedParent Symbol) {
	source.forEach(func(sourceSymbol Symbol, id __String) {
		targetSymbol := target.get(id)
		var merged Symbol
		if targetSymbol {
			merged = tc.mergeSymbol(targetSymbol, sourceSymbol, unidirectional)
		} else {
			merged = tc.getMergedSymbol(sourceSymbol)
		}
		if mergedParent && targetSymbol {
			// If a merge was performed on the target symbol, set its parent to the merged parent that initiated the merge
			// of its exports. Otherwise, `merged` came only from `sourceSymbol` and can keep its parent:
			//
			// // a.ts
			// export interface A { x: number; }
			//
			// // b.ts
			// declare module "./a" {
			//   interface A { y: number; }
			//   interface B {}
			// }
			//
			// When merging the module augmentation into a.ts, the symbol for `A` will itself be merged, so its parent
			// should be the merged module symbol. But the symbol for `B` has only one declaration, so its parent should
			// be the module augmentation symbol, which contains its only declaration.
			merged.parent = mergedParent
		}
		target.set(id, merged)
	})
}

func (tc *TypeChecker) mergeModuleAugmentation(moduleName /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteral | Identifier */ any) {
	moduleAugmentation := moduleName.parent /* as ModuleDeclaration */
	if moduleAugmentation.symbol.declarations[0] != moduleAugmentation {
		// this is a combined symbol for multiple augmentations within the same file.
		// its symbol already has accumulated information for all declarations
		// so we need to add it just once - do the work only for first declaration
		Debug.assert(moduleAugmentation.symbol.declarations.length > 1)
		return
	}

	if isGlobalScopeAugmentation(moduleAugmentation) {
		tc.mergeSymbolTable(tc.globals, moduleAugmentation.symbol.exports)
	} else {
		// find a module that about to be augmented
		// do not validate names of augmentations that are defined in ambient context
		var moduleNotFoundError *DiagnosticMessage
		if !(moduleName.parent.parent.flags & NodeFlagsAmbient) {
			moduleNotFoundError = Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found
		} else {
			moduleNotFoundError = nil
		}
		mainModule := tc.resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError /*ignoreErrors*/, false /*isForAugmentation*/, true)
		if !mainModule {
			return
		}
		// obtain item referenced by 'export='
		mainModule = tc.resolveExternalModuleSymbol(mainModule)
		if mainModule.flags & SymbolFlagsNamespace {
			// If we're merging an augmentation to a pattern ambient module, we want to
			// perform the merge unidirectionally from the augmentation ('a.foo') to
			// the pattern ('*.foo'), so that 'getMergedSymbol()' on a.foo gives you
			// all the exports both from the pattern and from the augmentation, but
			// 'getMergedSymbol()' on *.foo only gives you exports from *.foo.
			if some(tc.patternAmbientModules, func(module PatternAmbientModule) bool {
				return mainModule == module.symbol
			}) {
				merged := tc.mergeSymbol(moduleAugmentation.symbol, mainModule /*unidirectional*/, true)
				if !tc.patternAmbientModuleAugmentations {
					tc.patternAmbientModuleAugmentations = NewMap()
				}
				// moduleName will be a StringLiteral since this is not `declare global`.
				tc.patternAmbientModuleAugmentations.set((moduleName /* as StringLiteral */).text, merged)
			} else {
				if mainModule.exports. /* ? */ get(InternalSymbolNameExportStar) && moduleAugmentation.symbol.exports. /* ? */ size {
					// We may need to merge the module augmentation's exports into the target symbols of the resolved exports
					resolvedExports := tc.getResolvedMembersOrExportsOfSymbol(mainModule, MembersOrExportsResolutionKindresolvedExports)
					for _, TODO_IDENTIFIER := range arrayFrom(moduleAugmentation.symbol.exports.entries()) {
						if resolvedExports.has(key) && !mainModule.exports.has(key) {
							tc.mergeSymbol(resolvedExports.get(key), value)
						}
					}
				}
				tc.mergeSymbol(mainModule, moduleAugmentation.symbol)
			}
		} else {
			// moduleName will be a StringLiteral since this is not `declare global`.
			tc.error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName /* as StringLiteral */).text)
		}
	}
}

func (tc *TypeChecker) addUndefinedToGlobalsOrErrorOnRedeclaration() {
	name := tc.undefinedSymbol.escapedName
	targetSymbol := tc.globals.get(name)
	if targetSymbol {
		forEach(targetSymbol.declarations, func(declaration Declaration) {
			// checkTypeNameIsReserved will have added better diagnostics for type declarations.
			if !isTypeDeclaration(declaration) {
				tc.diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)))
			}
		})
	} else {
		tc.globals.set(name, tc.undefinedSymbol)
	}
}

func (tc *TypeChecker) getSymbolLinks(symbol Symbol) SymbolLinks {
	if symbol.flags & SymbolFlagsTransient {
		return (symbol /* as TransientSymbol */).links
	}
	id := getSymbolId(symbol)
	return /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: symbolLinks[id] ??= new SymbolLinks() */ TODO
}

func (tc *TypeChecker) getNodeLinks(node Node) NodeLinks {
	nodeId := getNodeId(node)
	return tc.nodeLinks[nodeId] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: nodeLinks[nodeId] = new (NodeLinks as any)() */ TODO)
}

func (tc *TypeChecker) getSymbol(symbols SymbolTable, name __String, meaning SymbolFlags) Symbol {
	if meaning {
		symbol := tc.getMergedSymbol(symbols.get(name))
		if symbol {
			if symbol.flags & meaning {
				return symbol
			}
			if symbol.flags & SymbolFlagsAlias {
				targetFlags := tc.getSymbolFlags(symbol)
				// `targetFlags` will be `SymbolFlags.All` if an error occurred in alias resolution; this avoids cascading errors
				if targetFlags & meaning {
					return symbol
				}
			}
		}
	}
	// return undefined if we can't find a symbol.
}

/**
 * Get symbols that represent parameter-property-declaration as parameter and as property declaration
 * @param parameter a parameterDeclaration node
 * @param parameterName a name of the parameter to get the symbols for.
 * @return a tuple of two symbols
 */

func (tc *TypeChecker) getSymbolsOfParameterPropertyDeclaration(parameter ParameterPropertyDeclaration, parameterName __String) /* TODO(TS-TO-GO) TypeNode TupleType: [Symbol, Symbol] */ any {
	constructorDeclaration := parameter.parent
	classDeclaration := parameter.parent.parent

	parameterSymbol := tc.getSymbol(constructorDeclaration.locals, parameterName, SymbolFlagsValue)
	propertySymbol := tc.getSymbol(tc.getMembersOfSymbol(classDeclaration.symbol), parameterName, SymbolFlagsValue)

	if parameterSymbol && propertySymbol {
		return []any{parameterSymbol, propertySymbol}
	}

	return Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration")
}

func (tc *TypeChecker) isBlockScopedNameDeclaredBeforeUse(declaration Declaration, usage Node) bool {
	declarationFile := getSourceFileOfNode(declaration)
	useFile := getSourceFileOfNode(usage)
	declContainer := getEnclosingBlockScopeContainer(declaration)
	if declarationFile != useFile {
		if (tc.moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) || (!tc.compilerOptions.outFile) || isInTypeQuery(usage) || declaration.flags&NodeFlagsAmbient {
			// nodes are in different files and order cannot be determined
			return true
		}
		// declaration is after usage
		// can be legal if usage is deferred (i.e. inside function or in initializer of instance property)
		if isUsedInFunctionOrInstanceProperty(usage, declaration) {
			return true
		}
		sourceFiles := host.getSourceFiles()
		return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile)
	}

	// deferred usage in a type context is always OK regardless of the usage position:
	if !!(usage.flags & NodeFlagsJSDoc) || isInTypeQuery(usage) || tc.isInAmbientOrTypeNode(usage) {
		return true
	}

	if declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken) {
		// declaration is before usage
		if declaration.kind == SyntaxKindBindingElement {
			// still might be illegal if declaration and usage are both binding elements (eg var [a = b, b = b] = [1, 2])
			errorBindingElement := getAncestor(usage, SyntaxKindBindingElement) /* as BindingElement */
			if errorBindingElement {
				return findAncestor(errorBindingElement, isBindingElement) != findAncestor(declaration, isBindingElement) || declaration.pos < errorBindingElement.pos
			}
			// or it might be illegal if usage happens before parent variable is declared (eg var [a] = a)
			return tc.isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, SyntaxKindVariableDeclaration) /* as Declaration */, usage)
		} else if declaration.kind == SyntaxKindVariableDeclaration {
			// still might be illegal if usage is in the initializer of the variable declaration (eg var a = a)
			return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration /* as VariableDeclaration */, usage)
		} else if isClassLike(declaration) {
			// still might be illegal if the usage is within a computed property name in the class (eg class A { static p = "a"; [A.p]() {} })
			// or when used within a decorator in the class (e.g. `@dec(A.x) class A { static x = "x" }`),
			// except when used in a function that is not an IIFE (e.g., `@dec(() => A.x) class A { ... }`)
			container := findAncestor(usage, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
				switch {
				case n == declaration:
					return "quit"
				case isComputedPropertyName(n):
					return n.parent.parent == declaration
				default:
					return !tc.legacyDecorators && isDecorator(n) && (n.parent == declaration || isMethodDeclaration(n.parent) && n.parent.parent == declaration || isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent == declaration || isPropertyDeclaration(n.parent) && n.parent.parent == declaration || isParameter(n.parent) && n.parent.parent.parent == declaration)
				}
			})
			if !container {
				return true
			}
			if !tc.legacyDecorators && isDecorator(container) {
				return !!findAncestor(usage, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
					if n == container {
						return "quit"
					} else {
						return isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n)
					}
				})
			}
			return false
		} else if isPropertyDeclaration(declaration) {
			// still might be illegal if a self-referencing property initializer (eg private x = this.x)
			return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage /*stopAtAnyPropertyDeclaration*/, false)
		} else if isParameterPropertyDeclaration(declaration, declaration.parent) {
			// foo = this.bar is illegal in emitStandardClassFields when bar is a parameter property
			return !(tc.emitStandardClassFields && getContainingClass(declaration) == getContainingClass(usage) && isUsedInFunctionOrInstanceProperty(usage, declaration))
		}
		return true
	}

	// declaration is after usage, but it can still be legal if usage is deferred:
	// 1. inside an export specifier
	// 2. inside a function
	// 3. inside an instance property initializer, a reference to a non-instance property
	//    (except when emitStandardClassFields: true and the reference is to a parameter property)
	// 4. inside a static property initializer, a reference to a static method in the same class
	// 5. inside a TS export= declaration (since we will move the export statement during emit to avoid TDZ)
	if usage.parent.kind == SyntaxKindExportSpecifier || (usage.parent.kind == SyntaxKindExportAssignment && (usage.parent /* as ExportAssignment */).isExportEquals) {
		// export specifiers do not use the variable, they only make it available for use
		return true
	}
	// When resolving symbols for exports, the `usage` location passed in can be the export site directly
	if usage.kind == SyntaxKindExportAssignment && (usage /* as ExportAssignment */).isExportEquals {
		return true
	}

	if isUsedInFunctionOrInstanceProperty(usage, declaration) {
		if tc.emitStandardClassFields && getContainingClass(declaration) && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent)) {
			return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage /*stopAtAnyPropertyDeclaration*/, true)
		} else {
			return true
		}
	}
	return false

	isImmediatelyUsedInInitializerOfBlockScopedVariable := func(declaration VariableDeclaration, usage Node) bool {
		switch declaration.parent.parent.kind {
		case SyntaxKindVariableStatement,
			SyntaxKindForStatement,
			SyntaxKindForOfStatement:
			if tc.isSameScopeDescendentOf(usage, declaration, declContainer) {
				return true
			}
		}

		// ForIn/ForOf case - use site should not be used in expression part
		grandparent := declaration.parent.parent
		return isForInOrOfStatement(grandparent) && tc.isSameScopeDescendentOf(usage, grandparent.expression, declContainer)
	}

	isUsedInFunctionOrInstanceProperty := func(usage Node, declaration Node) bool {
		return !!findAncestor(usage, func(current Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			if current == declContainer {
				return "quit"
			}
			if isFunctionLike(current) {
				return true
			}
			if isClassStaticBlockDeclaration(current) {
				return declaration.pos < usage.pos
			}

			propertyDeclaration := tryCast(current.parent, isPropertyDeclaration)
			if propertyDeclaration {
				initializerOfProperty := propertyDeclaration.initializer == current
				if initializerOfProperty {
					if isStatic(current.parent) {
						if declaration.kind == SyntaxKindMethodDeclaration {
							return true
						}
						if isPropertyDeclaration(declaration) && getContainingClass(usage) == getContainingClass(declaration) {
							propName := declaration.name
							if isIdentifier(propName) || isPrivateIdentifier(propName) {
								type_ := tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(declaration))
								staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
								if tc.isPropertyInitializedInStaticBlocks(propName, type_, staticBlocks, declaration.parent.pos, current.pos) {
									return true
								}
							}
						}
					} else {
						isDeclarationInstanceProperty := declaration.kind == SyntaxKindPropertyDeclaration && !isStatic(declaration)
						if !isDeclarationInstanceProperty || getContainingClass(usage) != getContainingClass(declaration) {
							return true
						}
					}
				}
			}
			return false
		})
	}

	/** stopAtAnyPropertyDeclaration is used for detecting ES-standard class field use-before-def errors */

	isPropertyImmediatelyReferencedWithinDeclaration := func(declaration /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | ParameterPropertyDeclaration */ any, usage Node, stopAtAnyPropertyDeclaration bool) bool {
		// always legal if usage is after declaration
		if usage.end > declaration.end {
			return false
		}

		// still might be legal if usage is deferred (e.g. x: any = () => this.x)
		// otherwise illegal if immediately referenced within the declaration (e.g. x: any = this.x)
		ancestorChangingReferenceScope := findAncestor(usage, func(node Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			if node == declaration {
				return "quit"
			}

			switch node.kind {
			case SyntaxKindArrowFunction:
				return true
			case SyntaxKindPropertyDeclaration:
				if stopAtAnyPropertyDeclaration && (isPropertyDeclaration(declaration) && node.parent == declaration.parent || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent == declaration.parent.parent) {
					return "quit"
				} else {
					return true
				}
			case SyntaxKindBlock:
				switch node.parent.kind {
				case SyntaxKindGetAccessor,
					SyntaxKindMethodDeclaration,
					SyntaxKindSetAccessor:
					return true
				default:
					return false
				}
				fallthrough
			default:
				return false
			}
		})

		return ancestorChangingReferenceScope == nil
	}

}

func (tc *TypeChecker) getRequiresScopeChangeCache(node FunctionLikeDeclaration) *bool {
	return tc.getNodeLinks(node).declarationRequiresScopeChange
}

func (tc *TypeChecker) setRequiresScopeChangeCache(node FunctionLikeDeclaration, value bool) {
	tc.getNodeLinks(node).declarationRequiresScopeChange = value
}

// The invalid initializer error is needed in two situation:
// 1. When result is undefined, after checking for a missing "this."
// 2. When result is defined
func (tc *TypeChecker) checkAndReportErrorForInvalidInitializer(errorLocation Node, name __String, propertyWithInvalidInitializer PropertyDeclaration, result Symbol) bool {
	if !tc.emitStandardClassFields {
		if errorLocation && !result && tc.checkAndReportErrorForMissingPrefix(errorLocation, name, name) {
			return true
		}
		// We have a match, but the reference occurred within a property initializer and the identifier also binds
		// to a local variable in the constructor where the code will be emitted. Note that this is actually allowed
		// with emitStandardClassFields because the scope semantics are different.
		tc.error(errorLocation, __COND__(errorLocation && propertyWithInvalidInitializer.type_ && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type_, errorLocation.pos), Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor), declarationNameToString(propertyWithInvalidInitializer.name), tc.diagnosticName(name))
		return true
	}
	return false
}

func (tc *TypeChecker) onFailedToResolveSymbol(errorLocation Node, nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage) {
	var name /* TODO(TS-TO-GO) inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | InternalSymbolName */ any
	if isString(nameArg) {
		name = nameArg
	} else {
		name = (nameArg /* as Identifier */).escapedText
	}
	tc.addLazyDiagnostic(func() {
		if !errorLocation || errorLocation.parent.kind != SyntaxKindJSDocLink && !tc.checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) && !tc.checkAndReportErrorForExtendingInterface(errorLocation) && !tc.checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) && !tc.checkAndReportErrorForExportingPrimitiveType(errorLocation, name) && !tc.checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) && !tc.checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) && !tc.checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
			var suggestion Symbol
			var suggestedLib *string
			// Report missing lib first
			if nameArg {
				suggestedLib = tc.getSuggestedLibForNonExistentName(nameArg)
				if suggestedLib {
					tc.error(errorLocation, nameNotFoundMessage, tc.diagnosticName(nameArg), suggestedLib)
				}
			}
			// then spelling suggestions
			if !suggestedLib && tc.suggestionCount < tc.maximumSuggestionCount {
				suggestion = tc.getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning)
				isGlobalScopeAugmentationDeclaration := suggestion. /* ? */ valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration)
				if isGlobalScopeAugmentationDeclaration {
					suggestion = nil
				}
				if suggestion {
					suggestionName := tc.symbolToString(suggestion)
					isUncheckedJS := tc.isUncheckedJSSuggestion(errorLocation, suggestion /*excludeClasses*/, false)
					var message DiagnosticMessage
					switch {
					case meaning == SymbolFlagsNamespace || nameArg && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof nameArg */ TODO != "string" && nodeIsSynthesized(nameArg):
						message = Diagnostics.Cannot_find_namespace_0_Did_you_mean_1
					case isUncheckedJS:
						message = Diagnostics.Could_not_find_name_0_Did_you_mean_1
					default:
						message = Diagnostics.Cannot_find_name_0_Did_you_mean_1
					}
					diagnostic := tc.createError(errorLocation, message, tc.diagnosticName(nameArg), suggestionName)
					diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, tc.diagnosticName(nameArg))
					tc.addErrorOrSuggestion(!isUncheckedJS, diagnostic)
					if suggestion.valueDeclaration {
						addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
					}
				}
			}
			// And then fall back to unspecified "not found"
			if !suggestion && !suggestedLib && nameArg {
				tc.error(errorLocation, nameNotFoundMessage, tc.diagnosticName(nameArg))
			}
			tc.suggestionCount++
		}
	})
}

func (tc *TypeChecker) onSuccessfullyResolvedSymbol(errorLocation Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool) {
	tc.addLazyDiagnostic(func() {
		name := result.escapedName
		isInExternalModule := lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation)
		// Only check for block-scoped variable if we have an error location and are looking for the
		// name with variable meaning
		//      For example,
		//          declare module foo {
		//              interface bar {}
		//          }
		//      const foo/*1*/: foo/*2*/.bar;
		// The foo at /*1*/ and /*2*/ will share same symbol with two meanings:
		// block-scoped variable and namespace module. However, only when we
		// try to resolve name in /*1*/ which is used in variable position,
		// we want to check for block-scoped
		if errorLocation && (meaning&SymbolFlagsBlockScopedVariable || ((meaning&SymbolFlagsClass || meaning&SymbolFlagsEnum) && (meaning&SymbolFlagsValue) == SymbolFlagsValue)) {
			exportOrLocalSymbol := tc.getExportSymbolOfValueSymbolIfExported(result)
			if exportOrLocalSymbol.flags&SymbolFlagsBlockScopedVariable || exportOrLocalSymbol.flags&SymbolFlagsClass || exportOrLocalSymbol.flags&SymbolFlagsEnum {
				tc.checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation)
			}
		}

		// If we're in an external module, we can't reference value symbols created from UMD export declarations
		if isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue && !(errorLocation.flags & NodeFlagsJSDoc) {
			merged := tc.getMergedSymbol(result)
			if length(merged.declarations) && every(merged.declarations, func(d Declaration) bool {
				return isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports
			}) {
				tc.errorOrSuggestion(!tc.compilerOptions.allowUmdGlobalAccess, errorLocation, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name))
			}
		}

		// If we're in a parameter initializer or binding name, we can't reference the values of the parameter whose initializer we're within or parameters to the right
		if associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
			candidate := tc.getMergedSymbol(tc.getLateBoundSymbol(result))
			root := getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) /* as ParameterDeclaration */
			// A parameter initializer or binding pattern initializer within a parameter cannot refer to itself
			if candidate == tc.getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName) {
				tc.error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name))
			} else if candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && tc.getSymbol(root.parent.locals, candidate.escapedName, meaning) == candidate {
				tc.error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation /* as Identifier */))
			}
		}
		if errorLocation && meaning&SymbolFlagsValue && result.flags&SymbolFlagsAlias && !(result.flags & SymbolFlagsValue) && !isValidTypeOnlyAliasUseSite(errorLocation) {
			typeOnlyDeclaration := tc.getTypeOnlyAliasDeclaration(result, SymbolFlagsValue)
			if typeOnlyDeclaration {
				var message DiagnosticMessage
				if typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration || typeOnlyDeclaration.kind == SyntaxKindNamespaceExport {
					message = Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type
				} else {
					message = Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type
				}
				unescapedName := unescapeLeadingUnderscores(name)
				tc.addTypeOnlyDeclarationRelatedInfo(tc.error(errorLocation, message, unescapedName), typeOnlyDeclaration, unescapedName)
			}
		}

		// Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
		// here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
		if tc.compilerOptions.isolatedModules && result && isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
			isGlobal := tc.getSymbol(tc.globals, name, meaning) == result
			nonValueSymbol := isGlobal && isSourceFile(lastLocation) && lastLocation.locals && tc.getSymbol(lastLocation.locals, name, ~SymbolFlagsValue)
			if nonValueSymbol {
				importDecl := nonValueSymbol.declarations. /* ? */ find(func(d Declaration) bool {
					return d.kind == SyntaxKindImportSpecifier || d.kind == SyntaxKindImportClause || d.kind == SyntaxKindNamespaceImport || d.kind == SyntaxKindImportEqualsDeclaration
				})
				if importDecl && !isTypeOnlyImportDeclaration(importDecl) {
					tc.error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name))
				}
			}
		}
	})
}

func (tc *TypeChecker) addTypeOnlyDeclarationRelatedInfo(diagnostic Diagnostic, typeOnlyDeclaration *TypeOnlyCompatibleAliasDeclaration, unescapedName string) Diagnostic {
	if !typeOnlyDeclaration {
		return diagnostic
	}
	return addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration, __COND__(typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration || typeOnlyDeclaration.kind == SyntaxKindNamespaceExport, Diagnostics._0_was_exported_here, Diagnostics._0_was_imported_here), unescapedName))
}

func (tc *TypeChecker) diagnosticName(nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier | PrivateIdentifier */ any) string {
	if isString(nameArg) {
		return unescapeLeadingUnderscores(nameArg /* as __String */)
	} else {
		return declarationNameToString(nameArg /* as Identifier */)
	}
}

func (tc *TypeChecker) checkAndReportErrorForMissingPrefix(errorLocation Node, name __String, nameArg /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any) bool {
	if !isIdentifier(errorLocation) || errorLocation.escapedText != name || tc.isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation) {
		return false
	}

	container := getThisContainer(errorLocation /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
	var location Node = container
	for location {
		if isClassLike(location.parent) {
			classSymbol := tc.getSymbolOfDeclaration(location.parent)
			if !classSymbol {
				break
			}

			// Check to see if a static member exists.
			constructorType := tc.getTypeOfSymbol(classSymbol)
			if tc.getPropertyOfType(constructorType, name) {
				tc.error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, tc.diagnosticName(nameArg), tc.symbolToString(classSymbol))
				return true
			}

			// No static member is present.
			// Check if we're in an instance method and look for a relevant instance member.
			if location == container && !isStatic(location) {
				instanceType := (tc.getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */).thisType
				// TODO: GH#18217
				if tc.getPropertyOfType(instanceType, name) {
					tc.error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, tc.diagnosticName(nameArg))
					return true
				}
			}
		}

		location = location.parent
	}
	return false
}

func (tc *TypeChecker) checkAndReportErrorForExtendingInterface(errorLocation Node) bool {
	expression := tc.getEntityNameForExtendingInterface(errorLocation)
	if expression && tc.resolveEntityName(expression, SymbolFlagsInterface /*ignoreErrors*/, true) {
		tc.error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression))
		return true
	}
	return false
}

/**
 * Climbs up parents to an ExpressionWithTypeArguments, and returns its expression,
 * but returns undefined if that expression is not an EntityNameExpression.
 */

func (tc *TypeChecker) getEntityNameForExtendingInterface(node Node) *EntityNameExpression {
	switch node.kind {
	case SyntaxKindIdentifier,
		SyntaxKindPropertyAccessExpression:
		if node.parent {
			return tc.getEntityNameForExtendingInterface(node.parent)
		} else {
			return nil
		}
	case SyntaxKindExpressionWithTypeArguments:
		if isEntityNameExpression((node /* as ExpressionWithTypeArguments */).expression) {
			return (node /* as ExpressionWithTypeArguments */).expression /* as EntityNameExpression */
		}
		fallthrough
	default:
		return nil
	}
}

func (tc *TypeChecker) checkAndReportErrorForUsingTypeAsNamespace(errorLocation Node, name __String, meaning SymbolFlags) bool {
	namespaceMeaning := SymbolFlagsNamespace | (__COND__(isInJSFile(errorLocation), SymbolFlagsValue, 0))
	if meaning == namespaceMeaning {
		symbol := tc.resolveSymbol(tc.resolveName(errorLocation, name, SymbolFlagsType&~namespaceMeaning /*nameNotFoundMessage*/, nil /*isUse*/, false))
		parent := errorLocation.parent
		if symbol {
			if isQualifiedName(parent) {
				Debug.assert(parent.left == errorLocation, "Should only be resolving left side of qualified name as a namespace")
				propName := parent.right.escapedText
				propType := tc.getPropertyOfType(tc.getDeclaredTypeOfSymbol(symbol), propName)
				if propType {
					tc.error(parent, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, unescapeLeadingUnderscores(name), unescapeLeadingUnderscores(propName))
					return true
				}
			}
			tc.error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name))
			return true
		}
	}

	return false
}

func (tc *TypeChecker) checkAndReportErrorForUsingValueAsType(errorLocation Node, name __String, meaning SymbolFlags) bool {
	if meaning & (SymbolFlagsType & ~SymbolFlagsNamespace) {
		symbol := tc.resolveSymbol(tc.resolveName(errorLocation, name, ~SymbolFlagsType&SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false))
		if symbol && !(symbol.flags & SymbolFlagsNamespace) {
			tc.error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name))
			return true
		}
	}
	return false
}

func (tc *TypeChecker) isPrimitiveTypeName(name __String) bool {
	return name == "any" || name == "string" || name == "number" || name == "boolean" || name == "never" || name == "unknown"
}

func (tc *TypeChecker) checkAndReportErrorForExportingPrimitiveType(errorLocation Node, name __String) bool {
	if tc.isPrimitiveTypeName(name) && errorLocation.parent.kind == SyntaxKindExportSpecifier {
		tc.error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name /* as string */)
		return true
	}
	return false
}

func (tc *TypeChecker) checkAndReportErrorForUsingTypeAsValue(errorLocation Node, name __String, meaning SymbolFlags) bool {
	if meaning & SymbolFlagsValue {
		if tc.isPrimitiveTypeName(name) {
			grandparent := errorLocation.parent.parent
			if grandparent && grandparent.parent && isHeritageClause(grandparent) {
				heritageKind := grandparent.token
				containerKind := grandparent.parent.kind
				if containerKind == SyntaxKindInterfaceDeclaration && heritageKind == SyntaxKindExtendsKeyword {
					tc.error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name))
				} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindExtendsKeyword {
					tc.error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name))
				} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindImplementsKeyword {
					tc.error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name))
				}
			} else {
				tc.error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name))
			}
			return true
		}
		symbol := tc.resolveSymbol(tc.resolveName(errorLocation, name, SymbolFlagsType&~SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false))
		allFlags := symbol && tc.getSymbolFlags(symbol)
		if symbol && allFlags != nil && !(allFlags & SymbolFlagsValue) {
			rawName := unescapeLeadingUnderscores(name)
			if tc.isES2015OrLaterConstructorName(name) {
				tc.error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName)
			} else if tc.maybeMappedType(errorLocation, symbol) {
				tc.error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, __COND__(rawName == "K", "P", "K"))
			} else {
				tc.error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName)
			}
			return true
		}
	}
	return false
}

func (tc *TypeChecker) maybeMappedType(node Node, symbol Symbol) bool {
	container := findAncestor(node.parent, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if isComputedPropertyName(n) || isPropertySignature(n) {
			return false
		} else {
			return isTypeLiteralNode(n) || "quit"
		}
	}) /* as TypeLiteralNode | undefined */
	if container && container.members.length == 1 {
		type_ := tc.getDeclaredTypeOfSymbol(symbol)
		return !!(type_.flags & TypeFlagsUnion) && tc.allTypesAssignableToKind(type_, TypeFlagsStringOrNumberLiteral /*strict*/, true)
	}
	return false
}

func (tc *TypeChecker) isES2015OrLaterConstructorName(n __String) bool {
	switch n {
	case "Promise",
		"Symbol",
		"Map",
		"WeakMap",
		"Set",
		"WeakSet":
		return true
	}
	return false
}

func (tc *TypeChecker) checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation Node, name __String, meaning SymbolFlags) bool {
	if meaning & (SymbolFlagsValue & ~SymbolFlagsType) {
		symbol := tc.resolveSymbol(tc.resolveName(errorLocation, name, SymbolFlagsNamespaceModule /*nameNotFoundMessage*/, nil /*isUse*/, false))
		if symbol {
			tc.error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_value, unescapeLeadingUnderscores(name))
			return true
		}
	} else if meaning & (SymbolFlagsType & ~SymbolFlagsValue) {
		symbol := tc.resolveSymbol(tc.resolveName(errorLocation, name, SymbolFlagsModule /*nameNotFoundMessage*/, nil /*isUse*/, false))
		if symbol {
			tc.error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name))
			return true
		}
	}
	return false
}

func (tc *TypeChecker) checkResolvedBlockScopedVariable(result Symbol, errorLocation Node) {
	Debug.assert(!!(result.flags&SymbolFlagsBlockScopedVariable || result.flags&SymbolFlagsClass || result.flags&SymbolFlagsEnum))
	if result.flags&(SymbolFlagsFunction|SymbolFlagsFunctionScopedVariable|SymbolFlagsAssignment) && result.flags&SymbolFlagsClass {
		// constructor functions aren't block scoped
		return
	}
	// Block-scoped variables cannot be used before their definition
	declaration := result.declarations. /* ? */ find(func(d Declaration) bool {
		return isBlockOrCatchScoped(d) || isClassLike(d) || (d.kind == SyntaxKindEnumDeclaration)
	})

	if declaration == nil {
		return Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration")
	}

	if !(declaration.flags & NodeFlagsAmbient) && !tc.isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation) {
		var diagnosticMessage TODO
		declarationName := declarationNameToString(getNameOfDeclaration(declaration))
		if result.flags & SymbolFlagsBlockScopedVariable {
			diagnosticMessage = tc.error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName)
		} else if result.flags & SymbolFlagsClass {
			diagnosticMessage = tc.error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName)
		} else if result.flags & SymbolFlagsRegularEnum {
			diagnosticMessage = tc.error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
		} else {
			Debug.assert(!!(result.flags & SymbolFlagsConstEnum))
			if getIsolatedModules(tc.compilerOptions) {
				diagnosticMessage = tc.error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
			}
		}

		if diagnosticMessage {
			addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName))
		}
	}
}

/* Starting from 'initial' node walk up the parent chain until 'stopAt' node is reached.
 * If at any point current node is equal to 'parent' node - return true.
 * If current node is an IIFE, continue walking up.
 * Return false if 'stopAt' node is reached or isFunctionLike(current) === true.
 */
func (tc *TypeChecker) isSameScopeDescendentOf(initial Node, parent Node, stopAt Node) bool {
	return !!parent && !!findAncestor(initial, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		return n == parent || (__COND__(n == stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n)&FunctionFlagsAsyncGenerator)), "quit", false))
	})
}

func (tc *TypeChecker) getAnyImportSyntax(node Node) *AnyImportOrJsDocImport {
	switch node.kind {
	case SyntaxKindImportEqualsDeclaration:
		return node /* as ImportEqualsDeclaration */
	case SyntaxKindImportClause:
		return (node /* as ImportClause */).parent
	case SyntaxKindNamespaceImport:
		return (node /* as NamespaceImport */).parent.parent
	case SyntaxKindImportSpecifier:
		return (node /* as ImportSpecifier */).parent.parent.parent
	default:
		return nil
	}
}

func (tc *TypeChecker) getDeclarationOfAliasSymbol(symbol Symbol) Declaration {
	return symbol.declarations && findLast(symbol.declarations, tc.isAliasSymbolDeclaration)
}

/**
 * An alias symbol is created by one of the following declarations:
 * import <symbol> = ...
 * import <symbol> from ...
 * import * as <symbol> from ...
 * import { x as <symbol> } from ...
 * export { x as <symbol> } from ...
 * export * as ns <symbol> from ...
 * export = <EntityNameExpression>
 * export default <EntityNameExpression>
 * module.exports = <EntityNameExpression>
 * {<Identifier>}
 * {name: <EntityNameExpression>}
 * const { x } = require ...
 */

func (tc *TypeChecker) isAliasSymbolDeclaration(node Node) bool {
	return node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindNamespaceExportDeclaration || node.kind == SyntaxKindImportClause && !!(node /* as ImportClause */).name || node.kind == SyntaxKindNamespaceImport || node.kind == SyntaxKindNamespaceExport || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindExportSpecifier || node.kind == SyntaxKindExportAssignment && exportAssignmentIsAlias(node /* as ExportAssignment */) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) == AssignmentDeclarationKindModuleExports && exportAssignmentIsAlias(node) || isAccessExpression(node) && isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken && tc.isAliasableOrJsExpression(node.parent.right) || node.kind == SyntaxKindShorthandPropertyAssignment || node.kind == SyntaxKindPropertyAssignment && tc.isAliasableOrJsExpression((node /* as PropertyAssignment */).initializer) || node.kind == SyntaxKindVariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node) || node.kind == SyntaxKindBindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent)
}

func (tc *TypeChecker) isAliasableOrJsExpression(e Expression) bool {
	return isAliasableExpression(e) || isFunctionExpression(e) && tc.isJSConstructor(e)
}

func (tc *TypeChecker) getTargetOfImportEqualsDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | VariableDeclaration */ any, dontResolveAlias bool) Symbol {
	commonJSPropertyAccess := tc.getCommonJSPropertyAccess(node)
	if commonJSPropertyAccess {
		name := (getLeftmostAccessExpression(commonJSPropertyAccess.expression) /* as CallExpression */).arguments[0] /* as StringLiteral */
		if isIdentifier(commonJSPropertyAccess.name) {
			return tc.resolveSymbol(tc.getPropertyOfType(tc.resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))
		} else {
			return nil
		}
	}
	if isVariableDeclaration(node) || node.moduleReference.kind == SyntaxKindExternalModuleReference {
		immediate := tc.resolveExternalModuleName(node, getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node))
		resolved := tc.resolveExternalModuleSymbol(immediate)
		tc.markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	resolved := tc.getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias)
	tc.checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved)
	return resolved
}

func (tc *TypeChecker) checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node ImportEqualsDeclaration, resolved Symbol) {
	if tc.markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false) && !node.isTypeOnly {
		typeOnlyDeclaration := tc.getTypeOnlyAliasDeclaration(tc.getSymbolOfDeclaration(node))
		isExport := typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration
		var message DiagnosticMessage
		if isExport {
			message = Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type
		} else {
			message = Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type
		}
		var relatedMessage DiagnosticMessage
		if isExport {
			relatedMessage = Diagnostics._0_was_exported_here
		} else {
			relatedMessage = Diagnostics._0_was_imported_here
		}

		// TODO: how to get name for export *?
		var name string
		if typeOnlyDeclaration.kind == SyntaxKindExportDeclaration {
			name = "*"
		} else {
			name = moduleExportNameTextUnescaped(typeOnlyDeclaration.name)
		}
		addRelatedInfo(tc.error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name))
	}
}

func (tc *TypeChecker) resolveExportByName(moduleSymbol Symbol, name __String, sourceNode *TypeOnlyCompatibleAliasDeclaration, dontResolveAlias bool) Symbol {
	exportValue := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
	var exportSymbol Symbol
	if exportValue {
		exportSymbol = tc.getPropertyOfType(tc.getTypeOfSymbol(exportValue), name /*skipObjectFunctionPropertyAugment*/, true)
	} else {
		exportSymbol = moduleSymbol.exports.get(name)
	}
	resolved := tc.resolveSymbol(exportSymbol, dontResolveAlias)
	tc.markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved /*overwriteEmpty*/, false)
	return resolved
}

func (tc *TypeChecker) isSyntacticDefault(node Node) bool {
	return ((isExportAssignment(node) && !node.isExportEquals) || hasSyntacticModifier(node, ModifierFlagsDefault) || isExportSpecifier(node) || isNamespaceExport(node))
}

func (tc *TypeChecker) getEmitSyntaxForModuleSpecifierExpression(usage Expression) ResolutionMode {
	if isStringLiteralLike(usage) {
		return host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage)
	} else {
		return nil
	}
}

func (tc *TypeChecker) isESMFormatImportImportingCommonjsFormatFile(usageMode ResolutionMode, targetMode ResolutionMode) bool {
	return usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS
}

func (tc *TypeChecker) isOnlyImportableAsDefault(usage Expression) bool {
	// In Node.js, JSON modules don't get named exports
	if ModuleKindNode16 <= tc.moduleKind && tc.moduleKind <= ModuleKindNodeNext {
		usageMode := tc.getEmitSyntaxForModuleSpecifierExpression(usage)
		return usageMode == ModuleKindESNext && endsWith((usage /* as StringLiteralLike */).text, ExtensionJson)
	}
	return false
}

func (tc *TypeChecker) canHaveSyntheticDefault(file *SourceFile, moduleSymbol Symbol, dontResolveAlias bool, usage Expression) bool {
	usageMode := file && tc.getEmitSyntaxForModuleSpecifierExpression(usage)
	if file && usageMode != nil {
		targetMode := host.getImpliedNodeFormatForEmit(file)
		if usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS && ModuleKindNode16 <= tc.moduleKind && tc.moduleKind <= ModuleKindNodeNext {
			// In Node.js, CommonJS modules always have a synthetic default when imported into ESM
			return true
		}
		if usageMode == ModuleKindESNext && targetMode == ModuleKindESNext {
			// No matter what the `module` setting is, if we're confident that both files
			// are ESM, there cannot be a synthetic default.
			return false
		}
	}
	if !tc.allowSyntheticDefaultImports {
		return false
	}
	// Declaration files (and ambient modules)
	if !file || file.isDeclarationFile {
		// Definitely cannot have a synthetic default if they have a syntactic default member specified
		defaultExportSymbol := tc.resolveExportByName(moduleSymbol, InternalSymbolNameDefault /*sourceNode*/, nil /*dontResolveAlias*/, true)
		// Dont resolve alias because we want the immediately exported symbol's declaration
		if defaultExportSymbol && some(defaultExportSymbol.declarations, tc.isSyntacticDefault) {
			return false
		}
		// It _might_ still be incorrect to assume there is no __esModule marker on the import at runtime, even if there is no `default` member
		// So we check a bit more,
		if tc.resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule") /*sourceNode*/, nil, dontResolveAlias) {
			// If there is an `__esModule` specified in the declaration (meaning someone explicitly added it or wrote it in their code),
			// it definitely is a module and does not have a synthetic default
			return false
		}
		// There are _many_ declaration files not written with esmodules in mind that still get compiled into a format with __esModule set
		// Meaning there may be no default at runtime - however to be on the permissive side, we allow access to a synthetic default member
		// as there is no marker to indicate if the accompanying JS has `__esModule` or not, or is even native esm
		return true
	}
	// TypeScript files never have a synthetic default (as they are always emitted with an __esModule marker) _unless_ they contain an export= statement
	if !isSourceFileJS(file) {
		return tc.hasExportAssignmentSymbol(moduleSymbol)
	}
	// JS files have a synthetic default if they do not contain ES2015+ module syntax (export = is not valid in js) _and_ do not have an __esModule marker
	return /* TODO(TS-TO-GO) Node TypeOfExpression: typeof file.externalModuleIndicator */ TODO != "object" && !tc.resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule") /*sourceNode*/, nil, dontResolveAlias)
}

func (tc *TypeChecker) getTargetOfImportClause(node ImportClause, dontResolveAlias bool) Symbol {
	moduleSymbol := tc.resolveExternalModuleName(node, node.parent.moduleSpecifier)
	if moduleSymbol {
		return tc.getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
	}
}

func (tc *TypeChecker) getTargetofModuleDefault(moduleSymbol Symbol, node /* TODO(TS-TO-GO) TypeNode UnionType: ImportClause | ImportOrExportSpecifier */ any, dontResolveAlias bool) Symbol {
	var exportDefaultSymbol Symbol
	if isShorthandAmbientModuleSymbol(moduleSymbol) {
		exportDefaultSymbol = moduleSymbol
	} else {
		exportDefaultSymbol = tc.resolveExportByName(moduleSymbol, InternalSymbolNameDefault, node, dontResolveAlias)
	}

	file := moduleSymbol.declarations. /* ? */ find(isSourceFile)
	specifier := tc.getModuleSpecifierForImportOrExport(node)
	if !specifier {
		return exportDefaultSymbol
	}
	hasDefaultOnly := tc.isOnlyImportableAsDefault(specifier)
	hasSyntheticDefault := tc.canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier)
	if !exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly {
		if tc.hasExportAssignmentSymbol(moduleSymbol) && !tc.allowSyntheticDefaultImports {
			var compilerOptionName /* TODO(TS-TO-GO) inferred type "allowSyntheticDefaultImports" | "esModuleInterop" */ any
			if tc.moduleKind >= ModuleKindES2015 {
				compilerOptionName = "allowSyntheticDefaultImports"
			} else {
				compilerOptionName = "esModuleInterop"
			}
			exportEqualsSymbol := moduleSymbol.exports.get(InternalSymbolNameExportEquals)
			exportAssignment := exportEqualsSymbol.valueDeclaration
			err := tc.error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, tc.symbolToString(moduleSymbol), compilerOptionName)

			if exportAssignment {
				addRelatedInfo(err, createDiagnosticForNode(exportAssignment, Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName))
			}
		} else if isImportClause(node) {
			tc.reportNonDefaultExport(moduleSymbol, node)
		} else {
			tc.errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name)
		}
	} else if hasSyntheticDefault || hasDefaultOnly {
		// per emit behavior, a synthetic default overrides a "real" .default member if `__esModule` is not present
		resolved := tc.resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || tc.resolveSymbol(moduleSymbol, dontResolveAlias)
		tc.markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved /*overwriteEmpty*/, false)
		return resolved
	}
	tc.markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol /*finalTarget*/, nil /*overwriteEmpty*/, false)
	return exportDefaultSymbol
}

func (tc *TypeChecker) getModuleSpecifierForImportOrExport(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier */ any) Expression {
	switch node.kind {
	case SyntaxKindImportClause:
		return node.parent.moduleSpecifier
	case SyntaxKindImportEqualsDeclaration:
		if isExternalModuleReference(node.moduleReference) {
			return node.moduleReference.expression
		} else {
			return nil
		}
	case SyntaxKindNamespaceImport:
		return node.parent.parent.moduleSpecifier
	case SyntaxKindImportSpecifier:
		return node.parent.parent.parent.moduleSpecifier
	case SyntaxKindExportSpecifier:
		return node.parent.parent.moduleSpecifier
	default:
		return Debug.assertNever(node)
	}
}

func (tc *TypeChecker) reportNonDefaultExport(moduleSymbol Symbol, node ImportClause) {
	if moduleSymbol.exports. /* ? */ has(node.symbol.escapedName) {
		tc.error(node.name, Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, tc.symbolToString(moduleSymbol), tc.symbolToString(node.symbol))
	} else {
		diagnostic := tc.error(node.name, Diagnostics.Module_0_has_no_default_export, tc.symbolToString(moduleSymbol))
		exportStar := moduleSymbol.exports. /* ? */ get(InternalSymbolNameExportStar)
		if exportStar {
			defaultExport := exportStar.declarations. /* ? */ find(func(decl Declaration) bool {
				return !!(isExportDeclaration(decl) && decl.moduleSpecifier && tc.resolveExternalModuleName(decl, decl.moduleSpecifier). /* ? */ exports. /* ? */ has(InternalSymbolNameDefault))
			})
			if defaultExport {
				addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default))
			}
		}
	}
}

func (tc *TypeChecker) getTargetOfNamespaceImport(node NamespaceImport, dontResolveAlias bool) Symbol {
	moduleSpecifier := node.parent.parent.moduleSpecifier
	immediate := tc.resolveExternalModuleName(node, moduleSpecifier)
	resolved := tc.resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias /*suppressInteropError*/, false)
	tc.markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /*overwriteEmpty*/, false)
	return resolved
}

func (tc *TypeChecker) getTargetOfNamespaceExport(node NamespaceExport, dontResolveAlias bool) Symbol {
	moduleSpecifier := node.parent.moduleSpecifier
	immediate := moduleSpecifier && tc.resolveExternalModuleName(node, moduleSpecifier)
	resolved := moduleSpecifier && tc.resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias /*suppressInteropError*/, false)
	tc.markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved /*overwriteEmpty*/, false)
	return resolved
}

// This function creates a synthetic symbol that combines the value side of one symbol with the
// type/namespace side of another symbol. Consider this example:
//
//	declare module graphics {
//	    interface Point {
//	        x: number;
//	        y: number;
//	    }
//	}
//	declare var graphics: {
//	    Point: new (x: number, y: number) => graphics.Point;
//	}
//	declare module "graphics" {
//	    export = graphics;
//	}
//
// An 'import { Point } from "graphics"' needs to create a symbol that combines the value side 'Point'
// property with the type/namespace side interface 'Point'.
func (tc *TypeChecker) combineValueAndTypeSymbols(valueSymbol Symbol, typeSymbol Symbol) Symbol {
	if valueSymbol == tc.unknownSymbol && typeSymbol == tc.unknownSymbol {
		return tc.unknownSymbol
	}
	if valueSymbol.flags & (SymbolFlagsType | SymbolFlagsNamespace) {
		return valueSymbol
	}
	result := tc.createSymbol(valueSymbol.flags|typeSymbol.flags, valueSymbol.escapedName)
	Debug.assert(valueSymbol.declarations || typeSymbol.declarations)
	result.declarations = deduplicate(concatenate(valueSymbol.declarations, typeSymbol.declarations), equateValues)
	result.parent = valueSymbol.parent || typeSymbol.parent
	if valueSymbol.valueDeclaration {
		result.valueDeclaration = valueSymbol.valueDeclaration
	}
	if typeSymbol.members {
		result.members = NewMap(typeSymbol.members)
	}
	if valueSymbol.exports {
		result.exports = NewMap(valueSymbol.exports)
	}
	return result
}

func (tc *TypeChecker) getExportOfModule(symbol Symbol, nameText __String, specifier Declaration, dontResolveAlias bool) Symbol {
	if symbol.flags & SymbolFlagsModule {
		exportSymbol := tc.getExportsOfSymbol(symbol).get(nameText)
		resolved := tc.resolveSymbol(exportSymbol, dontResolveAlias)
		exportStarDeclaration := tc.getSymbolLinks(symbol).typeOnlyExportStarMap. /* ? */ get(nameText)
		tc.markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved /*overwriteEmpty*/, false, exportStarDeclaration, nameText)
		return resolved
	}
}

func (tc *TypeChecker) getPropertyOfVariable(symbol Symbol, name __String) Symbol {
	if symbol.flags & SymbolFlagsVariable {
		typeAnnotation := (symbol.valueDeclaration /* as VariableDeclaration */).type_
		if typeAnnotation {
			return tc.resolveSymbol(tc.getPropertyOfType(tc.getTypeFromTypeNode(typeAnnotation), name))
		}
	}
}

func (tc *TypeChecker) getExternalModuleMember(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag */ any, specifier /* TODO(TS-TO-GO) TypeNode UnionType: ImportOrExportSpecifier | BindingElement | PropertyAccessExpression */ any, dontResolveAlias bool /*  = false */) Symbol {
	moduleSpecifier := getExternalModuleRequireArgument(node) || (node /* as ImportDeclaration | ExportDeclaration | JSDocImportTag */).moduleSpecifier
	moduleSymbol := tc.resolveExternalModuleName(node, moduleSpecifier)
	// TODO: GH#18217
	name := !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name
	if !isIdentifier(name) && name.kind != SyntaxKindStringLiteral {
		return nil
	}
	nameText := moduleExportNameTextEscaped(name)
	suppressInteropError := nameText == InternalSymbolNameDefault && tc.allowSyntheticDefaultImports
	targetSymbol := tc.resolveESModuleSymbol(moduleSymbol, moduleSpecifier /*dontResolveAlias*/, false, suppressInteropError)
	if targetSymbol {
		// Note: The empty string is a valid module export name:
		//
		//   import { "" as foo } from "./foo";
		//   export { foo as "" };
		//
		if nameText || name.kind == SyntaxKindStringLiteral {
			if isShorthandAmbientModuleSymbol(moduleSymbol) {
				return moduleSymbol
			}

			var symbolFromVariable Symbol
			// First check if module was specified with "export=". If so, get the member from the resolved type
			if moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolNameExportEquals) {
				symbolFromVariable = tc.getPropertyOfType(tc.getTypeOfSymbol(targetSymbol), nameText /*skipObjectFunctionPropertyAugment*/, true)
			} else {
				symbolFromVariable = tc.getPropertyOfVariable(targetSymbol, nameText)
			}
			// if symbolFromVariable is export - get its final target
			symbolFromVariable = tc.resolveSymbol(symbolFromVariable, dontResolveAlias)

			symbolFromModule := tc.getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias)
			if symbolFromModule == nil && nameText == InternalSymbolNameDefault {
				file := moduleSymbol.declarations. /* ? */ find(isSourceFile)
				if tc.isOnlyImportableAsDefault(moduleSpecifier) || tc.canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier) {
					symbolFromModule = tc.resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || tc.resolveSymbol(moduleSymbol, dontResolveAlias)
				}
			}

			var symbol Symbol
			if symbolFromModule && symbolFromVariable && symbolFromModule != symbolFromVariable {
				symbol = tc.combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule)
			} else {
				symbol = symbolFromModule || symbolFromVariable
			}
			if !symbol {
				tc.errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name)
			}
			return symbol
		}
	}
}

func (tc *TypeChecker) errorNoModuleMemberSymbol(moduleSymbol Symbol, targetSymbol Symbol, node Node, name ModuleExportName) {
	moduleName := tc.getFullyQualifiedName(moduleSymbol, node)
	declarationName := declarationNameToString(name)
	var suggestion Symbol
	if isIdentifier(name) {
		suggestion = tc.getSuggestedSymbolForNonexistentModule(name, targetSymbol)
	} else {
		suggestion = nil
	}
	if suggestion != nil {
		suggestionName := tc.symbolToString(suggestion)
		diagnostic := tc.error(name, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName)
		if suggestion.valueDeclaration {
			addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
		}
	} else {
		if moduleSymbol.exports. /* ? */ has(InternalSymbolNameDefault) {
			tc.error(name, Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName)
		} else {
			tc.reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName)
		}
	}
}

func (tc *TypeChecker) reportNonExportedMember(node Node, name ModuleExportName, declarationName string, moduleSymbol Symbol, moduleName string) {
	localSymbol := tryCast(moduleSymbol.valueDeclaration, canHaveLocals). /* ? */ locals. /* ? */ get(moduleExportNameTextEscaped(name))
	exports := moduleSymbol.exports
	if localSymbol {
		exportedEqualsSymbol := exports. /* ? */ get(InternalSymbolNameExportEquals)
		if exportedEqualsSymbol {
			__COND__(tc.getSymbolIfSameReference(exportedEqualsSymbol, localSymbol), tc.reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName), tc.error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName))
		} else {
			var exportedSymbol Symbol
			if exports {
				exportedSymbol = find(tc.symbolsToArray(exports), func(symbol Symbol) bool {
					return !!tc.getSymbolIfSameReference(symbol, localSymbol)
				})
			} else {
				exportedSymbol = nil
			}
			var diagnostic Diagnostic
			if exportedSymbol {
				diagnostic = tc.error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, tc.symbolToString(exportedSymbol))
			} else {
				diagnostic = tc.error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName)
			}
			if localSymbol.declarations {
				addRelatedInfo(diagnostic, map_(localSymbol.declarations, func(decl Declaration, index number) DiagnosticWithLocation {
					return createDiagnosticForNode(decl, __COND__(index == 0, Diagnostics._0_is_declared_here, Diagnostics.and_here), declarationName)
				})...)
			}
		}
	} else {
		tc.error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName)
	}
}

func (tc *TypeChecker) reportInvalidImportEqualsExportMember(node Node, name ModuleExportName, declarationName string, moduleName string) {
	if tc.moduleKind >= ModuleKindES2015 {
		var message DiagnosticMessage
		if getESModuleInterop(tc.compilerOptions) {
			message = Diagnostics._0_can_only_be_imported_by_using_a_default_import
		} else {
			message = Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import
		}
		tc.error(name, message, declarationName)
	} else {
		if isInJSFile(node) {
			var message DiagnosticMessage
			if getESModuleInterop(tc.compilerOptions) {
				message = Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import
			} else {
				message = Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import
			}
			tc.error(name, message, declarationName)
		} else {
			var message DiagnosticMessage
			if getESModuleInterop(tc.compilerOptions) {
				message = Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import
			} else {
				message = Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import
			}
			tc.error(name, message, declarationName, declarationName, moduleName)
		}
	}
}

func (tc *TypeChecker) getTargetOfImportSpecifier(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportSpecifier | BindingElement */ any, dontResolveAlias bool) Symbol {
	if isImportSpecifier(node) && moduleExportNameIsDefault(node.propertyName || node.name) {
		specifier := tc.getModuleSpecifierForImportOrExport(node)
		moduleSymbol := specifier && tc.resolveExternalModuleName(node, specifier)
		if moduleSymbol {
			return tc.getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
		}
	}
	var root /* TODO(TS-TO-GO) inferred type VariableDeclaration | ImportDeclaration | JSDocImportTag */ any
	if isBindingElement(node) {
		root = getRootDeclaration(node) /* as VariableDeclaration */
	} else {
		root = node.parent.parent.parent
	}
	commonJSPropertyAccess := tc.getCommonJSPropertyAccess(root)
	resolved := tc.getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias)
	name := node.propertyName || node.name
	if commonJSPropertyAccess && resolved && isIdentifier(name) {
		return tc.resolveSymbol(tc.getPropertyOfType(tc.getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias)
	}
	tc.markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
	return resolved
}

func (tc *TypeChecker) getCommonJSPropertyAccess(node Node) *PropertyAccessExpression {
	if isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer) {
		return node.initializer
	}
}

func (tc *TypeChecker) getTargetOfNamespaceExportDeclaration(node NamespaceExportDeclaration, dontResolveAlias bool) Symbol {
	if canHaveSymbol(node.parent) {
		resolved := tc.resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias)
		tc.markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
		return resolved
	}
}

func (tc *TypeChecker) getTargetOfExportSpecifier(node ExportSpecifier, meaning SymbolFlags, dontResolveAlias bool) Symbol {
	name := node.propertyName || node.name
	if moduleExportNameIsDefault(name) {
		specifier := tc.getModuleSpecifierForImportOrExport(node)
		moduleSymbol := specifier && tc.resolveExternalModuleName(node, specifier)
		if moduleSymbol {
			return tc.getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias)
		}
	}
	var resolved Symbol
	switch {
	case node.parent.parent.moduleSpecifier:
		resolved = tc.getExternalModuleMember(node.parent.parent, node, dontResolveAlias)
	case name.kind == SyntaxKindStringLiteral:
		resolved = nil
	default:
		resolved = tc.resolveEntityName(name, meaning /*ignoreErrors*/, false, dontResolveAlias)
	}
	tc.markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
	return resolved
}

func (tc *TypeChecker) getTargetOfExportAssignment(node /* TODO(TS-TO-GO) TypeNode UnionType: ExportAssignment | BinaryExpression */ any, dontResolveAlias bool) Symbol {
	var expression Expression
	if isExportAssignment(node) {
		expression = node.expression
	} else {
		expression = node.right
	}
	resolved := tc.getTargetOfAliasLikeExpression(expression, dontResolveAlias)
	tc.markSymbolOfAliasDeclarationIfTypeOnly(node /*immediateTarget*/, nil, resolved /*overwriteEmpty*/, false)
	return resolved
}

func (tc *TypeChecker) getTargetOfAliasLikeExpression(expression Expression, dontResolveAlias bool) Symbol {
	if isClassExpression(expression) {
		return tc.checkExpressionCached(expression).symbol
	}
	if !isEntityName(expression) && !isEntityNameExpression(expression) {
		return nil
	}
	aliasLike := tc.resolveEntityName(expression, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*ignoreErrors*/, true, dontResolveAlias)
	if aliasLike {
		return aliasLike
	}
	tc.checkExpressionCached(expression)
	return tc.getNodeLinks(expression).resolvedSymbol
}

func (tc *TypeChecker) getTargetOfAccessExpression(node AccessExpression, dontRecursivelyResolve bool) Symbol {
	if !(isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken) {
		return nil
	}

	return tc.getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve)
}

func (tc *TypeChecker) getTargetOfAliasDeclaration(node Declaration, dontRecursivelyResolve bool /*  = false */) Symbol {
	switch node.kind {
	case SyntaxKindImportEqualsDeclaration,
		SyntaxKindVariableDeclaration:
		return tc.getTargetOfImportEqualsDeclaration(node /* as ImportEqualsDeclaration | VariableDeclaration */, dontRecursivelyResolve)
	case SyntaxKindImportClause:
		return tc.getTargetOfImportClause(node /* as ImportClause */, dontRecursivelyResolve)
	case SyntaxKindNamespaceImport:
		return tc.getTargetOfNamespaceImport(node /* as NamespaceImport */, dontRecursivelyResolve)
	case SyntaxKindNamespaceExport:
		return tc.getTargetOfNamespaceExport(node /* as NamespaceExport */, dontRecursivelyResolve)
	case SyntaxKindImportSpecifier,
		SyntaxKindBindingElement:
		return tc.getTargetOfImportSpecifier(node /* as ImportSpecifier | BindingElement */, dontRecursivelyResolve)
	case SyntaxKindExportSpecifier:
		return tc.getTargetOfExportSpecifier(node /* as ExportSpecifier */, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, dontRecursivelyResolve)
	case SyntaxKindExportAssignment,
		SyntaxKindBinaryExpression:
		return tc.getTargetOfExportAssignment(node /* as ExportAssignment | BinaryExpression */, dontRecursivelyResolve)
	case SyntaxKindNamespaceExportDeclaration:
		return tc.getTargetOfNamespaceExportDeclaration(node /* as NamespaceExportDeclaration */, dontRecursivelyResolve)
	case SyntaxKindShorthandPropertyAssignment:
		return tc.resolveEntityName((node /* as ShorthandPropertyAssignment */).name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*ignoreErrors*/, true, dontRecursivelyResolve)
	case SyntaxKindPropertyAssignment:
		return tc.getTargetOfAliasLikeExpression((node /* as PropertyAssignment */).initializer, dontRecursivelyResolve)
	case SyntaxKindElementAccessExpression,
		SyntaxKindPropertyAccessExpression:
		return tc.getTargetOfAccessExpression(node /* as AccessExpression */, dontRecursivelyResolve)
	default:
		return Debug.fail()
	}
}

/**
 * Indicates that a symbol is an alias that does not merge with a local declaration.
 * OR Is a JSContainer which may merge an alias with a local declaration
 */

func (tc *TypeChecker) isNonLocalAlias(symbol Symbol, excludes number /*  = SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */) /* TODO(TS-TO-GO) TypeNode TypePredicate: symbol is Symbol */ any {
	if !symbol {
		return false
	}
	return (symbol.flags&(SymbolFlagsAlias|excludes)) == SymbolFlagsAlias || !!(symbol.flags&SymbolFlagsAlias && symbol.flags&SymbolFlagsAssignment)
}

/* OVERLOAD: function resolveSymbol(symbol: Symbol, dontResolveAlias?: boolean): Symbol; */
/* OVERLOAD: function resolveSymbol(symbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined; */
func (tc *TypeChecker) resolveSymbol(symbol Symbol, dontResolveAlias bool) Symbol {
	if !dontResolveAlias && tc.isNonLocalAlias(symbol) {
		return tc.resolveAlias(symbol)
	} else {
		return symbol
	}
}

func (tc *TypeChecker) resolveAlias(symbol Symbol) Symbol {
	Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
	links := tc.getSymbolLinks(symbol)
	if !links.aliasTarget {
		links.aliasTarget = tc.resolvingSymbol
		node := tc.getDeclarationOfAliasSymbol(symbol)
		if !node {
			return Debug.fail()
		}
		target := tc.getTargetOfAliasDeclaration(node)
		if links.aliasTarget == tc.resolvingSymbol {
			links.aliasTarget = target || tc.unknownSymbol
		} else {
			tc.error(node, Diagnostics.Circular_definition_of_import_alias_0, tc.symbolToString(symbol))
		}
	} else if links.aliasTarget == tc.resolvingSymbol {
		links.aliasTarget = tc.unknownSymbol
	}
	return links.aliasTarget
}

func (tc *TypeChecker) tryResolveAlias(symbol Symbol) Symbol {
	links := tc.getSymbolLinks(symbol)
	if links.aliasTarget != tc.resolvingSymbol {
		return tc.resolveAlias(symbol)
	}

	return nil
}

/**
 * Gets combined flags of a `symbol` and all alias targets it resolves to. `resolveAlias`
 * is typically recursive over chains of aliases, but stops mid-chain if an alias is merged
 * with another exported symbol, e.g.
 * ```ts
 * // a.ts
 * export const a = 0;
 * // b.ts
 * export { a } from "./a";
 * export type a = number;
 * // c.ts
 * import { a } from "./b";
 * ```
 * Calling `resolveAlias` on the `a` in c.ts would stop at the merged symbol exported
 * from b.ts, even though there is still more alias to resolve. Consequently, if we were
 * trying to determine if the `a` in c.ts has a value meaning, looking at the flags on
 * the local symbol and on the symbol returned by `resolveAlias` is not enough.
 * @returns SymbolFlags.All if `symbol` is an alias that ultimately resolves to `unknown`;
 * combined flags of all alias targets otherwise.
 */

func (tc *TypeChecker) getSymbolFlags(symbol Symbol, excludeTypeOnlyMeanings bool, excludeLocalMeanings bool) SymbolFlags {
	typeOnlyDeclaration := excludeTypeOnlyMeanings && tc.getTypeOnlyAliasDeclaration(symbol)
	typeOnlyDeclarationIsExportStar := typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration)
	typeOnlyResolution := typeOnlyDeclaration && (__COND__(typeOnlyDeclarationIsExportStar, tc.resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier /*ignoreErrors*/, true), tc.resolveAlias(typeOnlyDeclaration.symbol)))
	var typeOnlyExportStarTargets *SymbolTable
	if typeOnlyDeclarationIsExportStar && typeOnlyResolution {
		typeOnlyExportStarTargets = tc.getExportsOfModule(typeOnlyResolution)
	} else {
		typeOnlyExportStarTargets = nil
	}
	var flags SymbolFlags
	if excludeLocalMeanings {
		flags = SymbolFlagsNone
	} else {
		flags = symbol.flags
	}
	var seenSymbols TODO
	for symbol.flags & SymbolFlagsAlias {
		target := tc.getExportSymbolOfValueSymbolIfExported(tc.resolveAlias(symbol))
		if !typeOnlyDeclarationIsExportStar && target == typeOnlyResolution || typeOnlyExportStarTargets. /* ? */ get(target.escapedName) == target {
			break
		}
		if target == tc.unknownSymbol {
			return SymbolFlagsAll
		}

		// Optimizations - try to avoid creating or adding to
		// `seenSymbols` if possible
		if target == symbol || seenSymbols. /* ? */ has(target) {
			break
		}
		if target.flags & SymbolFlagsAlias {
			if seenSymbols {
				seenSymbols.add(target)
			} else {
				seenSymbols = NewSet([]Symbol{symbol, target})
			}
		}
		flags |= target.flags
		symbol = target
	}
	return flags
}

/**
 * Marks a symbol as type-only if its declaration is syntactically type-only.
 * If it is not itself marked type-only, but resolves to a type-only alias
 * somewhere in its resolution chain, save a reference to the type-only alias declaration
 * so the alias _not_ marked type-only can be identified as _transitively_ type-only.
 *
 * This function is called on each alias declaration that could be type-only or resolve to
 * another type-only alias during `resolveAlias`, so that later, when an alias is used in a
 * JS-emitting expression, we can quickly determine if that symbol is effectively type-only
 * and issue an error if so.
 *
 * @param aliasDeclaration The alias declaration not marked as type-only
 * @param immediateTarget The symbol to which the alias declaration immediately resolves
 * @param finalTarget The symbol to which the alias declaration ultimately resolves
 * @param overwriteEmpty Checks `resolvesToSymbol` for type-only declarations even if `aliasDeclaration`
 * has already been marked as not resolving to a type-only alias. Used when recursively resolving qualified
 * names of import aliases, e.g. `import C = a.b.C`. If namespace `a` is not found to be type-only, the
 * import declaration will initially be marked as not resolving to a type-only symbol. But, namespace `b`
 * must still be checked for a type-only marker, overwriting the previous negative result if found.
 */

func (tc *TypeChecker) markSymbolOfAliasDeclarationIfTypeOnly(aliasDeclaration Declaration, immediateTarget Symbol, finalTarget Symbol, overwriteEmpty bool, exportStarDeclaration /* TODO(TS-TO-GO) TypeNode IntersectionType: ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ any, exportStarName __String) bool {
	if !aliasDeclaration || isPropertyAccessExpression(aliasDeclaration) {
		return false
	}

	// If the declaration itself is type-only, mark it and return.
	// No need to check what it resolves to.
	sourceSymbol := tc.getSymbolOfDeclaration(aliasDeclaration)
	if isTypeOnlyImportOrExportDeclaration(aliasDeclaration) {
		links := tc.getSymbolLinks(sourceSymbol)
		links.typeOnlyDeclaration = aliasDeclaration
		return true
	}
	if exportStarDeclaration {
		links := tc.getSymbolLinks(sourceSymbol)
		links.typeOnlyDeclaration = exportStarDeclaration
		if sourceSymbol.escapedName != exportStarName {
			links.typeOnlyExportStarName = exportStarName
		}
		return true
	}

	links := tc.getSymbolLinks(sourceSymbol)
	return tc.markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty) || tc.markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty)
}

func (tc *TypeChecker) markSymbolOfAliasDeclarationIfTypeOnlyWorker(aliasDeclarationLinks SymbolLinks, target Symbol, overwriteEmpty bool) bool {
	if target && (aliasDeclarationLinks.typeOnlyDeclaration == nil || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration == false) {
		exportSymbol := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: target.exports?.get(InternalSymbolName.ExportEquals) ?? target */ TODO
		typeOnly := exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration)
		aliasDeclarationLinks.typeOnlyDeclaration = /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false */ TODO
	}
	return !!aliasDeclarationLinks.typeOnlyDeclaration
}

/** Indicates that a symbol directly or indirectly resolves to a type-only import or export. */

func (tc *TypeChecker) getTypeOnlyAliasDeclaration(symbol Symbol, include SymbolFlags) *TypeOnlyAliasDeclaration {
	if !(symbol.flags & SymbolFlagsAlias) {
		return nil
	}
	links := tc.getSymbolLinks(symbol)
	if links.typeOnlyDeclaration == nil {
		// We need to set a WIP value here to prevent reentrancy during `getImmediateAliasedSymbol` which, paradoxically, can depend on this
		links.typeOnlyDeclaration = false
		resolved := tc.resolveSymbol(symbol)
		// While usually the alias will have been marked during the pass by the full typecheck, we may still need to calculate the alias declaration now
		tc.markSymbolOfAliasDeclarationIfTypeOnly(symbol.declarations[0], tc.getDeclarationOfAliasSymbol(symbol) && tc.getImmediateAliasedSymbol(symbol), resolved /*overwriteEmpty*/, true)
	}
	if include == nil {
		return links.typeOnlyDeclaration || nil
	}
	if links.typeOnlyDeclaration {
		var resolved Symbol
		if links.typeOnlyDeclaration.kind == SyntaxKindExportDeclaration {
			resolved = tc.resolveSymbol(tc.getExportsOfModule(links.typeOnlyDeclaration.symbol.parent).get(links.typeOnlyExportStarName || symbol.escapedName))
		} else {
			resolved = tc.resolveAlias(links.typeOnlyDeclaration.symbol)
		}
		if tc.getSymbolFlags(resolved) & include {
			return links.typeOnlyDeclaration
		} else {
			return nil
		}
	}
	return nil
}

// This function is only for imports with entity names
func (tc *TypeChecker) getSymbolOfPartOfRightHandSideOfImportEquals(entityName EntityName, dontResolveAlias bool) Symbol {
	// There are three things we might try to look for. In the following examples,
	// the search term is enclosed in |...|:
	//
	//     import a = |b|; // Namespace
	//     import a = |b.c|; // Value, type, namespace
	//     import a = |b.c|.d; // Namespace
	if entityName.kind == SyntaxKindIdentifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName) {
		entityName = entityName.parent /* as QualifiedName */
	}
	// Check for case 1 and 3 in the above example
	if entityName.kind == SyntaxKindIdentifier || entityName.parent.kind == SyntaxKindQualifiedName {
		return tc.resolveEntityName(entityName, SymbolFlagsNamespace /*ignoreErrors*/, false, dontResolveAlias)
	} else {
		// Case 2 in above example
		// entityName.kind could be a QualifiedName or a Missing identifier
		Debug.assert(entityName.parent.kind == SyntaxKindImportEqualsDeclaration)
		return tc.resolveEntityName(entityName, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*ignoreErrors*/, false, dontResolveAlias)
	}
}

func (tc *TypeChecker) getFullyQualifiedName(symbol Symbol, containingLocation Node) string {
	if symbol.parent {
		return tc.getFullyQualifiedName(symbol.parent, containingLocation) + "." + tc.symbolToString(symbol)
	} else {
		return tc.symbolToString(symbol, containingLocation /*meaning*/, nil, SymbolFormatFlagsDoNotIncludeSymbolChain|SymbolFormatFlagsAllowAnyNodeKind)
	}
}

func (tc *TypeChecker) getContainingQualifiedNameNode(node QualifiedName) QualifiedName {
	for isQualifiedName(node.parent) {
		node = node.parent
	}
	return node
}

func (tc *TypeChecker) tryGetQualifiedNameAsValue(node QualifiedName) Symbol {
	var left /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | QualifiedName */ any = getFirstIdentifier(node)
	symbol := tc.resolveName(left, left, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
	if !symbol {
		return nil
	}
	for isQualifiedName(left.parent) {
		type_ := tc.getTypeOfSymbol(symbol)
		symbol = tc.getPropertyOfType(type_, left.parent.right.escapedText)
		if !symbol {
			return nil
		}
		left = left.parent
	}
	return symbol
}

/**
 * Resolves a qualified name and any involved aliases.
 */

func (tc *TypeChecker) resolveEntityName(name EntityNameOrEntityNameExpression, meaning SymbolFlags, ignoreErrors bool, dontResolveAlias bool, location Node) Symbol {
	if nodeIsMissing(name) {
		return nil
	}

	namespaceMeaning := SymbolFlagsNamespace | (__COND__(isInJSFile(name), meaning&SymbolFlagsValue, 0))
	var symbol Symbol
	if name.kind == SyntaxKindIdentifier {
		var message DiagnosticMessage
		if meaning == namespaceMeaning || nodeIsSynthesized(name) {
			message = Diagnostics.Cannot_find_namespace_0
		} else {
			message = tc.getCannotFindNameDiagnosticForName(getFirstIdentifier(name))
		}
		var symbolFromJSPrototype Symbol
		if isInJSFile(name) && !nodeIsSynthesized(name) {
			symbolFromJSPrototype = tc.resolveEntityNameFromAssignmentDeclaration(name, meaning)
		} else {
			symbolFromJSPrototype = nil
		}
		symbol = tc.getMergedSymbol(tc.resolveName(location || name, name, meaning, __COND__(ignoreErrors || symbolFromJSPrototype, nil, message) /*isUse*/, true /*excludeGlobals*/, false))
		if !symbol {
			return tc.getMergedSymbol(symbolFromJSPrototype)
		}
	} else if name.kind == SyntaxKindQualifiedName || name.kind == SyntaxKindPropertyAccessExpression {
		var left /* TODO(TS-TO-GO) inferred type Identifier | QualifiedName | PropertyAccessEntityNameExpression */ any
		if name.kind == SyntaxKindQualifiedName {
			left = name.left
		} else {
			left = name.expression
		}
		var right Identifier
		if name.kind == SyntaxKindQualifiedName {
			right = name.right
		} else {
			right = name.name
		}
		namespace := tc.resolveEntityName(left, namespaceMeaning, ignoreErrors /*dontResolveAlias*/, false, location)
		if !namespace || nodeIsMissing(right) {
			return nil
		} else if namespace == tc.unknownSymbol {
			return namespace
		}
		if namespace.valueDeclaration && isInJSFile(namespace.valueDeclaration) && getEmitModuleResolutionKind(tc.compilerOptions) != ModuleResolutionKindBundler && isVariableDeclaration(namespace.valueDeclaration) && namespace.valueDeclaration.initializer && tc.isCommonJsRequire(namespace.valueDeclaration.initializer) {
			moduleName := (namespace.valueDeclaration.initializer /* as CallExpression */).arguments[0] /* as StringLiteral */
			moduleSym := tc.resolveExternalModuleName(moduleName, moduleName)
			if moduleSym {
				resolvedModuleSymbol := tc.resolveExternalModuleSymbol(moduleSym)
				if resolvedModuleSymbol {
					namespace = resolvedModuleSymbol
				}
			}
		}
		symbol = tc.getMergedSymbol(tc.getSymbol(tc.getExportsOfSymbol(namespace), right.escapedText, meaning))
		if !symbol && (namespace.flags & SymbolFlagsAlias) {
			// `namespace` can be resolved further if there was a symbol merge with a re-export
			symbol = tc.getMergedSymbol(tc.getSymbol(tc.getExportsOfSymbol(tc.resolveAlias(namespace)), right.escapedText, meaning))
		}
		if !symbol {
			if !ignoreErrors {
				namespaceName := tc.getFullyQualifiedName(namespace)
				declarationName := declarationNameToString(right)
				suggestionForNonexistentModule := tc.getSuggestedSymbolForNonexistentModule(right, namespace)
				if suggestionForNonexistentModule {
					tc.error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, tc.symbolToString(suggestionForNonexistentModule))
					return nil
				}

				containingQualifiedName := isQualifiedName(name) && tc.getContainingQualifiedNameNode(name)
				canSuggestTypeof := tc.globalObjectType && (meaning & SymbolFlagsType) && containingQualifiedName && !isTypeOfExpression(containingQualifiedName.parent) && tc.tryGetQualifiedNameAsValue(containingQualifiedName)
				if canSuggestTypeof {
					tc.error(containingQualifiedName, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, entityNameToString(containingQualifiedName))
					return nil
				}

				if meaning&SymbolFlagsNamespace && isQualifiedName(name.parent) {
					exportedTypeSymbol := tc.getMergedSymbol(tc.getSymbol(tc.getExportsOfSymbol(namespace), right.escapedText, SymbolFlagsType))
					if exportedTypeSymbol {
						tc.error(name.parent.right, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, tc.symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores(name.parent.right.escapedText))
						return nil
					}
				}

				tc.error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName)
			}
			return nil
		}
	} else {
		Debug.assertNever(name, "Unknown entity name kind.")
	}
	if !nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags&SymbolFlagsAlias || name.parent.kind == SyntaxKindExportAssignment) {
		tc.markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol /*finalTarget*/, nil /*overwriteEmpty*/, true)
	}
	if (symbol.flags & meaning) || dontResolveAlias {
		return symbol
	} else {
		return tc.resolveAlias(symbol)
	}
}

/**
 * 1. For prototype-property methods like `A.prototype.m = function () ...`, try to resolve names in the scope of `A` too.
 * Note that prototype-property assignment to locations outside the current file (eg globals) doesn't work, so
 * name resolution won't work either.
 * 2. For property assignments like `{ x: function f () { } }`, try to resolve names in the scope of `f` too.
 */

func (tc *TypeChecker) resolveEntityNameFromAssignmentDeclaration(name Identifier, meaning SymbolFlags) Symbol {
	if tc.isJSDocTypeReference(name.parent) {
		secondaryLocation := tc.getAssignmentDeclarationLocation(name.parent)
		if secondaryLocation {
			return tc.resolveName(secondaryLocation, name, meaning /*nameNotFoundMessage*/, nil /*isUse*/, true)
		}
	}
}

func (tc *TypeChecker) getAssignmentDeclarationLocation(node TypeReferenceNode) Node {
	typeAlias := findAncestor(node, func(node Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if !(isJSDocNode(node) || node.flags&NodeFlagsJSDoc) {
			return "quit"
		} else {
			return isJSDocTypeAlias(node)
		}
	})
	if typeAlias {
		return
	}
	host := getJSDocHost(node)
	if host && isExpressionStatement(host) && isPrototypePropertyAssignment(host.expression) {
		// /** @param {K} p */ X.prototype.m = function () { } <-- look for K on X's declaration
		symbol := tc.getSymbolOfDeclaration(host.expression.left)
		if symbol {
			return tc.getDeclarationOfJSPrototypeContainer(symbol)
		}
	}
	if host && isFunctionExpression(host) && isPrototypePropertyAssignment(host.parent) && isExpressionStatement(host.parent.parent) {
		// X.prototype.m = /** @param {K} p */ function () { } <-- look for K on X's declaration
		symbol := tc.getSymbolOfDeclaration(host.parent.left)
		if symbol {
			return tc.getDeclarationOfJSPrototypeContainer(symbol)
		}
	}
	if host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) && isBinaryExpression(host.parent.parent) && getAssignmentDeclarationKind(host.parent.parent) == AssignmentDeclarationKindPrototype {
		// X.prototype = { /** @param {K} p */m() { } } <-- look for K on X's declaration
		symbol := tc.getSymbolOfDeclaration(host.parent.parent.left /* as BindableStaticNameExpression */)
		if symbol {
			return tc.getDeclarationOfJSPrototypeContainer(symbol)
		}
	}
	sig := getEffectiveJSDocHost(node)
	if sig && isFunctionLike(sig) {
		symbol := tc.getSymbolOfDeclaration(sig)
		return symbol && symbol.valueDeclaration
	}
}

func (tc *TypeChecker) getDeclarationOfJSPrototypeContainer(symbol Symbol) * /* TODO(TS-TO-GO) inferred type Declaration | Expression */ any {
	decl := symbol.parent.valueDeclaration
	if !decl {
		return nil
	}
	var initializer Expression
	switch {
	case isAssignmentDeclaration(decl):
		initializer = getAssignedExpandoInitializer(decl)
	case hasOnlyExpressionInitializer(decl):
		initializer = getDeclaredExpandoInitializer(decl)
	default:
		initializer = nil
	}
	return initializer || decl
}

/**
 * Get the real symbol of a declaration with an expando initializer.
 *
 * Normally, declarations have an associated symbol, but when a declaration has an expando
 * initializer, the expando's symbol is the one that has all the members merged into it.
 */

func (tc *TypeChecker) getExpandoSymbol(symbol Symbol) Symbol {
	decl := symbol.valueDeclaration
	if !decl || !isInJSFile(decl) || symbol.flags&SymbolFlagsTypeAlias || getExpandoInitializer(decl /*isPrototypeAssignment*/, false) {
		return nil
	}
	var init Expression
	if isVariableDeclaration(decl) {
		init = getDeclaredExpandoInitializer(decl)
	} else {
		init = getAssignedExpandoInitializer(decl)
	}
	if init {
		initSymbol := tc.getSymbolOfNode(init)
		if initSymbol {
			return tc.mergeJSSymbols(initSymbol, symbol)
		}
	}
}

func (tc *TypeChecker) resolveExternalModuleName(location Node, moduleReferenceExpression Expression, ignoreErrors bool) Symbol {
	isClassic := getEmitModuleResolutionKind(tc.compilerOptions) == ModuleResolutionKindClassic
	var errorMessage DiagnosticMessage
	if isClassic {
		errorMessage = Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option
	} else {
		errorMessage = Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations
	}
	return tc.resolveExternalModuleNameWorker(location, moduleReferenceExpression, __COND__(ignoreErrors, nil, errorMessage), ignoreErrors)
}

func (tc *TypeChecker) resolveExternalModuleNameWorker(location Node, moduleReferenceExpression Expression, moduleNotFoundError *DiagnosticMessage, ignoreErrors bool /*  = false */, isForAugmentation bool /*  = false */) Symbol {
	if isStringLiteralLike(moduleReferenceExpression) {
		return tc.resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, __COND__(!ignoreErrors, moduleReferenceExpression, nil), isForAugmentation)
	} else {
		return nil
	}
}

func (tc *TypeChecker) resolveExternalModule(location Node, moduleReference string, moduleNotFoundError *DiagnosticMessage, errorNode Node, isForAugmentation bool /*  = false */) Symbol {
	if errorNode && startsWith(moduleReference, "@types/") {
		diag := Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1
		withoutAtTypePrefix := removePrefix(moduleReference, "@types/")
		tc.error(errorNode, diag, withoutAtTypePrefix, moduleReference)
	}

	ambientModule := tc.tryFindAmbientModule(moduleReference /*withAugmentations*/, true)
	if ambientModule {
		return ambientModule
	}
	currentSourceFile := getSourceFileOfNode(location)
	var contextSpecifier Expression
	if isStringLiteralLike(location) {
		contextSpecifier = location
	} else {
		contextSpecifier = (__COND__(isModuleDeclaration(location), location, __COND__(location.parent && isModuleDeclaration(location.parent) && location.parent.name == location, location.parent, nil))). /* ? */ name || (__COND__(isLiteralImportTypeNode(location), location, nil)). /* ? */ argument.literal || (__COND__(isInJSFile(location) && isJSDocImportTag(location), location.moduleSpecifier, nil)) || (__COND__(isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer /*requireStringLiteralLikeArgument*/, true), location.initializer.arguments[0], nil)) || findAncestor(location, isImportCall). /* ? */ arguments[0] || findAncestor(location, isImportDeclaration). /* ? */ moduleSpecifier || findAncestor(location, isExternalModuleImportEqualsDeclaration). /* ? */ moduleReference.expression || findAncestor(location, isExportDeclaration). /* ? */ moduleSpecifier
	}
	var mode ResolutionMode
	if contextSpecifier && isStringLiteralLike(contextSpecifier) {
		mode = host.getModeForUsageLocation(currentSourceFile, contextSpecifier)
	} else {
		mode = host.getDefaultResolutionModeForFile(currentSourceFile)
	}
	moduleResolutionKind := getEmitModuleResolutionKind(tc.compilerOptions)
	resolvedModule := host.getResolvedModule(currentSourceFile, moduleReference, mode). /* ? */ resolvedModule
	resolutionDiagnostic := errorNode && resolvedModule && getResolutionDiagnostic(tc.compilerOptions, resolvedModule, currentSourceFile)
	sourceFile := resolvedModule && (!resolutionDiagnostic || resolutionDiagnostic == Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set) && host.getSourceFile(resolvedModule.resolvedFileName)
	if sourceFile {
		// If there's a resolutionDiagnostic we need to report it even if a sourceFile is found.
		if resolutionDiagnostic {
			tc.error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
		}

		if resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference) {
			importOrExport := findAncestor(location, isImportDeclaration). /* ? */ importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
			if errorNode && importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall) {
				tc.error(errorNode, Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead, getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))))
			}
		} else if resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(tc.compilerOptions, currentSourceFile.fileName) {
			importOrExport := findAncestor(location, isImportDeclaration). /* ? */ importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
			if errorNode && !(importOrExport. /* ? */ isTypeOnly || findAncestor(location, isImportTypeNode)) {
				tsExtension := Debug.checkDefined(tryExtractTSExtension(moduleReference))
				tc.error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension)
			}
		}

		if sourceFile.symbol {
			if errorNode && resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension) {
				tc.errorOnImplicitAnyModule(false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
			}
			if errorNode && (moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext) {
				isSyncImport := (currentSourceFile.impliedNodeFormat == ModuleKindCommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration)
				overrideHost := findAncestor(location, func(l Node) bool {
					return isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) || isJSDocImportTag(l)
				})
				// An override clause will take effect for type-only imports and import types, and allows importing the types across formats, regardless of
				// normal mode restrictions
				if isSyncImport && sourceFile.impliedNodeFormat == ModuleKindESNext && !hasResolutionModeOverride(overrideHost) {
					if findAncestor(location, isImportEqualsDeclaration) {
						// ImportEquals in a ESM file resolving to another ESM file
						tc.error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference)
					} else {
						// CJS file resolving to an ESM file
						var diagnosticDetails TODO
						ext := tryGetExtensionFromPath(currentSourceFile.fileName)
						if ext == ExtensionTs || ext == ExtensionJs || ext == ExtensionTsx || ext == ExtensionJsx {
							diagnosticDetails = createModeMismatchDetails(currentSourceFile)
						}

						var message DiagnosticMessage
						switch {
						case overrideHost. /* ? */ kind == SyntaxKindImportDeclaration && overrideHost.importClause. /* ? */ isTypeOnly:
							message = Diagnostics.Type_only_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute
						case overrideHost. /* ? */ kind == SyntaxKindImportType:
							message = Diagnostics.Type_import_of_an_ECMAScript_module_from_a_CommonJS_module_must_have_a_resolution_mode_attribute
						default:
							message = Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead
						}
						tc.diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chainDiagnosticMessages(diagnosticDetails, message, moduleReference)))
					}
				}
			}
			// merged symbol is module declaration symbol combined with all augmentations
			return tc.getMergedSymbol(sourceFile.symbol)
		}
		if errorNode && moduleNotFoundError && !isSideEffectImport(errorNode) {
			// report errors only if it was requested
			tc.error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName)
		}
		return nil
	}

	if tc.patternAmbientModules {
		pattern := findBestPatternMatch(tc.patternAmbientModules, func(_ PatternAmbientModule) Pattern {
			return _.pattern
		}, moduleReference)
		if pattern {
			// If the module reference matched a pattern ambient module ('*.foo') but there's also a
			// module augmentation by the specific name requested ('a.foo'), we store the merged symbol
			// by the augmentation name ('a.foo'), because asking for *.foo should not give you exports
			// from a.foo.
			augmentation := tc.patternAmbientModuleAugmentations && tc.patternAmbientModuleAugmentations.get(moduleReference)
			if augmentation {
				return tc.getMergedSymbol(augmentation)
			}
			return tc.getMergedSymbol(pattern.symbol)
		}
	}

	if !errorNode {
		return nil
	}

	// May be an untyped module. If so, ignore resolutionDiagnostic.
	if resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic == nil || resolutionDiagnostic == Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type {
		if isForAugmentation {
			diag := Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented
			tc.error(errorNode, diag, moduleReference, resolvedModule.resolvedFileName)
		} else {
			tc.errorOnImplicitAnyModule(tc.noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
		}
		// Failed imports and untyped modules are both treated in an untyped manner; only difference is whether we give a diagnostic first.
		return nil
	}

	if moduleNotFoundError {
		// See if this was possibly a projectReference redirect
		if resolvedModule {
			redirect := host.getProjectReferenceRedirect(resolvedModule.resolvedFileName)
			if redirect {
				tc.error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName)
				return nil
			}
		}

		if resolutionDiagnostic {
			tc.error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
		} else {
			isExtensionlessRelativePathImport := pathIsRelative(moduleReference) && !hasExtension(moduleReference)
			resolutionIsNode16OrNext := moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext
			if !getResolveJsonModule(tc.compilerOptions) && fileExtensionIs(moduleReference, ExtensionJson) && moduleResolutionKind != ModuleResolutionKindClassic && hasJsonModuleEmitEnabled(tc.compilerOptions) {
				tc.error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference)
			} else if mode == ModuleKindESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport {
				absoluteRef := getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path))
				suggestedExt := tc.suggestedExtensions.find(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [string, string] */ any) bool {
					return host.fileExists(absoluteRef + actualExt)
				})[1]
				if suggestedExt {
					tc.error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference+suggestedExt)
				} else {
					tc.error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path)
				}
			} else {
				if host.getResolvedModule(currentSourceFile, moduleReference, mode). /* ? */ alternateResult {
					errorInfo := createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference)
					tc.errorOrSuggestion(true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference))
				} else {
					tc.error(errorNode, moduleNotFoundError, moduleReference)
				}
			}
		}
	}
	return nil

	getSuggestedImportSource := func(tsExtension string) string {
		importSourceWithoutExtension := removeExtension(moduleReference, tsExtension)
		/**
		 * Direct users to import source with .js extension if outputting an ES module.
		 * @see https://github.com/microsoft/TypeScript/issues/42151
		 */

		if emitModuleKindIsNonNodeESM(tc.moduleKind) || mode == ModuleKindESNext {
			preferTs := isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(tc.compilerOptions)
			var ext /* TODO(TS-TO-GO) inferred type ".mts" | ".mjs" | ".ts" | ".js" | ".cts" | ".cjs" */ any
			switch {
			case tsExtension == ExtensionMts || tsExtension == ExtensionDmts:
				if preferTs {
					ext = ".mts"
				} else {
					ext = ".mjs"
				}
			case tsExtension == ExtensionCts || tsExtension == ExtensionDmts:
				if preferTs {
					ext = ".cts"
				} else {
					ext = ".cjs"
				}
			case preferTs:
				ext = ".ts"
			default:
				ext = ".js"
			}
			return importSourceWithoutExtension + ext
		}
		return importSourceWithoutExtension
	}

}

func (tc *TypeChecker) errorOnImplicitAnyModule(isError bool, errorNode Node, sourceFile SourceFile, mode ResolutionMode, TODO_IDENTIFIER ResolvedModuleFull, moduleReference string) {
	if isSideEffectImport(errorNode) {
		return
	}

	var errorInfo *DiagnosticMessageChain
	if !isExternalModuleNameRelative(moduleReference) && packageId {
		errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name)
	}
	tc.errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo, Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName))
}

/* OVERLOAD: function resolveExternalModuleSymbol(moduleSymbol: Symbol, dontResolveAlias?: boolean): Symbol; */
/* OVERLOAD: function resolveExternalModuleSymbol(moduleSymbol: Symbol | undefined, dontResolveAlias?: boolean): Symbol | undefined; */
func (tc *TypeChecker) resolveExternalModuleSymbol(moduleSymbol Symbol, dontResolveAlias bool) Symbol {
	if moduleSymbol. /* ? */ exports {
		exportEquals := tc.resolveSymbol(moduleSymbol.exports.get(InternalSymbolNameExportEquals), dontResolveAlias)
		exported := tc.getCommonJsExportEquals(tc.getMergedSymbol(exportEquals), tc.getMergedSymbol(moduleSymbol))
		return tc.getMergedSymbol(exported) || moduleSymbol
	}
	return nil
}

func (tc *TypeChecker) getCommonJsExportEquals(exported Symbol, moduleSymbol Symbol) Symbol {
	if !exported || exported == tc.unknownSymbol || exported == moduleSymbol || moduleSymbol.exports.size == 1 || exported.flags&SymbolFlagsAlias {
		return exported
	}
	links := tc.getSymbolLinks(exported)
	if links.cjsExportMerged {
		return links.cjsExportMerged
	}
	var merged Symbol
	if exported.flags & SymbolFlagsTransient {
		merged = exported
	} else {
		merged = tc.cloneSymbol(exported)
	}
	merged.flags = merged.flags | SymbolFlagsValueModule
	if merged.exports == nil {
		merged.exports = createSymbolTable()
	}
	moduleSymbol.exports.forEach(func(s Symbol, name __String) {
		if name == InternalSymbolNameExportEquals {
			return
		}
		merged.exports.set(name, __COND__(merged.exports.has(name), tc.mergeSymbol(merged.exports.get(name), s), s))
	})
	if merged == exported {
		// We just mutated a symbol, reset any cached links we may have already set
		// (Notably required to make late bound members appear)
		tc.getSymbolLinks(merged).resolvedExports = nil
		tc.getSymbolLinks(merged).resolvedMembers = nil
	}
	tc.getSymbolLinks(merged).cjsExportMerged = merged
	links.cjsExportMerged = merged
	return links.cjsExportMerged
}

// An external module with an 'export =' declaration may be referenced as an ES6 module provided the 'export ='
// references a symbol that is at least declared as a module or a variable. The target of the 'export =' may
// combine other declarations with the module or variable (e.g. a class/module, function/module, interface/variable).
func (tc *TypeChecker) resolveESModuleSymbol(moduleSymbol Symbol, referencingLocation Node, dontResolveAlias bool, suppressInteropError bool) Symbol {
	symbol := tc.resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias)

	if !dontResolveAlias && symbol {
		if !suppressInteropError && !(symbol.flags & (SymbolFlagsModule | SymbolFlagsVariable)) && !getDeclarationOfKind(symbol, SyntaxKindSourceFile) {
			var compilerOptionName /* TODO(TS-TO-GO) inferred type "allowSyntheticDefaultImports" | "esModuleInterop" */ any
			if tc.moduleKind >= ModuleKindES2015 {
				compilerOptionName = "allowSyntheticDefaultImports"
			} else {
				compilerOptionName = "esModuleInterop"
			}

			tc.error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName)

			return symbol
		}

		referenceParent := referencingLocation.parent
		if (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent)) || isImportCall(referenceParent) {
			var reference Expression
			if isImportCall(referenceParent) {
				reference = referenceParent.arguments[0]
			} else {
				reference = referenceParent.moduleSpecifier
			}
			type_ := tc.getTypeOfSymbol(symbol)
			defaultOnlyType := tc.getTypeWithSyntheticDefaultOnly(type_, symbol, moduleSymbol, reference)
			if defaultOnlyType {
				return tc.cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent)
			}

			targetFile := moduleSymbol. /* ? */ declarations. /* ? */ find(isSourceFile)
			isEsmCjsRef := targetFile && tc.isESMFormatImportImportingCommonjsFormatFile(tc.getEmitSyntaxForModuleSpecifierExpression(reference), host.getImpliedNodeFormatForEmit(targetFile))
			if getESModuleInterop(tc.compilerOptions) || isEsmCjsRef {
				sigs := tc.getSignaturesOfStructuredType(type_, SignatureKindCall)
				if !sigs || !sigs.length {
					sigs = tc.getSignaturesOfStructuredType(type_, SignatureKindConstruct)
				}
				if (sigs && sigs.length) || tc.getPropertyOfType(type_, InternalSymbolNameDefault /*skipObjectFunctionPropertyAugment*/, true) || isEsmCjsRef {
					var moduleType Type
					if type_.flags & TypeFlagsStructuredType {
						moduleType = tc.getTypeWithSyntheticDefaultImportType(type_, symbol, moduleSymbol, reference)
					} else {
						moduleType = tc.createDefaultPropertyWrapperForModule(symbol, symbol.parent)
					}
					return tc.cloneTypeAsModuleType(symbol, moduleType, referenceParent)
				}
			}
		}
	}
	return symbol
}

/**
 * Create a new symbol which has the module's type less the call and construct signatures
 */

func (tc *TypeChecker) cloneTypeAsModuleType(symbol Symbol, moduleType Type, referenceParent /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ImportCall */ any) TransientSymbol {
	result := tc.createSymbol(symbol.flags, symbol.escapedName)
	if symbol.declarations {
		result.declarations = symbol.declarations.slice()
	} else {
		result.declarations = []never{}
	}
	result.parent = symbol.parent
	result.links.target = symbol
	result.links.originatingImport = referenceParent
	if symbol.valueDeclaration {
		result.valueDeclaration = symbol.valueDeclaration
	}
	if symbol.constEnumOnlyModule {
		result.constEnumOnlyModule = true
	}
	if symbol.members {
		result.members = NewMap(symbol.members)
	}
	if symbol.exports {
		result.exports = NewMap(symbol.exports)
	}
	resolvedModuleType := tc.resolveStructuredTypeMembers(moduleType /* as StructuredType */)
	// Should already be resolved from the signature checks above
	result.links.type_ = tc.createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos)
	return result
}

func (tc *TypeChecker) hasExportAssignmentSymbol(moduleSymbol Symbol) bool {
	return moduleSymbol.exports.get(InternalSymbolNameExportEquals) != nil
}

func (tc *TypeChecker) getExportsOfModuleAsArray(moduleSymbol Symbol) []Symbol {
	return tc.symbolsToArray(tc.getExportsOfModule(moduleSymbol))
}

func (tc *TypeChecker) getExportsAndPropertiesOfModule(moduleSymbol Symbol) []Symbol {
	exports := tc.getExportsOfModuleAsArray(moduleSymbol)
	exportEquals := tc.resolveExternalModuleSymbol(moduleSymbol)
	if exportEquals != moduleSymbol {
		type_ := tc.getTypeOfSymbol(exportEquals)
		if tc.shouldTreatPropertiesOfExternalModuleAsExports(type_) {
			addRange(exports, tc.getPropertiesOfType(type_))
		}
	}
	return exports
}

func (tc *TypeChecker) forEachExportAndPropertyOfModule(moduleSymbol Symbol, cb func(symbol Symbol, key __String)) {
	exports := tc.getExportsOfModule(moduleSymbol)
	exports.forEach(func(symbol Symbol, key __String) {
		if !tc.isReservedMemberName(key) {
			cb(symbol, key)
		}
	})
	exportEquals := tc.resolveExternalModuleSymbol(moduleSymbol)
	if exportEquals != moduleSymbol {
		type_ := tc.getTypeOfSymbol(exportEquals)
		if tc.shouldTreatPropertiesOfExternalModuleAsExports(type_) {
			tc.forEachPropertyOfType(type_, func(symbol Symbol, escapedName __String) {
				cb(symbol, escapedName)
			})
		}
	}
}

func (tc *TypeChecker) tryGetMemberInModuleExports(memberName __String, moduleSymbol Symbol) Symbol {
	symbolTable := tc.getExportsOfModule(moduleSymbol)
	if symbolTable {
		return symbolTable.get(memberName)
	}
}

func (tc *TypeChecker) tryGetMemberInModuleExportsAndProperties(memberName __String, moduleSymbol Symbol) Symbol {
	symbol := tc.tryGetMemberInModuleExports(memberName, moduleSymbol)
	if symbol {
		return symbol
	}

	exportEquals := tc.resolveExternalModuleSymbol(moduleSymbol)
	if exportEquals == moduleSymbol {
		return nil
	}

	type_ := tc.getTypeOfSymbol(exportEquals)
	if tc.shouldTreatPropertiesOfExternalModuleAsExports(type_) {
		return tc.getPropertyOfType(type_, memberName)
	} else {
		return nil
	}
}

func (tc *TypeChecker) shouldTreatPropertiesOfExternalModuleAsExports(resolvedExternalModuleType Type) bool {
	return !(resolvedExternalModuleType.flags&TypeFlagsPrimitive || getObjectFlags(resolvedExternalModuleType)&ObjectFlagsClass || tc.isArrayType(resolvedExternalModuleType) || tc.isTupleType(resolvedExternalModuleType))
}

func (tc *TypeChecker) getExportsOfSymbol(symbol Symbol) SymbolTable {
	switch {
	case symbol.flags & SymbolFlagsLateBindingContainer:
		return tc.getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKindresolvedExports)
	case symbol.flags & SymbolFlagsModule:
		return tc.getExportsOfModule(symbol)
	default:
		return symbol.exports || tc.emptySymbols
	}
}

func (tc *TypeChecker) getExportsOfModule(moduleSymbol Symbol) SymbolTable {
	links := tc.getSymbolLinks(moduleSymbol)
	if !links.resolvedExports {
		TODO_IDENTIFIER := tc.getExportsOfModuleWorker(moduleSymbol)
		links.resolvedExports = exports
		links.typeOnlyExportStarMap = typeOnlyExportStarMap
	}
	return links.resolvedExports
}

/**
 * Extends one symbol table with another while collecting information on name collisions for error message generation into the `lookupTable` argument
 * Not passing `lookupTable` and `exportNode` disables this collection, and just extends the tables
 */

func (tc *TypeChecker) extendExportSymbols(target SymbolTable, source *SymbolTable, lookupTable ExportCollisionTrackerTable, exportNode ExportDeclaration) {
	if !source {
		return
	}
	source.forEach(func(sourceSymbol Symbol, id __String) {
		if id == InternalSymbolNameDefault {
			return
		}

		targetSymbol := target.get(id)
		if !targetSymbol {
			target.set(id, sourceSymbol)
			if lookupTable && exportNode {
				lookupTable.set(id, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"specifierText": getTextOfNode(exportNode.moduleSpecifier),
				})
			}
		} else if lookupTable && exportNode && targetSymbol && tc.resolveSymbol(targetSymbol) != tc.resolveSymbol(sourceSymbol) {
			collisionTracker := lookupTable.get(id)
			if !collisionTracker.exportsWithDuplicate {
				collisionTracker.exportsWithDuplicate = []ExportDeclaration{exportNode}
			} else {
				collisionTracker.exportsWithDuplicate.push(exportNode)
			}
		}
	})
}

func (tc *TypeChecker) getExportsOfModuleWorker(moduleSymbol Symbol) /* TODO(TS-TO-GO) inferred type { exports: SymbolTable; typeOnlyExportStarMap: Map<__String, ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; }> | undefined; } */ any {
	var visitedSymbols []Symbol = []never{}
	var typeOnlyExportStarMap *Map[__String /* TODO(TS-TO-GO) TypeNode IntersectionType: ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, any]
	nonTypeOnlyNames := NewSet[__String]()

	// A module defined by an 'export=' consists of one export that needs to be resolved
	moduleSymbol = tc.resolveExternalModuleSymbol(moduleSymbol)
	exports := visit(moduleSymbol) || tc.emptySymbols

	if typeOnlyExportStarMap {
		nonTypeOnlyNames.forEach(func(name __String) bool {
			return typeOnlyExportStarMap.delete(name)
		})
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"exports":               exports,
		"typeOnlyExportStarMap": typeOnlyExportStarMap,
	}

	// The ES6 spec permits export * declarations in a module to circularly reference the module itself. For example,
	// module 'a' can 'export * from "b"' and 'b' can 'export * from "a"' without error.
	visit := func(symbol Symbol, exportStar ExportDeclaration, isTypeOnly bool) *SymbolTable {
		if !isTypeOnly && symbol. /* ? */ exports {
			// Add non-type-only names before checking if we've visited this module,
			// because we might have visited it via an 'export type *', and visiting
			// again with 'export *' will override the type-onlyness of its exports.
			symbol.exports.forEach(func(_ Symbol, name __String) Set[__String] {
				return nonTypeOnlyNames.add(name)
			})
		}
		if !(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol)) {
			return
		}
		symbols := NewMap(symbol.exports)

		// All export * declarations are collected in an __export symbol by the binder
		exportStars := symbol.exports.get(InternalSymbolNameExportStar)
		if exportStars {
			nestedSymbols := createSymbolTable()
			var lookupTable ExportCollisionTrackerTable = NewMap()
			if exportStars.declarations {
				for _, node := range exportStars.declarations {
					resolvedModule := tc.resolveExternalModuleName(node, (node /* as ExportDeclaration */).moduleSpecifier)
					exportedSymbols := visit(resolvedModule, node /* as ExportDeclaration */, isTypeOnly || (node /* as ExportDeclaration */).isTypeOnly)
					tc.extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node /* as ExportDeclaration */)
				}
			}
			lookupTable.forEach(func(TODO_IDENTIFIER ExportCollisionTracker, id __String) {
				// It's not an error if the file with multiple `export *`s with duplicate names exports a member with that name itself
				if id == "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id) {
					return
				}
				for _, node := range exportsWithDuplicate {
					tc.diagnostics.add(createDiagnosticForNode(node, Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable.get(id).specifierText, unescapeLeadingUnderscores(id)))
				}
			})
			tc.extendExportSymbols(symbols, nestedSymbols)
		}
		if exportStar. /* ? */ isTypeOnly {
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: typeOnlyExportStarMap ??= new Map() */ TODO
			symbols.forEach(func(_ Symbol, escapedName __String) Map[__String /* TODO(TS-TO-GO) inferred type ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, any] {
				return typeOnlyExportStarMap.set(escapedName, exportStar /* as ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */)
			})
		}
		return symbols
	}

}

/* OVERLOAD: function getMergedSymbol(symbol: Symbol): Symbol; */
/* OVERLOAD: function getMergedSymbol(symbol: Symbol | undefined): Symbol | undefined; */
func (tc *TypeChecker) getMergedSymbol(symbol Symbol) Symbol {
	var merged Symbol
	if symbol && symbol.mergeId && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: merged = mergedSymbols[symbol.mergeId] */ TODO) {
		return merged
	} else {
		return symbol
	}
}

func (tc *TypeChecker) getSymbolOfDeclaration(node Declaration) Symbol {
	return tc.getMergedSymbol(node.symbol && tc.getLateBoundSymbol(node.symbol))
}

/**
 * Get the merged symbol for a node. If you know the node is a `Declaration`, it is faster and more type safe to
 * use use `getSymbolOfDeclaration` instead.
 */

func (tc *TypeChecker) getSymbolOfNode(node Node) Symbol {
	if canHaveSymbol(node) {
		return tc.getSymbolOfDeclaration(node)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getParentOfSymbol(symbol Symbol) Symbol {
	return tc.getMergedSymbol(symbol.parent && tc.getLateBoundSymbol(symbol.parent))
}

func (tc *TypeChecker) getFunctionExpressionParentSymbolOrSymbol(symbol Symbol) Symbol {
	if symbol.valueDeclaration. /* ? */ kind == SyntaxKindArrowFunction || symbol.valueDeclaration. /* ? */ kind == SyntaxKindFunctionExpression {
		return tc.getSymbolOfNode(symbol.valueDeclaration.parent) || symbol
	} else {
		return symbol
	}
}

func (tc *TypeChecker) getAlternativeContainingModules(symbol Symbol, enclosingDeclaration Node) []Symbol {
	containingFile := getSourceFileOfNode(enclosingDeclaration)
	id := getNodeId(containingFile)
	links := tc.getSymbolLinks(symbol)
	var results *[]Symbol
	if links.extendedContainersByFile && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: results = links.extendedContainersByFile.get(id) */ TODO) {
		return results
	}
	if containingFile && containingFile.imports {
		// Try to make an import using an import already in the enclosing file, if possible
		for _, importRef := range containingFile.imports {
			if nodeIsSynthesized(importRef) {
				continue
				// Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
			}
			// Synthetic names can't be resolved by `resolveExternalModuleName` - they'll cause a debug assert if they error
			resolvedModule := tc.resolveExternalModuleName(enclosingDeclaration, importRef /*ignoreErrors*/, true)
			if !resolvedModule {
				continue
			}
			ref := tc.getAliasForSymbolInContainer(resolvedModule, symbol)
			if !ref {
				continue
			}
			results = append(results, resolvedModule)
		}
		if length(results) {
			(links.extendedContainersByFile || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.extendedContainersByFile = new Map() */ TODO)).set(id, results)
			return results
		}
	}
	if links.extendedContainers {
		return links.extendedContainers
	}
	// No results from files already being imported by this file - expand search (expensive, but not location-specific, so cached)
	otherFiles := host.getSourceFiles()
	for _, file := range otherFiles {
		if !isExternalModule(file) {
			continue
		}
		sym := tc.getSymbolOfDeclaration(file)
		ref := tc.getAliasForSymbolInContainer(sym, symbol)
		if !ref {
			continue
		}
		results = append(results, sym)
	}
	links.extendedContainers = results || emptyArray
	return links.extendedContainers
}

/**
 * Attempts to find the symbol corresponding to the container a symbol is in - usually this
 * is just its' `.parent`, but for locals, this value is `undefined`
 */

func (tc *TypeChecker) getContainersOfSymbol(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) *[]Symbol {
	container := tc.getParentOfSymbol(symbol)
	// Type parameters end up in the `members` lists but are not externally visible
	if container && !(symbol.flags & SymbolFlagsTypeParameter) {
		return getWithAlternativeContainers(container)
	}
	candidates := mapDefined(symbol.declarations, func(d Declaration) Symbol {
		if !isAmbientModule(d) && d.parent {
			// direct children of a module
			if tc.hasNonGlobalAugmentationExternalModuleSymbol(d.parent) {
				return tc.getSymbolOfDeclaration(d.parent /* as Declaration */)
			}
			// export ='d member of an ambient module
			if isModuleBlock(d.parent) && d.parent.parent && tc.resolveExternalModuleSymbol(tc.getSymbolOfDeclaration(d.parent.parent)) == symbol {
				return tc.getSymbolOfDeclaration(d.parent.parent)
			}
		}
		if isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind == SyntaxKindEqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression) {
			if isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression) {
				return tc.getSymbolOfDeclaration(getSourceFileOfNode(d))
			}
			tc.checkExpressionCached(d.parent.left.expression)
			return tc.getNodeLinks(d.parent.left.expression).resolvedSymbol
		}
	})
	if !length(candidates) {
		return nil
	}
	containers := mapDefined(candidates, func(candidate Symbol) Symbol {
		if tc.getAliasForSymbolInContainer(candidate, symbol) {
			return candidate
		} else {
			return nil
		}
	})

	var bestContainers []Symbol = []never{}
	var alternativeContainers []Symbol = []never{}

	for _, container := range containers {
		TODO_IDENTIFIER := getWithAlternativeContainers(container)
		bestContainers = append(bestContainers, bestMatch)
		alternativeContainers = addRange(alternativeContainers, rest)
	}

	return concatenate(bestContainers, alternativeContainers)

	getWithAlternativeContainers := func(container Symbol) []Symbol {
		additionalContainers := mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer)
		reexportContainers := enclosingDeclaration && tc.getAlternativeContainingModules(symbol, enclosingDeclaration)
		objectLiteralContainer := tc.getVariableDeclarationOfObjectLiteral(container, meaning)
		if enclosingDeclaration && container.flags&tc.getQualifiedLeftMeaning(meaning) && tc.getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlagsNamespace /*useOnlyExternalAliasing*/, false) {
			return append(concatenate(concatenate([]Symbol{container}, additionalContainers), reexportContainers), objectLiteralContainer)
			// This order expresses a preference for the real container if it is in scope
		}
		// we potentially have a symbol which is a member of the instance side of something - look for a variable in scope with the container's type
		// which may be acting like a namespace (eg, `Symbol` acts like a namespace when looking up `Symbol.toStringTag`)
		var firstVariableMatch Symbol
		if !(container.flags & tc.getQualifiedLeftMeaning(meaning)) && container.flags&SymbolFlagsType && tc.getDeclaredTypeOfSymbol(container).flags&TypeFlagsObject && meaning == SymbolFlagsValue {
			firstVariableMatch = tc.forEachSymbolTableInScope(enclosingDeclaration, func(t SymbolTable) Symbol {
				return forEachEntry(t, func(s Symbol) Symbol {
					if s.flags&tc.getQualifiedLeftMeaning(meaning) && tc.getTypeOfSymbol(s) == tc.getDeclaredTypeOfSymbol(container) {
						return s
					}
				})
			})
		} else {
			firstVariableMatch = nil
		}
		var res []Symbol
		if firstVariableMatch {
			res = []Symbol{firstVariableMatch /* TODO(TS-TO-GO) Node SpreadElement: ...additionalContainers */, container}
		} else {
			res = []Symbol{ /* TODO(TS-TO-GO) Node SpreadElement: ...additionalContainers */ container}
		}
		res = append(res, objectLiteralContainer)
		res = addRange(res, reexportContainers)
		return res
	}

	fileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration) Symbol {
		return container && tc.getFileSymbolIfFileSymbolExportEqualsContainer(d, container)
	}

}

func (tc *TypeChecker) getVariableDeclarationOfObjectLiteral(symbol Symbol, meaning SymbolFlags) Symbol {
	// If we're trying to reference some object literal in, eg `var a = { x: 1 }`, the symbol for the literal, `__object`, is distinct
	// from the symbol of the declaration it is being assigned to. Since we can use the declaration to refer to the literal, however,
	// we'd like to make that connection here - potentially causing us to paint the declaration's visibility, and therefore the literal.
	var firstDecl /* TODO(TS-TO-GO) TypeNode UnionType: Node | false */ any = !!length(symbol.declarations) && first(symbol.declarations)
	if meaning&SymbolFlagsValue && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent) {
		if isObjectLiteralExpression(firstDecl) && firstDecl == firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl == firstDecl.parent.type_ {
			return tc.getSymbolOfDeclaration(firstDecl.parent)
		}
	}
}

func (tc *TypeChecker) getFileSymbolIfFileSymbolExportEqualsContainer(d Declaration, container Symbol) Symbol {
	fileSymbol := tc.getExternalModuleContainer(d)
	exported := fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolNameExportEquals)
	if exported && tc.getSymbolIfSameReference(exported, container) {
		return fileSymbol
	} else {
		return nil
	}
}

func (tc *TypeChecker) getAliasForSymbolInContainer(container Symbol, symbol Symbol) Symbol {
	if container == tc.getParentOfSymbol(symbol) {
		// fast path, `symbol` is either already the alias or isn't aliased
		return symbol
	}
	// Check if container is a thing with an `export=` which points directly at `symbol`, and if so, return
	// the container itself as the alias for the symbol
	exportEquals := container.exports && container.exports.get(InternalSymbolNameExportEquals)
	if exportEquals && tc.getSymbolIfSameReference(exportEquals, symbol) {
		return container
	}
	exports := tc.getExportsOfSymbol(container)
	quick := exports.get(symbol.escapedName)
	if quick && tc.getSymbolIfSameReference(quick, symbol) {
		return quick
	}
	return forEachEntry(exports, func(exported Symbol) Symbol {
		if tc.getSymbolIfSameReference(exported, symbol) {
			return exported
		}
	})
}

/**
 * Checks if two symbols, through aliasing and/or merging, refer to the same thing
 */

func (tc *TypeChecker) getSymbolIfSameReference(s1 Symbol, s2 Symbol) Symbol {
	if tc.getMergedSymbol(tc.resolveSymbol(tc.getMergedSymbol(s1))) == tc.getMergedSymbol(tc.resolveSymbol(tc.getMergedSymbol(s2))) {
		return s1
	}
}

/* OVERLOAD: function getExportSymbolOfValueSymbolIfExported(symbol: Symbol): Symbol; */
/* OVERLOAD: function getExportSymbolOfValueSymbolIfExported(symbol: Symbol | undefined): Symbol | undefined; */
func (tc *TypeChecker) getExportSymbolOfValueSymbolIfExported(symbol Symbol) Symbol {
	return tc.getMergedSymbol(symbol && (symbol.flags&SymbolFlagsExportValue) != 0 && symbol.exportSymbol || symbol)
}

func (tc *TypeChecker) symbolIsValue(symbol Symbol, includeTypeOnlyMembers bool) bool {
	return !!(symbol.flags&SymbolFlagsValue || symbol.flags&SymbolFlagsAlias && tc.getSymbolFlags(symbol, !includeTypeOnlyMembers)&SymbolFlagsValue)
}

func (tc *TypeChecker) createType(flags TypeFlags) Type {
	result := NewType(tc.checker, flags)
	tc.typeCount++
	result.id = tc.typeCount
	tracing. /* ? */ recordType(result)
	return result
}

func (tc *TypeChecker) createTypeWithSymbol(flags TypeFlags, symbol Symbol) Type {
	result := tc.createType(flags)
	result.symbol = symbol
	return result
}

func (tc *TypeChecker) createOriginType(flags TypeFlags) Type {
	return NewType(tc.checker, flags)
}

func (tc *TypeChecker) createIntrinsicType(kind TypeFlags, intrinsicName string, objectFlags ObjectFlags /*  = ObjectFlags.None */, debugIntrinsicName string) IntrinsicType {
	tc.checkIntrinsicName(intrinsicName, debugIntrinsicName)
	type_ := tc.createType(kind) /* as IntrinsicType */
	type_.intrinsicName = intrinsicName
	type_.debugIntrinsicName = debugIntrinsicName
	type_.objectFlags = objectFlags | ObjectFlagsCouldContainTypeVariablesComputed | ObjectFlagsIsGenericTypeComputed | ObjectFlagsIsUnknownLikeUnionComputed | ObjectFlagsIsNeverIntersectionComputed
	return type_
}

func (tc *TypeChecker) checkIntrinsicName(name string, debug *string) {
	key := __TEMPLATE__(name, "," /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: debug ?? "" */, TODO)
	if tc.seenIntrinsicNames.has(key) {
		Debug.fail(__TEMPLATE__("Duplicate intrinsic type name ", name, __COND__(debug, __TEMPLATE__(" (", debug, ")"), ""), "; you may need to pass a name to createIntrinsicType."))
	}
	tc.seenIntrinsicNames.add(key)
}

func (tc *TypeChecker) createObjectType(objectFlags ObjectFlags, symbol Symbol) ObjectType {
	type_ := tc.createTypeWithSymbol(TypeFlagsObject, symbol) /* as ObjectType */
	type_.objectFlags = objectFlags
	type_.members = nil
	type_.properties = nil
	type_.callSignatures = nil
	type_.constructSignatures = nil
	type_.indexInfos = nil
	return type_
}

func (tc *TypeChecker) createTypeofType() Type {
	return tc.getUnionType(arrayFrom(typeofNEFacts.keys(), tc.getStringLiteralType))
}

func (tc *TypeChecker) createTypeParameter(symbol Symbol) TypeParameter {
	return tc.createTypeWithSymbol(TypeFlagsTypeParameter, symbol) /* as TypeParameter */
}

// A reserved member name starts with two underscores, but the third character cannot be an underscore,
// @, or #. A third underscore indicates an escaped form of an identifier that started
// with at least two underscores. The @ character indicates that the name is denoted by a well known ES
// Symbol instance and the # character indicates that the name is a PrivateIdentifier.
func (tc *TypeChecker) isReservedMemberName(name __String) bool {
	return (name /* as string */).charCodeAt(0) == CharacterCodes_ && (name /* as string */).charCodeAt(1) == CharacterCodes_ && (name /* as string */).charCodeAt(2) != CharacterCodes_ && (name /* as string */).charCodeAt(2) != CharacterCodesat && (name /* as string */).charCodeAt(2) != CharacterCodeshash
}

func (tc *TypeChecker) getNamedMembers(members SymbolTable) []Symbol {
	var result *[]Symbol
	members.forEach(func(symbol Symbol, id __String) {
		if tc.isNamedMember(symbol, id) {
			(result || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = [] */ TODO)).push(symbol)
		}
	})
	return result || emptyArray
}

func (tc *TypeChecker) isNamedMember(member Symbol, escapedName __String) bool {
	return !tc.isReservedMemberName(escapedName) && tc.symbolIsValue(member)
}

func (tc *TypeChecker) getNamedOrIndexSignatureMembers(members SymbolTable) []Symbol {
	result := tc.getNamedMembers(members)
	index := tc.getIndexSymbolFromSymbolTable(members)
	if index {
		return concatenate(result, []Symbol{index})
	} else {
		return result
	}
}

func (tc *TypeChecker) setStructuredTypeMembers(type_ StructuredType, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
	resolved := type_ /* as ResolvedType */
	resolved.members = members
	resolved.properties = emptyArray
	resolved.callSignatures = callSignatures
	resolved.constructSignatures = constructSignatures
	resolved.indexInfos = indexInfos
	// This can loop back to getPropertyOfType() which would crash if `callSignatures` & `constructSignatures` are not initialized.
	if members != tc.emptySymbols {
		resolved.properties = tc.getNamedMembers(members)
	}
	return resolved
}

func (tc *TypeChecker) createAnonymousType(symbol Symbol, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
	return tc.setStructuredTypeMembers(tc.createObjectType(ObjectFlagsAnonymous, symbol), members, callSignatures, constructSignatures, indexInfos)
}

func (tc *TypeChecker) getResolvedTypeWithoutAbstractConstructSignatures(type_ ResolvedType) ObjectType {
	if type_.constructSignatures.length == 0 {
		return type_
	}
	if type_.objectTypeWithoutAbstractConstructSignatures {
		return type_.objectTypeWithoutAbstractConstructSignatures
	}
	constructSignatures := filter(type_.constructSignatures, func(signature Signature) bool {
		return !(signature.flags & SignatureFlagsAbstract)
	})
	if type_.constructSignatures == constructSignatures {
		return type_
	}
	typeCopy := tc.createAnonymousType(type_.symbol, type_.members, type_.callSignatures, __COND__(some(constructSignatures), constructSignatures, emptyArray), type_.indexInfos)
	type_.objectTypeWithoutAbstractConstructSignatures = typeCopy
	typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy
	return typeCopy
}

func (tc *TypeChecker) forEachSymbolTableInScope(enclosingDeclaration Node, callback func(symbolTable SymbolTable, ignoreQualification bool, isLocalNameLookup bool, scopeNode Node) T) T {
	var result T
	for location := enclosingDeclaration; location; location = location.parent {
		// Locals of a source file are not in scope (because they get merged into the global symbol table)
		if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
			if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = callback(location.locals, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location) */ TODO {
				return result
			}
		}
		switch location.kind {
		case SyntaxKindSourceFile:
			if !isExternalOrCommonJsModule(location /* as SourceFile */) {
				break
			}
			fallthrough
		case SyntaxKindModuleDeclaration:
			sym := tc.getSymbolOfDeclaration(location /* as ModuleDeclaration */)
			if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = callback(sym?.exports || emptySymbols, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location) */ TODO {
				return result
			}
		case SyntaxKindClassDeclaration,
			SyntaxKindClassExpression,
			SyntaxKindInterfaceDeclaration:
			var table *Map[__String, Symbol]
			(tc.getSymbolOfDeclaration(location /* as ClassLikeDeclaration | InterfaceDeclaration */).members || tc.emptySymbols).forEach(func(memberSymbol Symbol, key __String) {
				if memberSymbol.flags & (SymbolFlagsType & ~SymbolFlagsAssignment) {
					(table || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: table = createSymbolTable() */ TODO)).set(key, memberSymbol)
				}
			})
			if table && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = callback(table, /*ignoreQualification* / undefined, /*isLocalNameLookup* / false, location) */ TODO) {
				return result
			}
		}
	}

	return callback(tc.globals /*ignoreQualification*/, nil /*isLocalNameLookup*/, true)
}

func (tc *TypeChecker) getQualifiedLeftMeaning(rightMeaning SymbolFlags) /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Namespace */ any {
	// If we are looking in value space, the parent meaning is value, other wise it is namespace
	if rightMeaning == SymbolFlagsValue {
		return SymbolFlagsValue
	} else {
		return SymbolFlagsNamespace
	}
}

func (tc *TypeChecker) getAccessibleSymbolChain(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, useOnlyExternalAliasing bool, visitedSymbolTablesMap Map[number, []SymbolTable] /*  = new Map<SymbolId, SymbolTable[]>() */) *[]Symbol {
	if !(symbol && !tc.isPropertyOrMethodDeclarationSymbol(symbol)) {
		return nil
	}
	links := tc.getSymbolLinks(symbol)
	cache := ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: links.accessibleChainCache ||= new Map() */ TODO)
	// Go from enclosingDeclaration to the first scope we check, so the cache is keyed off the scope and thus shared more
	firstRelevantLocation := tc.forEachSymbolTableInScope(enclosingDeclaration, func(_ SymbolTable, __ *bool, ___ *bool, node Node) Node {
		return node
	})
	key := __TEMPLATE__(__COND__(useOnlyExternalAliasing, 0, 1), "|", firstRelevantLocation && getNodeId(firstRelevantLocation), "|", meaning)
	if cache.has(key) {
		return cache.get(key)
	}

	id := getSymbolId(symbol)
	visitedSymbolTables := visitedSymbolTablesMap.get(id)
	if !visitedSymbolTables {
		visitedSymbolTablesMap.set(id /* TODO(TS-TO-GO) EqualsToken BinaryExpression: visitedSymbolTables = [] */, TODO)
	}
	result := tc.forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable)
	cache.set(key, result)
	return result
	/**
	 * @param {ignoreQualification} boolean Set when a symbol is being looked for through the exports of another symbol (meaning we have a route to qualify it already)
	 */

	getAccessibleSymbolChainFromSymbolTable := func(symbols SymbolTable, ignoreQualification bool, isLocalNameLookup bool) *[]Symbol {
		if !pushIfUnique(visitedSymbolTables, symbols) {
			return nil
		}

		result := trySymbolTable(symbols, ignoreQualification, isLocalNameLookup)
		visitedSymbolTables.pop()
		return result
	}

	canQualifySymbol := func(symbolFromSymbolTable Symbol, meaning SymbolFlags) bool {
		// If the symbol is equivalent and doesn't need further qualification, this symbol is accessible
		return !tc.needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) || !!tc.getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, tc.getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap)
	}

	isAccessible := func(symbolFromSymbolTable Symbol, resolvedAliasSymbol Symbol, ignoreQualification bool) bool {
		return (symbol == (resolvedAliasSymbol || symbolFromSymbolTable) || tc.getMergedSymbol(symbol) == tc.getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) && !some(symbolFromSymbolTable.declarations, tc.hasNonGlobalAugmentationExternalModuleSymbol) && (ignoreQualification || canQualifySymbol(tc.getMergedSymbol(symbolFromSymbolTable), meaning))
	}

	trySymbolTable := func(symbols SymbolTable, ignoreQualification *bool, isLocalNameLookup *bool) *[]Symbol {
		// If symbol is directly available by its name in the symbol table
		if isAccessible(symbols.get(symbol.escapedName) /*resolvedAliasSymbol*/, nil, ignoreQualification) {
			return []Symbol{symbol}
		}

		// Check if symbol is any of the aliases in scope
		result := forEachEntry(symbols, func(symbolFromSymbolTable Symbol) *[]Symbol {
			if symbolFromSymbolTable.flags&SymbolFlagsAlias && symbolFromSymbolTable.escapedName != InternalSymbolNameExportEquals && symbolFromSymbolTable.escapedName != InternalSymbolNameDefault && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration))) && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration)) && (__COND__(isLocalNameLookup, !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration), true)) && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)) {
				resolvedImportedSymbol := tc.resolveAlias(symbolFromSymbolTable)
				candidate := getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)
				if candidate {
					return candidate
				}
			}
			if symbolFromSymbolTable.escapedName == symbol.escapedName && symbolFromSymbolTable.exportSymbol {
				if isAccessible(tc.getMergedSymbol(symbolFromSymbolTable.exportSymbol) /*resolvedAliasSymbol*/, nil, ignoreQualification) {
					return []Symbol{symbol}
				}
			}
		})

		// If there's no result and we're looking at the global symbol table, treat `globalThis` like an alias and try to lookup thru that
		return result || (__COND__(symbols == tc.globals, getCandidateListForSymbol(tc.globalThisSymbol, tc.globalThisSymbol, ignoreQualification), nil))
	}

	getCandidateListForSymbol := func(symbolFromSymbolTable Symbol, resolvedImportedSymbol Symbol, ignoreQualification *bool) *[]Symbol {
		if isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
			return []Symbol{symbolFromSymbolTable}
		}

		// Look in the exported members, if we can find accessibleSymbolChain, symbol is accessible using this chain
		// but only if the symbolFromSymbolTable can be qualified
		candidateTable := tc.getExportsOfSymbol(resolvedImportedSymbol)
		accessibleSymbolsFromExports := candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable /*ignoreQualification*/, true)
		if accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, tc.getQualifiedLeftMeaning(meaning)) {
			return []Symbol{symbolFromSymbolTable}.concat(accessibleSymbolsFromExports)
		}
	}

}

func (tc *TypeChecker) needsQualification(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) bool {
	qualify := false
	tc.forEachSymbolTableInScope(enclosingDeclaration, func(symbolTable SymbolTable) bool {
		// If symbol of this name is not available in the symbol table we are ok
		symbolFromSymbolTable := tc.getMergedSymbol(symbolTable.get(symbol.escapedName))
		if !symbolFromSymbolTable {
			// Continue to the next symbol table
			return false
		}
		// If the symbol with this name is present it should refer to the symbol
		if symbolFromSymbolTable == symbol {
			// No need to qualify
			return true
		}

		// Qualify if the symbol from symbol table has same meaning as expected
		shouldResolveAlias := symbolFromSymbolTable.flags&SymbolFlagsAlias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)
		if shouldResolveAlias {
			symbolFromSymbolTable = tc.resolveAlias(symbolFromSymbolTable)
		} else {
			symbolFromSymbolTable = symbolFromSymbolTable
		}
		var flags SymbolFlags
		if shouldResolveAlias {
			flags = tc.getSymbolFlags(symbolFromSymbolTable)
		} else {
			flags = symbolFromSymbolTable.flags
		}
		if flags & meaning {
			qualify = true
			return true
		}

		// Continue to the next symbol table
		return false
	})

	return qualify
}

func (tc *TypeChecker) isPropertyOrMethodDeclarationSymbol(symbol Symbol) bool {
	if symbol.declarations && symbol.declarations.length {
		for _, declaration := range symbol.declarations {
			switch declaration.kind {
			case SyntaxKindPropertyDeclaration,
				SyntaxKindMethodDeclaration,
				SyntaxKindGetAccessor,
				SyntaxKindSetAccessor:
				continue
				fallthrough
			default:
				return false
			}
		}
		return true
	}
	return false
}

func (tc *TypeChecker) isTypeSymbolAccessible(typeSymbol Symbol, enclosingDeclaration Node) bool {
	access := tc.isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsType /*shouldComputeAliasesToMakeVisible*/, false /*allowModules*/, true)
	return access.accessibility == SymbolAccessibilityAccessible
}

func (tc *TypeChecker) isValueSymbolAccessible(typeSymbol Symbol, enclosingDeclaration Node) bool {
	access := tc.isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsValue /*shouldComputeAliasesToMakeVisible*/, false /*allowModules*/, true)
	return access.accessibility == SymbolAccessibilityAccessible
}

func (tc *TypeChecker) isSymbolAccessibleByFlags(typeSymbol Symbol, enclosingDeclaration Node, flags SymbolFlags) bool {
	access := tc.isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags /*shouldComputeAliasesToMakeVisible*/, false /*allowModules*/, false)
	return access.accessibility == SymbolAccessibilityAccessible
}

func (tc *TypeChecker) isAnySymbolAccessible(symbols *[]Symbol, enclosingDeclaration Node, initialSymbol Symbol, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) *SymbolAccessibilityResult {
	if !length(symbols) {
		return
	}

	var hadAccessibleChain Symbol
	earlyModuleBail := false
	for _, symbol := range symbols {
		// Symbol is accessible if it by itself is accessible
		accessibleSymbolChain := tc.getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning /*useOnlyExternalAliasing*/, false)
		if accessibleSymbolChain {
			hadAccessibleChain = symbol
			hasAccessibleDeclarations := tc.hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible)
			if hasAccessibleDeclarations {
				return hasAccessibleDeclarations
			}
		}
		if allowModules {
			if some(symbol.declarations, tc.hasNonGlobalAugmentationExternalModuleSymbol) {
				if shouldComputeAliasesToMakeVisible {
					earlyModuleBail = true
					// Generally speaking, we want to use the aliases that already exist to refer to a module, if present
					// In order to do so, we need to find those aliases in order to retain them in declaration emit; so
					// if we are in declaration emit, we cannot use the fast path for module visibility until we've exhausted
					// all other visibility options (in order to capture the possible aliases used to reference the module)
					continue
				}
				// Any meaning of a module symbol is always accessible via an `import` type
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"accessibility": SymbolAccessibilityAccessible,
				}
			}
		}

		// If we haven't got the accessible symbol, it doesn't mean the symbol is actually inaccessible.
		// It could be a qualified symbol and hence verify the path
		// e.g.:
		// module m {
		//     export class c {
		//     }
		// }
		// const x: typeof m.c
		// In the above example when we start with checking if typeof m.c symbol is accessible,
		// we are going to see if c can be accessed in scope directly.
		// But it can't, hence the accessible is going to be undefined, but that doesn't mean m.c is inaccessible
		// It is accessible if the parent m is accessible because then m.c can be accessed through qualification

		containers := tc.getContainersOfSymbol(symbol, enclosingDeclaration, meaning)
		parentResult := tc.isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, __COND__(initialSymbol == symbol, tc.getQualifiedLeftMeaning(meaning), meaning), shouldComputeAliasesToMakeVisible, allowModules)
		if parentResult {
			return parentResult
		}
	}

	if earlyModuleBail {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility": SymbolAccessibilityAccessible,
		}
	}

	if hadAccessibleChain {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility":   SymbolAccessibilityNotAccessible,
			"errorSymbolName": tc.symbolToString(initialSymbol, enclosingDeclaration, meaning),
			"errorModuleName": __COND__(hadAccessibleChain != initialSymbol, tc.symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlagsNamespace), nil),
		}
	}
}

/**
 * Check if the given symbol in given enclosing declaration is accessible and mark all associated alias to be visible if requested
 *
 * @param symbol a Symbol to check if accessible
 * @param enclosingDeclaration a Node containing reference to the symbol
 * @param meaning a SymbolFlags to check if such meaning of the symbol is accessible
 * @param shouldComputeAliasToMakeVisible a boolean value to indicate whether to return aliases to be mark visible in case the symbol is accessible
 */

func (tc *TypeChecker) isSymbolAccessible(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool) SymbolAccessibilityResult {
	return tc.isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible /*allowModules*/, true)
}

func (tc *TypeChecker) isSymbolAccessibleWorker(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) SymbolAccessibilityResult {
	if symbol && enclosingDeclaration {
		result := tc.isAnySymbolAccessible([]Symbol{symbol}, enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules)
		if result {
			return result
		}

		// This could be a symbol that is not exported in the external module
		// or it could be a symbol from different external module that is not aliased and hence cannot be named
		symbolExternalModule := forEach(symbol.declarations, tc.getExternalModuleContainer)
		if symbolExternalModule {
			enclosingExternalModule := tc.getExternalModuleContainer(enclosingDeclaration)
			if symbolExternalModule != enclosingExternalModule {
				// name from different external module that is not visible
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"accessibility":   SymbolAccessibilityCannotBeNamed,
					"errorSymbolName": tc.symbolToString(symbol, enclosingDeclaration, meaning),
					"errorModuleName": tc.symbolToString(symbolExternalModule),
					"errorNode":       __COND__(isInJSFile(enclosingDeclaration), enclosingDeclaration, nil),
				}
			}
		}

		// Just a local name that is not accessible
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility":   SymbolAccessibilityNotAccessible,
			"errorSymbolName": tc.symbolToString(symbol, enclosingDeclaration, meaning),
		}
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"accessibility": SymbolAccessibilityAccessible,
	}
}

func (tc *TypeChecker) getExternalModuleContainer(declaration Node) Symbol {
	node := findAncestor(declaration, tc.hasExternalModuleSymbol)
	return node && tc.getSymbolOfDeclaration(node /* as AmbientModuleDeclaration | SourceFile */)
}

func (tc *TypeChecker) hasExternalModuleSymbol(declaration Node) bool {
	return isAmbientModule(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration /* as SourceFile */))
}

func (tc *TypeChecker) hasNonGlobalAugmentationExternalModuleSymbol(declaration Node) bool {
	return isModuleWithStringLiteralName(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration /* as SourceFile */))
}

func (tc *TypeChecker) hasVisibleDeclarations(symbol Symbol, shouldComputeAliasToMakeVisible bool) *SymbolVisibilityResult {
	var aliasesToMakeVisible *[]LateVisibilityPaintedStatement
	if !every(filter(symbol.declarations, func(d Declaration) bool {
		return d.kind != SyntaxKindIdentifier
	}), getIsDeclarationVisible) {
		return nil
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"accessibility":        SymbolAccessibilityAccessible,
		"aliasesToMakeVisible": aliasesToMakeVisible,
	}

	getIsDeclarationVisible := func(declaration Declaration) bool {
		if !tc.isDeclarationVisible(declaration) {
			// Mark the unexported alias as visible if its parent is visible
			// because these kind of aliases can be used to name types in declaration file

			anyImportSyntax := tc.getAnyImportSyntax(declaration)
			if anyImportSyntax && !hasSyntacticModifier(anyImportSyntax, ModifierFlagsExport) && tc.isDeclarationVisible(anyImportSyntax.parent) {
				return addVisibleAlias(declaration, anyImportSyntax)
			} else if isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) && !hasSyntacticModifier(declaration.parent.parent, ModifierFlagsExport) && tc.isDeclarationVisible(declaration.parent.parent.parent) {
				return addVisibleAlias(declaration, declaration.parent.parent)
			} else if isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration, ModifierFlagsExport) && tc.isDeclarationVisible(declaration.parent) {
				return addVisibleAlias(declaration, declaration)
			} else if isBindingElement(declaration) {
				if symbol.flags&SymbolFlagsAlias && isInJSFile(declaration) && declaration.parent. /* ? */ parent && isVariableDeclaration(declaration.parent.parent) && declaration.parent.parent.parent. /* ? */ parent && isVariableStatement(declaration.parent.parent.parent.parent) && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlagsExport) && declaration.parent.parent.parent.parent.parent && tc.isDeclarationVisible(declaration.parent.parent.parent.parent.parent) {
					return addVisibleAlias(declaration, declaration.parent.parent.parent.parent)
				} else if symbol.flags & SymbolFlagsBlockScopedVariable {
					variableStatement := findAncestor(declaration, isVariableStatement)
					if hasSyntacticModifier(variableStatement, ModifierFlagsExport) {
						return true
					}
					if !tc.isDeclarationVisible(variableStatement.parent) {
						return false
					}
					return addVisibleAlias(declaration, variableStatement)
				}
			}

			// Declaration is not visible
			return false
		}

		return true
	}

	addVisibleAlias := func(declaration Declaration, aliasingStatement LateVisibilityPaintedStatement) bool {
		// In function "buildTypeDisplay" where we decide whether to write type-alias or serialize types,
		// we want to just check if type- alias is accessible or not but we don't care about emitting those alias at that time
		// since we will do the emitting later in trackSymbol.
		if shouldComputeAliasToMakeVisible {
			tc.getNodeLinks(declaration).isVisible = true
			aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement)
		}
		return true
	}

}

func (tc *TypeChecker) getMeaningOfEntityNameReference(entityName EntityNameOrEntityNameExpression) SymbolFlags {
	// get symbol of the first identifier of the entityName
	var meaning SymbolFlags
	if entityName.parent.kind == SyntaxKindTypeQuery || entityName.parent.kind == SyntaxKindExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) || entityName.parent.kind == SyntaxKindComputedPropertyName || entityName.parent.kind == SyntaxKindTypePredicate && (entityName.parent /* as TypePredicateNode */).parameterName == entityName {
		// Typeof value
		meaning = SymbolFlagsValue | SymbolFlagsExportValue
	} else if entityName.kind == SyntaxKindQualifiedName || entityName.kind == SyntaxKindPropertyAccessExpression || entityName.parent.kind == SyntaxKindImportEqualsDeclaration || (entityName.parent.kind == SyntaxKindQualifiedName && (entityName.parent /* as QualifiedName */).left == entityName) || (entityName.parent.kind == SyntaxKindPropertyAccessExpression && (entityName.parent /* as PropertyAccessExpression */).expression == entityName) || (entityName.parent.kind == SyntaxKindElementAccessExpression && (entityName.parent /* as ElementAccessExpression */).expression == entityName) {
		// Left identifier from type reference or TypeAlias
		// Entity name of the import declaration
		meaning = SymbolFlagsNamespace
	} else {
		// Type Reference or TypeAlias entity = Identifier
		meaning = SymbolFlagsType
	}
	return meaning
}

func (tc *TypeChecker) isEntityNameVisible(entityName EntityNameOrEntityNameExpression, enclosingDeclaration Node, shouldComputeAliasToMakeVisible bool /*  = true */) SymbolVisibilityResult {
	meaning := tc.getMeaningOfEntityNameReference(entityName)
	firstIdentifier := getFirstIdentifier(entityName)
	symbol := tc.resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning /*nameNotFoundMessage*/, nil /*isUse*/, false)
	if symbol && symbol.flags&SymbolFlagsTypeParameter && meaning&SymbolFlagsType {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility": SymbolAccessibilityAccessible,
		}
	}
	if !symbol && isThisIdentifier(firstIdentifier) && tc.isSymbolAccessible(tc.getSymbolOfDeclaration(getThisContainer(firstIdentifier /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)), firstIdentifier, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility == SymbolAccessibilityAccessible {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility": SymbolAccessibilityAccessible,
		}
	}

	if !symbol {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"accessibility":   SymbolAccessibilityNotResolved,
			"errorSymbolName": getTextOfNode(firstIdentifier),
			"errorNode":       firstIdentifier,
		}
	}
	// Verify if the symbol is accessible
	return tc.hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"accessibility":   SymbolAccessibilityNotAccessible,
		"errorSymbolName": getTextOfNode(firstIdentifier),
		"errorNode":       firstIdentifier,
	}
}

func (tc *TypeChecker) symbolToString(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, flags SymbolFormatFlags /*  = SymbolFormatFlags.AllowAnyNodeKind */, writer EmitTextWriter) string {
	nodeFlags := NodeBuilderFlagsIgnoreErrors
	internalNodeFlags := InternalNodeBuilderFlagsNone
	if flags & SymbolFormatFlagsUseOnlyExternalAliasing {
		nodeFlags |= NodeBuilderFlagsUseOnlyExternalAliasing
	}
	if flags & SymbolFormatFlagsWriteTypeParametersOrArguments {
		nodeFlags |= NodeBuilderFlagsWriteTypeParametersInQualifiedName
	}
	if flags & SymbolFormatFlagsUseAliasDefinedOutsideCurrentScope {
		nodeFlags |= NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope
	}
	if flags & SymbolFormatFlagsDoNotIncludeSymbolChain {
		internalNodeFlags |= InternalNodeBuilderFlagsDoNotIncludeSymbolChain
	}
	if flags & SymbolFormatFlagsWriteComputedProps {
		internalNodeFlags |= InternalNodeBuilderFlagsWriteComputedProps
	}
	var builder /* TODO(TS-TO-GO) inferred type ((symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => EntityName | undefined) | ((symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | ComputedPropertyName | undefined) */ any
	if flags & SymbolFormatFlagsAllowAnyNodeKind {
		builder = tc.nodeBuilder.symbolToNode
	} else {
		builder = tc.nodeBuilder.symbolToEntityName
	}
	if writer {
		return symbolToStringWorker(writer).getText()
	} else {
		return usingSingleLineStringWriter(symbolToStringWorker)
	}

	symbolToStringWorker := func(writer EmitTextWriter) EmitTextWriter {
		entity := builder(symbol, meaning, enclosingDeclaration, nodeFlags, internalNodeFlags)
		// add neverAsciiEscape for GH#39027
		var printer Printer
		if enclosingDeclaration. /* ? */ kind == SyntaxKindSourceFile {
			printer = createPrinterWithRemoveCommentsNeverAsciiEscape()
		} else {
			printer = createPrinterWithRemoveComments()
		}
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		printer.writeNode(EmitHintUnspecified, entity /*sourceFile*/, sourceFile, writer)
		return writer
	}

}

func (tc *TypeChecker) signatureToString(signature Signature, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.None */, kind SignatureKind, writer EmitTextWriter) string {
	if writer {
		return signatureToStringWorker(writer).getText()
	} else {
		return usingSingleLineStringWriter(signatureToStringWorker)
	}

	signatureToStringWorker := func(writer EmitTextWriter) EmitTextWriter {
		var sigOutput SyntaxKind
		if flags & TypeFormatFlagsWriteArrowStyleSignature {
			if kind == SignatureKindConstruct {
				sigOutput = SyntaxKindConstructorType
			} else {
				sigOutput = SyntaxKindFunctionType
			}
		} else {
			if kind == SignatureKindConstruct {
				sigOutput = SyntaxKindConstructSignature
			} else {
				sigOutput = SyntaxKindCallSignature
			}
		}
		sig := tc.nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, tc.toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|NodeBuilderFlagsWriteTypeParametersInQualifiedName)
		printer := createPrinterWithRemoveCommentsOmitTrailingSemicolon()
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		printer.writeNode(EmitHintUnspecified, sig /*sourceFile*/, sourceFile, getTrailingSemicolonDeferringWriter(writer))
		// TODO: GH#18217
		return writer
	}

}

func (tc *TypeChecker) typeToString(type_ Type, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter /*  = createTextWriter("") */) string {
	noTruncation := tc.compilerOptions.noErrorTruncation || flags&TypeFormatFlagsNoTruncation
	typeNode := tc.nodeBuilder.typeToTypeNode(type_, enclosingDeclaration, tc.toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|(__COND__(noTruncation, NodeBuilderFlagsNoTruncation, NodeBuilderFlagsNone)) /*internalFlags*/, nil)
	if typeNode == nil {
		return Debug.fail("should always get typenode")
	}
	// The unresolved type gets a synthesized comment on `any` to hint to users that it's not a plain `any`.
	// Otherwise, we always strip comments out.
	var printer Printer
	if type_ != tc.unresolvedType {
		printer = createPrinterWithRemoveComments()
	} else {
		printer = createPrinterWithDefaults()
	}
	sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
	printer.writeNode(EmitHintUnspecified, typeNode /*sourceFile*/, sourceFile, writer)
	result := writer.getText()

	var maxLength number
	if noTruncation {
		maxLength = noTruncationMaximumTruncationLength * 2
	} else {
		maxLength = defaultMaximumTruncationLength * 2
	}
	if maxLength && result && result.length >= maxLength {
		return result.substr(0, maxLength-len("...")) + "..."
	}
	return result
}

func (tc *TypeChecker) getTypeNamesForErrorDisplay(left Type, right Type) /* TODO(TS-TO-GO) TypeNode TupleType: [string, string] */ any {
	var leftStr string
	if tc.symbolValueDeclarationIsContextSensitive(left.symbol) {
		leftStr = tc.typeToString(left, left.symbol.valueDeclaration)
	} else {
		leftStr = tc.typeToString(left)
	}
	var rightStr string
	if tc.symbolValueDeclarationIsContextSensitive(right.symbol) {
		rightStr = tc.typeToString(right, right.symbol.valueDeclaration)
	} else {
		rightStr = tc.typeToString(right)
	}
	if leftStr == rightStr {
		leftStr = tc.getTypeNameForErrorDisplay(left)
		rightStr = tc.getTypeNameForErrorDisplay(right)
	}
	return []any{leftStr, rightStr}
}

func (tc *TypeChecker) getTypeNameForErrorDisplay(type_ Type) string {
	return tc.typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsUseFullyQualifiedType)
}

func (tc *TypeChecker) symbolValueDeclarationIsContextSensitive(symbol Symbol) bool {
	return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !tc.isContextSensitive(symbol.valueDeclaration)
}

func (tc *TypeChecker) toNodeBuilderFlags(flags TypeFormatFlags /*  = TypeFormatFlags.None */) NodeBuilderFlags {
	return flags & TypeFormatFlagsNodeBuilderFlagsMask
}

func (tc *TypeChecker) isClassInstanceSide(type_ Type) bool {
	return !!type_.symbol && !!(type_.symbol.flags & SymbolFlagsClass) && (type_ == tc.getDeclaredTypeOfClassOrInterface(type_.symbol) || (!!(type_.flags & TypeFlagsObject) && !!(getObjectFlags(type_) & ObjectFlagsIsClassInstanceClone)))
}

/**
 * Same as getTypeFromTypeNode, but for use in createNodeBuilder
 * Inside createNodeBuilder we shadow getTypeFromTypeNode to make sure anyone using this function will call the local version that does type mapping if appropriate
 * This function is used to still be able to call the original getTypeFromTypeNode from the local scope version of getTypeFromTypeNode
 */

func (tc *TypeChecker) getTypeFromTypeNodeWithoutContext(node TypeNode) Type {
	return tc.getTypeFromTypeNode(node)
}

func (tc *TypeChecker) createNodeBuilder() /* TODO(TS-TO-GO) inferred type { typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => SignatureDeclaration | undefined; symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => EntityName | undefined; symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | undefined; symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => NodeArray<TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Statement[] | undefined; symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => Expression | ComputedPropertyName | undefined; } */ any {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"typeToTypeNode": func(type_ Type, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeNode {
				return typeToTypeNodeHelper(type_, context)
			})
		},
		"typePredicateToTypePredicateNode": func(typePredicate TypePredicate, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypePredicateNode {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypePredicateNode {
				return typePredicateToTypePredicateNodeHelper(typePredicate, context)
			})
		},
		"expressionOrTypeToTypeNode": func(expr /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeNode {
				return expressionOrTypeToTypeNode(context, expr, type_, addUndefined)
			})
		},
		"serializeTypeForDeclaration": func(declaration Declaration, type_ Type, symbol Symbol, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeNode {
				return serializeTypeForDeclaration(context, declaration, type_, symbol)
			})
		},
		"serializeReturnTypeForSignature": func(signature Signature, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) *TypeNode {
				return serializeReturnTypeForSignature(context, signature)
			})
		},
		"indexInfoToIndexSignatureDeclaration": func(indexInfo IndexInfo, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *IndexSignatureDeclaration {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) IndexSignatureDeclaration {
				return indexInfoToIndexSignatureDeclarationHelper(indexInfo, context /*typeNode*/, nil)
			})
		},
		"signatureToSignatureDeclaration": func(signature Signature, kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *SignatureDeclaration {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) SignatureDeclaration {
				return signatureToSignatureDeclarationHelper(signature, kind, context)
			})
		},
		"symbolToEntityName": func(symbol Symbol, meaning SymbolFlags, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *EntityName {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) EntityName {
				return symbolToName(symbol, context, meaning /*expectsIdentifier*/, false)
			})
		},
		"symbolToExpression": func(symbol Symbol, meaning SymbolFlags, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) Expression {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) Expression {
				return symbolToExpression(symbol, context, meaning)
			})
		},
		"symbolToTypeParameterDeclarations": func(symbol Symbol, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *NodeArray[TypeParameterDeclaration] {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) *NodeArray[TypeParameterDeclaration] {
				return typeParametersToTypeParameterDeclarations(symbol, context)
			})
		},
		"symbolToParameterDeclaration": func(symbol Symbol, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *ParameterDeclaration {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) ParameterDeclaration {
				return symbolToParameterDeclaration(symbol, context)
			})
		},
		"typeParameterToDeclaration": func(parameter TypeParameter, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeParameterDeclaration {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) TypeParameterDeclaration {
				return typeParameterToDeclaration(parameter, context)
			})
		},
		"symbolTableToDeclarationStatements": func(symbolTable SymbolTable, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *[]Statement {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) []Statement {
				return symbolTableToDeclarationStatements(symbolTable, context)
			})
		},
		"symbolToNode": func(symbol Symbol, meaning SymbolFlags, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) * /* TODO(TS-TO-GO) inferred type Expression | ComputedPropertyName */ any {
			return withContext(enclosingDeclaration, flags, internalFlags, tracker, func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type Expression | ComputedPropertyName */ any {
				return symbolToNode(symbol, context, meaning)
			})
		},
	}

	/* OVERLOAD: function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes?: false): Type; */
	/* OVERLOAD: function getTypeFromTypeNode(context: NodeBuilderContext, node: TypeNode, noMappedTypes: true): Type | undefined; */
	getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes bool) Type {
		type_ := tc.getTypeFromTypeNodeWithoutContext(node)
		if !context.mapper {
			return type_
		}

		mappedType := tc.instantiateType(type_, context.mapper)
		if noMappedTypes && mappedType != type_ {
			return nil
		} else {
			return mappedType
		}
	}

	/**
	 * Unlike the utilities `setTextRange`, this checks if the `location` we're trying to set on `range` is within the
	 * same file as the active context. If not, the range is not applied. This prevents us from copying ranges across files,
	 * which will confuse the node printer (as it assumes all node ranges are within the current file).
	 * Additionally, if `range` _isn't synthetic_, or isn't in the current file, it will _copy_ it to _remove_ its' position
	 * information.
	 *
	 * It also calls `setOriginalNode` to setup a `.original` pointer, since you basically *always* want these in the node builder.
	 */

	setTextRange := func(context NodeBuilderContext, range_ T, location Node) T {
		if !nodeIsSynthesized(range_) || !(range_.flags & NodeFlagsSynthesized) || !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(getOriginalNode(range_)) {
			range_ = factory.cloneNode(range_)
			// if `range` is synthesized or originates in another file, copy it so it definitely has synthetic positions
		}
		if range_ == location {
			return range_
		}
		if !location {
			return range_
		}
		// Don't overwrite the original node if `range` has an `original` node that points either directly or indirectly to `location`
		original := range_.original
		for original && original != location {
			original = original.original
		}
		if !original {
			setOriginalNode(range_, location)
		}
		// only set positions if range comes from the same file since copying text across files isn't supported by the emitter
		if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(getOriginalNode(location)) {
			return setTextRangeWorker(range_, location)
		}
		return range_
	}

	/**
	 * Same as expressionOrTypeToTypeNodeHelper, but also checks if the expression can be syntactically typed.
	 */

	expressionOrTypeToTypeNode := func(context NodeBuilderContext, expr /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) TypeNode {
		restoreFlags := saveRestoreFlags(context)
		if expr && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
			tc.syntacticNodeBuilder.serializeTypeOfExpression(expr, context, addUndefined)
		}
		context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
		result := expressionOrTypeToTypeNodeHelper(context, expr, type_, addUndefined)
		restoreFlags()
		return result
	}

	expressionOrTypeToTypeNodeHelper := func(context NodeBuilderContext, expr /* TODO(TS-TO-GO) TypeNode UnionType: Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) TypeNode {
		if expr {
			var typeNode *TypeNode
			switch {
			case isAssertionExpression(expr):
				typeNode = expr.type_
			case isJSDocTypeAssertion(expr):
				typeNode = getJSDocTypeAssertionType(expr)
			default:
				typeNode = nil
			}
			if typeNode && !isConstTypeReference(typeNode) {
				result := tryReuseExistingTypeNode(context, typeNode, type_, expr.parent, addUndefined)
				if result {
					return result
				}
			}
		}

		if addUndefined {
			type_ = tc.getOptionalType(type_)
		}

		return typeToTypeNodeHelper(type_, context)
	}

	tryReuseExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode, type_ Type, host Node, addUndefined bool) *TypeNode {
		originalType := type_
		if addUndefined {
			type_ = tc.getOptionalType(type_, !isParameter(host))
		}
		clone := tryReuseExistingNonParameterTypeNode(context, typeNode, type_, host)
		if clone {
			// explicitly add `| undefined` if it's missing from the input type nodes and the type contains `undefined` (and not the missing type)
			if addUndefined && tc.containsNonMissingUndefinedType(type_) && !tc.someType(getTypeFromTypeNode(context, typeNode), func(t Type) bool {
				return !!(t.flags & TypeFlagsUndefined)
			}) {
				return factory.createUnionTypeNode([]TypeNode{clone, factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
			}
			return clone
		}
		if addUndefined && originalType != type_ {
			cloneMissingUndefined := tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host)
			if cloneMissingUndefined {
				return factory.createUnionTypeNode([]TypeNode{cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
			}
		}
		return nil
	}

	tryReuseExistingNonParameterTypeNode := func(context NodeBuilderContext, existing TypeNode, type_ Type, host Node /*  = context.enclosingDeclaration */, annotationType Type /*  = getTypeFromTypeNode(context, existing, /*noMappedTypes* / true) */) *TypeNode {
		if annotationType && typeNodeIsEquivalentToType(host, type_, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) {
			result := tryReuseExistingTypeNodeHelper(context, existing)
			if result {
				return result
			}
		}
		return nil
	}

	symbolToNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(TS-TO-GO) inferred type Expression | ComputedPropertyName */ any {
		if context.internalFlags & InternalNodeBuilderFlagsWriteComputedProps {
			if symbol.valueDeclaration {
				name := getNameOfDeclaration(symbol.valueDeclaration)
				if name && isComputedPropertyName(name) {
					return name
				}
			}
			nameType := tc.getSymbolLinks(symbol).nameType
			if nameType && nameType.flags&(TypeFlagsEnumLiteral|TypeFlagsUniqueESSymbol) {
				context.enclosingDeclaration = nameType.symbol.valueDeclaration
				return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning))
			}
		}
		return symbolToExpression(symbol, context, meaning)
	}

	withContext := func(enclosingDeclaration Node, flags *NodeBuilderFlags, internalFlags *InternalNodeBuilderFlags, tracker *SymbolTracker, cb func(context NodeBuilderContext) T) *T {
		var moduleResolverHost *ModuleSpecifierResolutionHost
		switch {
		case tracker. /* ? */ trackSymbol:
			moduleResolverHost = tracker.moduleResolverHost
		case (internalFlags || InternalNodeBuilderFlagsNone) & InternalNodeBuilderFlagsDoNotIncludeSymbolChain:
			moduleResolverHost = createBasicNodeBuilderModuleSpecifierResolutionHost(host)
		default:
			moduleResolverHost = nil
		}
		var context NodeBuilderContext = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"enclosingDeclaration":                  enclosingDeclaration,
			"enclosingFile":                         enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),
			"flags":                                 flags || NodeBuilderFlagsNone,
			"internalFlags":                         internalFlags || InternalNodeBuilderFlagsNone,
			"tracker":                               nil,
			"encounteredError":                      false,
			"reportedDiagnostic":                    false,
			"visitedTypes":                          nil,
			"symbolDepth":                           nil,
			"inferTypeParameters":                   nil,
			"approximateLength":                     0,
			"trackedSymbols":                        nil,
			"bundled":                               !!tc.compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)),
			"truncating":                            false,
			"usedSymbolNames":                       nil,
			"remappedSymbolNames":                   nil,
			"remappedSymbolReferences":              nil,
			"reverseMappedStack":                    nil,
			"mustCreateTypeParameterSymbolList":     true,
			"typeParameterSymbolList":               nil,
			"mustCreateTypeParametersNamesLookups":  true,
			"typeParameterNames":                    nil,
			"typeParameterNamesByText":              nil,
			"typeParameterNamesByTextNextNameCount": nil,
			"mapper":                                nil,
		}
		context.tracker = NewSymbolTrackerImpl(context, tracker, moduleResolverHost)
		resultingNode := cb(context)
		if context.truncating && context.flags&NodeBuilderFlagsNoTruncation {
			context.tracker.reportTruncationError()
		}
		if context.encounteredError {
			return nil
		} else {
			return resultingNode
		}
	}

	saveRestoreFlags := func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type () => void */ any {
		flags := context.flags
		internalFlags := context.internalFlags

		return restore

		restore := func() {
			context.flags = flags
			context.internalFlags = internalFlags
		}

	}

	checkTruncationLength := func(context NodeBuilderContext) bool {
		if context.truncating {
			return context.truncating
		}
		context.truncating = context.approximateLength > (__COND__((context.flags & NodeBuilderFlagsNoTruncation), noTruncationMaximumTruncationLength, defaultMaximumTruncationLength))
		return context.truncating
	}

	typeToTypeNodeHelper := func(type_ Type, context NodeBuilderContext) TypeNode {
		restoreFlags := saveRestoreFlags(context)
		typeNode := typeToTypeNodeWorker(type_, context)
		restoreFlags()
		return typeNode
	}

	typeToTypeNodeWorker := func(type_ Type, context NodeBuilderContext) TypeNode {
		if tc.cancellationToken && tc.cancellationToken.throwIfCancellationRequested {
			tc.cancellationToken.throwIfCancellationRequested()
		}
		inTypeAlias := context.flags & NodeBuilderFlagsInTypeAlias
		context.flags &= ~NodeBuilderFlagsInTypeAlias

		if !type_ {
			if !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
				context.encounteredError = true
				return nil
				// TODO: GH#18217
			}
			context.approximateLength += 3
			return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
		}

		if !(context.flags & NodeBuilderFlagsNoTypeReduction) {
			type_ = tc.getReducedType(type_)
		}

		if type_.flags & TypeFlagsAny {
			if type_.aliasSymbol {
				return factory.createTypeReferenceNode(symbolToEntityNameNode(type_.aliasSymbol), mapToTypeNodes(type_.aliasTypeArguments, context))
			}
			if type_ == tc.unresolvedType {
				return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, "unresolved")
			}
			context.approximateLength += 3
			return factory.createKeywordTypeNode(__COND__(type_ == tc.intrinsicMarkerType, SyntaxKindIntrinsicKeyword, SyntaxKindAnyKeyword))
		}
		if type_.flags & TypeFlagsUnknown {
			return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
		}
		if type_.flags & TypeFlagsString {
			context.approximateLength += 6
			return factory.createKeywordTypeNode(SyntaxKindStringKeyword)
		}
		if type_.flags & TypeFlagsNumber {
			context.approximateLength += 6
			return factory.createKeywordTypeNode(SyntaxKindNumberKeyword)
		}
		if type_.flags & TypeFlagsBigInt {
			context.approximateLength += 6
			return factory.createKeywordTypeNode(SyntaxKindBigIntKeyword)
		}
		if type_.flags&TypeFlagsBoolean && !type_.aliasSymbol {
			context.approximateLength += 7
			return factory.createKeywordTypeNode(SyntaxKindBooleanKeyword)
		}
		if type_.flags & TypeFlagsEnumLike {
			if type_.symbol.flags & SymbolFlagsEnumMember {
				parentSymbol := tc.getParentOfSymbol(type_.symbol)
				parentName := symbolToTypeNode(parentSymbol, context, SymbolFlagsType)
				if tc.getDeclaredTypeOfSymbol(parentSymbol) == type_ {
					return parentName
				}
				memberName := symbolName(type_.symbol)
				if isIdentifierText(memberName, ScriptTargetES5) {
					return appendReferenceToType(parentName /* as TypeReferenceNode | ImportTypeNode */, factory.createTypeReferenceNode(memberName /*typeArguments*/, nil))
				}
				if isImportTypeNode(parentName) {
					(parentName /* as any */).isTypeOf = true
					// mutably update, node is freshly manufactured anyhow
					return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
				} else if isTypeReferenceNode(parentName) {
					return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
				} else {
					return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.")
				}
			}
			return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
		}
		if type_.flags & TypeFlagsStringLiteral {
			context.approximateLength += (type_ /* as StringLiteralType */).value.length + 2
			return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral((type_ /* as StringLiteralType */).value, !!(context.flags&NodeBuilderFlagsUseSingleQuotesForStringLiteralType)), EmitFlagsNoAsciiEscaping))
		}
		if type_.flags & TypeFlagsNumberLiteral {
			value := (type_ /* as NumberLiteralType */).value
			context.approximateLength += ("" + value).length
			return factory.createLiteralTypeNode(__COND__(value < 0, factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-value)), factory.createNumericLiteral(value)))
		}
		if type_.flags & TypeFlagsBigIntLiteral {
			context.approximateLength += (pseudoBigIntToString((type_ /* as BigIntLiteralType */).value).length) + 1
			return factory.createLiteralTypeNode(factory.createBigIntLiteral((type_ /* as BigIntLiteralType */).value))
		}
		if type_.flags & TypeFlagsBooleanLiteral {
			context.approximateLength += (type_ /* as IntrinsicType */).intrinsicName.length
			return factory.createLiteralTypeNode(__COND__((type_ /* as IntrinsicType */).intrinsicName == "true", factory.createTrue(), factory.createFalse()))
		}
		if type_.flags & TypeFlagsUniqueESSymbol {
			if !(context.flags & NodeBuilderFlagsAllowUniqueESSymbolType) {
				if tc.isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
					context.approximateLength += 6
					return symbolToTypeNode(type_.symbol, context, SymbolFlagsValue)
				}
				if context.tracker.reportInaccessibleUniqueSymbolError {
					context.tracker.reportInaccessibleUniqueSymbolError()
				}
			}
			context.approximateLength += 13
			return factory.createTypeOperatorNode(SyntaxKindUniqueKeyword, factory.createKeywordTypeNode(SyntaxKindSymbolKeyword))
		}
		if type_.flags & TypeFlagsVoid {
			context.approximateLength += 4
			return factory.createKeywordTypeNode(SyntaxKindVoidKeyword)
		}
		if type_.flags & TypeFlagsUndefined {
			context.approximateLength += 9
			return factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)
		}
		if type_.flags & TypeFlagsNull {
			context.approximateLength += 4
			return factory.createLiteralTypeNode(factory.createNull())
		}
		if type_.flags & TypeFlagsNever {
			context.approximateLength += 5
			return factory.createKeywordTypeNode(SyntaxKindNeverKeyword)
		}
		if type_.flags & TypeFlagsESSymbol {
			context.approximateLength += 6
			return factory.createKeywordTypeNode(SyntaxKindSymbolKeyword)
		}
		if type_.flags & TypeFlagsNonPrimitive {
			context.approximateLength += 6
			return factory.createKeywordTypeNode(SyntaxKindObjectKeyword)
		}
		if isThisTypeParameter(type_) {
			if context.flags & NodeBuilderFlagsInObjectTypeLiteral {
				if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowThisInObjectLiteral) {
					context.encounteredError = true
				}
				context.tracker.reportInaccessibleThisError()
			}
			context.approximateLength += 4
			return factory.createThisTypeNode()
		}

		if !inTypeAlias && type_.aliasSymbol && (context.flags&NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope || tc.isTypeSymbolAccessible(type_.aliasSymbol, context.enclosingDeclaration)) {
			typeArgumentNodes := mapToTypeNodes(type_.aliasTypeArguments, context)
			if tc.isReservedMemberName(type_.aliasSymbol.escapedName) && !(type_.aliasSymbol.flags & SymbolFlagsClass) {
				return factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes)
			}
			if length(typeArgumentNodes) == 1 && type_.aliasSymbol == tc.globalArrayType.symbol {
				return factory.createArrayTypeNode(typeArgumentNodes[0])
			}
			return symbolToTypeNode(type_.aliasSymbol, context, SymbolFlagsType, typeArgumentNodes)
		}

		objectFlags := getObjectFlags(type_)

		if objectFlags & ObjectFlagsReference {
			Debug.assert(!!(type_.flags & TypeFlagsObject))
			if (type_ /* as TypeReference */).node {
				return visitAndTransformType(type_ /* as TypeReference */, typeReferenceToTypeNode)
			} else {
				return typeReferenceToTypeNode(type_ /* as TypeReference */)
			}
		}
		if type_.flags&TypeFlagsTypeParameter || objectFlags&ObjectFlagsClassOrInterface {
			if type_.flags&TypeFlagsTypeParameter && contains(context.inferTypeParameters, type_) {
				context.approximateLength += symbolName(type_.symbol).length + 6
				var constraintNode *TypeNode
				constraint := tc.getConstraintOfTypeParameter(type_ /* as TypeParameter */)
				if constraint {
					// If the infer type has a constraint that is not the same as the constraint
					// we would have normally inferred based on context, we emit the constraint
					// using `infer T extends ?`. We omit inferred constraints from type references
					// as they may be elided.
					inferredConstraint := tc.getInferredTypeParameterConstraint(type_ /* as TypeParameter */ /*omitTypeReferences*/, true)
					if !(inferredConstraint && tc.isTypeIdenticalTo(constraint, inferredConstraint)) {
						context.approximateLength += 9
						constraintNode = constraint && typeToTypeNodeHelper(constraint, context)
					}
				}
				return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type_ /* as TypeParameter */, context, constraintNode))
			}
			if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.flags&TypeFlagsTypeParameter {
				name := typeParameterToName(type_, context)
				context.approximateLength += idText(name).length
				return factory.createTypeReferenceNode(factory.createIdentifier(idText(name)) /*typeArguments*/, nil)
			}
			// Ignore constraint/default when creating a usage (as opposed to declaration) of a type parameter.
			if type_.symbol {
				return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
			}
			var name string
			if (type_ == tc.markerSuperTypeForCheck || type_ == tc.markerSubTypeForCheck) && tc.varianceTypeParameter && tc.varianceTypeParameter.symbol {
				name = (__COND__(type_ == tc.markerSubTypeForCheck, "sub-", "super-")) + symbolName(tc.varianceTypeParameter.symbol)
			} else {
				name = "?"
			}
			return factory.createTypeReferenceNode(factory.createIdentifier(name) /*typeArguments*/, nil)
		}
		if type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).origin {
			type_ = (type_ /* as UnionType */).origin
		}
		if type_.flags & (TypeFlagsUnion | TypeFlagsIntersection) {
			var types []Type
			if type_.flags & TypeFlagsUnion {
				types = tc.formatUnionTypes((type_ /* as UnionType */).types)
			} else {
				types = (type_ /* as IntersectionType */).types
			}
			if length(types) == 1 {
				return typeToTypeNodeHelper(types[0], context)
			}
			typeNodes := mapToTypeNodes(types, context /*isBareList*/, true)
			if typeNodes && typeNodes.length > 0 {
				if type_.flags & TypeFlagsUnion {
					return factory.createUnionTypeNode(typeNodes)
				} else {
					return factory.createIntersectionTypeNode(typeNodes)
				}
			} else {
				if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
					context.encounteredError = true
				}
				return nil
				// TODO: GH#18217
			}
		}
		if objectFlags & (ObjectFlagsAnonymous | ObjectFlagsMapped) {
			Debug.assert(!!(type_.flags & TypeFlagsObject))
			// The type is an object literal type.
			return createAnonymousTypeNode(type_ /* as ObjectType */)
		}
		if type_.flags & TypeFlagsIndex {
			indexedType := (type_ /* as IndexType */).type_
			context.approximateLength += 6
			indexTypeNode := typeToTypeNodeHelper(indexedType, context)
			return factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, indexTypeNode)
		}
		if type_.flags & TypeFlagsTemplateLiteral {
			texts := (type_ /* as TemplateLiteralType */).texts
			types := (type_ /* as TemplateLiteralType */).types
			templateHead := factory.createTemplateHead(texts[0])
			templateSpans := factory.createNodeArray(map_(types, func(t Type, i number) TemplateLiteralTypeSpan {
				return factory.createTemplateLiteralTypeSpan(typeToTypeNodeHelper(t, context), (__COND__(i < types.length-1, factory.createTemplateMiddle, factory.createTemplateTail))(texts[i+1]))
			}))
			context.approximateLength += 2
			return factory.createTemplateLiteralType(templateHead, templateSpans)
		}
		if type_.flags & TypeFlagsStringMapping {
			typeNode := typeToTypeNodeHelper((type_ /* as StringMappingType */).type_, context)
			return symbolToTypeNode((type_ /* as StringMappingType */).symbol, context, SymbolFlagsType, []TypeNode{typeNode})
		}
		if type_.flags & TypeFlagsIndexedAccess {
			objectTypeNode := typeToTypeNodeHelper((type_ /* as IndexedAccessType */).objectType, context)
			indexTypeNode := typeToTypeNodeHelper((type_ /* as IndexedAccessType */).indexType, context)
			context.approximateLength += 2
			return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode)
		}
		if type_.flags & TypeFlagsConditional {
			return visitAndTransformType(type_, func(type_ Type) ConditionalTypeNode {
				return conditionalTypeToTypeNode(type_ /* as ConditionalType */)
			})
		}
		if type_.flags & TypeFlagsSubstitution {
			typeNode := typeToTypeNodeHelper((type_ /* as SubstitutionType */).baseType, context)
			noInferSymbol := tc.isNoInferType(type_) && tc.getGlobalTypeSymbol("NoInfer" /* as __String */ /*reportErrors*/, false)
			if noInferSymbol {
				return symbolToTypeNode(noInferSymbol, context, SymbolFlagsType, []TypeNode{typeNode})
			} else {
				return typeNode
			}
		}

		return Debug.fail("Should be unreachable.")

		conditionalTypeToTypeNode := func(type_ ConditionalType) ConditionalTypeNode {
			checkTypeNode := typeToTypeNodeHelper(type_.checkType, context)
			context.approximateLength += 15
			if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.root.isDistributive && !(type_.checkType.flags & TypeFlagsTypeParameter) {
				newParam := tc.createTypeParameter(tc.createSymbol(SymbolFlagsTypeParameter, "T" /* as __String */))
				name := typeParameterToName(newParam, context)
				newTypeVariable := factory.createTypeReferenceNode(name)
				context.approximateLength += 37
				// 15 each for two added conditionals, 7 for an added infer type
				newMapper := tc.prependTypeMapping(type_.root.checkType, newParam, type_.mapper)
				saveInferTypeParameters := context.inferTypeParameters
				context.inferTypeParameters = type_.root.inferTypeParameters
				extendsTypeNode := typeToTypeNodeHelper(tc.instantiateType(type_.root.extendsType, newMapper), context)
				context.inferTypeParameters = saveInferTypeParameters
				trueTypeNode := typeToTypeNodeOrCircularityElision(tc.instantiateType(getTypeFromTypeNode(context, type_.root.node.trueType), newMapper))
				falseTypeNode := typeToTypeNodeOrCircularityElision(tc.instantiateType(getTypeFromTypeNode(context, type_.root.node.falseType), newMapper))

				// outermost conditional makes `T` a type parameter, allowing the inner conditionals to be distributive
				// second conditional makes `T` have `T & checkType` substitution, so it is correctly usable as the checkType
				// inner conditional runs the check the user provided on the check type (distributively) and returns the result
				// checkType extends infer T ? T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never : never;
				// this is potentially simplifiable to
				// checkType extends infer T ? T extends checkType & extendsType<T> ? trueType<T> : falseType<T> : never;
				// but that may confuse users who read the output more.
				// On the other hand,
				// checkType extends infer T extends checkType ? T extends extendsType<T> ? trueType<T> : falseType<T> : never;
				// may also work with `infer ... extends ...` in, but would produce declarations only compatible with the latest TS.
				return factory.createConditionalTypeNode(checkTypeNode, factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* as Identifier */)), factory.createConditionalTypeNode(factory.createTypeReferenceNode(factory.cloneNode(name)), typeToTypeNodeHelper(type_.checkType, context), factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode), factory.createKeywordTypeNode(SyntaxKindNeverKeyword)), factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
			}
			saveInferTypeParameters := context.inferTypeParameters
			context.inferTypeParameters = type_.root.inferTypeParameters
			extendsTypeNode := typeToTypeNodeHelper(type_.extendsType, context)
			context.inferTypeParameters = saveInferTypeParameters
			trueTypeNode := typeToTypeNodeOrCircularityElision(tc.getTrueTypeFromConditionalType(type_))
			falseTypeNode := typeToTypeNodeOrCircularityElision(tc.getFalseTypeFromConditionalType(type_))
			return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode)
		}

		typeToTypeNodeOrCircularityElision := func(type_ Type) TypeNode {
			if type_.flags & TypeFlagsUnion {
				if context.visitedTypes. /* ? */ has(tc.getTypeId(type_)) {
					if !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
						context.encounteredError = true
						context.tracker. /* ? */ reportCyclicStructureError()
					}
					return createElidedInformationPlaceholder(context)
				}
				return visitAndTransformType(type_, func(type_ Type) TypeNode {
					return typeToTypeNodeHelper(type_, context)
				})
			}
			return typeToTypeNodeHelper(type_, context)
		}

		isMappedTypeHomomorphic := func(type_ MappedType) bool {
			return !!tc.getHomomorphicTypeVariable(type_)
		}

		isHomomorphicMappedTypeWithNonHomomorphicInstantiation := func(type_ MappedType) bool {
			return !!type_.target && isMappedTypeHomomorphic(type_.target /* as MappedType */) && !isMappedTypeHomomorphic(type_)
		}

		createMappedTypeNodeFromType := func(type_ MappedType) /* TODO(TS-TO-GO) inferred type MappedTypeNode | ConditionalTypeNode */ any {
			Debug.assert(!!(type_.flags & TypeFlagsObject))
			var readonlyToken * /* TODO(TS-TO-GO) inferred type ReadonlyKeyword | PlusToken | MinusToken */ any
			if type_.declaration.readonlyToken {
				readonlyToken = factory.createToken(type_.declaration.readonlyToken.kind) /* as ReadonlyKeyword | PlusToken | MinusToken */
			} else {
				readonlyToken = nil
			}
			var questionToken * /* TODO(TS-TO-GO) inferred type QuestionToken | PlusToken | MinusToken */ any
			if type_.declaration.questionToken {
				questionToken = factory.createToken(type_.declaration.questionToken.kind) /* as QuestionToken | PlusToken | MinusToken */
			} else {
				questionToken = nil
			}
			var appropriateConstraintTypeNode TypeNode
			var newTypeVariable *TypeReferenceNode
			// If the mapped type isn't `keyof` constraint-declared, _but_ still has modifiers preserved, and its naive instantiation won't preserve modifiers because its constraint isn't `keyof` constrained, we have work to do
			needsModifierPreservingWrapper := !tc.isMappedTypeWithKeyofConstraintDeclaration(type_) && !(tc.getModifiersTypeFromMappedType(type_).flags & TypeFlagsUnknown) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && !(tc.getConstraintTypeFromMappedType(type_).flags&TypeFlagsTypeParameter && tc.getConstraintOfTypeParameter(tc.getConstraintTypeFromMappedType(type_)). /* ? */ flags&TypeFlagsIndex)
			if tc.isMappedTypeWithKeyofConstraintDeclaration(type_) {
				// We have a { [P in keyof T]: X }
				// We do this to ensure we retain the toplevel keyof-ness of the type which may be lost due to keyof distribution during `getConstraintTypeFromMappedType`
				if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
					newParam := tc.createTypeParameter(tc.createSymbol(SymbolFlagsTypeParameter, "T" /* as __String */))
					name := typeParameterToName(newParam, context)
					newTypeVariable = factory.createTypeReferenceNode(name)
				}
				appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(tc.getModifiersTypeFromMappedType(type_), context))
			} else if needsModifierPreservingWrapper {
				// So, step 1: new type variable
				newParam := tc.createTypeParameter(tc.createSymbol(SymbolFlagsTypeParameter, "T" /* as __String */))
				name := typeParameterToName(newParam, context)
				newTypeVariable = factory.createTypeReferenceNode(name)
				// step 2: make that new type variable itself the constraint node, making the mapped type `{[K in T_1]: Template}`
				appropriateConstraintTypeNode = newTypeVariable
			} else {
				appropriateConstraintTypeNode = typeToTypeNodeHelper(tc.getConstraintTypeFromMappedType(type_), context)
			}
			typeParameterNode := typeParameterToDeclarationWithConstraint(tc.getTypeParameterFromMappedType(type_), context, appropriateConstraintTypeNode)
			var nameTypeNode *TypeNode
			if type_.declaration.nameType {
				nameTypeNode = typeToTypeNodeHelper(tc.getNameTypeFromMappedType(type_), context)
			} else {
				nameTypeNode = nil
			}
			templateTypeNode := typeToTypeNodeHelper(tc.removeMissingType(tc.getTemplateTypeFromMappedType(type_), !!(tc.getMappedTypeModifiers(type_)&MappedTypeModifiersIncludeOptional)), context)
			mappedTypeNode := factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode /*members*/, nil)
			context.approximateLength += 10
			result := setEmitFlags(mappedTypeNode, EmitFlagsSingleLine)
			if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
				// homomorphic mapped type with a non-homomorphic naive inlining
				// wrap it with a conditional like `SomeModifiersType extends infer U ? {..the mapped type...} : never` to ensure the resulting
				// type stays homomorphic
				originalConstraint := tc.instantiateType(tc.getConstraintOfTypeParameter(getTypeFromTypeNode(context, (type_.declaration.typeParameter.constraint /* as TypeOperatorNode */).type_) /* as TypeParameter */) || tc.unknownType, type_.mapper)
				return factory.createConditionalTypeNode(typeToTypeNodeHelper(tc.getModifiersTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* as Identifier */, __COND__(originalConstraint.flags&TypeFlagsUnknown, nil, typeToTypeNodeHelper(originalConstraint, context)))), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
			} else if needsModifierPreservingWrapper {
				// and step 3: once the mapped type is reconstructed, create a `ConstraintType extends infer T_1 extends keyof ModifiersType ? {[K in T_1]: Template} : never`
				// subtly different from the `keyof` constraint case, by including the `keyof` constraint on the `infer` type parameter, it doesn't rely on the constraint type being itself
				// constrained to a `keyof` type to preserve its modifier-preserving behavior. This is all basically because we preserve modifiers for a wider set of mapped types than
				// just homomorphic ones.
				return factory.createConditionalTypeNode(typeToTypeNodeHelper(tc.getConstraintTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* as Identifier */, factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, typeToTypeNodeHelper(tc.getModifiersTypeFromMappedType(type_), context)))), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
			}
			return result
		}

		createAnonymousTypeNode := func(type_ ObjectType) TypeNode {
			typeId := type_.id
			symbol := type_.symbol
			if symbol {
				isInstantiationExpressionType := !!(getObjectFlags(type_) & ObjectFlagsInstantiationExpressionType)
				if isInstantiationExpressionType {
					instantiationExpressionType := type_ /* as InstantiationExpressionType */
					existing := instantiationExpressionType.node
					if isTypeQueryNode(existing) {
						typeNode := tryReuseExistingNonParameterTypeNode(context, existing, type_)
						if typeNode {
							return typeNode
						}
					}
					if context.visitedTypes. /* ? */ has(typeId) {
						return createElidedInformationPlaceholder(context)
					}
					return visitAndTransformType(type_, createTypeNodeFromObjectType)
				}
				var isInstanceType /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Type */ any
				if tc.isClassInstanceSide(type_) {
					isInstanceType = SymbolFlagsType
				} else {
					isInstanceType = SymbolFlagsValue
				}
				if tc.isJSConstructor(symbol.valueDeclaration) {
					// Instance and static types share the same symbol; only add 'typeof' for the static side.
					return symbolToTypeNode(symbol, context, isInstanceType)
				} else if symbol.flags&SymbolFlagsClass && !tc.getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || tc.isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible)) || symbol.flags&(SymbolFlagsEnum|SymbolFlagsValueModule) || shouldWriteTypeOfFunctionSymbol() {
					return symbolToTypeNode(symbol, context, isInstanceType)
				} else if context.visitedTypes. /* ? */ has(typeId) {
					// If type is an anonymous type literal in a type alias declaration, use type alias name
					typeAlias := tc.getTypeAliasForTypeLiteral(type_)
					if typeAlias {
						// The specified symbol flags need to be reinterpreted as type flags
						return symbolToTypeNode(typeAlias, context, SymbolFlagsType)
					} else {
						return createElidedInformationPlaceholder(context)
					}
				} else {
					return visitAndTransformType(type_, createTypeNodeFromObjectType)
				}
			} else {
				// Anonymous types without a symbol are never circular.
				return createTypeNodeFromObjectType(type_)
			}
			shouldWriteTypeOfFunctionSymbol := func() *bool {
				isStaticMethodSymbol := !!(symbol.flags & SymbolFlagsMethod) && some(symbol.declarations, func(declaration Declaration) bool {
					return isStatic(declaration)
				})
				isNonLocalFunctionSymbol := !!(symbol.flags & SymbolFlagsFunction) && (symbol.parent || forEach(symbol.declarations, func(declaration Declaration) bool {
					return declaration.parent.kind == SyntaxKindSourceFile || declaration.parent.kind == SyntaxKindModuleBlock
				}))
				if isStaticMethodSymbol || isNonLocalFunctionSymbol {
					// typeof is allowed only for static/non local functions
					return (!!(context.flags & NodeBuilderFlagsUseTypeOfFunction) || (context.visitedTypes. /* ? */ has(typeId))) && (!(context.flags & NodeBuilderFlagsUseStructuralFallback) || tc.isValueSymbolAccessible(symbol, context.enclosingDeclaration))
					// And the build is going to succeed without visibility error or there is no structural fallback allowed
				}
			}

		}

		visitAndTransformType := func(type_ T, transform func(type_ T) TypeNode) TypeNode {
			typeId := type_.id
			isConstructorObject := getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&SymbolFlagsClass
			var id *string
			switch {
			case getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference & T */).node:
				id = "N" + getNodeId((type_ /* as TypeReference & T */).node)
			case type_.flags & TypeFlagsConditional:
				id = "N" + getNodeId((type_ /* as ConditionalType & T */).root.node)
			case type_.symbol:
				id = (__COND__(isConstructorObject, "+", "")) + getSymbolId(type_.symbol)
			default:
				id = nil
			}
			// Since instantiations of the same anonymous type have the same symbol, tracking symbols instead
			// of types allows us to catch circular references to instantiations of the same anonymous type
			if !context.visitedTypes {
				context.visitedTypes = NewSet()
			}
			if id && !context.symbolDepth {
				context.symbolDepth = NewMap()
			}

			links := context.enclosingDeclaration && tc.getNodeLinks(context.enclosingDeclaration)
			key := __TEMPLATE__(tc.getTypeId(type_), "|", context.flags, "|", context.internalFlags)
			if links {
				links.serializedTypes = links.serializedTypes || NewMap()
			}
			cachedResult := links. /* ? */ serializedTypes. /* ? */ get(key)
			if cachedResult {
				// TODO:: check if we instead store late painted statements associated with this?
				cachedResult.trackedSymbols. /* ? */ forEach(func(TODO_IDENTIFIER TrackedSymbol) bool {
					return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
				})
				if cachedResult.truncating {
					context.truncating = true
				}
				context.approximateLength += cachedResult.addedLength
				return deepCloneOrReuseNode(cachedResult.node)
			}

			var depth *number
			if id {
				depth = context.symbolDepth.get(id) || 0
				if depth > 10 {
					return createElidedInformationPlaceholder(context)
				}
				context.symbolDepth.set(id, depth+1)
			}
			context.visitedTypes.add(typeId)
			prevTrackedSymbols := context.trackedSymbols
			context.trackedSymbols = nil
			startLength := context.approximateLength
			result := transform(type_)
			addedLength := context.approximateLength - startLength
			if !context.reportedDiagnostic && !context.encounteredError {
				links. /* ? */ serializedTypes. /* ? */ set(key, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"node":           result,
					"truncating":     context.truncating,
					"addedLength":    addedLength,
					"trackedSymbols": context.trackedSymbols,
				})
			}
			context.visitedTypes.delete(typeId)
			if id {
				context.symbolDepth.set(id, depth)
			}
			context.trackedSymbols = prevTrackedSymbols
			return result

			deepCloneOrReuseNode := func(node T) T {
				if !nodeIsSynthesized(node) && getParseTreeNode(node) == node {
					return node
				}
				return setTextRange(context, factory.cloneNode(visitEachChildWorker(node, deepCloneOrReuseNode /*context*/, nil, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node)
			}

			deepCloneOrReuseNodes := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
				if nodes && nodes.length == 0 {
					// Ensure we explicitly make a copy of an empty array; visitNodes will not do this unless the array has elements,
					// which can lead to us reusing the same empty NodeArray more than once within the same AST during type noding.
					return setTextRangeWorker(factory.createNodeArray(nil, nodes.hasTrailingComma), nodes)
				}
				return visitNodes(nodes, visitor, test, start, count)
			}

		}

		createTypeNodeFromObjectType := func(type_ ObjectType) TypeNode {
			if tc.isGenericMappedType(type_) || (type_ /* as MappedType */).containsError {
				return createMappedTypeNodeFromType(type_ /* as MappedType */)
			}

			resolved := tc.resolveStructuredTypeMembers(type_)
			if !resolved.properties.length && !resolved.indexInfos.length {
				if !resolved.callSignatures.length && !resolved.constructSignatures.length {
					context.approximateLength += 2
					return setEmitFlags(factory.createTypeLiteralNode(nil), EmitFlagsSingleLine)
				}

				if resolved.callSignatures.length == 1 && !resolved.constructSignatures.length {
					signature := resolved.callSignatures[0]
					signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindFunctionType, context) /* as FunctionTypeNode */
					return signatureNode
				}

				if resolved.constructSignatures.length == 1 && !resolved.callSignatures.length {
					signature := resolved.constructSignatures[0]
					signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructorType, context) /* as ConstructorTypeNode */
					return signatureNode
				}
			}

			abstractSignatures := filter(resolved.constructSignatures, func(signature Signature) bool {
				return !!(signature.flags & SignatureFlagsAbstract)
			})
			if some(abstractSignatures) {
				types := map_(abstractSignatures, func(s Signature) ObjectType {
					return tc.getOrCreateTypeFromSignature(s)
				})
				// count the number of type elements excluding abstract constructors
				typeElementCount := resolved.callSignatures.length + (resolved.constructSignatures.length - abstractSignatures.length) + resolved.indexInfos.length + (__COND__(context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral, countWhere(resolved.properties, func(p Symbol) bool {
					return !(p.flags & SymbolFlagsPrototype)
				}), length(resolved.properties)))
				// don't include an empty object literal if there were no other static-side
				// properties to write, i.e. `abstract class C { }` becomes `abstract new () => {}`
				// and not `(abstract new () => {}) & {}`
				if typeElementCount {
					// create a copy of the object type without any abstract construct signatures.
					types.push(tc.getResolvedTypeWithoutAbstractConstructSignatures(resolved))
				}
				return typeToTypeNodeHelper(tc.getIntersectionType(types), context)
			}

			restoreFlags := saveRestoreFlags(context)
			context.flags |= NodeBuilderFlagsInObjectTypeLiteral
			members := createTypeNodesFromResolvedType(resolved)
			restoreFlags()
			typeLiteralNode := factory.createTypeLiteralNode(members)
			context.approximateLength += 2
			setEmitFlags(typeLiteralNode, __COND__((context.flags&NodeBuilderFlagsMultilineObjectLiterals), 0, EmitFlagsSingleLine))
			return typeLiteralNode
		}

		typeReferenceToTypeNode := func(type_ TypeReference) TypeNode {
			var typeArguments []Type = tc.getTypeArguments(type_)
			if type_.target == tc.globalArrayType || type_.target == tc.globalReadonlyArrayType {
				if context.flags & NodeBuilderFlagsWriteArrayAsGenericType {
					typeArgumentNode := typeToTypeNodeHelper(typeArguments[0], context)
					return factory.createTypeReferenceNode(__COND__(type_.target == tc.globalArrayType, "Array", "ReadonlyArray"), []TypeNode{typeArgumentNode})
				}
				elementType := typeToTypeNodeHelper(typeArguments[0], context)
				arrayType := factory.createArrayTypeNode(elementType)
				if type_.target == tc.globalArrayType {
					return arrayType
				} else {
					return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, arrayType)
				}
			} else if type_.target.objectFlags & ObjectFlagsTuple {
				typeArguments = sameMap(typeArguments, func(t Type, i number) Type {
					return tc.removeMissingType(t, !!((type_.target /* as TupleType */).elementFlags[i] & ElementFlagsOptional))
				})
				if typeArguments.length > 0 {
					arity := tc.getTypeReferenceArity(type_)
					tupleConstituentNodes := mapToTypeNodes(typeArguments.slice(0, arity), context)
					if tupleConstituentNodes {
						TODO_IDENTIFIER := type_.target /* as TupleType */
						for i := 0; i < tupleConstituentNodes.length; i++ {
							flags := (type_.target /* as TupleType */).elementFlags[i]
							labeledElementDeclaration := labeledElementDeclarations[i]

							if labeledElementDeclaration {
								tupleConstituentNodes[i] = factory.createNamedTupleMember(__COND__(flags&ElementFlagsVariable, factory.createToken(SyntaxKindDotDotDotToken), nil), factory.createIdentifier(unescapeLeadingUnderscores(tc.getTupleElementLabel(labeledElementDeclaration))), __COND__(flags&ElementFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil), __COND__(flags&ElementFlagsRest, factory.createArrayTypeNode(tupleConstituentNodes[i]), tupleConstituentNodes[i]))
							} else {
								switch {
								case flags & ElementFlagsVariable:
									tupleConstituentNodes[i] = factory.createRestTypeNode(__COND__(flags&ElementFlagsRest, factory.createArrayTypeNode(tupleConstituentNodes[i]), tupleConstituentNodes[i]))
								case flags & ElementFlagsOptional:
									tupleConstituentNodes[i] = factory.createOptionalTypeNode(tupleConstituentNodes[i])
								default:
									tupleConstituentNodes[i] = tupleConstituentNodes[i]
								}
							}
						}
						tupleTypeNode := setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), EmitFlagsSingleLine)
						if (type_.target /* as TupleType */).readonly {
							return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, tupleTypeNode)
						} else {
							return tupleTypeNode
						}
					}
				}
				if context.encounteredError || (context.flags & NodeBuilderFlagsAllowEmptyTuple) {
					tupleTypeNode := setEmitFlags(factory.createTupleTypeNode([]never{}), EmitFlagsSingleLine)
					if (type_.target /* as TupleType */).readonly {
						return factory.createTypeOperatorNode(SyntaxKindReadonlyKeyword, tupleTypeNode)
					} else {
						return tupleTypeNode
					}
				}
				context.encounteredError = true
				return nil
				// TODO: GH#18217
			} else if context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && type_.symbol.valueDeclaration && isClassLike(type_.symbol.valueDeclaration) && !tc.isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
				return createAnonymousTypeNode(type_)
			} else {
				outerTypeParameters := type_.target.outerTypeParameters
				i := 0
				var resultType /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ImportTypeNode | undefined */ any
				if outerTypeParameters {
					length := outerTypeParameters.length
					for i < length {
						// Find group of type arguments for type parameters with the same declaring container.
						start := i
						parent := tc.getParentSymbolOfTypeParameter(outerTypeParameters[i])
						for ok := true; ok; ok = i < length && tc.getParentSymbolOfTypeParameter(outerTypeParameters[i]) == parent { // do-while loop
							i++
						}
						// When type parameters are their own type arguments for the whole group (i.e. we have
						// the default outer type arguments), we don't show the group.
						if !rangeEquals(outerTypeParameters, typeArguments, start, i) {
							typeArgumentSlice := mapToTypeNodes(typeArguments.slice(start, i), context)
							restoreFlags := saveRestoreFlags(context)
							context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
							ref := symbolToTypeNode(parent, context, SymbolFlagsType, typeArgumentSlice) /* as TypeReferenceNode | ImportTypeNode */
							restoreFlags()
							if !resultType {
								resultType = ref
							} else {
								resultType = appendReferenceToType(resultType, ref /* as TypeReferenceNode */)
							}
						}
					}
				}
				var typeArgumentNodes *[]TypeNode
				if typeArguments.length > 0 {
					typeParameterCount := 0
					if type_.target.typeParameters {
						typeParameterCount = Math.min(type_.target.typeParameters.length, typeArguments.length)

						// Maybe we should do this for more types, but for now we only elide type arguments that are
						// identical to their associated type parameters' defaults for `Iterable`, `IterableIterator`,
						// `AsyncIterable`, and `AsyncIterableIterator` to provide backwards-compatible .d.ts emit due
						// to each now having three type parameters instead of only one.
						if tc.isReferenceToType(type_, tc.getGlobalIterableType(false)) || tc.isReferenceToType(type_, tc.getGlobalIterableIteratorType(false)) || tc.isReferenceToType(type_, tc.getGlobalAsyncIterableType(false)) || tc.isReferenceToType(type_, tc.getGlobalAsyncIterableIteratorType(false)) {
							if !type_.node || !isTypeReferenceNode(type_.node) || !type_.node.typeArguments || type_.node.typeArguments.length < typeParameterCount {
								for typeParameterCount > 0 {
									typeArgument := typeArguments[typeParameterCount-1]
									typeParameter := type_.target.typeParameters[typeParameterCount-1]
									defaultType := tc.getDefaultFromTypeParameter(typeParameter)
									if !defaultType || !tc.isTypeIdenticalTo(typeArgument, defaultType) {
										break
									}
									typeParameterCount--
								}
							}
						}
					}

					typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context)
				}
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
				finalRef := symbolToTypeNode(type_.symbol, context, SymbolFlagsType, typeArgumentNodes)
				restoreFlags()
				if !resultType {
					return finalRef
				} else {
					return appendReferenceToType(resultType, finalRef /* as TypeReferenceNode */)
				}
			}
		}

		appendReferenceToType := func(root /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ImportTypeNode */ any, ref TypeReferenceNode) /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ImportTypeNode */ any {
			if isImportTypeNode(root) {
				// first shift type arguments
				typeArguments := root.typeArguments
				qualifier := root.qualifier
				if qualifier {
					if isIdentifier(qualifier) {
						if typeArguments != getIdentifierTypeArguments(qualifier) {
							qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments)
						}
					} else {
						if typeArguments != getIdentifierTypeArguments(qualifier.right) {
							qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments))
						}
					}
				}
				typeArguments = ref.typeArguments
				// then move qualifiers
				ids := getAccessStack(ref)
				for _, id := range ids {
					if qualifier {
						qualifier = factory.createQualifiedName(qualifier, id)
					} else {
						qualifier = id
					}
				}
				return factory.updateImportTypeNode(root, root.argument, root.attributes, qualifier, typeArguments, root.isTypeOf)
			} else {
				// first shift type arguments
				typeArguments := root.typeArguments
				typeName := root.typeName
				if isIdentifier(typeName) {
					if typeArguments != getIdentifierTypeArguments(typeName) {
						typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments)
					}
				} else {
					if typeArguments != getIdentifierTypeArguments(typeName.right) {
						typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments))
					}
				}
				typeArguments = ref.typeArguments
				// then move qualifiers
				ids := getAccessStack(ref)
				for _, id := range ids {
					typeName = factory.createQualifiedName(typeName, id)
				}
				return factory.updateTypeReferenceNode(root, typeName, typeArguments)
			}
		}

		getAccessStack := func(ref TypeReferenceNode) []Identifier {
			state := ref.typeName
			ids := []never{}
			for !isIdentifier(state) {
				ids.unshift(state.right)
				state = state.left
			}
			ids.unshift(state)
			return ids
		}

		createTypeNodesFromResolvedType := func(resolvedType ResolvedType) *[]TypeElement {
			if checkTruncationLength(context) {
				if context.flags & NodeBuilderFlagsNoTruncation {
					return []NotEmittedTypeElement{addSyntheticTrailingComment(factory.createNotEmittedTypeElement(), SyntaxKindMultiLineCommentTrivia, "elided")}
				}
				return []PropertySignature{factory.createPropertySignature(nil, "..." /*questionToken*/, nil /*type*/, nil)}
			}
			var typeElements []TypeElement = []never{}
			for _, signature := range resolvedType.callSignatures {
				typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindCallSignature, context) /* as CallSignatureDeclaration */)
			}
			for _, signature := range resolvedType.constructSignatures {
				if signature.flags & SignatureFlagsAbstract {
					continue
				}
				typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructSignature, context) /* as ConstructSignatureDeclaration */)
			}
			for _, info := range resolvedType.indexInfos {
				typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context, __COND__(resolvedType.objectFlags&ObjectFlagsReverseMapped, createElidedInformationPlaceholder(context), nil)))
			}

			properties := resolvedType.properties
			if !properties {
				return typeElements
			}

			i := 0
			for _, propertySymbol := range properties {
				i++
				if context.flags & NodeBuilderFlagsWriteClassExpressionAsTypeLiteral {
					if propertySymbol.flags & SymbolFlagsPrototype {
						continue
					}
					if getDeclarationModifierFlagsFromSymbol(propertySymbol)&(ModifierFlagsPrivate|ModifierFlagsProtected) && context.tracker.reportPrivateInBaseOfClassExpression {
						context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName))
					}
				}
				if checkTruncationLength(context) && (i+2 < properties.length-1) {
					if context.flags & NodeBuilderFlagsNoTruncation {
						typeElement := typeElements.pop()
						typeElements.push(addSyntheticTrailingComment(typeElement, SyntaxKindMultiLineCommentTrivia, __TEMPLATE__("... ", properties.length-i, " more elided ...")))
					} else {
						typeElements.push(factory.createPropertySignature(nil, __TEMPLATE__("... ", properties.length-i, " more ...") /*questionToken*/, nil /*type*/, nil))
					}
					addPropertyToElementList(properties[properties.length-1], context, typeElements)
					break
				}
				addPropertyToElementList(propertySymbol, context, typeElements)
			}
			if typeElements.length {
				return typeElements
			} else {
				return nil
			}
		}

	}

	createElidedInformationPlaceholder := func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type KeywordTypeNode<SyntaxKind.AnyKeyword> | TypeReferenceNode */ any {
		context.approximateLength += 3
		if !(context.flags & NodeBuilderFlagsNoTruncation) {
			return factory.createTypeReferenceNode(factory.createIdentifier("...") /*typeArguments*/, nil)
		}
		return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, "elided")
	}

	shouldUsePlaceholderForProperty := func(propertySymbol Symbol, context NodeBuilderContext) bool {
		// Use placeholders for reverse mapped types we've either
		// (1) already descended into, or
		// (2) are nested reverse mappings within a mapping over a non-anonymous type, or
		// (3) are deeply nested properties that originate from the same mapped type.
		// Condition (2) is a restriction mostly just to
		// reduce the blowup in printback size from doing, eg, a deep reverse mapping over `Window`.
		// Since anonymous types usually come from expressions, this allows us to preserve the output
		// for deep mappings which likely come from expressions, while truncating those parts which
		// come from mappings over library functions.
		// Condition (3) limits printing of possibly infinitely deep reverse mapped types.
		depth := 3
		return !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped) && (contains(context.reverseMappedStack, propertySymbol /* as ReverseMappedSymbol */) || (context.reverseMappedStack[0] && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlagsAnonymous)) || isDeeplyNestedReverseMappedTypeProperty())
		isDeeplyNestedReverseMappedTypeProperty := func() bool {
			if ( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: context.reverseMappedStack?.length ?? 0 */ TODO) < depth {
				return false
			}
			for i := 0; i < depth; i++ {
				prop := context.reverseMappedStack[context.reverseMappedStack.length-1-i]
				if prop.links.mappedType.symbol != (propertySymbol /* as ReverseMappedSymbol */).links.mappedType.symbol {
					return false
				}
			}
			return true
		}

	}

	addPropertyToElementList := func(propertySymbol Symbol, context NodeBuilderContext, typeElements []TypeElement) {
		propertyIsReverseMapped := !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped)
		var propertyType Type
		if shouldUsePlaceholderForProperty(propertySymbol, context) {
			propertyType = tc.anyType
		} else {
			propertyType = tc.getNonMissingTypeOfSymbol(propertySymbol)
		}
		saveEnclosingDeclaration := context.enclosingDeclaration
		context.enclosingDeclaration = nil
		if context.tracker.canTrackSymbol && tc.isLateBoundName(propertySymbol.escapedName) {
			if propertySymbol.declarations {
				decl := first(propertySymbol.declarations)
				if tc.hasLateBindableName(decl) {
					if isBinaryExpression(decl) {
						name := getNameOfDeclaration(decl)
						if name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression) {
							trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context)
						}
					} else {
						trackComputedName(decl.name.expression, saveEnclosingDeclaration, context)
					}
				}
			} else {
				context.tracker.reportNonSerializableProperty(tc.symbolToString(propertySymbol))
			}
		}
		context.enclosingDeclaration = propertySymbol.valueDeclaration || propertySymbol.declarations[0] || saveEnclosingDeclaration
		propertyName := getPropertyNameNodeForSymbol(propertySymbol, context)
		context.enclosingDeclaration = saveEnclosingDeclaration
		context.approximateLength += symbolName(propertySymbol).length + 1

		if propertySymbol.flags & SymbolFlagsAccessor {
			writeType := tc.getWriteTypeOfSymbol(propertySymbol)
			if propertyType != writeType && !tc.isErrorType(propertyType) && !tc.isErrorType(writeType) {
				getterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindGetAccessor)
				getterSignature := tc.getSignatureFromDeclaration(getterDeclaration)
				typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(getterSignature, SyntaxKindGetAccessor, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"name": propertyName,
				}), /* as GetAccessorDeclaration */ getterDeclaration))
				setterDeclaration := getDeclarationOfKind(propertySymbol, SyntaxKindSetAccessor)
				setterSignature := tc.getSignatureFromDeclaration(setterDeclaration)
				typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(setterSignature, SyntaxKindSetAccessor, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"name": propertyName,
				}), /* as SetAccessorDeclaration */ setterDeclaration))
				return
			}
		}

		var optionalToken * /* TODO(TS-TO-GO) inferred type PunctuationToken<SyntaxKind.QuestionToken> */ any
		if propertySymbol.flags & SymbolFlagsOptional {
			optionalToken = factory.createToken(SyntaxKindQuestionToken)
		} else {
			optionalToken = nil
		}
		if propertySymbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) && !tc.getPropertiesOfObjectType(propertyType).length && !tc.isReadonlySymbol(propertySymbol) {
			signatures := tc.getSignaturesOfType(tc.filterType(propertyType, func(t Type) bool {
				return !(t.flags & TypeFlagsUndefined)
			}), SignatureKindCall)
			for _, signature := range signatures {
				methodDeclaration := signatureToSignatureDeclarationHelper(signature, SyntaxKindMethodSignature, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"name":          propertyName,
					"questionToken": optionalToken,
				}) /* as MethodSignature */
				typeElements.push(preserveCommentsOn(methodDeclaration))
			}
			if signatures.length || !optionalToken {
				return
			}
		}
		var propertyTypeNode TypeNode
		if shouldUsePlaceholderForProperty(propertySymbol, context) {
			propertyTypeNode = createElidedInformationPlaceholder(context)
		} else {
			if propertyIsReverseMapped {
				context.reverseMappedStack = context.reverseMappedStack || []never{}
				context.reverseMappedStack.push(propertySymbol /* as ReverseMappedSymbol */)
			}
			if propertyType {
				propertyTypeNode = serializeTypeForDeclaration(context /*declaration*/, nil, propertyType, propertySymbol)
			} else {
				propertyTypeNode = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			if propertyIsReverseMapped {
				context.reverseMappedStack.pop()
			}
		}

		var modifiers *[] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.ReadonlyKeyword> */ any
		if tc.isReadonlySymbol(propertySymbol) {
			modifiers = [] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.ReadonlyKeyword> */ any{factory.createToken(SyntaxKindReadonlyKeyword)}
		} else {
			modifiers = nil
		}
		if modifiers {
			context.approximateLength += 9
		}
		propertySignature := factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode)

		typeElements.push(preserveCommentsOn(propertySignature))

		preserveCommentsOn := func(node T) T {
			jsdocPropertyTag := propertySymbol.declarations. /* ? */ find(func(d Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: d is JSDocPropertyTag */ any {
				return d.kind == SyntaxKindJSDocPropertyTag
			})
			if jsdocPropertyTag {
				commentText := getTextOfJSDocComment(jsdocPropertyTag.comment)
				if commentText {
					setSyntheticLeadingComments(node, [] /* TODO(TS-TO-GO) inferred type { kind: SyntaxKind.MultiLineCommentTrivia; text: string; pos: -1; end: -1; hasTrailingNewLine: true; } */ any{map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"kind":               SyntaxKindMultiLineCommentTrivia,
						"text":               "*\n * " + commentText.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\n/g */ TODO, "\n * ") + "\n ",
						"pos":                -1,
						"end":                -1,
						"hasTrailingNewLine": true,
					}})
				}
			} else if propertySymbol.valueDeclaration {
				// Copy comments to node for declaration emit
				setCommentRange(context, node, propertySymbol.valueDeclaration)
			}
			return node
		}

	}

	setCommentRange := func(context NodeBuilderContext, node T, range_ Node) T {
		if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(range_) {
			// Copy comments to node for declaration emit
			return setCommentRangeWorker(node, range_)
		}
		return node
	}

	mapToTypeNodes := func(types *[]Type, context NodeBuilderContext, isBareList bool) *[]TypeNode {
		if some(types) {
			if checkTruncationLength(context) {
				if !isBareList {
					return [] /* TODO(TS-TO-GO) inferred type KeywordTypeNode<SyntaxKind.AnyKeyword> | TypeReferenceNode */ any{__COND__(context.flags&NodeBuilderFlagsNoTruncation, addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, "elided"), factory.createTypeReferenceNode("..." /*typeArguments*/, nil))}
				} else if types.length > 2 {
					return []TypeNode{typeToTypeNodeHelper(types[0], context), __COND__(context.flags&NodeBuilderFlagsNoTruncation, addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, __TEMPLATE__("... ", types.length-2, " more elided ...")), factory.createTypeReferenceNode(__TEMPLATE__("... ", types.length-2, " more ...") /*typeArguments*/, nil)), typeToTypeNodeHelper(types[types.length-1], context)}
				}
			}
			mayHaveNameCollisions := !(context.flags & NodeBuilderFlagsUseFullyQualifiedType)
			/** Map from type reference identifier text to [type, index in `result` where the type node is] */

			var seenNames * /* TODO(TS-TO-GO) inferred type MultiMap<__String, [Type, number]> */ any
			if mayHaveNameCollisions {
				seenNames = createMultiMap()
			} else {
				seenNames = nil
			}
			var result []TypeNode = []never{}
			i := 0
			for _, type_ := range types {
				i++
				if checkTruncationLength(context) && (i+2 < types.length-1) {
					result.push(__COND__(context.flags&NodeBuilderFlagsNoTruncation, addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, __TEMPLATE__("... ", types.length-i, " more elided ...")), factory.createTypeReferenceNode(__TEMPLATE__("... ", types.length-i, " more ...") /*typeArguments*/, nil)))
					typeNode := typeToTypeNodeHelper(types[types.length-1], context)
					if typeNode {
						result.push(typeNode)
					}
					break
				}
				context.approximateLength += 2
				// Account for whitespace + separator
				typeNode := typeToTypeNodeHelper(type_, context)
				if typeNode {
					result.push(typeNode)
					if seenNames && isIdentifierTypeReference(typeNode) {
						seenNames.add(typeNode.typeName.escapedText, []any{type_, result.length - 1})
					}
				}
			}

			if seenNames {
				// To avoid printing types like `[Foo, Foo]` or `Bar & Bar` where
				// occurrences of the same name actually come from different
				// namespaces, go through the single-identifier type reference nodes
				// we just generated, and see if any names were generated more than
				// once while referring to different types. If so, regenerate the
				// type node for each entry by that name with the
				// `UseFullyQualifiedType` flag enabled.
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsUseFullyQualifiedType
				seenNames.forEach(func(types [] /* TODO(TS-TO-GO) inferred type [Type, number] */ any) {
					if !arrayIsHomogeneous(types, func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [Type, number] */ any, TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [Type, number] */ any) bool {
						return typesAreSameReference(a, b)
					}) {
						for _, TODO_IDENTIFIER := range types {
							result[resultIndex] = typeToTypeNodeHelper(type_, context)
						}
					}
				})
				restoreFlags()
			}

			return result
		}
	}

	typesAreSameReference := func(a Type, b Type) bool {
		return a == b || !!a.symbol && a.symbol == b.symbol || !!a.aliasSymbol && a.aliasSymbol == b.aliasSymbol
	}

	indexInfoToIndexSignatureDeclarationHelper := func(indexInfo IndexInfo, context NodeBuilderContext, typeNode *TypeNode) IndexSignatureDeclaration {
		name := getNameFromIndexInfo(indexInfo) || "x"
		indexerTypeNode := typeToTypeNodeHelper(indexInfo.keyType, context)

		indexingParameter := factory.createParameterDeclaration(nil, nil, name, nil, indexerTypeNode, nil)
		if !typeNode {
			typeNode = typeToTypeNodeHelper(indexInfo.type_ || tc.anyType, context)
		}
		if !indexInfo.type_ && !(context.flags & NodeBuilderFlagsAllowEmptyIndexInfoType) {
			context.encounteredError = true
		}
		context.approximateLength += name.length + 4
		return factory.createIndexSignature(__COND__(indexInfo.isReadonly, [] /* TODO(TS-TO-GO) inferred type ModifierToken<SyntaxKind.ReadonlyKeyword> */ any{factory.createToken(SyntaxKindReadonlyKeyword)}, nil), []ParameterDeclaration{indexingParameter}, typeNode)
	}

	type SignatureToSignatureDeclarationOptions struct {
		modifiers     []Modifier
		name          PropertyName
		questionToken QuestionToken
	}

	signatureToSignatureDeclarationHelper := func(signature Signature, kind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any, context NodeBuilderContext, options SignatureToSignatureDeclarationOptions) SignatureDeclaration {
		var typeParameters *[]TypeParameterDeclaration
		var typeArguments *[]TypeNode

		expandedParams := tc.getExpandedParameters(signature /*skipUnionExpanding*/, true)[0]
		cleanup := enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper)
		context.approximateLength += 3
		// Usually a signature contributes a few more characters than this, but 3 is the minimum

		if context.flags&NodeBuilderFlagsWriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters {
			typeArguments = signature.target.typeParameters.map_(func(parameter TypeParameter) TypeNode {
				return typeToTypeNodeHelper(tc.instantiateType(parameter, signature.mapper), context)
			})
		} else {
			typeParameters = signature.typeParameters && signature.typeParameters.map_(func(parameter TypeParameter) TypeParameterDeclaration {
				return typeParameterToDeclaration(parameter, context)
			})
		}

		restoreFlags := saveRestoreFlags(context)
		context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
		// If the expanded parameter list had a variadic in a non-trailing position, don't expand it
		parameters := (__COND__(some(expandedParams, func(p Symbol) bool {
			return p != expandedParams[expandedParams.length-1] && !!(getCheckFlags(p) & CheckFlagsRestParameter)
		}), signature.parameters, expandedParams)).map_(func(parameter Symbol) ParameterDeclaration {
			return symbolToParameterDeclaration(parameter, context, kind == SyntaxKindConstructor)
		})
		var thisParameter *ParameterDeclaration
		if context.flags & NodeBuilderFlagsOmitThisParameter {
			thisParameter = nil
		} else {
			thisParameter = tryGetThisParameterDeclaration(signature, context)
		}
		if thisParameter {
			parameters.unshift(thisParameter)
		}
		restoreFlags()

		returnTypeNode := serializeReturnTypeForSignature(context, signature)

		modifiers := options. /* ? */ modifiers
		if (kind == SyntaxKindConstructorType) && signature.flags&SignatureFlagsAbstract {
			flags := modifiersToFlags(modifiers)
			modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlagsAbstract)
		}

		var node /* TODO(TS-TO-GO) inferred type CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | FunctionExpression | ArrowFunction */ any
		switch {
		case kind == SyntaxKindCallSignature:
			node = factory.createCallSignature(typeParameters, parameters, returnTypeNode)
		case kind == SyntaxKindConstructSignature:
			node = factory.createConstructSignature(typeParameters, parameters, returnTypeNode)
		case kind == SyntaxKindMethodSignature:
			node = factory.createMethodSignature(modifiers /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO, options. /* ? */ questionToken, typeParameters, parameters, returnTypeNode)
		case kind == SyntaxKindMethodDeclaration:
			node = factory.createMethodDeclaration(modifiers /*asteriskToken*/, nil /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO /*questionToken*/, nil, typeParameters, parameters, returnTypeNode /*body*/, nil)
		case kind == SyntaxKindConstructor:
			node = factory.createConstructorDeclaration(modifiers, parameters /*body*/, nil)
		case kind == SyntaxKindGetAccessor:
			node = factory.createGetAccessorDeclaration(modifiers /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO, parameters, returnTypeNode /*body*/, nil)
		case kind == SyntaxKindSetAccessor:
			node = factory.createSetAccessorDeclaration(modifiers /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: options?.name ?? factory.createIdentifier("") */, TODO, parameters /*body*/, nil)
		case kind == SyntaxKindIndexSignature:
			node = factory.createIndexSignature(modifiers, parameters, returnTypeNode)
		case kind == SyntaxKindJSDocFunctionType:
			node = factory.createJSDocFunctionType(parameters, returnTypeNode)
		case kind == SyntaxKindFunctionType:
			node = factory.createFunctionTypeNode(typeParameters, parameters /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier("")) */, TODO)
		case kind == SyntaxKindConstructorType:
			node = factory.createConstructorTypeNode(modifiers, typeParameters, parameters /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier("")) */, TODO)
		case kind == SyntaxKindFunctionDeclaration:
			node = factory.createFunctionDeclaration(modifiers /*asteriskToken*/, nil, __COND__(options. /* ? */ name, cast(options.name, isIdentifier), factory.createIdentifier("")), typeParameters, parameters, returnTypeNode /*body*/, nil)
		case kind == SyntaxKindFunctionExpression:
			node = factory.createFunctionExpression(modifiers /*asteriskToken*/, nil, __COND__(options. /* ? */ name, cast(options.name, isIdentifier), factory.createIdentifier("")), typeParameters, parameters, returnTypeNode, factory.createBlock([]never{}))
		case kind == SyntaxKindArrowFunction:
			node = factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode /*equalsGreaterThanToken*/, nil, factory.createBlock([]never{}))
		default:
			node = Debug.assertNever(kind)
		}

		if typeArguments {
			node.typeArguments = factory.createNodeArray(typeArguments)
		}
		if signature.declaration. /* ? */ kind == SyntaxKindJSDocSignature && signature.declaration.parent.kind == SyntaxKindJSDocOverloadTag {
			comment := getTextOfNode(signature.declaration.parent.parent /*includeTrivia*/, true).slice(2, -2).split(regexp.MustParse(`\r\n|\n|\r`)).map_(func(line string) string {
				return line.replace(regexp.MustParse(`^\s+`), " ")
			}).join("\n")
			addSyntheticLeadingComment(node, SyntaxKindMultiLineCommentTrivia, comment /*hasTrailingNewLine*/, true)
		}

		cleanup()
		return node
	}

	type IntroducesNewScopeNode /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature | MappedTypeNode */ any

	isNewScopeNode := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is IntroducesNewScopeNode */ any {
		return isFunctionLike(node) || isJSDocSignature(node) || isMappedTypeNode(node)
	}

	getTypeParametersInScope := func(node /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode */ any) *[]TypeParameter {
		switch {
		case isFunctionLike(node) || isJSDocSignature(node):
			return tc.getSignatureFromDeclaration(node).typeParameters
		case isConditionalTypeNode(node):
			return tc.getInferTypeParameters(node)
		default:
			return []TypeParameter{tc.getDeclaredTypeOfTypeParameter(tc.getSymbolOfDeclaration(node.typeParameter))}
		}
	}

	getParametersInScope := func(node /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode */ any) *[]Symbol {
		if isFunctionLike(node) || isJSDocSignature(node) {
			return tc.getSignatureFromDeclaration(node).parameters
		} else {
			return nil
		}
	}

	enterNewScope := func(context NodeBuilderContext, declaration /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode | undefined */ any, expandedParams *[]Symbol, typeParameters *[]TypeParameter, originalParameters *[]Symbol, mapper TypeMapper) /* TODO(TS-TO-GO) inferred type () => void */ any {
		cleanupContext := cloneNodeBuilderContext(context)
		// For regular function/method declarations, the enclosing declaration will already be signature.declaration,
		// so this is a no-op, but for arrow functions and function expressions, the enclosing declaration will be
		// the declaration that the arrow function / function expression is assigned to.
		//
		// If the parameters or return type include "typeof globalThis.paramName", using the wrong scope will lead
		// us to believe that we can emit "typeof paramName" instead, even though that would refer to the parameter,
		// not the global. Make sure we are in the right scope by changing the enclosingDeclaration to the function.
		//
		// We can't use the declaration directly; it may be in another file and so we may lose access to symbols
		// accessible to the current enclosing declaration, or gain access to symbols not accessible to the current
		// enclosing declaration. To keep this chain accurate, insert a fake scope into the chain which makes the
		// function's parameters visible.
		var cleanupParams *func()
		var cleanupTypeParams *func()
		oldEnclosingDecl := context.enclosingDeclaration
		oldMapper := context.mapper
		if mapper {
			context.mapper = mapper
		}
		if context.enclosingDeclaration && declaration {
			// As a performance optimization, reuse the same fake scope within this chain.
			// This is especially needed when we are working on an excessively deep type;
			// if we don't do this, then we spend all of our time adding more and more
			// scopes that need to be searched in isSymbolAccessible later. Since all we
			// really want to do is to mark certain names as unavailable, we can just keep
			// all of the names we're introducing in one large table and push/pop from it as
			// needed; isSymbolAccessible will walk upward and find the closest "fake" scope,
			// which will conveniently report on any and all faked scopes in the chain.
			//
			// It'd likely be better to store this somewhere else for isSymbolAccessible, but
			// since that API _only_ uses the enclosing declaration (and its parents), this is
			// seems like the best way to inject names into that search process.
			//
			// Note that we only check the most immediate enclosingDeclaration; the only place we
			// could potentially add another fake scope into the chain is right here, so we don't
			// traverse all ancestors.
			if !some(expandedParams) {
				cleanupParams = nil
			} else {
				cleanupParams = pushFakeScope("params", func(add /* TODO(TS-TO-GO) inferred type (name: __String, symbol: Symbol) => void */ any) {
					if !expandedParams {
						return
					}
					for pIndex := 0; pIndex < expandedParams.length; pIndex++ {
						param := expandedParams[pIndex]
						originalParam := originalParameters[pIndex]
						if originalParameters && originalParam != param {
							// Can't reference parameters that come from an expansion
							add(param.escapedName, tc.unknownSymbol)
							// Can't reference the original expanded parameter either
							if originalParam {
								add(originalParam.escapedName, tc.unknownSymbol)
							}
						} else if !forEach(param.declarations, func(d Declaration) *true {
							if isParameter(d) && isBindingPattern(d.name) {
								bindPattern(d.name)
								return true
							}
							return nil
							bindPattern := func(p BindingPattern) {
								forEach(p.elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) {
									switch e.kind {
									case SyntaxKindOmittedExpression:
										return
									case SyntaxKindBindingElement:
										return bindElement(e)
									default:
										return Debug.assertNever(e)
									}
								})
							}

							bindElement := func(e BindingElement) {
								if isBindingPattern(e.name) {
									return bindPattern(e.name)
								}
								symbol := tc.getSymbolOfDeclaration(e)
								add(symbol.escapedName, symbol)
							}

						}) {
							add(param.escapedName, param)
						}
					}
				})
			}

			if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && some(typeParameters) {
				cleanupTypeParams = pushFakeScope("typeParams", func(add /* TODO(TS-TO-GO) inferred type (name: __String, symbol: Symbol) => void */ any) {
					for _, typeParam := range /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: typeParameters ?? emptyArray */ TODO {
						typeParamName := typeParameterToName(typeParam, context).escapedText
						add(typeParamName, typeParam.symbol)
					}
				})
			}

			pushFakeScope := func(kind /* TODO(TS-TO-GO) TypeNode UnionType: "params" | "typeParams" */ any, addAll func(addSymbol func(name __String, symbol Symbol))) * /* TODO(TS-TO-GO) inferred type (() => void) */ any {
				// We only ever need to look two declarations upward.
				Debug.assert(context.enclosingDeclaration)
				var existingFakeScope Node
				if tc.getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration == kind {
					existingFakeScope = context.enclosingDeclaration
				} else if context.enclosingDeclaration.parent && tc.getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration == kind {
					existingFakeScope = context.enclosingDeclaration.parent
				}
				Debug.assertOptionalNode(existingFakeScope, isBlock)

				locals := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: existingFakeScope?.locals ?? createSymbolTable() */ TODO
				var newLocals *[]__String
				var oldLocals *[] /* TODO(TS-TO-GO) TypeNode TypeLiteral: { name: __String; oldSymbol: Symbol; } */ any
				addAll(func(name __String, symbol Symbol) {
					// Add cleanup information only if we don't own the fake scope
					if existingFakeScope {
						oldSymbol := locals.get(name)
						if !oldSymbol {
							newLocals = append(newLocals, name)
						} else {
							oldLocals = append(oldLocals, map[any]any{ /* TODO(TS-TO-GO): was object literal */
								"name":      name,
								"oldSymbol": oldSymbol,
							})
						}
					}
					locals.set(name, symbol)
				})

				if !existingFakeScope {
					// Use a Block for this; the type of the node doesn't matter so long as it
					// has locals, and this is cheaper/easier than using a function-ish Node.
					fakeScope := factory.createBlock(emptyArray)
					tc.getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind
					fakeScope.locals = locals

					setParent(fakeScope, context.enclosingDeclaration)
					context.enclosingDeclaration = fakeScope
				} else {
					// We did not create the current scope, so we have to clean it up
					return func /* undo */ () {
						forEach(newLocals, func(s __String) bool {
							return locals.delete(s)
						})
						forEach(oldLocals, func(s /* TODO(TS-TO-GO) inferred type { name: __String; oldSymbol: Symbol; } */ any) SymbolTable {
							return locals.set(s.name, s.oldSymbol)
						})
					}
				}
			}

		}

		return func() {
			cleanupParams()
			cleanupTypeParams()
			cleanupContext()
			context.enclosingDeclaration = oldEnclosingDecl
			context.mapper = oldMapper
		}
	}

	tryGetThisParameterDeclaration := func(signature Signature, context NodeBuilderContext) *ParameterDeclaration {
		if signature.thisParameter {
			return symbolToParameterDeclaration(signature.thisParameter, context)
		}
		if signature.declaration && isInJSFile(signature.declaration) {
			thisTag := getJSDocThisTag(signature.declaration)
			if thisTag && thisTag.typeExpression {
				return factory.createParameterDeclaration(nil, nil, "this", nil, typeToTypeNodeHelper(getTypeFromTypeNode(context, thisTag.typeExpression), context))
			}
		}
	}

	typeParameterToDeclarationWithConstraint := func(type_ TypeParameter, context NodeBuilderContext, constraintNode *TypeNode) TypeParameterDeclaration {
		restoreFlags := saveRestoreFlags(context)
		context.flags &= ~NodeBuilderFlagsWriteTypeParametersInQualifiedName
		// Avoids potential infinite loop when building for a claimspace with a generic
		modifiers := factory.createModifiersFromModifierFlags(tc.getTypeParameterModifiers(type_))
		name := typeParameterToName(type_, context)
		defaultParameter := tc.getDefaultFromTypeParameter(type_)
		defaultParameterNode := defaultParameter && typeToTypeNodeHelper(defaultParameter, context)
		restoreFlags()
		return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode)
	}

	typeToTypeNodeHelperWithPossibleReusableTypeNode := func(type_ Type, typeNode *TypeNode, context NodeBuilderContext) TypeNode {
		return typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type_) || typeToTypeNodeHelper(type_, context)
	}

	typeParameterToDeclaration := func(type_ TypeParameter, context NodeBuilderContext, constraint Type /*  = getConstraintOfTypeParameter(type) */) TypeParameterDeclaration {
		constraintNode := constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, tc.getConstraintDeclaration(type_), context)
		return typeParameterToDeclarationWithConstraint(type_, context, constraintNode)
	}

	typePredicateToTypePredicateNodeHelper := func(typePredicate TypePredicate, context NodeBuilderContext) TypePredicateNode {
		var assertsModifier * /* TODO(TS-TO-GO) inferred type KeywordToken<SyntaxKind.AssertsKeyword> */ any
		if typePredicate.kind == TypePredicateKindAssertsThis || typePredicate.kind == TypePredicateKindAssertsIdentifier {
			assertsModifier = factory.createToken(SyntaxKindAssertsKeyword)
		} else {
			assertsModifier = nil
		}
		var parameterName /* TODO(TS-TO-GO) inferred type Identifier | ThisTypeNode */ any
		if typePredicate.kind == TypePredicateKindIdentifier || typePredicate.kind == TypePredicateKindAssertsIdentifier {
			parameterName = setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlagsNoAsciiEscaping)
		} else {
			parameterName = factory.createThisTypeNode()
		}
		typeNode := typePredicate.type_ && typeToTypeNodeHelper(typePredicate.type_, context)
		return factory.createTypePredicateNode(assertsModifier, parameterName, typeNode)
	}

	getEffectiveParameterDeclaration := func(parameterSymbol Symbol) /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | undefined */ any {
		var parameterDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | undefined */ any = getDeclarationOfKind(parameterSymbol, SyntaxKindParameter)
		if parameterDeclaration {
			return parameterDeclaration
		}
		if !isTransientSymbol(parameterSymbol) {
			return getDeclarationOfKind(parameterSymbol, SyntaxKindJSDocParameterTag)
		}
	}

	symbolToParameterDeclaration := func(parameterSymbol Symbol, context NodeBuilderContext, preserveModifierFlags bool) ParameterDeclaration {
		parameterDeclaration := getEffectiveParameterDeclaration(parameterSymbol)

		parameterType := tc.getTypeOfSymbol(parameterSymbol)
		parameterTypeNode := serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol)

		var modifiers *[]Modifier
		if !(context.flags & NodeBuilderFlagsOmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) {
			modifiers = map_(getModifiers(parameterDeclaration), factory.cloneNode)
		} else {
			modifiers = nil
		}
		isRest := parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsRestParameter
		var dotDotDotToken * /* TODO(TS-TO-GO) inferred type PunctuationToken<SyntaxKind.DotDotDotToken> */ any
		if isRest {
			dotDotDotToken = factory.createToken(SyntaxKindDotDotDotToken)
		} else {
			dotDotDotToken = nil
		}
		name := parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context)
		isOptional := parameterDeclaration && tc.isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsOptionalParameter
		var questionToken * /* TODO(TS-TO-GO) inferred type PunctuationToken<SyntaxKind.QuestionToken> */ any
		if isOptional {
			questionToken = factory.createToken(SyntaxKindQuestionToken)
		} else {
			questionToken = nil
		}
		parameterNode := factory.createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, nil)
		context.approximateLength += symbolName(parameterSymbol).length + 3
		return parameterNode
	}

	parameterToParameterDeclarationName := func(parameterSymbol Symbol, parameterDeclaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | undefined */ any, context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type string | BindingName */ any {
		switch {
		case parameterDeclaration:
			switch {
			case parameterDeclaration.name:
				switch {
				case parameterDeclaration.name.kind == SyntaxKindIdentifier:
					return setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlagsNoAsciiEscaping)
				case parameterDeclaration.name.kind == SyntaxKindQualifiedName:
					return setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlagsNoAsciiEscaping)
				default:
					return cloneBindingName(parameterDeclaration.name)
				}
			default:
				return symbolName(parameterSymbol)
			}
		default:
			return symbolName(parameterSymbol)
		}

		cloneBindingName := func(node BindingName) BindingName {
			return elideInitializerAndSetEmitFlags(node) /* as BindingName */
			elideInitializerAndSetEmitFlags := func(node Node) Node {
				if context.tracker.canTrackSymbol && isComputedPropertyName(node) && tc.isLateBindableName(node) {
					trackComputedName(node.expression, context.enclosingDeclaration, context)
				}
				visited := visitEachChildWorker(node, elideInitializerAndSetEmitFlags /*context*/, nil /*nodesVisitor*/, nil, elideInitializerAndSetEmitFlags)
				if isBindingElement(visited) {
					visited = factory.updateBindingElement(visited, visited.dotDotDotToken, visited.propertyName, visited.name, nil)
				}
				if !nodeIsSynthesized(visited) {
					visited = factory.cloneNode(visited)
				}
				return setEmitFlags(visited, EmitFlagsSingleLine|EmitFlagsNoAsciiEscaping)
			}

		}

	}

	trackComputedName := func(accessExpression EntityNameOrEntityNameExpression, enclosingDeclaration Node, context NodeBuilderContext) {
		if !context.tracker.canTrackSymbol {
			return
		}
		// get symbol of the first identifier of the entityName
		firstIdentifier := getFirstIdentifier(accessExpression)
		name := tc.resolveName(firstIdentifier, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsExportValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
		if name {
			context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlagsValue)
		}
	}

	lookupSymbolChain := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) []Symbol {
		context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning)
		return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol)
	}

	lookupSymbolChainWorker := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) []Symbol {
		// Try to get qualified name if the symbol is not a type parameter and there is an enclosing declaration.
		var chain []Symbol
		isTypeParameter := symbol.flags & SymbolFlagsTypeParameter
		if !isTypeParameter && (context.enclosingDeclaration || context.flags&NodeBuilderFlagsUseFullyQualifiedType) && !(context.internalFlags & InternalNodeBuilderFlagsDoNotIncludeSymbolChain) {
			chain = Debug.checkDefined(getSymbolChain(symbol, meaning /*endOfChain*/, true))
			Debug.assert(chain && chain.length > 0)
		} else {
			chain = []Symbol{symbol}
		}
		return chain
		/** @param endOfChain Set to false for recursive calls; non-recursive calls should always output something. */

		getSymbolChain := func(symbol Symbol, meaning SymbolFlags, endOfChain bool) *[]Symbol {
			accessibleSymbolChain := tc.getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & NodeBuilderFlagsUseOnlyExternalAliasing))
			var parentSpecifiers []*string
			if !accessibleSymbolChain || tc.needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, __COND__(accessibleSymbolChain.length == 1, meaning, tc.getQualifiedLeftMeaning(meaning))) {
				// Go up and add our parent.
				parents := tc.getContainersOfSymbol(__COND__(accessibleSymbolChain, accessibleSymbolChain[0], symbol), context.enclosingDeclaration, meaning)
				if length(parents) {
					parentSpecifiers = parents.map_(func(symbol Symbol) *string {
						if some(symbol.declarations, tc.hasNonGlobalAugmentationExternalModuleSymbol) {
							return getSpecifierForModuleSymbol(symbol, context)
						} else {
							return nil
						}
					})
					indices := parents.map_(func(_ Symbol, i number) number {
						return i
					})
					indices.sort(sortByBestName)
					sortedParents := indices.map_(func(i number) Symbol {
						return parents[i]
					})
					for _, parent := range sortedParents {
						parentChain := getSymbolChain(parent, tc.getQualifiedLeftMeaning(meaning) /*endOfChain*/, false)
						if parentChain {
							if parent.exports && parent.exports.get(InternalSymbolNameExportEquals) && tc.getSymbolIfSameReference(parent.exports.get(InternalSymbolNameExportEquals), symbol) {
								// parentChain root _is_ symbol - symbol is a module export=, so it kinda looks like it's own parent
								// No need to lookup an alias for the symbol in itself
								accessibleSymbolChain = parentChain
								break
							}
							accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || []Symbol{tc.getAliasForSymbolInContainer(parent, symbol) || symbol})
							break
						}
					}
				}
			}

			if accessibleSymbolChain {
				return accessibleSymbolChain
			}
			if endOfChain || !(symbol.flags & (SymbolFlagsTypeLiteral | SymbolFlagsObjectLiteral)) {
				// If a parent symbol is an external module, don't write it. (We prefer just `x` vs `"foo/bar".x`.)
				if !endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, tc.hasNonGlobalAugmentationExternalModuleSymbol) {
					return
				}
				return []Symbol{symbol}
			}

			sortByBestName := func(a number, b number) number {
				specifierA := parentSpecifiers[a]
				specifierB := parentSpecifiers[b]
				if specifierA && specifierB {
					isBRelative := pathIsRelative(specifierB)
					if pathIsRelative(specifierA) == isBRelative {
						// Both relative or both non-relative, sort by number of parts
						return moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB)
					}
					if isBRelative {
						// A is non-relative, B is relative: prefer A
						return -1
					}
					// A is relative, B is non-relative: prefer B
					return 1
				}
				return 0
			}

		}

	}

	typeParametersToTypeParameterDeclarations := func(symbol Symbol, context NodeBuilderContext) *NodeArray[TypeParameterDeclaration] {
		var typeParameterNodes *NodeArray[TypeParameterDeclaration]
		targetSymbol := tc.getTargetSymbol(symbol)
		if targetSymbol.flags & (SymbolFlagsClass | SymbolFlagsInterface | SymbolFlagsTypeAlias) {
			typeParameterNodes = factory.createNodeArray(map_(tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), func(tp TypeParameter) TypeParameterDeclaration {
				return typeParameterToDeclaration(tp, context)
			}))
		}
		return typeParameterNodes
	}

	lookupTypeParameterNodes := func(chain []Symbol, index number, context NodeBuilderContext) *[] /* TODO(TS-TO-GO) inferred type TypeNode[] | readonly TypeParameterDeclaration */ any {
		Debug.assert(chain && 0 <= index && index < chain.length)
		symbol := chain[index]
		symbolId := getSymbolId(symbol)
		if context.typeParameterSymbolList. /* ? */ has(symbolId) {
			return nil
		}
		if context.mustCreateTypeParameterSymbolList {
			context.mustCreateTypeParameterSymbolList = false
			context.typeParameterSymbolList = NewSet(context.typeParameterSymbolList)
		}
		context.typeParameterSymbolList.add(symbolId)
		var typeParameterNodes /* TODO(TS-TO-GO) TypeNode UnionType: readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined */ any
		if context.flags&NodeBuilderFlagsWriteTypeParametersInQualifiedName && index < (chain.length-1) {
			parentSymbol := symbol
			nextSymbol := chain[index+1]
			if getCheckFlags(nextSymbol) & CheckFlagsInstantiated {
				params := tc.getTypeParametersOfClassOrInterface(__COND__(parentSymbol.flags&SymbolFlagsAlias, tc.resolveAlias(parentSymbol), parentSymbol))
				// NOTE: cast to TransientSymbol should be safe because only TransientSymbol can have CheckFlags.Instantiated
				typeParameterNodes = mapToTypeNodes(map_(params, func(t TypeParameter) Type {
					return tc.getMappedType(t, (nextSymbol /* as TransientSymbol */).links.mapper)
				}), context)
			} else {
				typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context)
			}
		}
		return typeParameterNodes
	}

	/**
	 * Given A[B][C][D], finds A[B]
	 */

	getTopmostIndexedAccessType := func(top IndexedAccessTypeNode) IndexedAccessTypeNode {
		if isIndexedAccessTypeNode(top.objectType) {
			return getTopmostIndexedAccessType(top.objectType)
		}
		return top
	}

	getSpecifierForModuleSymbol := func(symbol Symbol, context NodeBuilderContext, overrideImportMode ResolutionMode) string {
		file := getDeclarationOfKind(symbol, SyntaxKindSourceFile)
		if !file {
			equivalentFileSymbol := firstDefined(symbol.declarations, func(d Declaration) Symbol {
				return tc.getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol)
			})
			if equivalentFileSymbol {
				file = getDeclarationOfKind(equivalentFileSymbol, SyntaxKindSourceFile)
			}
		}
		if file && file.moduleName != nil {
			// Use the amd name if it is available
			return file.moduleName
		}
		if !file {
			if ambientModuleSymbolRegex.test(symbol.escapedName /* as string */) {
				return (symbol.escapedName /* as string */).substring(1, (symbol.escapedName /* as string */).length-1)
			}
		}
		if !context.enclosingFile || !context.tracker.moduleResolverHost {
			// If there's no context declaration, we can't lookup a non-ambient specifier, so we just use the symbol name
			if ambientModuleSymbolRegex.test(symbol.escapedName /* as string */) {
				return (symbol.escapedName /* as string */).substring(1, (symbol.escapedName /* as string */).length-1)
			}
			return getSourceFileOfNode(getNonAugmentationDeclaration(symbol)).fileName
			// A resolver may not be provided for baselines and errors - in those cases we use the fileName in full
		}
		enclosingDeclaration := getOriginalNode(context.enclosingDeclaration)
		var originalModuleSpecifier *StringLiteralLike
		if canHaveModuleSpecifier(enclosingDeclaration) {
			originalModuleSpecifier = tryGetModuleSpecifierFromDeclaration(enclosingDeclaration)
		} else {
			originalModuleSpecifier = nil
		}
		contextFile := context.enclosingFile
		resolutionMode := overrideImportMode || originalModuleSpecifier && host.getModeForUsageLocation(contextFile, originalModuleSpecifier) || contextFile && host.getDefaultResolutionModeForFile(contextFile)
		cacheKey := createModeAwareCacheKey(contextFile.path, resolutionMode)
		links := tc.getSymbolLinks(symbol)
		specifier := links.specifierCache && links.specifierCache.get(cacheKey)
		if !specifier {
			isBundle := !!tc.compilerOptions.outFile
			// For declaration bundles, we need to generate absolute paths relative to the common source dir for imports,
			// just like how the declaration emitter does for the ambient module declarations - we can easily accomplish this
			// using the `baseUrl` compiler option (which we would otherwise never use in declaration emit) and a non-relative
			// specifier preference
			TODO_IDENTIFIER := context.tracker
			var specifierCompilerOptions CompilerOptions
			if isBundle {
				specifierCompilerOptions = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					/* TODO(TS-TO-GO) Node SpreadAssignment: ...compilerOptions */
					"baseUrl": moduleResolverHost.getCommonSourceDirectory(),
				}
			} else {
				specifierCompilerOptions = tc.compilerOptions
			}
			specifier = first(moduleSpecifiers.getModuleSpecifiers(symbol, tc.checker, specifierCompilerOptions, contextFile, moduleResolverHost, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"importModuleSpecifierPreference": __COND__(isBundle, "non-relative", "project-relative"),
				"importModuleSpecifierEnding":     __COND__(isBundle, "minimal", __COND__(resolutionMode == ModuleKindESNext, "js", nil)),
			}, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"overrideImportMode": overrideImportMode,
			}))
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.specifierCache ??= new Map() */ TODO
			links.specifierCache.set(cacheKey, specifier)
		}
		return specifier
	}

	symbolToEntityNameNode := func(symbol Symbol) EntityName {
		identifier := factory.createIdentifier(unescapeLeadingUnderscores(symbol.escapedName))
		if symbol.parent {
			return factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier)
		} else {
			return identifier
		}
	}

	symbolToTypeNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, overrideTypeArguments []TypeNode) TypeNode {
		chain := lookupSymbolChain(symbol, context, meaning, !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope))
		// If we're using aliases outside the current scope, dont bother with the module

		isTypeOf := meaning == SymbolFlagsValue
		if some(chain[0].declarations, tc.hasNonGlobalAugmentationExternalModuleSymbol) {
			// module is root, must use `ImportTypeNode`
			var nonRootParts * /* TODO(TS-TO-GO) inferred type EntityName | IndexedAccessTypeNode */ any
			if chain.length > 1 {
				nonRootParts = createAccessFromSymbolChain(chain, chain.length-1, 1)
			} else {
				nonRootParts = nil
			}
			typeParameterNodes := overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context)
			contextFile := getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration))
			targetFile := getSourceFileOfModule(chain[0])
			var specifier *string
			var attributes *ImportAttributes
			if getEmitModuleResolutionKind(tc.compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(tc.compilerOptions) == ModuleResolutionKindNodeNext {
				// An `import` type directed at an esm format file is only going to resolve in esm mode - set the esm mode assertion
				if targetFile. /* ? */ impliedNodeFormat == ModuleKindESNext && targetFile.impliedNodeFormat != contextFile. /* ? */ impliedNodeFormat {
					specifier = getSpecifierForModuleSymbol(chain[0], context, ModuleKindESNext)
					attributes = factory.createImportAttributes(factory.createNodeArray([]ImportAttribute{factory.createImportAttribute(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral("import"))}))
				}
			}
			if !specifier {
				specifier = getSpecifierForModuleSymbol(chain[0], context)
			}
			if !(context.flags & NodeBuilderFlagsAllowNodeModulesRelativePaths) && getEmitModuleResolutionKind(tc.compilerOptions) != ModuleResolutionKindClassic && specifier.includes("/node_modules/") {
				oldSpecifier := specifier
				if getEmitModuleResolutionKind(tc.compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(tc.compilerOptions) == ModuleResolutionKindNodeNext {
					// We might be able to write a portable import type using a mode override; try specifier generation again, but with a different mode set
					var swappedMode /* TODO(TS-TO-GO) inferred type ModuleKind.CommonJS | ModuleKind.ESNext */ any
					if contextFile. /* ? */ impliedNodeFormat == ModuleKindESNext {
						swappedMode = ModuleKindCommonJS
					} else {
						swappedMode = ModuleKindESNext
					}
					specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode)

					if specifier.includes("/node_modules/") {
						// Still unreachable :(
						specifier = oldSpecifier
					} else {
						attributes = factory.createImportAttributes(factory.createNodeArray([]ImportAttribute{factory.createImportAttribute(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral(__COND__(swappedMode == ModuleKindESNext, "import", "require")))}))
					}
				}

				if !attributes {
					// If ultimately we can only name the symbol with a reference that dives into a `node_modules` folder, we should error
					// since declaration files with these kinds of references are liable to fail when published :(
					context.encounteredError = true
					if context.tracker.reportLikelyUnsafeImportRequiredError {
						context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier)
					}
				}
			}
			lit := factory.createLiteralTypeNode(factory.createStringLiteral(specifier))
			context.approximateLength += specifier.length + 10
			// specifier + import("")
			if !nonRootParts || isEntityName(nonRootParts) {
				if nonRootParts {
					var lastId Identifier
					if isIdentifier(nonRootParts) {
						lastId = nonRootParts
					} else {
						lastId = nonRootParts.right
					}
					setIdentifierTypeArguments(lastId /*typeArguments*/, nil)
				}
				return factory.createImportTypeNode(lit, attributes, nonRootParts /* as EntityName */, typeParameterNodes /* as readonly TypeNode[] */, isTypeOf)
			} else {
				splitNode := getTopmostIndexedAccessType(nonRootParts)
				qualifier := (splitNode.objectType /* as TypeReferenceNode */).typeName
				return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes /* as readonly TypeNode[] */, isTypeOf), splitNode.indexType)
			}
		}

		entityName := createAccessFromSymbolChain(chain, chain.length-1, 0)
		if isIndexedAccessTypeNode(entityName) {
			return entityName
			// Indexed accesses can never be `typeof`
		}
		if isTypeOf {
			return factory.createTypeQueryNode(entityName)
		} else {
			var lastId Identifier
			if isIdentifier(entityName) {
				lastId = entityName
			} else {
				lastId = entityName.right
			}
			lastTypeArgs := getIdentifierTypeArguments(lastId)
			setIdentifierTypeArguments(lastId /*typeArguments*/, nil)
			return factory.createTypeReferenceNode(entityName, lastTypeArgs /* as NodeArray<TypeNode> */)
		}

		createAccessFromSymbolChain := func(chain []Symbol, index number, stopper number) /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | IndexedAccessTypeNode */ any {
			var typeParameterNodes *[] /* TODO(TS-TO-GO) inferred type TypeNode[] | readonly TypeParameterDeclaration */ any
			if index == (chain.length - 1) {
				typeParameterNodes = overrideTypeArguments
			} else {
				typeParameterNodes = lookupTypeParameterNodes(chain, index, context)
			}
			symbol := chain[index]
			parent := chain[index-1]

			var symbolName *string
			if index == 0 {
				context.flags |= NodeBuilderFlagsInInitialEntityName
				symbolName = tc.getNameOfSymbolAsWritten(symbol, context)
				context.approximateLength += (__COND__(symbolName, symbolName.length, 0)) + 1
				context.flags ^= NodeBuilderFlagsInInitialEntityName
			} else {
				if parent && tc.getExportsOfSymbol(parent) {
					exports := tc.getExportsOfSymbol(parent)
					forEachEntry(exports, func(ex Symbol, name __String) *true {
						if tc.getSymbolIfSameReference(ex, symbol) && !tc.isLateBoundName(name) && name != InternalSymbolNameExportEquals {
							symbolName = unescapeLeadingUnderscores(name)
							return true
						}
					})
				}
			}

			if symbolName == nil {
				name := firstDefined(symbol.declarations, getNameOfDeclaration)
				if name && isComputedPropertyName(name) && isEntityName(name.expression) {
					LHS := createAccessFromSymbolChain(chain, index-1, stopper)
					if isEntityName(LHS) {
						return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression))
					}
					return LHS
				}
				symbolName = tc.getNameOfSymbolAsWritten(symbol, context)
			}
			context.approximateLength += symbolName.length + 1

			if !(context.flags & NodeBuilderFlagsForbidIndexedAccessSymbolReferences) && parent && tc.getMembersOfSymbol(parent) && tc.getMembersOfSymbol(parent).get(symbol.escapedName) && tc.getSymbolIfSameReference(tc.getMembersOfSymbol(parent).get(symbol.escapedName), symbol) {
				// Should use an indexed access
				LHS := createAccessFromSymbolChain(chain, index-1, stopper)
				if isIndexedAccessTypeNode(LHS) {
					return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
				} else {
					return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes /* as readonly TypeNode[] */), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
				}
			}

			identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
			if typeParameterNodes {
				setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
			}
			identifier.symbol = symbol

			if index > stopper {
				LHS := createAccessFromSymbolChain(chain, index-1, stopper)
				if !isEntityName(LHS) {
					return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable")
				}
				return factory.createQualifiedName(LHS, identifier)
			}
			return identifier
		}

	}

	typeParameterShadowsOtherTypeParameterInScope := func(escapedName __String, context NodeBuilderContext, type_ TypeParameter) bool {
		result := tc.resolveName(context.enclosingDeclaration, escapedName, SymbolFlagsType /*nameNotFoundMessage*/, nil /*isUse*/, false)
		if result && result.flags&SymbolFlagsTypeParameter {
			return result != type_.symbol
		}
		return false
	}

	typeParameterToName := func(type_ TypeParameter, context NodeBuilderContext) Identifier {
		if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && context.typeParameterNames {
			cached := context.typeParameterNames.get(tc.getTypeId(type_))
			if cached {
				return cached
			}
		}
		result := symbolToName(type_.symbol, context, SymbolFlagsType /*expectsIdentifier*/, true)
		if !(result.kind & SyntaxKindIdentifier) {
			return factory.createIdentifier("(Missing type parameter)")
		}
		decl := type_.symbol. /* ? */ declarations[0]
		if decl && isTypeParameterDeclaration(decl) {
			result = setTextRange(context, result, decl.name)
		}
		if context.flags & NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
			rawtext := result.escapedText /* as string */
			i := context.typeParameterNamesByTextNextNameCount. /* ? */ get(rawtext) || 0
			text := rawtext
			for context.typeParameterNamesByText. /* ? */ has(text) || typeParameterShadowsOtherTypeParameterInScope(text /* as __String */, context, type_) {
				i++
				text = __TEMPLATE__(rawtext, "_", i)
			}
			if text != rawtext {
				typeArguments := getIdentifierTypeArguments(result)
				result = factory.createIdentifier(text)
				setIdentifierTypeArguments(result, typeArguments)
			}
			if context.mustCreateTypeParametersNamesLookups {
				context.mustCreateTypeParametersNamesLookups = false
				context.typeParameterNames = NewMap(context.typeParameterNames)
				context.typeParameterNamesByTextNextNameCount = NewMap(context.typeParameterNamesByTextNextNameCount)
				context.typeParameterNamesByText = NewSet(context.typeParameterNamesByText)
			}
			// avoiding iterations of the above loop turns out to be worth it when `i` starts to get large, so we cache the max
			// `i` we've used thus far, to save work later
			context.typeParameterNamesByTextNextNameCount.set(rawtext, i)
			context.typeParameterNames.set(tc.getTypeId(type_), result)
			context.typeParameterNamesByText.add(text)
		}
		return result
	}

	/* OVERLOAD: function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: true): Identifier; */
	/* OVERLOAD: function symbolToName(symbol: Symbol, context: NodeBuilderContext, meaning: SymbolFlags, expectsIdentifier: false): EntityName; */
	symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier bool) EntityName {
		chain := lookupSymbolChain(symbol, context, meaning)

		if expectsIdentifier && chain.length != 1 && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowQualifiedNameInPlaceOfIdentifier) {
			context.encounteredError = true
		}
		return createEntityNameFromSymbolChain(chain, chain.length-1)

		createEntityNameFromSymbolChain := func(chain []Symbol, index number) EntityName {
			typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
			symbol := chain[index]

			if index == 0 {
				context.flags |= NodeBuilderFlagsInInitialEntityName
			}
			symbolName := tc.getNameOfSymbolAsWritten(symbol, context)
			if index == 0 {
				context.flags ^= NodeBuilderFlagsInInitialEntityName
			}

			identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
			if typeParameterNodes {
				setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
			}
			identifier.symbol = symbol

			if index > 0 {
				return factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index-1), identifier)
			} else {
				return identifier
			}
		}

	}

	symbolToExpression := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) Expression {
		chain := lookupSymbolChain(symbol, context, meaning)

		return createExpressionFromSymbolChain(chain, chain.length-1)

		createExpressionFromSymbolChain := func(chain []Symbol, index number) Expression {
			typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
			symbol := chain[index]

			if index == 0 {
				context.flags |= NodeBuilderFlagsInInitialEntityName
			}
			symbolName := tc.getNameOfSymbolAsWritten(symbol, context)
			if index == 0 {
				context.flags ^= NodeBuilderFlagsInInitialEntityName
			}
			firstChar := symbolName.charCodeAt(0)

			if isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, tc.hasNonGlobalAugmentationExternalModuleSymbol) {
				return factory.createStringLiteral(getSpecifierForModuleSymbol(symbol, context))
			}
			if index == 0 || canUsePropertyAccess(symbolName, tc.languageVersion) {
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
				}
				identifier.symbol = symbol

				if index > 0 {
					return factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index-1), identifier)
				} else {
					return identifier
				}
			} else {
				if firstChar == CharacterCodesopenBracket {
					symbolName = symbolName.substring(1, symbolName.length-1)
					firstChar = symbolName.charCodeAt(0)
				}
				var expression Expression
				if isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlagsEnumMember) {
					expression = factory.createStringLiteral(stripQuotes(symbolName).replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\\./g */ TODO, func(s string) string {
						return s.substring(1)
					}), firstChar == CharacterCodessingleQuote)
				} else if ("" + +symbolName) == symbolName {
					expression = factory.createNumericLiteral(+symbolName)
				}
				if !expression {
					identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
					if typeParameterNodes {
						setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes))
					}
					identifier.symbol = symbol
					expression = identifier
				}
				return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain, index-1), expression)
			}
		}

	}

	isStringNamed := func(d Declaration) bool {
		name := getNameOfDeclaration(d)
		if !name {
			return false
		}
		if isComputedPropertyName(name) {
			type_ := tc.checkExpression(name.expression)
			return !!(type_.flags & TypeFlagsStringLike)
		}
		if isElementAccessExpression(name) {
			type_ := tc.checkExpression(name.argumentExpression)
			return !!(type_.flags & TypeFlagsStringLike)
		}
		return isStringLiteral(name)
	}

	isSingleQuotedStringNamed := func(d Declaration) bool {
		name := getNameOfDeclaration(d)
		return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name /*includeTrivia*/, false), "'")))
	}

	getPropertyNameNodeForSymbol := func(symbol Symbol, context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type StringLiteral | Identifier | NumericLiteral | ComputedPropertyName */ any {
		stringNamed := !!length(symbol.declarations) && every(symbol.declarations, isStringNamed)
		singleQuote := !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed)
		isMethod := !!(symbol.flags & SymbolFlagsMethod)
		fromNameType := getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod)
		if fromNameType {
			return fromNameType
		}
		rawName := unescapeLeadingUnderscores(symbol.escapedName)
		return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(tc.compilerOptions), singleQuote, stringNamed, isMethod)
	}

	// See getNameForSymbolFromNameType for a stringy equivalent
	getPropertyNameNodeForSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext, singleQuote bool, stringNamed bool, isMethod bool) * /* TODO(TS-TO-GO) inferred type StringLiteral | Identifier | NumericLiteral | ComputedPropertyName */ any {
		nameType := tc.getSymbolLinks(symbol).nameType
		if nameType {
			if nameType.flags & TypeFlagsStringOrNumberLiteral {
				name := "" + (nameType /* as StringLiteralType | NumberLiteralType */).value
				if !isIdentifierText(name, getEmitScriptTarget(tc.compilerOptions)) && (stringNamed || !isNumericLiteralName(name)) {
					return factory.createStringLiteral(name, !!singleQuote)
				}
				if isNumericLiteralName(name) && startsWith(name, "-") {
					return factory.createComputedPropertyName(factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-name)))
				}
				return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(tc.compilerOptions), singleQuote, stringNamed, isMethod)
			}
			if nameType.flags & TypeFlagsUniqueESSymbol {
				return factory.createComputedPropertyName(symbolToExpression((nameType /* as UniqueESSymbolType */).symbol, context, SymbolFlagsValue))
			}
		}
	}

	cloneNodeBuilderContext := func(context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type () => void */ any {
		// Make type parameters created within this context not consume the name outside this context
		// The symbol serializer ends up creating many sibling scopes that all need "separate" contexts when
		// it comes to naming things - within a normal `typeToTypeNode` call, the node builder only ever descends
		// through the type tree, so the only cases where we could have used distinct sibling scopes was when there
		// were multiple generic overloads with similar generated type parameter names
		// The effect:
		// When we write out
		// export const x: <T>(x: T) => T
		// export const y: <T>(x: T) => T
		// we write it out like that, rather than as
		// export const x: <T>(x: T) => T
		// export const y: <T_1>(x: T_1) => T_1
		oldMustCreateTypeParameterSymbolList := context.mustCreateTypeParameterSymbolList
		oldMustCreateTypeParametersNamesLookups := context.mustCreateTypeParametersNamesLookups
		context.mustCreateTypeParameterSymbolList = true
		context.mustCreateTypeParametersNamesLookups = true
		oldTypeParameterNames := context.typeParameterNames
		oldTypeParameterNamesByText := context.typeParameterNamesByText
		oldTypeParameterNamesByTextNextNameCount := context.typeParameterNamesByTextNextNameCount
		oldTypeParameterSymbolList := context.typeParameterSymbolList
		return func() {
			context.typeParameterNames = oldTypeParameterNames
			context.typeParameterNamesByText = oldTypeParameterNamesByText
			context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount
			context.typeParameterSymbolList = oldTypeParameterSymbolList
			context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList
			context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups
		}
	}

	getDeclarationWithTypeAnnotation := func(symbol Symbol, enclosingDeclaration Node) Declaration {
		return symbol.declarations && find(symbol.declarations, func(s Declaration) bool {
			return !!tc.getNonlocalEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, func(n Node) bool {
				return n == enclosingDeclaration
			}))
		})
	}

	existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount := func(existing TypeNode, type_ Type) bool {
		// In JS, you can say something like `Foo` and get a `Foo<any>` implicitly - we don't want to preserve that original `Foo` in these cases, though.
		if !(getObjectFlags(type_) & ObjectFlagsReference) {
			return true
		}
		if !isTypeReferenceNode(existing) {
			return true
		}
		// `type` is a reference type, and `existing` is a type reference node, but we still need to make sure they refer to the _same_ target type
		// before we go comparing their type argument counts.
		tc.getTypeFromTypeReference(existing)
		// call to ensure symbol is resolved
		symbol := tc.getNodeLinks(existing).resolvedSymbol
		existingTarget := symbol && tc.getDeclaredTypeOfSymbol(symbol)
		if !existingTarget || existingTarget != (type_ /* as TypeReference */).target {
			return true
		}
		return length(existing.typeArguments) >= tc.getMinTypeArgumentCount((type_ /* as TypeReference */).target.typeParameters)
	}

	getEnclosingDeclarationIgnoringFakeScope := func(enclosingDeclaration Node) Node {
		for tc.getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration {
			enclosingDeclaration = enclosingDeclaration.parent
		}
		return enclosingDeclaration
	}

	/**
	 * Unlike `typeToTypeNodeHelper`, this handles setting up the `AllowUniqueESSymbolType` flag
	 * so a `unique symbol` is returned when appropriate for the input symbol, rather than `typeof sym`
	 * @param context - The node builder context. Any reused nodes are checked to be pulled from within the scope of the context's enclosingDeclaration.
	 * @param declaration - The preferred declaration to pull existing type nodes from (the symbol will be used as a fallback to find any annotated declaration)
	 * @param type - The type to write; an existing annotation must match this type if it's used, otherwise this is the type serialized as a new type node
	 * @param symbol - The symbol is used both to find an existing annotation if declaration is not provided, and to determine if `unique symbol` should be printed
	 */

	serializeTypeForDeclaration := func(context NodeBuilderContext, declaration Declaration, type_ Type, symbol Symbol) TypeNode {
		addUndefinedForParameter := declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && tc.requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration)
		enclosingDeclaration := context.enclosingDeclaration
		restoreFlags := saveRestoreFlags(context)
		if declaration && hasInferredType(declaration) && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
			tc.syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, context)
		}
		context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
		if enclosingDeclaration && (!tc.isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) {
			var declWithExistingAnnotation Declaration
			if declaration && tc.getNonlocalEffectiveTypeAnnotationNode(declaration) {
				declWithExistingAnnotation = declaration
			} else {
				declWithExistingAnnotation = getDeclarationWithTypeAnnotation(symbol)
			}
			if declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation) {
				// try to reuse the existing annotation
				existing := tc.getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)
				// explicitly add `| undefined` to optional mapped properties whose type contains `undefined` (and not `missing`)
				addUndefined := addUndefinedForParameter || !!(symbol.flags&SymbolFlagsProperty && symbol.flags&SymbolFlagsOptional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol /* as MappedSymbol */).links. /* ? */ mappedType && tc.containsNonMissingUndefinedType(type_))
				result := !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type_, declWithExistingAnnotation, addUndefined)
				if result {
					restoreFlags()
					return result
				}
			}
		}
		if type_.flags&TypeFlagsUniqueESSymbol && type_.symbol == symbol && (!context.enclosingDeclaration || some(symbol.declarations, func(d Declaration) bool {
			return getSourceFileOfNode(d) == getSourceFileOfNode(context.enclosingDeclaration)
		})) {
			context.flags |= NodeBuilderFlagsAllowUniqueESSymbolType
		}

		decl := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0] */ TODO
		var expr Expression
		if decl && tc.isDeclarationWithPossibleInnerTypeNodeReuse(decl) {
			expr = tc.getPossibleTypeNodeReuseExpression(decl)
		} else {
			expr = nil
		}

		result := expressionOrTypeToTypeNode(context, expr, type_, addUndefinedForParameter)
		restoreFlags()
		return result
	}

	typeNodeIsEquivalentToType := func(annotatedDeclaration Node, type_ Type, typeFromTypeNode Type) bool {
		if typeFromTypeNode == type_ {
			return true
		}
		if annotatedDeclaration && (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken {
			return tc.getTypeWithFacts(type_, TypeFactsNEUndefined) == typeFromTypeNode
		}
		return false
	}

	serializeReturnTypeForSignature := func(context NodeBuilderContext, signature Signature) *TypeNode {
		suppressAny := context.flags & NodeBuilderFlagsSuppressAnyReturnType
		restoreFlags := saveRestoreFlags(context)
		if suppressAny {
			context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
			// suppress only toplevel `any`s
		}
		// suppress only toplevel `any`s
		var returnTypeNode *TypeNode
		returnType := tc.getReturnTypeOfSignature(signature)
		if returnType && !(suppressAny && tc.isTypeAny(returnType)) {
			if signature.declaration && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				tc.syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, context)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature)
		} else if !suppressAny {
			returnTypeNode = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
		}
		restoreFlags()
		return returnTypeNode
	}

	serializeReturnTypeForSignatureWorker := func(context NodeBuilderContext, signature Signature) TypeNode {
		typePredicate := tc.getTypePredicateOfSignature(signature)
		type_ := tc.getReturnTypeOfSignature(signature)
		if context.enclosingDeclaration && (!tc.isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) && signature.declaration && !nodeIsSynthesized(signature.declaration) {
			annotation := tc.getNonlocalEffectiveReturnTypeAnnotationNode(signature.declaration)
			if annotation {
				result := tryReuseExistingTypeNode(context, annotation, type_, context.enclosingDeclaration)
				if result {
					return result
				}
			}
		}
		if typePredicate {
			return typePredicateToTypePredicateNodeHelper(typePredicate, context)
		}
		expr := signature.declaration && tc.getPossibleTypeNodeReuseExpression(signature.declaration)
		return expressionOrTypeToTypeNode(context, expr, type_)
	}

	trackExistingEntityName := func(node T, context NodeBuilderContext) /* TODO(TS-TO-GO) inferred type { introducesError: boolean; node: T; sym?: undefined; } | { introducesError: boolean; node: T; sym: Symbol | undefined; } */ any {
		introducesError := false
		leftmost := getFirstIdentifier(node)
		if isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) {
			introducesError = true
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"introducesError": introducesError,
				"node":            node,
			}
		}
		meaning := tc.getMeaningOfEntityNameReference(node)
		var sym Symbol
		if isThisIdentifier(leftmost) {
			// `this` isn't a bindable identifier - skip resolution, find a relevant `this` symbol directly and avoid exhaustive scope traversal
			sym = tc.getSymbolOfDeclaration(getThisContainer(leftmost /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false))
			if tc.isSymbolAccessible(sym, leftmost, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible {
				introducesError = true
				context.tracker.reportInaccessibleThisError()
			}
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"introducesError": introducesError,
				"node":            attachSymbolToLeftmostIdentifier(node), /* as T */
			}
		}
		sym = tc.resolveEntityName(leftmost, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true)
		if context.enclosingDeclaration && !(sym && sym.flags&SymbolFlagsTypeParameter) {
			sym = tc.getExportSymbolOfValueSymbolIfExported(sym)
			// Some declarations may be transplanted to a new location.
			// When this happens we need to make sure that the name has the same meaning at both locations
			// We also check for the unknownSymbol because when we create a fake scope some parameters may actually not be usable
			// either because they are the expanded rest parameter,
			// or because they are the newly added parameters from the tuple, which might have different meanings in the original context
			symAtLocation := tc.resolveEntityName(leftmost, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true, context.enclosingDeclaration)
			if symAtLocation == tc.unknownSymbol || (symAtLocation == nil && sym != nil) || (symAtLocation && sym && !tc.getSymbolIfSameReference(tc.getExportSymbolOfValueSymbolIfExported(symAtLocation), sym)) {
				// In isolated declaration we will not do rest parameter expansion so there is no need to report on these.
				if symAtLocation != tc.unknownSymbol {
					context.tracker.reportInferenceFallback(node)
				}
				introducesError = true
				return map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"introducesError": introducesError,
					"node":            node,
					"sym":             sym,
				}
			} else {
				sym = symAtLocation
			}
		}

		if sym {
			// If a parameter is resolvable in the current context it is also visible, so no need to go to symbol accesibility
			if sym.flags&SymbolFlagsFunctionScopedVariable && sym.valueDeclaration {
				if isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration) {
					return map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"introducesError": introducesError,
						"node":            attachSymbolToLeftmostIdentifier(node), /* as T */
					}
				}
			}
			if !(sym.flags & SymbolFlagsTypeParameter) && !isDeclarationName(node) && tc.isSymbolAccessible(sym, context.enclosingDeclaration, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible {
				context.tracker.reportInferenceFallback(node)
				introducesError = true
			} else {
				context.tracker.trackSymbol(sym, context.enclosingDeclaration, meaning)
			}
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"introducesError": introducesError,
				"node":            attachSymbolToLeftmostIdentifier(node), /* as T */
			}
		}

		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"introducesError": introducesError,
			"node":            node,
		}
		/**
		 * Attaches a `.symbol` member to an identifier, cloning it to do so, so symbol information
		 * is smuggled out for symbol display information.
		 */

		attachSymbolToLeftmostIdentifier := func(node Node) Node {
			if node == leftmost {
				type_ := tc.getDeclaredTypeOfSymbol(sym)
				var name Identifier
				if sym.flags & SymbolFlagsTypeParameter {
					name = typeParameterToName(type_, context)
				} else {
					name = factory.cloneNode(node /* as Identifier */)
				}
				name.symbol = sym
				// for quickinfo, which uses identifier symbol information
				return setTextRange(context, setEmitFlags(name, EmitFlagsNoAsciiEscaping), node)
			}
			updated := visitEachChildWorker(node, func(c Node) Node {
				return attachSymbolToLeftmostIdentifier(c)
			}, /*context*/ nil)
			if updated != node {
				setTextRange(context, updated, node)
			}
			return updated
		}

	}

	serializeTypeName := func(context NodeBuilderContext, node EntityName, isTypeOf bool, typeArguments []TypeNode) *TypeNode {
		var meaning /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Type */ any
		if isTypeOf {
			meaning = SymbolFlagsValue
		} else {
			meaning = SymbolFlagsType
		}
		symbol := tc.resolveEntityName(node, meaning /*ignoreErrors*/, true)
		if !symbol {
			return nil
		}
		var resolvedSymbol Symbol
		if symbol.flags & SymbolFlagsAlias {
			resolvedSymbol = tc.resolveAlias(symbol)
		} else {
			resolvedSymbol = symbol
		}
		if tc.isSymbolAccessible(symbol, context.enclosingDeclaration, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility != SymbolAccessibilityAccessible {
			return nil
		}
		return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments)
	}

	canReuseTypeNode := func(context NodeBuilderContext, existing TypeNode) /* TODO(TS-TO-GO) inferred type number | boolean */ any {
		if isInJSFile(existing) {
			if isLiteralImportTypeNode(existing) {
				// Ensure resolvedSymbol is present
				tc.getTypeFromImportTypeNode(existing)
				nodeSymbol := tc.getNodeLinks(existing).resolvedSymbol
				return (!nodeSymbol || !((!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(existing.typeArguments) >= tc.getMinTypeArgumentCount(tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))))
			}
		}
		if isThisTypeNode(existing) {
			if context.mapper == nil {
				return true
			}
			type_ := getTypeFromTypeNode(context, existing /*noMappedTypes*/, true)
			return !!type_
		}
		if isTypeReferenceNode(existing) {
			if isConstTypeReference(existing) {
				return false
			}
			type_ := tc.getTypeFromTypeReference(existing)
			symbol := tc.getNodeLinks(existing).resolvedSymbol
			if !symbol {
				return false
			}
			if symbol.flags & SymbolFlagsTypeParameter {
				type_ := tc.getDeclaredTypeOfSymbol(symbol)
				if context.mapper && tc.getMappedType(type_, context.mapper) != type_ {
					return false
				}
			}
			if isInJSDoc(existing) {
				return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) && !tc.getIntendedTypeFromJSDocTypeReference(existing) && (symbol.flags & SymbolFlagsType)
				// JSDoc type annotations can reference values (meaning typeof value) as well as types. We only reuse type nodes
			}
		}
		if isTypeOperatorNode(existing) && existing.operator == SyntaxKindUniqueKeyword && existing.type_.kind == SyntaxKindSymbolKeyword {
			effectiveEnclosingContext := context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration)
			return !!findAncestor(existing, func(n Node) bool {
				return n == effectiveEnclosingContext
			})
		}
		return true
	}

	serializeExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode) TypeNode {
		type_ := getTypeFromTypeNode(context, typeNode)
		return typeToTypeNodeHelper(type_, context)
	}

	/**
	 * Do you mean to call this directly? You probably should use `tryReuseExistingTypeNode` instead,
	 * which performs sanity checking on the type before doing this.
	 */

	tryReuseExistingTypeNodeHelper := func(context NodeBuilderContext, existing TypeNode) *TypeNode {
		if tc.cancellationToken && tc.cancellationToken.throwIfCancellationRequested {
			tc.cancellationToken.throwIfCancellationRequested()
		}
		hadError := false
		TODO_IDENTIFIER := createRecoveryBoundary()
		transformed := visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode)
		if !finalizeBoundary() {
			return nil
		}
		context.approximateLength += existing.end - existing.pos
		return transformed

		visitExistingNodeTreeSymbols := func(node Node) Node {
			// If there was an error in a sibling node bail early, the result will be discarded anyway
			if hadError {
				return node
			}
			recover := startRecoveryScope()
			var onExitNewScope * /* TODO(TS-TO-GO) inferred type (() => void) */ any
			if isNewScopeNode(node) {
				onExitNewScope = onEnterNewScope(node)
			} else {
				onExitNewScope = nil
			}
			result := visitExistingNodeTreeSymbolsWorker(node)
			onExitNewScope()

			// If there was an error, maybe we can recover by serializing the actual type of the node
			if hadError {
				if isTypeNode(node) && !isTypePredicateNode(node) {
					recover()
					return serializeExistingTypeNode(context, node)
				}
				return node
			}
			// We want to clone the subtree, so when we mark it up with __pos and __end in quickfixes,
			//  we don't get odd behavior because of reused nodes. We also need to clone to _remove_
			//  the position information if the node comes from a different file than the one the node builder
			//  is set to build for (even though we are reusing the node structure, the position information
			//  would make the printer print invalid spans for literals and identifiers, and the formatter would
			//  choke on the mismatched positonal spans between a parent and an injected child from another file).
			if result {
				return setTextRange(context, result, node)
			} else {
				return nil
			}
		}

		createRecoveryBoundary := func() /* TODO(TS-TO-GO) inferred type { startRecoveryScope: () => () => void; finalizeBoundary: () => boolean; } */ any {
			var trackedSymbols []TrackedSymbol
			var unreportedErrors []func()
			oldTracker := context.tracker
			oldTrackedSymbols := context.trackedSymbols
			context.trackedSymbols = nil
			oldEncounteredError := context.encounteredError
			context.tracker = NewSymbolTrackerImpl(context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
				/* TODO(TS-TO-GO) Node SpreadAssignment: ...oldTracker.inner */
				"reportCyclicStructureError": func() {
					markError(func() {
						return oldTracker.reportCyclicStructureError()
					})
				},
				"reportInaccessibleThisError": func() {
					markError(func() {
						return oldTracker.reportInaccessibleThisError()
					})
				},
				"reportInaccessibleUniqueSymbolError": func() {
					markError(func() {
						return oldTracker.reportInaccessibleUniqueSymbolError()
					})
				},
				"reportLikelyUnsafeImportRequiredError": func(specifier string) {
					markError(func() {
						return oldTracker.reportLikelyUnsafeImportRequiredError(specifier)
					})
				},
				"reportNonSerializableProperty": func(name string) {
					markError(func() {
						return oldTracker.reportNonSerializableProperty(name)
					})
				},
				"trackSymbol": func(sym Symbol, decl Node, meaning SymbolFlags) false {
					( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: trackedSymbols ??= [] */ TODO).push([]any{sym, decl, meaning})
					return false
				},
				"moduleResolverHost": context.tracker.moduleResolverHost,
			}, context.tracker.moduleResolverHost)

			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"startRecoveryScope": startRecoveryScope,
				"finalizeBoundary":   finalizeBoundary,
			}

			markError := func(unreportedError func()) {
				hadError = true
				( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: unreportedErrors ??= [] */ TODO).push(unreportedError)
			}

			startRecoveryScope := func() /* TODO(TS-TO-GO) inferred type () => void */ any {
				trackedSymbolsTop := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: trackedSymbols?.length ?? 0 */ TODO
				unreportedErrorsTop := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: unreportedErrors?.length ?? 0 */ TODO
				return func() {
					hadError = false
					// Reset the tracked symbols to before the error
					if trackedSymbols {
						trackedSymbols.length = trackedSymbolsTop
					}
					if unreportedErrors {
						unreportedErrors.length = unreportedErrorsTop
					}
				}
			}

			finalizeBoundary := func() bool {
				context.tracker = oldTracker
				context.trackedSymbols = oldTrackedSymbols
				context.encounteredError = oldEncounteredError

				unreportedErrors. /* ? */ forEach(func(fn /* TODO(TS-TO-GO) inferred type () => void */ any) {
					return fn()
				})
				if hadError {
					return false
				}
				trackedSymbols. /* ? */ forEach(func(TODO_IDENTIFIER TrackedSymbol) bool {
					return context.tracker.trackSymbol(symbol, enclosingDeclaration, meaning)
				})
				return true
			}

		}

		onEnterNewScope := func(node /* TODO(TS-TO-GO) TypeNode UnionType: IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(TS-TO-GO) inferred type () => void */ any {
			return enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node))
		}

		tryVisitSimpleTypeNode := func(node TypeNode) *TypeNode {
			innerNode := skipTypeParentheses(node)
			switch innerNode.kind {
			case SyntaxKindTypeReference:
				return tryVisitTypeReference(innerNode /* as TypeReferenceNode */)
			case SyntaxKindTypeQuery:
				return tryVisitTypeQuery(innerNode /* as TypeQueryNode */)
			case SyntaxKindIndexedAccessType:
				return tryVisitIndexedAccess(innerNode /* as IndexedAccessTypeNode */)
			case SyntaxKindTypeOperator:
				typeOperatorNode := innerNode /* as TypeOperatorNode */
				if typeOperatorNode.operator == SyntaxKindKeyOfKeyword {
					return tryVisitKeyOf(typeOperatorNode)
				}
			}
			return visitNode(node, visitExistingNodeTreeSymbols, isTypeNode)
		}

		tryVisitIndexedAccess := func(node IndexedAccessTypeNode) *TypeNode {
			resultObjectType := tryVisitSimpleTypeNode(node.objectType)
			if resultObjectType == nil {
				return nil
			}
			return factory.updateIndexedAccessTypeNode(node, resultObjectType, visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode))
		}

		tryVisitKeyOf := func(node TypeOperatorNode) *TypeNode {
			Debug.assertEqual(node.operator, SyntaxKindKeyOfKeyword)
			type_ := tryVisitSimpleTypeNode(node.type_)
			if type_ == nil {
				return nil
			}
			return factory.updateTypeOperatorNode(node, type_)
		}

		tryVisitTypeQuery := func(node TypeQueryNode) *TypeNode {
			TODO_IDENTIFIER := trackExistingEntityName(node.exprName, context)
			if !introducesError {
				return factory.updateTypeQueryNode(node, exprName, visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode))
			}

			serializedName := serializeTypeName(context, node.exprName /*isTypeOf*/, true)
			if serializedName {
				return setTextRange(context, serializedName, node.exprName)
			}
		}

		tryVisitTypeReference := func(node TypeReferenceNode) *TypeNode {
			if canReuseTypeNode(context, node) {
				TODO_IDENTIFIER := trackExistingEntityName(node.typeName, context)
				typeArguments := visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode)

				if !introducesError {
					updated := factory.updateTypeReferenceNode(node, newName, typeArguments)
					return setTextRange(context, updated, node)
				} else {
					serializedName := serializeTypeName(context, node.typeName /*isTypeOf*/, false, typeArguments)
					if serializedName {
						return setTextRange(context, serializedName, node.typeName)
					}
				}
			}
		}

		visitExistingNodeTreeSymbolsWorker := func(node Node) Node {
			if isJSDocTypeExpression(node) {
				// Unwrap JSDocTypeExpressions
				return visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode)
			}
			// We don't _actually_ support jsdoc namepath types, emit `any` instead
			if isJSDocAllType(node) || node.kind == SyntaxKindJSDocNamepathType {
				return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			if isJSDocUnknownType(node) {
				return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
			}
			if isJSDocNullableType(node) {
				return factory.createUnionTypeNode([]TypeNode{visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode), factory.createLiteralTypeNode(factory.createNull())})
			}
			if isJSDocOptionalType(node) {
				return factory.createUnionTypeNode([]TypeNode{visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode), factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)})
			}
			if isJSDocNonNullableType(node) {
				return visitNode(node.type_, visitExistingNodeTreeSymbols)
			}
			if isJSDocVariadicType(node) {
				return factory.createArrayTypeNode(visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
			}
			if isJSDocTypeLiteral(node) {
				return factory.createTypeLiteralNode(map_(node.jsDocPropertyTags, func(t JSDocPropertyLikeTag) PropertySignature {
					name := visitNode(__COND__(isIdentifier(t.name), t.name, t.name.right), visitExistingNodeTreeSymbols, isIdentifier)
					typeViaParent := tc.getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.escapedText)
					var overrideTypeNode *TypeNode
					if typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type_) != typeViaParent {
						overrideTypeNode = typeToTypeNodeHelper(typeViaParent, context)
					} else {
						overrideTypeNode = nil
					}

					return factory.createPropertySignature(nil, name, __COND__(t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type_), factory.createToken(SyntaxKindQuestionToken), nil), overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type_, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
				}))
			}
			if isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText == "" {
				return setOriginalNode(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), node)
			}
			if (isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node) {
				return factory.createTypeLiteralNode([]IndexSignatureDeclaration{factory.createIndexSignature(nil, []ParameterDeclaration{factory.createParameterDeclaration(nil, nil, "x", nil, visitNode(node.typeArguments[0], visitExistingNodeTreeSymbols, isTypeNode))}, visitNode(node.typeArguments[1], visitExistingNodeTreeSymbols, isTypeNode))})
			}
			if isJSDocFunctionType(node) {
				if isJSDocConstructSignature(node) {
					var newTypeNode *TypeNode
					return factory.createConstructorTypeNode(nil, visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined(node.parameters, func(p ParameterDeclaration, i number) *ParameterDeclaration {
						if p.name && isIdentifier(p.name) && p.name.escapedText == "new" {
							return ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: newTypeNode = p.type, undefined */ TODO)
						} else {
							return factory.createParameterDeclaration(nil, getEffectiveDotDotDotForParameter(p), setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p), factory.cloneNode(p.questionToken), visitNode(p.type_, visitExistingNodeTreeSymbols, isTypeNode), nil)
						}
					}), visitNode(newTypeNode || node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
				} else {
					return factory.createFunctionTypeNode(visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map_(node.parameters, func(p ParameterDeclaration, i number) ParameterDeclaration {
						return factory.createParameterDeclaration(nil, getEffectiveDotDotDotForParameter(p), setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p), factory.cloneNode(p.questionToken), visitNode(p.type_, visitExistingNodeTreeSymbols, isTypeNode), nil)
					}), visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
				}
			}
			if isThisTypeNode(node) {
				if canReuseTypeNode(context, node) {
					return node
				}
				hadError = true
				return node
			}
			if isTypeParameterDeclaration(node) {
				return factory.updateTypeParameterDeclaration(node, visitNodes(node.modifiers, visitExistingNodeTreeSymbols, isModifier), setTextRange(context, typeParameterToName(tc.getDeclaredTypeOfSymbol(tc.getSymbolOfDeclaration(node)), context), node), visitNode(node.constraint, visitExistingNodeTreeSymbols, isTypeNode), visitNode(node.default_, visitExistingNodeTreeSymbols, isTypeNode))
			}

			if isIndexedAccessTypeNode(node) {
				result := tryVisitIndexedAccess(node)
				if !result {
					hadError = true
					return node
				}
				return result
			}

			if isTypeReferenceNode(node) {
				result := tryVisitTypeReference(node)
				if result {
					return result
				}
				hadError = true
				return node
			}
			if isLiteralImportTypeNode(node) {
				nodeSymbol := tc.getNodeLinks(node).resolvedSymbol
				if isInJSDoc(node) && nodeSymbol && ((!node.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(node.typeArguments) >= tc.getMinTypeArgumentCount(tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))) {
					return setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node)
				}
				return factory.updateImportTypeNode(node, factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), visitNode(node.attributes, visitExistingNodeTreeSymbols, isImportAttributes), visitNode(node.qualifier, visitExistingNodeTreeSymbols, isEntityName), visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode), node.isTypeOf)
			}
			if isNamedDeclaration(node) && node.name.kind == SyntaxKindComputedPropertyName && !tc.isLateBindableName(node.name) {
				if !hasDynamicName(node) {
					return visitEachChild(node, visitExistingNodeTreeSymbols)
				}
				if !(context.internalFlags&InternalNodeBuilderFlagsAllowUnresolvedNames && isEntityNameExpression(node.name.expression) && tc.checkComputedPropertyName(node.name).flags&TypeFlagsAny) {
					return nil
				}
			}
			if (isFunctionLike(node) && !node.type_) || (isPropertyDeclaration(node) && !node.type_ && !node.initializer) || (isPropertySignature(node) && !node.type_ && !node.initializer) || (isParameter(node) && !node.type_ && !node.initializer) {
				visited := visitEachChild(node, visitExistingNodeTreeSymbols)
				if visited == node {
					visited = setTextRange(context, factory.cloneNode(node), node)
				}
				(visited /* as Mutable<typeof visited> */).type_ = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
				if isParameter(node) {
					(visited /* as Mutable<ParameterDeclaration> */).modifiers = nil
				}
				return visited
			}
			if isTypeQueryNode(node) {
				result := tryVisitTypeQuery(node)
				if !result {
					hadError = true
					return node
				}
				return result
			}
			if isComputedPropertyName(node) && isEntityNameExpression(node.expression) {
				TODO_IDENTIFIER := trackExistingEntityName(node.expression, context)
				if !introducesError {
					return factory.updateComputedPropertyName(node, result)
				} else {
					type_ := tc.getWidenedType(tc.getRegularTypeOfExpression(node.expression))
					computedPropertyNameType := typeToTypeNodeHelper(type_, context)
					var literal TODO
					if isLiteralTypeNode(computedPropertyNameType) {
						literal = computedPropertyNameType.literal
					} else {
						evaluated := tc.evaluateEntityNameExpression(node.expression)
						var literalNode * /* TODO(TS-TO-GO) inferred type StringLiteral | NumericLiteral */ any
						switch {
						case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof evaluated.value */ TODO == "string":
							literalNode = factory.createStringLiteral(evaluated.value /*isSingleQuote*/, nil)
						case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof evaluated.value */ TODO == "number":
							literalNode = factory.createNumericLiteral(evaluated.value /*numericLiteralFlags*/, 0)
						default:
							literalNode = nil
						}
						if !literalNode {
							if isImportTypeNode(computedPropertyNameType) {
								trackComputedName(node.expression, context.enclosingDeclaration, context)
							}
							return node
						}
						literal = literalNode
					}
					if literal.kind == SyntaxKindStringLiteral && isIdentifierText(literal.text, getEmitScriptTarget(tc.compilerOptions)) {
						return factory.createIdentifier(literal.text)
					}
					if literal.kind == SyntaxKindNumericLiteral && !literal.text.startsWith("-") {
						return literal
					}
					return factory.updateComputedPropertyName(node, literal)
				}
			}
			if isTypePredicateNode(node) {
				var parameterName TODO
				if isIdentifier(node.parameterName) {
					TODO_IDENTIFIER := trackExistingEntityName(node.parameterName, context)
					// Should not usually happen the only case is when a type predicate comes from a JSDoc type annotation with it's own parameter symbol definition.
					// /** @type {(v: unknown) => v is undefined} */
					// const isUndef = v => v === undefined;
					hadError = hadError || introducesError
					parameterName = result
				} else {
					parameterName = factory.cloneNode(node.parameterName)
				}
				return factory.updateTypePredicateNode(node, factory.cloneNode(node.assertsModifier), parameterName, visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
			}

			if isTupleTypeNode(node) || isTypeLiteralNode(node) || isMappedTypeNode(node) {
				visited := visitEachChild(node, visitExistingNodeTreeSymbols)
				clone := setTextRange(context, __COND__(visited == node, factory.cloneNode(node), visited), node)
				flags := getEmitFlags(clone)
				setEmitFlags(clone, flags|(__COND__(context.flags&NodeBuilderFlagsMultilineObjectLiterals && isTypeLiteralNode(node), 0, EmitFlagsSingleLine)))
				return clone
			}
			if isStringLiteral(node) && !!(context.flags & NodeBuilderFlagsUseSingleQuotesForStringLiteralType) && !node.singleQuote {
				clone := factory.cloneNode(node)
				(clone /* as Mutable<typeof clone> */).singleQuote = true
				return clone
			}
			if isConditionalTypeNode(node) {
				checkType := visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)

				disposeScope := onEnterNewScope(node)
				extendType := visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)
				trueType := visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)
				disposeScope()
				falseType := visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)
				return factory.updateConditionalTypeNode(node, checkType, extendType, trueType, falseType)
			}

			if isTypeOperatorNode(node) {
				if node.operator == SyntaxKindUniqueKeyword && node.type_.kind == SyntaxKindSymbolKeyword {
					if !canReuseTypeNode(context, node) {
						hadError = true
						return node
					}
				} else if node.operator == SyntaxKindKeyOfKeyword {
					result := tryVisitKeyOf(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
			}

			return visitEachChild(node, visitExistingNodeTreeSymbols)

			/* OVERLOAD: function visitEachChild<T extends Node>(node: T, visitor: Visitor): T; */
			/* OVERLOAD: function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor): T | undefined; */
			visitEachChild := func(node *T, visitor Visitor) *T {
				nonlocalNode := !context.enclosingFile || context.enclosingFile != getSourceFileOfNode(node)
				return visitEachChildWorker(node, visitor /*context*/, nil, __COND__(nonlocalNode, visitNodesWithoutCopyingPositions, nil))
			}

			visitNodesWithoutCopyingPositions := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
				result := visitNodes(nodes, visitor, test, start, count)
				if result {
					if result.pos != -1 || result.end != -1 {
						if result == nodes {
							result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma)
						}
						setTextRangePosEnd(result, -1, -1)
					}
				}
				return result
			}

			getEffectiveDotDotDotForParameter := func(p ParameterDeclaration) *DotDotDotToken {
				return p.dotDotDotToken || (__COND__(p.type_ && isJSDocVariadicType(p.type_), factory.createToken(SyntaxKindDotDotDotToken), nil))
			}

			/** Note that `new:T` parameters are not handled, but should be before calling this function. */

			getNameForJSDocFunctionParameter := func(p ParameterDeclaration, index number) string {
				switch {
				case p.name && isIdentifier(p.name) && p.name.escapedText == "this":
					return "this"
				case getEffectiveDotDotDotForParameter(p):
					return `args`
				default:
					return __TEMPLATE__("arg", index)
				}
			}

			rewriteModuleSpecifier := func(parent ImportTypeNode, lit StringLiteral) StringLiteral {
				if context.bundled || context.enclosingFile != getSourceFileOfNode(lit) {
					name := lit.text
					nodeSymbol := tc.getNodeLinks(node).resolvedSymbol
					var meaning /* TODO(TS-TO-GO) inferred type SymbolFlags.Value | SymbolFlags.Type */ any
					if parent.isTypeOf {
						meaning = SymbolFlagsValue
					} else {
						meaning = SymbolFlagsType
					}
					parentSymbol := nodeSymbol && tc.isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning /*shouldComputeAliasesToMakeVisible*/, false).accessibility == SymbolAccessibilityAccessible && lookupSymbolChain(nodeSymbol, context, meaning /*yieldModuleSymbol*/, true)[0]
					if parentSymbol && isExternalModuleSymbol(parentSymbol) {
						name = getSpecifierForModuleSymbol(parentSymbol, context)
					} else {
						targetFile := tc.getExternalModuleFileFromDeclaration(parent)
						if targetFile {
							name = getSpecifierForModuleSymbol(targetFile.symbol, context)
						}
					}
					if name.includes("/node_modules/") {
						context.encounteredError = true
						if context.tracker.reportLikelyUnsafeImportRequiredError {
							context.tracker.reportLikelyUnsafeImportRequiredError(name)
						}
					}
					if name != lit.text {
						return setOriginalNode(factory.createStringLiteral(name), lit)
					}
				}
				return visitNode(lit, visitExistingNodeTreeSymbols, isStringLiteral)
			}

		}

	}

	symbolTableToDeclarationStatements := func(symbolTable SymbolTable, context NodeBuilderContext) []Statement {
		serializePropertySymbolForClass := makeSerializePropertySymbol(factory.createPropertyDeclaration, SyntaxKindMethodDeclaration /*useAccessors*/, true)
		serializePropertySymbolForInterfaceWorker := makeSerializePropertySymbol(func(mods *[]Modifier, name /* TODO(TS-TO-GO) inferred type string | PropertyName */ any, question *QuestionToken, type_ *TypeNode) PropertySignature {
			return factory.createPropertySignature(mods, name, question, type_)
		}, SyntaxKindMethodSignature /*useAccessors*/, false)

		// TODO: Use `setOriginalNode` on original declaration names where possible so these declarations see some kind of
		// declaration mapping

		// We save the enclosing declaration off here so it's not adjusted by well-meaning declaration
		// emit codepaths which want to apply more specific contexts (so we can still refer to the root real declaration
		// we're trying to emit from later on)
		enclosingDeclaration := context.enclosingDeclaration
		var results []Statement = []never{}
		visitedSymbols := NewSet[number]()
		var deferredPrivatesStack []Map[SymbolId, Symbol] = []never{}
		oldcontext := context
		context = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			/* TODO(TS-TO-GO) Node SpreadAssignment: ...oldcontext */
			"usedSymbolNames":          NewSet(oldcontext.usedSymbolNames),
			"remappedSymbolNames":      NewMap(),
			"remappedSymbolReferences": NewMap(oldcontext.remappedSymbolReferences. /* ? */ entries()),
			"tracker":                  nil,
		}
		var tracker SymbolTracker = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			/* TODO(TS-TO-GO) Node SpreadAssignment: ...oldcontext.tracker.inner */
			"trackSymbol": func(sym Symbol, decl Node, meaning SymbolFlags) bool {
				if context.remappedSymbolNames. /* ? */ has(getSymbolId(sym)) {
					return false
					// If the context has a remapped name for the symbol, it *should* mean it's been made visible
				}
				// If the context has a remapped name for the symbol, it *should* mean it's been made visible
				accessibleResult := tc.isSymbolAccessible(sym, decl, meaning /*shouldComputeAliasesToMakeVisible*/, false)
				if accessibleResult.accessibility == SymbolAccessibilityAccessible {
					// Lookup the root symbol of the chain of refs we'll use to access it and serialize it
					chain := lookupSymbolChainWorker(sym, context, meaning)
					if !(sym.flags & SymbolFlagsProperty) {
						// Only include referenced privates in the same file. Weird JS aliases may expose privates
						// from other files - assume JS transforms will make those available via expected means
						root := chain[0]
						contextFile := getSourceFileOfNode(oldcontext.enclosingDeclaration)
						if some(root.declarations, func(d Declaration) bool {
							return getSourceFileOfNode(d) == contextFile
						}) {
							includePrivateSymbol(root)
						}
					}
				} else if oldcontext.tracker.inner. /* ? */ trackSymbol {
					return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning)
				}
				return false
			},
		}
		context.tracker = NewSymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost)
		forEachEntry(symbolTable, func(symbol Symbol, name __String) {
			baseName := unescapeLeadingUnderscores(name)
			getInternalSymbolName(symbol, baseName)
			// Called to cache values into `usedSymbolNames` and `remappedSymbolNames`
		})
		addingDeclare := !context.bundled
		exportEquals := symbolTable.get(InternalSymbolNameExportEquals)
		if exportEquals && symbolTable.size > 1 && exportEquals.flags&(SymbolFlagsAlias|SymbolFlagsModule) {
			symbolTable = createSymbolTable()
			// Remove extraneous elements from root symbol table (they'll be mixed back in when the target of the `export=` is looked up)
			symbolTable.set(InternalSymbolNameExportEquals, exportEquals)
		}

		visitSymbolTable(symbolTable)
		return mergeRedundantStatements(results)

		isIdentifierAndNotUndefined := func(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is Identifier */ any {
			return !!node && node.kind == SyntaxKindIdentifier
		}

		getNamesOfDeclaration := func(statement Statement) []Identifier {
			if isVariableStatement(statement) {
				return filter(map_(statement.declarationList.declarations, getNameOfDeclaration), isIdentifierAndNotUndefined)
			}
			return filter([]*DeclarationName{getNameOfDeclaration(statement /* as DeclarationStatement */)}, isIdentifierAndNotUndefined)
		}

		flattenExportAssignedNamespace := func(statements []Statement) []Statement {
			exportAssignment := find(statements, isExportAssignment)
			nsIndex := findIndex(statements, isModuleDeclaration)
			var ns *ModuleDeclaration
			if nsIndex != -1 {
				ns = statements[nsIndex] /* as ModuleDeclaration */
			} else {
				ns = nil
			}
			if ns && exportAssignment && exportAssignment.isExportEquals && isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) == idText(exportAssignment.expression) && ns.body && isModuleBlock(ns.body) {
				// Pass 0: Correct situations where a module has both an `export = ns` and multiple top-level exports by stripping the export modifiers from
				//  the top-level exports and exporting them in the targeted ns, as can occur when a js file has both typedefs and `module.export` assignments
				excessExports := filter(statements, func(s Statement) bool {
					return !!(getEffectiveModifierFlags(s) & ModifierFlagsExport)
				})
				name := ns.name
				body := ns.body
				if length(excessExports) {
					ns = factory.updateModuleDeclaration(ns, ns.modifiers, ns.name /* TODO(TS-TO-GO) EqualsToken BinaryExpression: body = factory.updateModuleBlock( body, factory.createNodeArray([ ...ns.body.statements, factory.createExportDeclaration( /*modifiers* / undefined, /*isTypeOnly* / false, factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly* / false, /*propertyName* / undefined, id))), /*moduleSpecifier* / undefined, ), ]), ) */, TODO)
					statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...statements.slice(0, nsIndex) */ ns /* TODO(TS-TO-GO) Node SpreadElement: ...statements.slice(nsIndex + 1) */}
				}

				// Pass 1: Flatten `export namespace _exports {} export = _exports;` so long as the `export=` only points at a single namespace declaration
				if !find(statements, func(s Statement) bool {
					return s != ns && nodeHasName(s, name)
				}) {
					results = []never{}
					// If the namespace contains no export assignments or declarations, and no declarations flagged with `export`, then _everything_ is exported -
					// to respect this as the top level, we need to add an `export` modifier to everything
					mixinExportFlag := !some(body.statements, func(s Statement) bool {
						return hasSyntacticModifier(s, ModifierFlagsExport) || isExportAssignment(s) || isExportDeclaration(s)
					})
					forEach(body.statements, func(s Statement) {
						addResult(s, __COND__(mixinExportFlag, ModifierFlagsExport, ModifierFlagsNone))
						// Recalculates the ambient (and export, if applicable from above) flag
					})
					statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...filter(statements, s => s !== ns && s !== exportAssignment) */ /* TODO(TS-TO-GO) Node SpreadElement: ...results */ }
				}
			}
			return statements
		}

		mergeExportDeclarations := func(statements []Statement) []Statement {
			// Pass 2: Combine all `export {}` declarations
			exports := filter(statements, func(d Statement) bool {
				return isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
			}) /* as ExportDeclaration[] */
			if length(exports) > 1 {
				nonExports := filter(statements, func(d Statement) bool {
					return !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause
				})
				statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...nonExports */ factory.createExportDeclaration(nil, false, factory.createNamedExports(flatMap(exports, func(e ExportDeclaration) NodeArray[ExportSpecifier] {
					return cast(e.exportClause, isNamedExports).elements
				})), nil)}
			}
			// Pass 2b: Also combine all `export {} from "..."` declarations as needed
			reexports := filter(statements, func(d Statement) bool {
				return isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause)
			}) /* as ExportDeclaration[] */
			if length(reexports) > 1 {
				groups := group(reexports, func(decl ExportDeclaration) string {
					if isStringLiteral(decl.moduleSpecifier) {
						return ">" + decl.moduleSpecifier.text
					} else {
						return ">"
					}
				})
				if groups.length != reexports.length {
					for _, group := range groups {
						if group.length > 1 {
							// remove group members from statements and then merge group members and add back to statements
							statements = []Statement{ /* TODO(TS-TO-GO) Node SpreadElement: ...filter(statements, s => !group.includes(s as ExportDeclaration)) */ factory.createExportDeclaration(nil, false, factory.createNamedExports(flatMap(group, func(e ExportDeclaration) NodeArray[ExportSpecifier] {
								return cast(e.exportClause, isNamedExports).elements
							})), group[0].moduleSpecifier)}
						}
					}
				}
			}
			return statements
		}

		inlineExportModifiers := func(statements []Statement) []Statement {
			// Pass 3: Move all `export {}`'s to `export` modifiers where possible
			index := findIndex(statements, func(d Statement) bool {
				return isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause && isNamedExports(d.exportClause)
			})
			if index >= 0 {
				exportDecl := statements[index] /* as ExportDeclaration & { readonly exportClause: NamedExports; } */
				replacements := mapDefined(exportDecl.exportClause.elements, func(e ExportSpecifier) *ExportSpecifier {
					if !e.propertyName && e.name.kind != SyntaxKindStringLiteral {
						// export {name} - look thru `statements` for `name`, and if all results can take an `export` modifier, do so and filter it
						name := e.name
						indices := indicesOf(statements)
						associatedIndices := filter(indices, func(i number) bool {
							return nodeHasName(statements[i], name)
						})
						if length(associatedIndices) && every(associatedIndices, func(i number) bool {
							return canHaveExportModifier(statements[i])
						}) {
							for _, index := range associatedIndices {
								statements[index] = addExportModifier(statements[index] /* as Extract<HasModifiers, Statement> */)
							}
							return nil
						}
					}
					return e
				})
				if !length(replacements) {
					// all clauses removed, remove the export declaration
					orderedRemoveItemAt(statements, index)
				} else {
					// some items filtered, others not - update the export declaration
					statements[index] = factory.updateExportDeclaration(exportDecl, exportDecl.modifiers, exportDecl.isTypeOnly, factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.attributes)
				}
			}
			return statements
		}

		mergeRedundantStatements := func(statements []Statement) []Statement {
			statements = flattenExportAssignedNamespace(statements)
			statements = mergeExportDeclarations(statements)
			statements = inlineExportModifiers(statements)

			// Not a cleanup, but as a final step: If there is a mix of `export` and non-`export` declarations, but no `export =` or `export {}` add a `export {};` so
			// declaration privacy is respected.
			if enclosingDeclaration && ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) && (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker))) {
				statements.push(createEmptyExports(factory))
			}
			return statements
		}

		addExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(TS-TO-GO) inferred type FunctionDeclaration | ExportAssignment | VariableStatement | InterfaceDeclaration | ClassDeclaration | EnumDeclaration | ExportDeclaration | ImportDeclaration | ImportEqualsDeclaration | ModuleDeclaration | TypeAliasDeclaration */ any {
			flags := (getEffectiveModifierFlags(node) | ModifierFlagsExport) & ~ModifierFlagsAmbient
			return factory.replaceModifiers(node, flags)
		}

		removeExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(TS-TO-GO) inferred type FunctionDeclaration | ExportAssignment | VariableStatement | InterfaceDeclaration | ClassDeclaration | EnumDeclaration | ExportDeclaration | ImportDeclaration | ImportEqualsDeclaration | ModuleDeclaration | TypeAliasDeclaration */ any {
			flags := getEffectiveModifierFlags(node) & ~ModifierFlagsExport
			return factory.replaceModifiers(node, flags)
		}

		visitSymbolTable := func(symbolTable SymbolTable, suppressNewPrivateContext bool, propertyAsAlias bool) {
			if !suppressNewPrivateContext {
				deferredPrivatesStack.push(NewMap())
			}
			symbolTable.forEach(func(symbol Symbol) {
				serializeSymbol(symbol /*isPrivate*/, false, !!propertyAsAlias)
			})
			if !suppressNewPrivateContext {
				// deferredPrivates will be filled up by visiting the symbol table
				// And will continue to iterate as elements are added while visited `deferredPrivates`
				// (As that's how a map iterator is defined to work)
				deferredPrivatesStack[deferredPrivatesStack.length-1].forEach(func(symbol Symbol) {
					serializeSymbol(symbol /*isPrivate*/, true, !!propertyAsAlias)
				})
				deferredPrivatesStack.pop()
			}
		}

		serializeSymbol := func(symbol Symbol, isPrivate bool, propertyAsAlias bool) {
			tc.getPropertiesOfType(tc.getTypeOfSymbol(symbol))
			// cache visited list based on merged symbol, since we want to use the unmerged top-level symbol, but
			// still skip reserializing it if we encounter the merged product later on
			visitedSym := tc.getMergedSymbol(symbol)
			if visitedSymbols.has(getSymbolId(visitedSym)) {
				return
				// Already printed
			}
			visitedSymbols.add(getSymbolId(visitedSym))
			// Only actually serialize symbols within the correct enclosing declaration, otherwise do nothing with the out-of-context symbol
			skipMembershipCheck := !isPrivate
			// We only call this on exported symbols when we know they're in the correct scope
			if skipMembershipCheck || (!!length(symbol.declarations) && some(symbol.declarations, func(d Declaration) bool {
				return !!findAncestor(d, func(n Node) bool {
					return n == enclosingDeclaration
				})
			})) {
				scopeCleanup := cloneNodeBuilderContext(context)
				serializeSymbolWorker(symbol, isPrivate, propertyAsAlias)
				scopeCleanup()
			}
		}

		// Synthesize declarations for a symbol - might be an Interface, a Class, a Namespace, a Type, a Variable (const, let, or var), an Alias
		// or a merge of some number of those.
		// An interesting challenge is ensuring that when classes merge with namespaces and interfaces, is keeping
		// each symbol in only one of the representations
		// Also, synthesizing a default export of some kind
		// If it's an alias: emit `export default ref`
		// If it's a property: emit `export default _default` with a `_default` prop
		// If it's a class/interface/function: emit a class/interface/function with a `default` modifier
		// These forms can merge, eg (`export default 12; export default interface A {}`)
		serializeSymbolWorker := func(symbol Symbol, isPrivate bool, propertyAsAlias bool, escapedSymbolName __String /*  = symbol.escapedName */) {
			symbolName := unescapeLeadingUnderscores(escapedSymbolName)
			isDefault := escapedSymbolName == InternalSymbolNameDefault
			if isPrivate && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) && isStringANonContextualKeyword(symbolName) && !isDefault {
				// Oh no. We cannot use this symbol's name as it's name... It's likely some jsdoc had an invalid name like `export` or `default` :(
				context.encounteredError = true
				// TODO: Issue error via symbol tracker?
				return
				// If we need to emit a private with a keyword name, we're done for, since something else will try to refer to it by that name
			}
			needsPostExportDefault := isDefault && !!(symbol.flags&SymbolFlagsExportDoesNotSupportDefaultModifier || (symbol.flags&SymbolFlagsFunction && length(tc.getPropertiesOfType(tc.getTypeOfSymbol(symbol))))) && !(symbol.flags & SymbolFlagsAlias)
			// An alias symbol should preclude needing to make an alias ourselves
			needsExportDeclaration := !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault
			// `serializeVariableOrProperty` will handle adding the export declaration if it is run (since `getInternalSymbolName` will create the name mapping), so we need to ensuer we unset `needsExportDeclaration` if it is
			if needsPostExportDefault || needsExportDeclaration {
				isPrivate = true
			}
			modifierFlags := (__COND__(!isPrivate, ModifierFlagsExport, 0)) | (__COND__(isDefault && !needsPostExportDefault, ModifierFlagsDefault, 0))
			isConstMergedWithNS := symbol.flags&SymbolFlagsModule && symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty) && escapedSymbolName != InternalSymbolNameExportEquals
			isConstMergedWithNSPrintableAsSignatureMerge := isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(tc.getTypeOfSymbol(symbol), symbol)
			if symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) || isConstMergedWithNSPrintableAsSignatureMerge {
				serializeAsFunctionNamespaceMerge(tc.getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
			}
			if symbol.flags & SymbolFlagsTypeAlias {
				serializeTypeAlias(symbol, symbolName, modifierFlags)
			}
			// Need to skip over export= symbols below - json source files get a single `Property` flagged
			// symbol of name `export=` which needs to be handled like an alias. It's not great, but it is what it is.
			if symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty|SymbolFlagsAccessor) && escapedSymbolName != InternalSymbolNameExportEquals && !(symbol.flags & SymbolFlagsPrototype) && !(symbol.flags & SymbolFlagsClass) && !(symbol.flags & SymbolFlagsMethod) && !isConstMergedWithNSPrintableAsSignatureMerge {
				if propertyAsAlias {
					createdExport := serializeMaybeAliasAssignment(symbol)
					if createdExport {
						needsExportDeclaration = false
						needsPostExportDefault = false
					}
				} else {
					type_ := tc.getTypeOfSymbol(symbol)
					localName := getInternalSymbolName(symbol, symbolName)
					if type_.symbol && type_.symbol != symbol && type_.symbol.flags&SymbolFlagsFunction && some(type_.symbol.declarations, isFunctionExpressionOrArrowFunction) && (type_.symbol.members. /* ? */ size || type_.symbol.exports. /* ? */ size) {
						// assignment of a anonymous expando/class-like function, the func/ns/merge branch below won't trigger,
						// and the assignment form has to reference the unreachable anonymous type so will error.
						// Instead, serialize the type's symbol, but with the current symbol's name, rather than the anonymous one.
						if !context.remappedSymbolReferences {
							context.remappedSymbolReferences = NewMap()
						}
						context.remappedSymbolReferences.set(getSymbolId(type_.symbol), symbol)
						// save name remapping as local name for target symbol
						serializeSymbolWorker(type_.symbol, isPrivate, propertyAsAlias, escapedSymbolName)
						context.remappedSymbolReferences.delete(getSymbolId(type_.symbol))
					} else if !(symbol.flags & SymbolFlagsFunction) && isTypeRepresentableAsFunctionNamespaceMerge(type_, symbol) {
						// If the type looks like a function declaration + ns could represent it, and it's type is sourced locally, rewrite it into a function declaration + ns
						serializeAsFunctionNamespaceMerge(type_, symbol, localName, modifierFlags)
					} else {
						// A Class + Property merge is made for a `module.exports.Member = class {}`, and it doesn't serialize well as either a class _or_ a property symbol - in fact, _it behaves like an alias!_
						// `var` is `FunctionScopedVariable`, `const` and `let` are `BlockScopedVariable`, and `module.exports.thing =` is `Property`
						var flags * /* TODO(TS-TO-GO) inferred type NodeFlags.Let | NodeFlags.Const */ any
						switch {
						case !(symbol.flags & SymbolFlagsBlockScopedVariable):
							if symbol.parent. /* ? */ valueDeclaration && isSourceFile(symbol.parent. /* ? */ valueDeclaration) {
								flags = NodeFlagsConst
							} else {
								flags = nil
							}
						case tc.isConstantVariable(symbol):
							flags = NodeFlagsConst
						default:
							flags = NodeFlagsLet
						}
						var name string
						if needsPostExportDefault || !(symbol.flags & SymbolFlagsProperty) {
							name = localName
						} else {
							name = getUnusedName(localName, symbol)
						}
						var textRange Node = symbol.declarations && find(symbol.declarations, func(d Declaration) bool {
							return isVariableDeclaration(d)
						})
						if textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length == 1 {
							textRange = textRange.parent.parent
						}
						propertyAccessRequire := symbol.declarations. /* ? */ find(isPropertyAccessExpression)
						if propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right) && type_.symbol. /* ? */ valueDeclaration && isSourceFile(type_.symbol.valueDeclaration) {
							var alias *Identifier
							if localName == propertyAccessRequire.parent.right.escapedText {
								alias = nil
							} else {
								alias = propertyAccessRequire.parent.right
							}
							addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, alias, localName)})), ModifierFlagsNone)
							context.tracker.trackSymbol(type_.symbol, context.enclosingDeclaration, SymbolFlagsValue)
						} else {
							statement := setTextRange(context, factory.createVariableStatement(nil, factory.createVariableDeclarationList([]VariableDeclaration{factory.createVariableDeclaration(name /*exclamationToken*/, nil, serializeTypeForDeclaration(context /*declaration*/, nil, type_, symbol))}, flags)), textRange)
							addResult(statement, __COND__(name != localName, modifierFlags&~ModifierFlagsExport, modifierFlags))
							if name != localName && !isPrivate {
								// We rename the variable declaration we generate for Property symbols since they may have a name which
								// conflicts with a local declaration. For example, given input:
								// ```
								// function g() {}
								// module.exports.g = g
								// ```
								// In such a situation, we have a local variable named `g`, and a separate exported variable named `g`.
								// Naively, we would emit
								// ```
								// function g() {}
								// export const g: typeof g;
								// ```
								// That's obviously incorrect - the `g` in the type annotation needs to refer to the local `g`, but
								// the export declaration shadows it.
								// To work around that, we instead write
								// ```
								// function g() {}
								// const g_1: typeof g;
								// export { g_1 as g };
								// ```
								// To create an export named `g` that does _not_ shadow the local `g`
								addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, name, localName)})), ModifierFlagsNone)
								needsExportDeclaration = false
								needsPostExportDefault = false
							}
						}
					}
				}
			}
			if symbol.flags & SymbolFlagsEnum {
				serializeEnum(symbol, symbolName, modifierFlags)
			}
			if symbol.flags & SymbolFlagsClass {
				if symbol.flags&SymbolFlagsProperty && symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration.parent) && isClassExpression(symbol.valueDeclaration.parent.right) {
					// Looks like a `module.exports.Sub = class {}` - if we serialize `symbol` as a class, the result will have no members,
					// since the classiness is actually from the target of the effective alias the symbol is. yes. A BlockScopedVariable|Class|Property
					// _really_ acts like an Alias, and none of a BlockScopedVariable, Class, or Property. This is the travesty of JS binding today.
					serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				} else {
					serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
			}
			if (symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge {
				serializeModule(symbol, symbolName, modifierFlags)
			}
			// The class meaning serialization should handle serializing all interface members
			if symbol.flags&SymbolFlagsInterface && !(symbol.flags & SymbolFlagsClass) {
				serializeInterface(symbol, symbolName, modifierFlags)
			}
			if symbol.flags & SymbolFlagsAlias {
				serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
			}
			if symbol.flags&SymbolFlagsProperty && symbol.escapedName == InternalSymbolNameExportEquals {
				serializeMaybeAliasAssignment(symbol)
			}
			if symbol.flags & SymbolFlagsExportStar {
				// synthesize export * from "moduleReference"
				// Straightforward - only one thing to do - make an export declaration
				if symbol.declarations {
					for _, node := range symbol.declarations {
						resolvedModule := tc.resolveExternalModuleName(node, (node /* as ExportDeclaration */).moduleSpecifier)
						if !resolvedModule {
							continue
						}
						addResult(factory.createExportDeclaration(nil /*isTypeOnly*/, (node /* as ExportDeclaration */).isTypeOnly /*exportClause*/, nil, factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), ModifierFlagsNone)
					}
				}
			}
			if needsPostExportDefault {
				addResult(factory.createExportAssignment(nil /*isExportEquals*/, false, factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), ModifierFlagsNone)
			} else if needsExportDeclaration {
				addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, getInternalSymbolName(symbol, symbolName), symbolName)})), ModifierFlagsNone)
			}
		}

		includePrivateSymbol := func(symbol Symbol) {
			if some(symbol.declarations, isPartOfParameterDeclaration) {
				return
			}
			Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length-1])
			getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol)
			// Blanket moving (import) aliases into the root private context should work, since imports are not valid within namespaces
			// (so they must have been in the root to begin with if they were real imports) cjs `require` aliases (an upcoming feature)
			// will throw a wrench in this, since those may have been nested, but we'll need to synthesize them in the outer scope
			// anyway, as that's the only place the import they translate to is valid. In such a case, we might need to use a unique name
			// for the moved import; which hopefully the above `getUnusedName` call should produce.
			isExternalImportAlias := !!(symbol.flags & SymbolFlagsAlias) && !some(symbol.declarations, func(d Declaration) bool {
				return !!findAncestor(d, isExportDeclaration) || isNamespaceExport(d) || (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference))
			})
			deferredPrivatesStack[__COND__(isExternalImportAlias, 0, (deferredPrivatesStack.length-1))].set(getSymbolId(symbol), symbol)
		}

		isExportingScope := func(enclosingDeclaration Node) bool {
			return ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) || (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration)))
		}

		// Prepends a `declare` and/or `export` modifier if the context requires it, and then adds `node` to `result` and returns `node`
		addResult := func(node Statement, additionalModifierFlags ModifierFlags) {
			if canHaveModifiers(node) {
				var newModifierFlags ModifierFlags = ModifierFlagsNone
				enclosingDeclaration := context.enclosingDeclaration && (__COND__(isJSDocTypeAlias(context.enclosingDeclaration), getSourceFileOfNode(context.enclosingDeclaration), context.enclosingDeclaration))
				if additionalModifierFlags&ModifierFlagsExport && enclosingDeclaration && (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) && canHaveExportModifier(node) {
					// Classes, namespaces, variables, functions, interfaces, and types should all be `export`ed in a module context if not private
					newModifierFlags |= ModifierFlagsExport
				}
				if addingDeclare && !(newModifierFlags & ModifierFlagsExport) && (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlagsAmbient)) && (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node)) {
					// Classes, namespaces, variables, enums, and functions all need `declare` modifiers to be valid in a declaration file top-level scope
					newModifierFlags |= ModifierFlagsAmbient
				}
				if (additionalModifierFlags & ModifierFlagsDefault) && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node)) {
					newModifierFlags |= ModifierFlagsDefault
				}
				if newModifierFlags {
					node = factory.replaceModifiers(node, newModifierFlags|getEffectiveModifierFlags(node))
				}
			}
			results.push(node)
		}

		serializeTypeAlias := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
			aliasType := tc.getDeclaredTypeOfTypeAlias(symbol)
			typeParams := tc.getSymbolLinks(symbol).typeParameters
			typeParamDecls := map_(typeParams, func(p TypeParameter) TypeParameterDeclaration {
				return typeParameterToDeclaration(p, context)
			})
			jsdocAliasDecl := symbol.declarations. /* ? */ find(isJSDocTypeAlias)
			commentText := getTextOfJSDocComment(__COND__(jsdocAliasDecl, jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment, nil))
			restoreFlags := saveRestoreFlags(context)
			context.flags |= NodeBuilderFlagsInTypeAlias
			oldEnclosingDecl := context.enclosingDeclaration
			context.enclosingDeclaration = jsdocAliasDecl
			typeNode := jsdocAliasDecl && jsdocAliasDecl.typeExpression && isJSDocTypeExpression(jsdocAliasDecl.typeExpression) && tryReuseExistingNonParameterTypeNode(context, jsdocAliasDecl.typeExpression.type_, aliasType /*host*/, nil) || typeToTypeNodeHelper(aliasType, context)
			addResult(setSyntheticLeadingComments(factory.createTypeAliasDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode), __COND__(!commentText, []never{}, [] /* TODO(TS-TO-GO) inferred type { kind: SyntaxKind.MultiLineCommentTrivia; text: string; pos: -1; end: -1; hasTrailingNewLine: true; } */ any{map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"kind":               SyntaxKindMultiLineCommentTrivia,
				"text":               "*\n * " + commentText.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /\n/g */ TODO, "\n * ") + "\n ",
				"pos":                -1,
				"end":                -1,
				"hasTrailingNewLine": true,
			}})), modifierFlags)
			restoreFlags()
			context.enclosingDeclaration = oldEnclosingDecl
		}

		serializeInterface := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
			interfaceType := tc.getDeclaredTypeOfClassOrInterface(symbol)
			localParams := tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			typeParamDecls := map_(localParams, func(p TypeParameter) TypeParameterDeclaration {
				return typeParameterToDeclaration(p, context)
			})
			baseTypes := tc.getBaseTypes(interfaceType)
			var baseType Type
			if length(baseTypes) {
				baseType = tc.getIntersectionType(baseTypes)
			} else {
				baseType = nil
			}
			members := flatMap(tc.getPropertiesOfType(interfaceType), func(p Symbol) [] /* TODO(TS-TO-GO) inferred type TypeElement | TypeElement */ any {
				return serializePropertySymbolForInterface(p, baseType)
			})
			callSignatures := serializeSignatures(SignatureKindCall, interfaceType, baseType, SyntaxKindCallSignature)                /* as CallSignatureDeclaration[] */
			constructSignatures := serializeSignatures(SignatureKindConstruct, interfaceType, baseType, SyntaxKindConstructSignature) /* as ConstructSignatureDeclaration[] */
			indexSignatures := serializeIndexSignatures(interfaceType, baseType)

			var heritageClauses *[]HeritageClause
			if !length(baseTypes) {
				heritageClauses = nil
			} else {
				heritageClauses = []HeritageClause{factory.createHeritageClause(SyntaxKindExtendsKeyword, mapDefined(baseTypes, func(b BaseType) *ExpressionWithTypeArguments {
					return trySerializeAsTypeReference(b, SymbolFlagsValue)
				}))}
			}
			addResult(factory.createInterfaceDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses, []TypeElement{ /* TODO(TS-TO-GO) Node SpreadElement: ...indexSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...constructSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...callSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...members */ }), modifierFlags)
		}

		getNamespaceMembersForSerialization := func(symbol Symbol) []Symbol {
			exports := arrayFrom(tc.getExportsOfSymbol(symbol).values())
			merged := tc.getMergedSymbol(symbol)
			if merged != symbol {
				membersSet := NewSet(exports)
				for _, exported := range tc.getExportsOfSymbol(merged).values() {
					if !(tc.getSymbolFlags(tc.resolveSymbol(exported)) & SymbolFlagsValue) {
						membersSet.add(exported)
					}
				}
				exports = arrayFrom(membersSet)
			}
			return filter(exports, func(m Symbol) bool {
				return isNamespaceMember(m) && isIdentifierText(m.escapedName /* as string */, ScriptTargetESNext)
			})
		}

		isTypeOnlyNamespace := func(symbol Symbol) bool {
			return every(getNamespaceMembersForSerialization(symbol), func(m Symbol) bool {
				return !(tc.getSymbolFlags(tc.resolveSymbol(m)) & SymbolFlagsValue)
			})
		}

		serializeModule := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
			members := getNamespaceMembersForSerialization(symbol)
			// Split NS members up by declaration - members whose parent symbol is the ns symbol vs those whose is not (but were added in later via merging)
			locationMap := arrayToMultiMap(members, func(m Symbol) /* TODO(TS-TO-GO) inferred type "real" | "merged" */ any {
				if m.parent && m.parent == symbol {
					return "real"
				} else {
					return "merged"
				}
			})
			realMembers := locationMap.get("real") || emptyArray
			mergedMembers := locationMap.get("merged") || emptyArray
			// TODO: `suppressNewPrivateContext` is questionable -we need to simply be emitting privates in whatever scope they were declared in, rather
			// than whatever scope we traverse to them in. That's a bit of a complex rewrite, since we're not _actually_ tracking privates at all in advance,
			// so we don't even have placeholders to fill in.
			if length(realMembers) {
				localName := getInternalSymbolName(symbol, symbolName)
				serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (SymbolFlagsFunction | SymbolFlagsAssignment)))
			}
			if length(mergedMembers) {
				containingFile := getSourceFileOfNode(context.enclosingDeclaration)
				localName := getInternalSymbolName(symbol, symbolName)
				nsBody := factory.createModuleBlock([]ExportDeclaration{factory.createExportDeclaration(nil, false, factory.createNamedExports(mapDefined(filter(mergedMembers, func(n Symbol) bool {
					return n.escapedName != InternalSymbolNameExportEquals
				}), func(s Symbol) *ExportSpecifier {
					name := unescapeLeadingUnderscores(s.escapedName)
					localName := getInternalSymbolName(s, name)
					aliasDecl := s.declarations && tc.getDeclarationOfAliasSymbol(s)
					if containingFile && (__COND__(aliasDecl, containingFile != getSourceFileOfNode(aliasDecl), !some(s.declarations, func(d Declaration) bool {
						return getSourceFileOfNode(d) == containingFile
					}))) {
						context.tracker. /* ? */ reportNonlocalAugmentation(containingFile, symbol, s)
						return nil
					}
					target := aliasDecl && tc.getTargetOfAliasDeclaration(aliasDecl /*dontRecursivelyResolve*/, true)
					includePrivateSymbol(target || s)
					var targetName string
					if target {
						targetName = getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName))
					} else {
						targetName = localName
					}
					return factory.createExportSpecifier(false, __COND__(name == targetName, nil, targetName), name)
				})))})
				addResult(factory.createModuleDeclaration(nil, factory.createIdentifier(localName), nsBody, NodeFlagsNamespace), ModifierFlagsNone)
			}
		}

		serializeEnum := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
			addResult(factory.createEnumDeclaration(factory.createModifiersFromModifierFlags(__COND__(tc.isConstEnumSymbol(symbol), ModifierFlagsConst, 0)), getInternalSymbolName(symbol, symbolName), map_(filter(tc.getPropertiesOfType(tc.getTypeOfSymbol(symbol)), func(p Symbol) bool {
				return !!(p.flags & SymbolFlagsEnumMember)
			}), func(p Symbol) EnumMember {
				// TODO: Handle computed names
				// I hate that to get the initialized value we need to walk back to the declarations here; but there's no
				// other way to get the possible const value of an enum member that I'm aware of, as the value is cached
				// _on the declaration_, not on the declaration's symbol...
				var initializedValue * /* TODO(TS-TO-GO) inferred type string | number */ any
				if p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) {
					initializedValue = tc.getConstantValue(p.declarations[0])
				} else {
					initializedValue = nil
				}
				return factory.createEnumMember(unescapeLeadingUnderscores(p.escapedName), __COND__(initializedValue == nil, nil, __COND__( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof initializedValue */ TODO == "string", factory.createStringLiteral(initializedValue), factory.createNumericLiteral(initializedValue))))
			})), modifierFlags)
		}

		serializeAsFunctionNamespaceMerge := func(type_ Type, symbol Symbol, localName string, modifierFlags ModifierFlags) {
			signatures := tc.getSignaturesOfType(type_, SignatureKindCall)
			for _, sig := range signatures {
				// Each overload becomes a separate function declaration, in order
				decl := signatureToSignatureDeclarationHelper(sig, SyntaxKindFunctionDeclaration, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"name": factory.createIdentifier(localName),
				}) /* as FunctionDeclaration */
				addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags)
			}
			// Module symbol emit will take care of module-y members, provided it has exports
			if !(symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && !!symbol.exports && !!symbol.exports.size) {
				props := filter(tc.getPropertiesOfType(type_), isNamespaceMember)
				serializeAsNamespaceDeclaration(props, localName, modifierFlags /*suppressNewPrivateContext*/, true)
			}
		}

		getSignatureTextRangeLocation := func(signature Signature) * /* TODO(TS-TO-GO) inferred type BinaryExpression | SignatureDeclaration | VariableDeclarationList | CatchClause | JSDocSignature */ any {
			if signature.declaration && signature.declaration.parent {
				if isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) == AssignmentDeclarationKindProperty {
					return signature.declaration.parent
				}
				// for expressions assigned to `var`s, use the `var` as the text range
				if isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent {
					return signature.declaration.parent.parent
				}
			}
			return signature.declaration
		}

		serializeAsNamespaceDeclaration := func(props []Symbol, localName string, modifierFlags ModifierFlags, suppressNewPrivateContext bool) {
			if length(props) {
				localVsRemoteMap := arrayToMultiMap(props, func(p Symbol) /* TODO(TS-TO-GO) inferred type "local" | "remote" */ any {
					if !length(p.declarations) || some(p.declarations, func(d Declaration) bool {
						return getSourceFileOfNode(d) == getSourceFileOfNode(context.enclosingDeclaration)
					}) {
						return "local"
					} else {
						return "remote"
					}
				})
				localProps := localVsRemoteMap.get("local") || emptyArray
				// handle remote props first - we need to make an `import` declaration that points at the module containing each remote
				// prop in the outermost scope (TODO: a namespace within a namespace would need to be appropriately handled by this)
				// Example:
				// import Foo_1 = require("./exporter");
				// export namespace ns {
				//     import Foo = Foo_1.Foo;
				//     export { Foo };
				//     export const c: number;
				// }
				// This is needed because in JS, statements like `const x = require("./f")` support both type and value lookup, even if they're
				// normally just value lookup (so it functions kinda like an alias even when it's not an alias)
				// _Usually_, we'll simply print the top-level as an alias instead of a `var` in such situations, however is is theoretically
				// possible to encounter a situation where a type has members from both the current file and other files - in those situations,
				// emit akin to the above would be needed.

				// Add a namespace
				// Create namespace as non-synthetic so it is usable as an enclosing declaration
				fakespace := parseNodeFactory.createModuleDeclaration(nil, factory.createIdentifier(localName), factory.createModuleBlock([]never{}), NodeFlagsNamespace)
				setParent(fakespace, enclosingDeclaration /* as SourceFile | NamespaceDeclaration */)
				fakespace.locals = createSymbolTable(props)
				fakespace.symbol = props[0].parent

				oldResults := results
				results = []never{}
				oldAddingDeclare := addingDeclare
				addingDeclare = false
				subcontext := map[any]any{ /* TODO(TS-TO-GO): was object literal */
					/* TODO(TS-TO-GO) Node SpreadAssignment: ...context */
					"enclosingDeclaration": fakespace,
				}
				oldContext := context
				context = subcontext
				// TODO: implement handling for the localVsRemoteMap.get("remote") - should be difficult to trigger (see comment above), as only interesting cross-file js merges should make this possible
				visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext /*propertyAsAlias*/, true)
				context = oldContext
				addingDeclare = oldAddingDeclare
				declarations := results
				results = oldResults
				// replace namespace with synthetic version
				defaultReplaced := map_(declarations, func(d Statement) Statement {
					if isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) {
						return factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, d.expression, factory.createIdentifier(InternalSymbolNameDefault))}))
					} else {
						return d
					}
				})
				var exportModifierStripped []Statement
				if every(defaultReplaced, func(d Statement) bool {
					return hasSyntacticModifier(d, ModifierFlagsExport)
				}) {
					exportModifierStripped = map_(defaultReplaced /* as Extract<HasModifiers, Statement>[] */, removeExportModifier)
				} else {
					exportModifierStripped = defaultReplaced
				}
				fakespace = factory.updateModuleDeclaration(fakespace, fakespace.modifiers, fakespace.name, factory.createModuleBlock(exportModifierStripped))
				addResult(fakespace, modifierFlags)
				// namespaces can never be default exported
			}
		}

		isNamespaceMember := func(p Symbol) bool {
			return !!(p.flags & (SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsAlias)) || !(p.flags&SymbolFlagsPrototype || p.escapedName == "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent))
		}

		sanitizeJSDocImplements := func(clauses []ExpressionWithTypeArguments) *[]ExpressionWithTypeArguments {
			result := mapDefined(clauses, func(e ExpressionWithTypeArguments) *ExpressionWithTypeArguments {
				oldEnclosing := context.enclosingDeclaration
				context.enclosingDeclaration = e
				expr := e.expression
				if isEntityNameExpression(expr) {
					if isIdentifier(expr) && idText(expr) == "" {
						return cleanup(nil)
						// Empty heritage clause, should be an error, but prefer emitting no heritage clauses to reemitting the empty one
					}
					var introducesError bool
					( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: { introducesError, node: expr } = trackExistingEntityName(expr, context) */ TODO)
					if introducesError {
						return cleanup(nil)
					}
				}
				return cleanup(factory.createExpressionWithTypeArguments(expr, map_(e.typeArguments, func(a TypeNode) TypeNode {
					return tryReuseExistingNonParameterTypeNode(context, a, getTypeFromTypeNode(context, a)) || typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context)
				})))

				cleanup := func(result T) T {
					context.enclosingDeclaration = oldEnclosing
					return result
				}

			})
			if result.length == clauses.length {
				return result
			}
			return nil
		}

		serializeAsClass := func(symbol Symbol, localName string, modifierFlags ModifierFlags) {
			originalDecl := symbol.declarations. /* ? */ find(isClassLike)
			oldEnclosing := context.enclosingDeclaration
			context.enclosingDeclaration = originalDecl || oldEnclosing
			localParams := tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			typeParamDecls := map_(localParams, func(p TypeParameter) TypeParameterDeclaration {
				return typeParameterToDeclaration(p, context)
			})
			classType := tc.getTypeWithThisArgument(tc.getDeclaredTypeOfClassOrInterface(symbol)) /* as InterfaceType */
			baseTypes := tc.getBaseTypes(classType)
			originalImplements := originalDecl && getEffectiveImplementsTypeNodes(originalDecl)
			implementsExpressions := originalImplements && sanitizeJSDocImplements(originalImplements) || mapDefined(tc.getImplementsTypes(classType), serializeImplementedType)
			staticType := tc.getTypeOfSymbol(symbol)
			isClass := !!staticType.symbol. /* ? */ valueDeclaration && isClassLike(staticType.symbol.valueDeclaration)
			var staticBaseType Type
			if isClass {
				staticBaseType = tc.getBaseConstructorTypeOfClass(staticType /* as InterfaceType */)
			} else {
				staticBaseType = tc.anyType
			}
			heritageClauses := []HeritageClause{ /* TODO(TS-TO-GO) Node SpreadElement: ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))] */ /* TODO(TS-TO-GO) Node SpreadElement: ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)] */ }
			symbolProps := tc.getNonInheritedProperties(classType, baseTypes, tc.getPropertiesOfType(classType))
			publicSymbolProps := filter(symbolProps, func(s Symbol) bool {
				// `valueDeclaration` could be undefined if inherited from
				// a union/intersection base type, but inherited properties
				// don't matter here.
				valueDecl := s.valueDeclaration
				return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name))
			})
			hasPrivateIdentifier := some(symbolProps, func(s Symbol) bool {
				// `valueDeclaration` could be undefined if inherited from
				// a union/intersection base type, but inherited properties
				// don't matter here.
				valueDecl := s.valueDeclaration
				return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name)
			})
			// Boil down all private properties into a single one.
			var privateProperties []PropertyDeclaration
			if hasPrivateIdentifier {
				privateProperties = []PropertyDeclaration{factory.createPropertyDeclaration(nil, factory.createPrivateIdentifier("#private"), nil, nil, nil)}
			} else {
				privateProperties = emptyArray
			}
			publicProperties := flatMap(publicSymbolProps, func(p Symbol) [] /* TODO(TS-TO-GO) inferred type ClassElement | AccessorDeclaration | (ClassElement | AccessorDeclaration) */ any {
				return serializePropertySymbolForClass(p /*isStatic*/, false, baseTypes[0])
			})
			// Consider static members empty if symbol also has function or module meaning - function namespacey emit will handle statics
			staticMembers := flatMap(filter(tc.getPropertiesOfType(staticType), func(p Symbol) bool {
				return !(p.flags & SymbolFlagsPrototype) && p.escapedName != "prototype" && !isNamespaceMember(p)
			}), func(p Symbol) [] /* TODO(TS-TO-GO) inferred type ClassElement | AccessorDeclaration | (ClassElement | AccessorDeclaration) */ any {
				return serializePropertySymbolForClass(p /*isStatic*/, true, staticBaseType)
			})
			// When we encounter an `X.prototype.y` assignment in a JS file, we bind `X` as a class regardless as to whether
			// the value is ever initialized with a class or function-like value. For cases where `X` could never be
			// created via `new`, we will inject a `private constructor()` declaration to indicate it is not createable.
			isNonConstructableClassLikeInJsFile := !isClass && !!symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && !some(tc.getSignaturesOfType(staticType, SignatureKindConstruct))
			var constructors []ConstructorDeclaration
			if isNonConstructableClassLikeInJsFile {
				constructors = []ConstructorDeclaration{factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlagsPrivate), []never{} /*body*/, nil)}
			} else {
				constructors = serializeSignatures(SignatureKindConstruct, staticType, staticBaseType, SyntaxKindConstructor) /* as ConstructorDeclaration[] */
			}
			indexSignatures := serializeIndexSignatures(classType, baseTypes[0])
			context.enclosingDeclaration = oldEnclosing
			addResult(setTextRange(context, factory.createClassDeclaration(nil, localName, typeParamDecls, heritageClauses, []ClassElement{ /* TODO(TS-TO-GO) Node SpreadElement: ...indexSignatures */ /* TODO(TS-TO-GO) Node SpreadElement: ...staticMembers */ /* TODO(TS-TO-GO) Node SpreadElement: ...constructors */ /* TODO(TS-TO-GO) Node SpreadElement: ...publicProperties */ /* TODO(TS-TO-GO) Node SpreadElement: ...privateProperties */ }), symbol.declarations && filter(symbol.declarations, func(d Declaration) bool {
				return isClassDeclaration(d) || isClassExpression(d)
			})[0]), modifierFlags)
		}

		getSomeTargetNameFromDeclarations := func(declarations *[]Declaration) *string {
			return firstDefined(declarations, func(d Declaration) *string {
				if isImportSpecifier(d) || isExportSpecifier(d) {
					return moduleExportNameTextUnescaped(d.propertyName || d.name)
				}
				if isBinaryExpression(d) || isExportAssignment(d) {
					var expression Expression
					if isExportAssignment(d) {
						expression = d.expression
					} else {
						expression = d.right
					}
					if isPropertyAccessExpression(expression) {
						return idText(expression.name)
					}
				}
				if tc.isAliasSymbolDeclaration(d) {
					// This is... heuristic, at best. But it's probably better than always printing the name of the shorthand ambient module.
					name := getNameOfDeclaration(d)
					if name && isIdentifier(name) {
						return idText(name)
					}
				}
				return nil
			})
		}

		serializeAsAlias := func(symbol Symbol, localName string, modifierFlags ModifierFlags) undefined {
			// synthesize an alias, eg `export { symbolName as Name }`
			// need to mark the alias `symbol` points at
			// as something we need to serialize as a private declaration as well
			node := tc.getDeclarationOfAliasSymbol(symbol)
			if !node {
				return Debug.fail()
			}
			target := tc.getMergedSymbol(tc.getTargetOfAliasDeclaration(node /*dontRecursivelyResolve*/, true))
			if !target {
				return
			}
			// If `target` refers to a shorthand module symbol, the name we're trying to pull out isn;t recoverable from the target symbol
			// In such a scenario, we must fall back to looking for an alias declaration on `symbol` and pulling the target name from that
			verbatimTargetName := isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName)
			if verbatimTargetName == InternalSymbolNameExportEquals && tc.allowSyntheticDefaultImports {
				// target refers to an `export=` symbol that was hoisted into a synthetic default - rename here to match
				verbatimTargetName = InternalSymbolNameDefault
			}
			targetName := getInternalSymbolName(target, verbatimTargetName)
			includePrivateSymbol(target)
			// the target may be within the same scope - attempt to serialize it first
			switch node.kind {
			case SyntaxKindBindingElement:
				if node.parent. /* ? */ parent. /* ? */ kind == SyntaxKindVariableDeclaration {
					// const { SomeClass } = require('./lib');
					specifier := getSpecifierForModuleSymbol(target.parent || target, context)
					// './lib'
					TODO_IDENTIFIER := node /* as BindingElement */
					addResult(factory.createImportDeclaration(nil, factory.createImportClause(false, nil, factory.createNamedImports([]ImportSpecifier{factory.createImportSpecifier(false, __COND__(propertyName && isIdentifier(propertyName), factory.createIdentifier(idText(propertyName)), nil), factory.createIdentifier(localName))})), factory.createStringLiteral(specifier), nil), ModifierFlagsNone)
					break
				}
				Debug.failBadSyntaxKind(node.parent. /* ? */ parent || node, "Unhandled binding element grandparent kind in declaration serialization")
			case SyntaxKindShorthandPropertyAssignment:
				if node.parent. /* ? */ parent. /* ? */ kind == SyntaxKindBinaryExpression {
					// module.exports = { SomeClass }
					serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), targetName)
				}
			case SyntaxKindVariableDeclaration:
				if isPropertyAccessExpression((node /* as VariableDeclaration */).initializer) {
					// const x = require('y').z
					initializer := (node /* as VariableDeclaration */).initializer /* as PropertyAccessExpression */
					// require('y').z
					uniqueName := factory.createUniqueName(localName)
					// _x
					specifier := getSpecifierForModuleSymbol(target.parent || target, context)
					// import _x = require('y');
					addResult(factory.createImportEqualsDeclaration(nil, false, uniqueName, factory.createExternalModuleReference(factory.createStringLiteral(specifier))), ModifierFlagsNone)
					// import x = _x.z
					addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName), factory.createQualifiedName(uniqueName, initializer.name /* as Identifier */)), modifierFlags)
					break
				}
				fallthrough
			case SyntaxKindImportEqualsDeclaration:
				if target.escapedName == InternalSymbolNameExportEquals && some(target.declarations, func(d Declaration) bool {
					return isSourceFile(d) && isJsonSourceFile(d)
				}) {
					serializeMaybeAliasAssignment(symbol)
					break
				}
				isLocalImport := !(target.flags & SymbolFlagsValueModule) && !isVariableDeclaration(node)
				addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(localName), __COND__(isLocalImport, symbolToName(target, context, SymbolFlagsAll /*expectsIdentifier*/, false), factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))))), __COND__(isLocalImport, modifierFlags, ModifierFlagsNone))
			case SyntaxKindNamespaceExportDeclaration:
				addResult(factory.createNamespaceExportDeclaration(idText((node /* as NamespaceExportDeclaration */).name)), ModifierFlagsNone)
			case SyntaxKindImportClause:
				generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
				// generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
				var specifier Expression
				if context.bundled {
					specifier = factory.createStringLiteral(generatedSpecifier)
				} else {
					specifier = (node /* as ImportClause */).parent.moduleSpecifier
				}
				var attributes *ImportAttributes
				if isImportDeclaration(node.parent) {
					attributes = node.parent.attributes
				} else {
					attributes = nil
				}
				isTypeOnly := isJSDocImportTag((node /* as ImportClause */).parent)
				addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, factory.createIdentifier(localName) /*namedBindings*/, nil), specifier, attributes), ModifierFlagsNone)
				break
				fallthrough
			case SyntaxKindNamespaceImport:
				generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
				// generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
				var specifier Expression
				if context.bundled {
					specifier = factory.createStringLiteral(generatedSpecifier)
				} else {
					specifier = (node /* as NamespaceImport */).parent.parent.moduleSpecifier
				}
				isTypeOnly := isJSDocImportTag((node /* as NamespaceImport */).parent.parent)
				addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly /*name*/, nil, factory.createNamespaceImport(factory.createIdentifier(localName))), specifier, (node /* as ImportClause */).parent.attributes), ModifierFlagsNone)
				break
				fallthrough
			case SyntaxKindNamespaceExport:
				addResult(factory.createExportDeclaration(nil, false, factory.createNamespaceExport(factory.createIdentifier(localName)), factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))), ModifierFlagsNone)
			case SyntaxKindImportSpecifier:
				generatedSpecifier := getSpecifierForModuleSymbol(target.parent || target, context)
				// generate specifier (even though we're reusing and existing one) for ambient module reference include side effects
				var specifier Expression
				if context.bundled {
					specifier = factory.createStringLiteral(generatedSpecifier)
				} else {
					specifier = (node /* as ImportSpecifier */).parent.parent.parent.moduleSpecifier
				}
				isTypeOnly := isJSDocImportTag((node /* as ImportSpecifier */).parent.parent.parent)
				addResult(factory.createImportDeclaration(nil, factory.createImportClause(isTypeOnly, nil, factory.createNamedImports([]ImportSpecifier{factory.createImportSpecifier(false, __COND__(localName != verbatimTargetName, factory.createIdentifier(verbatimTargetName), nil), factory.createIdentifier(localName))})), specifier, (node /* as ImportSpecifier */).parent.parent.parent.attributes), ModifierFlagsNone)
				break
				fallthrough
			case SyntaxKindExportSpecifier:
				specifier := (node.parent.parent /* as ExportDeclaration */).moduleSpecifier
				if specifier {
					propertyName := (node /* as ExportSpecifier */).propertyName
					if propertyName && moduleExportNameIsDefault(propertyName) {
						verbatimTargetName = InternalSymbolNameDefault
					}
				}
				serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), __COND__(specifier, verbatimTargetName, targetName), __COND__(specifier && isStringLiteralLike(specifier), factory.createStringLiteral(specifier.text), nil))
			case SyntaxKindExportAssignment:
				serializeMaybeAliasAssignment(symbol)
			case SyntaxKindBinaryExpression,
				SyntaxKindPropertyAccessExpression,
				SyntaxKindElementAccessExpression:
				if symbol.escapedName == InternalSymbolNameDefault || symbol.escapedName == InternalSymbolNameExportEquals {
					serializeMaybeAliasAssignment(symbol)
				} else {
					serializeExportSpecifier(localName, targetName)
				}
			default:
				return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!")
			}
		}

		serializeExportSpecifier := func(localName string, targetName string, specifier Expression) {
			addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports([]ExportSpecifier{factory.createExportSpecifier(false, __COND__(localName != targetName, targetName, nil), localName)}), specifier), ModifierFlagsNone)
		}

		/**
		 * Returns `true` if an export assignment or declaration was produced for the symbol
		 */

		serializeMaybeAliasAssignment := func(symbol Symbol) bool {
			if symbol.flags & SymbolFlagsPrototype {
				return false
			}
			name := unescapeLeadingUnderscores(symbol.escapedName)
			isExportEquals := name == InternalSymbolNameExportEquals
			isDefault := name == InternalSymbolNameDefault
			isExportAssignmentCompatibleSymbolName := isExportEquals || isDefault
			// synthesize export = ref
			// ref should refer to either be a locally scoped symbol which we need to emit, or
			// a reference to another namespace/module which we may need to emit an `import` statement for
			aliasDecl := symbol.declarations && tc.getDeclarationOfAliasSymbol(symbol)
			// serialize what the alias points to, preserve the declaration's initializer
			target := aliasDecl && tc.getTargetOfAliasDeclaration(aliasDecl /*dontRecursivelyResolve*/, true)
			// If the target resolves and resolves to a thing defined in this file, emit as an alias, otherwise emit as a const
			if target && length(target.declarations) && some(target.declarations, func(d Declaration) bool {
				return getSourceFileOfNode(d) == getSourceFileOfNode(enclosingDeclaration)
			}) {
				// In case `target` refers to a namespace member, look at the declaration and serialize the leftmost symbol in it
				// eg, `namespace A { export class B {} }; exports = A.B;`
				// Technically, this is all that's required in the case where the assignment is an entity name expression
				expr := aliasDecl && (__COND__((isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)), getExportAssignmentExpression(aliasDecl), getPropertyAssignmentAliasLikeExpression(aliasDecl /* as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression */)))
				var first *Identifier
				if expr && isEntityNameExpression(expr) {
					first = tc.getFirstNonModuleExportsIdentifier(expr)
				} else {
					first = nil
				}
				referenced := first && tc.resolveEntityName(first, SymbolFlagsAll /*ignoreErrors*/, true /*dontResolveAlias*/, true, enclosingDeclaration)
				if referenced || target {
					includePrivateSymbol(referenced || target)
				}

				// We disable the context's symbol tracker for the duration of this name serialization
				// as, by virtue of being here, the name is required to print something, and we don't want to
				// issue a visibility error on it. Only anonymous classes that an alias points at _would_ issue
				// a visibility error here (as they're not visible within any scope), but we want to hoist them
				// into the containing scope anyway, so we want to skip the visibility checks.
				prevDisableTrackSymbol := context.tracker.disableTrackSymbol
				context.tracker.disableTrackSymbol = true
				if isExportAssignmentCompatibleSymbolName {
					results.push(factory.createExportAssignment(nil, isExportEquals, symbolToExpression(target, context, SymbolFlagsAll)))
				} else {
					if first == expr && first {
						// serialize as `export {target as name}`
						serializeExportSpecifier(name, idText(first))
					} else if expr && isClassExpression(expr) {
						serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)))
					} else {
						// serialize as `import _Ref = t.arg.et; export { _Ref as name }`
						varName := getUnusedName(name, symbol)
						addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(varName), symbolToName(target, context, SymbolFlagsAll /*expectsIdentifier*/, false)), ModifierFlagsNone)
						serializeExportSpecifier(name, varName)
					}
				}
				context.tracker.disableTrackSymbol = prevDisableTrackSymbol
				return true
			} else {
				// serialize as an anonymous property declaration
				varName := getUnusedName(name, symbol)
				// We have to use `getWidenedType` here since the object within a json file is unwidened within the file
				// (Unwidened types can only exist in expression contexts and should never be serialized)
				typeToSerialize := tc.getWidenedType(tc.getTypeOfSymbol(tc.getMergedSymbol(symbol)))
				if isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol) {
					// If there are no index signatures and `typeToSerialize` is an object type, emit as a namespace instead of a const
					serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, __COND__(isExportAssignmentCompatibleSymbolName, ModifierFlagsNone, ModifierFlagsExport))
				} else {
					var flags /* TODO(TS-TO-GO) inferred type NodeFlags.Let | NodeFlags.Const */ any
					if context.enclosingDeclaration. /* ? */ kind == SyntaxKindModuleDeclaration && (!(symbol.flags & SymbolFlagsAccessor) || symbol.flags&SymbolFlagsSetAccessor) {
						flags = NodeFlagsLet
					} else {
						flags = NodeFlagsConst
					}
					statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList([]VariableDeclaration{factory.createVariableDeclaration(varName /*exclamationToken*/, nil, serializeTypeForDeclaration(context /*declaration*/, nil, typeToSerialize, symbol))}, flags))
					// Inlined JSON types exported with [module.]exports= will already emit an export=, so should use `declare`.
					// Otherwise, the type itself should be exported.
					addResult(statement, __COND__(target && target.flags&SymbolFlagsProperty && target.escapedName == InternalSymbolNameExportEquals, ModifierFlagsAmbient, __COND__(name == varName, ModifierFlagsExport, ModifierFlagsNone)))
				}
				if isExportAssignmentCompatibleSymbolName {
					results.push(factory.createExportAssignment(nil, isExportEquals, factory.createIdentifier(varName)))
					return true
				} else if name != varName {
					serializeExportSpecifier(name, varName)
					return true
				}
				return false
			}
		}

		isTypeRepresentableAsFunctionNamespaceMerge := func(typeToSerialize Type, hostSymbol Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
			// Only object types which are not constructable, or indexable, whose members all come from the
			// context source file, and whose property names are all valid identifiers and not late-bound, _and_
			// whose input is not type annotated (if the input symbol has an annotation we can reuse, we should prefer it)
			ctxSrc := getSourceFileOfNode(context.enclosingDeclaration)
			return getObjectFlags(typeToSerialize)&(ObjectFlagsAnonymous|ObjectFlagsMapped) && !some(typeToSerialize.symbol. /* ? */ declarations, isTypeNode) && !length(tc.getIndexInfosOfType(typeToSerialize)) && !tc.isClassInstanceSide(typeToSerialize) && !!(length(filter(tc.getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(tc.getSignaturesOfType(typeToSerialize, SignatureKindCall))) && !length(tc.getSignaturesOfType(typeToSerialize, SignatureKindConstruct)) && !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) && !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, func(d Declaration) bool {
				return getSourceFileOfNode(d) != ctxSrc
			})) && !some(tc.getPropertiesOfType(typeToSerialize), func(p Symbol) bool {
				return tc.isLateBoundName(p.escapedName)
			}) && !some(tc.getPropertiesOfType(typeToSerialize), func(p Symbol) bool {
				return some(p.declarations, func(d Declaration) bool {
					return getSourceFileOfNode(d) != ctxSrc
				})
			}) && every(tc.getPropertiesOfType(typeToSerialize), func(p Symbol) bool {
				if !isIdentifierText(symbolName(p), tc.languageVersion) {
					return false
				}
				if !(p.flags & SymbolFlagsAccessor) {
					return true
				}
				return tc.getNonMissingTypeOfSymbol(p) == tc.getWriteTypeOfSymbol(p)
			})
		}

		/* OVERLOAD: function makeSerializePropertySymbol<T extends Node>( createProperty: ( modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined, ) => T, methodKind: SignatureDeclaration["kind"], useAccessors: true, ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | AccessorDeclaration | (T | AccessorDeclaration)[]; */
		/* OVERLOAD: function makeSerializePropertySymbol<T extends Node>( createProperty: ( modifiers: readonly Modifier[] | undefined, name: string | PropertyName, questionOrExclamationToken: QuestionToken | undefined, type: TypeNode | undefined, initializer: Expression | undefined, ) => T, methodKind: SignatureDeclaration["kind"], useAccessors: false, ): (p: Symbol, isStatic: boolean, baseType: Type | undefined) => T | T[]; */
		makeSerializePropertySymbol := func(createProperty func(modifiers *[]Modifier, name /* TODO(TS-TO-GO) TypeNode UnionType: string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer Expression) T, methodKind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any, useAccessors bool) func(p Symbol, isStatic bool, baseType Type) /* TODO(TS-TO-GO) TypeNode UnionType: T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
			return func /* serializePropertySymbol */ (p Symbol, isStatic bool, baseType Type) /* TODO(TS-TO-GO) TypeNode UnionType: T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
				modifierFlags := getDeclarationModifierFlagsFromSymbol(p)
				isPrivate := !!(modifierFlags & ModifierFlagsPrivate)
				if isStatic && (p.flags & (SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsAlias)) {
					// Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols
					// need to be merged namespace members
					return []never{}
				}
				if p.flags&SymbolFlagsPrototype || p.escapedName == "constructor" || (baseType && tc.getPropertyOfType(baseType, p.escapedName) && tc.isReadonlySymbol(tc.getPropertyOfType(baseType, p.escapedName)) == tc.isReadonlySymbol(p) && (p.flags&SymbolFlagsOptional) == (tc.getPropertyOfType(baseType, p.escapedName).flags&SymbolFlagsOptional) && tc.isTypeIdenticalTo(tc.getTypeOfSymbol(p), tc.getTypeOfPropertyOfType(baseType, p.escapedName))) {
					return []never{}
				}
				flag := (modifierFlags & ~ModifierFlagsAsync) | (__COND__(isStatic, ModifierFlagsStatic, 0))
				name := getPropertyNameNodeForSymbol(p, context)
				firstPropertyLikeDecl := p.declarations. /* ? */ find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression))
				if p.flags&SymbolFlagsAccessor && useAccessors {
					var result []AccessorDeclaration = []never{}
					if p.flags & SymbolFlagsSetAccessor {
						setter := p.declarations && forEach(p.declarations, func(d Declaration) * /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any {
							if d.kind == SyntaxKindSetAccessor {
								return d /* as SetAccessorDeclaration */
							}
							if isCallExpression(d) && isBindableObjectDefinePropertyCall(d) {
								return forEach(d.arguments[2].properties, func(propDecl /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) * /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any {
									id := getNameOfDeclaration(propDecl)
									if !!id && isIdentifier(id) && idText(id) == "set" {
										return propDecl
									}
								})
							}
						})

						Debug.assert(!!setter)
						var paramSymbol Symbol
						if isFunctionLikeDeclaration(setter) {
							paramSymbol = tc.getSignatureFromDeclaration(setter).parameters[0]
						} else {
							paramSymbol = nil
						}

						result.push(setTextRange(context, factory.createSetAccessorDeclaration(factory.createModifiersFromModifierFlags(flag), name, []ParameterDeclaration{factory.createParameterDeclaration(nil, nil, __COND__(paramSymbol, parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context), "value"), nil, __COND__(isPrivate, nil, serializeTypeForDeclaration(context /*declaration*/, nil, tc.getWriteTypeOfSymbol(p), p)))}, nil), p.declarations. /* ? */ find(isSetAccessor) || firstPropertyLikeDecl))
					}
					if p.flags & SymbolFlagsGetAccessor {
						isPrivate := modifierFlags & ModifierFlagsPrivate
						result.push(setTextRange(context, factory.createGetAccessorDeclaration(factory.createModifiersFromModifierFlags(flag), name, []never{}, __COND__(isPrivate, nil, serializeTypeForDeclaration(context /*declaration*/, nil, tc.getTypeOfSymbol(p), p)), nil), p.declarations. /* ? */ find(isGetAccessor) || firstPropertyLikeDecl))
					}
					return result
				} else if p.flags & (SymbolFlagsProperty | SymbolFlagsVariable | SymbolFlagsAccessor) {
					return setTextRange(context, createProperty(factory.createModifiersFromModifierFlags((__COND__(tc.isReadonlySymbol(p), ModifierFlagsReadonly, 0))|flag), name, __COND__(p.flags&SymbolFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil), __COND__(isPrivate, nil, serializeTypeForDeclaration(context /*declaration*/, nil, tc.getWriteTypeOfSymbol(p), p)), nil), p.declarations. /* ? */ find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl)
				}
				if p.flags & (SymbolFlagsMethod | SymbolFlagsFunction) {
					type_ := tc.getTypeOfSymbol(p)
					signatures := tc.getSignaturesOfType(type_, SignatureKindCall)
					if flag & ModifierFlagsPrivate {
						return setTextRange(context, createProperty(factory.createModifiersFromModifierFlags((__COND__(tc.isReadonlySymbol(p), ModifierFlagsReadonly, 0))|flag), name, __COND__(p.flags&SymbolFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil), nil, nil), p.declarations. /* ? */ find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0])
					}

					results := []never{}
					for _, sig := range signatures {
						// Each overload becomes a separate method declaration, in order
						decl := signatureToSignatureDeclarationHelper(sig, methodKind, context, map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"name":          name,
							"questionToken": __COND__(p.flags&SymbolFlagsOptional, factory.createToken(SyntaxKindQuestionToken), nil),
							"modifiers":     __COND__(flag, factory.createModifiersFromModifierFlags(flag), nil),
						})
						var location * /* TODO(TS-TO-GO) inferred type SignatureDeclaration | JSDocSignature | PrototypePropertyAssignment */ any
						if sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) {
							location = sig.declaration.parent
						} else {
							location = sig.declaration
						}
						results.push(setTextRange(context, decl, location))
					}
					return results /* as unknown */ /* as T[] */
				}
				// The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static
				return Debug.fail(__TEMPLATE__("Unhandled class member kind! ", (p /* as any */).__debugFlags || p.flags))
			}
		}

		serializePropertySymbolForInterface := func(p Symbol, baseType Type) [] /* TODO(TS-TO-GO) inferred type TypeElement | TypeElement */ any {
			return serializePropertySymbolForInterfaceWorker(p /*isStatic*/, false, baseType)
		}

		serializeSignatures := func(kind SignatureKind, input Type, baseType Type, outputKind /* TODO(TS-TO-GO) TypeNode IndexedAccessType: SignatureDeclaration["kind"] */ any) [] /* TODO(TS-TO-GO) inferred type (CallSignatureDeclaration | ConstructSignatureDeclaration | MethodSignature | IndexSignatureDeclaration | FunctionTypeNode | ConstructorTypeNode | JSDocFunctionType | FunctionDeclaration | MethodDeclaration | ConstructorDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | FunctionExpression | ArrowFunction) */ any {
			signatures := tc.getSignaturesOfType(input, kind)
			if kind == SignatureKindConstruct {
				if !baseType && every(signatures, func(s Signature) bool {
					return length(s.parameters) == 0
				}) {
					return []never{}
					// No base type, every constructor is empty - elide the extraneous `constructor()`
				}
				if baseType {
					// If there is a base type, if every signature in the class is identical to a signature in the baseType, elide all the declarations
					baseSigs := tc.getSignaturesOfType(baseType, SignatureKindConstruct)
					if !length(baseSigs) && every(signatures, func(s Signature) bool {
						return length(s.parameters) == 0
					}) {
						return []never{}
						// Base had no explicit signatures, if all our signatures are also implicit, return an empty list
					}
					if baseSigs.length == signatures.length {
						failed := false
						for i := 0; i < baseSigs.length; i++ {
							if !tc.compareSignaturesIdentical(signatures[i], baseSigs[i] /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true, tc.compareTypesIdentical) {
								failed = true
								break
							}
						}
						if !failed {
							return []never{}
							// Every signature was identical - elide constructor list as it is inherited
						}
					}
				}
				var privateProtected ModifierFlags = 0
				for _, s := range signatures {
					if s.declaration {
						privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlagsPrivate|ModifierFlagsProtected)
					}
				}
				if privateProtected {
					return []ConstructorDeclaration{setTextRange(context, factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(privateProtected), []never{}, nil), signatures[0].declaration)}
				}
			}

			results := []never{}
			for _, sig := range signatures {
				// Each overload becomes a separate constructor declaration, in order
				decl := signatureToSignatureDeclarationHelper(sig, outputKind, context)
				results.push(setTextRange(context, decl, sig.declaration))
			}
			return results
		}

		serializeIndexSignatures := func(input Type, baseType Type) []IndexSignatureDeclaration {
			var results []IndexSignatureDeclaration = []never{}
			for _, info := range tc.getIndexInfosOfType(input) {
				if baseType {
					baseInfo := tc.getIndexInfoOfType(baseType, info.keyType)
					if baseInfo {
						if tc.isTypeIdenticalTo(info.type_, baseInfo.type_) {
							continue
							// elide identical index signatures
						}
					}
				}
				results.push(indexInfoToIndexSignatureDeclarationHelper(info, context /*typeNode*/, nil))
			}
			return results
		}

		serializeBaseType := func(t Type, staticType Type, rootName string) ExpressionWithTypeArguments {
			ref := trySerializeAsTypeReference(t, SymbolFlagsValue)
			if ref {
				return ref
			}
			tempName := getUnusedName(__TEMPLATE__(rootName, "_base"))
			statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList([]VariableDeclaration{factory.createVariableDeclaration(tempName /*exclamationToken*/, nil, typeToTypeNodeHelper(staticType, context))}, NodeFlagsConst))
			addResult(statement, ModifierFlagsNone)
			return factory.createExpressionWithTypeArguments(factory.createIdentifier(tempName) /*typeArguments*/, nil)
		}

		trySerializeAsTypeReference := func(t Type, flags SymbolFlags) *ExpressionWithTypeArguments {
			var typeArgs *[]TypeNode
			var reference Expression

			// We don't use `isValueSymbolAccessible` below. since that considers alternative containers (like modules)
			// which we can't write out in a syntactically valid way as an expression
			if (t /* as TypeReference */).target && tc.isSymbolAccessibleByFlags((t /* as TypeReference */).target.symbol, enclosingDeclaration, flags) {
				typeArgs = map_(tc.getTypeArguments(t /* as TypeReference */), func(t Type) TypeNode {
					return typeToTypeNodeHelper(t, context)
				})
				reference = symbolToExpression((t /* as TypeReference */).target.symbol, context, SymbolFlagsType)
			} else if t.symbol && tc.isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags) {
				reference = symbolToExpression(t.symbol, context, SymbolFlagsType)
			}
			if reference {
				return factory.createExpressionWithTypeArguments(reference, typeArgs)
			}
		}

		serializeImplementedType := func(t Type) *ExpressionWithTypeArguments {
			ref := trySerializeAsTypeReference(t, SymbolFlagsType)
			if ref {
				return ref
			}
			if t.symbol {
				return factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, SymbolFlagsType) /*typeArguments*/, nil)
			}
		}

		getUnusedName := func(input string, symbol Symbol) string {
			var id *number
			if symbol {
				id = getSymbolId(symbol)
			} else {
				id = nil
			}
			if id {
				if context.remappedSymbolNames.has(id) {
					return context.remappedSymbolNames.get(id)
				}
			}
			if symbol {
				input = getNameCandidateWorker(symbol, input)
			}
			i := 0
			original := input
			for context.usedSymbolNames. /* ? */ has(input) {
				i++
				input = __TEMPLATE__(original, "_", i)
			}
			context.usedSymbolNames. /* ? */ add(input)
			if id {
				context.remappedSymbolNames.set(id, input)
			}
			return input
		}

		getNameCandidateWorker := func(symbol Symbol, localName string) string {
			if localName == InternalSymbolNameDefault || localName == InternalSymbolNameClass || localName == InternalSymbolNameFunction {
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInInitialEntityName
				nameCandidate := tc.getNameOfSymbolAsWritten(symbol, context)
				restoreFlags()
				if nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) {
					localName = stripQuotes(nameCandidate)
				} else {
					localName = nameCandidate
				}
			}
			if localName == InternalSymbolNameDefault {
				localName = "_default"
			} else if localName == InternalSymbolNameExportEquals {
				localName = "_exports"
			}
			if isIdentifierText(localName, tc.languageVersion) && !isStringANonContextualKeyword(localName) {
				localName = localName
			} else {
				localName = "_" + localName.replace( /* TODO(TS-TO-GO) Node RegularExpressionLiteral: /[^a-z0-9]/gi */ TODO, "_")
			}
			return localName
		}

		getInternalSymbolName := func(symbol Symbol, localName string) string {
			id := getSymbolId(symbol)
			if context.remappedSymbolNames.has(id) {
				return context.remappedSymbolNames.get(id)
			}
			localName = getNameCandidateWorker(symbol, localName)
			// The result of this is going to be used as the symbol's name - lock it in, so `getUnusedName` will also pick it up
			context.remappedSymbolNames.set(id, localName)
			return localName
		}

	}

}

func (tc *TypeChecker) typePredicateToString(typePredicate TypePredicate, enclosingDeclaration Node, flags TypeFormatFlags /*  = TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter) string {
	if writer {
		return typePredicateToStringWorker(writer).getText()
	} else {
		return usingSingleLineStringWriter(typePredicateToStringWorker)
	}

	typePredicateToStringWorker := func(writer EmitTextWriter) EmitTextWriter {
		nodeBuilderFlags := tc.toNodeBuilderFlags(flags) | NodeBuilderFlagsIgnoreErrors | NodeBuilderFlagsWriteTypeParametersInQualifiedName
		predicate := tc.nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)
		// TODO: GH#18217
		printer := createPrinterWithRemoveComments()
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		printer.writeNode(EmitHintUnspecified, predicate /*sourceFile*/, sourceFile, writer)
		return writer
	}

}

func (tc *TypeChecker) formatUnionTypes(types []Type) []Type {
	var result []Type = []never{}
	flags := 0 /* as TypeFlags */
	for i := 0; i < types.length; i++ {
		t := types[i]
		flags |= t.flags
		if !(t.flags & TypeFlagsNullable) {
			if t.flags & (TypeFlagsBooleanLiteral | TypeFlagsEnumLike) {
				var baseType Type
				if t.flags & TypeFlagsBooleanLiteral {
					baseType = tc.booleanType
				} else {
					baseType = tc.getBaseTypeOfEnumLikeType(t /* as LiteralType */)
				}
				if baseType.flags & TypeFlagsUnion {
					count := (baseType /* as UnionType */).types.length
					if i+count <= types.length && tc.getRegularTypeOfLiteralType(types[i+count-1]) == tc.getRegularTypeOfLiteralType((baseType /* as UnionType */).types[count-1]) {
						result.push(baseType)
						i += count - 1
						continue
					}
				}
			}
			result.push(t)
		}
	}
	if flags & TypeFlagsNull {
		result.push(tc.nullType)
	}
	if flags & TypeFlagsUndefined {
		result.push(tc.undefinedType)
	}
	return result || types
}

func (tc *TypeChecker) visibilityToString(flags ModifierFlags) string {
	if flags == ModifierFlagsPrivate {
		return "private"
	}
	if flags == ModifierFlagsProtected {
		return "protected"
	}
	return "public"
}

func (tc *TypeChecker) getTypeAliasForTypeLiteral(type_ Type) Symbol {
	if type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && type_.symbol.declarations {
		node := walkUpParenthesizedTypes(type_.symbol.declarations[0].parent)
		if isTypeAliasDeclaration(node) {
			return tc.getSymbolOfDeclaration(node)
		}
	}
	return nil
}

func (tc *TypeChecker) isTopLevelInExternalModuleAugmentation(node Node) bool {
	return node && node.parent && node.parent.kind == SyntaxKindModuleBlock && isExternalModuleAugmentation(node.parent.parent)
}

func (tc *TypeChecker) isDefaultBindingContext(location Node) bool {
	return location.kind == SyntaxKindSourceFile || isAmbientModule(location)
}

func (tc *TypeChecker) getNameOfSymbolFromNameType(symbol Symbol, context NodeBuilderContext) *string {
	nameType := tc.getSymbolLinks(symbol).nameType
	if nameType {
		if nameType.flags & TypeFlagsStringOrNumberLiteral {
			name := "" + (nameType /* as StringLiteralType | NumberLiteralType */).value
			if !isIdentifierText(name, getEmitScriptTarget(tc.compilerOptions)) && !isNumericLiteralName(name) {
				return __TEMPLATE__("\"", escapeString(name, CharacterCodesdoubleQuote), "\"")
			}
			if isNumericLiteralName(name) && startsWith(name, "-") {
				return __TEMPLATE__("[", name, "]")
			}
			return name
		}
		if nameType.flags & TypeFlagsUniqueESSymbol {
			return __TEMPLATE__("[", tc.getNameOfSymbolAsWritten((nameType /* as UniqueESSymbolType */).symbol, context), "]")
		}
	}
}

/**
 * Gets a human-readable name for a symbol.
 * Should *not* be used for the right-hand side of a `.` -- use `symbolName(symbol)` for that instead.
 *
 * Unlike `symbolName(symbol)`, this will include quotes if the name is from a string literal.
 * It will also use a representation of a number as written instead of a decimal form, e.g. `0o11` instead of `9`.
 */

func (tc *TypeChecker) getNameOfSymbolAsWritten(symbol Symbol, context NodeBuilderContext) string {
	if context. /* ? */ remappedSymbolReferences. /* ? */ has(getSymbolId(symbol)) {
		symbol = context.remappedSymbolReferences.get(getSymbolId(symbol))
	}
	if context && symbol.escapedName == InternalSymbolNameDefault && !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope) && (!(context.flags & NodeBuilderFlagsInInitialEntityName) || !symbol.declarations || (context.enclosingDeclaration && findAncestor(symbol.declarations[0], tc.isDefaultBindingContext) != findAncestor(context.enclosingDeclaration, tc.isDefaultBindingContext))) {
		return "default"
	}
	if symbol.declarations && symbol.declarations.length {
		declaration := firstDefined(symbol.declarations, func(d Declaration) Declaration {
			if getNameOfDeclaration(d) {
				return d
			} else {
				return nil
			}
		})
		// Try using a declaration with a name, first
		name := declaration && getNameOfDeclaration(declaration)
		if declaration && name {
			if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
				return symbolName(symbol)
			}
			if isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlagsLate) {
				nameType := tc.getSymbolLinks(symbol).nameType
				if nameType && nameType.flags&TypeFlagsStringOrNumberLiteral {
					// Computed property name isn't late bound, but has a well-known name type - use name type to generate a symbol name
					result := tc.getNameOfSymbolFromNameType(symbol, context)
					if result != nil {
						return result
					}
				}
			}
			return declarationNameToString(name)
		}
		if !declaration {
			declaration = symbol.declarations[0]
			// Declaration may be nameless, but we'll try anyway
		}
		if declaration.parent && declaration.parent.kind == SyntaxKindVariableDeclaration {
			return declarationNameToString((declaration.parent /* as VariableDeclaration */).name)
		}
		switch declaration.kind {
		case SyntaxKindClassExpression,
			SyntaxKindFunctionExpression,
			SyntaxKindArrowFunction:
			if context && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
				context.encounteredError = true
			}
			if declaration.kind == SyntaxKindClassExpression {
				return "(Anonymous class)"
			} else {
				return "(Anonymous function)"
			}
		}
	}
	name := tc.getNameOfSymbolFromNameType(symbol, context)
	if name != nil {
		return name
	} else {
		return symbolName(symbol)
	}
}

func (tc *TypeChecker) isDeclarationVisible(node Node) bool {
	if node {
		links := tc.getNodeLinks(node)
		if links.isVisible == nil {
			links.isVisible = !!determineIfDeclarationIsVisible()
		}
		return links.isVisible
	}

	return false

	determineIfDeclarationIsVisible := func() bool {
		switch node.kind {
		case SyntaxKindJSDocCallbackTag,
			SyntaxKindJSDocTypedefTag,
			SyntaxKindJSDocEnumTag:
			return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent))
		case SyntaxKindBindingElement:
			return tc.isDeclarationVisible(node.parent.parent)
		case SyntaxKindVariableDeclaration:
			if isBindingPattern((node /* as VariableDeclaration */).name) && !((node /* as VariableDeclaration */).name /* as BindingPattern */).elements.length {
				// If the binding pattern is empty, this variable declaration is not visible
				return false
			}
			fallthrough
		case SyntaxKindModuleDeclaration,
			SyntaxKindClassDeclaration,
			SyntaxKindInterfaceDeclaration,
			SyntaxKindTypeAliasDeclaration,
			SyntaxKindFunctionDeclaration,
			SyntaxKindEnumDeclaration,
			SyntaxKindImportEqualsDeclaration:
			if isExternalModuleAugmentation(node) {
				return true
			}
			parent := tc.getDeclarationContainer(node)
			if !(tc.getCombinedModifierFlagsCached(node /* as Declaration */) & ModifierFlagsExport) && !(node.kind != SyntaxKindImportEqualsDeclaration && parent.kind != SyntaxKindSourceFile && parent.flags&NodeFlagsAmbient) {
				return isGlobalSourceFile(parent)
			}
			return tc.isDeclarationVisible(parent)
		case SyntaxKindPropertyDeclaration,
			SyntaxKindPropertySignature,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor,
			SyntaxKindMethodDeclaration,
			SyntaxKindMethodSignature:
			if hasEffectiveModifier(node, ModifierFlagsPrivate|ModifierFlagsProtected) {
				// Private/protected properties/methods are not visible
				return false
			}
			fallthrough
		case SyntaxKindConstructor,
			SyntaxKindConstructSignature,
			SyntaxKindCallSignature,
			SyntaxKindIndexSignature,
			SyntaxKindParameter,
			SyntaxKindModuleBlock,
			SyntaxKindFunctionType,
			SyntaxKindConstructorType,
			SyntaxKindTypeLiteral,
			SyntaxKindTypeReference,
			SyntaxKindArrayType,
			SyntaxKindTupleType,
			SyntaxKindUnionType,
			SyntaxKindIntersectionType,
			SyntaxKindParenthesizedType,
			SyntaxKindNamedTupleMember:
			return tc.isDeclarationVisible(node.parent)
		case SyntaxKindImportClause,
			SyntaxKindNamespaceImport,
			SyntaxKindImportSpecifier:
			return false
		case SyntaxKindTypeParameter,
			SyntaxKindSourceFile,
			SyntaxKindNamespaceExportDeclaration:
			return true
		case SyntaxKindExportAssignment:
			return false
		default:
			return false
		}
	}

}

func (tc *TypeChecker) collectLinkedAliases(node ModuleExportName, setVisibility bool) *[]Node {
	var exportSymbol Symbol
	if node.kind != SyntaxKindStringLiteral && node.parent && node.parent.kind == SyntaxKindExportAssignment {
		exportSymbol = tc.resolveName(node, node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, false)
	} else if node.parent.kind == SyntaxKindExportSpecifier {
		exportSymbol = tc.getTargetOfExportSpecifier(node.parent /* as ExportSpecifier */, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
	}
	var result *[]Node
	var visited *Set[number]
	if exportSymbol {
		visited = NewSet()
		visited.add(getSymbolId(exportSymbol))
		buildVisibleNodeList(exportSymbol.declarations)
	}
	return result

	buildVisibleNodeList := func(declarations *[]Declaration) {
		forEach(declarations, func(declaration Declaration) {
			resultNode := tc.getAnyImportSyntax(declaration) || declaration
			if setVisibility {
				tc.getNodeLinks(declaration).isVisible = true
			} else {
				result = result || []never{}
				pushIfUnique(result, resultNode)
			}

			if isInternalModuleImportEqualsDeclaration(declaration) {
				// Add the referenced top container visible
				internalModuleReference := declaration.moduleReference /* as Identifier | QualifiedName */
				firstIdentifier := getFirstIdentifier(internalModuleReference)
				importSymbol := tc.resolveName(declaration, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace /*nameNotFoundMessage*/, nil /*isUse*/, false)
				if importSymbol && visited {
					if tryAddToSet(visited, getSymbolId(importSymbol)) {
						buildVisibleNodeList(importSymbol.declarations)
					}
				}
			}
		})
	}

}

/**
 * Push an entry on the type resolution stack. If an entry with the given target and the given property name
 * is already on the stack, and no entries in between already have a type, then a circularity has occurred.
 * In this case, the result values of the existing entry and all entries pushed after it are changed to false,
 * and the value false is returned. Otherwise, the new entry is just pushed onto the stack, and true is returned.
 * In order to see if the same query has already been done before, the target object and the propertyName both
 * must match the one passed in.
 *
 * @param target The symbol, type, or signature whose type is being queried
 * @param propertyName The property name that should be used to query the target for its type
 */

func (tc *TypeChecker) pushTypeResolution(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
	resolutionCycleStartIndex := tc.findResolutionCycleStartIndex(target, propertyName)
	if resolutionCycleStartIndex >= 0 {
		// A cycle was found
		TODO_IDENTIFIER := tc.resolutionTargets
		for i := resolutionCycleStartIndex; i < length; i++ {
			tc.resolutionResults[i] = false
		}
		return false
	}
	tc.resolutionTargets.push(target)
	tc.resolutionResults.push(true)
	tc.resolutionPropertyNames.push(propertyName)
	return true
}

func (tc *TypeChecker) findResolutionCycleStartIndex(target TypeSystemEntity, propertyName TypeSystemPropertyName) number {
	for i := tc.resolutionTargets.length - 1; i >= tc.resolutionStart; i-- {
		if tc.resolutionTargetHasProperty(tc.resolutionTargets[i], tc.resolutionPropertyNames[i]) {
			return -1
		}
		if tc.resolutionTargets[i] == target && tc.resolutionPropertyNames[i] == propertyName {
			return i
		}
	}
	return -1
}

func (tc *TypeChecker) resolutionTargetHasProperty(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
	switch propertyName {
	case TypeSystemPropertyNameType:
		return !!tc.getSymbolLinks(target /* as Symbol */).type_
	case TypeSystemPropertyNameDeclaredType:
		return !!tc.getSymbolLinks(target /* as Symbol */).declaredType
	case TypeSystemPropertyNameResolvedBaseConstructorType:
		return !!(target /* as InterfaceType */).resolvedBaseConstructorType
	case TypeSystemPropertyNameResolvedReturnType:
		return !!(target /* as Signature */).resolvedReturnType
	case TypeSystemPropertyNameImmediateBaseConstraint:
		return !!(target /* as Type */).immediateBaseConstraint
	case TypeSystemPropertyNameResolvedTypeArguments:
		return !!(target /* as TypeReference */).resolvedTypeArguments
	case TypeSystemPropertyNameResolvedBaseTypes:
		return !!(target /* as InterfaceType */).baseTypesResolved
	case TypeSystemPropertyNameWriteType:
		return !!tc.getSymbolLinks(target /* as Symbol */).writeType
	case TypeSystemPropertyNameParameterInitializerContainsUndefined:
		return tc.getNodeLinks(target /* as ParameterDeclaration */).parameterInitializerContainsUndefined != nil
	}
	return Debug.assertNever(propertyName)
}

/**
 * Pop an entry from the type resolution stack and return its associated result value. The result value will
 * be true if no circularities were detected, or false if a circularity was found.
 */

func (tc *TypeChecker) popTypeResolution() bool {
	tc.resolutionTargets.pop()
	tc.resolutionPropertyNames.pop()
	return tc.resolutionResults.pop()
}

func (tc *TypeChecker) getDeclarationContainer(node Node) Node {
	return findAncestor(getRootDeclaration(node), func(node Node) bool {
		switch node.kind {
		case SyntaxKindVariableDeclaration,
			SyntaxKindVariableDeclarationList,
			SyntaxKindImportSpecifier,
			SyntaxKindNamedImports,
			SyntaxKindNamespaceImport,
			SyntaxKindImportClause:
			return false
		default:
			return true
		}
	}).parent
}

func (tc *TypeChecker) getTypeOfPrototypeProperty(prototype Symbol) Type {
	// TypeScript 1.0 spec (April 2014): 8.4
	// Every class automatically contains a static property member named 'prototype',
	// the type of which is an instantiation of the class type with type Any supplied as a type argument for each type parameter.
	// It is an error to explicitly declare a static property member with the name 'prototype'.
	classType := tc.getDeclaredTypeOfSymbol(tc.getParentOfSymbol(prototype)) /* as InterfaceType */
	if classType.typeParameters {
		return tc.createTypeReference(classType /* as GenericType */, map_(classType.typeParameters, func(_ TypeParameter) IntrinsicType {
			return tc.anyType
		}))
	} else {
		return classType
	}
}

// Return the type of the given property in the given type, or undefined if no such property exists
func (tc *TypeChecker) getTypeOfPropertyOfType(type_ Type, name __String) Type {
	prop := tc.getPropertyOfType(type_, name)
	if prop {
		return tc.getTypeOfSymbol(prop)
	} else {
		return nil
	}
}

/**
 * Return the type of the matching property or index signature in the given type, or undefined
 * if no matching property or index signature exists. Add optionality to index signature types.
 */

func (tc *TypeChecker) getTypeOfPropertyOrIndexSignatureOfType(type_ Type, name __String) Type {
	var propType TODO
	return tc.getTypeOfPropertyOfType(type_, name) || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: propType = getApplicableIndexInfoForName(type, name)?.type */ TODO) && tc.addOptionality(propType /*isProperty*/, true /*isOptional*/, true)
}

func (tc *TypeChecker) isTypeAny(type_ Type) *bool {
	return type_ && (type_.flags&TypeFlagsAny) != 0
}

func (tc *TypeChecker) isErrorType(type_ Type) bool {
	// The only 'any' types that have alias symbols are those manufactured by getTypeFromTypeAliasReference for
	// a reference to an unresolved symbol. We want those to behave like the errorType.
	return type_ == tc.errorType || !!(type_.flags&TypeFlagsAny && type_.aliasSymbol)
}

// Return the type of a binding element parent. We check SymbolLinks first to see if a type has been
// assigned by contextual typing.
func (tc *TypeChecker) getTypeForBindingElementParent(node BindingElementGrandparent, checkMode CheckMode) Type {
	if checkMode != CheckModeNormal {
		return tc.getTypeForVariableLikeDeclaration(node /*includeOptionality*/, false, checkMode)
	}
	symbol := tc.getSymbolOfDeclaration(node)
	return symbol && tc.getSymbolLinks(symbol).type_ || tc.getTypeForVariableLikeDeclaration(node /*includeOptionality*/, false, checkMode)
}

func (tc *TypeChecker) getRestType(source Type, properties []PropertyName, symbol Symbol) Type {
	source = tc.filterType(source, func(t Type) bool {
		return !(t.flags & TypeFlagsNullable)
	})
	if source.flags & TypeFlagsNever {
		return tc.emptyObjectType
	}
	if source.flags & TypeFlagsUnion {
		return tc.mapType(source, func(t Type) Type {
			return tc.getRestType(t, properties, symbol)
		})
	}

	omitKeyType := tc.getUnionType(map_(properties, tc.getLiteralTypeFromPropertyName))

	var spreadableProperties []Symbol = []never{}
	var unspreadableToRestKeys []Type = []never{}

	for _, prop := range tc.getPropertiesOfType(source) {
		literalTypeFromProperty := tc.getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
		if !tc.isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected)) && tc.isSpreadableProperty(prop) {
			spreadableProperties.push(prop)
		} else {
			unspreadableToRestKeys.push(literalTypeFromProperty)
		}
	}

	if tc.isGenericObjectType(source) || tc.isGenericIndexType(omitKeyType) {
		if unspreadableToRestKeys.length {
			// If the type we're spreading from has properties that cannot
			// be spread into the rest type (e.g. getters, methods), ensure
			// they are explicitly omitted, as they would in the non-generic case.
			omitKeyType = tc.getUnionType([]Type{omitKeyType /* TODO(TS-TO-GO) Node SpreadElement: ...unspreadableToRestKeys */})
		}

		if omitKeyType.flags & TypeFlagsNever {
			return source
		}

		omitTypeAlias := tc.getGlobalOmitSymbol()
		if !omitTypeAlias {
			return tc.errorType
		}
		return tc.getTypeAliasInstantiation(omitTypeAlias, []Type{source, omitKeyType})
	}
	members := createSymbolTable()
	for _, prop := range spreadableProperties {
		members.set(prop.escapedName, tc.getSpreadSymbol(prop /*readonly*/, false))
	}
	result := tc.createAnonymousType(symbol, members, emptyArray, emptyArray, tc.getIndexInfosOfType(source))
	result.objectFlags |= ObjectFlagsObjectRestType
	return result
}

func (tc *TypeChecker) isGenericTypeWithUndefinedConstraint(type_ Type) bool {
	return !!(type_.flags & TypeFlagsInstantiable) && tc.maybeTypeOfKind(tc.getBaseConstraintOfType(type_) || tc.unknownType, TypeFlagsUndefined)
}

func (tc *TypeChecker) getNonUndefinedType(type_ Type) Type {
	var typeOrConstraint Type
	if tc.someType(type_, tc.isGenericTypeWithUndefinedConstraint) {
		typeOrConstraint = tc.mapType(type_, func(t Type) Type {
			if t.flags & TypeFlagsInstantiable {
				return tc.getBaseConstraintOrType(t)
			} else {
				return t
			}
		})
	} else {
		typeOrConstraint = type_
	}
	return tc.getTypeWithFacts(typeOrConstraint, TypeFactsNEUndefined)
}

// Determine the control flow type associated with a destructuring declaration or assignment. The following
// forms of destructuring are possible:
//
//	let { x } = obj;  // BindingElement
//	let [ x ] = obj;  // BindingElement
//	{ x } = obj;      // ShorthandPropertyAssignment
//	{ x: v } = obj;   // PropertyAssignment
//	[ x ] = obj;      // Expression
//
// We construct a synthetic element access expression corresponding to 'obj.x' such that the control
// flow analyzer doesn't have to handle all the different syntactic forms.
func (tc *TypeChecker) getFlowTypeOfDestructuring(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any, declaredType Type) Type {
	reference := tc.getSyntheticElementAccess(node)
	if reference {
		return tc.getFlowTypeOfReference(reference, declaredType)
	} else {
		return declaredType
	}
}

func (tc *TypeChecker) getSyntheticElementAccess(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *ElementAccessExpression {
	parentAccess := tc.getParentElementAccess(node)
	if parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode {
		propName := tc.getDestructuringPropertyName(node)
		if propName {
			literal := setTextRangeWorker(parseNodeFactory.createStringLiteral(propName), node)
			var lhsExpr /* TODO(TS-TO-GO) inferred type FunctionExpression | PropertyAccessExpression | ElementAccessExpression | Identifier | ParenthesizedExpression | MetaProperty | ThisExpression | SuperExpression */ any
			if isLeftHandSideExpression(parentAccess) {
				lhsExpr = parentAccess
			} else {
				lhsExpr = parseNodeFactory.createParenthesizedExpression(parentAccess)
			}
			result := setTextRangeWorker(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node)
			setParent(literal, result)
			setParent(result, node)
			if lhsExpr != parentAccess {
				setParent(lhsExpr, result)
			}
			result.flowNode = parentAccess.flowNode
			return result
		}
	}
}

func (tc *TypeChecker) getParentElementAccess(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) Expression {
	ancestor := node.parent.parent
	switch ancestor.kind {
	case SyntaxKindBindingElement,
		SyntaxKindPropertyAssignment:
		return tc.getSyntheticElementAccess(ancestor /* as BindingElement | PropertyAssignment */)
	case SyntaxKindArrayLiteralExpression:
		return tc.getSyntheticElementAccess(node.parent /* as Expression */)
	case SyntaxKindVariableDeclaration:
		return (ancestor /* as VariableDeclaration */).initializer
	case SyntaxKindBinaryExpression:
		return (ancestor /* as BinaryExpression */).right
	}
}

func (tc *TypeChecker) getDestructuringPropertyName(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *string {
	parent := node.parent
	if node.kind == SyntaxKindBindingElement && parent.kind == SyntaxKindObjectBindingPattern {
		return tc.getLiteralPropertyNameText((node /* as BindingElement */).propertyName || (node /* as BindingElement */).name /* as Identifier */)
	}
	if node.kind == SyntaxKindPropertyAssignment || node.kind == SyntaxKindShorthandPropertyAssignment {
		return tc.getLiteralPropertyNameText((node /* as PropertyAssignment | ShorthandPropertyAssignment */).name)
	}
	return "" + ((parent /* as BindingPattern | ArrayLiteralExpression */).elements /* as NodeArray<Node> */).indexOf(node)
}

func (tc *TypeChecker) getLiteralPropertyNameText(name PropertyName) *string {
	type_ := tc.getLiteralTypeFromPropertyName(name)
	if type_.flags & (TypeFlagsStringLiteral | TypeFlagsNumberLiteral) {
		return "" + (type_ /* as StringLiteralType | NumberLiteralType */).value
	} else {
		return nil
	}
}

/** Return the inferred type for a binding element */

func (tc *TypeChecker) getTypeForBindingElement(declaration BindingElement) Type {
	var checkMode /* TODO(TS-TO-GO) inferred type CheckMode.Normal | CheckMode.RestBindingElement */ any
	if declaration.dotDotDotToken {
		checkMode = CheckModeRestBindingElement
	} else {
		checkMode = CheckModeNormal
	}
	parentType := tc.getTypeForBindingElementParent(declaration.parent.parent, checkMode)
	return parentType && tc.getBindingElementTypeFromParentType(declaration, parentType /*noTupleBoundsCheck*/, false)
}

func (tc *TypeChecker) getBindingElementTypeFromParentType(declaration BindingElement, parentType Type, noTupleBoundsCheck bool) Type {
	// If an any type was inferred for parent, infer that for the binding element
	if tc.isTypeAny(parentType) {
		return parentType
	}
	pattern := declaration.parent
	// Relax null check on ambient destructuring parameters, since the parameters have no implementation and are just documentation
	if tc.strictNullChecks && declaration.flags&NodeFlagsAmbient && isPartOfParameterDeclaration(declaration) {
		parentType = tc.getNonNullableType(parentType)
	} else if tc.strictNullChecks && pattern.parent.initializer && !(tc.hasTypeFacts(tc.getTypeOfInitializer(pattern.parent.initializer), TypeFactsEQUndefined)) {
		parentType = tc.getTypeWithFacts(parentType, TypeFactsNEUndefined)
	}

	accessFlags := AccessFlagsExpressionPosition | (__COND__(noTupleBoundsCheck || tc.hasDefaultValue(declaration), AccessFlagsAllowMissing, 0))
	var type_ Type
	if pattern.kind == SyntaxKindObjectBindingPattern {
		if declaration.dotDotDotToken {
			parentType = tc.getReducedType(parentType)
			if parentType.flags&TypeFlagsUnknown || !tc.isValidSpreadType(parentType) {
				tc.error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types)
				return tc.errorType
			}
			var literalMembers []PropertyName = []never{}
			for _, element := range pattern.elements {
				if !element.dotDotDotToken {
					literalMembers.push(element.propertyName || element.name /* as Identifier */)
				}
			}
			type_ = tc.getRestType(parentType, literalMembers, declaration.symbol)
		} else {
			// Use explicitly specified property name ({ p: xxx } form), or otherwise the implied name ({ p } form)
			name := declaration.propertyName || declaration.name /* as Identifier */
			indexType := tc.getLiteralTypeFromPropertyName(name)
			declaredType := tc.getIndexedAccessType(parentType, indexType, accessFlags, name)
			type_ = tc.getFlowTypeOfDestructuring(declaration, declaredType)
		}
	} else {
		// This elementType will be used if the specific property corresponding to this index is not
		// present (aka the tuple element property). This call also checks that the parentType is in
		// fact an iterable or array (depending on target language).
		elementType := tc.checkIteratedTypeOrElementType(IterationUseDestructuring|(__COND__(declaration.dotDotDotToken, 0, IterationUsePossiblyOutOfBounds)), parentType, tc.undefinedType, pattern)
		index := pattern.elements.indexOf(declaration)
		if declaration.dotDotDotToken {
			// If the parent is a tuple type, the rest element has a tuple type of the
			// remaining tuple element types. Otherwise, the rest element has an array type with same
			// element type as the parent type.
			baseConstraint := tc.mapType(parentType, func(t Type) Type {
				if t.flags & TypeFlagsInstantiableNonPrimitive {
					return tc.getBaseConstraintOrType(t)
				} else {
					return t
				}
			})
			if tc.everyType(baseConstraint, tc.isTupleType) {
				type_ = tc.mapType(baseConstraint, func(t Type) Type {
					return tc.sliceTupleType(t /* as TupleTypeReference */, index)
				})
			} else {
				type_ = tc.createArrayType(elementType)
			}
		} else if tc.isArrayLikeType(parentType) {
			indexType := tc.getNumberLiteralType(index)
			declaredType := tc.getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || tc.errorType
			type_ = tc.getFlowTypeOfDestructuring(declaration, declaredType)
		} else {
			type_ = elementType
		}
	}
	if !declaration.initializer {
		return type_
	}
	if getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)) {
		// In strict null checking mode, if a default value of a non-undefined type is specified, remove
		// undefined from the final type.
		if tc.strictNullChecks && !(tc.hasTypeFacts(tc.checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined)) {
			return tc.getNonUndefinedType(type_)
		} else {
			return type_
		}
	}
	return tc.widenTypeInferredFromInitializer(declaration, tc.getUnionType([]Type{tc.getNonUndefinedType(type_), tc.checkDeclarationInitializer(declaration, CheckModeNormal)}, UnionReductionSubtype))
}

func (tc *TypeChecker) getTypeForDeclarationFromJSDocComment(declaration Node) Type {
	jsdocType := getJSDocType(declaration)
	if jsdocType {
		return tc.getTypeFromTypeNode(jsdocType)
	}
	return nil
}

func (tc *TypeChecker) isNullOrUndefined(node Expression) bool {
	expr := skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
	return expr.kind == SyntaxKindNullKeyword || expr.kind == SyntaxKindIdentifier && tc.getResolvedSymbol(expr /* as Identifier */) == tc.undefinedSymbol
}

func (tc *TypeChecker) isEmptyArrayLiteral(node Expression) bool {
	expr := skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
	return expr.kind == SyntaxKindArrayLiteralExpression && (expr /* as ArrayLiteralExpression */).elements.length == 0
}

func (tc *TypeChecker) addOptionality(type_ Type, isProperty bool /*  = false */, isOptional bool /*  = true */) Type {
	if tc.strictNullChecks && isOptional {
		return tc.getOptionalType(type_, isProperty)
	} else {
		return type_
	}
}

// Return the inferred type for a variable, parameter, or property declaration
func (tc *TypeChecker) getTypeForVariableLikeDeclaration(declaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, includeOptionality bool, checkMode CheckMode) Type {
	// A variable declared in a for..in statement is of type string, or of type keyof T when the
	// right hand expression is of a type parameter type.
	if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForInStatement {
		indexType := tc.getIndexType(tc.getNonNullableTypeIfNeeded(tc.checkExpression(declaration.parent.parent.expression /*checkMode*/, checkMode)))
		if indexType.flags & (TypeFlagsTypeParameter | TypeFlagsIndex) {
			return tc.getExtractStringType(indexType)
		} else {
			return tc.stringType
		}
	}

	if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
		// checkRightHandSideOfForOf will return undefined if the for-of expression type was
		// missing properties/signatures required to get its iteratedType (like
		// [Symbol.iterator] or next). This may be because we accessed properties from anyType,
		// or it may have led to an error inside getElementTypeOfIterable.
		forOfStatement := declaration.parent.parent
		return tc.checkRightHandSideOfForOf(forOfStatement) || tc.anyType
	}

	if isBindingPattern(declaration.parent) {
		return tc.getTypeForBindingElement(declaration /* as BindingElement */)
	}

	isProperty := (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration)
	isOptional := includeOptionality && isOptionalDeclaration(declaration)

	// Use type from type annotation if one is present
	declaredType := tc.tryGetTypeFromEffectiveTypeNode(declaration)
	if isCatchClauseVariableDeclarationOrBindingElement(declaration) {
		if declaredType {
			// If the catch clause is explicitly annotated with any or unknown, accept it, otherwise error.
			if tc.isTypeAny(declaredType) || declaredType == tc.unknownType {
				return declaredType
			} else {
				return tc.errorType
			}
		}
		// If the catch clause is not explicitly annotated, treat it as though it were explicitly
		// annotated with unknown or any, depending on useUnknownInCatchVariables.
		if tc.useUnknownInCatchVariables {
			return tc.unknownType
		} else {
			return tc.anyType
		}
	}
	if declaredType {
		return tc.addOptionality(declaredType, isProperty, isOptional)
	}

	if (tc.noImplicitAny || isInJSFile(declaration)) && isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) && !(tc.getCombinedModifierFlagsCached(declaration) & ModifierFlagsExport) && !(declaration.flags & NodeFlagsAmbient) {
		// If --noImplicitAny is on or the declaration is in a Javascript file,
		// use control flow tracked 'any' type for non-ambient, non-exported var or let variables with no
		// initializer or a 'null' or 'undefined' initializer.
		if !(tc.getCombinedNodeFlagsCached(declaration) & NodeFlagsConstant) && (!declaration.initializer || tc.isNullOrUndefined(declaration.initializer)) {
			return tc.autoType
		}
		// Use control flow tracked 'any[]' type for non-ambient, non-exported variables with an empty array
		// literal initializer.
		if declaration.initializer && tc.isEmptyArrayLiteral(declaration.initializer) {
			return tc.autoArrayType
		}
	}

	if isParameter(declaration) {
		if !declaration.symbol {
			// parameters of function types defined in JSDoc in TS files don't have symbols
			return
		}
		func_ := declaration.parent /* as FunctionLikeDeclaration */
		// For a parameter of a set accessor, use the type of the get accessor if one is present
		if func_.kind == SyntaxKindSetAccessor && tc.hasBindableName(func_) {
			getter := getDeclarationOfKind(tc.getSymbolOfDeclaration(declaration.parent), SyntaxKindGetAccessor)
			if getter {
				getterSignature := tc.getSignatureFromDeclaration(getter)
				thisParameter := tc.getAccessorThisParameter(func_ /* as AccessorDeclaration */)
				if thisParameter && declaration == thisParameter {
					// Use the type from the *getter*
					Debug.assert(!thisParameter.type_)
					return tc.getTypeOfSymbol(getterSignature.thisParameter)
				}
				return tc.getReturnTypeOfSignature(getterSignature)
			}
		}
		parameterTypeOfTypeTag := tc.getParameterTypeOfTypeTag(func_, declaration)
		if parameterTypeOfTypeTag {
			return parameterTypeOfTypeTag
		}
		// Use contextual parameter type if one is available
		var type_ Type
		if declaration.symbol.escapedName == InternalSymbolNameThis {
			type_ = tc.getContextualThisParameterType(func_)
		} else {
			type_ = tc.getContextuallyTypedParameterType(declaration)
		}
		if type_ {
			return tc.addOptionality(type_ /*isProperty*/, false, isOptional)
		}
	}

	// Use the type of the initializer expression if one is present and the declaration is
	// not a parameter of a contextually typed function
	if hasOnlyExpressionInitializer(declaration) && !!declaration.initializer {
		if isInJSFile(declaration) && !isParameter(declaration) {
			containerObjectType := tc.getJSContainerObjectType(declaration, tc.getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration))
			if containerObjectType {
				return containerObjectType
			}
		}
		type_ := tc.widenTypeInferredFromInitializer(declaration, tc.checkDeclarationInitializer(declaration, checkMode))
		return tc.addOptionality(type_, isProperty, isOptional)
	}

	if isPropertyDeclaration(declaration) && (tc.noImplicitAny || isInJSFile(declaration)) {
		// We have a property declaration with no type annotation or initializer, in noImplicitAny mode or a .js file.
		// Use control flow analysis of this.xxx assignments in the constructor or static block to determine the type of the property.
		if !hasStaticModifier(declaration) {
			constructor := findConstructorDeclaration(declaration.parent)
			var type_ Type
			switch {
			case constructor:
				type_ = tc.getFlowTypeInConstructor(declaration.symbol, constructor)
			case getEffectiveModifierFlags(declaration) & ModifierFlagsAmbient:
				type_ = tc.getTypeOfPropertyInBaseClass(declaration.symbol)
			default:
				type_ = nil
			}
			return type_ && tc.addOptionality(type_ /*isProperty*/, true, isOptional)
		} else {
			staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
			var type_ Type
			switch {
			case staticBlocks.length:
				type_ = tc.getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks)
			case getEffectiveModifierFlags(declaration) & ModifierFlagsAmbient:
				type_ = tc.getTypeOfPropertyInBaseClass(declaration.symbol)
			default:
				type_ = nil
			}
			return type_ && tc.addOptionality(type_ /*isProperty*/, true, isOptional)
		}
	}

	if isJsxAttribute(declaration) {
		// if JSX attribute doesn't have initializer, by default the attribute will have boolean value of true.
		// I.e <Elem attr /> is sugar for <Elem attr={true} />
		return tc.trueType
	}

	// If the declaration specifies a binding pattern and is not a parameter of a contextually
	// typed function, use the type implied by the binding pattern
	if isBindingPattern(declaration.name) {
		return tc.getTypeFromBindingPattern(declaration.name /*includePatternInType*/, false /*reportErrors*/, true)
	}

	// No type specified and nothing can be inferred
	return nil
}

func (tc *TypeChecker) isConstructorDeclaredProperty(symbol Symbol) bool {
	// A property is considered a constructor declared property when all declaration sites are this.xxx assignments,
	// when no declaration sites have JSDoc type annotations, and when at least one declaration site is in the body of
	// a class constructor.
	if symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration) {
		links := tc.getSymbolLinks(symbol)
		if links.isConstructorDeclaredProperty == nil {
			links.isConstructorDeclaredProperty = false
			links.isConstructorDeclaredProperty = !!tc.getDeclaringConstructor(symbol) && every(symbol.declarations, func(declaration Declaration) bool {
				return isBinaryExpression(declaration) && tc.isPossiblyAliasedThisProperty(declaration) && (declaration.left.kind != SyntaxKindElementAccessExpression || isStringOrNumericLiteralLike((declaration.left /* as ElementAccessExpression */).argumentExpression)) && !tc.getAnnotatedTypeForAssignmentDeclaration(nil, declaration, symbol, declaration)
			})
		}
		return links.isConstructorDeclaredProperty
	}
	return false
}

func (tc *TypeChecker) isAutoTypedProperty(symbol Symbol) *bool {
	// A property is auto-typed when its declaration has no type annotation or initializer and we're in
	// noImplicitAny mode or a .js file.
	declaration := symbol.valueDeclaration
	return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) && !declaration.initializer && (tc.noImplicitAny || isInJSFile(declaration))
}

func (tc *TypeChecker) getDeclaringConstructor(symbol Symbol) *ConstructorDeclaration {
	if !symbol.declarations {
		return
	}
	for _, declaration := range symbol.declarations {
		container := getThisContainer(declaration /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		if container && (container.kind == SyntaxKindConstructor || tc.isJSConstructor(container)) {
			return container /* as ConstructorDeclaration */
		}
	}
}

/** Create a synthetic property access flow node after the last statement of the file */

func (tc *TypeChecker) getFlowTypeFromCommonJSExport(symbol Symbol) Type {
	file := getSourceFileOfNode(symbol.declarations[0])
	accessName := unescapeLeadingUnderscores(symbol.escapedName)
	areAllModuleExports := symbol.declarations.every(func(d Declaration) bool {
		return isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression)
	})
	var reference PropertyAccessExpression
	if areAllModuleExports {
		reference = factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName)
	} else {
		reference = factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName)
	}
	if areAllModuleExports {
		setParent((reference.expression /* as PropertyAccessExpression */).expression, reference.expression)
	}
	setParent(reference.expression, reference)
	setParent(reference, file)
	reference.flowNode = file.endFlowNode
	return tc.getFlowTypeOfReference(reference, tc.autoType, tc.undefinedType)
}

func (tc *TypeChecker) getFlowTypeInStaticBlocks(symbol Symbol, staticBlocks []ClassStaticBlockDeclaration) Type {
	var accessName /* TODO(TS-TO-GO) inferred type string | PrivateIdentifier */ any
	if startsWith(symbol.escapedName /* as string */, "__#") {
		accessName = factory.createPrivateIdentifier((symbol.escapedName /* as string */).split("@")[1])
	} else {
		accessName = unescapeLeadingUnderscores(symbol.escapedName)
	}
	for _, staticBlock := range staticBlocks {
		reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
		setParent(reference.expression, reference)
		setParent(reference, staticBlock)
		reference.flowNode = staticBlock.returnFlowNode
		flowType := tc.getFlowTypeOfProperty(reference, symbol)
		if tc.noImplicitAny && (flowType == tc.autoType || flowType == tc.autoArrayType) {
			tc.error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, tc.symbolToString(symbol), tc.typeToString(flowType))
		}
		// We don't infer a type if assignments are only null or undefined.
		if tc.everyType(flowType, tc.isNullableType) {
			continue
		}
		return tc.convertAutoToAny(flowType)
	}
}

func (tc *TypeChecker) getFlowTypeInConstructor(symbol Symbol, constructor ConstructorDeclaration) Type {
	var accessName /* TODO(TS-TO-GO) inferred type string | PrivateIdentifier */ any
	if startsWith(symbol.escapedName /* as string */, "__#") {
		accessName = factory.createPrivateIdentifier((symbol.escapedName /* as string */).split("@")[1])
	} else {
		accessName = unescapeLeadingUnderscores(symbol.escapedName)
	}
	reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
	setParent(reference.expression, reference)
	setParent(reference, constructor)
	reference.flowNode = constructor.returnFlowNode
	flowType := tc.getFlowTypeOfProperty(reference, symbol)
	if tc.noImplicitAny && (flowType == tc.autoType || flowType == tc.autoArrayType) {
		tc.error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, tc.symbolToString(symbol), tc.typeToString(flowType))
	}
	// We don't infer a type if assignments are only null or undefined.
	if tc.everyType(flowType, tc.isNullableType) {
		return nil
	} else {
		return tc.convertAutoToAny(flowType)
	}
}

func (tc *TypeChecker) getFlowTypeOfProperty(reference Node, prop Symbol) Type {
	initialType := prop. /* ? */ valueDeclaration && (!tc.isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration)&ModifierFlagsAmbient) && tc.getTypeOfPropertyInBaseClass(prop) || tc.undefinedType
	return tc.getFlowTypeOfReference(reference, tc.autoType, initialType)
}

func (tc *TypeChecker) getWidenedTypeForAssignmentDeclaration(symbol Symbol, resolvedSymbol Symbol) Type {
	// function/class/{} initializers are themselves containers, so they won't merge in the same way as other initializers
	container := getAssignedExpandoInitializer(symbol.valueDeclaration)
	if container {
		var tag *JSDocTypeTag
		if isInJSFile(container) {
			tag = getJSDocTypeTag(container)
		} else {
			tag = nil
		}
		if tag && tag.typeExpression {
			return tc.getTypeFromTypeNode(tag.typeExpression)
		}
		containerObjectType := symbol.valueDeclaration && tc.getJSContainerObjectType(symbol.valueDeclaration, symbol, container)
		return containerObjectType || tc.getWidenedLiteralType(tc.checkExpressionCached(container))
	}
	var type_ TODO
	definedInConstructor := false
	definedInMethod := false
	// We use control flow analysis to determine the type of the property if the property qualifies as a constructor
	// declared property and the resulting control flow type isn't just undefined or null.
	if tc.isConstructorDeclaredProperty(symbol) {
		type_ = tc.getFlowTypeInConstructor(symbol, tc.getDeclaringConstructor(symbol))
	}
	if !type_ {
		var types *[]Type
		if symbol.declarations {
			var jsdocType Type
			for _, declaration := range symbol.declarations {
				var expression * /* TODO(TS-TO-GO) inferred type BinaryExpression | CallExpression | AccessExpression */ any
				switch {
				case (isBinaryExpression(declaration) || isCallExpression(declaration)):
					expression = declaration
				case isAccessExpression(declaration):
					if isBinaryExpression(declaration.parent) {
						expression = declaration.parent
					} else {
						expression = declaration
					}
				default:
					expression = nil
				}
				if !expression {
					continue
					// Non-assignment declaration merged in (eg, an Identifier to mark the thing as a namespace) - skip over it and pull type info from elsewhere
				}

				var kind AssignmentDeclarationKind
				if isAccessExpression(expression) {
					kind = getAssignmentDeclarationPropertyAccessKind(expression)
				} else {
					kind = getAssignmentDeclarationKind(expression)
				}
				if kind == AssignmentDeclarationKindThisProperty || isBinaryExpression(expression) && tc.isPossiblyAliasedThisProperty(expression, kind) {
					if tc.isDeclarationInConstructor(expression) {
						definedInConstructor = true
					} else {
						definedInMethod = true
					}
				}
				if !isCallExpression(expression) {
					jsdocType = tc.getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration)
				}
				if !jsdocType {
					(types || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: types = [] */ TODO)).push(__COND__((isBinaryExpression(expression) || isCallExpression(expression)), tc.getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind), tc.neverType))
				}
			}
			type_ = jsdocType
		}
		if !type_ {
			if !length(types) {
				return tc.errorType
				// No types from any declarations :(
			}
			var constructorTypes *[]Type
			if definedInConstructor && symbol.declarations {
				constructorTypes = tc.getConstructorDefinedThisAssignmentTypes(types, symbol.declarations)
			} else {
				constructorTypes = nil
			}
			// use only the constructor types unless they were only assigned null | undefined (including widening variants)
			if definedInMethod {
				propType := tc.getTypeOfPropertyInBaseClass(symbol)
				if propType {
					(constructorTypes || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: constructorTypes = [] */ TODO)).push(propType)
					definedInConstructor = true
				}
			}
			var sourceTypes *[]Type
			if some(constructorTypes, func(t Type) bool {
				return !!(t.flags & ~TypeFlagsNullable)
			}) {
				sourceTypes = constructorTypes
			} else {
				sourceTypes = types
			}
			// TODO: GH#18217
			type_ = tc.getUnionType(sourceTypes)
		}
	}
	widened := tc.getWidenedType(tc.addOptionality(type_ /*isProperty*/, false, definedInMethod && !definedInConstructor))
	if symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && tc.filterType(widened, func(t Type) bool {
		return !!(t.flags & ~TypeFlagsNullable)
	}) == tc.neverType {
		tc.reportImplicitAny(symbol.valueDeclaration, tc.anyType)
		return tc.anyType
	}
	return widened
}

func (tc *TypeChecker) getJSContainerObjectType(decl Node, symbol Symbol, init Expression) Type {
	if !isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length {
		return nil
	}
	exports := createSymbolTable()
	for isBinaryExpression(decl) || isPropertyAccessExpression(decl) {
		s := tc.getSymbolOfNode(decl)
		if s. /* ? */ exports. /* ? */ size {
			tc.mergeSymbolTable(exports, s.exports)
		}
		if isBinaryExpression(decl) {
			decl = decl.parent
		} else {
			decl = decl.parent.parent
		}
	}
	s := tc.getSymbolOfNode(decl)
	if s. /* ? */ exports. /* ? */ size {
		tc.mergeSymbolTable(exports, s.exports)
	}
	type_ := tc.createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray)
	type_.objectFlags |= ObjectFlagsJSLiteral
	return type_
}

func (tc *TypeChecker) getAnnotatedTypeForAssignmentDeclaration(declaredType Type, expression Expression, symbol Symbol, declaration Declaration) Type {
	typeNode := getEffectiveTypeAnnotationNode(expression.parent)
	if typeNode {
		type_ := tc.getWidenedType(tc.getTypeFromTypeNode(typeNode))
		if !declaredType {
			return type_
		} else if !tc.isErrorType(declaredType) && !tc.isErrorType(type_) && !tc.isTypeIdenticalTo(declaredType, type_) {
			tc.errorNextVariableOrPropertyDeclarationMustHaveSameType(nil, declaredType, declaration, type_)
		}
	}
	if symbol.parent. /* ? */ valueDeclaration {
		possiblyAnnotatedSymbol := tc.getFunctionExpressionParentSymbolOrSymbol(symbol.parent)
		if possiblyAnnotatedSymbol.valueDeclaration {
			typeNode := getEffectiveTypeAnnotationNode(possiblyAnnotatedSymbol.valueDeclaration)
			if typeNode {
				annotationSymbol := tc.getPropertyOfType(tc.getTypeFromTypeNode(typeNode), symbol.escapedName)
				if annotationSymbol {
					return tc.getNonMissingTypeOfSymbol(annotationSymbol)
				}
			}
		}
	}

	return declaredType
}

/** If we don't have an explicit JSDoc type, get the type from the initializer. */

func (tc *TypeChecker) getInitializerTypeFromAssignmentDeclaration(symbol Symbol, resolvedSymbol Symbol, expression /* TODO(TS-TO-GO) TypeNode UnionType: BinaryExpression | CallExpression */ any, kind AssignmentDeclarationKind) Type {
	if isCallExpression(expression) {
		if resolvedSymbol {
			return tc.getTypeOfSymbol(resolvedSymbol)
			// This shouldn't happen except under some hopefully forbidden merges of export assignments and object define assignments
		}
		objectLitType := tc.checkExpressionCached((expression /* as BindableObjectDefinePropertyCall */).arguments[2])
		valueType := tc.getTypeOfPropertyOfType(objectLitType, "value" /* as __String */)
		if valueType {
			return valueType
		}
		getFunc := tc.getTypeOfPropertyOfType(objectLitType, "get" /* as __String */)
		if getFunc {
			getSig := tc.getSingleCallSignature(getFunc)
			if getSig {
				return tc.getReturnTypeOfSignature(getSig)
			}
		}
		setFunc := tc.getTypeOfPropertyOfType(objectLitType, "set" /* as __String */)
		if setFunc {
			setSig := tc.getSingleCallSignature(setFunc)
			if setSig {
				return tc.getTypeOfFirstParameterOfSignature(setSig)
			}
		}
		return tc.anyType
	}
	if tc.containsSameNamedThisProperty(expression.left, expression.right) {
		return tc.anyType
	}
	isDirectExport := kind == AssignmentDeclarationKindExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression)))
	var type_ Type
	switch {
	case resolvedSymbol:
		type_ = tc.getTypeOfSymbol(resolvedSymbol)
	case isDirectExport:
		type_ = tc.getRegularTypeOfLiteralType(tc.checkExpressionCached(expression.right))
	default:
		type_ = tc.getWidenedLiteralType(tc.checkExpressionCached(expression.right))
	}
	if type_.flags&TypeFlagsObject && kind == AssignmentDeclarationKindModuleExports && symbol.escapedName == InternalSymbolNameExportEquals {
		exportedType := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		members := createSymbolTable()
		copyEntries(exportedType.members, members)
		initialSize := members.size
		if resolvedSymbol && !resolvedSymbol.exports {
			resolvedSymbol.exports = createSymbolTable()
		}
		(resolvedSymbol || symbol).exports.forEach(func(s Symbol, name __String) {
			exportedMember := members.get(name)
			if exportedMember && exportedMember != s && !(s.flags & SymbolFlagsAlias) {
				if s.flags&SymbolFlagsValue && exportedMember.flags&SymbolFlagsValue {
					// If the member has an additional value-like declaration, union the types from the two declarations,
					// but issue an error if they occurred in two different files. The purpose is to support a JS file with
					// a pattern like:
					//
					// module.exports = { a: true };
					// module.exports.a = 3;
					//
					// but we may have a JS file with `module.exports = { a: true }` along with a TypeScript module augmentation
					// declaring an `export const a: number`. In that case, we issue a duplicate identifier error, because
					// it's unclear what that's supposed to mean, so it's probably a mistake.
					if s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) != getSourceFileOfNode(exportedMember.valueDeclaration) {
						unescapedName := unescapeLeadingUnderscores(s.escapedName)
						exportedMemberName := tryCast(exportedMember.valueDeclaration, isNamedDeclaration). /* ? */ name || exportedMember.valueDeclaration
						addRelatedInfo(tc.error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName))
						addRelatedInfo(tc.error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName))
					}
					union := tc.createSymbol(s.flags|exportedMember.flags, name)
					union.links.type_ = tc.getUnionType([]Type{tc.getTypeOfSymbol(s), tc.getTypeOfSymbol(exportedMember)})
					union.valueDeclaration = exportedMember.valueDeclaration
					union.declarations = concatenate(exportedMember.declarations, s.declarations)
					members.set(name, union)
				} else {
					members.set(name, tc.mergeSymbol(s, exportedMember))
				}
			} else {
				members.set(name, s)
			}
		})
		result := tc.createAnonymousType(__COND__(initialSize != members.size, nil, exportedType.symbol), members, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos)
		if initialSize == members.size {
			if type_.aliasSymbol {
				result.aliasSymbol = type_.aliasSymbol
				result.aliasTypeArguments = type_.aliasTypeArguments
			}
			if getObjectFlags(type_) & ObjectFlagsReference {
				result.aliasSymbol = (type_ /* as TypeReference */).symbol
				args := tc.getTypeArguments(type_ /* as TypeReference */)
				if length(args) {
					result.aliasTypeArguments = args
				} else {
					result.aliasTypeArguments = nil
				}
			}
		}
		result.objectFlags |= tc.getPropagatingFlagsOfTypes([]Type{type_}) | getObjectFlags(type_)&(ObjectFlagsJSLiteral|ObjectFlagsArrayLiteral|ObjectFlagsObjectLiteral)
		if result.symbol && result.symbol.flags&SymbolFlagsClass && type_ == tc.getDeclaredTypeOfClassOrInterface(result.symbol) {
			result.objectFlags |= ObjectFlagsIsClassInstanceClone
			// Propagate the knowledge that this type is equivalent to the symbol's class instance type
		}
		return result
	}
	if tc.isEmptyArrayLiteralType(type_) {
		tc.reportImplicitAny(expression, tc.anyArrayType)
		return tc.anyArrayType
	}
	return type_
}

func (tc *TypeChecker) containsSameNamedThisProperty(thisProperty Expression, expression Expression) *bool {
	return isPropertyAccessExpression(thisProperty) && thisProperty.expression.kind == SyntaxKindThisKeyword && forEachChildRecursively(expression, func(n Node) bool {
		return tc.isMatchingReference(thisProperty, n)
	})
}

func (tc *TypeChecker) isDeclarationInConstructor(expression Expression) bool {
	thisContainer := getThisContainer(expression /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
	// Properties defined in a constructor (or base constructor, or javascript constructor function) don't get undefined added.
	// Function expressions that are assigned to the prototype count as methods.
	return thisContainer.kind == SyntaxKindConstructor || thisContainer.kind == SyntaxKindFunctionDeclaration || (thisContainer.kind == SyntaxKindFunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent))
}

func (tc *TypeChecker) getConstructorDefinedThisAssignmentTypes(types []Type, declarations []Declaration) *[]Type {
	Debug.assert(types.length == declarations.length)
	return types.filter(func(_ Type, i number) *bool {
		declaration := declarations[i]
		var expression *BinaryExpression
		switch {
		case isBinaryExpression(declaration):
			expression = declaration
		case isBinaryExpression(declaration.parent):
			expression = declaration.parent
		default:
			expression = nil
		}
		return expression && tc.isDeclarationInConstructor(expression)
	})
}

// Return the type implied by a binding pattern element. This is the type of the initializer of the element if
// one is present. Otherwise, if the element is itself a binding pattern, it is the type implied by the binding
// pattern. Otherwise, it is the type any.
func (tc *TypeChecker) getTypeFromBindingElement(element BindingElement, includePatternInType bool, reportErrors bool) Type {
	if element.initializer {
		// The type implied by a binding pattern is independent of context, so we check the initializer with no
		// contextual type or, if the element itself is a binding pattern, with the type implied by that binding
		// pattern.
		var contextualType Type
		if isBindingPattern(element.name) {
			contextualType = tc.getTypeFromBindingPattern(element.name /*includePatternInType*/, true /*reportErrors*/, false)
		} else {
			contextualType = tc.unknownType
		}
		return tc.addOptionality(tc.widenTypeInferredFromInitializer(element, tc.checkDeclarationInitializer(element, CheckModeNormal, contextualType)))
	}
	if isBindingPattern(element.name) {
		return tc.getTypeFromBindingPattern(element.name, includePatternInType, reportErrors)
	}
	if reportErrors && !tc.declarationBelongsToPrivateAmbientMember(element) {
		tc.reportImplicitAny(element, tc.anyType)
	}
	// When we're including the pattern in the type (an indication we're obtaining a contextual type), we
	// use a non-inferrable any type. Inference will never directly infer this type, but it is possible
	// to infer a type that contains it, e.g. for a binding pattern like [foo] or { foo }. In such cases,
	// widening of the binding pattern type substitutes a regular any for the non-inferrable any.
	if includePatternInType {
		return tc.nonInferrableAnyType
	} else {
		return tc.anyType
	}
}

// Return the type implied by an object binding pattern
func (tc *TypeChecker) getTypeFromObjectBindingPattern(pattern ObjectBindingPattern, includePatternInType bool, reportErrors bool) Type {
	members := createSymbolTable()
	var stringIndexInfo *IndexInfo
	objectFlags := ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
	forEach(pattern.elements, func(e BindingElement) {
		name := e.propertyName || e.name /* as Identifier */
		if e.dotDotDotToken {
			stringIndexInfo = tc.createIndexInfo(tc.stringType, tc.anyType /*isReadonly*/, false)
			return
		}

		exprType := tc.getLiteralTypeFromPropertyName(name)
		if !isTypeUsableAsPropertyName(exprType) {
			// do not include computed properties in the implied type
			objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
			return
		}
		text := getPropertyNameFromType(exprType)
		flags := SymbolFlagsProperty | (__COND__(e.initializer, SymbolFlagsOptional, 0))
		symbol := tc.createSymbol(flags, text)
		symbol.links.type_ = tc.getTypeFromBindingElement(e, includePatternInType, reportErrors)
		symbol.links.bindingElement = e
		members.set(symbol.escapedName, symbol)
	})
	result := tc.createAnonymousType(nil, members, emptyArray, emptyArray, __COND__(stringIndexInfo, []IndexInfo{stringIndexInfo}, emptyArray))
	result.objectFlags |= objectFlags
	if includePatternInType {
		result.pattern = pattern
		result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
	}
	return result
}

// Return the type implied by an array binding pattern
func (tc *TypeChecker) getTypeFromArrayBindingPattern(pattern BindingPattern, includePatternInType bool, reportErrors bool) Type {
	elements := pattern.elements
	lastElement := lastOrUndefined(elements)
	var restElement *BindingElement
	if lastElement && lastElement.kind == SyntaxKindBindingElement && lastElement.dotDotDotToken {
		restElement = lastElement
	} else {
		restElement = nil
	}
	if elements.length == 0 || elements.length == 1 && restElement {
		if tc.languageVersion >= ScriptTargetES2015 {
			return tc.createIterableType(tc.anyType)
		} else {
			return tc.anyArrayType
		}
	}
	elementTypes := map_(elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) Type {
		if isOmittedExpression(e) {
			return tc.anyType
		} else {
			return tc.getTypeFromBindingElement(e, includePatternInType, reportErrors)
		}
	})
	minLength := findLastIndex(elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) bool {
		return !(e == restElement || isOmittedExpression(e) || tc.hasDefaultValue(e))
	}, elements.length-1) + 1
	elementFlags := map_(elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any, i number) /* TODO(TS-TO-GO) inferred type ElementFlags.Required | ElementFlags.Optional | ElementFlags.Rest */ any {
		switch {
		case e == restElement:
			return ElementFlagsRest
		case i >= minLength:
			return ElementFlagsOptional
		default:
			return ElementFlagsRequired
		}
	})
	result := tc.createTupleType(elementTypes, elementFlags) /* as TypeReference */
	if includePatternInType {
		result = tc.cloneTypeReference(result)
		result.pattern = pattern
		result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
	}
	return result
}

// Return the type implied by a binding pattern. This is the type implied purely by the binding pattern itself
// and without regard to its context (i.e. without regard any type annotation or initializer associated with the
// declaration in which the binding pattern is contained). For example, the implied type of [x, y] is [any, any]
// and the implied type of { x, y: z = 1 } is { x: any; y: number; }. The type implied by a binding pattern is
// used as the contextual type of an initializer associated with the binding pattern. Also, for a destructuring
// parameter with no type annotation or initializer, the type implied by the binding pattern becomes the type of
// the parameter.
func (tc *TypeChecker) getTypeFromBindingPattern(pattern BindingPattern, includePatternInType bool /*  = false */, reportErrors bool /*  = false */) Type {
	if includePatternInType {
		tc.contextualBindingPatterns.push(pattern)
	}
	var result Type
	if pattern.kind == SyntaxKindObjectBindingPattern {
		result = tc.getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)
	} else {
		result = tc.getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors)
	}
	if includePatternInType {
		tc.contextualBindingPatterns.pop()
	}
	return result
}

// Return the type associated with a variable, parameter, or property declaration. In the simple case this is the type
// specified in a type annotation or inferred from an initializer. However, in the case of a destructuring declaration it
// is a bit more involved. For example:
//
//	var [x, s = ""] = [1, "one"];
//
// Here, the array literal [1, "one"] is contextually typed by the type [any, string], which is the implied type of the
// binding pattern [x, s = ""]. Because the contextual type is a tuple type, the resulting type of [1, "one"] is the
// tuple type [number, string]. Thus, the type inferred for 'x' is number and the type inferred for 's' is string.
func (tc *TypeChecker) getWidenedTypeForVariableLikeDeclaration(declaration /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, reportErrors bool) Type {
	return tc.widenTypeForVariableLikeDeclaration(tc.getTypeForVariableLikeDeclaration(declaration /*includeOptionality*/, true, CheckModeNormal), declaration, reportErrors)
}

func (tc *TypeChecker) getTypeFromImportAttributes(node ImportAttributes) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		symbol := tc.createSymbol(SymbolFlagsObjectLiteral, InternalSymbolNameImportAttributes)
		members := createSymbolTable()
		forEach(node.elements, func(attr ImportAttribute) {
			member := tc.createSymbol(SymbolFlagsProperty, getNameFromImportAttribute(attr))
			member.parent = symbol
			member.links.type_ = tc.checkImportAttribute(attr)
			member.links.target = member
			members.set(member.escapedName, member)
		})
		type_ := tc.createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		type_.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsNonInferrableType
		links.resolvedType = type_
	}
	return links.resolvedType
}

func (tc *TypeChecker) isGlobalSymbolConstructor(node Node) *bool {
	symbol := tc.getSymbolOfNode(node)
	globalSymbol := tc.getGlobalESSymbolConstructorTypeSymbol(false)
	return globalSymbol && symbol && symbol == globalSymbol
}

func (tc *TypeChecker) widenTypeForVariableLikeDeclaration(type_ Type, declaration any, reportErrors bool) Type {
	if type_ {
		// TODO: If back compat with pre-3.0/4.0 libs isn't required, remove the following SymbolConstructor special case transforming `symbol` into `unique symbol`
		if type_.flags&TypeFlagsESSymbol && tc.isGlobalSymbolConstructor(declaration.parent) {
			type_ = tc.getESSymbolLikeTypeForNode(declaration)
		}
		if reportErrors {
			tc.reportErrorsFromWidening(declaration, type_)
		}

		// always widen a 'unique symbol' type if the type was created for a different declaration.
		if type_.flags&TypeFlagsUniqueESSymbol && (isBindingElement(declaration) || !declaration.type_) && type_.symbol != tc.getSymbolOfDeclaration(declaration) {
			type_ = tc.esSymbolType
		}

		return tc.getWidenedType(type_)
	}

	// Rest parameters default to type any[], other parameters default to type any
	if isParameter(declaration) && declaration.dotDotDotToken {
		type_ = tc.anyArrayType
	} else {
		type_ = tc.anyType
	}

	// Report implicit any errors unless this is a private property within an ambient declaration
	if reportErrors {
		if !tc.declarationBelongsToPrivateAmbientMember(declaration) {
			tc.reportImplicitAny(declaration, type_)
		}
	}
	return type_
}

func (tc *TypeChecker) declarationBelongsToPrivateAmbientMember(declaration VariableLikeDeclaration) bool {
	root := getRootDeclaration(declaration)
	var memberDeclaration Node
	if root.kind == SyntaxKindParameter {
		memberDeclaration = root.parent
	} else {
		memberDeclaration = root
	}
	return tc.isPrivateWithinAmbient(memberDeclaration)
}

func (tc *TypeChecker) tryGetTypeFromEffectiveTypeNode(node Node) Type {
	typeNode := getEffectiveTypeAnnotationNode(node)
	if typeNode {
		return tc.getTypeFromTypeNode(typeNode)
	}
}

func (tc *TypeChecker) isParameterOfContextSensitiveSignature(symbol Symbol) bool {
	decl := symbol.valueDeclaration
	if !decl {
		return false
	}
	if isBindingElement(decl) {
		decl = walkUpBindingElementsAndPatterns(decl)
	}
	if isParameter(decl) {
		return tc.isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent)
	}
	return false
}

func (tc *TypeChecker) getTypeOfVariableOrParameterOrProperty(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.type_ {
		type_ := tc.getTypeOfVariableOrParameterOrPropertyWorker(symbol)
		// For a contextually typed parameter it is possible that a type has already
		// been assigned (in assignTypeToParameterAndFixTypeParameters), and we want
		// to preserve this type. In fact, we need to _prefer_ that type, but it won't
		// be assigned until contextual typing is complete, so we need to defer in
		// cases where contextual typing may take place.
		if !links.type_ && !tc.isParameterOfContextSensitiveSignature(symbol) {
			links.type_ = type_
		}
		return type_
	}
	return links.type_
}

func (tc *TypeChecker) getTypeOfVariableOrParameterOrPropertyWorker(symbol Symbol) Type {
	// Handle prototype property
	if symbol.flags & SymbolFlagsPrototype {
		return tc.getTypeOfPrototypeProperty(symbol)
	}
	// CommonsJS require and module both have type any.
	if symbol == tc.requireSymbol {
		return tc.anyType
	}
	if symbol.flags&SymbolFlagsModuleExports && symbol.valueDeclaration {
		fileSymbol := tc.getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration))
		result := tc.createSymbol(fileSymbol.flags, "exports" /* as __String */)
		if fileSymbol.declarations {
			result.declarations = fileSymbol.declarations.slice()
		} else {
			result.declarations = []never{}
		}
		result.parent = symbol
		result.links.target = fileSymbol
		if fileSymbol.valueDeclaration {
			result.valueDeclaration = fileSymbol.valueDeclaration
		}
		if fileSymbol.members {
			result.members = NewMap(fileSymbol.members)
		}
		if fileSymbol.exports {
			result.exports = NewMap(fileSymbol.exports)
		}
		members := createSymbolTable()
		members.set("exports" /* as __String */, result)
		return tc.createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
	}
	Debug.assertIsDefined(symbol.valueDeclaration)
	declaration := symbol.valueDeclaration
	// Handle export default expressions
	if isSourceFile(declaration) && isJsonSourceFile(declaration) {
		if !declaration.statements.length {
			return tc.emptyObjectType
		}
		return tc.getWidenedType(tc.getWidenedLiteralType(tc.checkExpression(declaration.statements[0].expression)))
	}
	if isAccessor(declaration) {
		// Binding of certain patterns in JS code will occasionally mark symbols as both properties
		// and accessors. Here we dispatch to accessor resolution if needed.
		return tc.getTypeOfAccessors(symbol)
	}

	// Handle variable, parameter or property
	if !tc.pushTypeResolution(symbol, TypeSystemPropertyNameType) {
		// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
		if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
			return tc.getTypeOfFuncClassEnumModule(symbol)
		}
		return tc.reportCircularityError(symbol)
	}
	var type_ Type
	if declaration.kind == SyntaxKindExportAssignment {
		type_ = tc.widenTypeForVariableLikeDeclaration(tc.tryGetTypeFromEffectiveTypeNode(declaration) || tc.checkExpressionCached((declaration /* as ExportAssignment */).expression), declaration)
	} else if isBinaryExpression(declaration) || (isInJSFile(declaration) && (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) {
		type_ = tc.getWidenedTypeForAssignmentDeclaration(symbol)
	} else if isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(declaration) || isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration)) || isMethodSignature(declaration) || isSourceFile(declaration) {
		// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
			return tc.getTypeOfFuncClassEnumModule(symbol)
		}
		if isBinaryExpression(declaration.parent) {
			type_ = tc.getWidenedTypeForAssignmentDeclaration(symbol)
		} else {
			type_ = tc.tryGetTypeFromEffectiveTypeNode(declaration) || tc.anyType
		}
	} else if isPropertyAssignment(declaration) {
		type_ = tc.tryGetTypeFromEffectiveTypeNode(declaration) || tc.checkPropertyAssignment(declaration)
	} else if isJsxAttribute(declaration) {
		type_ = tc.tryGetTypeFromEffectiveTypeNode(declaration) || tc.checkJsxAttribute(declaration)
	} else if isShorthandPropertyAssignment(declaration) {
		type_ = tc.tryGetTypeFromEffectiveTypeNode(declaration) || tc.checkExpressionForMutableLocation(declaration.name, CheckModeNormal)
	} else if isObjectLiteralMethod(declaration) {
		type_ = tc.tryGetTypeFromEffectiveTypeNode(declaration) || tc.checkObjectLiteralMethod(declaration, CheckModeNormal)
	} else if isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(declaration) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(declaration) {
		type_ = tc.getWidenedTypeForVariableLikeDeclaration(declaration /*reportErrors*/, true)
	} else if isEnumDeclaration(declaration) {
		type_ = tc.getTypeOfFuncClassEnumModule(symbol)
	} else if isEnumMember(declaration) {
		type_ = tc.getTypeOfEnumMember(symbol)
	} else {
		return Debug.fail("Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol))
	}

	if !tc.popTypeResolution() {
		// Symbol is property of some kind that is merged with something - should use `getTypeOfFuncClassEnumModule` and not `getTypeOfVariableOrParameterOrProperty`
		if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
			return tc.getTypeOfFuncClassEnumModule(symbol)
		}
		return tc.reportCircularityError(symbol)
	}
	return type_
}

func (tc *TypeChecker) getAnnotatedAccessorTypeNode(accessor /* TODO(TS-TO-GO) TypeNode UnionType: AccessorDeclaration | PropertyDeclaration | undefined */ any) *TypeNode {
	if accessor {
		switch accessor.kind {
		case SyntaxKindGetAccessor:
			getterTypeAnnotation := getEffectiveReturnTypeNode(accessor)
			return getterTypeAnnotation
		case SyntaxKindSetAccessor:
			setterTypeAnnotation := getEffectiveSetAccessorTypeAnnotationNode(accessor)
			return setterTypeAnnotation
		case SyntaxKindPropertyDeclaration:
			Debug.assert(hasAccessorModifier(accessor))
			accessorTypeAnnotation := getEffectiveTypeAnnotationNode(accessor)
			return accessorTypeAnnotation
		}
	}
	return nil
}

func (tc *TypeChecker) getAnnotatedAccessorType(accessor /* TODO(TS-TO-GO) TypeNode UnionType: AccessorDeclaration | PropertyDeclaration | undefined */ any) Type {
	node := tc.getAnnotatedAccessorTypeNode(accessor)
	return node && tc.getTypeFromTypeNode(node)
}

func (tc *TypeChecker) getAnnotatedAccessorThisParameter(accessor AccessorDeclaration) Symbol {
	parameter := tc.getAccessorThisParameter(accessor)
	return parameter && parameter.symbol
}

func (tc *TypeChecker) getThisTypeOfDeclaration(declaration SignatureDeclaration) Type {
	return tc.getThisTypeOfSignature(tc.getSignatureFromDeclaration(declaration))
}

func (tc *TypeChecker) getTypeOfAccessors(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.type_ {
		if !tc.pushTypeResolution(symbol, TypeSystemPropertyNameType) {
			return tc.errorType
		}
		getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
		setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
		accessor := tryCast(getDeclarationOfKind(symbol, SyntaxKindPropertyDeclaration), isAutoAccessorPropertyDeclaration)

		// We try to resolve a getter type annotation, a setter type annotation, or a getter function
		// body return type inference, in that order.
		type_ := getter && isInJSFile(getter) && tc.getTypeForDeclarationFromJSDocComment(getter) || tc.getAnnotatedAccessorType(getter) || tc.getAnnotatedAccessorType(setter) || tc.getAnnotatedAccessorType(accessor) || getter && getter.body && tc.getReturnTypeFromBody(getter) || accessor && accessor.initializer && tc.getWidenedTypeForVariableLikeDeclaration(accessor /*reportErrors*/, true)
		if !type_ {
			if setter && !tc.isPrivateWithinAmbient(setter) {
				tc.errorOrSuggestion(tc.noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, tc.symbolToString(symbol))
			} else if getter && !tc.isPrivateWithinAmbient(getter) {
				tc.errorOrSuggestion(tc.noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, tc.symbolToString(symbol))
			} else if accessor && !tc.isPrivateWithinAmbient(accessor) {
				tc.errorOrSuggestion(tc.noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, tc.symbolToString(symbol), "any")
			}
			type_ = tc.anyType
		}
		if !tc.popTypeResolution() {
			if tc.getAnnotatedAccessorTypeNode(getter) {
				tc.error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, tc.symbolToString(symbol))
			} else if tc.getAnnotatedAccessorTypeNode(setter) {
				tc.error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, tc.symbolToString(symbol))
			} else if tc.getAnnotatedAccessorTypeNode(accessor) {
				tc.error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, tc.symbolToString(symbol))
			} else if getter && tc.noImplicitAny {
				tc.error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, tc.symbolToString(symbol))
			}
			type_ = tc.anyType
		}
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.type ??= type */ TODO
	}
	return links.type_
}

func (tc *TypeChecker) getWriteTypeOfAccessors(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.writeType {
		if !tc.pushTypeResolution(symbol, TypeSystemPropertyNameWriteType) {
			return tc.errorType
		}

		setter := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor) ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration) */ TODO
		writeType := tc.getAnnotatedAccessorType(setter)
		if !tc.popTypeResolution() {
			if tc.getAnnotatedAccessorTypeNode(setter) {
				tc.error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, tc.symbolToString(symbol))
			}
			writeType = tc.anyType
		}
		// Absent an explicit setter type annotation we use the read type of the accessor.
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.writeType ??= writeType || getTypeOfAccessors(symbol) */
		TODO
	}
	return links.writeType
}

func (tc *TypeChecker) getBaseTypeVariableOfClass(symbol Symbol) Type {
	baseConstructorType := tc.getBaseConstructorTypeOfClass(tc.getDeclaredTypeOfClassOrInterface(symbol))
	switch {
	case baseConstructorType.flags & TypeFlagsTypeVariable:
		return baseConstructorType
	case baseConstructorType.flags & TypeFlagsIntersection:
		return find((baseConstructorType /* as IntersectionType */).types, func(t Type) bool {
			return !!(t.flags & TypeFlagsTypeVariable)
		})
	default:
		return nil
	}
}

func (tc *TypeChecker) getTypeOfFuncClassEnumModule(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	originalLinks := links
	if !links.type_ {
		expando := symbol.valueDeclaration && tc.getSymbolOfExpando(symbol.valueDeclaration /*allowDeclaration*/, false)
		if expando {
			merged := tc.mergeJSSymbols(symbol, expando)
			if merged {
				// note:we overwrite links because we just cloned the symbol
				symbol = merged
				links = merged.links
			}
		}
		originalLinks.type_ = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.type = getTypeOfFuncClassEnumModuleWorker(symbol) */ TODO
	}
	return links.type_
}

func (tc *TypeChecker) getTypeOfFuncClassEnumModuleWorker(symbol Symbol) Type {
	declaration := symbol.valueDeclaration
	if symbol.flags&SymbolFlagsModule && isShorthandAmbientModuleSymbol(symbol) {
		return tc.anyType
	} else if declaration && (declaration.kind == SyntaxKindBinaryExpression || isAccessExpression(declaration) && declaration.parent.kind == SyntaxKindBinaryExpression) {
		return tc.getWidenedTypeForAssignmentDeclaration(symbol)
	} else if symbol.flags&SymbolFlagsValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator {
		resolvedModule := tc.resolveExternalModuleSymbol(symbol)
		if resolvedModule != symbol {
			if !tc.pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return tc.errorType
			}
			exportEquals := tc.getMergedSymbol(symbol.exports.get(InternalSymbolNameExportEquals))
			type_ := tc.getWidenedTypeForAssignmentDeclaration(exportEquals, __COND__(exportEquals == resolvedModule, nil, resolvedModule))
			if !tc.popTypeResolution() {
				return tc.reportCircularityError(symbol)
			}
			return type_
		}
	}
	type_ := tc.createObjectType(ObjectFlagsAnonymous, symbol)
	if symbol.flags & SymbolFlagsClass {
		baseTypeVariable := tc.getBaseTypeVariableOfClass(symbol)
		if baseTypeVariable {
			return tc.getIntersectionType([]Type{type_, baseTypeVariable})
		} else {
			return type_
		}
	} else {
		if tc.strictNullChecks && symbol.flags&SymbolFlagsOptional {
			return tc.getOptionalType(type_ /*isProperty*/, true)
		} else {
			return type_
		}
	}
}

func (tc *TypeChecker) getTypeOfEnumMember(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	return links.type_ || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.type = getDeclaredTypeOfEnumMember(symbol) */ TODO)
}

func (tc *TypeChecker) getTypeOfAlias(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.type_ {
		if !tc.pushTypeResolution(symbol, TypeSystemPropertyNameType) {
			return tc.errorType
		}
		targetSymbol := tc.resolveAlias(symbol)
		exportSymbol := symbol.declarations && tc.getTargetOfAliasDeclaration(tc.getDeclarationOfAliasSymbol(symbol) /*dontRecursivelyResolve*/, true)
		declaredType := firstDefined(exportSymbol. /* ? */ declarations, func(d Declaration) Type {
			if isExportAssignment(d) {
				return tc.tryGetTypeFromEffectiveTypeNode(d)
			} else {
				return nil
			}
		})

		// It only makes sense to get the type of a value symbol. If the result of resolving
		// the alias is not a value, then it has no type. To get the type associated with a
		// type symbol, call getDeclaredTypeOfSymbol.
		// This check is important because without it, a call to getTypeOfSymbol could end
		// up recursively calling getTypeOfAlias, causing a stack overflow.
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol) : isDuplicatedCommonJSExport(symbol.declarations) ? autoType : declaredType ? declaredType : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol) : errorType */
		TODO

		if !tc.popTypeResolution() {
			tc.reportCircularityError( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: exportSymbol ?? symbol */ TODO)
			return /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.type ??= errorType */ TODO
		}
	}
	return links.type_
}

func (tc *TypeChecker) getTypeOfInstantiatedSymbol(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	return links.type_ || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper) */ TODO)
}

func (tc *TypeChecker) getWriteTypeOfInstantiatedSymbol(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	return links.writeType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper) */ TODO)
}

func (tc *TypeChecker) reportCircularityError(symbol Symbol) IntrinsicType {
	declaration := symbol.valueDeclaration
	// Check if variable has type annotation that circularly references the variable itself
	if declaration {
		if getEffectiveTypeAnnotationNode(declaration) {
			tc.error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, tc.symbolToString(symbol))
			return tc.errorType
		}
		// Check if variable has initializer that circularly references the variable itself
		if tc.noImplicitAny && (declaration.kind != SyntaxKindParameter || (declaration /* as HasInitializer */).initializer) {
			tc.error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, tc.symbolToString(symbol))
		}
	} else if symbol.flags & SymbolFlagsAlias {
		node := tc.getDeclarationOfAliasSymbol(symbol)
		if node {
			tc.error(node, Diagnostics.Circular_definition_of_import_alias_0, tc.symbolToString(symbol))
		}
	}
	// Circularities could also result from parameters in function expressions that end up
	// having themselves as contextual types following type argument inference. In those cases
	// we have already reported an implicit any error so we don't report anything here.
	return tc.anyType
}

func (tc *TypeChecker) getTypeOfSymbolWithDeferredType(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.type_ {
		Debug.assertIsDefined(links.deferralParent)
		Debug.assertIsDefined(links.deferralConstituents)
		if links.deferralParent.flags & TypeFlagsUnion {
			links.type_ = tc.getUnionType(links.deferralConstituents)
		} else {
			links.type_ = tc.getIntersectionType(links.deferralConstituents)
		}
	}
	return links.type_
}

func (tc *TypeChecker) getWriteTypeOfSymbolWithDeferredType(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.writeType && links.deferralWriteConstituents {
		Debug.assertIsDefined(links.deferralParent)
		Debug.assertIsDefined(links.deferralConstituents)
		if links.deferralParent.flags & TypeFlagsUnion {
			links.writeType = tc.getUnionType(links.deferralWriteConstituents)
		} else {
			links.writeType = tc.getIntersectionType(links.deferralWriteConstituents)
		}
	}
	return links.writeType
}

/**
 * Distinct write types come only from set accessors, but synthetic union and intersection
 * properties deriving from set accessors will either pre-compute or defer the union or
 * intersection of the writeTypes of their constituents.
 */

func (tc *TypeChecker) getWriteTypeOfSymbol(symbol Symbol) Type {
	checkFlags := getCheckFlags(symbol)
	if symbol.flags & SymbolFlagsProperty {
		switch {
		case checkFlags & CheckFlagsSyntheticProperty:
			if checkFlags & CheckFlagsDeferredType {
				return tc.getWriteTypeOfSymbolWithDeferredType(symbol) || tc.getTypeOfSymbolWithDeferredType(symbol)
			} else {
				return (symbol /* as TransientSymbol */).links.writeType || (symbol /* as TransientSymbol */).links.type_
			}
		default:
			return tc.removeMissingType(tc.getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
		}
	}
	if symbol.flags & SymbolFlagsAccessor {
		if checkFlags & CheckFlagsInstantiated {
			return tc.getWriteTypeOfInstantiatedSymbol(symbol)
		} else {
			return tc.getWriteTypeOfAccessors(symbol)
		}
	}
	return tc.getTypeOfSymbol(symbol)
}

func (tc *TypeChecker) getTypeOfSymbol(symbol Symbol) Type {
	checkFlags := getCheckFlags(symbol)
	if checkFlags & CheckFlagsDeferredType {
		return tc.getTypeOfSymbolWithDeferredType(symbol)
	}
	if checkFlags & CheckFlagsInstantiated {
		return tc.getTypeOfInstantiatedSymbol(symbol)
	}
	if checkFlags & CheckFlagsMapped {
		return tc.getTypeOfMappedSymbol(symbol /* as MappedSymbol */)
	}
	if checkFlags & CheckFlagsReverseMapped {
		return tc.getTypeOfReverseMappedSymbol(symbol /* as ReverseMappedSymbol */)
	}
	if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
		return tc.getTypeOfVariableOrParameterOrProperty(symbol)
	}
	if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
		return tc.getTypeOfFuncClassEnumModule(symbol)
	}
	if symbol.flags & SymbolFlagsEnumMember {
		return tc.getTypeOfEnumMember(symbol)
	}
	if symbol.flags & SymbolFlagsAccessor {
		return tc.getTypeOfAccessors(symbol)
	}
	if symbol.flags & SymbolFlagsAlias {
		return tc.getTypeOfAlias(symbol)
	}
	return tc.errorType
}

func (tc *TypeChecker) getNonMissingTypeOfSymbol(symbol Symbol) Type {
	return tc.removeMissingType(tc.getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
}

func (tc *TypeChecker) isReferenceToSomeType(type_ Type, targets []Type) bool {
	if type_ == nil || (getObjectFlags(type_)&ObjectFlagsReference) == 0 {
		return false
	}
	for _, target := range targets {
		if (type_ /* as TypeReference */).target == target {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) isReferenceToType(type_ Type, target Type) bool {
	return type_ != nil && target != nil && (getObjectFlags(type_)&ObjectFlagsReference) != 0 && (type_ /* as TypeReference */).target == target
}

func (tc *TypeChecker) getTargetType(type_ Type) Type {
	if getObjectFlags(type_) & ObjectFlagsReference {
		return (type_ /* as TypeReference */).target
	} else {
		return type_
	}
}

// TODO: GH#18217 If `checkBase` is undefined, we should not call this because this will always return false.
func (tc *TypeChecker) hasBaseType(type_ Type, checkBase Type) bool {
	return check(type_)
	check := func(type_ Type) bool {
		if getObjectFlags(type_) & (ObjectFlagsClassOrInterface | ObjectFlagsReference) {
			target := tc.getTargetType(type_) /* as InterfaceType */
			return target == checkBase || some(tc.getBaseTypes(target), check)
		} else if type_.flags & TypeFlagsIntersection {
			return some((type_ /* as IntersectionType */).types, check)
		}
		return false
	}

}

// Appends the type parameters given by a list of declarations to a set of type parameters and returns the resulting set.
// The function allocates a new array if the input type parameter set is undefined, but otherwise it modifies the set
// in-place and returns the same array.
func (tc *TypeChecker) appendTypeParameters(typeParameters *[]TypeParameter, declarations []TypeParameterDeclaration) *[]TypeParameter {
	for _, declaration := range declarations {
		typeParameters = appendIfUnique(typeParameters, tc.getDeclaredTypeOfTypeParameter(tc.getSymbolOfDeclaration(declaration)))
	}
	return typeParameters
}

// Return the outer type parameters of a node or undefined if the node has no outer type parameters.
func (tc *TypeChecker) getOuterTypeParameters(node Node, includeThisTypes bool) *[]TypeParameter {
	for true {
		node = node.parent
		// TODO: GH#18217 Use SourceFile kind check instead
		if node && isBinaryExpression(node) {
			// prototype assignments get the outer type parameters of their constructor function
			assignmentKind := getAssignmentDeclarationKind(node)
			if assignmentKind == AssignmentDeclarationKindPrototype || assignmentKind == AssignmentDeclarationKindPrototypeProperty {
				symbol := tc.getSymbolOfDeclaration(node.left /* as BindableStaticNameExpression | PropertyAssignment */)
				if symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, func(d Node) bool {
					return node == d
				}) {
					node = symbol.parent.valueDeclaration
				}
			}
		}
		if !node {
			return nil
		}
		kind := node.kind
		switch kind {
		case SyntaxKindClassDeclaration,
			SyntaxKindClassExpression,
			SyntaxKindInterfaceDeclaration,
			SyntaxKindCallSignature,
			SyntaxKindConstructSignature,
			SyntaxKindMethodSignature,
			SyntaxKindFunctionType,
			SyntaxKindConstructorType,
			SyntaxKindJSDocFunctionType,
			SyntaxKindFunctionDeclaration,
			SyntaxKindMethodDeclaration,
			SyntaxKindFunctionExpression,
			SyntaxKindArrowFunction,
			SyntaxKindTypeAliasDeclaration,
			SyntaxKindJSDocTemplateTag,
			SyntaxKindJSDocTypedefTag,
			SyntaxKindJSDocEnumTag,
			SyntaxKindJSDocCallbackTag,
			SyntaxKindMappedType,
			SyntaxKindConditionalType:
			outerTypeParameters := tc.getOuterTypeParameters(node, includeThisTypes)
			if (kind == SyntaxKindFunctionExpression || kind == SyntaxKindArrowFunction || isObjectLiteralMethod(node)) && tc.isContextSensitive(node /* as Expression | MethodDeclaration */) {
				signature := firstOrUndefined(tc.getSignaturesOfType(tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node /* as FunctionLikeDeclaration */)), SignatureKindCall))
				if signature && signature.typeParameters {
					return []TypeParameter{ /* TODO(TS-TO-GO) Node SpreadElement: ...(outerTypeParameters || emptyArray) */ /* TODO(TS-TO-GO) Node SpreadElement: ...signature.typeParameters */ }
				}
			}
			if kind == SyntaxKindMappedType {
				return append(outerTypeParameters, tc.getDeclaredTypeOfTypeParameter(tc.getSymbolOfDeclaration((node /* as MappedTypeNode */).typeParameter)))
			} else if kind == SyntaxKindConditionalType {
				return concatenate(outerTypeParameters, tc.getInferTypeParameters(node /* as ConditionalTypeNode */))
			}
			outerAndOwnTypeParameters := tc.appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node /* as DeclarationWithTypeParameters */))
			thisType := includeThisTypes && (kind == SyntaxKindClassDeclaration || kind == SyntaxKindClassExpression || kind == SyntaxKindInterfaceDeclaration || tc.isJSConstructor(node)) && tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfDeclaration(node /* as ClassLikeDeclaration | InterfaceDeclaration */)).thisType
			if thisType {
				return append(outerAndOwnTypeParameters, thisType)
			} else {
				return outerAndOwnTypeParameters
			}
			fallthrough
		case SyntaxKindJSDocParameterTag:
			paramSymbol := getParameterSymbolFromJSDoc(node /* as JSDocParameterTag */)
			if paramSymbol {
				node = paramSymbol.valueDeclaration
			}
		case SyntaxKindJSDoc:
			outerTypeParameters := tc.getOuterTypeParameters(node, includeThisTypes)
			if (node /* as JSDoc */).tags {
				return tc.appendTypeParameters(outerTypeParameters, flatMap((node /* as JSDoc */).tags, func(t JSDocTag) *NodeArray[TypeParameterDeclaration] {
					if isJSDocTemplateTag(t) {
						return t.typeParameters
					} else {
						return nil
					}
				}))
			} else {
				return outerTypeParameters
			}
		}
	}
}

// The outer type parameters are those defined by enclosing generic classes, methods, or functions.
func (tc *TypeChecker) getOuterTypeParametersOfClassOrInterface(symbol Symbol) *[]TypeParameter {
	var declaration Declaration
	if symbol.flags&SymbolFlagsClass || symbol.flags&SymbolFlagsFunction {
		declaration = symbol.valueDeclaration
	} else {
		declaration = symbol.declarations. /* ? */ find(func(decl Declaration) bool {
			if decl.kind == SyntaxKindInterfaceDeclaration {
				return true
			}
			if decl.kind != SyntaxKindVariableDeclaration {
				return false
			}
			initializer := (decl /* as VariableDeclaration */).initializer
			return !!initializer && (initializer.kind == SyntaxKindFunctionExpression || initializer.kind == SyntaxKindArrowFunction)
		})
	}
	Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations")
	return tc.getOuterTypeParameters(declaration)
}

// The local type parameters are the combined set of type parameters from all declarations of the class,
// interface, or type alias.
func (tc *TypeChecker) getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol Symbol) *[]TypeParameter {
	if !symbol.declarations {
		return
	}
	var result *[]TypeParameter
	for _, node := range symbol.declarations {
		if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression || tc.isJSConstructor(node) || isTypeAlias(node) {
			declaration := node /* as InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag */
			result = tc.appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration))
		}
	}
	return result
}

// The full set of type parameters for a generic class or interface type consists of its outer type parameters plus
// its locally declared type parameters.
func (tc *TypeChecker) getTypeParametersOfClassOrInterface(symbol Symbol) *[]TypeParameter {
	return concatenate(tc.getOuterTypeParametersOfClassOrInterface(symbol), tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol))
}

// A type is a mixin constructor if it has a single construct signature taking no type parameters and a single
// rest parameter of type any[].
func (tc *TypeChecker) isMixinConstructorType(type_ Type) bool {
	signatures := tc.getSignaturesOfType(type_, SignatureKindConstruct)
	if signatures.length == 1 {
		s := signatures[0]
		if !s.typeParameters && s.parameters.length == 1 && signatureHasRestParameter(s) {
			paramType := tc.getTypeOfParameter(s.parameters[0])
			return tc.isTypeAny(paramType) || tc.getElementTypeOfArrayType(paramType) == tc.anyType
		}
	}
	return false
}

func (tc *TypeChecker) isConstructorType(type_ Type) bool {
	if tc.getSignaturesOfType(type_, SignatureKindConstruct).length > 0 {
		return true
	}
	if type_.flags & TypeFlagsTypeVariable {
		constraint := tc.getBaseConstraintOfType(type_)
		return !!constraint && tc.isMixinConstructorType(constraint)
	}
	return false
}

func (tc *TypeChecker) getBaseTypeNodeOfClass(type_ InterfaceType) *ExpressionWithTypeArguments {
	decl := getClassLikeDeclarationOfSymbol(type_.symbol)
	return decl && getEffectiveBaseTypeNode(decl)
}

func (tc *TypeChecker) getConstructorsForTypeArguments(type_ Type, typeArgumentNodes *[]TypeNode, location Node) []Signature {
	typeArgCount := length(typeArgumentNodes)
	isJavascript := isInJSFile(location)
	return filter(tc.getSignaturesOfType(type_, SignatureKindConstruct), func(sig Signature) bool {
		return (isJavascript || typeArgCount >= tc.getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters)
	})
}

func (tc *TypeChecker) getInstantiatedConstructorsForTypeArguments(type_ Type, typeArgumentNodes *[]TypeNode, location Node) []Signature {
	signatures := tc.getConstructorsForTypeArguments(type_, typeArgumentNodes, location)
	typeArguments := map_(typeArgumentNodes, tc.getTypeFromTypeNode)
	return sameMap(signatures, func(sig Signature) Signature {
		if some(sig.typeParameters) {
			return tc.getSignatureInstantiation(sig, typeArguments, isInJSFile(location))
		} else {
			return sig
		}
	})
}

/**
 * The base constructor of a class can resolve to
 * * undefinedType if the class has no extends clause,
 * * errorType if an error occurred during resolution of the extends expression,
 * * nullType if the extends expression is the null value,
 * * anyType if the extends expression has type any, or
 * * an object type with at least one construct signature.
 */

func (tc *TypeChecker) getBaseConstructorTypeOfClass(type_ InterfaceType) Type {
	if !type_.resolvedBaseConstructorType {
		decl := getClassLikeDeclarationOfSymbol(type_.symbol)
		extended := decl && getEffectiveBaseTypeNode(decl)
		baseTypeNode := tc.getBaseTypeNodeOfClass(type_)
		if !baseTypeNode {
			type_.resolvedBaseConstructorType = tc.undefinedType
			return type_.resolvedBaseConstructorType
		}
		if !tc.pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseConstructorType) {
			return tc.errorType
		}
		baseConstructorType := tc.checkExpression(baseTypeNode.expression)
		if extended && baseTypeNode != extended {
			Debug.assert(!extended.typeArguments)
			// Because this is in a JS file, and baseTypeNode is in an @extends tag
			tc.checkExpression(extended.expression)
		}
		if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection) {
			// Resolving the members of a class requires us to resolve the base class of that class.
			// We force resolution here such that we catch circularities now.
			tc.resolveStructuredTypeMembers(baseConstructorType /* as ObjectType */)
		}
		if !tc.popTypeResolution() {
			tc.error(type_.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, tc.symbolToString(type_.symbol))
			return /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: type.resolvedBaseConstructorType ??= errorType */ TODO
		}
		if !(baseConstructorType.flags & TypeFlagsAny) && baseConstructorType != tc.nullWideningType && !tc.isConstructorType(baseConstructorType) {
			err := tc.error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, tc.typeToString(baseConstructorType))
			if baseConstructorType.flags & TypeFlagsTypeParameter {
				constraint := tc.getConstraintFromTypeParameter(baseConstructorType)
				var ctorReturn Type = tc.unknownType
				if constraint {
					ctorSig := tc.getSignaturesOfType(constraint, SignatureKindConstruct)
					if ctorSig[0] {
						ctorReturn = tc.getReturnTypeOfSignature(ctorSig[0])
					}
				}
				if baseConstructorType.symbol.declarations {
					addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, tc.symbolToString(baseConstructorType.symbol), tc.typeToString(ctorReturn)))
				}
			}
			return /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: type.resolvedBaseConstructorType ??= errorType */ TODO
		}
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: type.resolvedBaseConstructorType ??= baseConstructorType */ TODO
	}
	return type_.resolvedBaseConstructorType
}

func (tc *TypeChecker) getImplementsTypes(type_ InterfaceType) []BaseType {
	var resolvedImplementsTypes []BaseType = emptyArray
	if type_.symbol.declarations {
		for _, declaration := range type_.symbol.declarations {
			implementsTypeNodes := getEffectiveImplementsTypeNodes(declaration /* as ClassLikeDeclaration */)
			if !implementsTypeNodes {
				continue
			}
			for _, node := range implementsTypeNodes {
				implementsType := tc.getTypeFromTypeNode(node)
				if !tc.isErrorType(implementsType) {
					if resolvedImplementsTypes == emptyArray {
						resolvedImplementsTypes = []ObjectType{implementsType /* as ObjectType */}
					} else {
						resolvedImplementsTypes.push(implementsType)
					}
				}
			}
		}
	}
	return resolvedImplementsTypes
}

func (tc *TypeChecker) reportCircularBaseType(node Node, type_ Type) {
	tc.error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, tc.typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrayAsGenericType))
}

func (tc *TypeChecker) getBaseTypes(type_ InterfaceType) []BaseType {
	if !type_.baseTypesResolved {
		if tc.pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseTypes) {
			if type_.objectFlags & ObjectFlagsTuple {
				type_.resolvedBaseTypes = []ObjectType{tc.getTupleBaseType(type_ /* as TupleType */)}
			} else if type_.symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
				if type_.symbol.flags & SymbolFlagsClass {
					tc.resolveBaseTypesOfClass(type_)
				}
				if type_.symbol.flags & SymbolFlagsInterface {
					tc.resolveBaseTypesOfInterface(type_)
				}
			} else {
				Debug.fail("type must be class or interface")
			}
			if !tc.popTypeResolution() && type_.symbol.declarations {
				for _, declaration := range type_.symbol.declarations {
					if declaration.kind == SyntaxKindClassDeclaration || declaration.kind == SyntaxKindInterfaceDeclaration {
						tc.reportCircularBaseType(declaration, type_)
					}
				}
			}
		}
		type_.baseTypesResolved = true
	}
	return type_.resolvedBaseTypes
}

func (tc *TypeChecker) getTupleBaseType(type_ TupleType) ObjectType {
	elementTypes := sameMap(type_.typeParameters, func(t TypeParameter, i number) Type {
		if type_.elementFlags[i] & ElementFlagsVariadic {
			return tc.getIndexedAccessType(t, tc.numberType)
		} else {
			return t
		}
	})
	return tc.createArrayType(tc.getUnionType(elementTypes || emptyArray), type_.readonly)
}

func (tc *TypeChecker) resolveBaseTypesOfClass(type_ InterfaceType) []BaseType {
	type_.resolvedBaseTypes = resolvingEmptyArray
	baseConstructorType := tc.getApparentType(tc.getBaseConstructorTypeOfClass(type_))
	if !(baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsAny)) {
		type_.resolvedBaseTypes = emptyArray
		return type_.resolvedBaseTypes
	}
	baseTypeNode := tc.getBaseTypeNodeOfClass(type_)
	var baseType Type
	var originalBaseType Type
	if baseConstructorType.symbol {
		originalBaseType = tc.getDeclaredTypeOfSymbol(baseConstructorType.symbol)
	} else {
		originalBaseType = nil
	}
	if baseConstructorType.symbol && baseConstructorType.symbol.flags&SymbolFlagsClass && tc.areAllOuterTypeParametersApplied(originalBaseType) {
		// When base constructor type is a class with no captured type arguments we know that the constructors all have the same type parameters as the
		// class and all return the instance type of the class. There is no need for further checks and we can apply the
		// type arguments in the same manner as a type reference to get the same error reporting experience.
		baseType = tc.getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol)
	} else if baseConstructorType.flags & TypeFlagsAny {
		baseType = baseConstructorType
	} else {
		// The class derives from a "class-like" constructor function, check that we have at least one construct signature
		// with a matching number of type parameters and use the return type of the first instantiated signature. Elsewhere
		// we check that all instantiated signatures return the same type.
		constructors := tc.getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode)
		if !constructors.length {
			tc.error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments)
			type_.resolvedBaseTypes = emptyArray
			return type_.resolvedBaseTypes
		}
		baseType = tc.getReturnTypeOfSignature(constructors[0])
	}

	if tc.isErrorType(baseType) {
		type_.resolvedBaseTypes = emptyArray
		return type_.resolvedBaseTypes
	}
	reducedBaseType := tc.getReducedType(baseType)
	if !tc.isValidBaseType(reducedBaseType) {
		elaboration := tc.elaborateNeverIntersection(nil, baseType)
		diagnostic := chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, tc.typeToString(reducedBaseType))
		tc.diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic))
		type_.resolvedBaseTypes = emptyArray
		return type_.resolvedBaseTypes
	}
	if type_ == reducedBaseType || tc.hasBaseType(reducedBaseType, type_) {
		tc.error(type_.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, tc.typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrayAsGenericType))
		type_.resolvedBaseTypes = emptyArray
		return type_.resolvedBaseTypes
	}
	if type_.resolvedBaseTypes == resolvingEmptyArray {
		// Circular reference, likely through instantiation of default parameters
		// (otherwise there'd be an error from hasBaseType) - this is fine, but `.members` should be reset
		// as `getIndexedAccessType` via `instantiateType` via `getTypeFromClassOrInterfaceReference` forces a
		// partial instantiation of the members without the base types fully resolved
		type_.members = nil
	}
	type_.resolvedBaseTypes = []BaseType{reducedBaseType}
	return type_.resolvedBaseTypes
}

func (tc *TypeChecker) areAllOuterTypeParametersApplied(type_ Type) bool {
	// An unapplied type parameter has its symbol still the same as the matching argument symbol.
	// Since parameters are applied outer-to-inner, only the last outer parameter needs to be checked.
	outerTypeParameters := (type_ /* as InterfaceType */).outerTypeParameters
	if outerTypeParameters {
		last := outerTypeParameters.length - 1
		typeArguments := tc.getTypeArguments(type_ /* as TypeReference */)
		return outerTypeParameters[last].symbol != typeArguments[last].symbol
	}
	return true
}

// A valid base type is `any`, an object type or intersection of object types.
func (tc *TypeChecker) isValidBaseType(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is BaseType */ any {
	if type_.flags & TypeFlagsTypeParameter {
		constraint := tc.getBaseConstraintOfType(type_)
		if constraint {
			return tc.isValidBaseType(constraint)
		}
	}
	// TODO: Given that we allow type parmeters here now, is this `!isGenericMappedType(type)` check really needed?
	// There's no reason a `T` should be allowed while a `Readonly<T>` should not.
	return !!(type_.flags&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsAny) && !tc.isGenericMappedType(type_) || type_.flags&TypeFlagsIntersection && every((type_ /* as IntersectionType */).types, tc.isValidBaseType))
}

func (tc *TypeChecker) resolveBaseTypesOfInterface(type_ InterfaceType) {
	type_.resolvedBaseTypes = type_.resolvedBaseTypes || emptyArray
	if type_.symbol.declarations {
		for _, declaration := range type_.symbol.declarations {
			if declaration.kind == SyntaxKindInterfaceDeclaration && getInterfaceBaseTypeNodes(declaration /* as InterfaceDeclaration */) {
				for _, node := range getInterfaceBaseTypeNodes(declaration /* as InterfaceDeclaration */) {
					baseType := tc.getReducedType(tc.getTypeFromTypeNode(node))
					if !tc.isErrorType(baseType) {
						if tc.isValidBaseType(baseType) {
							if type_ != baseType && !tc.hasBaseType(baseType, type_) {
								if type_.resolvedBaseTypes == emptyArray {
									type_.resolvedBaseTypes = []ObjectType{baseType /* as ObjectType */}
								} else {
									type_.resolvedBaseTypes.push(baseType)
								}
							} else {
								tc.reportCircularBaseType(declaration, type_)
							}
						} else {
							tc.error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members)
						}
					}
				}
			}
		}
	}
}

/**
 * Returns true if the interface given by the symbol is free of "this" references.
 *
 * Specifically, the result is true if the interface itself contains no references
 * to "this" in its body, if all base types are interfaces,
 * and if none of the base interfaces have a "this" type.
 */

func (tc *TypeChecker) isThislessInterface(symbol Symbol) bool {
	if !symbol.declarations {
		return true
	}
	for _, declaration := range symbol.declarations {
		if declaration.kind == SyntaxKindInterfaceDeclaration {
			if declaration.flags & NodeFlagsContainsThis {
				return false
			}
			baseTypeNodes := getInterfaceBaseTypeNodes(declaration /* as InterfaceDeclaration */)
			if baseTypeNodes {
				for _, node := range baseTypeNodes {
					if isEntityNameExpression(node.expression) {
						baseSymbol := tc.resolveEntityName(node.expression, SymbolFlagsType /*ignoreErrors*/, true)
						if !baseSymbol || !(baseSymbol.flags & SymbolFlagsInterface) || tc.getDeclaredTypeOfClassOrInterface(baseSymbol).thisType {
							return false
						}
					}
				}
			}
		}
	}
	return true
}

func (tc *TypeChecker) getDeclaredTypeOfClassOrInterface(symbol Symbol) InterfaceType {
	links := tc.getSymbolLinks(symbol)
	originalLinks := links
	if !links.declaredType {
		var kind /* TODO(TS-TO-GO) inferred type ObjectFlags.Class | ObjectFlags.Interface */ any
		if symbol.flags & SymbolFlagsClass {
			kind = ObjectFlagsClass
		} else {
			kind = ObjectFlagsInterface
		}
		merged := tc.mergeJSSymbols(symbol, symbol.valueDeclaration && tc.getAssignedClassSymbol(symbol.valueDeclaration))
		if merged {
			// note:we overwrite links because we just cloned the symbol
			symbol = merged
			links = merged.links
		}

		type_ := /* TODO(TS-TO-GO) EqualsToken BinaryExpression: originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType */ TODO
		outerTypeParameters := tc.getOuterTypeParametersOfClassOrInterface(symbol)
		localTypeParameters := tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
		// A class or interface is generic if it has type parameters or a "this" type. We always give classes a "this" type
		// because it is not feasible to analyze all members to determine if the "this" type escapes the class (in particular,
		// property types inferred from initializers and method return types inferred from return statements are very hard
		// to exhaustively analyze). We give interfaces a "this" type if we can't definitely determine that they are free of
		// "this" references.
		if outerTypeParameters || localTypeParameters || kind == ObjectFlagsClass || !tc.isThislessInterface(symbol) {
			type_.objectFlags |= ObjectFlagsReference
			type_.typeParameters = concatenate(outerTypeParameters, localTypeParameters)
			type_.outerTypeParameters = outerTypeParameters
			type_.localTypeParameters = localTypeParameters
			(type_ /* as GenericType */).instantiations = NewMap[string, TypeReference]()
			(type_ /* as GenericType */).instantiations.set(tc.getTypeListId(type_.typeParameters), type_ /* as GenericType */)
			(type_ /* as GenericType */).target = type_ /* as GenericType */
			(type_ /* as GenericType */).resolvedTypeArguments = type_.typeParameters
			type_.thisType = tc.createTypeParameter(symbol)
			type_.thisType.isThisType = true
			type_.thisType.constraint = type_
		}
	}
	return links.declaredType /* as InterfaceType */
}

func (tc *TypeChecker) getDeclaredTypeOfTypeAlias(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.declaredType {
		// Note that we use the links object as the target here because the symbol object is used as the unique
		// identity for resolution of the 'type' property in SymbolLinks.
		if !tc.pushTypeResolution(symbol, TypeSystemPropertyNameDeclaredType) {
			return tc.errorType
		}

		declaration := Debug.checkDefined(symbol.declarations. /* ? */ find(isTypeAlias), "Type alias symbol with no valid declaration found")
		var typeNode *TypeNode
		if isJSDocTypeAlias(declaration) {
			typeNode = declaration.typeExpression
		} else {
			typeNode = declaration.type_
		}
		// If typeNode is missing, we will error in checkJSDocTypedefTag.
		var type_ Type
		if typeNode {
			type_ = tc.getTypeFromTypeNode(typeNode)
		} else {
			type_ = tc.errorType
		}
		if tc.popTypeResolution() {
			typeParameters := tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			if typeParameters {
				// Initialize the instantiation cache for generic type aliases. The declared type corresponds to
				// an instantiation of the type alias with the type parameters supplied as type arguments.
				links.typeParameters = typeParameters
				links.instantiations = NewMap[string, Type]()
				links.instantiations.set(tc.getTypeListId(typeParameters), type_)
			}
			if type_ == tc.intrinsicMarkerType && symbol.escapedName == "BuiltinIteratorReturn" {
				type_ = tc.getBuiltinIteratorReturnType()
			}
		} else {
			type_ = tc.errorType
			if declaration.kind == SyntaxKindJSDocEnumTag {
				tc.error(declaration.typeExpression.type_, Diagnostics.Type_alias_0_circularly_references_itself, tc.symbolToString(symbol))
			} else {
				tc.error(__COND__(isNamedDeclaration(declaration), declaration.name || declaration, declaration), Diagnostics.Type_alias_0_circularly_references_itself, tc.symbolToString(symbol))
			}
		}
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.declaredType ??= type */ TODO
	}
	return links.declaredType
}

func (tc *TypeChecker) getBaseTypeOfEnumLikeType(type_ Type) Type {
	if type_.flags&TypeFlagsEnumLike && type_.symbol.flags&SymbolFlagsEnumMember {
		return tc.getDeclaredTypeOfSymbol(tc.getParentOfSymbol(type_.symbol))
	} else {
		return type_
	}
}

func (tc *TypeChecker) getDeclaredTypeOfEnum(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.declaredType {
		var memberTypeList []Type = []never{}
		if symbol.declarations {
			for _, declaration := range symbol.declarations {
				if declaration.kind == SyntaxKindEnumDeclaration {
					for _, member := range (declaration /* as EnumDeclaration */).members {
						if tc.hasBindableName(member) {
							memberSymbol := tc.getSymbolOfDeclaration(member)
							value := tc.getEnumMemberValue(member).value
							memberType := tc.getFreshTypeOfLiteralType(__COND__(value != nil, tc.getEnumLiteralType(value, getSymbolId(symbol), memberSymbol), tc.createComputedEnumType(memberSymbol)))
							tc.getSymbolLinks(memberSymbol).declaredType = memberType
							memberTypeList.push(tc.getRegularTypeOfLiteralType(memberType))
						}
					}
				}
			}
		}
		var enumType Type
		if memberTypeList.length {
			enumType = tc.getUnionType(memberTypeList, UnionReductionLiteral, symbol /*aliasTypeArguments*/, nil)
		} else {
			enumType = tc.createComputedEnumType(symbol)
		}
		if enumType.flags & TypeFlagsUnion {
			enumType.flags |= TypeFlagsEnumLiteral
			enumType.symbol = symbol
		}
		links.declaredType = enumType
	}
	return links.declaredType
}

func (tc *TypeChecker) createComputedEnumType(symbol Symbol) EnumType {
	regularType := tc.createTypeWithSymbol(TypeFlagsEnum, symbol) /* as EnumType */
	freshType := tc.createTypeWithSymbol(TypeFlagsEnum, symbol)   /* as EnumType */
	regularType.regularType = regularType
	regularType.freshType = freshType
	freshType.regularType = regularType
	freshType.freshType = freshType
	return regularType
}

func (tc *TypeChecker) getDeclaredTypeOfEnumMember(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.declaredType {
		enumType := tc.getDeclaredTypeOfEnum(tc.getParentOfSymbol(symbol))
		if !links.declaredType {
			links.declaredType = enumType
		}
	}
	return links.declaredType
}

func (tc *TypeChecker) getDeclaredTypeOfTypeParameter(symbol Symbol) TypeParameter {
	links := tc.getSymbolLinks(symbol)
	return links.declaredType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.declaredType = createTypeParameter(symbol) */ TODO)
}

func (tc *TypeChecker) getDeclaredTypeOfAlias(symbol Symbol) Type {
	links := tc.getSymbolLinks(symbol)
	return links.declaredType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)) */ TODO)
}

func (tc *TypeChecker) getDeclaredTypeOfSymbol(symbol Symbol) Type {
	return tc.tryGetDeclaredTypeOfSymbol(symbol) || tc.errorType
}

func (tc *TypeChecker) tryGetDeclaredTypeOfSymbol(symbol Symbol) Type {
	if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
		return tc.getDeclaredTypeOfClassOrInterface(symbol)
	}
	if symbol.flags & SymbolFlagsTypeAlias {
		return tc.getDeclaredTypeOfTypeAlias(symbol)
	}
	if symbol.flags & SymbolFlagsTypeParameter {
		return tc.getDeclaredTypeOfTypeParameter(symbol)
	}
	if symbol.flags & SymbolFlagsEnum {
		return tc.getDeclaredTypeOfEnum(symbol)
	}
	if symbol.flags & SymbolFlagsEnumMember {
		return tc.getDeclaredTypeOfEnumMember(symbol)
	}
	if symbol.flags & SymbolFlagsAlias {
		return tc.getDeclaredTypeOfAlias(symbol)
	}
	return nil
}

/**
 * A type is free of this references if it's the any, string, number, boolean, symbol, or void keyword, a string
 * literal type, an array with an element type that is free of this references, or a type reference that is
 * free of this references.
 */

func (tc *TypeChecker) isThislessType(node TypeNode) bool {
	switch node.kind {
	case SyntaxKindAnyKeyword,
		SyntaxKindUnknownKeyword,
		SyntaxKindStringKeyword,
		SyntaxKindNumberKeyword,
		SyntaxKindBigIntKeyword,
		SyntaxKindBooleanKeyword,
		SyntaxKindSymbolKeyword,
		SyntaxKindObjectKeyword,
		SyntaxKindVoidKeyword,
		SyntaxKindUndefinedKeyword,
		SyntaxKindNeverKeyword,
		SyntaxKindLiteralType:
		return true
	case SyntaxKindArrayType:
		return tc.isThislessType((node /* as ArrayTypeNode */).elementType)
	case SyntaxKindTypeReference:
		return !(node /* as TypeReferenceNode */).typeArguments || (node /* as TypeReferenceNode */).typeArguments.every(tc.isThislessType)
	}
	return false
}

/** A type parameter is thisless if its constraint is thisless, or if it has no constraint. */

func (tc *TypeChecker) isThislessTypeParameter(node TypeParameterDeclaration) bool {
	constraint := getEffectiveConstraintOfTypeParameter(node)
	return !constraint || tc.isThislessType(constraint)
}

/**
 * A variable-like declaration is free of this references if it has a type annotation
 * that is thisless, or if it has no type annotation and no initializer (and is thus of type any).
 */

func (tc *TypeChecker) isThislessVariableLikeDeclaration(node VariableLikeDeclaration) bool {
	typeNode := getEffectiveTypeAnnotationNode(node)
	if typeNode {
		return tc.isThislessType(typeNode)
	} else {
		return !hasInitializer(node)
	}
}

/**
 * A function-like declaration is considered free of `this` references if it has a return type
 * annotation that is free of this references and if each parameter is thisless and if
 * each type parameter (if present) is thisless.
 */

func (tc *TypeChecker) isThislessFunctionLikeDeclaration(node FunctionLikeDeclaration) bool {
	returnType := getEffectiveReturnTypeNode(node)
	typeParameters := getEffectiveTypeParameterDeclarations(node)
	return (node.kind == SyntaxKindConstructor || (!!returnType && tc.isThislessType(returnType))) && node.parameters.every(tc.isThislessVariableLikeDeclaration) && typeParameters.every(tc.isThislessTypeParameter)
}

/**
 * Returns true if the class or interface member given by the symbol is free of "this" references. The
 * function may return false for symbols that are actually free of "this" references because it is not
 * feasible to perform a complete analysis in all cases. In particular, property members with types
 * inferred from their initializers and function members with inferred return types are conservatively
 * assumed not to be free of "this" references.
 */

func (tc *TypeChecker) isThisless(symbol Symbol) bool {
	if symbol.declarations && symbol.declarations.length == 1 {
		declaration := symbol.declarations[0]
		if declaration {
			switch declaration.kind {
			case SyntaxKindPropertyDeclaration,
				SyntaxKindPropertySignature:
				return tc.isThislessVariableLikeDeclaration(declaration /* as VariableLikeDeclaration */)
			case SyntaxKindMethodDeclaration,
				SyntaxKindMethodSignature,
				SyntaxKindConstructor,
				SyntaxKindGetAccessor,
				SyntaxKindSetAccessor:
				return tc.isThislessFunctionLikeDeclaration(declaration /* as FunctionLikeDeclaration | AccessorDeclaration */)
			}
		}
	}
	return false
}

// The mappingThisOnly flag indicates that the only type parameter being mapped is "this". When the flag is true,
// we check symbols to see if we can quickly conclude they are free of "this" references, thus needing no instantiation.
func (tc *TypeChecker) createInstantiatedSymbolTable(symbols []Symbol, mapper TypeMapper, mappingThisOnly bool) SymbolTable {
	result := createSymbolTable()
	for _, symbol := range symbols {
		result.set(symbol.escapedName, __COND__(mappingThisOnly && tc.isThisless(symbol), symbol, tc.instantiateSymbol(symbol, mapper)))
	}
	return result
}

func (tc *TypeChecker) addInheritedMembers(symbols SymbolTable, baseSymbols []Symbol) {
	for _, base := range baseSymbols {
		if tc.isStaticPrivateIdentifierProperty(base) {
			continue
		}
		derived := symbols.get(base.escapedName)
		if !derived || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) && !tc.isConstructorDeclaredProperty(derived) && !getContainingClassStaticBlock(derived.valueDeclaration) {
			symbols.set(base.escapedName, base)
			symbols.set(base.escapedName, base)
		}
	}
}

func (tc *TypeChecker) isStaticPrivateIdentifierProperty(s Symbol) bool {
	return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration)
}

func (tc *TypeChecker) resolveDeclaredMembers(type_ InterfaceType) InterfaceTypeWithDeclaredMembers {
	if !(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredProperties {
		symbol := type_.symbol
		members := tc.getMembersOfSymbol(symbol)
		(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredProperties = tc.getNamedMembers(members)
		// Start with signatures at empty array in case of recursive types
		(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredCallSignatures = emptyArray
		(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredConstructSignatures = emptyArray
		(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredIndexInfos = emptyArray

		(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredCallSignatures = tc.getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
		(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredConstructSignatures = tc.getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
		(type_ /* as InterfaceTypeWithDeclaredMembers */).declaredIndexInfos = tc.getIndexInfosOfSymbol(symbol)
	}
	return type_ /* as InterfaceTypeWithDeclaredMembers */
}

/**
 * Indicates whether a declaration name is definitely late-bindable.
 * A declaration name is only late-bindable if:
 * - It is a `ComputedPropertyName`.
 * - Its expression is an `Identifier` or either a `PropertyAccessExpression` an
 * `ElementAccessExpression` consisting only of these same three types of nodes.
 * - The type of its expression is a string or numeric literal type, or is a `unique symbol` type.
 */

func (tc *TypeChecker) isLateBindableName(node DeclarationName) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LateBoundName */ any {
	if !isComputedPropertyName(node) && !isElementAccessExpression(node) {
		return false
	}
	var expr Expression
	if isComputedPropertyName(node) {
		expr = node.expression
	} else {
		expr = node.argumentExpression
	}
	return isEntityNameExpression(expr) && isTypeUsableAsPropertyName(__COND__(isComputedPropertyName(node), tc.checkComputedPropertyName(node), tc.checkExpressionCached(expr)))
}

func (tc *TypeChecker) isLateBoundName(name __String) bool {
	return (name /* as string */).charCodeAt(0) == CharacterCodes_ && (name /* as string */).charCodeAt(1) == CharacterCodes_ && (name /* as string */).charCodeAt(2) == CharacterCodesat
}

/**
 * Indicates whether a declaration has a late-bindable dynamic name.
 */

func (tc *TypeChecker) hasLateBindableName(node Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any {
	name := getNameOfDeclaration(node)
	return !!name && tc.isLateBindableName(name)
}

/**
 * Indicates whether a declaration has an early-bound name or a dynamic name that can be late-bound.
 */

func (tc *TypeChecker) hasBindableName(node Declaration) bool {
	return !hasDynamicName(node) || tc.hasLateBindableName(node)
}

/**
 * Indicates whether a declaration name is a dynamic name that cannot be late-bound.
 */

func (tc *TypeChecker) isNonBindableDynamicName(node DeclarationName) bool {
	return isDynamicName(node) && !tc.isLateBindableName(node)
}

/**
 * Adds a declaration to a late-bound dynamic member. This performs the same function for
 * late-bound members that `addDeclarationToSymbol` in binder.ts performs for early-bound
 * members.
 */

func (tc *TypeChecker) addDeclarationToLateBoundSymbol(symbol Symbol, member /* TODO(TS-TO-GO) TypeNode UnionType: LateBoundDeclaration | BinaryExpression */ any, symbolFlags SymbolFlags) {
	Debug.assert(!!(getCheckFlags(symbol) & CheckFlagsLate), "Expected a late-bound symbol.")
	symbol.flags |= symbolFlags
	tc.getSymbolLinks(member.symbol).lateSymbol = symbol
	if !symbol.declarations {
		symbol.declarations = [] /* TODO(TS-TO-GO) inferred type BinaryExpression | LateBoundDeclaration */ any{member}
	} else if !member.symbol.isReplaceableByMethod {
		symbol.declarations.push(member)
	}
	if symbolFlags & SymbolFlagsValue {
		if !symbol.valueDeclaration || symbol.valueDeclaration.kind != member.kind {
			symbol.valueDeclaration = member
		}
	}
}

/**
 * Performs late-binding of a dynamic member. This performs the same function for
 * late-bound members that `declareSymbol` in binder.ts performs for early-bound
 * members.
 *
 * If a symbol is a dynamic name from a computed property, we perform an additional "late"
 * binding phase to attempt to resolve the name for the symbol from the type of the computed
 * property's expression. If the type of the expression is a string-literal, numeric-literal,
 * or unique symbol type, we can use that type as the name of the symbol.
 *
 * For example, given:
 *
 *   const x = Symbol();
 *
 *   interface I {
 *     [x]: number;
 *   }
 *
 * The binder gives the property `[x]: number` a special symbol with the name "__computed".
 * In the late-binding phase we can type-check the expression `x` and see that it has a
 * unique symbol type which we can then use as the name of the member. This allows users
 * to define custom symbols that can be used in the members of an object type.
 *
 * @param parent The containing symbol for the member.
 * @param earlySymbols The early-bound symbols of the parent.
 * @param lateSymbols The late-bound symbols of the parent.
 * @param decl The member to bind.
 */

func (tc *TypeChecker) lateBindMember(parent Symbol, earlySymbols *SymbolTable, lateSymbols Map[__String, TransientSymbol], decl /* TODO(TS-TO-GO) TypeNode UnionType: LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any) Symbol {
	Debug.assert(!!decl.symbol, "The member is expected to have a symbol.")
	links := tc.getNodeLinks(decl)
	if !links.resolvedSymbol {
		// In the event we attempt to resolve the late-bound name of this member recursively,
		// fall back to the early-bound name of this member.
		links.resolvedSymbol = decl.symbol
		var declName /* TODO(TS-TO-GO) inferred type LateBoundElementAccessExpression | LateBoundName */ any
		if isBinaryExpression(decl) {
			declName = decl.left
		} else {
			declName = decl.name
		}
		var type_ Type
		if isElementAccessExpression(declName) {
			type_ = tc.checkExpressionCached(declName.argumentExpression)
		} else {
			type_ = tc.checkComputedPropertyName(declName)
		}
		if isTypeUsableAsPropertyName(type_) {
			memberName := getPropertyNameFromType(type_)
			symbolFlags := decl.symbol.flags

			// Get or add a late-bound symbol for the member. This allows us to merge late-bound accessor declarations.
			lateSymbol := lateSymbols.get(memberName)
			if !lateSymbol {
				lateSymbols.set(memberName /* TODO(TS-TO-GO) EqualsToken BinaryExpression: lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late) */, TODO)
			}

			// Report an error if there's a symbol declaration with the same name and conflicting flags.
			earlySymbol := earlySymbols && earlySymbols.get(memberName)
			// Duplicate property declarations of classes are checked in checkClassForDuplicateDeclarations.
			if !(parent.flags & SymbolFlagsClass) && lateSymbol.flags&tc.getExcludedSymbolFlags(symbolFlags) {
				// If we have an existing early-bound member, combine its declarations so that we can
				// report an error at each declaration.
				var declarations *[]Declaration
				if earlySymbol {
					declarations = concatenate(earlySymbol.declarations, lateSymbol.declarations)
				} else {
					declarations = lateSymbol.declarations
				}
				name := !(type_.flags&TypeFlagsUniqueESSymbol) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName)
				forEach(declarations, func(declaration Declaration) Diagnostic {
					return tc.error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name)
				})
				tc.error(declName || decl, Diagnostics.Duplicate_property_0, name)
				lateSymbol = tc.createSymbol(SymbolFlagsNone, memberName, CheckFlagsLate)
			}
			lateSymbol.links.nameType = type_
			tc.addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags)
			if lateSymbol.parent {
				Debug.assert(lateSymbol.parent == parent, "Existing symbol parent should match new one")
			} else {
				lateSymbol.parent = parent
			}
			links.resolvedSymbol = lateSymbol
			return links.resolvedSymbol
		}
	}
	return links.resolvedSymbol
}

func (tc *TypeChecker) getResolvedMembersOrExportsOfSymbol(symbol Symbol, resolutionKind MembersOrExportsResolutionKind) Map[__String, Symbol] {
	links := tc.getSymbolLinks(symbol)
	if !links[resolutionKind] {
		isStatic := resolutionKind == MembersOrExportsResolutionKindresolvedExports
		var earlySymbols *SymbolTable
		switch {
		case !isStatic:
			earlySymbols = symbol.members
		case symbol.flags & SymbolFlagsModule:
			earlySymbols = tc.getExportsOfModuleWorker(symbol).exports
		default:
			earlySymbols = symbol.exports
		}

		// In the event we recursively resolve the members/exports of the symbol, we
		// set the initial value of resolvedMembers/resolvedExports to the early-bound
		// members/exports of the symbol.
		links[resolutionKind] = earlySymbols || tc.emptySymbols

		// fill in any as-yet-unresolved late-bound members.
		lateSymbols := createSymbolTable() /* as Map<__String, TransientSymbol> */
		for _, decl := range symbol.declarations || emptyArray {
			members := getMembersOfDeclaration(decl)
			if members {
				for _, member := range members {
					if isStatic == hasStaticModifier(member) {
						if tc.hasLateBindableName(member) {
							tc.lateBindMember(symbol, earlySymbols, lateSymbols, member)
						}
					}
				}
			}
		}
		assignments := tc.getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers

		if assignments {
			decls := arrayFrom(assignments.values())
			for _, member := range decls {
				assignmentKind := getAssignmentDeclarationKind(member /* as BinaryExpression | CallExpression */)
				isInstanceMember := assignmentKind == AssignmentDeclarationKindPrototypeProperty || isBinaryExpression(member) && tc.isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind == AssignmentDeclarationKindObjectDefinePrototypeProperty || assignmentKind == AssignmentDeclarationKindPrototype
				// A straight `Prototype` assignment probably can never have a computed name
				if isStatic == !isInstanceMember {
					if tc.hasLateBindableName(member) {
						tc.lateBindMember(symbol, earlySymbols, lateSymbols, member)
					}
				}
			}
		}

		resolved := tc.combineSymbolTables(earlySymbols, lateSymbols)
		if symbol.flags&SymbolFlagsTransient && links.cjsExportMerged && symbol.declarations {
			for _, decl := range symbol.declarations {
				original := tc.getSymbolLinks(decl.symbol)[resolutionKind]
				if !resolved {
					resolved = original
					continue
				}
				if !original {
					continue
				}
				original.forEach(func(s Symbol, name __String) {
					existing := resolved.get(name)
					if !existing {
						resolved.set(name, s)
					} else if existing == s {
						return
					} else {
						resolved.set(name, tc.mergeSymbol(existing, s))
					}
				})
			}
		}
		links[resolutionKind] = resolved || tc.emptySymbols
	}

	return links[resolutionKind]
}

/**
 * Gets a SymbolTable containing both the early- and late-bound members of a symbol.
 *
 * For a description of late-binding, see `lateBindMember`.
 */

func (tc *TypeChecker) getMembersOfSymbol(symbol Symbol) SymbolTable {
	if symbol.flags & SymbolFlagsLateBindingContainer {
		return tc.getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKindresolvedMembers)
	} else {
		return symbol.members || tc.emptySymbols
	}
}

/**
 * If a symbol is the dynamic name of the member of an object type, get the late-bound
 * symbol of the member.
 *
 * For a description of late-binding, see `lateBindMember`.
 */

func (tc *TypeChecker) getLateBoundSymbol(symbol Symbol) Symbol {
	if symbol.flags&SymbolFlagsClassMember && symbol.escapedName == InternalSymbolNameComputed {
		links := tc.getSymbolLinks(symbol)
		if !links.lateSymbol && some(symbol.declarations, tc.hasLateBindableName) {
			// force late binding of members/exports. This will set the late-bound symbol
			parent := tc.getMergedSymbol(symbol.parent)
			if some(symbol.declarations, hasStaticModifier) {
				tc.getExportsOfSymbol(parent)
			} else {
				tc.getMembersOfSymbol(parent)
			}
		}
		return links.lateSymbol || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.lateSymbol = symbol */ TODO)
	}
	return symbol
}

func (tc *TypeChecker) getTypeWithThisArgument(type_ Type, thisArgument Type, needApparentType bool) Type {
	if getObjectFlags(type_) & ObjectFlagsReference {
		target := (type_ /* as TypeReference */).target
		typeArguments := tc.getTypeArguments(type_ /* as TypeReference */)
		if length(target.typeParameters) == length(typeArguments) {
			return tc.createTypeReference(target, concatenate(typeArguments, []Type{thisArgument || target.thisType}))
		} else {
			return type_
		}
	} else if type_.flags & TypeFlagsIntersection {
		types := sameMap((type_ /* as IntersectionType */).types, func(t Type) Type {
			return tc.getTypeWithThisArgument(t, thisArgument, needApparentType)
		})
		if types != (type_ /* as IntersectionType */).types {
			return tc.getIntersectionType(types)
		} else {
			return type_
		}
	}
	if needApparentType {
		return tc.getApparentType(type_)
	} else {
		return type_
	}
}

func (tc *TypeChecker) resolveObjectTypeMembers(type_ ObjectType, source InterfaceTypeWithDeclaredMembers, typeParameters []TypeParameter, typeArguments []Type) {
	var mapper *TypeMapper
	var members SymbolTable
	var callSignatures []Signature
	var constructSignatures []Signature
	var indexInfos []IndexInfo
	if rangeEquals(typeParameters, typeArguments, 0, typeParameters.length) {
		if source.symbol {
			members = tc.getMembersOfSymbol(source.symbol)
		} else {
			members = createSymbolTable(source.declaredProperties)
		}
		callSignatures = source.declaredCallSignatures
		constructSignatures = source.declaredConstructSignatures
		indexInfos = source.declaredIndexInfos
	} else {
		mapper = tc.createTypeMapper(typeParameters, typeArguments)
		members = tc.createInstantiatedSymbolTable(source.declaredProperties, mapper /*mappingThisOnly*/, typeParameters.length == 1)
		callSignatures = tc.instantiateSignatures(source.declaredCallSignatures, mapper)
		constructSignatures = tc.instantiateSignatures(source.declaredConstructSignatures, mapper)
		indexInfos = tc.instantiateIndexInfos(source.declaredIndexInfos, mapper)
	}
	baseTypes := tc.getBaseTypes(source)
	if baseTypes.length {
		if source.symbol && members == tc.getMembersOfSymbol(source.symbol) {
			symbolTable := createSymbolTable(source.declaredProperties)
			// copy index signature symbol as well (for quickinfo)
			sourceIndex := tc.getIndexSymbol(source.symbol)
			if sourceIndex {
				symbolTable.set(InternalSymbolNameIndex, sourceIndex)
			}
			members = symbolTable
		}
		tc.setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
		thisArgument := lastOrUndefined(typeArguments)
		for _, baseType := range baseTypes {
			var instantiatedBaseType Type
			if thisArgument {
				instantiatedBaseType = tc.getTypeWithThisArgument(tc.instantiateType(baseType, mapper), thisArgument)
			} else {
				instantiatedBaseType = baseType
			}
			tc.addInheritedMembers(members, tc.getPropertiesOfType(instantiatedBaseType))
			callSignatures = concatenate(callSignatures, tc.getSignaturesOfType(instantiatedBaseType, SignatureKindCall))
			constructSignatures = concatenate(constructSignatures, tc.getSignaturesOfType(instantiatedBaseType, SignatureKindConstruct))
			var inheritedIndexInfos []IndexInfo
			if instantiatedBaseType != tc.anyType {
				inheritedIndexInfos = tc.getIndexInfosOfType(instantiatedBaseType)
			} else {
				inheritedIndexInfos = []IndexInfo{tc.createIndexInfo(tc.stringType, tc.anyType /*isReadonly*/, false)}
			}
			indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, func(info IndexInfo) bool {
				return !tc.findIndexInfo(indexInfos, info.keyType)
			}))
		}
	}
	tc.setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
}

func (tc *TypeChecker) resolveClassOrInterfaceMembers(type_ InterfaceType) {
	tc.resolveObjectTypeMembers(type_, tc.resolveDeclaredMembers(type_), emptyArray, emptyArray)
}

func (tc *TypeChecker) resolveTypeReferenceMembers(type_ TypeReference) {
	source := tc.resolveDeclaredMembers(type_.target)
	typeParameters := concatenate(source.typeParameters, []TypeParameter{source.thisType})
	typeArguments := tc.getTypeArguments(type_)
	var paddedTypeArguments []Type
	if typeArguments.length == typeParameters.length {
		paddedTypeArguments = typeArguments
	} else {
		paddedTypeArguments = concatenate(typeArguments, []TypeReference{type_})
	}
	tc.resolveObjectTypeMembers(type_, source, typeParameters, paddedTypeArguments)
}

func (tc *TypeChecker) createSignature(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature | undefined */ any, typeParameters *[]TypeParameter, thisParameter Symbol, parameters []Symbol, resolvedReturnType Type, resolvedTypePredicate *TypePredicate, minArgumentCount number, flags SignatureFlags) Signature {
	sig := NewSignature(tc.checker, flags)
	sig.declaration = declaration
	sig.typeParameters = typeParameters
	sig.parameters = parameters
	sig.thisParameter = thisParameter
	sig.resolvedReturnType = resolvedReturnType
	sig.resolvedTypePredicate = resolvedTypePredicate
	sig.minArgumentCount = minArgumentCount
	sig.resolvedMinArgumentCount = nil
	sig.target = nil
	sig.mapper = nil
	sig.compositeSignatures = nil
	sig.compositeKind = nil
	return sig
}

func (tc *TypeChecker) cloneSignature(sig Signature) Signature {
	result := tc.createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters /*resolvedReturnType*/, nil /*resolvedTypePredicate*/, nil, sig.minArgumentCount, sig.flags&SignatureFlagsPropagatingFlags)
	result.target = sig.target
	result.mapper = sig.mapper
	result.compositeSignatures = sig.compositeSignatures
	result.compositeKind = sig.compositeKind
	return result
}

func (tc *TypeChecker) createUnionSignature(signature Signature, unionSignatures []Signature) Signature {
	result := tc.cloneSignature(signature)
	result.compositeSignatures = unionSignatures
	result.compositeKind = TypeFlagsUnion
	result.target = nil
	result.mapper = nil
	return result
}

func (tc *TypeChecker) getOptionalCallSignature(signature Signature, callChainFlags SignatureFlags) Signature {
	if (signature.flags & SignatureFlagsCallChainFlags) == callChainFlags {
		return signature
	}
	if !signature.optionalCallSignatureCache {
		signature.optionalCallSignatureCache = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		}
	}
	var key /* TODO(TS-TO-GO) inferred type "inner" | "outer" */ any
	if callChainFlags == SignatureFlagsIsInnerCallChain {
		key = "inner"
	} else {
		key = "outer"
	}
	return signature.optionalCallSignatureCache[key] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags) */ TODO)
}

func (tc *TypeChecker) createOptionalCallSignature(signature Signature, callChainFlags SignatureFlags) Signature {
	Debug.assert(callChainFlags == SignatureFlagsIsInnerCallChain || callChainFlags == SignatureFlagsIsOuterCallChain, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.")
	result := tc.cloneSignature(signature)
	result.flags |= callChainFlags
	return result
}

func (tc *TypeChecker) getExpandedParameters(sig Signature, skipUnionExpanding bool) [][]Symbol {
	if signatureHasRestParameter(sig) {
		restIndex := sig.parameters.length - 1
		restSymbol := sig.parameters[restIndex]
		restType := tc.getTypeOfSymbol(restSymbol)
		if tc.isTupleType(restType) {
			return [][]Symbol{expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)}
		} else if !skipUnionExpanding && restType.flags&TypeFlagsUnion && every((restType /* as UnionType */).types, tc.isTupleType) {
			return map_((restType /* as UnionType */).types, func(t Type) []Symbol {
				return expandSignatureParametersWithTupleMembers(t /* as TupleTypeReference */, restIndex, restSymbol)
			})
		}
	}
	return [][]Symbol{sig.parameters}

	expandSignatureParametersWithTupleMembers := func(restType TupleTypeReference, restIndex number, restSymbol Symbol) []Symbol {
		elementTypes := tc.getTypeArguments(restType)
		associatedNames := getUniqAssociatedNamesFromTupleType(restType, restSymbol)
		restParams := map_(elementTypes, func(t Type, i number) TransientSymbol {
			// Lookup the label from the individual tuple passed in before falling back to the signature `rest` parameter name
			var name /* TODO(TS-TO-GO) inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | InternalSymbolName */ any
			if associatedNames && associatedNames[i] {
				name = associatedNames[i]
			} else {
				name = tc.getParameterNameAtPosition(sig, restIndex+i, restType)
			}
			flags := restType.target.elementFlags[i]
			var checkFlags /* TODO(TS-TO-GO) inferred type 0 | CheckFlags.OptionalParameter | CheckFlags.RestParameter */ any
			switch {
			case flags & ElementFlagsVariable:
				checkFlags = CheckFlagsRestParameter
			case flags & ElementFlagsOptional:
				checkFlags = CheckFlagsOptionalParameter
			default:
				checkFlags = 0
			}
			symbol := tc.createSymbol(SymbolFlagsFunctionScopedVariable, name, checkFlags)
			if flags & ElementFlagsRest {
				symbol.links.type_ = tc.createArrayType(t)
			} else {
				symbol.links.type_ = t
			}
			return symbol
		})
		return concatenate(sig.parameters.slice(0, restIndex), restParams)
	}

	getUniqAssociatedNamesFromTupleType := func(type_ TupleTypeReference, restSymbol Symbol) *[]__String {
		names := map_(type_.target.labeledElementDeclarations, func(labeledElement * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any, i number) __String {
			return tc.getTupleElementLabel(labeledElement, i, type_.target.elementFlags[i], restSymbol)
		})
		if names {
			var duplicates []number = []never{}
			uniqueNames := NewSet[__String]()
			for i := 0; i < names.length; i++ {
				name := names[i]
				if !tryAddToSet(uniqueNames, name) {
					duplicates.push(i)
				}
			}
			counters := NewMap[__String, number]()
			for _, i := range duplicates {
				counter := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: counters.get(names[i]) ?? 1 */ TODO
				var name __String
				for !tryAddToSet(uniqueNames /* TODO(TS-TO-GO) EqualsToken BinaryExpression: name = `${names[i]}_${counter}` as __String */, TODO) {
					counter++
				}
				names[i] = name
				counters.set(names[i], counter+1)
			}
		}
		return names
	}

}

func (tc *TypeChecker) getDefaultConstructSignatures(classType InterfaceType) []Signature {
	baseConstructorType := tc.getBaseConstructorTypeOfClass(classType)
	baseSignatures := tc.getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
	declaration := getClassLikeDeclarationOfSymbol(classType.symbol)
	isAbstract := !!declaration && hasSyntacticModifier(declaration, ModifierFlagsAbstract)
	if baseSignatures.length == 0 {
		return []Signature{tc.createSignature(nil, classType.localTypeParameters /*thisParameter*/, nil, emptyArray, classType /*resolvedTypePredicate*/, nil, 0, __COND__(isAbstract, SignatureFlagsAbstract, SignatureFlagsNone))}
	}
	baseTypeNode := tc.getBaseTypeNodeOfClass(classType)
	isJavaScript := isInJSFile(baseTypeNode)
	typeArguments := tc.typeArgumentsFromTypeReferenceNode(baseTypeNode)
	typeArgCount := length(typeArguments)
	var result []Signature = []never{}
	for _, baseSig := range baseSignatures {
		minTypeArgumentCount := tc.getMinTypeArgumentCount(baseSig.typeParameters)
		typeParamCount := length(baseSig.typeParameters)
		if isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount {
			var sig Signature
			if typeParamCount {
				sig = tc.createSignatureInstantiation(baseSig, tc.fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript))
			} else {
				sig = tc.cloneSignature(baseSig)
			}
			sig.typeParameters = classType.localTypeParameters
			sig.resolvedReturnType = classType
			if isAbstract {
				sig.flags = sig.flags | SignatureFlagsAbstract
			} else {
				sig.flags = sig.flags & ~SignatureFlagsAbstract
			}
			result.push(sig)
		}
	}
	return result
}

func (tc *TypeChecker) findMatchingSignature(signatureList []Signature, signature Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool) *Signature {
	for _, s := range signatureList {
		if tc.compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, __COND__(partialMatch, tc.compareTypesSubtypeOf, tc.compareTypesIdentical)) {
			return s
		}
	}
}

func (tc *TypeChecker) findMatchingSignatures(signatureLists [][]Signature, signature Signature, listIndex number) *[]Signature {
	if signature.typeParameters {
		// We require an exact match for generic signatures, so we only return signatures from the first
		// signature list and only if they have exact matches in the other signature lists.
		if listIndex > 0 {
			return nil
		}
		for i := 1; i < signatureLists.length; i++ {
			if !tc.findMatchingSignature(signatureLists[i], signature /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, false) {
				return nil
			}
		}
		return []Signature{signature}
	}
	var result *[]Signature
	for i := 0; i < signatureLists.length; i++ {
		// Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.
		// Prefer matching this types if possible.
		var match *Signature
		if i == listIndex {
			match = signature
		} else {
			match = tc.findMatchingSignature(signatureLists[i], signature /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true) || tc.findMatchingSignature(signatureLists[i], signature /*partialMatch*/, true /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true)
		}
		if !match {
			return nil
		}
		result = appendIfUnique(result, match)
	}
	return result
}

// The signatures of a union type are those signatures that are present in each of the constituent types.
// Generic signatures must match exactly, but non-generic signatures are allowed to have extra optional
// parameters and may differ in return types. When signatures differ in return types, the resulting return
// type is the union of the constituent return types.
func (tc *TypeChecker) getUnionSignatures(signatureLists [][]Signature) []Signature {
	var result *[]Signature
	var indexWithLengthOverOne *number
	for i := 0; i < signatureLists.length; i++ {
		if signatureLists[i].length == 0 {
			return emptyArray
		}
		if signatureLists[i].length > 1 {
			if indexWithLengthOverOne == nil {
				indexWithLengthOverOne = i
			} else {
				indexWithLengthOverOne = -1
			}
			// -1 is a signal there are multiple overload sets
		}
		for _, signature := range signatureLists[i] {
			// Only process signatures with parameter lists that aren't already in the result list
			if !result || !tc.findMatchingSignature(result, signature /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, true) {
				unionSignatures := tc.findMatchingSignatures(signatureLists, signature, i)
				if unionSignatures {
					s := signature
					// Union the result types when more than one signature matches
					if unionSignatures.length > 1 {
						thisParameter := signature.thisParameter
						firstThisParameterOfUnionSignatures := forEach(unionSignatures, func(sig Signature) Symbol {
							return sig.thisParameter
						})
						if firstThisParameterOfUnionSignatures {
							thisType := tc.getIntersectionType(mapDefined(unionSignatures, func(sig Signature) Type {
								return sig.thisParameter && tc.getTypeOfSymbol(sig.thisParameter)
							}))
							thisParameter = tc.createSymbolWithType(firstThisParameterOfUnionSignatures, thisType)
						}
						s = tc.createUnionSignature(signature, unionSignatures)
						s.thisParameter = thisParameter
					}
					(result || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = [] */ TODO)).push(s)
				}
			}
		}
	}
	if !length(result) && indexWithLengthOverOne != -1 {
		// No sufficiently similar signature existed to subsume all the other signatures in the union - time to see if we can make a single
		// signature that handles all over them. We only do this when there are overloads in only one constituent.
		// (Overloads are conditional in nature and having overloads in multiple constituents would necessitate making a power set of
		// signatures from the type, whose ordering would be non-obvious)
		masterList := signatureLists[__COND__(indexWithLengthOverOne != nil, indexWithLengthOverOne, 0)]
		var results *[]Signature = masterList.slice()
		for _, signatures := range signatureLists {
			if signatures != masterList {
				signature := signatures[0]
				Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass")
				if !!signature.typeParameters && some(results, func(s Signature) bool {
					return !!s.typeParameters && !tc.compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)
				}) {
					results = nil
				} else {
					results = map_(results, func(sig Signature) Signature {
						return tc.combineSignaturesOfUnionMembers(sig, signature)
					})
				}
				if !results {
					break
				}
			}
		}
		result = results
	}
	return result || emptyArray
}

func (tc *TypeChecker) compareTypeParametersIdentical(sourceParams *[]TypeParameter, targetParams *[]TypeParameter) bool {
	if length(sourceParams) != length(targetParams) {
		return false
	}
	if !sourceParams || !targetParams {
		return true
	}

	mapper := tc.createTypeMapper(targetParams, sourceParams)
	for i := 0; i < sourceParams.length; i++ {
		source := sourceParams[i]
		target := targetParams[i]
		if source == target {
			continue
		}
		// We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`
		if !tc.isTypeIdenticalTo(tc.getConstraintFromTypeParameter(source) || tc.unknownType, tc.instantiateType(tc.getConstraintFromTypeParameter(target) || tc.unknownType, mapper)) {
			return false
		}
		// We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.
		// It might make sense to combine these defaults in the future, but doing so intelligently requires knowing
		// if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)
		// and, since it's just an inference _default_, just picking one arbitrarily works OK.
	}

	return true
}

func (tc *TypeChecker) combineUnionThisParam(left Symbol, right Symbol, mapper *TypeMapper) Symbol {
	if !left || !right {
		return left || right
	}
	// A signature `this` type might be a read or a write position... It's very possible that it should be invariant
	// and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
	// permissive when calling, for now, we'll intersect the `this` types just like we do for param types in union signatures.
	thisType := tc.getIntersectionType([]Type{tc.getTypeOfSymbol(left), tc.instantiateType(tc.getTypeOfSymbol(right), mapper)})
	return tc.createSymbolWithType(left, thisType)
}

func (tc *TypeChecker) combineUnionParameters(left Signature, right Signature, mapper *TypeMapper) []Symbol {
	leftCount := tc.getParameterCount(left)
	rightCount := tc.getParameterCount(right)
	var longest Signature
	if leftCount >= rightCount {
		longest = left
	} else {
		longest = right
	}
	var shorter Signature
	if longest == left {
		shorter = right
	} else {
		shorter = left
	}
	var longestCount number
	if longest == left {
		longestCount = leftCount
	} else {
		longestCount = rightCount
	}
	eitherHasEffectiveRest := tc.hasEffectiveRestParameter(left) || tc.hasEffectiveRestParameter(right)
	needsExtraRestElement := eitherHasEffectiveRest && !tc.hasEffectiveRestParameter(longest)
	params := NewArray[Symbol](longestCount + (__COND__(needsExtraRestElement, 1, 0)))
	for i := 0; i < longestCount; i++ {
		longestParamType := tc.tryGetTypeAtPosition(longest, i)
		if longest == right {
			longestParamType = tc.instantiateType(longestParamType, mapper)
		}
		shorterParamType := tc.tryGetTypeAtPosition(shorter, i) || tc.unknownType
		if shorter == right {
			shorterParamType = tc.instantiateType(shorterParamType, mapper)
		}
		unionParamType := tc.getIntersectionType([]Type{longestParamType, shorterParamType})
		isRestParam := eitherHasEffectiveRest && !needsExtraRestElement && i == (longestCount-1)
		isOptional := i >= tc.getMinArgumentCount(longest) && i >= tc.getMinArgumentCount(shorter)
		var leftName *__String
		if i >= leftCount {
			leftName = nil
		} else {
			leftName = tc.getParameterNameAtPosition(left, i)
		}
		var rightName *__String
		if i >= rightCount {
			rightName = nil
		} else {
			rightName = tc.getParameterNameAtPosition(right, i)
		}

		var paramName *__String
		switch {
		case leftName == rightName:
			paramName = leftName
		case !leftName:
			paramName = rightName
		case !rightName:
			paramName = leftName
		default:
			paramName = nil
		}
		paramSymbol := tc.createSymbol(SymbolFlagsFunctionScopedVariable|(__COND__(isOptional && !isRestParam, SymbolFlagsOptional, 0)), paramName || __TEMPLATE__("arg", i) /* as __String */, __COND__(isRestParam, CheckFlagsRestParameter, __COND__(isOptional, CheckFlagsOptionalParameter, 0)))
		if isRestParam {
			paramSymbol.links.type_ = tc.createArrayType(unionParamType)
		} else {
			paramSymbol.links.type_ = unionParamType
		}
		params[i] = paramSymbol
	}
	if needsExtraRestElement {
		restParamSymbol := tc.createSymbol(SymbolFlagsFunctionScopedVariable, "args" /* as __String */, CheckFlagsRestParameter)
		restParamSymbol.links.type_ = tc.createArrayType(tc.getTypeAtPosition(shorter, longestCount))
		if shorter == right {
			restParamSymbol.links.type_ = tc.instantiateType(restParamSymbol.links.type_, mapper)
		}
		params[longestCount] = restParamSymbol
	}
	return params
}

func (tc *TypeChecker) combineSignaturesOfUnionMembers(left Signature, right Signature) Signature {
	typeParams := left.typeParameters || right.typeParameters
	var paramMapper *TypeMapper
	if left.typeParameters && right.typeParameters {
		paramMapper = tc.createTypeMapper(right.typeParameters, left.typeParameters)
		// We just use the type parameter defaults from the first signature
	}
	declaration := left.declaration
	params := tc.combineUnionParameters(left, right, paramMapper)
	thisParam := tc.combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper)
	minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
	result := tc.createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
	result.compositeKind = TypeFlagsUnion
	result.compositeSignatures = concatenate(left.compositeKind != TypeFlagsIntersection && left.compositeSignatures || []Signature{left}, []Signature{right})
	if paramMapper {
		if left.compositeKind != TypeFlagsIntersection && left.mapper && left.compositeSignatures {
			result.mapper = tc.combineTypeMappers(left.mapper, paramMapper)
		} else {
			result.mapper = paramMapper
		}
	} else if left.compositeKind != TypeFlagsIntersection && left.mapper && left.compositeSignatures {
		result.mapper = left.mapper
	}
	return result
}

func (tc *TypeChecker) getUnionIndexInfos(types []Type) []IndexInfo {
	sourceInfos := tc.getIndexInfosOfType(types[0])
	if sourceInfos {
		result := []never{}
		for _, info := range sourceInfos {
			indexType := info.keyType
			if every(types, func(t Type) bool {
				return !!tc.getIndexInfoOfType(t, indexType)
			}) {
				result.push(tc.createIndexInfo(indexType, tc.getUnionType(map_(types, func(t Type) Type {
					return tc.getIndexTypeOfType(t, indexType)
				})), some(types, func(t Type) bool {
					return tc.getIndexInfoOfType(t, indexType).isReadonly
				})))
			}
		}
		return result
	}
	return emptyArray
}

func (tc *TypeChecker) resolveUnionTypeMembers(type_ UnionType) {
	// The members and properties collections are empty for union types. To get all properties of a union
	// type use getPropertiesOfType (only the language service uses this).
	callSignatures := tc.getUnionSignatures(map_(type_.types, func(t Type) []Signature {
		if t == tc.globalFunctionType {
			return []Signature{tc.unknownSignature}
		} else {
			return tc.getSignaturesOfType(t, SignatureKindCall)
		}
	}))
	constructSignatures := tc.getUnionSignatures(map_(type_.types, func(t Type) []Signature {
		return tc.getSignaturesOfType(t, SignatureKindConstruct)
	}))
	indexInfos := tc.getUnionIndexInfos(type_.types)
	tc.setStructuredTypeMembers(type_, tc.emptySymbols, callSignatures, constructSignatures, indexInfos)
}

/* OVERLOAD: function intersectTypes(type1: Type, type2: Type): Type; */
/* OVERLOAD: function intersectTypes(type1: Type | undefined, type2: Type | undefined): Type | undefined; */
func (tc *TypeChecker) intersectTypes(type1 Type, type2 Type) Type {
	switch {
	case !type1:
		return type2
	case !type2:
		return type1
	default:
		return tc.getIntersectionType([]Type{type1, type2})
	}
}

func (tc *TypeChecker) findMixins(types []Type) []bool {
	constructorTypeCount := countWhere(types, func(t Type) bool {
		return tc.getSignaturesOfType(t, SignatureKindConstruct).length > 0
	})
	mixinFlags := map_(types, tc.isMixinConstructorType)
	if constructorTypeCount > 0 && constructorTypeCount == countWhere(mixinFlags, func(b bool) bool {
		return b
	}) {
		firstMixinIndex := mixinFlags.indexOf(true)
		mixinFlags[firstMixinIndex] = false
	}
	return mixinFlags
}

func (tc *TypeChecker) includeMixinType(type_ Type, types []Type, mixinFlags []bool, index number) Type {
	var mixedTypes []Type = []never{}
	for i := 0; i < types.length; i++ {
		if i == index {
			mixedTypes.push(type_)
		} else if mixinFlags[i] {
			mixedTypes.push(tc.getReturnTypeOfSignature(tc.getSignaturesOfType(types[i], SignatureKindConstruct)[0]))
		}
	}
	return tc.getIntersectionType(mixedTypes)
}

func (tc *TypeChecker) resolveIntersectionTypeMembers(type_ IntersectionType) {
	// The members and properties collections are empty for intersection types. To get all properties of an
	// intersection type use getPropertiesOfType (only the language service uses this).
	var callSignatures *[]Signature
	var constructSignatures *[]Signature
	var indexInfos *[]IndexInfo
	types := type_.types
	mixinFlags := tc.findMixins(types)
	mixinCount := countWhere(mixinFlags, func(b bool) bool {
		return b
	})
	for i := 0; i < types.length; i++ {
		t := type_.types[i]
		// When an intersection type contains mixin constructor types, the construct signatures from
		// those types are discarded and their return types are mixed into the return types of all
		// other construct signatures in the intersection type. For example, the intersection type
		// '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature
		// 'new(s: string) => A & B'.
		if !mixinFlags[i] {
			signatures := tc.getSignaturesOfType(t, SignatureKindConstruct)
			if signatures.length && mixinCount > 0 {
				signatures = map_(signatures, func(s Signature) Signature {
					clone := tc.cloneSignature(s)
					clone.resolvedReturnType = tc.includeMixinType(tc.getReturnTypeOfSignature(s), types, mixinFlags, i)
					return clone
				})
			}
			constructSignatures = tc.appendSignatures(constructSignatures, signatures)
		}
		callSignatures = tc.appendSignatures(callSignatures, tc.getSignaturesOfType(t, SignatureKindCall))
		indexInfos = reduceLeft(tc.getIndexInfosOfType(t), func(infos *[]IndexInfo, newInfo IndexInfo) []IndexInfo {
			return tc.appendIndexInfo(infos, newInfo /*union*/, false)
		}, indexInfos)
	}
	tc.setStructuredTypeMembers(type_, tc.emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray)
}

func (tc *TypeChecker) appendSignatures(signatures *[]Signature, newSignatures []Signature) *[]Signature {
	for _, sig := range newSignatures {
		if !signatures || every(signatures, func(s Signature) bool {
			return !tc.compareSignaturesIdentical(s, sig /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, false, tc.compareTypesIdentical)
		}) {
			signatures = append(signatures, sig)
		}
	}
	return signatures
}

func (tc *TypeChecker) appendIndexInfo(indexInfos *[]IndexInfo, newInfo IndexInfo, union bool) []IndexInfo {
	if indexInfos {
		for i := 0; i < indexInfos.length; i++ {
			info := indexInfos[i]
			if info.keyType == newInfo.keyType {
				indexInfos[i] = tc.createIndexInfo(info.keyType, __COND__(union, tc.getUnionType([]Type{info.type_, newInfo.type_}), tc.getIntersectionType([]Type{info.type_, newInfo.type_})), __COND__(union, info.isReadonly || newInfo.isReadonly, info.isReadonly && newInfo.isReadonly))
				return indexInfos
			}
		}
	}
	return append(indexInfos, newInfo)
}

/**
 * Converts an AnonymousType to a ResolvedType.
 */

func (tc *TypeChecker) resolveAnonymousTypeMembers(type_ AnonymousType) {
	if type_.target {
		tc.setStructuredTypeMembers(type_, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
		members := tc.createInstantiatedSymbolTable(tc.getPropertiesOfObjectType(type_.target), type_.mapper /*mappingThisOnly*/, false)
		callSignatures := tc.instantiateSignatures(tc.getSignaturesOfType(type_.target, SignatureKindCall), type_.mapper)
		constructSignatures := tc.instantiateSignatures(tc.getSignaturesOfType(type_.target, SignatureKindConstruct), type_.mapper)
		indexInfos := tc.instantiateIndexInfos(tc.getIndexInfosOfType(type_.target), type_.mapper)
		tc.setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
		return
	}
	symbol := tc.getMergedSymbol(type_.symbol)
	if symbol.flags & SymbolFlagsTypeLiteral {
		tc.setStructuredTypeMembers(type_, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
		members := tc.getMembersOfSymbol(symbol)
		callSignatures := tc.getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
		constructSignatures := tc.getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
		indexInfos := tc.getIndexInfosOfSymbol(symbol)
		tc.setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
		return
	}
	// Combinations of function, class, enum and module
	members := tc.getExportsOfSymbol(symbol)
	var indexInfos *[]IndexInfo
	if symbol == tc.globalThisSymbol {
		varsOnly := NewMap[__String, Symbol]()
		members.forEach(func(p Symbol) {
			if !(p.flags & SymbolFlagsBlockScoped) && !(p.flags&SymbolFlagsValueModule && p.declarations. /* ? */ length && every(p.declarations, isAmbientModule)) {
				varsOnly.set(p.escapedName, p)
			}
		})
		members = varsOnly
	}
	var baseConstructorIndexInfo *IndexInfo
	tc.setStructuredTypeMembers(type_, members, emptyArray, emptyArray, emptyArray)
	if symbol.flags & SymbolFlagsClass {
		classType := tc.getDeclaredTypeOfClassOrInterface(symbol)
		baseConstructorType := tc.getBaseConstructorTypeOfClass(classType)
		if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsTypeVariable) {
			members = createSymbolTable(tc.getNamedOrIndexSignatureMembers(members))
			tc.addInheritedMembers(members, tc.getPropertiesOfType(baseConstructorType))
		} else if baseConstructorType == tc.anyType {
			baseConstructorIndexInfo = tc.createIndexInfo(tc.stringType, tc.anyType /*isReadonly*/, false)
		}
	}

	indexSymbol := tc.getIndexSymbolFromSymbolTable(members)
	if indexSymbol {
		indexInfos = tc.getIndexInfosOfIndexSymbol(indexSymbol)
	} else {
		if baseConstructorIndexInfo {
			indexInfos = append(indexInfos, baseConstructorIndexInfo)
		}
		if symbol.flags&SymbolFlagsEnum && (tc.getDeclaredTypeOfSymbol(symbol).flags&TypeFlagsEnum || some(type_.properties, func(prop Symbol) bool {
			return !!(tc.getTypeOfSymbol(prop).flags & TypeFlagsNumberLike)
		})) {
			indexInfos = append(indexInfos, tc.enumNumberIndexInfo)
		}
	}
	tc.setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
	// We resolve the members before computing the signatures because a signature may use
	// typeof with a qualified name expression that circularly references the type we are
	// in the process of resolving (see issue #6072). The temporarily empty signature list
	// will never be observed because a qualified name can't reference signatures.
	if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
		type_.callSignatures = tc.getSignaturesOfSymbol(symbol)
	}
	// And likewise for construct signatures for classes
	if symbol.flags & SymbolFlagsClass {
		classType := tc.getDeclaredTypeOfClassOrInterface(symbol)
		var constructSignatures []Signature
		if symbol.members {
			constructSignatures = tc.getSignaturesOfSymbol(symbol.members.get(InternalSymbolNameConstructor))
		} else {
			constructSignatures = emptyArray
		}
		if symbol.flags & SymbolFlagsFunction {
			constructSignatures = addRange(constructSignatures.slice(), mapDefined(type_.callSignatures, func(sig Signature) *Signature {
				if tc.isJSConstructor(sig.declaration) {
					return tc.createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType /*resolvedTypePredicate*/, nil, sig.minArgumentCount, sig.flags&SignatureFlagsPropagatingFlags)
				} else {
					return nil
				}
			}))
		}
		if !constructSignatures.length {
			constructSignatures = tc.getDefaultConstructSignatures(classType)
		}
		type_.constructSignatures = constructSignatures
	}
}

func (tc *TypeChecker) replaceIndexedAccess(instantiable Type, type_ ReplaceableIndexedAccessType, replacement Type) Type {
	// map type.indexType to 0
	// map type.objectType to `[TReplacement]`
	// thus making the indexed access `[TReplacement][0]` or `TReplacement`
	return tc.instantiateType(instantiable, tc.createTypeMapper([] /* TODO(TS-TO-GO) inferred type Type & TypeParameter */ any{type_.indexType, type_.objectType}, []Type{tc.getNumberLiteralType(0), tc.createTupleType([]Type{replacement})}))
}

// If the original mapped type had an intersection constraint we extract its components,
// and we make an attempt to do so even if the intersection has been reduced to a union.
// This entire process allows us to possibly retrieve the filtering type literals.
// e.g. { [K in keyof U & ("a" | "b") ] } -> "a" | "b"
func (tc *TypeChecker) getLimitedConstraint(type_ ReverseMappedType) Type {
	constraint := tc.getConstraintTypeFromMappedType(type_.mappedType)
	if !(constraint.flags&TypeFlagsUnion || constraint.flags&TypeFlagsIntersection) {
		return
	}
	var origin Type
	if constraint.flags & TypeFlagsUnion {
		origin = (constraint /* as UnionType */).origin
	} else {
		origin = (constraint /* as IntersectionType */)
	}
	if !origin || !(origin.flags & TypeFlagsIntersection) {
		return
	}
	limitedConstraint := tc.getIntersectionType((origin /* as IntersectionType */).types.filter(func(t Type) bool {
		return t != type_.constraintType
	}))
	if limitedConstraint != tc.neverType {
		return limitedConstraint
	} else {
		return nil
	}
}

func (tc *TypeChecker) resolveReverseMappedTypeMembers(type_ ReverseMappedType) {
	indexInfo := tc.getIndexInfoOfType(type_.source, tc.stringType)
	modifiers := tc.getMappedTypeModifiers(type_.mappedType)
	var readonlyMask bool
	if modifiers & MappedTypeModifiersIncludeReadonly {
		readonlyMask = false
	} else {
		readonlyMask = true
	}
	var optionalMask /* TODO(TS-TO-GO) inferred type SymbolFlags.Optional | 0 */ any
	if modifiers & MappedTypeModifiersIncludeOptional {
		optionalMask = 0
	} else {
		optionalMask = SymbolFlagsOptional
	}
	var indexInfos []IndexInfo
	if indexInfo {
		indexInfos = []IndexInfo{tc.createIndexInfo(tc.stringType, tc.inferReverseMappedType(indexInfo.type_, type_.mappedType, type_.constraintType) || tc.unknownType, readonlyMask && indexInfo.isReadonly)}
	} else {
		indexInfos = emptyArray
	}
	members := createSymbolTable()
	limitedConstraint := tc.getLimitedConstraint(type_)
	for _, prop := range tc.getPropertiesOfType(type_.source) {
		// In case of a reverse mapped type with an intersection constraint, if we were able to
		// extract the filtering type literals we skip those properties that are not assignable to them,
		// because the extra properties wouldn't get through the application of the mapped type anyway
		if limitedConstraint {
			propertyNameType := tc.getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
			if !tc.isTypeAssignableTo(propertyNameType, limitedConstraint) {
				continue
			}
		}
		checkFlags := CheckFlagsReverseMapped | (__COND__(readonlyMask && tc.isReadonlySymbol(prop), CheckFlagsReadonly, 0))
		inferredProp := tc.createSymbol(SymbolFlagsProperty|prop.flags&optionalMask, prop.escapedName, checkFlags) /* as ReverseMappedSymbol */
		inferredProp.declarations = prop.declarations
		inferredProp.links.nameType = tc.getSymbolLinks(prop).nameType
		inferredProp.links.propertyType = tc.getTypeOfSymbol(prop)
		if type_.constraintType.type_.flags&TypeFlagsIndexedAccess && (type_.constraintType.type_ /* as IndexedAccessType */).objectType.flags&TypeFlagsTypeParameter && (type_.constraintType.type_ /* as IndexedAccessType */).indexType.flags&TypeFlagsTypeParameter {
			// A reverse mapping of `{[K in keyof T[K_1]]: T[K_1]}` is the same as that of `{[K in keyof T]: T}`, since all we care about is
			// inferring to the "type parameter" (or indexed access) shared by the constraint and template. So, to reduce the number of
			// type identities produced, we simplify such indexed access occurences
			newTypeParam := (type_.constraintType.type_ /* as IndexedAccessType */).objectType
			newMappedType := tc.replaceIndexedAccess(type_.mappedType, type_.constraintType.type_ /* as ReplaceableIndexedAccessType */, newTypeParam)
			inferredProp.links.mappedType = newMappedType                     /* as MappedType */
			inferredProp.links.constraintType = tc.getIndexType(newTypeParam) /* as IndexType */
		} else {
			inferredProp.links.mappedType = type_.mappedType
			inferredProp.links.constraintType = type_.constraintType
		}
		members.set(prop.escapedName, inferredProp)
	}
	tc.setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos)
}

// Return the lower bound of the key type in a mapped type. Intuitively, the lower
// bound includes those keys that are known to always be present, for example because
// because of constraints on type parameters (e.g. 'keyof T' for a constrained T).
func (tc *TypeChecker) getLowerBoundOfKeyType(type_ Type) Type {
	if type_.flags & TypeFlagsIndex {
		t := tc.getApparentType((type_ /* as IndexType */).type_)
		if tc.isGenericTupleType(t) {
			return tc.getKnownKeysOfTupleType(t)
		} else {
			return tc.getIndexType(t)
		}
	}
	if type_.flags & TypeFlagsConditional {
		if (type_ /* as ConditionalType */).root.isDistributive {
			checkType := (type_ /* as ConditionalType */).checkType
			constraint := tc.getLowerBoundOfKeyType(checkType)
			if constraint != checkType {
				return tc.getConditionalTypeInstantiation(type_ /* as ConditionalType */, tc.prependTypeMapping((type_ /* as ConditionalType */).root.checkType, constraint, (type_ /* as ConditionalType */).mapper) /*forConstraint*/, false)
			}
		}
		return type_
	}
	if type_.flags & TypeFlagsUnion {
		return tc.mapType(type_ /* as UnionType */, tc.getLowerBoundOfKeyType /*noReductions*/, true)
	}
	if type_.flags & TypeFlagsIntersection {
		// Similarly to getTypeFromIntersectionTypeNode, we preserve the special string & {}, number & {},
		// and bigint & {} intersections that are used to prevent subtype reduction in union types.
		types := (type_ /* as IntersectionType */).types
		if types.length == 2 && !!(types[0].flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) && types[1] == tc.emptyTypeLiteralType {
			return type_
		}
		return tc.getIntersectionType(sameMap((type_ /* as UnionType */).types, tc.getLowerBoundOfKeyType))
	}
	return type_
}

func (tc *TypeChecker) getIsLateCheckFlag(s Symbol) CheckFlags {
	return getCheckFlags(s) & CheckFlagsLate
}

func (tc *TypeChecker) forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(type_ Type, include TypeFlags, stringsOnly bool, cb func(keyType Type)) {
	for _, prop := range tc.getPropertiesOfType(type_) {
		cb(tc.getLiteralTypeFromProperty(prop, include))
	}
	if type_.flags & TypeFlagsAny {
		cb(tc.stringType)
	} else {
		for _, info := range tc.getIndexInfosOfType(type_) {
			if !stringsOnly || info.keyType.flags&(TypeFlagsString|TypeFlagsTemplateLiteral) {
				cb(info.keyType)
			}
		}
	}
}

/** Resolve the members of a mapped type { [P in K]: T } */

func (tc *TypeChecker) resolveMappedTypeMembers(type_ MappedType) {
	var members SymbolTable = createSymbolTable()
	var indexInfos *[]IndexInfo
	// Resolve upfront such that recursive references see an empty object type.
	tc.setStructuredTypeMembers(type_, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	// In { [P in K]: T }, we refer to P as the type parameter type, K as the constraint type,
	// and T as the template type.
	typeParameter := tc.getTypeParameterFromMappedType(type_)
	constraintType := tc.getConstraintTypeFromMappedType(type_)
	mappedType := (type_.target /* as MappedType */) || type_
	nameType := tc.getNameTypeFromMappedType(mappedType)
	shouldLinkPropDeclarations := tc.getMappedTypeNameTypeKind(mappedType) != MappedTypeNameTypeKindRemapping
	templateType := tc.getTemplateTypeFromMappedType(mappedType)
	modifiersType := tc.getApparentType(tc.getModifiersTypeFromMappedType(type_))
	// The 'T' in 'keyof T'
	templateModifiers := tc.getMappedTypeModifiers(type_)
	include := TypeFlagsStringOrNumberLiteralOrUnique
	if tc.isMappedTypeWithKeyofConstraintDeclaration(type_) {
		// We have a { [P in keyof T]: X }
		tc.forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include /*stringsOnly*/, false, addMemberForKeyType)
	} else {
		tc.forEachType(tc.getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
	}
	tc.setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)

	addMemberForKeyType := func(keyType Type) {
		var propNameType Type
		if nameType {
			propNameType = tc.instantiateType(nameType, tc.appendTypeMapping(type_.mapper, typeParameter, keyType))
		} else {
			propNameType = keyType
		}
		tc.forEachType(propNameType, func(t Type) {
			return addMemberForKeyTypeWorker(keyType, t)
		})
	}

	addMemberForKeyTypeWorker := func(keyType Type, propNameType Type) {
		// If the current iteration type constituent is a string literal type, create a property.
		// Otherwise, for type string create a string index signature.
		if isTypeUsableAsPropertyName(propNameType) {
			propName := getPropertyNameFromType(propNameType)
			// String enum members from separate enums with identical values
			// are distinct types with the same property name. Make the resulting
			// property symbol's name type be the union of those enum member types.
			existingProp := members.get(propName) /* as MappedSymbol | undefined */
			if existingProp {
				existingProp.links.nameType = tc.getUnionType([]Type{existingProp.links.nameType, propNameType})
				existingProp.links.keyType = tc.getUnionType([]Type{existingProp.links.keyType, keyType})
			} else {
				var modifiersProp Symbol
				if isTypeUsableAsPropertyName(keyType) {
					modifiersProp = tc.getPropertyOfType(modifiersType, getPropertyNameFromType(keyType))
				} else {
					modifiersProp = nil
				}
				isOptional := !!(templateModifiers&MappedTypeModifiersIncludeOptional || !(templateModifiers&MappedTypeModifiersExcludeOptional) && modifiersProp && modifiersProp.flags&SymbolFlagsOptional)
				isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersProp && tc.isReadonlySymbol(modifiersProp))
				stripOptional := tc.strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags&SymbolFlagsOptional
				var lateFlag CheckFlags
				if modifiersProp {
					lateFlag = tc.getIsLateCheckFlag(modifiersProp)
				} else {
					lateFlag = 0
				}
				prop := tc.createSymbol(SymbolFlagsProperty|(__COND__(isOptional, SymbolFlagsOptional, 0)), propName, lateFlag|CheckFlagsMapped|(__COND__(isReadonly, CheckFlagsReadonly, 0))|(__COND__(stripOptional, CheckFlagsStripOptional, 0))) /* as MappedSymbol */
				prop.links.mappedType = type_
				prop.links.nameType = propNameType
				prop.links.keyType = keyType
				if modifiersProp {
					prop.links.syntheticOrigin = modifiersProp
					if shouldLinkPropDeclarations {
						prop.declarations = modifiersProp.declarations
					} else {
						prop.declarations = nil
					}
				}
				members.set(propName, prop)
			}
		} else if tc.isValidIndexKeyType(propNameType) || propNameType.flags&(TypeFlagsAny|TypeFlagsEnum) {
			var indexKeyType Type
			switch {
			case propNameType.flags & (TypeFlagsAny | TypeFlagsString):
				indexKeyType = tc.stringType
			case propNameType.flags & (TypeFlagsNumber | TypeFlagsEnum):
				indexKeyType = tc.numberType
			default:
				indexKeyType = propNameType
			}
			propType := tc.instantiateType(templateType, tc.appendTypeMapping(type_.mapper, typeParameter, keyType))
			modifiersIndexInfo := tc.getApplicableIndexInfo(modifiersType, propNameType)
			isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersIndexInfo. /* ? */ isReadonly)
			indexInfo := tc.createIndexInfo(indexKeyType, propType, isReadonly)
			indexInfos = tc.appendIndexInfo(indexInfos, indexInfo /*union*/, true)
		}
	}

}

func (tc *TypeChecker) getTypeOfMappedSymbol(symbol MappedSymbol) Type {
	if !symbol.links.type_ {
		mappedType := symbol.links.mappedType
		if !tc.pushTypeResolution(symbol, TypeSystemPropertyNameType) {
			mappedType.containsError = true
			return tc.errorType
		}
		templateType := tc.getTemplateTypeFromMappedType(mappedType.target /* as MappedType */ || mappedType)
		mapper := tc.appendTypeMapping(mappedType.mapper, tc.getTypeParameterFromMappedType(mappedType), symbol.links.keyType)
		propType := tc.instantiateType(templateType, mapper)
		// When creating an optional property in strictNullChecks mode, if 'undefined' isn't assignable to the
		// type, we include 'undefined' in the type. Similarly, when creating a non-optional property in strictNullChecks
		// mode, if the underlying property is optional we remove 'undefined' from the type.
		var type_ Type
		switch {
		case tc.strictNullChecks && symbol.flags&SymbolFlagsOptional && !tc.maybeTypeOfKind(propType, TypeFlagsUndefined|TypeFlagsVoid):
			type_ = tc.getOptionalType(propType /*isProperty*/, true)
		case symbol.links.checkFlags & CheckFlagsStripOptional:
			type_ = tc.removeMissingOrUndefinedType(propType)
		default:
			type_ = propType
		}
		if !tc.popTypeResolution() {
			tc.error(tc.currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, tc.symbolToString(symbol), tc.typeToString(mappedType))
			type_ = tc.errorType
		}
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: symbol.links.type ??= type */ TODO
	}
	return symbol.links.type_
}

func (tc *TypeChecker) getTypeParameterFromMappedType(type_ MappedType) TypeParameter {
	return type_.typeParameter || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)) */ TODO)
}

func (tc *TypeChecker) getConstraintTypeFromMappedType(type_ MappedType) Type {
	return type_.constraintType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType */ TODO)
}

func (tc *TypeChecker) getNameTypeFromMappedType(type_ MappedType) Type {
	if type_.declaration.nameType {
		return type_.nameType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper) */ TODO)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getTemplateTypeFromMappedType(type_ MappedType) Type {
	return type_.templateType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.templateType = type.declaration.type ? instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty* / true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) : errorType */ TODO)
}

func (tc *TypeChecker) getConstraintDeclarationForMappedType(type_ MappedType) *TypeNode {
	return getEffectiveConstraintOfTypeParameter(type_.declaration.typeParameter)
}

func (tc *TypeChecker) isMappedTypeWithKeyofConstraintDeclaration(type_ MappedType) bool {
	constraintDeclaration := tc.getConstraintDeclarationForMappedType(type_)
	// TODO: GH#18217
	return constraintDeclaration.kind == SyntaxKindTypeOperator && (constraintDeclaration /* as TypeOperatorNode */).operator == SyntaxKindKeyOfKeyword
}

func (tc *TypeChecker) getModifiersTypeFromMappedType(type_ MappedType) Type {
	if !type_.modifiersType {
		if tc.isMappedTypeWithKeyofConstraintDeclaration(type_) {
			// If the constraint declaration is a 'keyof T' node, the modifiers type is T. We check
			// AST nodes here because, when T is a non-generic type, the logic below eagerly resolves
			// 'keyof T' to a literal union type and we can't recover T from that type.
			type_.modifiersType = tc.instantiateType(tc.getTypeFromTypeNode((tc.getConstraintDeclarationForMappedType(type_) /* as TypeOperatorNode */).type_), type_.mapper)
		} else {
			// Otherwise, get the declared constraint type, and if the constraint type is a type parameter,
			// get the constraint of that type parameter. If the resulting type is an indexed type 'keyof T',
			// the modifiers type is T. Otherwise, the modifiers type is unknown.
			declaredType := tc.getTypeFromMappedTypeNode(type_.declaration) /* as MappedType */
			constraint := tc.getConstraintTypeFromMappedType(declaredType)
			var extendedConstraint Type
			if constraint && constraint.flags&TypeFlagsTypeParameter {
				extendedConstraint = tc.getConstraintOfTypeParameter(constraint /* as TypeParameter */)
			} else {
				extendedConstraint = constraint
			}
			if extendedConstraint && extendedConstraint.flags&TypeFlagsIndex {
				type_.modifiersType = tc.instantiateType((extendedConstraint /* as IndexType */).type_, type_.mapper)
			} else {
				type_.modifiersType = tc.unknownType
			}
		}
	}
	return type_.modifiersType
}

func (tc *TypeChecker) getMappedTypeModifiers(type_ MappedType) MappedTypeModifiers {
	declaration := type_.declaration
	return (__COND__(declaration.readonlyToken, __COND__(declaration.readonlyToken.kind == SyntaxKindMinusToken, MappedTypeModifiersExcludeReadonly, MappedTypeModifiersIncludeReadonly), 0)) | (__COND__(declaration.questionToken, __COND__(declaration.questionToken.kind == SyntaxKindMinusToken, MappedTypeModifiersExcludeOptional, MappedTypeModifiersIncludeOptional), 0))
}

// Return -1, 0, or 1, where -1 means optionality is stripped (i.e. -?), 0 means optionality is unchanged, and 1 means
// optionality is added (i.e. +?).
func (tc *TypeChecker) getMappedTypeOptionality(type_ MappedType) number {
	modifiers := tc.getMappedTypeModifiers(type_)
	switch {
	case modifiers & MappedTypeModifiersExcludeOptional:
		return -1
	case modifiers & MappedTypeModifiersIncludeOptional:
		return 1
	default:
		return 0
	}
}

// Return -1, 0, or 1, for stripped, unchanged, or added optionality respectively. When a homomorphic mapped type doesn't
// modify optionality, recursively consult the optionality of the type being mapped over to see if it strips or adds optionality.
// For intersections, return -1 or 1 when all constituents strip or add optionality, otherwise return 0.
func (tc *TypeChecker) getCombinedMappedTypeOptionality(type_ Type) number {
	if getObjectFlags(type_) & ObjectFlagsMapped {
		return tc.getMappedTypeOptionality(type_ /* as MappedType */) || tc.getCombinedMappedTypeOptionality(tc.getModifiersTypeFromMappedType(type_ /* as MappedType */))
	}
	if type_.flags & TypeFlagsIntersection {
		optionality := tc.getCombinedMappedTypeOptionality((type_ /* as IntersectionType */).types[0])
		if every((type_ /* as IntersectionType */).types, func(t Type, i number) bool {
			return i == 0 || tc.getCombinedMappedTypeOptionality(t) == optionality
		}) {
			return optionality
		} else {
			return 0
		}
	}
	return 0
}

func (tc *TypeChecker) isPartialMappedType(type_ Type) bool {
	return !!(getObjectFlags(type_)&ObjectFlagsMapped && tc.getMappedTypeModifiers(type_ /* as MappedType */)&MappedTypeModifiersIncludeOptional)
}

func (tc *TypeChecker) isGenericMappedType(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is MappedType */ any {
	if getObjectFlags(type_) & ObjectFlagsMapped {
		constraint := tc.getConstraintTypeFromMappedType(type_ /* as MappedType */)
		if tc.isGenericIndexType(constraint) {
			return true
		}
		// A mapped type is generic if the 'as' clause references generic types other than the iteration type.
		// To determine this, we substitute the constraint type (that we now know isn't generic) for the iteration
		// type and check whether the resulting type is generic.
		nameType := tc.getNameTypeFromMappedType(type_ /* as MappedType */)
		if nameType && tc.isGenericIndexType(tc.instantiateType(nameType, tc.makeUnaryTypeMapper(tc.getTypeParameterFromMappedType(type_ /* as MappedType */), constraint))) {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) getMappedTypeNameTypeKind(type_ MappedType) MappedTypeNameTypeKind {
	nameType := tc.getNameTypeFromMappedType(type_)
	if !nameType {
		return MappedTypeNameTypeKindNone
	}
	if tc.isTypeAssignableTo(nameType, tc.getTypeParameterFromMappedType(type_)) {
		return MappedTypeNameTypeKindFiltering
	} else {
		return MappedTypeNameTypeKindRemapping
	}
}

func (tc *TypeChecker) resolveStructuredTypeMembers(type_ StructuredType) ResolvedType {
	if !(type_ /* as ResolvedType */).members {
		if type_.flags & TypeFlagsObject {
			if (type_ /* as ObjectType */).objectFlags & ObjectFlagsReference {
				tc.resolveTypeReferenceMembers(type_ /* as TypeReference */)
			} else if (type_ /* as ObjectType */).objectFlags & ObjectFlagsClassOrInterface {
				tc.resolveClassOrInterfaceMembers(type_ /* as InterfaceType */)
			} else if (type_ /* as ReverseMappedType */).objectFlags & ObjectFlagsReverseMapped {
				tc.resolveReverseMappedTypeMembers(type_ /* as ReverseMappedType */)
			} else if (type_ /* as ObjectType */).objectFlags & ObjectFlagsAnonymous {
				tc.resolveAnonymousTypeMembers(type_ /* as AnonymousType */)
			} else if (type_ /* as MappedType */).objectFlags & ObjectFlagsMapped {
				tc.resolveMappedTypeMembers(type_ /* as MappedType */)
			} else {
				Debug.fail("Unhandled object type " + Debug.formatObjectFlags(type_.objectFlags))
			}
		} else if type_.flags & TypeFlagsUnion {
			tc.resolveUnionTypeMembers(type_ /* as UnionType */)
		} else if type_.flags & TypeFlagsIntersection {
			tc.resolveIntersectionTypeMembers(type_ /* as IntersectionType */)
		} else {
			Debug.fail("Unhandled type " + Debug.formatTypeFlags(type_.flags))
		}
	}
	return type_ /* as ResolvedType */
}

/** Return properties of an object type or an empty array for other types */

func (tc *TypeChecker) getPropertiesOfObjectType(type_ Type) []Symbol {
	if type_.flags & TypeFlagsObject {
		return tc.resolveStructuredTypeMembers(type_ /* as ObjectType */).properties
	}
	return emptyArray
}

/** If the given type is an object type and that type has a property by the given name,
 * return the symbol for that property. Otherwise return undefined.
 */

func (tc *TypeChecker) getPropertyOfObjectType(type_ Type, name __String) Symbol {
	if type_.flags & TypeFlagsObject {
		resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		symbol := resolved.members.get(name)
		if symbol && tc.symbolIsValue(symbol) {
			return symbol
		}
	}
}

func (tc *TypeChecker) getPropertiesOfUnionOrIntersectionType(type_ UnionOrIntersectionType) []Symbol {
	if !type_.resolvedProperties {
		members := createSymbolTable()
		for _, current := range type_.types {
			for _, prop := range tc.getPropertiesOfType(current) {
				if !members.has(prop.escapedName) {
					combinedProp := tc.getPropertyOfUnionOrIntersectionType(type_, prop.escapedName /*skipObjectFunctionPropertyAugment*/, !!(type_.flags & TypeFlagsIntersection))
					if combinedProp {
						members.set(prop.escapedName, combinedProp)
					}
				}
			}
			// The properties of a union type are those that are present in all constituent types, so
			// we only need to check the properties of the first type without index signature
			if type_.flags&TypeFlagsUnion && tc.getIndexInfosOfType(current).length == 0 {
				break
			}
		}
		type_.resolvedProperties = tc.getNamedMembers(members)
	}
	return type_.resolvedProperties
}

func (tc *TypeChecker) getPropertiesOfType(type_ Type) []Symbol {
	type_ = tc.getReducedApparentType(type_)
	if type_.flags & TypeFlagsUnionOrIntersection {
		return tc.getPropertiesOfUnionOrIntersectionType(type_ /* as UnionType */)
	} else {
		return tc.getPropertiesOfObjectType(type_)
	}
}

func (tc *TypeChecker) forEachPropertyOfType(type_ Type, action func(symbol Symbol, escapedName __String)) {
	type_ = tc.getReducedApparentType(type_)
	if type_.flags & TypeFlagsStructuredType {
		tc.resolveStructuredTypeMembers(type_ /* as StructuredType */).members.forEach(func(symbol Symbol, escapedName __String) {
			if tc.isNamedMember(symbol, escapedName) {
				action(symbol, escapedName)
			}
		})
	}
}

func (tc *TypeChecker) isTypeInvalidDueToUnionDiscriminant(contextualType Type, obj /* TODO(TS-TO-GO) TypeNode UnionType: ObjectLiteralExpression | JsxAttributes */ any) bool {
	list := obj.properties /* as NodeArray<ObjectLiteralElementLike | JsxAttributeLike> */
	return list.some(func(property /* TODO(TS-TO-GO) inferred type ObjectLiteralElementLike | JsxAttributeLike */ any) bool {
		nameType := property.name && (__COND__(isJsxNamespacedName(property.name), tc.getStringLiteralType(getTextOfJsxAttributeName(property.name)), tc.getLiteralTypeFromPropertyName(property.name)))
		var name *__String
		if nameType && isTypeUsableAsPropertyName(nameType) {
			name = getPropertyNameFromType(nameType)
		} else {
			name = nil
		}
		var expected Type
		if name == nil {
			expected = nil
		} else {
			expected = tc.getTypeOfPropertyOfType(contextualType, name)
		}
		return !!expected && tc.isLiteralType(expected) && !tc.isTypeAssignableTo(tc.getTypeOfNode(property), expected)
	})
}

func (tc *TypeChecker) getAllPossiblePropertiesOfTypes(types []Type) []Symbol {
	unionType := tc.getUnionType(types)
	if !(unionType.flags & TypeFlagsUnion) {
		return tc.getAugmentedPropertiesOfType(unionType)
	}

	props := createSymbolTable()
	for _, memberType := range types {
		for _, TODO_IDENTIFIER := range tc.getAugmentedPropertiesOfType(memberType) {
			if !props.has(escapedName) {
				prop := tc.createUnionOrIntersectionProperty(unionType /* as UnionType */, escapedName)
				// May be undefined if the property is private
				if prop {
					props.set(escapedName, prop)
				}
			}
		}
	}
	return arrayFrom(props.values())
}

func (tc *TypeChecker) getConstraintOfType(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any) Type {
	switch {
	case type_.flags & TypeFlagsTypeParameter:
		return tc.getConstraintOfTypeParameter(type_ /* as TypeParameter */)
	case type_.flags & TypeFlagsIndexedAccess:
		return tc.getConstraintOfIndexedAccess(type_ /* as IndexedAccessType */)
	case type_.flags & TypeFlagsConditional:
		return tc.getConstraintOfConditionalType(type_ /* as ConditionalType */)
	default:
		return tc.getBaseConstraintOfType(type_)
	}
}

func (tc *TypeChecker) getConstraintOfTypeParameter(typeParameter TypeParameter) Type {
	if tc.hasNonCircularBaseConstraint(typeParameter) {
		return tc.getConstraintFromTypeParameter(typeParameter)
	} else {
		return nil
	}
}

func (tc *TypeChecker) isConstMappedType(type_ MappedType, depth number) bool {
	typeVariable := tc.getHomomorphicTypeVariable(type_)
	return !!typeVariable && tc.isConstTypeVariable(typeVariable, depth)
}

func (tc *TypeChecker) isConstTypeVariable(type_ Type, depth number /*  = 0 */) bool {
	return depth < 5 && !!(type_ && (type_.flags&TypeFlagsTypeParameter && some((type_ /* as TypeParameter */).symbol. /* ? */ declarations, func(d Declaration) bool {
		return hasSyntacticModifier(d, ModifierFlagsConst)
	}) || type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as UnionOrIntersectionType */).types, func(t Type) bool {
		return tc.isConstTypeVariable(t, depth)
	}) || type_.flags&TypeFlagsIndexedAccess && tc.isConstTypeVariable((type_ /* as IndexedAccessType */).objectType, depth+1) || type_.flags&TypeFlagsConditional && tc.isConstTypeVariable(tc.getConstraintOfConditionalType(type_ /* as ConditionalType */), depth+1) || type_.flags&TypeFlagsSubstitution && tc.isConstTypeVariable((type_ /* as SubstitutionType */).baseType, depth) || getObjectFlags(type_)&ObjectFlagsMapped && tc.isConstMappedType(type_ /* as MappedType */, depth) || tc.isGenericTupleType(type_) && findIndex(tc.getElementTypes(type_), func(t Type, i number) bool {
		return !!(type_.target.elementFlags[i] & ElementFlagsVariadic) && tc.isConstTypeVariable(t, depth)
	}) >= 0))
}

func (tc *TypeChecker) getConstraintOfIndexedAccess(type_ IndexedAccessType) Type {
	if tc.hasNonCircularBaseConstraint(type_) {
		return tc.getConstraintFromIndexedAccess(type_)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getSimplifiedTypeOrConstraint(type_ Type) Type {
	simplified := tc.getSimplifiedType(type_ /*writing*/, false)
	if simplified != type_ {
		return simplified
	} else {
		return tc.getConstraintOfType(type_)
	}
}

func (tc *TypeChecker) getConstraintFromIndexedAccess(type_ IndexedAccessType) Type {
	if tc.isMappedTypeGenericIndexedAccess(type_) {
		// For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
		// we substitute an instantiation of E where P is replaced with X.
		return tc.substituteIndexedMappedType(type_.objectType /* as MappedType */, type_.indexType)
	}
	indexConstraint := tc.getSimplifiedTypeOrConstraint(type_.indexType)
	if indexConstraint && indexConstraint != type_.indexType {
		indexedAccess := tc.getIndexedAccessTypeOrUndefined(type_.objectType, indexConstraint, type_.accessFlags)
		if indexedAccess {
			return indexedAccess
		}
	}
	objectConstraint := tc.getSimplifiedTypeOrConstraint(type_.objectType)
	if objectConstraint && objectConstraint != type_.objectType {
		return tc.getIndexedAccessTypeOrUndefined(objectConstraint, type_.indexType, type_.accessFlags)
	}
	return nil
}

func (tc *TypeChecker) getDefaultConstraintOfConditionalType(type_ ConditionalType) Type {
	if !type_.resolvedDefaultConstraint {
		// An `any` branch of a conditional type would normally be viral - specifically, without special handling here,
		// a conditional type with a single branch of type `any` would be assignable to anything, since it's constraint would simplify to
		// just `any`. This result is _usually_ unwanted - so instead here we elide an `any` branch from the constraint type,
		// in effect treating `any` like `never` rather than `unknown` in this location.
		trueConstraint := tc.getInferredTrueTypeFromConditionalType(type_)
		falseConstraint := tc.getFalseTypeFromConditionalType(type_)
		switch {
		case tc.isTypeAny(trueConstraint):
			type_.resolvedDefaultConstraint = falseConstraint
		case tc.isTypeAny(falseConstraint):
			type_.resolvedDefaultConstraint = trueConstraint
		default:
			type_.resolvedDefaultConstraint = tc.getUnionType([]Type{trueConstraint, falseConstraint})
		}
	}
	return type_.resolvedDefaultConstraint
}

func (tc *TypeChecker) getConstraintOfDistributiveConditionalType(type_ ConditionalType) Type {
	if type_.resolvedConstraintOfDistributive != nil {
		return type_.resolvedConstraintOfDistributive || nil
	}

	// Check if we have a conditional type of the form 'T extends U ? X : Y', where T is a constrained
	// type parameter. If so, create an instantiation of the conditional type where T is replaced
	// with its constraint. We do this because if the constraint is a union type it will be distributed
	// over the conditional type and possibly reduced. For example, 'T extends undefined ? never : T'
	// removes 'undefined' from T.
	// We skip returning a distributive constraint for a restrictive instantiation of a conditional type
	// as the constraint for all type params (check type included) have been replace with `unknown`, which
	// is going to produce even more false positive/negative results than the distribute constraint already does.
	// Please note: the distributive constraint is a kludge for emulating what a negated type could to do filter
	// a union - once negated types exist and are applied to the conditional false branch, this "constraint"
	// likely doesn't need to exist.
	if type_.root.isDistributive && type_.restrictiveInstantiation != type_ {
		simplified := tc.getSimplifiedType(type_.checkType /*writing*/, false)
		var constraint Type
		if simplified == type_.checkType {
			constraint = tc.getConstraintOfType(simplified)
		} else {
			constraint = simplified
		}
		if constraint && constraint != type_.checkType {
			instantiated := tc.getConditionalTypeInstantiation(type_, tc.prependTypeMapping(type_.root.checkType, constraint, type_.mapper) /*forConstraint*/, true)
			if !(instantiated.flags & TypeFlagsNever) {
				type_.resolvedConstraintOfDistributive = instantiated
				return instantiated
			}
		}
	}
	type_.resolvedConstraintOfDistributive = false
	return nil
}

func (tc *TypeChecker) getConstraintFromConditionalType(type_ ConditionalType) Type {
	return tc.getConstraintOfDistributiveConditionalType(type_) || tc.getDefaultConstraintOfConditionalType(type_)
}

func (tc *TypeChecker) getConstraintOfConditionalType(type_ ConditionalType) Type {
	if tc.hasNonCircularBaseConstraint(type_) {
		return tc.getConstraintFromConditionalType(type_)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getEffectiveConstraintOfIntersection(types []Type, targetIsUnion bool) Type {
	var constraints *[]Type
	hasDisjointDomainType := false
	for _, t := range types {
		if t.flags & TypeFlagsInstantiable {
			// We keep following constraints as long as we have an instantiable type that is known
			// not to be circular or infinite (hence we stop on index access types).
			constraint := tc.getConstraintOfType(t)
			for constraint && constraint.flags&(TypeFlagsTypeParameter|TypeFlagsIndex|TypeFlagsConditional) {
				constraint = tc.getConstraintOfType(constraint)
			}
			if constraint {
				constraints = append(constraints, constraint)
				if targetIsUnion {
					constraints = append(constraints, t)
				}
			}
		} else if t.flags&TypeFlagsDisjointDomains || tc.isEmptyAnonymousObjectType(t) {
			hasDisjointDomainType = true
		}
	}
	// If the target is a union type or if we are intersecting with types belonging to one of the
	// disjoint domains, we may end up producing a constraint that hasn't been examined before.
	if constraints && (targetIsUnion || hasDisjointDomainType) {
		if hasDisjointDomainType {
			// We add any types belong to one of the disjoint domains because they might cause the final
			// intersection operation to reduce the union constraints.
			for _, t := range types {
				if t.flags&TypeFlagsDisjointDomains || tc.isEmptyAnonymousObjectType(t) {
					constraints = append(constraints, t)
				}
			}
		}
		// The source types were normalized; ensure the result is normalized too.
		return tc.getNormalizedType(tc.getIntersectionType(constraints, IntersectionFlagsNoConstraintReduction) /*writing*/, false)
	}
	return nil
}

func (tc *TypeChecker) getBaseConstraintOfType(type_ Type) Type {
	if type_.flags&(TypeFlagsInstantiableNonPrimitive|TypeFlagsUnionOrIntersection|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || tc.isGenericTupleType(type_) {
		constraint := tc.getResolvedBaseConstraint(type_ /* as InstantiableType | UnionOrIntersectionType */)
		if constraint != tc.noConstraintType && constraint != tc.circularConstraintType {
			return constraint
		} else {
			return nil
		}
	}
	if type_.flags & TypeFlagsIndex {
		return tc.stringNumberSymbolType
	} else {
		return nil
	}
}

/**
 * This is similar to `getBaseConstraintOfType` except it returns the input type if there's no base constraint, instead of `undefined`
 * It also doesn't map indexes to `string`, as where this is used this would be unneeded (and likely undesirable)
 */

func (tc *TypeChecker) getBaseConstraintOrType(type_ Type) Type {
	return tc.getBaseConstraintOfType(type_) || type_
}

func (tc *TypeChecker) hasNonCircularBaseConstraint(type_ InstantiableType) bool {
	return tc.getResolvedBaseConstraint(type_) != tc.circularConstraintType
}

/**
 * Return the resolved base constraint of a type variable. The noConstraintType singleton is returned if the
 * type variable has no constraint, and the circularConstraintType singleton is returned if the constraint
 * circularly references the type variable.
 */

func (tc *TypeChecker) getResolvedBaseConstraint(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any) Type {
	if type_.resolvedBaseConstraint {
		return type_.resolvedBaseConstraint
	}
	var stack []any = []never{}
	type_.resolvedBaseConstraint = getImmediateBaseConstraint(type_)
	return type_.resolvedBaseConstraint

	getImmediateBaseConstraint := func(t Type) Type {
		if !t.immediateBaseConstraint {
			if !tc.pushTypeResolution(t, TypeSystemPropertyNameImmediateBaseConstraint) {
				return tc.circularConstraintType
			}
			var result TODO
			// We always explore at least 10 levels of nested constraints. Thereafter, we continue to explore
			// up to 50 levels of nested constraints provided there are no "deeply nested" types on the stack
			// (i.e. no types for which five instantiations have been recorded on the stack). If we reach 50
			// levels of nesting, we are presumably exploring a repeating pattern with a long cycle that hasn't
			// yet triggered the deeply nested limiter. We have no test cases that actually get to 50 levels of
			// nesting, so it is effectively just a safety stop.
			identity := tc.getRecursionIdentity(t)
			if stack.length < 10 || stack.length < 50 && !contains(stack, identity) {
				stack.push(identity)
				result = computeBaseConstraint(tc.getSimplifiedType(t /*writing*/, false))
				stack.pop()
			}
			if !tc.popTypeResolution() {
				if t.flags & TypeFlagsTypeParameter {
					errorNode := tc.getConstraintDeclaration(t /* as TypeParameter */)
					if errorNode {
						diagnostic := tc.error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, tc.typeToString(t))
						if tc.currentNode && !isNodeDescendantOf(errorNode, tc.currentNode) && !isNodeDescendantOf(tc.currentNode, errorNode) {
							addRelatedInfo(diagnostic, createDiagnosticForNode(tc.currentNode, Diagnostics.Circularity_originates_in_type_at_this_location))
						}
					}
				}
				result = tc.circularConstraintType
			}
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: t.immediateBaseConstraint ??= result || noConstraintType */ TODO
		}
		return t.immediateBaseConstraint
	}

	getBaseConstraint := func(t Type) Type {
		c := getImmediateBaseConstraint(t)
		if c != tc.noConstraintType && c != tc.circularConstraintType {
			return c
		} else {
			return nil
		}
	}

	computeBaseConstraint := func(t Type) Type {
		if t.flags & TypeFlagsTypeParameter {
			constraint := tc.getConstraintFromTypeParameter(t /* as TypeParameter */)
			if (t /* as TypeParameter */).isThisType || !constraint {
				return constraint
			} else {
				return getBaseConstraint(constraint)
			}
		}
		if t.flags & TypeFlagsUnionOrIntersection {
			types := (t /* as UnionOrIntersectionType */).types
			var baseTypes []Type = []never{}
			different := false
			for _, type_ := range types {
				baseType := getBaseConstraint(type_)
				if baseType {
					if baseType != type_ {
						different = true
					}
					baseTypes.push(baseType)
				} else {
					different = true
				}
			}
			if !different {
				return t
			}
			switch {
			case t.flags&TypeFlagsUnion && baseTypes.length == types.length:
				return tc.getUnionType(baseTypes)
			case t.flags&TypeFlagsIntersection && baseTypes.length:
				return tc.getIntersectionType(baseTypes)
			default:
				return nil
			}
		}
		if t.flags & TypeFlagsIndex {
			return tc.stringNumberSymbolType
		}
		if t.flags & TypeFlagsTemplateLiteral {
			types := (t /* as TemplateLiteralType */).types
			constraints := mapDefined(types, getBaseConstraint)
			if constraints.length == types.length {
				return tc.getTemplateLiteralType((t /* as TemplateLiteralType */).texts, constraints)
			} else {
				return tc.stringType
			}
		}
		if t.flags & TypeFlagsStringMapping {
			constraint := getBaseConstraint((t /* as StringMappingType */).type_)
			if constraint && constraint != (t /* as StringMappingType */).type_ {
				return tc.getStringMappingType((t /* as StringMappingType */).symbol, constraint)
			} else {
				return tc.stringType
			}
		}
		if t.flags & TypeFlagsIndexedAccess {
			if tc.isMappedTypeGenericIndexedAccess(t) {
				// For indexed access types of the form { [P in K]: E }[X], where K is non-generic and X is generic,
				// we substitute an instantiation of E where P is replaced with X.
				return getBaseConstraint(tc.substituteIndexedMappedType((t /* as IndexedAccessType */).objectType /* as MappedType */, (t /* as IndexedAccessType */).indexType))
			}
			baseObjectType := getBaseConstraint((t /* as IndexedAccessType */).objectType)
			baseIndexType := getBaseConstraint((t /* as IndexedAccessType */).indexType)
			baseIndexedAccess := baseObjectType && baseIndexType && tc.getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t /* as IndexedAccessType */).accessFlags)
			return baseIndexedAccess && getBaseConstraint(baseIndexedAccess)
		}
		if t.flags & TypeFlagsConditional {
			constraint := tc.getConstraintFromConditionalType(t /* as ConditionalType */)
			return constraint && getBaseConstraint(constraint)
		}
		if t.flags & TypeFlagsSubstitution {
			return getBaseConstraint(tc.getSubstitutionIntersection(t /* as SubstitutionType */))
		}
		if tc.isGenericTupleType(t) {
			// We substitute constraints for variadic elements only when the constraints are array types or
			// non-variadic tuple types as we want to avoid further (possibly unbounded) recursion.
			newElements := map_(tc.getElementTypes(t), func(v Type, i number) Type {
				constraint := v.flags&TypeFlagsTypeParameter && t.target.elementFlags[i]&ElementFlagsVariadic && getBaseConstraint(v) || v
				if constraint != v && tc.everyType(constraint, func(c Type) bool {
					return tc.isArrayOrTupleType(c) && !tc.isGenericTupleType(c)
				}) {
					return constraint
				} else {
					return v
				}
			})
			return tc.createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations)
		}
		return t
	}

}

func (tc *TypeChecker) getApparentTypeOfIntersectionType(type_ IntersectionType, thisArgument Type) Type {
	if type_ == thisArgument {
		return type_.resolvedApparentType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true) */ TODO)
	}
	key := __TEMPLATE__("I", tc.getTypeId(type_), ",", tc.getTypeId(thisArgument))
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
}

func (tc *TypeChecker) getResolvedTypeParameterDefault(typeParameter TypeParameter) Type {
	if !typeParameter.default_ {
		if typeParameter.target {
			targetDefault := tc.getResolvedTypeParameterDefault(typeParameter.target)
			if targetDefault {
				typeParameter.default_ = tc.instantiateType(targetDefault, typeParameter.mapper)
			} else {
				typeParameter.default_ = tc.noConstraintType
			}
		} else {
			// To block recursion, set the initial value to the resolvingDefaultType.
			typeParameter.default_ = tc.resolvingDefaultType
			defaultDeclaration := typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl Declaration) * /* TODO(TS-TO-GO) inferred type false | TypeNode */ any {
				return isTypeParameterDeclaration(decl) && decl.default_
			})
			var defaultType Type
			if defaultDeclaration {
				defaultType = tc.getTypeFromTypeNode(defaultDeclaration)
			} else {
				defaultType = tc.noConstraintType
			}
			if typeParameter.default_ == tc.resolvingDefaultType {
				// If we have not been called recursively, set the correct default type.
				typeParameter.default_ = defaultType
			}
		}
	} else if typeParameter.default_ == tc.resolvingDefaultType {
		// If we are called recursively for this type parameter, mark the default as circular.
		typeParameter.default_ = tc.circularConstraintType
	}
	return typeParameter.default_
}

/**
 * Gets the default type for a type parameter.
 *
 * If the type parameter is the result of an instantiation, this gets the instantiated
 * default type of its target. If the type parameter has no default type or the default is
 * circular, `undefined` is returned.
 */

func (tc *TypeChecker) getDefaultFromTypeParameter(typeParameter TypeParameter) Type {
	defaultType := tc.getResolvedTypeParameterDefault(typeParameter)
	if defaultType != tc.noConstraintType && defaultType != tc.circularConstraintType {
		return defaultType
	} else {
		return nil
	}
}

func (tc *TypeChecker) hasNonCircularTypeParameterDefault(typeParameter TypeParameter) bool {
	return tc.getResolvedTypeParameterDefault(typeParameter) != tc.circularConstraintType
}

/**
 * Indicates whether the declaration of a typeParameter has a default type.
 */

func (tc *TypeChecker) hasTypeParameterDefault(typeParameter TypeParameter) bool {
	return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl Declaration) * /* TODO(TS-TO-GO) inferred type false | TypeNode */ any {
		return isTypeParameterDeclaration(decl) && decl.default_
	}))
}

func (tc *TypeChecker) getApparentTypeOfMappedType(type_ MappedType) Type {
	return type_.resolvedApparentType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type) */ TODO)
}

func (tc *TypeChecker) getResolvedApparentTypeOfMappedType(type_ MappedType) Type {
	target := ( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: type.target ?? type */ TODO) /* as MappedType */
	typeVariable := tc.getHomomorphicTypeVariable(target)
	if typeVariable && !target.declaration.nameType {
		// We have a homomorphic mapped type or an instantiation of a homomorphic mapped type, i.e. a type
		// of the form { [P in keyof T]: X }. Obtain the modifiers type (the T of the keyof T), and if it is
		// another generic mapped type, recursively obtain its apparent type. Otherwise, obtain its base
		// constraint. Then, if every constituent of the base constraint is an array or tuple type, apply
		// this mapped type to the base constraint. It is safe to recurse when the modifiers type is a
		// mapped type because we protect again circular constraints in getTypeFromMappedTypeNode.
		modifiersType := tc.getModifiersTypeFromMappedType(type_)
		var baseConstraint Type
		if tc.isGenericMappedType(modifiersType) {
			baseConstraint = tc.getApparentTypeOfMappedType(modifiersType)
		} else {
			baseConstraint = tc.getBaseConstraintOfType(modifiersType)
		}
		if baseConstraint && tc.everyType(baseConstraint, func(t Type) bool {
			return tc.isArrayOrTupleType(t) || tc.isArrayOrTupleOrIntersection(t)
		}) {
			return tc.instantiateType(target, tc.prependTypeMapping(typeVariable, baseConstraint, type_.mapper))
		}
	}
	return type_
}

func (tc *TypeChecker) isArrayOrTupleOrIntersection(type_ Type) bool {
	return !!(type_.flags & TypeFlagsIntersection) && every((type_ /* as IntersectionType */).types, tc.isArrayOrTupleType)
}

func (tc *TypeChecker) isMappedTypeGenericIndexedAccess(type_ Type) bool {
	var objectType TODO
	return !!(type_.flags&TypeFlagsIndexedAccess && getObjectFlags( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: objectType = (type as IndexedAccessType).objectType */ TODO)&ObjectFlagsMapped && !tc.isGenericMappedType(objectType) && tc.isGenericIndexType((type_ /* as IndexedAccessType */).indexType) && !(tc.getMappedTypeModifiers(objectType /* as MappedType */) & MappedTypeModifiersExcludeOptional) && !(objectType /* as MappedType */).declaration.nameType)
}

/**
 * For a type parameter, return the base constraint of the type parameter. For the string, number,
 * boolean, and symbol primitive types, return the corresponding object types. Otherwise return the
 * type itself.
 */

func (tc *TypeChecker) getApparentType(type_ Type) Type {
	var t Type
	if type_.flags & TypeFlagsInstantiable {
		t = tc.getBaseConstraintOfType(type_) || tc.unknownType
	} else {
		t = type_
	}
	objectFlags := getObjectFlags(t)
	switch {
	case objectFlags & ObjectFlagsMapped:
		return tc.getApparentTypeOfMappedType(t /* as MappedType */)
	case objectFlags&ObjectFlagsReference && t != type_:
		return tc.getTypeWithThisArgument(t, type_)
	case t.flags & TypeFlagsIntersection:
		return tc.getApparentTypeOfIntersectionType(t /* as IntersectionType */, type_)
	case t.flags & TypeFlagsStringLike:
		return tc.globalStringType
	case t.flags & TypeFlagsNumberLike:
		return tc.globalNumberType
	case t.flags & TypeFlagsBigIntLike:
		return tc.getGlobalBigIntType()
	case t.flags & TypeFlagsBooleanLike:
		return tc.globalBooleanType
	case t.flags & TypeFlagsESSymbolLike:
		return tc.getGlobalESSymbolType()
	case t.flags & TypeFlagsNonPrimitive:
		return tc.emptyObjectType
	case t.flags & TypeFlagsIndex:
		return tc.stringNumberSymbolType
	case t.flags&TypeFlagsUnknown && !tc.strictNullChecks:
		return tc.emptyObjectType
	default:
		return t
	}
}

func (tc *TypeChecker) getReducedApparentType(type_ Type) Type {
	// Since getApparentType may return a non-reduced union or intersection type, we need to perform
	// type reduction both before and after obtaining the apparent type. For example, given a type parameter
	// 'T extends A | B', the type 'T & X' becomes 'A & X | B & X' after obtaining the apparent type, and
	// that type may need further reduction to remove empty intersections.
	return tc.getReducedType(tc.getApparentType(tc.getReducedType(type_)))
}

func (tc *TypeChecker) createUnionOrIntersectionProperty(containingType UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) Symbol {
	var singleProp Symbol
	var propSet *Map[SymbolId, Symbol]
	var indexTypes *[]Type
	isUnion := containingType.flags & TypeFlagsUnion
	// Flags we want to propagate to the result if they exist in all source symbols
	var optionalFlag *SymbolFlags
	syntheticFlag := CheckFlagsSyntheticMethod
	var checkFlags number
	if isUnion {
		checkFlags = 0
	} else {
		checkFlags = CheckFlagsReadonly
	}
	mergedInstantiations := false
	for _, current := range containingType.types {
		type_ := tc.getApparentType(current)
		if !(tc.isErrorType(type_) || type_.flags&TypeFlagsNever) {
			prop := tc.getPropertyOfType(type_, name, skipObjectFunctionPropertyAugment)
			var modifiers /* TODO(TS-TO-GO) inferred type 0 | ModifierFlags */ any
			if prop {
				modifiers = getDeclarationModifierFlagsFromSymbol(prop)
			} else {
				modifiers = 0
			}
			if prop {
				if prop.flags & SymbolFlagsClassMember {
					/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional */ TODO
					if isUnion {
						optionalFlag |= prop.flags & SymbolFlagsOptional
					} else {
						optionalFlag &= prop.flags
					}
				}
				if !singleProp {
					singleProp = prop
				} else if prop != singleProp {
					isInstantiation := (tc.getTargetSymbol(prop) || prop) == (tc.getTargetSymbol(singleProp) || singleProp)
					// If the symbols are instances of one another with identical types - consider the symbols
					// equivalent and just use the first one, which thus allows us to avoid eliding private
					// members when intersecting a (this-)instantiations of a class with its raw base or another instance
					if isInstantiation && tc.compareProperties(singleProp, prop, func(a Type, b Type) /* TODO(TS-TO-GO) inferred type Ternary.False | Ternary.True */ any {
						if a == b {
							return TernaryTrue
						} else {
							return TernaryFalse
						}
					}) == TernaryTrue {
						// If we merged instantiations of a generic type, we replicate the symbol parent resetting behavior we used
						// to do when we recorded multiple distinct symbols so that we still get, eg, `Array<T>.length` printed
						// back and not `Array<string>.length` when we're looking at a `.length` access on a `string[] | number[]`
						mergedInstantiations = !!singleProp.parent && !!length(tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent))
					} else {
						if !propSet {
							propSet = NewMap[SymbolId, Symbol]()
							propSet.set(getSymbolId(singleProp), singleProp)
						}
						id := getSymbolId(prop)
						if !propSet.has(id) {
							propSet.set(id, prop)
						}
					}
				}
				if isUnion && tc.isReadonlySymbol(prop) {
					checkFlags |= CheckFlagsReadonly
				} else if !isUnion && !tc.isReadonlySymbol(prop) {
					checkFlags &= ~CheckFlagsReadonly
				}
				checkFlags |= (__COND__(!(modifiers & ModifierFlagsNonPublicAccessibilityModifier), CheckFlagsContainsPublic, 0)) | (__COND__(modifiers&ModifierFlagsProtected, CheckFlagsContainsProtected, 0)) | (__COND__(modifiers&ModifierFlagsPrivate, CheckFlagsContainsPrivate, 0)) | (__COND__(modifiers&ModifierFlagsStatic, CheckFlagsContainsStatic, 0))
				if !tc.isPrototypeProperty(prop) {
					syntheticFlag = CheckFlagsSyntheticProperty
				}
			} else if isUnion {
				indexInfo := !tc.isLateBoundName(name) && tc.getApplicableIndexInfoForName(type_, name)
				if indexInfo {
					checkFlags |= CheckFlagsWritePartial | (__COND__(indexInfo.isReadonly, CheckFlagsReadonly, 0))
					indexTypes = append(indexTypes, __COND__(tc.isTupleType(type_), tc.getRestTypeOfTupleType(type_) || tc.undefinedType, indexInfo.type_))
				} else if tc.isObjectLiteralType(type_) && !(getObjectFlags(type_) & ObjectFlagsContainsSpread) {
					checkFlags |= CheckFlagsWritePartial
					indexTypes = append(indexTypes, tc.undefinedType)
				} else {
					checkFlags |= CheckFlagsReadPartial
				}
			}
		}
	}
	if !singleProp || isUnion && (propSet || checkFlags&CheckFlagsPartial) && checkFlags&(CheckFlagsContainsPrivate|CheckFlagsContainsProtected) && !(propSet && tc.getCommonDeclarationsOfSymbols(propSet.values())) {
		// No property was found, or, in a union, a property has a private or protected declaration in one
		// constituent, but is missing or has a different declaration in another constituent.
		return nil
	}
	if !propSet && !(checkFlags & CheckFlagsReadPartial) && !indexTypes {
		if mergedInstantiations {
			// No symbol from a union/intersection should have a `.parent` set (since unions/intersections don't act as symbol parents)
			// Unless that parent is "reconstituted" from the "first value declaration" on the symbol (which is likely different than its instantiated parent!)
			// They also have a `.containingType` set, which affects some services endpoints behavior, like `getRootSymbol`
			links := tryCast(singleProp, isTransientSymbol). /* ? */ links
			clone := tc.createSymbolWithType(singleProp, links. /* ? */ type_)
			clone.parent = singleProp.valueDeclaration. /* ? */ symbol. /* ? */ parent
			clone.links.containingType = containingType
			clone.links.mapper = links. /* ? */ mapper
			clone.links.writeType = tc.getWriteTypeOfSymbol(singleProp)
			return clone
		} else {
			return singleProp
		}
	}
	var props []Symbol
	if propSet {
		props = arrayFrom(propSet.values())
	} else {
		props = []Symbol{singleProp}
	}
	var declarations *[]Declaration
	var firstType Type
	var nameType Type
	var propTypes []Type = []never{}
	var writeTypes *[]Type
	var firstValueDeclaration Declaration
	hasNonUniformValueDeclaration := false
	for _, prop := range props {
		if !firstValueDeclaration {
			firstValueDeclaration = prop.valueDeclaration
		} else if prop.valueDeclaration && prop.valueDeclaration != firstValueDeclaration {
			hasNonUniformValueDeclaration = true
		}
		declarations = addRange(declarations, prop.declarations)
		type_ := tc.getTypeOfSymbol(prop)
		if !firstType {
			firstType = type_
			nameType = tc.getSymbolLinks(prop).nameType
		}
		writeType := tc.getWriteTypeOfSymbol(prop)
		if writeTypes || writeType != type_ {
			writeTypes = append(__COND__(!writeTypes, propTypes.slice(), writeTypes), writeType)
		}
		if type_ != firstType {
			checkFlags |= CheckFlagsHasNonUniformType
		}
		if tc.isLiteralType(type_) || tc.isPatternLiteralType(type_) {
			checkFlags |= CheckFlagsHasLiteralType
		}
		if type_.flags&TypeFlagsNever && type_ != tc.uniqueLiteralType {
			checkFlags |= CheckFlagsHasNeverType
		}
		propTypes.push(type_)
	}
	addRange(propTypes, indexTypes)
	result := tc.createSymbol(SymbolFlagsProperty|( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: optionalFlag ?? 0 */ TODO), name, syntheticFlag|checkFlags)
	result.links.containingType = containingType
	if !hasNonUniformValueDeclaration && firstValueDeclaration {
		result.valueDeclaration = firstValueDeclaration

		// Inherit information about parent type.
		if firstValueDeclaration.symbol.parent {
			result.parent = firstValueDeclaration.symbol.parent
		}
	}

	result.declarations = declarations
	result.links.nameType = nameType
	if propTypes.length > 2 {
		// When `propTypes` has the potential to explode in size when normalized, defer normalization until absolutely needed
		result.links.checkFlags |= CheckFlagsDeferredType
		result.links.deferralParent = containingType
		result.links.deferralConstituents = propTypes
		result.links.deferralWriteConstituents = writeTypes
	} else {
		if isUnion {
			result.links.type_ = tc.getUnionType(propTypes)
		} else {
			result.links.type_ = tc.getIntersectionType(propTypes)
		}
		if writeTypes {
			if isUnion {
				result.links.writeType = tc.getUnionType(writeTypes)
			} else {
				result.links.writeType = tc.getIntersectionType(writeTypes)
			}
		}
	}
	return result
}

// Return the symbol for a given property in a union or intersection type, or undefined if the property
// does not exist in any constituent type. Note that the returned property may only be present in some
// constituents, in which case the isPartial flag is set when the containing type is union type. We need
// these partial properties when identifying discriminant properties, but otherwise they are filtered out
// and do not appear to be present in the union type.
func (tc *TypeChecker) getUnionOrIntersectionProperty(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) Symbol {
	var property Symbol
	if skipObjectFunctionPropertyAugment {
		property = type_.propertyCacheWithoutObjectFunctionPropertyAugment. /* ? */ get(name)
	} else {
		property = type_.propertyCache. /* ? */ get(name)
	}
	if !property {
		property = tc.createUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
		if property {
			var properties SymbolTable
			if skipObjectFunctionPropertyAugment {
				properties = /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() */ TODO
			} else {
				properties = /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: type.propertyCache ||= createSymbolTable() */ TODO
			}
			properties.set(name, property)
			// Propagate an entry from the non-augmented cache to the augmented cache unless the property is partial.
			if skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlagsPartial) && !type_.propertyCache. /* ? */ get(name) {
				properties := /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: type.propertyCache ||= createSymbolTable() */ TODO
				properties.set(name, property)
			}
		}
	}
	return property
}

func (tc *TypeChecker) getCommonDeclarationsOfSymbols(symbols Iterable[Symbol]) *Set[Node] {
	var commonDeclarations *Set[Node]
	for _, symbol := range symbols {
		if !symbol.declarations {
			return nil
		}
		if !commonDeclarations {
			commonDeclarations = NewSet(symbol.declarations)
			continue
		}
		commonDeclarations.forEach(func(declaration Node) {
			if !contains(symbol.declarations, declaration) {
				commonDeclarations.delete(declaration)
			}
		})
		if commonDeclarations.size == 0 {
			return nil
		}
	}
	return commonDeclarations
}

func (tc *TypeChecker) getPropertyOfUnionOrIntersectionType(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) Symbol {
	property := tc.getUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
	// We need to filter out partial properties in union types
	if property && !(getCheckFlags(property) & CheckFlagsReadPartial) {
		return property
	} else {
		return nil
	}
}

/**
 * Return the reduced form of the given type. For a union type, it is a union of the normalized constituent types.
 * For an intersection of types containing one or more mututally exclusive discriminant properties, it is 'never'.
 * For all other types, it is simply the type itself. Discriminant properties are considered mutually exclusive when
 * no constituent property has type 'never', but the intersection of the constituent property types is 'never'.
 */

func (tc *TypeChecker) getReducedType(type_ Type) Type {
	if type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).objectFlags&ObjectFlagsContainsIntersections {
		return (type_ /* as UnionType */).resolvedReducedType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: (type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType) */ TODO)
	} else if type_.flags & TypeFlagsIntersection {
		if !((type_ /* as IntersectionType */).objectFlags & ObjectFlagsIsNeverIntersectionComputed) {
			(type_ /* as IntersectionType */).objectFlags |= ObjectFlagsIsNeverIntersectionComputed | (__COND__(some(tc.getPropertiesOfUnionOrIntersectionType(type_ /* as IntersectionType */), tc.isNeverReducedProperty), ObjectFlagsIsNeverIntersection, 0))
		}
		if (type_ /* as IntersectionType */).objectFlags & ObjectFlagsIsNeverIntersection {
			return tc.neverType
		} else {
			return type_
		}
	}
	return type_
}

func (tc *TypeChecker) getReducedUnionType(unionType UnionType) Type {
	reducedTypes := sameMap(unionType.types, tc.getReducedType)
	if reducedTypes == unionType.types {
		return unionType
	}
	reduced := tc.getUnionType(reducedTypes)
	if reduced.flags & TypeFlagsUnion {
		(reduced /* as UnionType */).resolvedReducedType = reduced
	}
	return reduced
}

func (tc *TypeChecker) isNeverReducedProperty(prop Symbol) bool {
	return tc.isDiscriminantWithNeverType(prop) || tc.isConflictingPrivateProperty(prop)
}

func (tc *TypeChecker) isDiscriminantWithNeverType(prop Symbol) bool {
	// Return true for a synthetic non-optional property with non-uniform types, where at least one is
	// a literal type and none is never, that reduces to never.
	return !(prop.flags & SymbolFlagsOptional) && (getCheckFlags(prop)&(CheckFlagsDiscriminant|CheckFlagsHasNeverType)) == CheckFlagsDiscriminant && !!(tc.getTypeOfSymbol(prop).flags & TypeFlagsNever)
}

func (tc *TypeChecker) isConflictingPrivateProperty(prop Symbol) bool {
	// Return true for a synthetic property with multiple declarations, at least one of which is private.
	return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlagsContainsPrivate)
}

/**
 * A union type which is reducible upon instantiation (meaning some members are removed under certain instantiations)
 * must be kept generic, as that instantiation information needs to flow through the type system. By replacing all
 * type parameters in the union with a special never type that is treated as a literal in `getReducedType`, we can cause
 * the `getReducedType` logic to reduce the resulting type if possible (since only intersections with conflicting
 * literal-typed properties are reducible).
 */

func (tc *TypeChecker) isGenericReducibleType(type_ Type) bool {
	return !!(type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).objectFlags&ObjectFlagsContainsIntersections && some((type_ /* as UnionType */).types, tc.isGenericReducibleType) || type_.flags&TypeFlagsIntersection && tc.isReducibleIntersection(type_ /* as IntersectionType */))
}

func (tc *TypeChecker) isReducibleIntersection(type_ IntersectionType) bool {
	uniqueFilled := type_.uniqueLiteralFilledInstantiation || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper) */ TODO)
	return tc.getReducedType(uniqueFilled) != uniqueFilled
}

func (tc *TypeChecker) elaborateNeverIntersection(errorInfo *DiagnosticMessageChain, type_ Type) *DiagnosticMessageChain {
	if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsNeverIntersection {
		neverProp := find(tc.getPropertiesOfUnionOrIntersectionType(type_ /* as IntersectionType */), tc.isDiscriminantWithNeverType)
		if neverProp {
			return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, tc.typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsNoTypeReduction), tc.symbolToString(neverProp))
		}
		privateProp := find(tc.getPropertiesOfUnionOrIntersectionType(type_ /* as IntersectionType */), tc.isConflictingPrivateProperty)
		if privateProp {
			return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, tc.typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsNoTypeReduction), tc.symbolToString(privateProp))
		}
	}
	return errorInfo
}

/**
 * Return the symbol for the property with the given name in the given type. Creates synthetic union properties when
 * necessary, maps primitive types and type parameters are to their apparent types, and augments with properties from
 * Object and Function as appropriate.
 *
 * @param type a type to look up property from
 * @param name a name of property to look up in a given type
 */

func (tc *TypeChecker) getPropertyOfType(type_ Type, name __String, skipObjectFunctionPropertyAugment bool, includeTypeOnlyMembers bool) Symbol {
	type_ = tc.getReducedApparentType(type_)
	if type_.flags & TypeFlagsObject {
		resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		symbol := resolved.members.get(name)
		if symbol && !includeTypeOnlyMembers && type_.symbol. /* ? */ flags&SymbolFlagsValueModule && tc.getSymbolLinks(type_.symbol).typeOnlyExportStarMap. /* ? */ has(name) {
			// If this is the type of a module, `resolved.members.get(name)` might have effectively skipped over
			// an `export type * from './foo'`, leaving `symbolIsValue` unable to see that the symbol is being
			// viewed through a type-only export.
			return nil
		}
		if symbol && tc.symbolIsValue(symbol, includeTypeOnlyMembers) {
			return symbol
		}
		if skipObjectFunctionPropertyAugment {
			return nil
		}
		var functionType *ObjectType
		switch {
		case resolved == tc.anyFunctionType:
			functionType = tc.globalFunctionType
		case resolved.callSignatures.length:
			functionType = tc.globalCallableFunctionType
		case resolved.constructSignatures.length:
			functionType = tc.globalNewableFunctionType
		default:
			functionType = nil
		}
		if functionType {
			symbol := tc.getPropertyOfObjectType(functionType, name)
			if symbol {
				return symbol
			}
		}
		return tc.getPropertyOfObjectType(tc.globalObjectType, name)
	}
	if type_.flags & TypeFlagsIntersection {
		prop := tc.getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name /*skipObjectFunctionPropertyAugment*/, true)
		if prop {
			return prop
		}
		if !skipObjectFunctionPropertyAugment {
			return tc.getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
		}
		return nil
	}
	if type_.flags & TypeFlagsUnion {
		return tc.getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
	}
	return nil
}

func (tc *TypeChecker) getSignaturesOfStructuredType(type_ Type, kind SignatureKind) []Signature {
	if type_.flags & TypeFlagsStructuredType {
		resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		if kind == SignatureKindCall {
			return resolved.callSignatures
		} else {
			return resolved.constructSignatures
		}
	}
	return emptyArray
}

/**
 * Return the signatures of the given kind in the given type. Creates synthetic union signatures when necessary and
 * maps primitive types and type parameters are to their apparent types.
 */

func (tc *TypeChecker) getSignaturesOfType(type_ Type, kind SignatureKind) []Signature {
	result := tc.getSignaturesOfStructuredType(tc.getReducedApparentType(type_), kind)
	if kind == SignatureKindCall && !length(result) && type_.flags&TypeFlagsUnion {
		if (type_ /* as UnionType */).arrayFallbackSignatures {
			return (type_ /* as UnionType */).arrayFallbackSignatures
		}
		// If the union is all different instantiations of a member of the global array type...
		var memberName __String
		if tc.everyType(type_, func(t Type) bool {
			return !!t.symbol. /* ? */ parent && tc.isArrayOrTupleSymbol(t.symbol.parent) && (__COND__(!memberName, ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: memberName = t.symbol.escapedName, true */ TODO), memberName == t.symbol.escapedName))
		}) {
			// Transform the type from `(A[] | B[])["member"]` to `(A | B)[]["member"]` (since we pretend array is covariant anyway)
			arrayArg := tc.mapType(type_, func(t Type) Type {
				return tc.getMappedType((__COND__(tc.isReadonlyArraySymbol(t.symbol.parent), tc.globalReadonlyArrayType, tc.globalArrayType)).typeParameters[0], (t /* as AnonymousType */).mapper)
			})
			arrayType := tc.createArrayType(arrayArg, tc.someType(type_, func(t Type) bool {
				return tc.isReadonlyArraySymbol(t.symbol.parent)
			}))
			(type_ /* as UnionType */).arrayFallbackSignatures = tc.getSignaturesOfType(tc.getTypeOfPropertyOfType(arrayType, memberName), kind)
			return (type_ /* as UnionType */).arrayFallbackSignatures
		}
		(type_ /* as UnionType */).arrayFallbackSignatures = result
	}
	return result
}

func (tc *TypeChecker) isArrayOrTupleSymbol(symbol Symbol) bool {
	if !symbol || !tc.globalArrayType.symbol || !tc.globalReadonlyArrayType.symbol {
		return false
	}
	return !!tc.getSymbolIfSameReference(symbol, tc.globalArrayType.symbol) || !!tc.getSymbolIfSameReference(symbol, tc.globalReadonlyArrayType.symbol)
}

func (tc *TypeChecker) isReadonlyArraySymbol(symbol Symbol) bool {
	if !symbol || !tc.globalReadonlyArrayType.symbol {
		return false
	}
	return !!tc.getSymbolIfSameReference(symbol, tc.globalReadonlyArrayType.symbol)
}

func (tc *TypeChecker) findIndexInfo(indexInfos []IndexInfo, keyType Type) *IndexInfo {
	return find(indexInfos, func(info IndexInfo) bool {
		return info.keyType == keyType
	})
}

func (tc *TypeChecker) findApplicableIndexInfo(indexInfos []IndexInfo, keyType Type) *IndexInfo {
	// Index signatures for type 'string' are considered only when no other index signatures apply.
	var stringIndexInfo *IndexInfo
	var applicableInfo *IndexInfo
	var applicableInfos *[]IndexInfo
	for _, info := range indexInfos {
		if info.keyType == tc.stringType {
			stringIndexInfo = info
		} else if tc.isApplicableIndexType(keyType, info.keyType) {
			if !applicableInfo {
				applicableInfo = info
			} else {
				(applicableInfos || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: applicableInfos = [applicableInfo] */ TODO)).push(info)
			}
		}
	}
	// When more than one index signature is applicable we create a synthetic IndexInfo. Instead of computing
	// the intersected key type, we just use unknownType for the key type as nothing actually depends on the
	// keyType property of the returned IndexInfo.
	switch {
	case applicableInfos:
		return tc.createIndexInfo(tc.unknownType, tc.getIntersectionType(map_(applicableInfos, func(info IndexInfo) Type {
			return info.type_
		})), reduceLeft(applicableInfos, func(isReadonly bool, info IndexInfo) bool {
			return isReadonly && info.isReadonly
		}, /*initial*/ true))
	case applicableInfo:
		return applicableInfo
	case stringIndexInfo && tc.isApplicableIndexType(keyType, tc.stringType):
		return stringIndexInfo
	default:
		return nil
	}
}

func (tc *TypeChecker) isApplicableIndexType(source Type, target Type) bool {
	// A 'string' index signature applies to types assignable to 'string' or 'number', and a 'number' index
	// signature applies to types assignable to 'number', `${number}` and numeric string literal types.
	return tc.isTypeAssignableTo(source, target) || target == tc.stringType && tc.isTypeAssignableTo(source, tc.numberType) || target == tc.numberType && (source == tc.numericStringType || !!(source.flags&TypeFlagsStringLiteral) && isNumericLiteralName((source /* as StringLiteralType */).value))
}

func (tc *TypeChecker) getIndexInfosOfStructuredType(type_ Type) []IndexInfo {
	if type_.flags & TypeFlagsStructuredType {
		resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		return resolved.indexInfos
	}
	return emptyArray
}

func (tc *TypeChecker) getIndexInfosOfType(type_ Type) []IndexInfo {
	return tc.getIndexInfosOfStructuredType(tc.getReducedApparentType(type_))
}

// Return the indexing info of the given kind in the given type. Creates synthetic union index types when necessary and
// maps primitive types and type parameters are to their apparent types.
func (tc *TypeChecker) getIndexInfoOfType(type_ Type, keyType Type) *IndexInfo {
	return tc.findIndexInfo(tc.getIndexInfosOfType(type_), keyType)
}

// Return the index type of the given kind in the given type. Creates synthetic union index types when necessary and
// maps primitive types and type parameters are to their apparent types.
func (tc *TypeChecker) getIndexTypeOfType(type_ Type, keyType Type) Type {
	return tc.getIndexInfoOfType(type_, keyType). /* ? */ type_
}

func (tc *TypeChecker) getApplicableIndexInfos(type_ Type, keyType Type) []IndexInfo {
	return tc.getIndexInfosOfType(type_).filter(func(info IndexInfo) bool {
		return tc.isApplicableIndexType(keyType, info.keyType)
	})
}

func (tc *TypeChecker) getApplicableIndexInfo(type_ Type, keyType Type) *IndexInfo {
	return tc.findApplicableIndexInfo(tc.getIndexInfosOfType(type_), keyType)
}

func (tc *TypeChecker) getApplicableIndexInfoForName(type_ Type, name __String) *IndexInfo {
	return tc.getApplicableIndexInfo(type_, __COND__(tc.isLateBoundName(name), tc.esSymbolType, tc.getStringLiteralType(unescapeLeadingUnderscores(name))))
}

// Return list of type parameters with duplicates removed (duplicate identifier errors are generated in the actual
// type checking functions).
func (tc *TypeChecker) getTypeParametersFromDeclaration(declaration DeclarationWithTypeParameters) *[]TypeParameter {
	var result *[]TypeParameter
	for _, node := range getEffectiveTypeParameterDeclarations(declaration) {
		result = appendIfUnique(result, tc.getDeclaredTypeOfTypeParameter(node.symbol))
	}
	switch {
	case result. /* ? */ length:
		return result
	case isFunctionDeclaration(declaration):
		return tc.getSignatureOfTypeTag(declaration). /* ? */ typeParameters
	default:
		return nil
	}
}

func (tc *TypeChecker) symbolsToArray(symbols SymbolTable) []Symbol {
	var result []Symbol = []never{}
	symbols.forEach(func(symbol Symbol, id __String) {
		if !tc.isReservedMemberName(id) {
			result.push(symbol)
		}
	})
	return result
}

func (tc *TypeChecker) tryFindAmbientModule(moduleName string, withAugmentations bool) Symbol {
	if isExternalModuleNameRelative(moduleName) {
		return nil
	}
	symbol := tc.getSymbol(tc.globals, "\""+moduleName+"\"" /* as __String */, SymbolFlagsValueModule)
	// merged symbol is module declaration symbol combined with all augmentations
	if symbol && withAugmentations {
		return tc.getMergedSymbol(symbol)
	} else {
		return symbol
	}
}

func (tc *TypeChecker) hasEffectiveQuestionToken(node /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) bool {
	return hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node)
}

func (tc *TypeChecker) isOptionalParameter(node /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) bool {
	if tc.hasEffectiveQuestionToken(node) {
		return true
	}
	if !isParameter(node) {
		return false
	}
	if node.initializer {
		signature := tc.getSignatureFromDeclaration(node.parent)
		parameterIndex := node.parent.parameters.indexOf(node)
		Debug.assert(parameterIndex >= 0)
		// Only consider syntactic or instantiated parameters as optional, not `void` parameters as this function is used
		// in grammar checks and checking for `void` too early results in parameter types widening too early
		// and causes some noImplicitAny errors to be lost.
		return parameterIndex >= tc.getMinArgumentCount(signature, MinArgumentCountFlagsStrongArityForUntypedJS|MinArgumentCountFlagsVoidIsNonOptional)
	}
	iife := getImmediatelyInvokedFunctionExpression(node.parent)
	if iife {
		return !node.type_ && !node.dotDotDotToken && node.parent.parameters.indexOf(node) >= tc.getEffectiveCallArguments(iife).length
	}

	return false
}

func (tc *TypeChecker) isOptionalPropertyDeclaration(node Declaration) * /* TODO(TS-TO-GO) inferred type false | QuestionToken */ any {
	return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken
}

func (tc *TypeChecker) createTypePredicate(kind TypePredicateKind, parameterName *string, parameterIndex *number, type_ Type) TypePredicate {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind":           kind,
		"parameterName":  parameterName,
		"parameterIndex": parameterIndex,
		"type_":          type_,
	} /* as TypePredicate */
}

/**
 * Gets the minimum number of type arguments needed to satisfy all non-optional type
 * parameters.
 */

func (tc *TypeChecker) getMinTypeArgumentCount(typeParameters *[]TypeParameter) number {
	minTypeArgumentCount := 0
	if typeParameters {
		for i := 0; i < typeParameters.length; i++ {
			if !tc.hasTypeParameterDefault(typeParameters[i]) {
				minTypeArgumentCount = i + 1
			}
		}
	}
	return minTypeArgumentCount
}

/**
 * Fill in default types for unsupplied type arguments. If `typeArguments` is undefined
 * when a default type is supplied, a new array will be created and returned.
 *
 * @param typeArguments The supplied type arguments.
 * @param typeParameters The requested type parameters.
 * @param minTypeArgumentCount The minimum number of required type arguments.
 */

/* OVERLOAD: function fillMissingTypeArguments(typeArguments: readonly Type[], typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[]; */
/* OVERLOAD: function fillMissingTypeArguments(typeArguments: readonly Type[] | undefined, typeParameters: readonly TypeParameter[] | undefined, minTypeArgumentCount: number, isJavaScriptImplicitAny: boolean): Type[] | undefined; */
func (tc *TypeChecker) fillMissingTypeArguments(typeArguments *[]Type, typeParameters *[]TypeParameter, minTypeArgumentCount number, isJavaScriptImplicitAny bool) *[]Type {
	numTypeParameters := length(typeParameters)
	if !numTypeParameters {
		return []never{}
	}
	numTypeArguments := length(typeArguments)
	if isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) {
		var result []Type
		if typeArguments {
			result = typeArguments.slice()
		} else {
			result = []never{}
		}
		// Map invalid forward references in default types to the error type
		for i := numTypeArguments; i < numTypeParameters; i++ {
			result[i] = tc.errorType
		}
		baseDefaultType := tc.getDefaultTypeArgumentType(isJavaScriptImplicitAny)
		for i := numTypeArguments; i < numTypeParameters; i++ {
			defaultType := tc.getDefaultFromTypeParameter(typeParameters[i])
			if isJavaScriptImplicitAny && defaultType && (tc.isTypeIdenticalTo(defaultType, tc.unknownType) || tc.isTypeIdenticalTo(defaultType, tc.emptyObjectType)) {
				defaultType = tc.anyType
			}
			if defaultType {
				result[i] = tc.instantiateType(defaultType, tc.createTypeMapper(typeParameters, result))
			} else {
				result[i] = baseDefaultType
			}
		}
		result.length = typeParameters.length
		return result
	}
	return typeArguments && typeArguments.slice()
}

func (tc *TypeChecker) getSignatureFromDeclaration(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) Signature {
	links := tc.getNodeLinks(declaration)
	if !links.resolvedSignature {
		var parameters []Symbol = []never{}
		flags := SignatureFlagsNone
		minArgumentCount := 0
		var thisParameter Symbol
		var thisTag *JSDocThisTag
		if isInJSFile(declaration) {
			thisTag = getJSDocThisTag(declaration)
		} else {
			thisTag = nil
		}
		hasThisParameter := false
		iife := getImmediatelyInvokedFunctionExpression(declaration)
		isJSConstructSignature := isJSDocConstructSignature(declaration)
		isUntypedSignatureInJSFile := !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration)
		if isUntypedSignatureInJSFile {
			flags |= SignatureFlagsIsUntypedSignatureInJSFile
		}

		// If this is a JSDoc construct signature, then skip the first parameter in the
		// parameter list.  The first parameter represents the return type of the construct
		// signature.
		for i := __COND__(isJSConstructSignature, 1, 0); i < declaration.parameters.length; i++ {
			param := declaration.parameters[i]
			if isInJSFile(param) && isJSDocThisTag(param) {
				thisTag = param
				continue
			}

			paramSymbol := param.symbol
			var type_ *TypeNode
			if isJSDocParameterTag(param) {
				type_ = (param.typeExpression && param.typeExpression.type_)
			} else {
				type_ = param.type_
			}
			// Include parameter symbol instead of property symbol in the signature
			if paramSymbol && !!(paramSymbol.flags & SymbolFlagsProperty) && !isBindingPattern(param.name) {
				resolvedSymbol := tc.resolveName(param, paramSymbol.escapedName, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false)
				paramSymbol = resolvedSymbol
			}
			if i == 0 && paramSymbol.escapedName == InternalSymbolNameThis {
				hasThisParameter = true
				thisParameter = param.symbol
			} else {
				parameters.push(paramSymbol)
			}

			if type_ && type_.kind == SyntaxKindLiteralType {
				flags |= SignatureFlagsHasLiteralTypes
			}

			// Record a new minimum argument count if this is not an optional parameter
			isOptionalParameter := tc.hasEffectiveQuestionToken(param) || isParameter(param) && param.initializer || isRestParameter(param) || iife && parameters.length > iife.arguments.length && !type_
			if !isOptionalParameter {
				minArgumentCount = parameters.length
			}
		}

		// If only one accessor includes a this-type annotation, the other behaves as if it had the same type annotation
		if (declaration.kind == SyntaxKindGetAccessor || declaration.kind == SyntaxKindSetAccessor) && tc.hasBindableName(declaration) && (!hasThisParameter || !thisParameter) {
			var otherKind /* TODO(TS-TO-GO) inferred type SyntaxKind.GetAccessor | SyntaxKind.SetAccessor */ any
			if declaration.kind == SyntaxKindGetAccessor {
				otherKind = SyntaxKindSetAccessor
			} else {
				otherKind = SyntaxKindGetAccessor
			}
			other := getDeclarationOfKind(tc.getSymbolOfDeclaration(declaration), otherKind)
			if other {
				thisParameter = tc.getAnnotatedAccessorThisParameter(other)
			}
		}

		if thisTag && thisTag.typeExpression {
			thisParameter = tc.createSymbolWithType(tc.createSymbol(SymbolFlagsFunctionScopedVariable, InternalSymbolNameThis), tc.getTypeFromTypeNode(thisTag.typeExpression))
		}

		var hostDeclaration Node
		if isJSDocSignature(declaration) {
			hostDeclaration = getEffectiveJSDocHost(declaration)
		} else {
			hostDeclaration = declaration
		}
		var classType *InterfaceType
		if hostDeclaration && isConstructorDeclaration(hostDeclaration) {
			classType = tc.getDeclaredTypeOfClassOrInterface(tc.getMergedSymbol((hostDeclaration.parent /* as ClassDeclaration */).symbol))
		} else {
			classType = nil
		}
		var typeParameters *[]TypeParameter
		if classType {
			typeParameters = classType.localTypeParameters
		} else {
			typeParameters = tc.getTypeParametersFromDeclaration(declaration)
		}
		if hasRestParameter(declaration) || isInJSFile(declaration) && tc.maybeAddJsSyntheticRestParameter(declaration, parameters) {
			flags |= SignatureFlagsHasRestParameter
		}
		if isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlagsAbstract) || isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlagsAbstract) {
			flags |= SignatureFlagsAbstract
		}
		links.resolvedSignature = tc.createSignature(declaration, typeParameters, thisParameter, parameters /*resolvedReturnType*/, nil /*resolvedTypePredicate*/, nil, minArgumentCount, flags)
	}
	return links.resolvedSignature
}

/**
 * A JS function gets a synthetic rest parameter if it references `arguments` AND:
 * 1. It has no parameters but at least one `@param` with a type that starts with `...`
 * OR
 * 2. It has at least one parameter, and the last parameter has a matching `@param` with a type that starts with `...`
 */

func (tc *TypeChecker) maybeAddJsSyntheticRestParameter(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any, parameters []Symbol) bool {
	if isJSDocSignature(declaration) || !tc.containsArgumentsReference(declaration) {
		return false
	}
	lastParam := lastOrUndefined(declaration.parameters)
	var lastParamTags []JSDocParameterTag
	if lastParam {
		lastParamTags = getJSDocParameterTags(lastParam)
	} else {
		lastParamTags = getJSDocTags(declaration).filter(isJSDocParameterTag)
	}
	lastParamVariadicType := firstDefined(lastParamTags, func(p JSDocParameterTag) *JSDocVariadicType {
		if p.typeExpression && isJSDocVariadicType(p.typeExpression.type_) {
			return p.typeExpression.type_
		} else {
			return nil
		}
	})

	syntheticArgsSymbol := tc.createSymbol(SymbolFlagsVariable, "args" /* as __String */, CheckFlagsRestParameter)
	if lastParamVariadicType {
		// Parameter has effective annotation, lock in type
		syntheticArgsSymbol.links.type_ = tc.createArrayType(tc.getTypeFromTypeNode(lastParamVariadicType.type_))
	} else {
		// Parameter has no annotation
		// By using a `DeferredType` symbol, we allow the type of this rest arg to be overriden by contextual type assignment so long as its type hasn't been
		// cached by `getTypeOfSymbol` yet.
		syntheticArgsSymbol.links.checkFlags |= CheckFlagsDeferredType
		syntheticArgsSymbol.links.deferralParent = tc.neverType
		syntheticArgsSymbol.links.deferralConstituents = []Type{tc.anyArrayType}
		syntheticArgsSymbol.links.deferralWriteConstituents = []Type{tc.anyArrayType}
	}
	if lastParamVariadicType {
		// Replace the last parameter with a rest parameter.
		parameters.pop()
	}
	parameters.push(syntheticArgsSymbol)
	return true
}

func (tc *TypeChecker) getSignatureOfTypeTag(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) *Signature {
	// should be attached to a function declaration or expression
	if !(isInJSFile(node) && isFunctionLikeDeclaration(node)) {
		return nil
	}
	typeTag := getJSDocTypeTag(node)
	return typeTag. /* ? */ typeExpression && tc.getSingleCallSignature(tc.getTypeFromTypeNode(typeTag.typeExpression))
}

func (tc *TypeChecker) getParameterTypeOfTypeTag(func_ FunctionLikeDeclaration, parameter ParameterDeclaration) Type {
	signature := tc.getSignatureOfTypeTag(func_)
	if !signature {
		return nil
	}
	pos := func_.parameters.indexOf(parameter)
	if parameter.dotDotDotToken {
		return tc.getRestTypeAtPosition(signature, pos)
	} else {
		return tc.getTypeAtPosition(signature, pos)
	}
}

func (tc *TypeChecker) getReturnTypeOfTypeTag(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) Type {
	signature := tc.getSignatureOfTypeTag(node)
	return signature && tc.getReturnTypeOfSignature(signature)
}

func (tc *TypeChecker) containsArgumentsReference(declaration SignatureDeclaration) bool {
	links := tc.getNodeLinks(declaration)
	if links.containsArgumentsReference == nil {
		if links.flags & NodeCheckFlagsCaptureArguments {
			links.containsArgumentsReference = true
		} else {
			links.containsArgumentsReference = traverse((declaration /* as FunctionLikeDeclaration */).body)
		}
	}
	return links.containsArgumentsReference

	traverse := func(node Node) bool {
		if !node {
			return false
		}
		switch node.kind {
		case SyntaxKindIdentifier:
			return (node /* as Identifier */).escapedText == tc.argumentsSymbol.escapedName && tc.getReferencedValueSymbol(node /* as Identifier */) == tc.argumentsSymbol
		case SyntaxKindPropertyDeclaration,
			SyntaxKindMethodDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			return (node /* as NamedDeclaration */).name.kind == SyntaxKindComputedPropertyName && traverse((node /* as NamedDeclaration */).name)
		case SyntaxKindPropertyAccessExpression,
			SyntaxKindElementAccessExpression:
			return traverse((node /* as PropertyAccessExpression | ElementAccessExpression */).expression)
		case SyntaxKindPropertyAssignment:
			return traverse((node /* as PropertyAssignment */).initializer)
		default:
			return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse)
		}
	}

}

func (tc *TypeChecker) getSignaturesOfSymbol(symbol Symbol) []Signature {
	if !symbol || !symbol.declarations {
		return emptyArray
	}
	var result []Signature = []never{}
	for i := 0; i < symbol.declarations.length; i++ {
		decl := symbol.declarations[i]
		if !isFunctionLike(decl) {
			continue
		}
		// Don't include signature if node is the implementation of an overloaded function. A node is considered
		// an implementation node if it has a body and the previous node is of the same kind and immediately
		// precedes the implementation node (i.e. has the same parent and ends where the implementation starts).
		if i > 0 && (decl /* as FunctionLikeDeclaration */).body {
			previous := symbol.declarations[i-1]
			if decl.parent == previous.parent && decl.kind == previous.kind && decl.pos == previous.end {
				continue
			}
		}
		if isInJSFile(decl) && decl.jsDoc {
			tags := getJSDocOverloadTags(decl)
			if length(tags) {
				for _, tag := range tags {
					jsDocSignature := tag.typeExpression
					if jsDocSignature.type_ == nil && !isConstructorDeclaration(decl) {
						tc.reportImplicitAny(jsDocSignature, tc.anyType)
					}
					result.push(tc.getSignatureFromDeclaration(jsDocSignature))
				}
				continue
			}
		}
		// If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.
		// Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.
		result.push((!isFunctionExpressionOrArrowFunction(decl) && !isObjectLiteralMethod(decl) && tc.getSignatureOfTypeTag(decl)) || tc.getSignatureFromDeclaration(decl))
	}
	return result
}

func (tc *TypeChecker) resolveExternalModuleTypeByLiteral(name StringLiteral) Type {
	moduleSym := tc.resolveExternalModuleName(name, name)
	if moduleSym {
		resolvedModuleSymbol := tc.resolveExternalModuleSymbol(moduleSym)
		if resolvedModuleSymbol {
			return tc.getTypeOfSymbol(resolvedModuleSymbol)
		}
	}

	return tc.anyType
}

func (tc *TypeChecker) getThisTypeOfSignature(signature Signature) Type {
	if signature.thisParameter {
		return tc.getTypeOfSymbol(signature.thisParameter)
	}
}

func (tc *TypeChecker) getTypePredicateOfSignature(signature Signature) *TypePredicate {
	if !signature.resolvedTypePredicate {
		if signature.target {
			targetTypePredicate := tc.getTypePredicateOfSignature(signature.target)
			if targetTypePredicate {
				signature.resolvedTypePredicate = tc.instantiateTypePredicate(targetTypePredicate, signature.mapper)
			} else {
				signature.resolvedTypePredicate = tc.noTypePredicate
			}
		} else if signature.compositeSignatures {
			signature.resolvedTypePredicate = tc.getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || tc.noTypePredicate
		} else {
			type_ := signature.declaration && getEffectiveReturnTypeNode(signature.declaration)
			var jsdocPredicate *TypePredicate
			if !type_ {
				jsdocSignature := tc.getSignatureOfTypeTag(signature.declaration)
				if jsdocSignature && signature != jsdocSignature {
					jsdocPredicate = tc.getTypePredicateOfSignature(jsdocSignature)
				}
			}
			if type_ || jsdocPredicate {
				if type_ && isTypePredicateNode(type_) {
					signature.resolvedTypePredicate = tc.createTypePredicateFromTypePredicateNode(type_, signature)
				} else {
					signature.resolvedTypePredicate = jsdocPredicate || tc.noTypePredicate
				}
			} else if signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags&TypeFlagsBoolean) && tc.getParameterCount(signature) > 0 {
				TODO_IDENTIFIER := signature
				signature.resolvedTypePredicate = tc.noTypePredicate
				// avoid infinite loop
				signature.resolvedTypePredicate = tc.getTypePredicateFromBody(declaration) || tc.noTypePredicate
			} else {
				signature.resolvedTypePredicate = tc.noTypePredicate
			}
		}
		Debug.assert(!!signature.resolvedTypePredicate)
	}
	if signature.resolvedTypePredicate == tc.noTypePredicate {
		return nil
	} else {
		return signature.resolvedTypePredicate
	}
}

func (tc *TypeChecker) createTypePredicateFromTypePredicateNode(node TypePredicateNode, signature Signature) TypePredicate {
	parameterName := node.parameterName
	type_ := node.type_ && tc.getTypeFromTypeNode(node.type_)
	if parameterName.kind == SyntaxKindThisType {
		return tc.createTypePredicate(__COND__(node.assertsModifier, TypePredicateKindAssertsThis, TypePredicateKindThis) /*parameterName*/, nil /*parameterIndex*/, nil, type_)
	} else {
		return tc.createTypePredicate(__COND__(node.assertsModifier, TypePredicateKindAssertsIdentifier, TypePredicateKindIdentifier), parameterName.escapedText /* as string */, findIndex(signature.parameters, func(p Symbol) bool {
			return p.escapedName == parameterName.escapedText
		}), type_)
	}
}

func (tc *TypeChecker) getUnionOrIntersectionType(types []Type, kind *TypeFlags, unionReduction UnionReduction) Type {
	if kind != TypeFlagsIntersection {
		return tc.getUnionType(types, unionReduction)
	} else {
		return tc.getIntersectionType(types)
	}
}

func (tc *TypeChecker) getReturnTypeOfSignature(signature Signature) Type {
	if !signature.resolvedReturnType {
		if !tc.pushTypeResolution(signature, TypeSystemPropertyNameResolvedReturnType) {
			return tc.errorType
		}
		var type_ Type
		switch {
		case signature.target:
			type_ = tc.instantiateType(tc.getReturnTypeOfSignature(signature.target), signature.mapper)
		case signature.compositeSignatures:
			type_ = tc.instantiateType(tc.getUnionOrIntersectionType(map_(signature.compositeSignatures, tc.getReturnTypeOfSignature), signature.compositeKind, UnionReductionSubtype), signature.mapper)
		default:
			type_ = tc.getReturnTypeFromAnnotation(signature.declaration) || (__COND__(nodeIsMissing((signature.declaration /* as FunctionLikeDeclaration */).body), tc.anyType, tc.getReturnTypeFromBody(signature.declaration /* as FunctionLikeDeclaration */)))
		}
		if signature.flags & SignatureFlagsIsInnerCallChain {
			type_ = tc.addOptionalTypeMarker(type_)
		} else if signature.flags & SignatureFlagsIsOuterCallChain {
			type_ = tc.getOptionalType(type_)
		}
		if !tc.popTypeResolution() {
			if signature.declaration {
				typeNode := getEffectiveReturnTypeNode(signature.declaration)
				if typeNode {
					tc.error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself)
				} else if tc.noImplicitAny {
					declaration := signature.declaration /* as Declaration */
					name := getNameOfDeclaration(declaration)
					if name {
						tc.error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name))
					} else {
						tc.error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions)
					}
				}
			}
			type_ = tc.anyType
		}
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: signature.resolvedReturnType ??= type */ TODO
	}
	return signature.resolvedReturnType
}

func (tc *TypeChecker) getReturnTypeFromAnnotation(declaration /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) Type {
	if declaration.kind == SyntaxKindConstructor {
		return tc.getDeclaredTypeOfClassOrInterface(tc.getMergedSymbol((declaration.parent /* as ClassDeclaration */).symbol))
	}
	typeNode := getEffectiveReturnTypeNode(declaration)
	if isJSDocSignature(declaration) {
		root := getJSDocRoot(declaration)
		if root && isConstructorDeclaration(root.parent) && !typeNode {
			return tc.getDeclaredTypeOfClassOrInterface(tc.getMergedSymbol((root.parent.parent /* as ClassDeclaration */).symbol))
		}
	}
	if isJSDocConstructSignature(declaration) {
		return tc.getTypeFromTypeNode((declaration.parameters[0] /* as ParameterDeclaration */).type_)
		// TODO: GH#18217
	}
	if typeNode {
		return tc.getTypeFromTypeNode(typeNode)
	}
	if declaration.kind == SyntaxKindGetAccessor && tc.hasBindableName(declaration) {
		jsDocType := isInJSFile(declaration) && tc.getTypeForDeclarationFromJSDocComment(declaration)
		if jsDocType {
			return jsDocType
		}
		setter := getDeclarationOfKind(tc.getSymbolOfDeclaration(declaration), SyntaxKindSetAccessor)
		setterType := tc.getAnnotatedAccessorType(setter)
		if setterType {
			return setterType
		}
	}
	return tc.getReturnTypeOfTypeTag(declaration)
}

func (tc *TypeChecker) isResolvingReturnTypeOfSignature(signature Signature) bool {
	return signature.compositeSignatures && some(signature.compositeSignatures, tc.isResolvingReturnTypeOfSignature) || !signature.resolvedReturnType && tc.findResolutionCycleStartIndex(signature, TypeSystemPropertyNameResolvedReturnType) >= 0
}

func (tc *TypeChecker) getRestTypeOfSignature(signature Signature) Type {
	return tc.tryGetRestTypeOfSignature(signature) || tc.anyType
}

func (tc *TypeChecker) tryGetRestTypeOfSignature(signature Signature) Type {
	if signatureHasRestParameter(signature) {
		sigRestType := tc.getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
		var restType Type
		if tc.isTupleType(sigRestType) {
			restType = tc.getRestTypeOfTupleType(sigRestType)
		} else {
			restType = sigRestType
		}
		return restType && tc.getIndexTypeOfType(restType, tc.numberType)
	}
	return nil
}

func (tc *TypeChecker) getSignatureInstantiation(signature Signature, typeArguments *[]Type, isJavascript bool, inferredTypeParameters []TypeParameter) Signature {
	instantiatedSignature := tc.getSignatureInstantiationWithoutFillingInTypeArguments(signature, tc.fillMissingTypeArguments(typeArguments, signature.typeParameters, tc.getMinTypeArgumentCount(signature.typeParameters), isJavascript))
	if inferredTypeParameters {
		returnSignature := tc.getSingleCallOrConstructSignature(tc.getReturnTypeOfSignature(instantiatedSignature))
		if returnSignature {
			newReturnSignature := tc.cloneSignature(returnSignature)
			newReturnSignature.typeParameters = inferredTypeParameters
			newInstantiatedSignature := tc.cloneSignature(instantiatedSignature)
			newInstantiatedSignature.resolvedReturnType = tc.getOrCreateTypeFromSignature(newReturnSignature)
			return newInstantiatedSignature
		}
	}
	return instantiatedSignature
}

func (tc *TypeChecker) getSignatureInstantiationWithoutFillingInTypeArguments(signature Signature, typeArguments *[]Type) Signature {
	instantiations := signature.instantiations || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: signature.instantiations = new Map<string, Signature>() */ TODO)
	id := tc.getTypeListId(typeArguments)
	instantiation := instantiations.get(id)
	if !instantiation {
		instantiations.set(id /* TODO(TS-TO-GO) EqualsToken BinaryExpression: instantiation = createSignatureInstantiation(signature, typeArguments) */, TODO)
	}
	return instantiation
}

func (tc *TypeChecker) createSignatureInstantiation(signature Signature, typeArguments *[]Type) Signature {
	return tc.instantiateSignature(signature, tc.createSignatureTypeMapper(signature, typeArguments) /*eraseTypeParameters*/, true)
}

func (tc *TypeChecker) getTypeParametersForMapper(signature Signature) *[]Type {
	return sameMap(signature.typeParameters, func(tp TypeParameter) Type {
		if tp.mapper {
			return tc.instantiateType(tp, tp.mapper)
		} else {
			return tp
		}
	})
}

func (tc *TypeChecker) createSignatureTypeMapper(signature Signature, typeArguments *[]Type) TypeMapper {
	return tc.createTypeMapper(tc.getTypeParametersForMapper(signature), typeArguments)
}

func (tc *TypeChecker) getErasedSignature(signature Signature) Signature {
	if signature.typeParameters {
		return signature.erasedSignatureCache || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: signature.erasedSignatureCache = createErasedSignature(signature) */ TODO)
	} else {
		return signature
	}
}

func (tc *TypeChecker) createErasedSignature(signature Signature) Signature {
	// Create an instantiation of the signature where all type arguments are the any type.
	return tc.instantiateSignature(signature, tc.createTypeEraser(signature.typeParameters) /*eraseTypeParameters*/, true)
}

func (tc *TypeChecker) getCanonicalSignature(signature Signature) Signature {
	if signature.typeParameters {
		return signature.canonicalSignatureCache || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: signature.canonicalSignatureCache = createCanonicalSignature(signature) */ TODO)
	} else {
		return signature
	}
}

func (tc *TypeChecker) createCanonicalSignature(signature Signature) Signature {
	// Create an instantiation of the signature where each unconstrained type parameter is replaced with
	// its original. When a generic class or interface is instantiated, each generic method in the class or
	// interface is instantiated with a fresh set of cloned type parameters (which we need to handle scenarios
	// where different generations of the same type parameter are in scope). This leads to a lot of new type
	// identities, and potentially a lot of work comparing those identities, so here we create an instantiation
	// that uses the original type identities for all unconstrained type parameters.
	return tc.getSignatureInstantiation(signature, map_(signature.typeParameters, func(tp TypeParameter) TypeParameter {
		if tp.target && !tc.getConstraintOfTypeParameter(tp.target) {
			return tp.target
		} else {
			return tp
		}
	}), isInJSFile(signature.declaration))
}

func (tc *TypeChecker) getImplementationSignature(signature Signature) Signature {
	if signature.typeParameters {
		return /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: signature.implementationSignatureCache ||= createImplementationSignature(signature) */ TODO
	} else {
		return signature
	}
}

func (tc *TypeChecker) createImplementationSignature(signature Signature) Signature {
	if signature.typeParameters {
		return tc.instantiateSignature(signature, tc.createTypeMapper([]never{}, []never{}))
	} else {
		return signature
	}
}

func (tc *TypeChecker) getBaseSignature(signature Signature) Signature {
	typeParameters := signature.typeParameters
	if typeParameters {
		if signature.baseSignatureCache {
			return signature.baseSignatureCache
		}
		typeEraser := tc.createTypeEraser(typeParameters)
		baseConstraintMapper := tc.createTypeMapper(typeParameters, map_(typeParameters, func(tp TypeParameter) Type {
			return tc.getConstraintOfTypeParameter(tp) || tc.unknownType
		}))
		var baseConstraints []Type = map_(typeParameters, func(tp TypeParameter) Type {
			return tc.instantiateType(tp, baseConstraintMapper) || tc.unknownType
		})
		// Run N type params thru the immediate constraint mapper up to N times
		// This way any noncircular interdependent type parameters are definitely resolved to their external dependencies
		for i := 0; i < typeParameters.length-1; i++ {
			baseConstraints = tc.instantiateTypes(baseConstraints, baseConstraintMapper)
		}
		// and then apply a type eraser to remove any remaining circularly dependent type parameters
		baseConstraints = tc.instantiateTypes(baseConstraints, typeEraser)
		signature.baseSignatureCache = tc.instantiateSignature(signature, tc.createTypeMapper(typeParameters, baseConstraints) /*eraseTypeParameters*/, true)
		return signature.baseSignatureCache
	}
	return signature
}

func (tc *TypeChecker) getOrCreateTypeFromSignature(signature Signature, outerTypeParameters []TypeParameter) ObjectType {
	// There are two ways to declare a construct signature, one is by declaring a class constructor
	// using the constructor keyword, and the other is declaring a bare construct signature in an
	// object type literal or interface (using the new keyword). Each way of declaring a constructor
	// will result in a different declaration kind.
	if !signature.isolatedSignatureType {
		kind := signature.declaration. /* ? */ kind

		// If declaration is undefined, it is likely to be the signature of the default constructor.
		isConstructor := kind == nil || kind == SyntaxKindConstructor || kind == SyntaxKindConstructSignature || kind == SyntaxKindConstructorType

		// The type must have a symbol with a `Function` flag and a declaration in order to be correctly flagged as possibly containing
		// type variables by `couldContainTypeVariables`
		type_ := tc.createObjectType(ObjectFlagsAnonymous|ObjectFlagsSingleSignatureType, tc.createSymbol(SymbolFlagsFunction, InternalSymbolNameFunction)) /* as SingleSignatureType */
		if signature.declaration && !nodeIsSynthesized(signature.declaration) {
			type_.symbol.declarations = [] /* TODO(TS-TO-GO) inferred type SignatureDeclaration | JSDocSignature */ any{signature.declaration}
			type_.symbol.valueDeclaration = signature.declaration
		}
		outerTypeParameters = outerTypeParameters || signature.declaration && tc.getOuterTypeParameters(signature.declaration /*includeThisTypes*/, true)
		type_.outerTypeParameters = outerTypeParameters

		type_.members = tc.emptySymbols
		type_.properties = emptyArray
		if !isConstructor {
			type_.callSignatures = []Signature{signature}
		} else {
			type_.callSignatures = emptyArray
		}
		if isConstructor {
			type_.constructSignatures = []Signature{signature}
		} else {
			type_.constructSignatures = emptyArray
		}
		type_.indexInfos = emptyArray
		signature.isolatedSignatureType = type_
	}

	return signature.isolatedSignatureType
}

func (tc *TypeChecker) getIndexSymbol(symbol Symbol) Symbol {
	if symbol.members {
		return tc.getIndexSymbolFromSymbolTable(symbol.members)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getIndexSymbolFromSymbolTable(symbolTable SymbolTable) Symbol {
	return symbolTable.get(InternalSymbolNameIndex)
}

func (tc *TypeChecker) createIndexInfo(keyType Type, type_ Type, isReadonly bool, declaration IndexSignatureDeclaration) IndexInfo {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"keyType":     keyType,
		"type_":       type_,
		"isReadonly":  isReadonly,
		"declaration": declaration,
	}
}

func (tc *TypeChecker) getIndexInfosOfSymbol(symbol Symbol) []IndexInfo {
	indexSymbol := tc.getIndexSymbol(symbol)
	if indexSymbol {
		return tc.getIndexInfosOfIndexSymbol(indexSymbol)
	} else {
		return emptyArray
	}
}

func (tc *TypeChecker) getIndexInfosOfIndexSymbol(indexSymbol Symbol) []IndexInfo {
	if indexSymbol.declarations {
		var indexInfos []IndexInfo = []never{}
		for _, declaration := range indexSymbol.declarations /* as IndexSignatureDeclaration[] */ {
			if declaration.parameters.length == 1 {
				parameter := declaration.parameters[0]
				if parameter.type_ {
					tc.forEachType(tc.getTypeFromTypeNode(parameter.type_), func(keyType Type) {
						if tc.isValidIndexKeyType(keyType) && !tc.findIndexInfo(indexInfos, keyType) {
							indexInfos.push(tc.createIndexInfo(keyType, __COND__(declaration.type_, tc.getTypeFromTypeNode(declaration.type_), tc.anyType), hasEffectiveModifier(declaration, ModifierFlagsReadonly), declaration))
						}
					})
				}
			}
		}
		return indexInfos
	}
	return emptyArray
}

func (tc *TypeChecker) isValidIndexKeyType(type_ Type) bool {
	return !!(type_.flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsESSymbol)) || tc.isPatternLiteralType(type_) || !!(type_.flags&TypeFlagsIntersection) && !tc.isGenericType(type_) && some((type_ /* as IntersectionType */).types, tc.isValidIndexKeyType)
}

func (tc *TypeChecker) getConstraintDeclaration(type_ TypeParameter) *TypeNode {
	return mapDefined(filter(type_.symbol && type_.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0]
}

func (tc *TypeChecker) getInferredTypeParameterConstraint(typeParameter TypeParameter, omitTypeReferences bool) Type {
	var inferences *[]Type
	if typeParameter.symbol. /* ? */ declarations {
		for _, declaration := range typeParameter.symbol.declarations {
			if declaration.parent.kind == SyntaxKindInferType {
				// When an 'infer T' declaration is immediately contained in a type reference node
				// (such as 'Foo<infer T>'), T's constraint is inferred from the constraint of the
				// corresponding type parameter in 'Foo'. When multiple 'infer T' declarations are
				// present, we form an intersection of the inferred constraint types.
				TODO_IDENTIFIER := walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent)
				if grandParent.kind == SyntaxKindTypeReference && !omitTypeReferences {
					typeReference := grandParent /* as TypeReferenceNode */
					typeParameters := tc.getTypeParametersForTypeReferenceOrImport(typeReference)
					if typeParameters {
						index := typeReference.typeArguments.indexOf(childTypeParameter /* as TypeNode */)
						if index < typeParameters.length {
							declaredConstraint := tc.getConstraintOfTypeParameter(typeParameters[index])
							if declaredConstraint {
								// Type parameter constraints can reference other type parameters so
								// constraints need to be instantiated. If instantiation produces the
								// type parameter itself, we discard that inference. For example, in
								//   type Foo<T extends string, U extends T> = [T, U];
								//   type Bar<T> = T extends Foo<infer X, infer X> ? Foo<X, X> : T;
								// the instantiated constraint for U is X, so we discard that inference.
								mapper := tc.makeDeferredTypeMapper(typeParameters, typeParameters.map_(func(_ TypeParameter, index number) /* TODO(TS-TO-GO) inferred type () => Type */ any {
									return func() Type {
										return tc.getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index)
									}
								}))
								constraint := tc.instantiateType(declaredConstraint, mapper)
								if constraint != typeParameter {
									inferences = append(inferences, constraint)
								}
							}
						}
					}
				} else if grandParent.kind == SyntaxKindParameter && (grandParent /* as ParameterDeclaration */).dotDotDotToken || grandParent.kind == SyntaxKindRestType || grandParent.kind == SyntaxKindNamedTupleMember && (grandParent /* as NamedTupleMember */).dotDotDotToken {
					inferences = append(inferences, tc.createArrayType(tc.unknownType))
				} else if grandParent.kind == SyntaxKindTemplateLiteralTypeSpan {
					inferences = append(inferences, tc.stringType)
				} else if grandParent.kind == SyntaxKindTypeParameter && grandParent.parent.kind == SyntaxKindMappedType {
					inferences = append(inferences, tc.stringNumberSymbolType)
				} else if grandParent.kind == SyntaxKindMappedType && (grandParent /* as MappedTypeNode */).type_ && skipParentheses((grandParent /* as MappedTypeNode */).type_) == declaration.parent && grandParent.parent.kind == SyntaxKindConditionalType && (grandParent.parent /* as ConditionalTypeNode */).extendsType == grandParent && (grandParent.parent /* as ConditionalTypeNode */).checkType.kind == SyntaxKindMappedType && ((grandParent.parent /* as ConditionalTypeNode */).checkType /* as MappedTypeNode */).type_ {
					checkMappedType := (grandParent.parent /* as ConditionalTypeNode */).checkType /* as MappedTypeNode */
					nodeType := tc.getTypeFromTypeNode(checkMappedType.type_)
					inferences = append(inferences, tc.instantiateType(nodeType, tc.makeUnaryTypeMapper(tc.getDeclaredTypeOfTypeParameter(tc.getSymbolOfDeclaration(checkMappedType.typeParameter)), __COND__(checkMappedType.typeParameter.constraint, tc.getTypeFromTypeNode(checkMappedType.typeParameter.constraint), tc.stringNumberSymbolType))))
				}
			}
		}
	}
	return inferences && tc.getIntersectionType(inferences)
}

/** This is a worker function. Use getConstraintOfTypeParameter which guards against circular constraints. */

func (tc *TypeChecker) getConstraintFromTypeParameter(typeParameter TypeParameter) Type {
	if !typeParameter.constraint {
		if typeParameter.target {
			targetConstraint := tc.getConstraintOfTypeParameter(typeParameter.target)
			if targetConstraint {
				typeParameter.constraint = tc.instantiateType(targetConstraint, typeParameter.mapper)
			} else {
				typeParameter.constraint = tc.noConstraintType
			}
		} else {
			constraintDeclaration := tc.getConstraintDeclaration(typeParameter)
			if !constraintDeclaration {
				typeParameter.constraint = tc.getInferredTypeParameterConstraint(typeParameter) || tc.noConstraintType
			} else {
				type_ := tc.getTypeFromTypeNode(constraintDeclaration)
				if type_.flags&TypeFlagsAny && !tc.isErrorType(type_) {
					// use stringNumberSymbolType as the base constraint for mapped type key constraints (unknown isn;t assignable to that, but `any` was),
					// use unknown otherwise
					if constraintDeclaration.parent.parent.kind == SyntaxKindMappedType {
						type_ = tc.stringNumberSymbolType
					} else {
						type_ = tc.unknownType
					}
				}
				typeParameter.constraint = type_
			}
		}
	}
	if typeParameter.constraint == tc.noConstraintType {
		return nil
	} else {
		return typeParameter.constraint
	}
}

func (tc *TypeChecker) getParentSymbolOfTypeParameter(typeParameter TypeParameter) Symbol {
	tp := getDeclarationOfKind(typeParameter.symbol, SyntaxKindTypeParameter)
	var host * /* TODO(TS-TO-GO) inferred type SignatureDeclaration | InterfaceDeclaration | ClassDeclaration | ClassExpression | TypeAliasDeclaration | InferTypeNode | JSDocCallbackTag | JSDocEnumTag | JSDocTypedefTag */ any
	if isJSDocTemplateTag(tp.parent) {
		host = getEffectiveContainerForJSDocTemplateTag(tp.parent)
	} else {
		host = tp.parent
	}
	return host && tc.getSymbolOfNode(host)
}

func (tc *TypeChecker) getTypeListId(types *[]Type) string {
	result := ""
	if types {
		length := types.length
		i := 0
		for i < length {
			startId := types[i].id
			count := 1
			for i+count < length && types[i+count].id == startId+count {
				count++
			}
			if result.length {
				result += ","
			}
			result += startId
			if count > 1 {
				result += ":" + count
			}
			i += count
		}
	}
	return result
}

func (tc *TypeChecker) getAliasId(aliasSymbol Symbol, aliasTypeArguments *[]Type) string {
	if aliasSymbol {
		return __TEMPLATE__("@", getSymbolId(aliasSymbol)) + (__COND__(aliasTypeArguments, __TEMPLATE__(":", tc.getTypeListId(aliasTypeArguments)), ""))
	} else {
		return ""
	}
}

// This function is used to propagate certain flags when creating new object type references and union types.
// It is only necessary to do so if a constituent type might be the undefined type, the null type, the type
// of an object literal or a non-inferrable type. This is because there are operations in the type checker
// that care about the presence of such types at arbitrary depth in a containing type.
func (tc *TypeChecker) getPropagatingFlagsOfTypes(types []Type, excludeKinds TypeFlags) ObjectFlags {
	var result ObjectFlags = 0
	for _, type_ := range types {
		if excludeKinds == nil || !(type_.flags & excludeKinds) {
			result |= getObjectFlags(type_)
		}
	}
	return result & ObjectFlagsPropagatingFlags
}

func (tc *TypeChecker) tryCreateTypeReference(target GenericType, typeArguments *[]Type) Type {
	if some(typeArguments) && target == tc.emptyGenericType {
		return tc.unknownType
	}

	return tc.createTypeReference(target, typeArguments)
}

func (tc *TypeChecker) createTypeReference(target GenericType, typeArguments *[]Type) TypeReference {
	id := tc.getTypeListId(typeArguments)
	type_ := target.instantiations.get(id)
	if !type_ {
		type_ = tc.createObjectType(ObjectFlagsReference, target.symbol) /* as TypeReference */
		target.instantiations.set(id, type_)
		if typeArguments {
			type_.objectFlags |= tc.getPropagatingFlagsOfTypes(typeArguments)
		} else {
			type_.objectFlags |= 0
		}
		type_.target = target
		type_.resolvedTypeArguments = typeArguments
	}
	return type_
}

func (tc *TypeChecker) cloneTypeReference(source TypeReference) TypeReference {
	type_ := tc.createTypeWithSymbol(source.flags, source.symbol) /* as TypeReference */
	type_.objectFlags = source.objectFlags
	type_.target = source.target
	type_.resolvedTypeArguments = source.resolvedTypeArguments
	return type_
}

func (tc *TypeChecker) createDeferredTypeReference(target GenericType, node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) DeferredTypeReference {
	if !aliasSymbol {
		aliasSymbol = tc.getAliasSymbolForTypeNode(node)
		localAliasTypeArguments := tc.getTypeArgumentsForAliasSymbol(aliasSymbol)
		if mapper {
			aliasTypeArguments = tc.instantiateTypes(localAliasTypeArguments, mapper)
		} else {
			aliasTypeArguments = localAliasTypeArguments
		}
	}
	type_ := tc.createObjectType(ObjectFlagsReference, target.symbol) /* as DeferredTypeReference */
	type_.target = target
	type_.node = node
	type_.mapper = mapper
	type_.aliasSymbol = aliasSymbol
	type_.aliasTypeArguments = aliasTypeArguments
	return type_
}

func (tc *TypeChecker) getTypeArguments(type_ TypeReference) []Type {
	if !type_.resolvedTypeArguments {
		if !tc.pushTypeResolution(type_, TypeSystemPropertyNameResolvedTypeArguments) {
			return concatenate(type_.target.outerTypeParameters, type_.target.localTypeParameters. /* ? */ map_(func() IntrinsicType {
				return tc.errorType
			})) || emptyArray
		}
		node := type_.node
		var typeArguments []Type
		switch {
		case !node:
			typeArguments = emptyArray
		case node.kind == SyntaxKindTypeReference:
			typeArguments = concatenate(type_.target.outerTypeParameters, tc.getEffectiveTypeArguments(node, type_.target.localTypeParameters))
		case node.kind == SyntaxKindArrayType:
			typeArguments = []Type{tc.getTypeFromTypeNode(node.elementType)}
		default:
			typeArguments = map_(node.elements, tc.getTypeFromTypeNode)
		}
		if tc.popTypeResolution() {
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments */ TODO
		} else {
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray) */ TODO
			tc.error(type_.node || tc.currentNode, __COND__(type_.target.symbol, Diagnostics.Type_arguments_for_0_circularly_reference_themselves, Diagnostics.Tuple_type_arguments_circularly_reference_themselves), type_.target.symbol && tc.symbolToString(type_.target.symbol))
		}
	}
	return type_.resolvedTypeArguments
}

func (tc *TypeChecker) getTypeReferenceArity(type_ TypeReference) number {
	return length(type_.target.typeParameters)
}

/**
 * Get type from type-reference that reference to class or interface
 */

func (tc *TypeChecker) getTypeFromClassOrInterfaceReference(node NodeWithTypeArguments, symbol Symbol) Type {
	type_ := tc.getDeclaredTypeOfSymbol(tc.getMergedSymbol(symbol)) /* as InterfaceType */
	typeParameters := type_.localTypeParameters
	if typeParameters {
		numTypeArguments := length(node.typeArguments)
		minTypeArgumentCount := tc.getMinTypeArgumentCount(typeParameters)
		isJs := isInJSFile(node)
		isJsImplicitAny := !tc.noImplicitAny && isJs
		if !isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
			missingAugmentsTag := isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent)
			var diag DiagnosticMessage
			switch {
			case minTypeArgumentCount == typeParameters.length:
				if missingAugmentsTag {
					diag = Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag
				} else {
					diag = Diagnostics.Generic_type_0_requires_1_type_argument_s
				}
			case missingAugmentsTag:
				diag = Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag
			default:
				diag = Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments
			}

			typeStr := tc.typeToString(type_ /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrayAsGenericType)
			tc.error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length)
			if !isJs {
				// TODO: Adopt same permissive behavior in TS as in JS to reduce follow-on editing experience failures (requires editing fillMissingTypeArguments)
				return tc.errorType
			}
		}
		if node.kind == SyntaxKindTypeReference && tc.isDeferredTypeReferenceNode(node /* as TypeReferenceNode */, length(node.typeArguments) != typeParameters.length) {
			return tc.createDeferredTypeReference(type_ /* as GenericType */, node /* as TypeReferenceNode */ /*mapper*/, nil)
		}
		// In a type reference, the outer type parameters of the referenced class or interface are automatically
		// supplied as type arguments and the type reference only specifies arguments for the local type parameters
		// of the class or interface.
		typeArguments := concatenate(type_.outerTypeParameters, tc.fillMissingTypeArguments(tc.typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs))
		return tc.createTypeReference(type_ /* as GenericType */, typeArguments)
	}
	if tc.checkNoTypeArguments(node, symbol) {
		return type_
	} else {
		return tc.errorType
	}
}

func (tc *TypeChecker) getTypeAliasInstantiation(symbol Symbol, typeArguments *[]Type, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	type_ := tc.getDeclaredTypeOfSymbol(symbol)
	if type_ == tc.intrinsicMarkerType {
		typeKind := intrinsicTypeKinds.get(symbol.escapedName /* as string */)
		if typeKind != nil && typeArguments && typeArguments.length == 1 {
			if typeKind == IntrinsicTypeKindNoInfer {
				return tc.getNoInferType(typeArguments[0])
			} else {
				return tc.getStringMappingType(symbol, typeArguments[0])
			}
		}
	}
	links := tc.getSymbolLinks(symbol)
	typeParameters := links.typeParameters
	id := tc.getTypeListId(typeArguments) + tc.getAliasId(aliasSymbol, aliasTypeArguments)
	instantiation := links.instantiations.get(id)
	if !instantiation {
		links.instantiations.set(id /* TODO(TS-TO-GO) EqualsToken BinaryExpression: instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments) */, TODO)
	}
	return instantiation
}

/**
 * Get type from reference to type alias. When a type alias is generic, the declared type of the type alias may include
 * references to the type parameters of the alias. We replace those with the actual type arguments by instantiating the
 * declared type. Instantiations are cached using the type identities of the type arguments as the key.
 */

func (tc *TypeChecker) getTypeFromTypeAliasReference(node NodeWithTypeArguments, symbol Symbol) Type {
	if getCheckFlags(symbol) & CheckFlagsUnresolved {
		typeArguments := tc.typeArgumentsFromTypeReferenceNode(node)
		id := tc.getAliasId(symbol, typeArguments)
		errorType := tc.errorTypes.get(id)
		if !errorType {
			errorType = tc.createIntrinsicType(TypeFlagsAny, "error" /*objectFlags*/, nil, __TEMPLATE__("alias ", id))
			errorType.aliasSymbol = symbol
			errorType.aliasTypeArguments = typeArguments
			tc.errorTypes.set(id, errorType)
		}
		return errorType
	}
	type_ := tc.getDeclaredTypeOfSymbol(symbol)
	typeParameters := tc.getSymbolLinks(symbol).typeParameters
	if typeParameters {
		numTypeArguments := length(node.typeArguments)
		minTypeArgumentCount := tc.getMinTypeArgumentCount(typeParameters)
		if numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length {
			tc.error(node, __COND__(minTypeArgumentCount == typeParameters.length, Diagnostics.Generic_type_0_requires_1_type_argument_s, Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments), tc.symbolToString(symbol), minTypeArgumentCount, typeParameters.length)
			return tc.errorType
		}
		// We refrain from associating a local type alias with an instantiation of a top-level type alias
		// because the local alias may end up being referenced in an inferred return type where it is not
		// accessible--which in turn may lead to a large structural expansion of the type when generating
		// a .d.ts file. See #43622 for an example.
		aliasSymbol := tc.getAliasSymbolForTypeNode(node)
		var newAliasSymbol Symbol
		if aliasSymbol && (tc.isLocalTypeAlias(symbol) || !tc.isLocalTypeAlias(aliasSymbol)) {
			newAliasSymbol = aliasSymbol
		} else {
			newAliasSymbol = nil
		}
		var aliasTypeArguments *[]Type
		if newAliasSymbol {
			aliasTypeArguments = tc.getTypeArgumentsForAliasSymbol(newAliasSymbol)
		} else if isTypeReferenceType(node) {
			aliasSymbol := tc.resolveTypeReferenceName(node, SymbolFlagsAlias /*ignoreErrors*/, true)
			// refers to an alias import/export/reexport - by making sure we use the target as an aliasSymbol,
			// we ensure the exported symbol is used to refer to the type when it's reserialized later
			if aliasSymbol && aliasSymbol != tc.unknownSymbol {
				resolved := tc.resolveAlias(aliasSymbol)
				if resolved && resolved.flags&SymbolFlagsTypeAlias {
					newAliasSymbol = resolved
					aliasTypeArguments = tc.typeArgumentsFromTypeReferenceNode(node) || (__COND__(typeParameters, []never{}, nil))
				}
			}
		}
		return tc.getTypeAliasInstantiation(symbol, tc.typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments)
	}
	if tc.checkNoTypeArguments(node, symbol) {
		return type_
	} else {
		return tc.errorType
	}
}

func (tc *TypeChecker) isLocalTypeAlias(symbol Symbol) bool {
	declaration := symbol.declarations. /* ? */ find(isTypeAlias)
	return !!(declaration && getContainingFunction(declaration))
}

func (tc *TypeChecker) getTypeReferenceName(node TypeReferenceType) *EntityNameOrEntityNameExpression {
	switch node.kind {
	case SyntaxKindTypeReference:
		return node.typeName
	case SyntaxKindExpressionWithTypeArguments:
		expr := node.expression
		if isEntityNameExpression(expr) {
			return expr
		}
	}

	return nil
}

func (tc *TypeChecker) getSymbolPath(symbol Symbol) string {
	if symbol.parent {
		return __TEMPLATE__(tc.getSymbolPath(symbol.parent), ".", symbol.escapedName)
	} else {
		return symbol.escapedName /* as string */
	}
}

func (tc *TypeChecker) getUnresolvedSymbolForEntityName(name EntityNameOrEntityNameExpression) TransientSymbol {
	var identifier Identifier
	switch {
	case name.kind == SyntaxKindQualifiedName:
		identifier = name.right
	case name.kind == SyntaxKindPropertyAccessExpression:
		identifier = name.name
	default:
		identifier = name
	}
	text := identifier.escapedText
	if text {
		var parentSymbol *TransientSymbol
		switch {
		case name.kind == SyntaxKindQualifiedName:
			parentSymbol = tc.getUnresolvedSymbolForEntityName(name.left)
		case name.kind == SyntaxKindPropertyAccessExpression:
			parentSymbol = tc.getUnresolvedSymbolForEntityName(name.expression)
		default:
			parentSymbol = nil
		}
		var path string
		if parentSymbol {
			path = __TEMPLATE__(tc.getSymbolPath(parentSymbol), ".", text)
		} else {
			path = text /* as string */
		}
		result := tc.unresolvedSymbols.get(path)
		if !result {
			tc.unresolvedSymbols.set(path /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved) */, TODO)
			result.parent = parentSymbol
			result.links.declaredType = tc.unresolvedType
		}
		return result
	}
	return tc.unknownSymbol
}

func (tc *TypeChecker) resolveTypeReferenceName(typeReference TypeReferenceType, meaning SymbolFlags, ignoreErrors bool) Symbol {
	name := tc.getTypeReferenceName(typeReference)
	if !name {
		return tc.unknownSymbol
	}
	symbol := tc.resolveEntityName(name, meaning, ignoreErrors)
	switch {
	case symbol && symbol != tc.unknownSymbol:
		return symbol
	case ignoreErrors:
		return tc.unknownSymbol
	default:
		return tc.getUnresolvedSymbolForEntityName(name)
	}
}

func (tc *TypeChecker) getTypeReferenceType(node NodeWithTypeArguments, symbol Symbol) Type {
	if symbol == tc.unknownSymbol {
		return tc.errorType
	}
	symbol = tc.getExpandoSymbol(symbol) || symbol
	if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
		return tc.getTypeFromClassOrInterfaceReference(node, symbol)
	}
	if symbol.flags & SymbolFlagsTypeAlias {
		return tc.getTypeFromTypeAliasReference(node, symbol)
	}
	// Get type from reference to named type that cannot be generic (enum or type parameter)
	res := tc.tryGetDeclaredTypeOfSymbol(symbol)
	if res {
		if tc.checkNoTypeArguments(node, symbol) {
			return tc.getRegularTypeOfLiteralType(res)
		} else {
			return tc.errorType
		}
	}
	if symbol.flags&SymbolFlagsValue && tc.isJSDocTypeReference(node) {
		jsdocType := tc.getTypeFromJSDocValueReference(node, symbol)
		if jsdocType {
			return jsdocType
		} else {
			// Resolve the type reference as a Type for the purpose of reporting errors.
			tc.resolveTypeReferenceName(node, SymbolFlagsType)
			return tc.getTypeOfSymbol(symbol)
		}
	}
	return tc.errorType
}

/**
 * A JSdoc TypeReference may be to a value, but resolve it as a type anyway.
 * Example: import('./b').ConstructorFunction
 */

func (tc *TypeChecker) getTypeFromJSDocValueReference(node NodeWithTypeArguments, symbol Symbol) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedJSDocType {
		valueType := tc.getTypeOfSymbol(symbol)
		typeType := valueType
		if symbol.valueDeclaration {
			isImportTypeWithQualifier := node.kind == SyntaxKindImportType && (node /* as ImportTypeNode */).qualifier
			// valueType might not have a symbol, eg, {import('./b').STRING_LITERAL}
			if valueType.symbol && valueType.symbol != symbol && isImportTypeWithQualifier {
				typeType = tc.getTypeReferenceType(node, valueType.symbol)
			}
		}
		links.resolvedJSDocType = typeType
	}
	return links.resolvedJSDocType
}

func (tc *TypeChecker) getNoInferType(type_ Type) Type {
	if tc.isNoInferTargetType(type_) {
		return tc.getOrCreateSubstitutionType(type_, tc.unknownType)
	} else {
		return type_
	}
}

func (tc *TypeChecker) isNoInferTargetType(type_ Type) bool {
	// This is effectively a more conservative and predictable form of couldContainTypeVariables. We want to
	// preserve NoInfer<T> only for types that could contain type variables, but we don't want to exhaustively
	// examine all object type members.
	return !!(type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as UnionOrIntersectionType */).types, tc.isNoInferTargetType) || type_.flags&TypeFlagsSubstitution && !tc.isNoInferType(type_) && tc.isNoInferTargetType((type_ /* as SubstitutionType */).baseType) || type_.flags&TypeFlagsObject && !tc.isEmptyAnonymousObjectType(type_) || type_.flags&(TypeFlagsInstantiable&~TypeFlagsSubstitution) && !tc.isPatternLiteralType(type_))
}

func (tc *TypeChecker) isNoInferType(type_ Type) bool {
	// A NoInfer<T> type is represented as a substitution type with a TypeFlags.Unknown constraint.
	return !!(type_.flags&TypeFlagsSubstitution && (type_ /* as SubstitutionType */).constraint.flags&TypeFlagsUnknown)
}

func (tc *TypeChecker) getSubstitutionType(baseType Type, constraint Type) Type {
	if constraint.flags&TypeFlagsAnyOrUnknown || constraint == baseType || baseType.flags&TypeFlagsAny {
		return baseType
	} else {
		return tc.getOrCreateSubstitutionType(baseType, constraint)
	}
}

func (tc *TypeChecker) getOrCreateSubstitutionType(baseType Type, constraint Type) SubstitutionType {
	id := __TEMPLATE__(tc.getTypeId(baseType), ">", tc.getTypeId(constraint))
	cached := tc.substitutionTypes.get(id)
	if cached {
		return cached
	}
	result := tc.createType(TypeFlagsSubstitution) /* as SubstitutionType */
	result.baseType = baseType
	result.constraint = constraint
	tc.substitutionTypes.set(id, result)
	return result
}

func (tc *TypeChecker) getSubstitutionIntersection(substitutionType SubstitutionType) Type {
	if tc.isNoInferType(substitutionType) {
		return substitutionType.baseType
	} else {
		return tc.getIntersectionType([]Type{substitutionType.constraint, substitutionType.baseType})
	}
}

func (tc *TypeChecker) isUnaryTupleTypeNode(node TypeNode) bool {
	return node.kind == SyntaxKindTupleType && (node /* as TupleTypeNode */).elements.length == 1
}

func (tc *TypeChecker) getImpliedConstraint(type_ Type, checkNode TypeNode, extendsNode TypeNode) Type {
	switch {
	case tc.isUnaryTupleTypeNode(checkNode) && tc.isUnaryTupleTypeNode(extendsNode):
		return tc.getImpliedConstraint(type_, (checkNode /* as TupleTypeNode */).elements[0], (extendsNode /* as TupleTypeNode */).elements[0])
	case tc.getActualTypeVariable(tc.getTypeFromTypeNode(checkNode)) == tc.getActualTypeVariable(type_):
		return tc.getTypeFromTypeNode(extendsNode)
	default:
		return nil
	}
}

func (tc *TypeChecker) getConditionalFlowTypeOfType(type_ Type, node Node) Type {
	var constraints *[]Type
	covariant := true
	for node && !isStatement(node) && node.kind != SyntaxKindJSDoc {
		parent := node.parent
		// only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but
		// often get used in indexed accesses where they behave sortof invariantly, but our checking is lax
		if parent.kind == SyntaxKindParameter {
			covariant = !covariant
		}
		// Always substitute on type parameters, regardless of variance, since even
		// in contravariant positions, they may rely on substituted constraints to be valid
		if (covariant || type_.flags&TypeFlagsTypeVariable) && parent.kind == SyntaxKindConditionalType && node == (parent /* as ConditionalTypeNode */).trueType {
			constraint := tc.getImpliedConstraint(type_, (parent /* as ConditionalTypeNode */).checkType, (parent /* as ConditionalTypeNode */).extendsType)
			if constraint {
				constraints = append(constraints, constraint)
			}
		} else if type_.flags&TypeFlagsTypeParameter && parent.kind == SyntaxKindMappedType && !(parent /* as MappedTypeNode */).nameType && node == (parent /* as MappedTypeNode */).type_ {
			mappedType := tc.getTypeFromTypeNode(parent /* as TypeNode */) /* as MappedType */
			if tc.getTypeParameterFromMappedType(mappedType) == tc.getActualTypeVariable(type_) {
				typeParameter := tc.getHomomorphicTypeVariable(mappedType)
				if typeParameter {
					constraint := tc.getConstraintOfTypeParameter(typeParameter)
					if constraint && tc.everyType(constraint, tc.isArrayOrTupleType) {
						constraints = append(constraints, tc.getUnionType([]Type{tc.numberType, tc.numericStringType}))
					}
				}
			}
		}
		node = parent
	}
	if constraints {
		return tc.getSubstitutionType(type_, tc.getIntersectionType(constraints))
	} else {
		return type_
	}
}

func (tc *TypeChecker) isJSDocTypeReference(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is TypeReferenceNode */ any {
	return !!(node.flags & NodeFlagsJSDoc) && (node.kind == SyntaxKindTypeReference || node.kind == SyntaxKindImportType)
}

func (tc *TypeChecker) checkNoTypeArguments(node NodeWithTypeArguments, symbol Symbol) bool {
	if node.typeArguments {
		tc.error(node, Diagnostics.Type_0_is_not_generic, __COND__(symbol, tc.symbolToString(symbol), __COND__((node /* as TypeReferenceNode */).typeName, declarationNameToString((node /* as TypeReferenceNode */).typeName), anon)))
		return false
	}
	return true
}

func (tc *TypeChecker) getIntendedTypeFromJSDocTypeReference(node TypeReferenceNode) Type {
	if isIdentifier(node.typeName) {
		typeArgs := node.typeArguments
		switch node.typeName.escapedText {
		case "String":
			tc.checkNoTypeArguments(node)
			return tc.stringType
		case "Number":
			tc.checkNoTypeArguments(node)
			return tc.numberType
		case "Boolean":
			tc.checkNoTypeArguments(node)
			return tc.booleanType
		case "Void":
			tc.checkNoTypeArguments(node)
			return tc.voidType
		case "Undefined":
			tc.checkNoTypeArguments(node)
			return tc.undefinedType
		case "Null":
			tc.checkNoTypeArguments(node)
			return tc.nullType
		case "Function",
			"function":
			tc.checkNoTypeArguments(node)
			return tc.globalFunctionType
		case "array":
			if (!typeArgs || !typeArgs.length) && !tc.noImplicitAny {
				return tc.anyArrayType
			} else {
				return nil
			}
		case "promise":
			if (!typeArgs || !typeArgs.length) && !tc.noImplicitAny {
				return tc.createPromiseType(tc.anyType)
			} else {
				return nil
			}
		case "Object":
			if typeArgs && typeArgs.length == 2 {
				if isJSDocIndexSignature(node) {
					indexed := tc.getTypeFromTypeNode(typeArgs[0])
					target := tc.getTypeFromTypeNode(typeArgs[1])
					var indexInfo []IndexInfo
					if indexed == tc.stringType || indexed == tc.numberType {
						indexInfo = []IndexInfo{tc.createIndexInfo(indexed, target /*isReadonly*/, false)}
					} else {
						indexInfo = emptyArray
					}
					return tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, indexInfo)
				}
				return tc.anyType
			}
			tc.checkNoTypeArguments(node)
			if !tc.noImplicitAny {
				return tc.anyType
			} else {
				return nil
			}
		}
	}
}

func (tc *TypeChecker) getTypeFromJSDocNullableTypeNode(node JSDocNullableType) Type {
	type_ := tc.getTypeFromTypeNode(node.type_)
	if tc.strictNullChecks {
		return tc.getNullableType(type_, TypeFlagsNull)
	} else {
		return type_
	}
}

func (tc *TypeChecker) getTypeFromTypeReference(node TypeReferenceType) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		// handle LS queries on the `const` in `x as const` by resolving to the type of `x`
		if isConstTypeReference(node) && isAssertionExpression(node.parent) {
			links.resolvedSymbol = tc.unknownSymbol
			links.resolvedType = tc.checkExpressionCached(node.parent.expression)
			return links.resolvedType
		}
		var symbol Symbol
		var type_ Type
		meaning := SymbolFlagsType
		if tc.isJSDocTypeReference(node) {
			type_ = tc.getIntendedTypeFromJSDocTypeReference(node)
			if !type_ {
				symbol = tc.resolveTypeReferenceName(node, meaning /*ignoreErrors*/, true)
				if symbol == tc.unknownSymbol {
					symbol = tc.resolveTypeReferenceName(node, meaning|SymbolFlagsValue)
				} else {
					tc.resolveTypeReferenceName(node, meaning)
					// Resolve again to mark errors, if any
				}
				type_ = tc.getTypeReferenceType(node, symbol)
			}
		}
		if !type_ {
			symbol = tc.resolveTypeReferenceName(node, meaning)
			type_ = tc.getTypeReferenceType(node, symbol)
		}
		// Cache both the resolved symbol and the resolved type. The resolved symbol is needed when we check the
		// type reference in checkTypeReferenceNode.
		links.resolvedSymbol = symbol
		links.resolvedType = type_
	}
	return links.resolvedType
}

func (tc *TypeChecker) typeArgumentsFromTypeReferenceNode(node NodeWithTypeArguments) *[]Type {
	return map_(node.typeArguments, tc.getTypeFromTypeNode)
}

func (tc *TypeChecker) getTypeFromTypeQueryNode(node TypeQueryNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		// TypeScript 1.0 spec (April 2014): 3.6.3
		// The expression is processed as an identifier expression (section 4.3)
		// or property access expression(section 4.10),
		// the widened type(section 3.9) of which becomes the result.
		type_ := tc.checkExpressionWithTypeArguments(node)
		links.resolvedType = tc.getRegularTypeOfLiteralType(tc.getWidenedType(type_))
	}
	return links.resolvedType
}

func (tc *TypeChecker) getTypeOfGlobalSymbol(symbol Symbol, arity number) ObjectType {
	getTypeDeclaration := func(symbol Symbol) Declaration {
		declarations := symbol.declarations
		if declarations {
			for _, declaration := range declarations {
				switch declaration.kind {
				case SyntaxKindClassDeclaration,
					SyntaxKindInterfaceDeclaration,
					SyntaxKindEnumDeclaration:
					return declaration
				}
			}
		}
	}

	if !symbol {
		if arity {
			return tc.emptyGenericType
		} else {
			return tc.emptyObjectType
		}
	}
	type_ := tc.getDeclaredTypeOfSymbol(symbol)
	if !(type_.flags & TypeFlagsObject) {
		tc.error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol))
		if arity {
			return tc.emptyGenericType
		} else {
			return tc.emptyObjectType
		}
	}
	if length((type_ /* as InterfaceType */).typeParameters) != arity {
		tc.error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
		if arity {
			return tc.emptyGenericType
		} else {
			return tc.emptyObjectType
		}
	}
	return type_ /* as ObjectType */
}

func (tc *TypeChecker) getGlobalValueSymbol(name __String, reportErrors bool) Symbol {
	return tc.getGlobalSymbol(name, SymbolFlagsValue, __COND__(reportErrors, Diagnostics.Cannot_find_global_value_0, nil))
}

func (tc *TypeChecker) getGlobalTypeSymbol(name __String, reportErrors bool) Symbol {
	return tc.getGlobalSymbol(name, SymbolFlagsType, __COND__(reportErrors, Diagnostics.Cannot_find_global_type_0, nil))
}

func (tc *TypeChecker) getGlobalTypeAliasSymbol(name __String, arity number, reportErrors bool) Symbol {
	symbol := tc.getGlobalSymbol(name, SymbolFlagsType, __COND__(reportErrors, Diagnostics.Cannot_find_global_type_0, nil))
	if symbol {
		// Resolve the declared type of the symbol. This resolves type parameters for the type
		// alias so that we can check arity.
		tc.getDeclaredTypeOfSymbol(symbol)
		if length(tc.getSymbolLinks(symbol).typeParameters) != arity {
			decl := symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration)
			tc.error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
			return nil
		}
	}
	return symbol
}

func (tc *TypeChecker) getGlobalSymbol(name __String, meaning SymbolFlags, diagnostic *DiagnosticMessage) Symbol {
	// Don't track references for global symbols anyway, so value if `isReference` is arbitrary
	return tc.resolveName(nil, name, meaning, diagnostic /*isUse*/, false /*excludeGlobals*/, false)
}

/* OVERLOAD: function getGlobalType(name: __String, arity: 0, reportErrors: true): ObjectType; */
/* OVERLOAD: function getGlobalType(name: __String, arity: 0, reportErrors: boolean): ObjectType | undefined; */
/* OVERLOAD: function getGlobalType(name: __String, arity: number, reportErrors: true): GenericType; */
/* OVERLOAD: function getGlobalType(name: __String, arity: number, reportErrors: boolean): GenericType | undefined; */
func (tc *TypeChecker) getGlobalType(name __String, arity number, reportErrors bool) *ObjectType {
	symbol := tc.getGlobalTypeSymbol(name, reportErrors)
	if symbol || reportErrors {
		return tc.getTypeOfGlobalSymbol(symbol, arity)
	} else {
		return nil
	}
}

/* OVERLOAD: function getGlobalBuiltinTypes(typeNames: readonly string[], arity: 0): ObjectType[]; */
/* OVERLOAD: function getGlobalBuiltinTypes(typeNames: readonly string[], arity: number): GenericType[]; */
func (tc *TypeChecker) getGlobalBuiltinTypes(typeNames []string, arity number) []Type {
	var types *[]Type
	for _, typeName := range typeNames {
		types = append(types, tc.getGlobalType(typeName /* as __String */, arity /*reportErrors*/, false))
	}
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: types ?? emptyArray */ TODO
}

func (tc *TypeChecker) getGlobalTypedPropertyDescriptorType() GenericType {
	// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
	tc.deferredGlobalTypedPropertyDescriptorType = tc.deferredGlobalTypedPropertyDescriptorType || tc.getGlobalType("TypedPropertyDescriptor" /* as __String */ /*arity*/, 1 /*reportErrors*/, true) || tc.emptyGenericType
	return tc.deferredGlobalTypedPropertyDescriptorType
}

func (tc *TypeChecker) getGlobalTemplateStringsArrayType() ObjectType {
	// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
	tc.deferredGlobalTemplateStringsArrayType = tc.deferredGlobalTemplateStringsArrayType || tc.getGlobalType("TemplateStringsArray" /* as __String */ /*arity*/, 0 /*reportErrors*/, true) || tc.emptyObjectType
	return tc.deferredGlobalTemplateStringsArrayType
}

func (tc *TypeChecker) getGlobalImportMetaType() ObjectType {
	// We always report an error, so store a result in the event we could not resolve the symbol to prevent reporting it multiple times
	tc.deferredGlobalImportMetaType = tc.deferredGlobalImportMetaType || tc.getGlobalType("ImportMeta" /* as __String */ /*arity*/, 0 /*reportErrors*/, true) || tc.emptyObjectType
	return tc.deferredGlobalImportMetaType
}

func (tc *TypeChecker) getGlobalImportMetaExpressionType() ObjectType {
	if !tc.deferredGlobalImportMetaExpressionType {
		// Create a synthetic type `ImportMetaExpression { meta: MetaProperty }`
		symbol := tc.createSymbol(SymbolFlagsNone, "ImportMetaExpression" /* as __String */)
		importMetaType := tc.getGlobalImportMetaType()

		metaPropertySymbol := tc.createSymbol(SymbolFlagsProperty, "meta" /* as __String */, CheckFlagsReadonly)
		metaPropertySymbol.parent = symbol
		metaPropertySymbol.links.type_ = importMetaType

		members := createSymbolTable([]TransientSymbol{metaPropertySymbol})
		symbol.members = members

		tc.deferredGlobalImportMetaExpressionType = tc.createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
	}
	return tc.deferredGlobalImportMetaExpressionType
}

func (tc *TypeChecker) getGlobalImportCallOptionsType(reportErrors bool) ObjectType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity* / 0, reportErrors) */ TODO) || tc.emptyObjectType
}

func (tc *TypeChecker) getGlobalImportAttributesType(reportErrors bool) ObjectType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity* / 0, reportErrors) */ TODO) || tc.emptyObjectType
}

func (tc *TypeChecker) getGlobalESSymbolConstructorSymbol(reportErrors bool) Symbol {
	tc.deferredGlobalESSymbolConstructorSymbol = tc.deferredGlobalESSymbolConstructorSymbol || tc.getGlobalValueSymbol("Symbol" /* as __String */, reportErrors)
	return tc.deferredGlobalESSymbolConstructorSymbol
}

func (tc *TypeChecker) getGlobalESSymbolConstructorTypeSymbol(reportErrors bool) Symbol {
	tc.deferredGlobalESSymbolConstructorTypeSymbol = tc.deferredGlobalESSymbolConstructorTypeSymbol || tc.getGlobalTypeSymbol("SymbolConstructor" /* as __String */, reportErrors)
	return tc.deferredGlobalESSymbolConstructorTypeSymbol
}

func (tc *TypeChecker) getGlobalESSymbolType() ObjectType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || tc.emptyObjectType
}

func (tc *TypeChecker) getGlobalPromiseType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity* / 1, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalPromiseLikeType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity* / 1, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalPromiseConstructorSymbol(reportErrors bool) Symbol {
	tc.deferredGlobalPromiseConstructorSymbol = tc.deferredGlobalPromiseConstructorSymbol || tc.getGlobalValueSymbol("Promise" /* as __String */, reportErrors)
	return tc.deferredGlobalPromiseConstructorSymbol
}

func (tc *TypeChecker) getGlobalPromiseConstructorLikeType(reportErrors bool) ObjectType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity* / 0, reportErrors) */ TODO) || tc.emptyObjectType
}

func (tc *TypeChecker) getGlobalAsyncIterableType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalAsyncIteratorType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalAsyncIterableIteratorType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalBuiltinAsyncIteratorTypes() []GenericType {
	// NOTE: This list does not include all built-in async iterator types, only those that are likely to be encountered frequently.
	return /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1) */ TODO
}

func (tc *TypeChecker) getGlobalAsyncIteratorObjectType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalAsyncGeneratorType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalIterableType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalIteratorType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalIterableIteratorType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getBuiltinIteratorReturnType() IntrinsicType {
	if tc.strictBuiltinIteratorReturn {
		return tc.undefinedType
	} else {
		return tc.anyType
	}
}

func (tc *TypeChecker) getGlobalBuiltinIteratorTypes() []GenericType {
	// NOTE: This list does not include all built-in iterator types, only those that are likely to be encountered frequently.
	return /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1) */ TODO
}

func (tc *TypeChecker) getGlobalIteratorObjectType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalGeneratorType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity* / 3, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalIteratorYieldResultType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity* / 1, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalIteratorReturnResultType(reportErrors bool) GenericType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity* / 1, reportErrors) */ TODO) || tc.emptyGenericType
}

func (tc *TypeChecker) getGlobalDisposableType(reportErrors bool) ObjectType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity* / 0, reportErrors) */ TODO) || tc.emptyObjectType
}

func (tc *TypeChecker) getGlobalAsyncDisposableType(reportErrors bool) ObjectType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity* / 0, reportErrors) */ TODO) || tc.emptyObjectType
}

func (tc *TypeChecker) getGlobalTypeOrUndefined(name __String, arity number /*  = 0 */) *ObjectType {
	symbol := tc.getGlobalSymbol(name, SymbolFlagsType /*diagnostic*/, nil)
	return symbol && tc.getTypeOfGlobalSymbol(symbol, arity) /* as GenericType */
}

func (tc *TypeChecker) getGlobalExtractSymbol() Symbol {
	// We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
	tc.deferredGlobalExtractSymbol = tc.deferredGlobalExtractSymbol || tc.getGlobalTypeAliasSymbol("Extract" /* as __String */ /*arity*/, 2 /*reportErrors*/, true) || tc.unknownSymbol
	if tc.deferredGlobalExtractSymbol == tc.unknownSymbol {
		return nil
	} else {
		return tc.deferredGlobalExtractSymbol
	}
}

func (tc *TypeChecker) getGlobalOmitSymbol() Symbol {
	// We always report an error, so cache a result in the event we could not resolve the symbol to prevent reporting it multiple times
	tc.deferredGlobalOmitSymbol = tc.deferredGlobalOmitSymbol || tc.getGlobalTypeAliasSymbol("Omit" /* as __String */ /*arity*/, 2 /*reportErrors*/, true) || tc.unknownSymbol
	if tc.deferredGlobalOmitSymbol == tc.unknownSymbol {
		return nil
	} else {
		return tc.deferredGlobalOmitSymbol
	}
}

func (tc *TypeChecker) getGlobalAwaitedSymbol(reportErrors bool) Symbol {
	// Only cache `unknownSymbol` if we are reporting errors so that we don't report the error more than once.
	tc.deferredGlobalAwaitedSymbol = tc.deferredGlobalAwaitedSymbol || tc.getGlobalTypeAliasSymbol("Awaited" /* as __String */ /*arity*/, 1, reportErrors) || (__COND__(reportErrors, tc.unknownSymbol, nil))
	if tc.deferredGlobalAwaitedSymbol == tc.unknownSymbol {
		return nil
	} else {
		return tc.deferredGlobalAwaitedSymbol
	}
}

func (tc *TypeChecker) getGlobalBigIntType() ObjectType {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || tc.emptyObjectType
}

func (tc *TypeChecker) getGlobalClassDecoratorContextType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity* / 1, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalClassMethodDecoratorContextType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalClassGetterDecoratorContextType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalClassSetterDecoratorContextType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalClassAccessorDecoratorContextType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalClassAccessorDecoratorTargetType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalClassAccessorDecoratorResultType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalClassFieldDecoratorContextType(reportErrors bool) GenericType {
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
}

func (tc *TypeChecker) getGlobalNaNSymbol() Symbol {
	return ( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors* / false) */ TODO)
}

func (tc *TypeChecker) getGlobalRecordSymbol() Symbol {
	tc.deferredGlobalRecordSymbol = tc.deferredGlobalRecordSymbol || tc.getGlobalTypeAliasSymbol("Record" /* as __String */ /*arity*/, 2 /*reportErrors*/, true) || tc.unknownSymbol
	if tc.deferredGlobalRecordSymbol == tc.unknownSymbol {
		return nil
	} else {
		return tc.deferredGlobalRecordSymbol
	}
}

/**
 * Instantiates a global type that is generic with some element type, and returns that instantiation.
 */

func (tc *TypeChecker) createTypeFromGenericGlobalType(genericGlobalType GenericType, typeArguments []Type) ObjectType {
	if genericGlobalType != tc.emptyGenericType {
		return tc.createTypeReference(genericGlobalType, typeArguments)
	} else {
		return tc.emptyObjectType
	}
}

func (tc *TypeChecker) createTypedPropertyDescriptorType(propertyType Type) Type {
	return tc.createTypeFromGenericGlobalType(tc.getGlobalTypedPropertyDescriptorType(), []Type{propertyType})
}

func (tc *TypeChecker) createIterableType(iteratedType Type) Type {
	return tc.createTypeFromGenericGlobalType(tc.getGlobalIterableType(true), []Type{iteratedType, tc.voidType, tc.undefinedType})
}

func (tc *TypeChecker) createArrayType(elementType Type, readonly bool) ObjectType {
	return tc.createTypeFromGenericGlobalType(__COND__(readonly, tc.globalReadonlyArrayType, tc.globalArrayType), []Type{elementType})
}

func (tc *TypeChecker) getTupleElementFlags(node TypeNode) /* TODO(TS-TO-GO) inferred type ElementFlags.Required | ElementFlags.Optional | ElementFlags.Rest | ElementFlags.Variadic */ any {
	switch node.kind {
	case SyntaxKindOptionalType:
		return ElementFlagsOptional
	case SyntaxKindRestType:
		return tc.getRestTypeElementFlags(node /* as RestTypeNode */)
	case SyntaxKindNamedTupleMember:
		switch {
		case (node /* as NamedTupleMember */).questionToken:
			return ElementFlagsOptional
		case (node /* as NamedTupleMember */).dotDotDotToken:
			return tc.getRestTypeElementFlags(node /* as NamedTupleMember */)
		default:
			return ElementFlagsRequired
		}
	default:
		return ElementFlagsRequired
	}
}

func (tc *TypeChecker) getRestTypeElementFlags(node /* TODO(TS-TO-GO) TypeNode UnionType: RestTypeNode | NamedTupleMember */ any) /* TODO(TS-TO-GO) inferred type ElementFlags.Rest | ElementFlags.Variadic */ any {
	if tc.getArrayElementTypeNode(node.type_) {
		return ElementFlagsRest
	} else {
		return ElementFlagsVariadic
	}
}

func (tc *TypeChecker) getArrayOrTupleTargetType(node /* TODO(TS-TO-GO) TypeNode UnionType: ArrayTypeNode | TupleTypeNode */ any) GenericType {
	readonly := tc.isReadonlyTypeOperator(node.parent)
	elementType := tc.getArrayElementTypeNode(node)
	if elementType {
		if readonly {
			return tc.globalReadonlyArrayType
		} else {
			return tc.globalArrayType
		}
	}
	elementFlags := map_((node /* as TupleTypeNode */).elements, tc.getTupleElementFlags)
	return tc.getTupleTargetType(elementFlags, readonly, map_((node /* as TupleTypeNode */).elements, tc.memberIfLabeledElementDeclaration))
}

func (tc *TypeChecker) memberIfLabeledElementDeclaration(member Node) /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any {
	if isNamedTupleMember(member) || isParameter(member) {
		return member
	} else {
		return nil
	}
}

// Return true if the given type reference node is directly aliased or if it needs to be deferred
// because it is possibly contained in a circular chain of eagerly resolved types.
func (tc *TypeChecker) isDeferredTypeReferenceNode(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, hasDefaultTypeArguments bool) bool {
	return !!tc.getAliasSymbolForTypeNode(node) || tc.isResolvedByTypeAlias(node) && (__COND__(node.kind == SyntaxKindArrayType, tc.mayResolveTypeAlias(node.elementType), __COND__(node.kind == SyntaxKindTupleType, some(node.elements, tc.mayResolveTypeAlias), hasDefaultTypeArguments || some(node.typeArguments, tc.mayResolveTypeAlias))))
}

// Return true when the given node is transitively contained in type constructs that eagerly
// resolve their constituent types. We include SyntaxKind.TypeReference because type arguments
// of type aliases are eagerly resolved.
func (tc *TypeChecker) isResolvedByTypeAlias(node Node) bool {
	parent := node.parent
	switch parent.kind {
	case SyntaxKindParenthesizedType,
		SyntaxKindNamedTupleMember,
		SyntaxKindTypeReference,
		SyntaxKindUnionType,
		SyntaxKindIntersectionType,
		SyntaxKindIndexedAccessType,
		SyntaxKindConditionalType,
		SyntaxKindTypeOperator,
		SyntaxKindArrayType,
		SyntaxKindTupleType:
		return tc.isResolvedByTypeAlias(parent)
	case SyntaxKindTypeAliasDeclaration:
		return true
	}
	return false
}

// Return true if resolving the given node (i.e. getTypeFromTypeNode) possibly causes resolution
// of a type alias.
func (tc *TypeChecker) mayResolveTypeAlias(node Node) bool {
	switch node.kind {
	case SyntaxKindTypeReference:
		return tc.isJSDocTypeReference(node) || !!(tc.resolveTypeReferenceName(node /* as TypeReferenceNode */, SymbolFlagsType).flags & SymbolFlagsTypeAlias)
	case SyntaxKindTypeQuery:
		return true
	case SyntaxKindTypeOperator:
		return (node /* as TypeOperatorNode */).operator != SyntaxKindUniqueKeyword && tc.mayResolveTypeAlias((node /* as TypeOperatorNode */).type_)
	case SyntaxKindParenthesizedType,
		SyntaxKindOptionalType,
		SyntaxKindNamedTupleMember,
		SyntaxKindJSDocOptionalType,
		SyntaxKindJSDocNullableType,
		SyntaxKindJSDocNonNullableType,
		SyntaxKindJSDocTypeExpression:
		return tc.mayResolveTypeAlias((node /* as ParenthesizedTypeNode | OptionalTypeNode | JSDocTypeReferencingNode | NamedTupleMember */).type_)
	case SyntaxKindRestType:
		return (node /* as RestTypeNode */).type_.kind != SyntaxKindArrayType || tc.mayResolveTypeAlias(((node /* as RestTypeNode */).type_ /* as ArrayTypeNode */).elementType)
	case SyntaxKindUnionType,
		SyntaxKindIntersectionType:
		return some((node /* as UnionOrIntersectionTypeNode */).types, tc.mayResolveTypeAlias)
	case SyntaxKindIndexedAccessType:
		return tc.mayResolveTypeAlias((node /* as IndexedAccessTypeNode */).objectType) || tc.mayResolveTypeAlias((node /* as IndexedAccessTypeNode */).indexType)
	case SyntaxKindConditionalType:
		return tc.mayResolveTypeAlias((node /* as ConditionalTypeNode */).checkType) || tc.mayResolveTypeAlias((node /* as ConditionalTypeNode */).extendsType) || tc.mayResolveTypeAlias((node /* as ConditionalTypeNode */).trueType) || tc.mayResolveTypeAlias((node /* as ConditionalTypeNode */).falseType)
	}
	return false
}

func (tc *TypeChecker) getTypeFromArrayOrTupleTypeNode(node /* TODO(TS-TO-GO) TypeNode UnionType: ArrayTypeNode | TupleTypeNode */ any) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		target := tc.getArrayOrTupleTargetType(node)
		if target == tc.emptyGenericType {
			links.resolvedType = tc.emptyObjectType
		} else if !(node.kind == SyntaxKindTupleType && some(node.elements, func(e /* TODO(TS-TO-GO) inferred type TypeNode | NamedTupleMember */ any) bool {
			return !!(tc.getTupleElementFlags(e) & ElementFlagsVariadic)
		})) && tc.isDeferredTypeReferenceNode(node) {
			if node.kind == SyntaxKindTupleType && node.elements.length == 0 {
				links.resolvedType = target
			} else {
				links.resolvedType = tc.createDeferredTypeReference(target, node /*mapper*/, nil)
			}
		} else {
			var elementTypes []Type
			if node.kind == SyntaxKindArrayType {
				elementTypes = []Type{tc.getTypeFromTypeNode(node.elementType)}
			} else {
				elementTypes = map_(node.elements, tc.getTypeFromTypeNode)
			}
			links.resolvedType = tc.createNormalizedTypeReference(target, elementTypes)
		}
	}
	return links.resolvedType
}

func (tc *TypeChecker) isReadonlyTypeOperator(node Node) bool {
	return isTypeOperatorNode(node) && node.operator == SyntaxKindReadonlyKeyword
}

func (tc *TypeChecker) createTupleType(elementTypes []Type, elementFlags []ElementFlags, readonly bool /*  = false */, namedMemberDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any /*  = [] */) Type {
	tupleTarget := tc.getTupleTargetType(elementFlags || map_(elementTypes, func(_ Type) /* TODO(TS-TO-GO) inferred type ElementFlags.Required */ any {
		return ElementFlagsRequired
	}), readonly, namedMemberDeclarations)
	switch {
	case tupleTarget == tc.emptyGenericType:
		return tc.emptyObjectType
	case elementTypes.length:
		return tc.createNormalizedTypeReference(tupleTarget, elementTypes)
	default:
		return tupleTarget
	}
}

func (tc *TypeChecker) getTupleTargetType(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any) GenericType {
	if elementFlags.length == 1 && elementFlags[0]&ElementFlagsRest {
		// [...X[]] is equivalent to just X[]
		if readonly {
			return tc.globalReadonlyArrayType
		} else {
			return tc.globalArrayType
		}
	}
	key := map_(elementFlags, func(f ElementFlags) /* TODO(TS-TO-GO) inferred type "*" | "?" | "#" | "." */ any {
		switch {
		case f & ElementFlagsRequired:
			return "#"
		case f & ElementFlagsOptional:
			return "?"
		case f & ElementFlagsRest:
			return "."
		default:
			return "*"
		}
	}).join() + (__COND__(readonly, "R", "")) + (__COND__(some(namedMemberDeclarations, func(node * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any) bool {
		return !!node
	}), ","+map_(namedMemberDeclarations, func(node * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any) /* TODO(TS-TO-GO) inferred type number | "_" */ any {
		if node {
			return getNodeId(node)
		} else {
			return "_"
		}
	}).join(","), ""))
	type_ := tc.tupleTypes.get(key)
	if !type_ {
		tc.tupleTypes.set(key /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) */, TODO)
	}
	return type_
}

// We represent tuple types as type references to synthesized generic interface types created by
// this function. The types are of the form:
//
//	interface Tuple<T0, T1, T2, ...> extends Array<T0 | T1 | T2 | ...> { 0: T0, 1: T1, 2: T2, ... }
//
// Note that the generic type created by this function has no symbol associated with it. The same
// is true for each of the synthesized type parameters.
func (tc *TypeChecker) createTupleTargetType(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any) TupleType {
	arity := elementFlags.length
	minLength := countWhere(elementFlags, func(f ElementFlags) bool {
		return !!(f & (ElementFlagsRequired | ElementFlagsVariadic))
	})
	var typeParameters *[]TypeParameter
	var properties []Symbol = []never{}
	combinedFlags := 0 /* as ElementFlags */
	if arity {
		typeParameters = NewArray(arity)
		for i := 0; i < arity; i++ {
			typeParameter := /* TODO(TS-TO-GO) EqualsToken BinaryExpression: typeParameters[i] = createTypeParameter() */ TODO
			flags := elementFlags[i]
			combinedFlags |= flags
			if !(combinedFlags & ElementFlagsVariable) {
				property := tc.createSymbol(SymbolFlagsProperty|(__COND__(flags&ElementFlagsOptional, SymbolFlagsOptional, 0)), ""+i /* as __String */, __COND__(readonly, CheckFlagsReadonly, 0))
				property.links.tupleLabelDeclaration = namedMemberDeclarations[i]
				property.links.type_ = typeParameter
				properties.push(property)
			}
		}
	}
	fixedLength := properties.length
	lengthSymbol := tc.createSymbol(SymbolFlagsProperty, "length" /* as __String */, __COND__(readonly, CheckFlagsReadonly, 0))
	if combinedFlags & ElementFlagsVariable {
		lengthSymbol.links.type_ = tc.numberType
	} else {
		literalTypes := []never{}
		for i := minLength; i <= arity; i++ {
			literalTypes.push(tc.getNumberLiteralType(i))
		}
		lengthSymbol.links.type_ = tc.getUnionType(literalTypes)
	}
	properties.push(lengthSymbol)
	type_ := tc.createObjectType(ObjectFlagsTuple | ObjectFlagsReference) /* as TupleType & InterfaceTypeWithDeclaredMembers */
	type_.typeParameters = typeParameters
	type_.outerTypeParameters = nil
	type_.localTypeParameters = typeParameters
	type_.instantiations = NewMap[string, TypeReference]()
	type_.instantiations.set(tc.getTypeListId(type_.typeParameters), type_ /* as GenericType */)
	type_.target = type_ /* as GenericType */
	type_.resolvedTypeArguments = type_.typeParameters
	type_.thisType = tc.createTypeParameter()
	type_.thisType.isThisType = true
	type_.thisType.constraint = type_
	type_.declaredProperties = properties
	type_.declaredCallSignatures = emptyArray
	type_.declaredConstructSignatures = emptyArray
	type_.declaredIndexInfos = emptyArray
	type_.elementFlags = elementFlags
	type_.minLength = minLength
	type_.fixedLength = fixedLength
	type_.hasRestElement = !!(combinedFlags & ElementFlagsVariable)
	type_.combinedFlags = combinedFlags
	type_.readonly = readonly
	type_.labeledElementDeclarations = namedMemberDeclarations
	return type_
}

func (tc *TypeChecker) createNormalizedTypeReference(target GenericType, typeArguments *[]Type) Type {
	if target.objectFlags & ObjectFlagsTuple {
		return tc.createNormalizedTupleType(target /* as TupleType */, typeArguments)
	} else {
		return tc.createTypeReference(target, typeArguments)
	}
}

func (tc *TypeChecker) createNormalizedTupleType(target TupleType, elementTypes []Type) Type {
	if !(target.combinedFlags & ElementFlagsNonRequired) {
		// No need to normalize when we only have regular required elements
		return tc.createTypeReference(target, elementTypes)
	}
	if target.combinedFlags & ElementFlagsVariadic {
		// Transform [A, ...(X | Y | Z)] into [A, ...X] | [A, ...Y] | [A, ...Z]
		unionIndex := findIndex(elementTypes, func(t Type, i number) bool {
			return !!(target.elementFlags[i]&ElementFlagsVariadic && t.flags&(TypeFlagsNever|TypeFlagsUnion))
		})
		if unionIndex >= 0 {
			if tc.checkCrossProductUnion(map_(elementTypes, func(t Type, i number) Type {
				if target.elementFlags[i] & ElementFlagsVariadic {
					return t
				} else {
					return tc.unknownType
				}
			})) {
				return tc.mapType(elementTypes[unionIndex], func(t Type) Type {
					return tc.createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))
				})
			} else {
				return tc.errorType
			}
		}
	}
	// We have optional, rest, or variadic elements that may need normalizing. Normalization ensures that all variadic
	// elements are generic and that the tuple type has one of the following layouts, disregarding variadic elements:
	// (1) Zero or more required elements, followed by zero or more optional elements, followed by zero or one rest element.
	// (2) Zero or more required elements, followed by a rest element, followed by zero or more required elements.
	// In either layout, zero or more generic variadic elements may be present at any location.
	var expandedTypes []Type = []never{}
	var expandedFlags []ElementFlags = []never{}
	var expandedDeclarations [] /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any = []never{}
	lastRequiredIndex := -1
	firstRestIndex := -1
	lastOptionalOrRestIndex := -1
	for i := 0; i < elementTypes.length; i++ {
		type_ := elementTypes[i]
		flags := target.elementFlags[i]
		if flags & ElementFlagsVariadic {
			if type_.flags & TypeFlagsAny {
				addElement(type_, ElementFlagsRest, target.labeledElementDeclarations[i])
			} else if type_.flags&TypeFlagsInstantiableNonPrimitive || tc.isGenericMappedType(type_) {
				// Generic variadic elements stay as they are.
				addElement(type_, ElementFlagsVariadic, target.labeledElementDeclarations[i])
			} else if tc.isTupleType(type_) {
				elements := tc.getElementTypes(type_)
				if elements.length+expandedTypes.length >= 10_000 {
					tc.error(tc.currentNode, __COND__(isPartOfTypeNode(tc.currentNode), Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent, Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent))
					return tc.errorType
				}
				// Spread variadic elements with tuple types into the resulting tuple.
				forEach(elements, func(t Type, n number) {
					return addElement(t, type_.target.elementFlags[n], type_.target.labeledElementDeclarations[n])
				})
			} else {
				// Treat everything else as an array type and create a rest element.
				addElement(tc.isArrayLikeType(type_) && tc.getIndexTypeOfType(type_, tc.numberType) || tc.errorType, ElementFlagsRest, target.labeledElementDeclarations[i])
			}
		} else {
			// Copy other element kinds with no change.
			addElement(type_, flags, target.labeledElementDeclarations[i])
		}
	}
	// Turn optional elements preceding the last required element into required elements
	for i := 0; i < lastRequiredIndex; i++ {
		if expandedFlags[i] & ElementFlagsOptional {
			expandedFlags[i] = ElementFlagsRequired
		}
	}
	if firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex {
		// Turn elements between first rest and last optional/rest into a single rest element
		expandedTypes[firstRestIndex] = tc.getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex+1), func(t Type, i number) Type {
			if expandedFlags[firstRestIndex+i] & ElementFlagsVariadic {
				return tc.getIndexedAccessType(t, tc.numberType)
			} else {
				return t
			}
		}))
		expandedTypes.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
		expandedFlags.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
		expandedDeclarations.splice(firstRestIndex+1, lastOptionalOrRestIndex-firstRestIndex)
	}
	tupleTarget := tc.getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations)
	switch {
	case tupleTarget == tc.emptyGenericType:
		return tc.emptyObjectType
	case expandedFlags.length:
		return tc.createTypeReference(tupleTarget, expandedTypes)
	default:
		return tupleTarget
	}

	addElement := func(type_ Type, flags ElementFlags, declaration /* TODO(TS-TO-GO) TypeNode UnionType: NamedTupleMember | ParameterDeclaration | undefined */ any) {
		if flags & ElementFlagsRequired {
			lastRequiredIndex = expandedFlags.length
		}
		if flags&ElementFlagsRest && firstRestIndex < 0 {
			firstRestIndex = expandedFlags.length
		}
		if flags & (ElementFlagsOptional | ElementFlagsRest) {
			lastOptionalOrRestIndex = expandedFlags.length
		}
		expandedTypes.push(__COND__(flags&ElementFlagsOptional, tc.addOptionality(type_ /*isProperty*/, true), type_))
		expandedFlags.push(flags)
		expandedDeclarations.push(declaration)
	}

}

func (tc *TypeChecker) sliceTupleType(type_ TupleTypeReference, index number, endSkipCount number /*  = 0 */) Type {
	target := type_.target
	endIndex := tc.getTypeReferenceArity(type_) - endSkipCount
	if index > target.fixedLength {
		return tc.getRestArrayTypeOfTupleType(type_) || tc.createTupleType(emptyArray)
	} else {
		return tc.createTupleType(tc.getTypeArguments(type_).slice(index, endIndex), target.elementFlags.slice(index, endIndex) /*readonly*/, false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex))
	}
}

func (tc *TypeChecker) getKnownKeysOfTupleType(type_ TupleTypeReference) Type {
	return tc.getUnionType(append(arrayOf(type_.target.fixedLength, func(i number) StringLiteralType {
		return tc.getStringLiteralType("" + i)
	}), tc.getIndexType(__COND__(type_.target.readonly, tc.globalReadonlyArrayType, tc.globalArrayType))))
}

// Return count of starting consecutive tuple elements of the given kind(s)
func (tc *TypeChecker) getStartElementCount(type_ TupleType, flags ElementFlags) number {
	index := findIndex(type_.elementFlags, func(f ElementFlags) bool {
		return !(f & flags)
	})
	if index >= 0 {
		return index
	} else {
		return type_.elementFlags.length
	}
}

// Return count of ending consecutive tuple elements of the given kind(s)
func (tc *TypeChecker) getEndElementCount(type_ TupleType, flags ElementFlags) number {
	return type_.elementFlags.length - findLastIndex(type_.elementFlags, func(f ElementFlags) bool {
		return !(f & flags)
	}) - 1
}

func (tc *TypeChecker) getTotalFixedElementCount(type_ TupleType) number {
	return type_.fixedLength + tc.getEndElementCount(type_, ElementFlagsFixed)
}

func (tc *TypeChecker) getElementTypes(type_ TupleTypeReference) []Type {
	typeArguments := tc.getTypeArguments(type_)
	arity := tc.getTypeReferenceArity(type_)
	if typeArguments.length == arity {
		return typeArguments
	} else {
		return typeArguments.slice(0, arity)
	}
}

func (tc *TypeChecker) getTypeFromOptionalTypeNode(node OptionalTypeNode) Type {
	return tc.addOptionality(tc.getTypeFromTypeNode(node.type_) /*isProperty*/, true)
}

func (tc *TypeChecker) getTypeId(type_ Type) TypeId {
	return type_.id
}

func (tc *TypeChecker) containsType(types []Type, type_ Type) bool {
	return binarySearch(types, type_, tc.getTypeId, compareValues) >= 0
}

func (tc *TypeChecker) insertType(types []Type, type_ Type) bool {
	index := binarySearch(types, type_, tc.getTypeId, compareValues)
	if index < 0 {
		types.splice(~index, 0, type_)
		return true
	}
	return false
}

func (tc *TypeChecker) addTypeToUnion(typeSet []Type, includes TypeFlags, type_ Type) TypeFlags {
	flags := type_.flags
	// We ignore 'never' types in unions
	if !(flags & TypeFlagsNever) {
		includes |= flags & TypeFlagsIncludesMask
		if flags & TypeFlagsInstantiable {
			includes |= TypeFlagsIncludesInstantiable
		}
		if flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
			includes |= TypeFlagsIncludesConstrainedTypeVariable
		}
		if type_ == tc.wildcardType {
			includes |= TypeFlagsIncludesWildcard
		}
		if tc.isErrorType(type_) {
			includes |= TypeFlagsIncludesError
		}
		if !tc.strictNullChecks && flags&TypeFlagsNullable {
			if !(getObjectFlags(type_) & ObjectFlagsContainsWideningType) {
				includes |= TypeFlagsIncludesNonWideningType
			}
		} else {
			len := typeSet.length
			var index number
			if len && type_.id > typeSet[len-1].id {
				index = ~len
			} else {
				index = binarySearch(typeSet, type_, tc.getTypeId, compareValues)
			}
			if index < 0 {
				typeSet.splice(~index, 0, type_)
			}
		}
	}
	return includes
}

// Add the given types to the given type set. Order is preserved, duplicates are removed,
// and nested types of the given kind are flattened into the set.
func (tc *TypeChecker) addTypesToUnion(typeSet []Type, includes TypeFlags, types []Type) TypeFlags {
	var lastType Type
	for _, type_ := range types {
		// We skip the type if it is the same as the last type we processed. This simple test particularly
		// saves a lot of work for large lists of the same union type, such as when resolving `Record<A, B>[A]`,
		// where A and B are large union types.
		if type_ != lastType {
			if type_.flags & TypeFlagsUnion {
				includes = tc.addTypesToUnion(typeSet, includes|(__COND__(tc.isNamedUnionType(type_), TypeFlagsUnion, 0)), (type_ /* as UnionType */).types)
			} else {
				includes = tc.addTypeToUnion(typeSet, includes, type_)
			}
			lastType = type_
		}
	}
	return includes
}

func (tc *TypeChecker) removeSubtypes(types []Type, hasObjectTypes bool) *[]Type {
	// [] and [T] immediately reduce to [] and [T] respectively
	if types.length < 2 {
		return types
	}

	id := tc.getTypeListId(types)
	match := tc.subtypeReductionCache.get(id)
	if match {
		return match
	}

	// We assume that redundant primitive types have already been removed from the types array and that there
	// are no any and unknown types in the array. Thus, the only possible supertypes for primitive types are empty
	// object types, and if none of those are present we can exclude primitive types from the subtype check.
	hasEmptyObject := hasObjectTypes && some(types, func(t Type) bool {
		return !!(t.flags & TypeFlagsObject) && !tc.isGenericMappedType(t) && tc.isEmptyResolvedType(tc.resolveStructuredTypeMembers(t /* as ObjectType */))
	})
	len := types.length
	i := len
	count := 0
	for i > 0 {
		i--
		source := types[i]
		if hasEmptyObject || source.flags&TypeFlagsStructuredOrInstantiable {
			// A type parameter with a union constraint may be a subtype of some union, but not a subtype of the
			// individual constituents of that union. For example, `T extends A | B` is a subtype of `A | B`, but not
			// a subtype of just `A` or just `B`. When we encounter such a type parameter, we therefore check if the
			// type parameter is a subtype of a union of all the other types.
			if source.flags&TypeFlagsTypeParameter && tc.getBaseConstraintOrType(source).flags&TypeFlagsUnion {
				if tc.isTypeRelatedTo(source, tc.getUnionType(map_(types, func(t Type) Type {
					if t == source {
						return tc.neverType
					} else {
						return t
					}
				})), tc.strictSubtypeRelation) {
					orderedRemoveItemAt(types, i)
				}
				continue
			}
			// Find the first property with a unit type, if any. When constituents have a property by the same name
			// but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype
			// reduction of large discriminated union types.
			var keyProperty Symbol
			if source.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsInstantiableNonPrimitive) {
				keyProperty = find(tc.getPropertiesOfType(source), func(p Symbol) bool {
					return tc.isUnitType(tc.getTypeOfSymbol(p))
				})
			} else {
				keyProperty = nil
			}
			keyPropertyType := keyProperty && tc.getRegularTypeOfLiteralType(tc.getTypeOfSymbol(keyProperty))
			for _, target := range types {
				if source != target {
					if count == 100000 {
						// After 100000 subtype checks we estimate the remaining amount of work by assuming the
						// same ratio of checks per element. If the estimated number of remaining type checks is
						// greater than 1M we deem the union type too complex to represent. This for example
						// caps union types at 1000 unique object types.
						estimatedCount := (count / (len - i)) * len
						if estimatedCount > 1000000 {
							tracing. /* ? */ instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
								"typeIds": types.map_(func(t Type) number {
									return t.id
								}),
							})
							tc.error(tc.currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
							return nil
						}
					}
					count++
					if keyProperty && target.flags&(TypeFlagsObject|TypeFlagsIntersection|TypeFlagsInstantiableNonPrimitive) {
						t := tc.getTypeOfPropertyOfType(target, keyProperty.escapedName)
						if t && tc.isUnitType(t) && tc.getRegularTypeOfLiteralType(t) != keyPropertyType {
							continue
						}
					}
					if tc.isTypeRelatedTo(source, target, tc.strictSubtypeRelation) && (!(getObjectFlags(tc.getTargetType(source)) & ObjectFlagsClass) || !(getObjectFlags(tc.getTargetType(target)) & ObjectFlagsClass) || tc.isTypeDerivedFrom(source, target)) {
						orderedRemoveItemAt(types, i)
						break
					}
				}
			}
		}
	}
	tc.subtypeReductionCache.set(id, types)
	return types
}

func (tc *TypeChecker) removeRedundantLiteralTypes(types []Type, includes TypeFlags, reduceVoidUndefined bool) {
	i := types.length
	for i > 0 {
		i--
		t := types[i]
		flags := t.flags
		remove := flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsString || flags&TypeFlagsNumberLiteral && includes&TypeFlagsNumber || flags&TypeFlagsBigIntLiteral && includes&TypeFlagsBigInt || flags&TypeFlagsUniqueESSymbol && includes&TypeFlagsESSymbol || reduceVoidUndefined && flags&TypeFlagsUndefined && includes&TypeFlagsVoid || tc.isFreshLiteralType(t) && tc.containsType(types, (t /* as LiteralType */).regularType)
		if remove {
			orderedRemoveItemAt(types, i)
		}
	}
}

func (tc *TypeChecker) removeStringLiteralsMatchedByTemplateLiterals(types []Type) {
	templates := filter(types, tc.isPatternLiteralType) /* as (TemplateLiteralType | StringMappingType)[] */
	if templates.length {
		i := types.length
		for i > 0 {
			i--
			t := types[i]
			if t.flags&TypeFlagsStringLiteral && some(templates, func(template /* TODO(TS-TO-GO) inferred type TemplateLiteralType | StringMappingType */ any) bool {
				return tc.isTypeMatchedByTemplateLiteralOrStringMapping(t, template)
			}) {
				orderedRemoveItemAt(types, i)
			}
		}
	}
}

func (tc *TypeChecker) isTypeMatchedByTemplateLiteralOrStringMapping(type_ Type, template /* TODO(TS-TO-GO) TypeNode UnionType: TemplateLiteralType | StringMappingType */ any) bool {
	if template.flags & TypeFlagsTemplateLiteral {
		return tc.isTypeMatchedByTemplateLiteralType(type_, template /* as TemplateLiteralType */)
	} else {
		return tc.isMemberOfStringMapping(type_, template)
	}
}

func (tc *TypeChecker) removeConstrainedTypeVariables(types []Type) {
	var typeVariables []TypeVariable = []never{}
	// First collect a list of the type variables occurring in constraining intersections.
	for _, type_ := range types {
		if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
			var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
			if (type_ /* as IntersectionType */).types[0].flags & TypeFlagsTypeVariable {
				index = 0
			} else {
				index = 1
			}
			pushIfUnique(typeVariables, (type_ /* as IntersectionType */).types[index])
		}
	}
	// For each type variable, check if the constraining intersections for that type variable fully
	// cover the constraint of the type variable; if so, remove the constraining intersections and
	// substitute the type variable.
	for _, typeVariable := range typeVariables {
		var primitives []Type = []never{}
		// First collect the primitive types from the constraining intersections.
		for _, type_ := range types {
			if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
				if (type_ /* as IntersectionType */).types[0].flags & TypeFlagsTypeVariable {
					index = 0
				} else {
					index = 1
				}
				if (type_ /* as IntersectionType */).types[index] == typeVariable {
					tc.insertType(primitives, (type_ /* as IntersectionType */).types[1-index])
				}
			}
		}
		// If every constituent in the type variable's constraint is covered by an intersection of the type
		// variable and that constituent, remove those intersections and substitute the type variable.
		constraint := tc.getBaseConstraintOfType(typeVariable)
		if tc.everyType(constraint, func(t Type) bool {
			return tc.containsType(primitives, t)
		}) {
			i := types.length
			for i > 0 {
				i--
				type_ := types[i]
				if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
					var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
					if (type_ /* as IntersectionType */).types[0].flags & TypeFlagsTypeVariable {
						index = 0
					} else {
						index = 1
					}
					if (type_ /* as IntersectionType */).types[index] == typeVariable && tc.containsType(primitives, (type_ /* as IntersectionType */).types[1-index]) {
						orderedRemoveItemAt(types, i)
					}
				}
			}
			tc.insertType(types, typeVariable)
		}
	}
}

func (tc *TypeChecker) isNamedUnionType(type_ Type) bool {
	return !!(type_.flags&TypeFlagsUnion && (type_.aliasSymbol || (type_ /* as UnionType */).origin))
}

func (tc *TypeChecker) addNamedUnions(namedUnions []Type, types []Type) {
	for _, t := range types {
		if t.flags & TypeFlagsUnion {
			origin := (t /* as UnionType */).origin
			if t.aliasSymbol || origin && !(origin.flags&TypeFlagsUnion) {
				pushIfUnique(namedUnions, t)
			} else if origin && origin.flags&TypeFlagsUnion {
				tc.addNamedUnions(namedUnions, (origin /* as UnionType */).types)
			}
		}
	}
}

func (tc *TypeChecker) createOriginUnionOrIntersectionType(flags TypeFlags, types []Type) UnionOrIntersectionType {
	result := tc.createOriginType(flags) /* as UnionOrIntersectionType */
	result.types = types
	return result
}

// We sort and deduplicate the constituent types based on object identity. If the subtypeReduction
// flag is specified we also reduce the constituent type set to only include types that aren't subtypes
// of other types. Subtype reduction is expensive for large union types and is possible only when union
// types are known not to circularly reference themselves (as is the case with union types created by
// expression constructs such as array literals and the || and ?: operators). Named types can
// circularly reference themselves and therefore cannot be subtype reduced during their declaration.
// For example, "type Item = string | (() => Item" is a named type that circularly references itself.
func (tc *TypeChecker) getUnionType(types []Type, unionReduction UnionReduction /*  = UnionReduction.Literal */, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
	if types.length == 0 {
		return tc.neverType
	}
	if types.length == 1 {
		return types[0]
	}
	// We optimize for the common case of unioning a union type with some other type (such as `undefined`).
	if types.length == 2 && !origin && (types[0].flags&TypeFlagsUnion || types[1].flags&TypeFlagsUnion) {
		var infix /* TODO(TS-TO-GO) inferred type "N" | "S" | "L" */ any
		switch {
		case unionReduction == UnionReductionNone:
			infix = "N"
		case unionReduction == UnionReductionSubtype:
			infix = "S"
		default:
			infix = "L"
		}
		var index /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
		if types[0].id < types[1].id {
			index = 0
		} else {
			index = 1
		}
		id := types[index].id + infix + types[1-index].id + tc.getAliasId(aliasSymbol, aliasTypeArguments)
		type_ := tc.unionOfUnionTypes.get(id)
		if !type_ {
			type_ = tc.getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments /*origin*/, nil)
			tc.unionOfUnionTypes.set(id, type_)
		}
		return type_
	}
	return tc.getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin)
}

func (tc *TypeChecker) getUnionTypeWorker(types []Type, unionReduction UnionReduction, aliasSymbol Symbol, aliasTypeArguments *[]Type, origin Type) Type {
	var typeSet *[]Type = []never{}
	includes := tc.addTypesToUnion(typeSet, 0 /* as TypeFlags */, types)
	if unionReduction != UnionReductionNone {
		if includes & TypeFlagsAnyOrUnknown {
			switch {
			case includes & TypeFlagsAny:
				switch {
				case includes & TypeFlagsIncludesWildcard:
					return tc.wildcardType
				case includes & TypeFlagsIncludesError:
					return tc.errorType
				default:
					return tc.anyType
				}
			default:
				return tc.unknownType
			}
		}
		if includes & TypeFlagsUndefined {
			// If type set contains both undefinedType and missingType, remove missingType
			if typeSet.length >= 2 && typeSet[0] == tc.undefinedType && typeSet[1] == tc.missingType {
				orderedRemoveItemAt(typeSet, 1)
			}
		}
		if includes&(TypeFlagsEnum|TypeFlagsLiteral|TypeFlagsUniqueESSymbol|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsVoid && includes&TypeFlagsUndefined {
			tc.removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReductionSubtype))
		}
		if includes&TypeFlagsStringLiteral && includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) {
			tc.removeStringLiteralsMatchedByTemplateLiterals(typeSet)
		}
		if includes & TypeFlagsIncludesConstrainedTypeVariable {
			tc.removeConstrainedTypeVariables(typeSet)
		}
		if unionReduction == UnionReductionSubtype {
			typeSet = tc.removeSubtypes(typeSet, !!(includes & TypeFlagsObject))
			if !typeSet {
				return tc.errorType
			}
		}
		if typeSet.length == 0 {
			switch {
			case includes & TypeFlagsNull:
				if includes & TypeFlagsIncludesNonWideningType {
					return tc.nullType
				} else {
					return tc.nullWideningType
				}
			case includes & TypeFlagsUndefined:
				if includes & TypeFlagsIncludesNonWideningType {
					return tc.undefinedType
				} else {
					return tc.undefinedWideningType
				}
			default:
				return tc.neverType
			}
		}
	}
	if !origin && includes&TypeFlagsUnion {
		var namedUnions []Type = []never{}
		tc.addNamedUnions(namedUnions, types)
		var reducedTypes []Type = []never{}
		for _, t := range typeSet {
			if !some(namedUnions, func(union Type) bool {
				return tc.containsType((union /* as UnionType */).types, t)
			}) {
				reducedTypes.push(t)
			}
		}
		if !aliasSymbol && namedUnions.length == 1 && reducedTypes.length == 0 {
			return namedUnions[0]
		}
		// We create a denormalized origin type only when the union was created from one or more named unions
		// (unions with alias symbols or origins) and when there is no overlap between those named unions.
		namedTypesCount := reduceLeft(namedUnions, func(sum number, union Type) number {
			return sum + (union /* as UnionType */).types.length
		}, 0)
		if namedTypesCount+reducedTypes.length == typeSet.length {
			for _, t := range namedUnions {
				tc.insertType(reducedTypes, t)
			}
			origin = tc.createOriginUnionOrIntersectionType(TypeFlagsUnion, reducedTypes)
		}
	}
	objectFlags := (__COND__(includes&TypeFlagsNotPrimitiveUnion, 0, ObjectFlagsPrimitiveUnion)) | (__COND__(includes&TypeFlagsIntersection, ObjectFlagsContainsIntersections, 0))
	return tc.getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin)
}

func (tc *TypeChecker) getUnionOrIntersectionTypePredicate(signatures []Signature, kind *TypeFlags) *TypePredicate {
	var last *TypePredicate
	var types []Type = []never{}
	for _, sig := range signatures {
		pred := tc.getTypePredicateOfSignature(sig)
		if pred {
			// Constituent type predicates must all have matching kinds. We don't create composite type predicates for assertions.
			if pred.kind != TypePredicateKindThis && pred.kind != TypePredicateKindIdentifier || last && !tc.typePredicateKindsMatch(last, pred) {
				return nil
			}
			last = pred
			types.push(pred.type_)
		} else {
			// In composite union signatures we permit and ignore signatures with a return type `false`.
			var returnType Type
			if kind != TypeFlagsIntersection {
				returnType = tc.getReturnTypeOfSignature(sig)
			} else {
				returnType = nil
			}
			if returnType != tc.falseType && returnType != tc.regularFalseType {
				return nil
			}
		}
	}
	if !last {
		return nil
	}
	compositeType := tc.getUnionOrIntersectionType(types, kind)
	return tc.createTypePredicate(last.kind, last.parameterName, last.parameterIndex, compositeType)
}

func (tc *TypeChecker) typePredicateKindsMatch(a TypePredicate, b TypePredicate) bool {
	return a.kind == b.kind && a.parameterIndex == b.parameterIndex
}

// This function assumes the constituent type list is sorted and deduplicated.
func (tc *TypeChecker) getUnionTypeFromSortedList(types []Type, precomputedObjectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
	if types.length == 0 {
		return tc.neverType
	}
	if types.length == 1 {
		return types[0]
	}
	var typeKey string
	switch {
	case !origin:
		typeKey = tc.getTypeListId(types)
	case origin.flags & TypeFlagsUnion:
		typeKey = __TEMPLATE__("|", tc.getTypeListId((origin /* as UnionType */).types))
	case origin.flags & TypeFlagsIntersection:
		typeKey = __TEMPLATE__("&", tc.getTypeListId((origin /* as IntersectionType */).types))
	default:
		typeKey = __TEMPLATE__("#", (origin /* as IndexType */).type_.id, "|", tc.getTypeListId(types))
	}
	// origin type id alone is insufficient, as `keyof x` may resolve to multiple WIP values while `x` is still resolving
	id := typeKey + tc.getAliasId(aliasSymbol, aliasTypeArguments)
	type_ := tc.unionTypes.get(id)
	if !type_ {
		type_ = tc.createType(TypeFlagsUnion) /* as UnionType */
		type_.objectFlags = precomputedObjectFlags | tc.getPropagatingFlagsOfTypes(types /*excludeKinds*/, TypeFlagsNullable)
		type_.types = types
		type_.origin = origin
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		if types.length == 2 && types[0].flags&TypeFlagsBooleanLiteral && types[1].flags&TypeFlagsBooleanLiteral {
			type_.flags |= TypeFlagsBoolean
			(type_ /* as UnionType & IntrinsicType */).intrinsicName = "boolean"
		}
		tc.unionTypes.set(id, type_)
	}
	return type_
}

func (tc *TypeChecker) getTypeFromUnionTypeNode(node UnionTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		aliasSymbol := tc.getAliasSymbolForTypeNode(node)
		links.resolvedType = tc.getUnionType(map_(node.types, tc.getTypeFromTypeNode), UnionReductionLiteral, aliasSymbol, tc.getTypeArgumentsForAliasSymbol(aliasSymbol))
	}
	return links.resolvedType
}

func (tc *TypeChecker) addTypeToIntersection(typeSet Map[string, Type], includes TypeFlags, type_ Type) TypeFlags {
	flags := type_.flags
	if flags & TypeFlagsIntersection {
		return tc.addTypesToIntersection(typeSet, includes, (type_ /* as IntersectionType */).types)
	}
	if tc.isEmptyAnonymousObjectType(type_) {
		if !(includes & TypeFlagsIncludesEmptyObject) {
			includes |= TypeFlagsIncludesEmptyObject
			typeSet.set(type_.id.toString(), type_)
		}
	} else {
		if flags & TypeFlagsAnyOrUnknown {
			if type_ == tc.wildcardType {
				includes |= TypeFlagsIncludesWildcard
			}
			if tc.isErrorType(type_) {
				includes |= TypeFlagsIncludesError
			}
		} else if tc.strictNullChecks || !(flags & TypeFlagsNullable) {
			if type_ == tc.missingType {
				includes |= TypeFlagsIncludesMissingType
				type_ = tc.undefinedType
			}
			if !typeSet.has(type_.id.toString()) {
				if type_.flags&TypeFlagsUnit && includes&TypeFlagsUnit {
					// We have seen two distinct unit types which means we should reduce to an
					// empty intersection. Adding TypeFlags.NonPrimitive causes that to happen.
					includes |= TypeFlagsNonPrimitive
				}
				typeSet.set(type_.id.toString(), type_)
			}
		}
		includes |= flags & TypeFlagsIncludesMask
	}
	return includes
}

// Add the given types to the given type set. Order is preserved, freshness is removed from literal
// types, duplicates are removed, and nested types of the given kind are flattened into the set.
func (tc *TypeChecker) addTypesToIntersection(typeSet Map[string, Type], includes TypeFlags, types []Type) TypeFlags {
	for _, type_ := range types {
		includes = tc.addTypeToIntersection(typeSet, includes, tc.getRegularTypeOfLiteralType(type_))
	}
	return includes
}

func (tc *TypeChecker) removeRedundantSupertypes(types []Type, includes TypeFlags) {
	i := types.length
	for i > 0 {
		i--
		t := types[i]
		remove := t.flags&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || t.flags&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || t.flags&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || t.flags&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || t.flags&TypeFlagsVoid && includes&TypeFlagsUndefined || tc.isEmptyAnonymousObjectType(t) && includes&TypeFlagsDefinitelyNonNullable
		if remove {
			orderedRemoveItemAt(types, i)
		}
	}
}

// Check that the given type has a match in every union. A given type is matched by
// an identical type, and a literal type is additionally matched by its corresponding
// primitive type, and missingType is matched by undefinedType (and vice versa).
func (tc *TypeChecker) eachUnionContains(unionTypes []UnionType, type_ Type) bool {
	for _, u := range tc.unionTypes {
		if !tc.containsType(u.types, type_) {
			if type_ == tc.missingType {
				return tc.containsType(u.types, tc.undefinedType)
			}
			if type_ == tc.undefinedType {
				return tc.containsType(u.types, tc.missingType)
			}
			var primitive *IntrinsicType
			switch {
			case type_.flags & TypeFlagsStringLiteral:
				primitive = tc.stringType
			case type_.flags & (TypeFlagsEnum | TypeFlagsNumberLiteral):
				primitive = tc.numberType
			case type_.flags & TypeFlagsBigIntLiteral:
				primitive = tc.bigintType
			case type_.flags & TypeFlagsUniqueESSymbol:
				primitive = tc.esSymbolType
			default:
				primitive = nil
			}
			if !primitive || !tc.containsType(u.types, primitive) {
				return false
			}
		}
	}
	return true
}

/**
 * Returns true if the intersection of the template literals and string literals is the empty set,
 * for example `get${string}` & "setX", and should reduce to never.
 */

func (tc *TypeChecker) extractRedundantTemplateLiterals(types []Type) bool {
	i := types.length
	literals := filter(types, func(t Type) bool {
		return !!(t.flags & TypeFlagsStringLiteral)
	})
	for i > 0 {
		i--
		t := types[i]
		if !(t.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) {
			continue
		}
		for _, t2 := range literals {
			if tc.isTypeSubtypeOf(t2, t) {
				// For example, `get${T}` & "getX" is just "getX", and Lowercase<string> & "foo" is just "foo"
				orderedRemoveItemAt(types, i)
				break
			} else if tc.isPatternLiteralType(t) {
				return true
			}
		}
	}
	return false
}

func (tc *TypeChecker) removeFromEach(types []Type, flag TypeFlags) {
	for i := 0; i < types.length; i++ {
		types[i] = tc.filterType(types[i], func(t Type) bool {
			return !(t.flags & flag)
		})
	}
}

// If the given list of types contains more than one union of primitive types, replace the
// first with a union containing an intersection of those primitive types, then remove the
// other unions and return true. Otherwise, do nothing and return false.
func (tc *TypeChecker) intersectUnionsOfPrimitiveTypes(types []Type) bool {
	var unionTypes *[]UnionType
	index := findIndex(types, func(t Type) bool {
		return !!(getObjectFlags(t) & ObjectFlagsPrimitiveUnion)
	})
	if index < 0 {
		return false
	}
	i := index + 1
	// Remove all but the first union of primitive types and collect them in
	// the unionTypes array.
	for i < types.length {
		t := types[i]
		if getObjectFlags(t) & ObjectFlagsPrimitiveUnion {
			(unionTypes || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: unionTypes = [types[index] as UnionType] */ TODO)).push(t /* as UnionType */)
			orderedRemoveItemAt(types, i)
		} else {
			i++
		}
	}
	// Return false if there was only one union of primitive types
	if !unionTypes {
		return false
	}
	// We have more than one union of primitive types, now intersect them. For each
	// type in each union we check if the type is matched in every union and if so
	// we include it in the result.
	var checked []Type = []never{}
	var result []Type = []never{}
	for _, u := range unionTypes {
		for _, t := range u.types {
			if tc.insertType(checked, t) {
				if tc.eachUnionContains(unionTypes, t) {
					// undefinedType/missingType should always come sorted first so we leverage that here
					if t == tc.undefinedType && result.length && result[0] == tc.missingType {
						continue
					}
					if t == tc.missingType && result.length && result[0] == tc.undefinedType {
						result[0] = tc.missingType
						continue
					}
					tc.insertType(result, t)
				}
			}
		}
	}
	// Finally replace the first union with the result
	types[index] = tc.getUnionTypeFromSortedList(result, ObjectFlagsPrimitiveUnion)
	return true
}

func (tc *TypeChecker) createIntersectionType(types []Type, objectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type) IntersectionType {
	result := tc.createType(TypeFlagsIntersection) /* as IntersectionType */
	result.objectFlags = objectFlags | tc.getPropagatingFlagsOfTypes(types /*excludeKinds*/, TypeFlagsNullable)
	result.types = types
	result.aliasSymbol = aliasSymbol
	result.aliasTypeArguments = aliasTypeArguments
	return result
}

// We normalize combinations of intersection and union types based on the distributive property of the '&'
// operator. Specifically, because X & (A | B) is equivalent to X & A | X & B, we can transform intersection
// types with union type constituents into equivalent union types with intersection type constituents and
// effectively ensure that union types are always at the top level in type representations.
//
// We do not perform structural deduplication on intersection types. Intersection types are created only by the &
// type operator and we can't reduce those because we want to support recursive intersection types. For example,
// a type alias of the form "type List<T> = T & { next: List<T> }" cannot be reduced during its declaration.
// Also, unlike union types, the order of the constituent types is preserved in order that overload resolution
// for intersections of types with signatures can be deterministic.
func (tc *TypeChecker) getIntersectionType(types []Type, flags IntersectionFlags /*  = IntersectionFlags.None */, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	typeMembershipMap := NewMap[string, Type]()
	includes := tc.addTypesToIntersection(typeMembershipMap, 0 /* as TypeFlags */, types)
	var typeSet []Type = arrayFrom(typeMembershipMap.values())
	objectFlags := ObjectFlagsNone
	// An intersection type is considered empty if it contains
	// the type never, or
	// more than one unit type or,
	// an object type and a nullable type (null or undefined), or
	// a string-like type and a type known to be non-string-like, or
	// a number-like type and a type known to be non-number-like, or
	// a symbol-like type and a type known to be non-symbol-like, or
	// a void-like type and a type known to be non-void-like, or
	// a non-primitive type and a type known to be primitive.
	if includes & TypeFlagsNever {
		if contains(typeSet, tc.silentNeverType) {
			return tc.silentNeverType
		} else {
			return tc.neverType
		}
	}
	if tc.strictNullChecks && includes&TypeFlagsNullable && includes&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsIncludesEmptyObject) || includes&TypeFlagsNonPrimitive && includes&(TypeFlagsDisjointDomains&~TypeFlagsNonPrimitive) || includes&TypeFlagsStringLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsStringLike) || includes&TypeFlagsNumberLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsNumberLike) || includes&TypeFlagsBigIntLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsBigIntLike) || includes&TypeFlagsESSymbolLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsESSymbolLike) || includes&TypeFlagsVoidLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsVoidLike) {
		return tc.neverType
	}
	if includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsStringLiteral && tc.extractRedundantTemplateLiterals(typeSet) {
		return tc.neverType
	}
	if includes & TypeFlagsAny {
		switch {
		case includes & TypeFlagsIncludesWildcard:
			return tc.wildcardType
		case includes & TypeFlagsIncludesError:
			return tc.errorType
		default:
			return tc.anyType
		}
	}
	if !tc.strictNullChecks && includes&TypeFlagsNullable {
		switch {
		case includes & TypeFlagsIncludesEmptyObject:
			return tc.neverType
		case includes & TypeFlagsUndefined:
			return tc.undefinedType
		default:
			return tc.nullType
		}
	}
	if includes&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || includes&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || includes&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || includes&TypeFlagsVoid && includes&TypeFlagsUndefined || includes&TypeFlagsIncludesEmptyObject && includes&TypeFlagsDefinitelyNonNullable {
		if !(flags & IntersectionFlagsNoSupertypeReduction) {
			tc.removeRedundantSupertypes(typeSet, includes)
		}
	}
	if includes & TypeFlagsIncludesMissingType {
		typeSet[typeSet.indexOf(tc.undefinedType)] = tc.missingType
	}
	if typeSet.length == 0 {
		return tc.unknownType
	}
	if typeSet.length == 1 {
		return typeSet[0]
	}
	if typeSet.length == 2 && !(flags & IntersectionFlagsNoConstraintReduction) {
		var typeVarIndex /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
		if typeSet[0].flags & TypeFlagsTypeVariable {
			typeVarIndex = 0
		} else {
			typeVarIndex = 1
		}
		typeVariable := typeSet[typeVarIndex]
		primitiveType := typeSet[1-typeVarIndex]
		if typeVariable.flags&TypeFlagsTypeVariable && (primitiveType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) && !tc.isGenericStringLikeType(primitiveType) || includes&TypeFlagsIncludesEmptyObject) {
			// We have an intersection T & P or P & T, where T is a type variable and P is a primitive type, the object type, or {}.
			constraint := tc.getBaseConstraintOfType(typeVariable)
			// Check that T's constraint is similarly composed of primitive types, the object type, or {}.
			if constraint && tc.everyType(constraint, func(t Type) bool {
				return !!(t.flags & (TypeFlagsPrimitive | TypeFlagsNonPrimitive)) || tc.isEmptyAnonymousObjectType(t)
			}) {
				// If T's constraint is a subtype of P, simply return T. For example, given `T extends "a" | "b"`,
				// the intersection `T & string` reduces to just T.
				if tc.isTypeStrictSubtypeOf(constraint, primitiveType) {
					return typeVariable
				}
				if !(constraint.flags&TypeFlagsUnion && tc.someType(constraint, func(c Type) bool {
					return tc.isTypeStrictSubtypeOf(c, primitiveType)
				})) {
					// No constituent of T's constraint is a subtype of P. If P is also not a subtype of T's constraint,
					// then the constraint and P are unrelated, and the intersection reduces to never. For example, given
					// `T extends "a" | "b"`, the intersection `T & number` reduces to never.
					if !tc.isTypeStrictSubtypeOf(primitiveType, constraint) {
						return tc.neverType
					}
				}
				// Some constituent of T's constraint is a subtype of P, or P is a subtype of T's constraint. Thus,
				// the intersection further constrains the type variable. For example, given `T extends string | number`,
				// the intersection `T & "a"` is marked as a constrained type variable. Likewise, given `T extends "a" | 1`,
				// the intersection `T & number` is marked as a constrained type variable.
				objectFlags = ObjectFlagsIsConstrainedTypeVariable
			}
		}
	}
	id := tc.getTypeListId(typeSet) + (__COND__(flags&IntersectionFlagsNoConstraintReduction, "*", tc.getAliasId(aliasSymbol, aliasTypeArguments)))
	result := tc.intersectionTypes.get(id)
	if !result {
		if includes & TypeFlagsUnion {
			if tc.intersectUnionsOfPrimitiveTypes(typeSet) {
				// When the intersection creates a reduced set (which might mean that *all* union types have
				// disappeared), we restart the operation to get a new set of combined flags. Once we have
				// reduced we'll never reduce again, so this occurs at most once.
				result = tc.getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments)
			} else if every(typeSet, func(t Type) bool {
				return !!(t.flags&TypeFlagsUnion && (t /* as UnionType */).types[0].flags&TypeFlagsUndefined)
			}) {
				var containedUndefinedType IntrinsicType
				if some(typeSet, tc.containsMissingType) {
					containedUndefinedType = tc.missingType
				} else {
					containedUndefinedType = tc.undefinedType
				}
				tc.removeFromEach(typeSet, TypeFlagsUndefined)
				result = tc.getUnionType([]Type{tc.getIntersectionType(typeSet, flags), containedUndefinedType}, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
			} else if every(typeSet, func(t Type) bool {
				return !!(t.flags&TypeFlagsUnion && ((t /* as UnionType */).types[0].flags&TypeFlagsNull || (t /* as UnionType */).types[1].flags&TypeFlagsNull))
			}) {
				tc.removeFromEach(typeSet, TypeFlagsNull)
				result = tc.getUnionType([]Type{tc.getIntersectionType(typeSet, flags), tc.nullType}, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
			} else if typeSet.length >= 3 && types.length > 2 {
				// When we have three or more constituents, more than two inputs (to head off infinite reexpansion), some of which are unions, we employ a "divide and conquer" strategy
				// where A & B & C & D is processed as (A & B) & (C & D). Since intersections of unions often produce far smaller
				// unions of intersections than the full cartesian product (due to some intersections becoming `never`), this can
				// dramatically reduce the overall work.
				middle := Math.floor(typeSet.length / 2)
				result = tc.getIntersectionType([]Type{tc.getIntersectionType(typeSet.slice(0, middle), flags), tc.getIntersectionType(typeSet.slice(middle), flags)}, flags, aliasSymbol, aliasTypeArguments)
			} else {
				// We are attempting to construct a type of the form X & (A | B) & (C | D). Transform this into a type of
				// the form X & A & C | X & A & D | X & B & C | X & B & D. If the estimated size of the resulting union type
				// exceeds 100000 constituents, report an error.
				if !tc.checkCrossProductUnion(typeSet) {
					return tc.errorType
				}
				constituents := tc.getCrossProductIntersections(typeSet, flags)
				// We attach a denormalized origin type when at least one constituent of the cross-product union is an
				// intersection (i.e. when the intersection didn't just reduce one or more unions to smaller unions) and
				// the denormalized origin has fewer constituents than the union itself.
				var origin *UnionOrIntersectionType
				if some(constituents, func(t Type) bool {
					return !!(t.flags & TypeFlagsIntersection)
				}) && tc.getConstituentCountOfTypes(constituents) > tc.getConstituentCountOfTypes(typeSet) {
					origin = tc.createOriginUnionOrIntersectionType(TypeFlagsIntersection, typeSet)
				} else {
					origin = nil
				}
				result = tc.getUnionType(constituents, UnionReductionLiteral, aliasSymbol, aliasTypeArguments, origin)
			}
		} else {
			result = tc.createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments)
		}
		tc.intersectionTypes.set(id, result)
	}
	return result
}

func (tc *TypeChecker) getCrossProductUnionSize(types []Type) number {
	return reduceLeft(types, func(n number, t Type) number {
		switch {
		case t.flags & TypeFlagsUnion:
			return n * (t /* as UnionType */).types.length
		case t.flags & TypeFlagsNever:
			return 0
		default:
			return n
		}
	}, 1)
}

func (tc *TypeChecker) checkCrossProductUnion(types []Type) bool {
	size := tc.getCrossProductUnionSize(types)
	if size >= 100000 {
		tracing. /* ? */ instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"typeIds": types.map_(func(t Type) number {
				return t.id
			}),
			"size": size,
		})
		tc.error(tc.currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
		return false
	}
	return true
}

func (tc *TypeChecker) getCrossProductIntersections(types []Type, flags IntersectionFlags) []Type {
	count := tc.getCrossProductUnionSize(types)
	var intersections []Type = []never{}
	for i := 0; i < count; i++ {
		constituents := types.slice()
		n := i
		for j := types.length - 1; j >= 0; j-- {
			if types[j].flags & TypeFlagsUnion {
				sourceTypes := (types[j] /* as UnionType */).types
				length := sourceTypes.length
				constituents[j] = sourceTypes[n%length]
				n = Math.floor(n / length)
			}
		}
		t := tc.getIntersectionType(constituents, flags)
		if !(t.flags & TypeFlagsNever) {
			intersections.push(t)
		}
	}
	return intersections
}

func (tc *TypeChecker) getConstituentCount(type_ Type) number {
	switch {
	case !(type_.flags & TypeFlagsUnionOrIntersection) || type_.aliasSymbol:
		return 1
	case type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).origin:
		return tc.getConstituentCount((type_ /* as UnionType */).origin)
	default:
		return tc.getConstituentCountOfTypes((type_ /* as UnionOrIntersectionType */).types)
	}
}

func (tc *TypeChecker) getConstituentCountOfTypes(types []Type) number {
	return reduceLeft(types, func(n number, t Type) number {
		return n + tc.getConstituentCount(t)
	}, 0)
}

func (tc *TypeChecker) getTypeFromIntersectionTypeNode(node IntersectionTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		aliasSymbol := tc.getAliasSymbolForTypeNode(node)
		types := map_(node.types, tc.getTypeFromTypeNode)
		// We perform no supertype reduction for X & {} or {} & X, where X is one of string, number, bigint,
		// or a pattern literal template type. This enables union types like "a" | "b" | string & {} or
		// "aa" | "ab" | `a${string}` which preserve the literal types for purposes of statement completion.
		var emptyIndex number
		if types.length == 2 {
			emptyIndex = types.indexOf(tc.emptyTypeLiteralType)
		} else {
			emptyIndex = -1
		}
		var t Type
		if emptyIndex >= 0 {
			t = types[1-emptyIndex]
		} else {
			t = tc.unknownType
		}
		noSupertypeReduction := !!(t.flags&(TypeFlagsString|TypeFlagsNumber|TypeFlagsBigInt) || t.flags&TypeFlagsTemplateLiteral && tc.isPatternLiteralType(t))
		links.resolvedType = tc.getIntersectionType(types, __COND__(noSupertypeReduction, IntersectionFlagsNoSupertypeReduction, 0), aliasSymbol, tc.getTypeArgumentsForAliasSymbol(aliasSymbol))
	}
	return links.resolvedType
}

func (tc *TypeChecker) createIndexType(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) IndexType {
	result := tc.createType(TypeFlagsIndex) /* as IndexType */
	result.type_ = type_
	result.indexFlags = indexFlags
	return result
}

func (tc *TypeChecker) createOriginIndexType(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any) IndexType {
	result := tc.createOriginType(TypeFlagsIndex) /* as IndexType */
	result.type_ = type_
	return result
}

func (tc *TypeChecker) getIndexTypeForGenericType(type_ /* TODO(TS-TO-GO) TypeNode UnionType: InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) IndexType {
	if indexFlags & IndexFlagsStringsOnly {
		return type_.resolvedStringIndexType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly) */ TODO)
	} else {
		return type_.resolvedIndexType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.resolvedIndexType = createIndexType(type, IndexFlags.None) */ TODO)
	}
}

/**
 * This roughly mirrors `resolveMappedTypeMembers` in the nongeneric case, except only reports a union of the keys calculated,
 * rather than manufacturing the properties. We can't just fetch the `constraintType` since that would ignore mappings
 * and mapping the `constraintType` directly ignores how mapped types map _properties_ and not keys (thus ignoring subtype
 * reduction in the constraintType) when possible.
 * @param noIndexSignatures Indicates if _string_ index signatures should be elided. (other index signatures are always reported)
 */

func (tc *TypeChecker) getIndexTypeForMappedType(type_ MappedType, indexFlags IndexFlags) Type {
	typeParameter := tc.getTypeParameterFromMappedType(type_)
	constraintType := tc.getConstraintTypeFromMappedType(type_)
	nameType := tc.getNameTypeFromMappedType(type_.target /* as MappedType */ || type_)
	if !nameType && !(indexFlags & IndexFlagsNoIndexSignatures) {
		// no mapping and no filtering required, just quickly bail to returning the constraint in the common case
		return constraintType
	}
	var keyTypes []Type = []never{}
	// Calling getApparentType on the `T` of a `keyof T` in the constraint type of a generic mapped type can
	// trigger a circularity. For example, `T extends { [P in keyof T & string as Captitalize<P>]: any }` is
	// a circular definition. For this reason, we only eagerly manifest the keys if the constraint is non-generic.
	if tc.isGenericIndexType(constraintType) {
		if tc.isMappedTypeWithKeyofConstraintDeclaration(type_) {
			// We have a generic index and a homomorphic mapping (but a distributive key remapping) - we need to defer
			// the whole `keyof whatever` for later since it's not safe to resolve the shape of modifier type.
			return tc.getIndexTypeForGenericType(type_, indexFlags)
		}
		// Include the generic component in the resulting type.
		tc.forEachType(constraintType, addMemberForKeyType)
	} else if tc.isMappedTypeWithKeyofConstraintDeclaration(type_) {
		modifiersType := tc.getApparentType(tc.getModifiersTypeFromMappedType(type_))
		// The 'T' in 'keyof T'
		tc.forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlagsStringsOnly), addMemberForKeyType)
	} else {
		tc.forEachType(tc.getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
	}
	// We had to pick apart the constraintType to potentially map/filter it - compare the final resulting list with the
	// original constraintType, so we can return the union that preserves aliases/origin data if possible.
	var result Type
	if indexFlags & IndexFlagsNoIndexSignatures {
		result = tc.filterType(tc.getUnionType(keyTypes), func(t Type) bool {
			return !(t.flags & (TypeFlagsAny | TypeFlagsString))
		})
	} else {
		result = tc.getUnionType(keyTypes)
	}
	if result.flags&TypeFlagsUnion && constraintType.flags&TypeFlagsUnion && tc.getTypeListId((result /* as UnionType */).types) == tc.getTypeListId((constraintType /* as UnionType */).types) {
		return constraintType
	}
	return result

	addMemberForKeyType := func(keyType Type) {
		var propNameType Type
		if nameType {
			propNameType = tc.instantiateType(nameType, tc.appendTypeMapping(type_.mapper, typeParameter, keyType))
		} else {
			propNameType = keyType
		}
		// `keyof` currently always returns `string | number` for concrete `string` index signatures - the below ternary keeps that behavior for mapped types
		// See `getLiteralTypeFromProperties` where there's a similar ternary to cause the same behavior.
		keyTypes.push(__COND__(propNameType == tc.stringType, tc.stringOrNumberType, propNameType))
	}

}

// Ordinarily we reduce a keyof M, where M is a mapped type { [P in K as N<P>]: X }, to simply N<K>. This however presumes
// that N distributes over union types, i.e. that N<A | B | C> is equivalent to N<A> | N<B> | N<C>. Specifically, we only
// want to perform the reduction when the name type of a mapped type is distributive with respect to the type variable
// introduced by the 'in' clause of the mapped type. Note that non-generic types are considered to be distributive because
// they're the same type regardless of what's being distributed over.
func (tc *TypeChecker) hasDistributiveNameType(mappedType MappedType) bool {
	typeVariable := tc.getTypeParameterFromMappedType(mappedType)
	return isDistributive(tc.getNameTypeFromMappedType(mappedType) || typeVariable)
	isDistributive := func(type_ Type) bool {
		switch {
		case type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsPrimitive | TypeFlagsNever | TypeFlagsTypeParameter | TypeFlagsObject | TypeFlagsNonPrimitive):
			return true
		case type_.flags & TypeFlagsConditional:
			return (type_ /* as ConditionalType */).root.isDistributive && (type_ /* as ConditionalType */).checkType == typeVariable
		case type_.flags & (TypeFlagsUnionOrIntersection | TypeFlagsTemplateLiteral):
			return every((type_ /* as UnionOrIntersectionType | TemplateLiteralType */).types, isDistributive)
		case type_.flags & TypeFlagsIndexedAccess:
			return isDistributive((type_ /* as IndexedAccessType */).objectType) && isDistributive((type_ /* as IndexedAccessType */).indexType)
		case type_.flags & TypeFlagsSubstitution:
			return isDistributive((type_ /* as SubstitutionType */).baseType) && isDistributive((type_ /* as SubstitutionType */).constraint)
		case type_.flags & TypeFlagsStringMapping:
			return isDistributive((type_ /* as StringMappingType */).type_)
		default:
			return false
		}
	}

}

func (tc *TypeChecker) getLiteralTypeFromPropertyName(name /* TODO(TS-TO-GO) TypeNode UnionType: PropertyName | JsxAttributeName */ any) Type {
	if isPrivateIdentifier(name) {
		return tc.neverType
	}
	if isNumericLiteral(name) {
		return tc.getRegularTypeOfLiteralType(tc.checkExpression(name))
	}
	if isComputedPropertyName(name) {
		return tc.getRegularTypeOfLiteralType(tc.checkComputedPropertyName(name))
	}
	propertyName := getPropertyNameForPropertyNameNode(name)
	if propertyName != nil {
		return tc.getStringLiteralType(unescapeLeadingUnderscores(propertyName))
	}
	if isExpression(name) {
		return tc.getRegularTypeOfLiteralType(tc.checkExpression(name))
	}
	return tc.neverType
}

func (tc *TypeChecker) getLiteralTypeFromProperty(prop Symbol, include TypeFlags, includeNonPublic bool) Type {
	if includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlagsNonPublicAccessibilityModifier) {
		type_ := tc.getSymbolLinks(tc.getLateBoundSymbol(prop)).nameType
		if !type_ {
			name := getNameOfDeclaration(prop.valueDeclaration) /* as PropertyName | JsxAttributeName */
			if prop.escapedName == InternalSymbolNameDefault {
				type_ = tc.getStringLiteralType("default")
			} else {
				type_ = name && tc.getLiteralTypeFromPropertyName(name) || (__COND__(!isKnownSymbol(prop), tc.getStringLiteralType(symbolName(prop)), nil))
			}
		}
		if type_ && type_.flags&include {
			return type_
		}
	}
	return tc.neverType
}

func (tc *TypeChecker) isKeyTypeIncluded(keyType Type, include TypeFlags) bool {
	return !!(keyType.flags&include || keyType.flags&TypeFlagsIntersection && some((keyType /* as IntersectionType */).types, func(t Type) bool {
		return tc.isKeyTypeIncluded(t, include)
	}))
}

func (tc *TypeChecker) getLiteralTypeFromProperties(type_ Type, include TypeFlags, includeOrigin bool) Type {
	var origin *IndexType
	if includeOrigin && (getObjectFlags(type_)&(ObjectFlagsClassOrInterface|ObjectFlagsReference) || type_.aliasSymbol) {
		origin = tc.createOriginIndexType(type_)
	} else {
		origin = nil
	}
	propertyTypes := map_(tc.getPropertiesOfType(type_), func(prop Symbol) Type {
		return tc.getLiteralTypeFromProperty(prop, include)
	})
	indexKeyTypes := map_(tc.getIndexInfosOfType(type_), func(info IndexInfo) Type {
		switch {
		case info != tc.enumNumberIndexInfo && tc.isKeyTypeIncluded(info.keyType, include):
			if info.keyType == tc.stringType && include&TypeFlagsNumber {
				return tc.stringOrNumberType
			} else {
				return info.keyType
			}
		default:
			return tc.neverType
		}
	})
	return tc.getUnionType(concatenate(propertyTypes, indexKeyTypes), UnionReductionLiteral /*aliasSymbol*/, nil /*aliasTypeArguments*/, nil, origin)
}

func (tc *TypeChecker) shouldDeferIndexType(type_ Type, indexFlags IndexFlags /*  = IndexFlags.None */) bool {
	return !!(type_.flags&TypeFlagsInstantiableNonPrimitive || tc.isGenericTupleType(type_) || tc.isGenericMappedType(type_) && (!tc.hasDistributiveNameType(type_) || tc.getMappedTypeNameTypeKind(type_) == MappedTypeNameTypeKindRemapping) || type_.flags&TypeFlagsUnion && !(indexFlags&IndexFlagsNoReducibleCheck) && tc.isGenericReducibleType(type_) || type_.flags&TypeFlagsIntersection && tc.maybeTypeOfKind(type_, TypeFlagsInstantiable) && some((type_ /* as IntersectionType */).types, tc.isEmptyAnonymousObjectType))
}

func (tc *TypeChecker) getIndexType(type_ Type, indexFlags IndexFlags /*  = IndexFlags.None */) Type {
	type_ = tc.getReducedType(type_)
	switch {
	case tc.isNoInferType(type_):
		return tc.getNoInferType(tc.getIndexType((type_ /* as SubstitutionType */).baseType, indexFlags))
	case tc.shouldDeferIndexType(type_, indexFlags):
		return tc.getIndexTypeForGenericType(type_ /* as InstantiableType | UnionOrIntersectionType */, indexFlags)
	case type_.flags & TypeFlagsUnion:
		return tc.getIntersectionType(map_((type_ /* as UnionType */).types, func(t Type) Type {
			return tc.getIndexType(t, indexFlags)
		}))
	case type_.flags & TypeFlagsIntersection:
		return tc.getUnionType(map_((type_ /* as IntersectionType */).types, func(t Type) Type {
			return tc.getIndexType(t, indexFlags)
		}))
	case getObjectFlags(type_) & ObjectFlagsMapped:
		return tc.getIndexTypeForMappedType(type_ /* as MappedType */, indexFlags)
	case type_ == tc.wildcardType:
		return tc.wildcardType
	case type_.flags & TypeFlagsUnknown:
		return tc.neverType
	case type_.flags & (TypeFlagsAny | TypeFlagsNever):
		return tc.stringNumberSymbolType
	default:
		return tc.getLiteralTypeFromProperties(type_, (__COND__(indexFlags&IndexFlagsNoIndexSignatures, TypeFlagsStringLiteral, TypeFlagsStringLike))|(__COND__(indexFlags&IndexFlagsStringsOnly, 0, TypeFlagsNumberLike|TypeFlagsESSymbolLike)), indexFlags == IndexFlagsNone)
	}
}

func (tc *TypeChecker) getExtractStringType(type_ Type) Type {
	extractTypeAlias := tc.getGlobalExtractSymbol()
	if extractTypeAlias {
		return tc.getTypeAliasInstantiation(extractTypeAlias, []Type{type_, tc.stringType})
	} else {
		return tc.stringType
	}
}

func (tc *TypeChecker) getIndexTypeOrString(type_ Type) Type {
	indexType := tc.getExtractStringType(tc.getIndexType(type_))
	if indexType.flags & TypeFlagsNever {
		return tc.stringType
	} else {
		return indexType
	}
}

func (tc *TypeChecker) getTypeFromTypeOperatorNode(node TypeOperatorNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		switch node.operator {
		case SyntaxKindKeyOfKeyword:
			links.resolvedType = tc.getIndexType(tc.getTypeFromTypeNode(node.type_))
		case SyntaxKindUniqueKeyword:
			if node.type_.kind == SyntaxKindSymbolKeyword {
				links.resolvedType = tc.getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent))
			} else {
				links.resolvedType = tc.errorType
			}
		case SyntaxKindReadonlyKeyword:
			links.resolvedType = tc.getTypeFromTypeNode(node.type_)
		default:
			Debug.assertNever(node.operator)
		}
	}
	return links.resolvedType
}

func (tc *TypeChecker) getTypeFromTemplateTypeNode(node TemplateLiteralTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		links.resolvedType = tc.getTemplateLiteralType([]string{node.head.text /* TODO(TS-TO-GO) Node SpreadElement: ...map(node.templateSpans, span => span.literal.text) */}, map_(node.templateSpans, func(span TemplateLiteralTypeSpan) Type {
			return tc.getTypeFromTypeNode(span.type_)
		}))
	}
	return links.resolvedType
}

func (tc *TypeChecker) getTemplateLiteralType(texts []string, types []Type) Type {
	unionIndex := findIndex(types, func(t Type) bool {
		return !!(t.flags & (TypeFlagsNever | TypeFlagsUnion))
	})
	if unionIndex >= 0 {
		if tc.checkCrossProductUnion(types) {
			return tc.mapType(types[unionIndex], func(t Type) Type {
				return tc.getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))
			})
		} else {
			return tc.errorType
		}
	}
	if contains(types, tc.wildcardType) {
		return tc.wildcardType
	}
	var newTypes []Type = []never{}
	var newTexts []string = []never{}
	text := texts[0]
	if !addSpans(texts, types) {
		return tc.stringType
	}
	if newTypes.length == 0 {
		return tc.getStringLiteralType(text)
	}
	newTexts.push(text)
	if every(newTexts, func(t string) bool {
		return t == ""
	}) {
		if every(newTypes, func(t Type) bool {
			return !!(t.flags & TypeFlagsString)
		}) {
			return tc.stringType
		}
		// Normalize `${Mapping<xxx>}` into Mapping<xxx>
		if newTypes.length == 1 && tc.isPatternLiteralType(newTypes[0]) {
			return newTypes[0]
		}
	}
	id := __TEMPLATE__(tc.getTypeListId(newTypes), "|", map_(newTexts, func(t string) number {
		return t.length
	}).join(","), "|", newTexts.join(""))
	type_ := tc.templateLiteralTypes.get(id)
	if !type_ {
		tc.templateLiteralTypes.set(id /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type = createTemplateLiteralType(newTexts, newTypes) */, TODO)
	}
	return type_

	addSpans := func(texts []string, types []Type) bool {
		for i := 0; i < types.length; i++ {
			t := types[i]
			if t.flags & (TypeFlagsLiteral | TypeFlagsNull | TypeFlagsUndefined) {
				text += tc.getTemplateStringForType(t) || ""
				text += texts[i+1]
			} else if t.flags & TypeFlagsTemplateLiteral {
				text += (t /* as TemplateLiteralType */).texts[0]
				if !addSpans((t /* as TemplateLiteralType */).texts, (t /* as TemplateLiteralType */).types) {
					return false
				}
				text += texts[i+1]
			} else if tc.isGenericIndexType(t) || tc.isPatternLiteralPlaceholderType(t) {
				newTypes.push(t)
				newTexts.push(text)
				text = texts[i+1]
			} else {
				return false
			}
		}
		return true
	}

}

func (tc *TypeChecker) getTemplateStringForType(type_ Type) *string {
	switch {
	case type_.flags & TypeFlagsStringLiteral:
		return (type_ /* as StringLiteralType */).value
	case type_.flags & TypeFlagsNumberLiteral:
		return "" + (type_ /* as NumberLiteralType */).value
	case type_.flags & TypeFlagsBigIntLiteral:
		return pseudoBigIntToString((type_ /* as BigIntLiteralType */).value)
	case type_.flags & (TypeFlagsBooleanLiteral | TypeFlagsNullable):
		return (type_ /* as IntrinsicType */).intrinsicName
	default:
		return nil
	}
}

func (tc *TypeChecker) createTemplateLiteralType(texts []string, types []Type) TemplateLiteralType {
	type_ := tc.createType(TypeFlagsTemplateLiteral) /* as TemplateLiteralType */
	type_.texts = texts
	type_.types = types
	return type_
}

func (tc *TypeChecker) getStringMappingType(symbol Symbol, type_ Type) Type {
	switch {
	case type_.flags & (TypeFlagsUnion | TypeFlagsNever):
		return tc.mapType(type_, func(t Type) Type {
			return tc.getStringMappingType(symbol, t)
		})
	case type_.flags & TypeFlagsStringLiteral:
		return tc.getStringLiteralType(tc.applyStringMapping(symbol, (type_ /* as StringLiteralType */).value))
	case type_.flags & TypeFlagsTemplateLiteral:
		return tc.getTemplateLiteralType(tc.applyTemplateStringMapping(symbol, (type_ /* as TemplateLiteralType */).texts, (type_ /* as TemplateLiteralType */).types)...)
	case type_.flags&TypeFlagsStringMapping && symbol == type_.symbol:
		return type_
	case type_.flags&(TypeFlagsAny|TypeFlagsString|TypeFlagsStringMapping) || tc.isGenericIndexType(type_):
		return tc.getStringMappingTypeForGenericType(symbol, type_)
	case tc.isPatternLiteralPlaceholderType(type_):
		return tc.getStringMappingTypeForGenericType(symbol, tc.getTemplateLiteralType([]string{"", ""}, []Type{type_}))
	default:
		return type_
	}
}

func (tc *TypeChecker) applyStringMapping(symbol Symbol, str string) string {
	switch intrinsicTypeKinds.get(symbol.escapedName /* as string */) {
	case IntrinsicTypeKindUppercase:
		return str.toUpperCase()
	case IntrinsicTypeKindLowercase:
		return str.toLowerCase()
	case IntrinsicTypeKindCapitalize:
		return str.charAt(0).toUpperCase() + str.slice(1)
	case IntrinsicTypeKindUncapitalize:
		return str.charAt(0).toLowerCase() + str.slice(1)
	}
	return str
}

func (tc *TypeChecker) applyTemplateStringMapping(symbol Symbol, texts []string, types []Type) /* TODO(TS-TO-GO) TypeNode TupleType: [texts: readonly string[], types: readonly Type[]] */ any {
	switch intrinsicTypeKinds.get(symbol.escapedName /* as string */) {
	case IntrinsicTypeKindUppercase:
		return []any{texts.map_(func(t string) string {
			return t.toUpperCase()
		}), types.map_(func(t Type) Type {
			return tc.getStringMappingType(symbol, t)
		})}
	case IntrinsicTypeKindLowercase:
		return []any{texts.map_(func(t string) string {
			return t.toLowerCase()
		}), types.map_(func(t Type) Type {
			return tc.getStringMappingType(symbol, t)
		})}
	case IntrinsicTypeKindCapitalize:
		return []any{__COND__(texts[0] == "", texts, []string{texts[0].charAt(0).toUpperCase() + texts[0].slice(1) /* TODO(TS-TO-GO) Node SpreadElement: ...texts.slice(1) */}), __COND__(texts[0] == "", []Type{tc.getStringMappingType(symbol, types[0]) /* TODO(TS-TO-GO) Node SpreadElement: ...types.slice(1) */}, types)}
	case IntrinsicTypeKindUncapitalize:
		return []any{__COND__(texts[0] == "", texts, []string{texts[0].charAt(0).toLowerCase() + texts[0].slice(1) /* TODO(TS-TO-GO) Node SpreadElement: ...texts.slice(1) */}), __COND__(texts[0] == "", []Type{tc.getStringMappingType(symbol, types[0]) /* TODO(TS-TO-GO) Node SpreadElement: ...types.slice(1) */}, types)}
	}
	return []any{texts, types}
}

func (tc *TypeChecker) getStringMappingTypeForGenericType(symbol Symbol, type_ Type) Type {
	id := __TEMPLATE__(getSymbolId(symbol), ",", tc.getTypeId(type_))
	result := tc.stringMappingTypes.get(id)
	if !result {
		tc.stringMappingTypes.set(id /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = createStringMappingType(symbol, type) */, TODO)
	}
	return result
}

func (tc *TypeChecker) createStringMappingType(symbol Symbol, type_ Type) StringMappingType {
	result := tc.createTypeWithSymbol(TypeFlagsStringMapping, symbol) /* as StringMappingType */
	result.type_ = type_
	return result
}

func (tc *TypeChecker) createIndexedAccessType(objectType Type, indexType Type, accessFlags AccessFlags, aliasSymbol Symbol, aliasTypeArguments *[]Type) IndexedAccessType {
	type_ := tc.createType(TypeFlagsIndexedAccess) /* as IndexedAccessType */
	type_.objectType = objectType
	type_.indexType = indexType
	type_.accessFlags = accessFlags
	type_.aliasSymbol = aliasSymbol
	type_.aliasTypeArguments = aliasTypeArguments
	return type_
}

/**
 * Returns if a type is or consists of a JSLiteral object type
 * In addition to objects which are directly literals,
 * * unions where every element is a jsliteral
 * * intersections where at least one element is a jsliteral
 * * and instantiable types constrained to a jsliteral
 * Should all count as literals and not print errors on access or assignment of possibly existing properties.
 * This mirrors the behavior of the index signature propagation, to which this behaves similarly (but doesn't affect assignability or inference).
 */

func (tc *TypeChecker) isJSLiteralType(type_ Type) bool {
	if tc.noImplicitAny {
		return false
		// Flag is meaningless under `noImplicitAny` mode
	}
	if getObjectFlags(type_) & ObjectFlagsJSLiteral {
		return true
	}
	if type_.flags & TypeFlagsUnion {
		return every((type_ /* as UnionType */).types, tc.isJSLiteralType)
	}
	if type_.flags & TypeFlagsIntersection {
		return some((type_ /* as IntersectionType */).types, tc.isJSLiteralType)
	}
	if type_.flags & TypeFlagsInstantiable {
		constraint := tc.getResolvedBaseConstraint(type_)
		return constraint != type_ && tc.isJSLiteralType(constraint)
	}
	return false
}

func (tc *TypeChecker) getPropertyNameFromIndex(indexType Type, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined */ any) *__String {
	switch {
	case isTypeUsableAsPropertyName(indexType):
		return getPropertyNameFromType(indexType)
	case accessNode && isPropertyName(accessNode):
		return getPropertyNameForPropertyNameNode(accessNode)
	default:
		return nil
	}
}

func (tc *TypeChecker) isUncalledFunctionReference(node Node, symbol Symbol) bool {
	if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
		parent := findAncestor(node.parent, func(n Node) bool {
			return !isAccessExpression(n)
		}) || node.parent
		if isCallLikeExpression(parent) {
			return isCallOrNewExpression(parent) && isIdentifier(node) && tc.hasMatchingArgument(parent, node)
		}
		return every(symbol.declarations, func(d Declaration) bool {
			return !isFunctionLike(d) || tc.isDeprecatedDeclaration(d)
		})
	}
	return true
}

func (tc *TypeChecker) getPropertyTypeForIndexType(originalObjectType Type, objectType Type, indexType Type, fullIndexType Type, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined */ any, accessFlags AccessFlags) Type {
	var accessExpression *ElementAccessExpression
	if accessNode && accessNode.kind == SyntaxKindElementAccessExpression {
		accessExpression = accessNode
	} else {
		accessExpression = nil
	}
	var propName *__String
	if accessNode && isPrivateIdentifier(accessNode) {
		propName = nil
	} else {
		propName = tc.getPropertyNameFromIndex(indexType, accessNode)
	}

	if propName != nil {
		if accessFlags & AccessFlagsContextual {
			return tc.getTypeOfPropertyOfContextualType(objectType, propName) || tc.anyType
		}
		prop := tc.getPropertyOfType(objectType, propName)
		if prop {
			if accessFlags&AccessFlagsReportDeprecated && accessNode && prop.declarations && tc.isDeprecatedSymbol(prop) && tc.isUncalledFunctionReference(accessNode, prop) {
				deprecatedNode := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode) */ TODO
				tc.addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName /* as string */)
			}
			if accessExpression {
				tc.markPropertyAsReferenced(prop, accessExpression, tc.isSelfTypeAccess(accessExpression.expression, objectType.symbol))
				if tc.isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression)) {
					tc.error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, tc.symbolToString(prop))
					return nil
				}
				if accessFlags & AccessFlagsCacheSymbol {
					tc.getNodeLinks(accessNode).resolvedSymbol = prop
				}
				if tc.isThisPropertyAccessInConstructor(accessExpression, prop) {
					return tc.autoType
				}
			}
			var propType Type
			if accessFlags & AccessFlagsWriting {
				propType = tc.getWriteTypeOfSymbol(prop)
			} else {
				propType = tc.getTypeOfSymbol(prop)
			}
			switch {
			case accessExpression && getAssignmentTargetKind(accessExpression) != AssignmentKindDefinite:
				return tc.getFlowTypeOfReference(accessExpression, propType)
			case accessNode && isIndexedAccessTypeNode(accessNode) && tc.containsMissingType(propType):
				return tc.getUnionType([]Type{propType, tc.undefinedType})
			default:
				return propType
			}
		}
		if tc.everyType(objectType, tc.isTupleType) && isNumericLiteralName(propName) {
			index := +propName
			if accessNode && tc.everyType(objectType, func(t Type) bool {
				return !((t /* as TupleTypeReference */).target.combinedFlags & ElementFlagsVariable)
			}) && !(accessFlags & AccessFlagsAllowMissing) {
				indexNode := tc.getIndexNodeForAccessExpression(accessNode)
				if tc.isTupleType(objectType) {
					if index < 0 {
						tc.error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value)
						return tc.undefinedType
					}
					tc.error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, tc.typeToString(objectType), tc.getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName))
				} else {
					tc.error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), tc.typeToString(objectType))
				}
			}
			if index >= 0 {
				errorIfWritingToReadonlyIndex(tc.getIndexInfoOfType(objectType, tc.numberType))
				return tc.getTupleElementTypeOutOfStartCount(objectType, index, __COND__(accessFlags&AccessFlagsIncludeUndefined, tc.missingType, nil))
			}
		}
	}
	if !(indexType.flags & TypeFlagsNullable) && tc.isTypeAssignableToKind(indexType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) {
		if objectType.flags & (TypeFlagsAny | TypeFlagsNever) {
			return objectType
		}
		// If no index signature is applicable, we default to the string index signature. In effect, this means the string
		// index signature applies even when accessing with a symbol-like type.
		indexInfo := tc.getApplicableIndexInfo(objectType, indexType) || tc.getIndexInfoOfType(objectType, tc.stringType)
		if indexInfo {
			if accessFlags&AccessFlagsNoIndexSignatures && indexInfo.keyType != tc.numberType {
				if accessExpression {
					if accessFlags & AccessFlagsWriting {
						tc.error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, tc.typeToString(originalObjectType))
					} else {
						tc.error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, tc.typeToString(indexType), tc.typeToString(originalObjectType))
					}
				}
				return nil
			}
			if accessNode && indexInfo.keyType == tc.stringType && !tc.isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
				indexNode := tc.getIndexNodeForAccessExpression(accessNode)
				tc.error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, tc.typeToString(indexType))
				if accessFlags & AccessFlagsIncludeUndefined {
					return tc.getUnionType([]Type{indexInfo.type_, tc.missingType})
				} else {
					return indexInfo.type_
				}
			}
			errorIfWritingToReadonlyIndex(indexInfo)
			// When accessing an enum object with its own type,
			// e.g. E[E.A] for enum E { A }, undefined shouldn't
			// be included in the result type
			if (accessFlags & AccessFlagsIncludeUndefined) && !(objectType.symbol && objectType.symbol.flags&(SymbolFlagsRegularEnum|SymbolFlagsConstEnum) && (indexType.symbol && indexType.flags&TypeFlagsEnumLiteral && tc.getParentOfSymbol(indexType.symbol) == objectType.symbol)) {
				return tc.getUnionType([]Type{indexInfo.type_, tc.missingType})
			}
			return indexInfo.type_
		}
		if indexType.flags & TypeFlagsNever {
			return tc.neverType
		}
		if tc.isJSLiteralType(objectType) {
			return tc.anyType
		}
		if accessExpression && !tc.isConstEnumObjectType(objectType) {
			if tc.isObjectLiteralType(objectType) {
				if tc.noImplicitAny && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
					tc.diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as StringLiteralType */).value, tc.typeToString(objectType)))
					return tc.undefinedType
				} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
					types := map_((objectType /* as ResolvedType */).properties, func(property Symbol) Type {
						return tc.getTypeOfSymbol(property)
					})
					return tc.getUnionType(append(types, tc.undefinedType))
				}
			}

			if objectType.symbol == tc.globalThisSymbol && propName != nil && tc.globalThisSymbol.exports.has(propName) && (tc.globalThisSymbol.exports.get(propName).flags & SymbolFlagsBlockScoped) {
				tc.error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), tc.typeToString(objectType))
			} else if tc.noImplicitAny && !(accessFlags & AccessFlagsSuppressNoImplicitAnyError) {
				if propName != nil && tc.typeHasStaticProperty(propName, objectType) {
					typeName := tc.typeToString(objectType)
					tc.error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName /* as string */, typeName, typeName+"["+getTextOfNode(accessExpression.argumentExpression)+"]")
				} else if tc.getIndexTypeOfType(objectType, tc.numberType) {
					tc.error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number)
				} else {
					var suggestion *string
					if propName != nil && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: suggestion = getSuggestionForNonexistentProperty(propName as string, objectType) */ TODO) {
						if suggestion != nil {
							tc.error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName /* as string */, tc.typeToString(objectType), suggestion)
						}
					} else {
						suggestion := tc.getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType)
						if suggestion != nil {
							tc.error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, tc.typeToString(objectType), suggestion)
						} else {
							var errorInfo *DiagnosticMessageChain
							if indexType.flags & TypeFlagsEnumLiteral {
								errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, "["+tc.typeToString(indexType)+"]", tc.typeToString(objectType))
							} else if indexType.flags & TypeFlagsUniqueESSymbol {
								symbolName := tc.getFullyQualifiedName((indexType /* as UniqueESSymbolType */).symbol, accessExpression)
								errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, "["+symbolName+"]", tc.typeToString(objectType))
							} else if indexType.flags & TypeFlagsStringLiteral {
								errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as StringLiteralType */).value, tc.typeToString(objectType))
							} else if indexType.flags & TypeFlagsNumberLiteral {
								errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as NumberLiteralType */).value, tc.typeToString(objectType))
							} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
								errorInfo = chainDiagnosticMessages(nil, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, tc.typeToString(indexType), tc.typeToString(objectType))
							}

							errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, tc.typeToString(fullIndexType), tc.typeToString(objectType))
							tc.diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo))
						}
					}
				}
			}
			return nil
		}
	}
	if accessFlags&AccessFlagsAllowMissing && tc.isObjectLiteralType(objectType) {
		return tc.undefinedType
	}
	if tc.isJSLiteralType(objectType) {
		return tc.anyType
	}
	if accessNode {
		indexNode := tc.getIndexNodeForAccessExpression(accessNode)
		if indexNode.kind != SyntaxKindBigIntLiteral && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
			tc.error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, ""+(indexType /* as StringLiteralType | NumberLiteralType */).value, tc.typeToString(objectType))
		} else if indexType.flags & (TypeFlagsString | TypeFlagsNumber) {
			tc.error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, tc.typeToString(objectType), tc.typeToString(indexType))
		} else {
			var typeString string
			if indexNode.kind == SyntaxKindBigIntLiteral {
				typeString = "bigint"
			} else {
				typeString = tc.typeToString(indexType)
			}
			tc.error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeString)
		}
	}
	if tc.isTypeAny(indexType) {
		return indexType
	}
	return nil

	errorIfWritingToReadonlyIndex := func(indexInfo *IndexInfo) {
		if indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression)) {
			tc.error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, tc.typeToString(objectType))
		}
	}

}

func (tc *TypeChecker) getIndexNodeForAccessExpression(accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any) /* TODO(TS-TO-GO) inferred type Expression | TypeNode | ObjectBindingPattern | ArrayBindingPattern */ any {
	switch {
	case accessNode.kind == SyntaxKindElementAccessExpression:
		return accessNode.argumentExpression
	case accessNode.kind == SyntaxKindIndexedAccessType:
		return accessNode.indexType
	case accessNode.kind == SyntaxKindComputedPropertyName:
		return accessNode.expression
	default:
		return accessNode
	}
}

func (tc *TypeChecker) isPatternLiteralPlaceholderType(type_ Type) bool {
	if type_.flags & TypeFlagsIntersection {
		// Return true if the intersection consists of one or more placeholders and zero or
		// more object type tags.
		seenPlaceholder := false
		for _, t := range (type_ /* as IntersectionType */).types {
			if t.flags&(TypeFlagsLiteral|TypeFlagsNullable) || tc.isPatternLiteralPlaceholderType(t) {
				seenPlaceholder = true
			} else if !(t.flags & TypeFlagsObject) {
				return false
			}
		}
		return seenPlaceholder
	}
	return !!(type_.flags & (TypeFlagsAny | TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) || tc.isPatternLiteralType(type_)
}

func (tc *TypeChecker) isPatternLiteralType(type_ Type) bool {
	// A pattern literal type is a template literal or a string mapping type that contains only
	// non-generic pattern literal placeholders.
	return !!(type_.flags&TypeFlagsTemplateLiteral) && every((type_ /* as TemplateLiteralType */).types, tc.isPatternLiteralPlaceholderType) || !!(type_.flags&TypeFlagsStringMapping) && tc.isPatternLiteralPlaceholderType((type_ /* as StringMappingType */).type_)
}

func (tc *TypeChecker) isGenericStringLikeType(type_ Type) bool {
	return !!(type_.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) && !tc.isPatternLiteralType(type_)
}

func (tc *TypeChecker) isGenericType(type_ Type) bool {
	return !!tc.getGenericObjectFlags(type_)
}

func (tc *TypeChecker) isGenericObjectType(type_ Type) bool {
	return !!(tc.getGenericObjectFlags(type_) & ObjectFlagsIsGenericObjectType)
}

func (tc *TypeChecker) isGenericIndexType(type_ Type) bool {
	return !!(tc.getGenericObjectFlags(type_) & ObjectFlagsIsGenericIndexType)
}

func (tc *TypeChecker) getGenericObjectFlags(type_ Type) ObjectFlags {
	if type_.flags & (TypeFlagsUnionOrIntersection) {
		if !((type_ /* as UnionOrIntersectionType */).objectFlags & ObjectFlagsIsGenericTypeComputed) {
			(type_ /* as UnionOrIntersectionType */).objectFlags |= ObjectFlagsIsGenericTypeComputed | reduceLeft((type_ /* as UnionOrIntersectionType */).types, func(flags number, t Type) number {
				return flags | tc.getGenericObjectFlags(t)
			}, 0)
		}
		return (type_ /* as UnionOrIntersectionType */).objectFlags & ObjectFlagsIsGenericType
	}
	if type_.flags & TypeFlagsSubstitution {
		if !((type_ /* as SubstitutionType */).objectFlags & ObjectFlagsIsGenericTypeComputed) {
			(type_ /* as SubstitutionType */).objectFlags |= ObjectFlagsIsGenericTypeComputed | tc.getGenericObjectFlags((type_ /* as SubstitutionType */).baseType) | tc.getGenericObjectFlags((type_ /* as SubstitutionType */).constraint)
		}
		return (type_ /* as SubstitutionType */).objectFlags & ObjectFlagsIsGenericType
	}
	return (__COND__(type_.flags&TypeFlagsInstantiableNonPrimitive || tc.isGenericMappedType(type_) || tc.isGenericTupleType(type_), ObjectFlagsIsGenericObjectType, 0)) | (__COND__(type_.flags&(TypeFlagsInstantiableNonPrimitive|TypeFlagsIndex) || tc.isGenericStringLikeType(type_), ObjectFlagsIsGenericIndexType, 0))
}

func (tc *TypeChecker) getSimplifiedType(type_ Type, writing bool) Type {
	switch {
	case type_.flags & TypeFlagsIndexedAccess:
		return tc.getSimplifiedIndexedAccessType(type_ /* as IndexedAccessType */, writing)
	case type_.flags & TypeFlagsConditional:
		return tc.getSimplifiedConditionalType(type_ /* as ConditionalType */, writing)
	default:
		return type_
	}
}

func (tc *TypeChecker) distributeIndexOverObjectType(objectType Type, indexType Type, writing bool) Type {
	// (T | U)[K] -> T[K] | U[K] (reading)
	// (T | U)[K] -> T[K] & U[K] (writing)
	// (T & U)[K] -> T[K] & U[K]
	if objectType.flags&TypeFlagsUnion || objectType.flags&TypeFlagsIntersection && !tc.shouldDeferIndexType(objectType) {
		types := map_((objectType /* as UnionOrIntersectionType */).types, func(t Type) Type {
			return tc.getSimplifiedType(tc.getIndexedAccessType(t, indexType), writing)
		})
		if objectType.flags&TypeFlagsIntersection || writing {
			return tc.getIntersectionType(types)
		} else {
			return tc.getUnionType(types)
		}
	}
}

func (tc *TypeChecker) distributeObjectOverIndexType(objectType Type, indexType Type, writing bool) Type {
	// T[A | B] -> T[A] | T[B] (reading)
	// T[A | B] -> T[A] & T[B] (writing)
	if indexType.flags & TypeFlagsUnion {
		types := map_((indexType /* as UnionType */).types, func(t Type) Type {
			return tc.getSimplifiedType(tc.getIndexedAccessType(objectType, t), writing)
		})
		if writing {
			return tc.getIntersectionType(types)
		} else {
			return tc.getUnionType(types)
		}
	}
}

// Transform an indexed access to a simpler form, if possible. Return the simpler form, or return
// the type itself if no transformation is possible. The writing flag indicates that the type is
// the target of an assignment.
func (tc *TypeChecker) getSimplifiedIndexedAccessType(type_ IndexedAccessType, writing bool) Type {
	var cache /* TODO(TS-TO-GO) inferred type "simplifiedForWriting" | "simplifiedForReading" */ any
	if writing {
		cache = "simplifiedForWriting"
	} else {
		cache = "simplifiedForReading"
	}
	if type_[cache] {
		if type_[cache] == tc.circularConstraintType {
			return type_
		} else {
			return type_[cache]
		}
	}
	type_[cache] = tc.circularConstraintType
	// We recursively simplify the object type as it may in turn be an indexed access type. For example, with
	// '{ [P in T]: { [Q in U]: number } }[T][U]' we want to first simplify the inner indexed access type.
	objectType := tc.getSimplifiedType(type_.objectType, writing)
	indexType := tc.getSimplifiedType(type_.indexType, writing)
	// T[A | B] -> T[A] | T[B] (reading)
	// T[A | B] -> T[A] & T[B] (writing)
	distributedOverIndex := tc.distributeObjectOverIndexType(objectType, indexType, writing)
	if distributedOverIndex {
		type_[cache] = distributedOverIndex
		return type_[cache]
	}
	// Only do the inner distributions if the index can no longer be instantiated to cause index distribution again
	if !(indexType.flags & TypeFlagsInstantiable) {
		// (T | U)[K] -> T[K] | U[K] (reading)
		// (T | U)[K] -> T[K] & U[K] (writing)
		// (T & U)[K] -> T[K] & U[K]
		distributedOverObject := tc.distributeIndexOverObjectType(objectType, indexType, writing)
		if distributedOverObject {
			type_[cache] = distributedOverObject
			return type_[cache]
		}
	}
	// So ultimately (reading):
	// ((A & B) | C)[K1 | K2] -> ((A & B) | C)[K1] | ((A & B) | C)[K2] -> (A & B)[K1] | C[K1] | (A & B)[K2] | C[K2] -> (A[K1] & B[K1]) | C[K1] | (A[K2] & B[K2]) | C[K2]

	// A generic tuple type indexed by a number exists only when the index type doesn't select a
	// fixed element. We simplify to either the combined type of all elements (when the index type
	// the actual number type) or to the combined type of all non-fixed elements.
	if tc.isGenericTupleType(objectType) && indexType.flags&TypeFlagsNumberLike {
		elementType := tc.getElementTypeOfSliceOfTupleType(objectType, __COND__(indexType.flags&TypeFlagsNumber, 0, objectType.target.fixedLength) /*endSkipCount*/, 0, writing)
		if elementType {
			type_[cache] = elementType
			return type_[cache]
		}
	}
	// If the object type is a mapped type { [P in K]: E }, where K is generic, or { [P in K as N]: E }, where
	// K is generic and N is assignable to P, instantiate E using a mapper that substitutes the index type for P.
	// For example, for an index access { [P in K]: Box<T[P]> }[X], we construct the type Box<T[X]>.
	if tc.isGenericMappedType(objectType) {
		if tc.getMappedTypeNameTypeKind(objectType) != MappedTypeNameTypeKindRemapping {
			type_[cache] = tc.mapType(tc.substituteIndexedMappedType(objectType, type_.indexType), func(t Type) Type {
				return tc.getSimplifiedType(t, writing)
			})
			return type_[cache]
		}
	}
	type_[cache] = type_
	return type_[cache]
}

func (tc *TypeChecker) getSimplifiedConditionalType(type_ ConditionalType, writing bool) Type {
	checkType := type_.checkType
	extendsType := type_.extendsType
	trueType := tc.getTrueTypeFromConditionalType(type_)
	falseType := tc.getFalseTypeFromConditionalType(type_)
	// Simplifications for types of the form `T extends U ? T : never` and `T extends U ? never : T`.
	if falseType.flags&TypeFlagsNever && tc.getActualTypeVariable(trueType) == tc.getActualTypeVariable(checkType) {
		if checkType.flags&TypeFlagsAny || tc.isTypeAssignableTo(tc.getRestrictiveInstantiation(checkType), tc.getRestrictiveInstantiation(extendsType)) {
			return tc.getSimplifiedType(trueType, writing)
		} else if tc.isIntersectionEmpty(checkType, extendsType) {
			return tc.neverType
		}
	} else if trueType.flags&TypeFlagsNever && tc.getActualTypeVariable(falseType) == tc.getActualTypeVariable(checkType) {
		if !(checkType.flags & TypeFlagsAny) && tc.isTypeAssignableTo(tc.getRestrictiveInstantiation(checkType), tc.getRestrictiveInstantiation(extendsType)) {
			return tc.neverType
		} else if checkType.flags&TypeFlagsAny || tc.isIntersectionEmpty(checkType, extendsType) {
			return tc.getSimplifiedType(falseType, writing)
		}
	}
	return type_
}

/**
 * Invokes union simplification logic to determine if an intersection is considered empty as a union constituent
 */

func (tc *TypeChecker) isIntersectionEmpty(type1 Type, type2 Type) bool {
	return !!(tc.getUnionType([]Type{tc.intersectTypes(type1, type2), tc.neverType}).flags & TypeFlagsNever)
}

// Given an indexed access on a mapped type of the form { [P in K]: E }[X], return an instantiation of E where P is
// replaced with X. Since this simplification doesn't account for mapped type modifiers, add 'undefined' to the
// resulting type if the mapped type includes a '?' modifier or if the modifiers type indicates that some properties
// are optional. If the modifiers type is generic, conservatively estimate optionality by recursively looking for
// mapped types that include '?' modifiers.
func (tc *TypeChecker) substituteIndexedMappedType(objectType MappedType, index Type) Type {
	mapper := tc.createTypeMapper([]TypeParameter{tc.getTypeParameterFromMappedType(objectType)}, []Type{index})
	templateMapper := tc.combineTypeMappers(objectType.mapper, mapper)
	instantiatedTemplateType := tc.instantiateType(tc.getTemplateTypeFromMappedType(objectType.target /* as MappedType */ || objectType), templateMapper)
	isOptional := tc.getMappedTypeOptionality(objectType) > 0 || (__COND__(tc.isGenericType(objectType), tc.getCombinedMappedTypeOptionality(tc.getModifiersTypeFromMappedType(objectType)) > 0, tc.couldAccessOptionalProperty(objectType, index)))
	return tc.addOptionality(instantiatedTemplateType /*isProperty*/, true, isOptional)
}

// Return true if an indexed access with the given object and index types could access an optional property.
func (tc *TypeChecker) couldAccessOptionalProperty(objectType Type, indexType Type) bool {
	indexConstraint := tc.getBaseConstraintOfType(indexType)
	return !!indexConstraint && some(tc.getPropertiesOfType(objectType), func(p Symbol) bool {
		return !!(p.flags & SymbolFlagsOptional) && tc.isTypeAssignableTo(tc.getLiteralTypeFromProperty(p, TypeFlagsStringOrNumberLiteralOrUnique), indexConstraint)
	})
}

func (tc *TypeChecker) getIndexedAccessType(objectType Type, indexType Type, accessFlags AccessFlags /*  = AccessFlags.None */, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	return tc.getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (__COND__(accessNode, tc.errorType, tc.unknownType))
}

func (tc *TypeChecker) indexTypeLessThan(indexType Type, limit number) bool {
	return tc.everyType(indexType, func(t Type) bool {
		if t.flags & TypeFlagsStringOrNumberLiteral {
			propName := getPropertyNameFromType(t /* as StringLiteralType | NumberLiteralType */)
			if isNumericLiteralName(propName) {
				index := +propName
				return index >= 0 && index < limit
			}
		}
		return false
	})
}

func (tc *TypeChecker) getIndexedAccessTypeOrUndefined(objectType Type, indexType Type, accessFlags AccessFlags /*  = AccessFlags.None */, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	if objectType == tc.wildcardType || indexType == tc.wildcardType {
		return tc.wildcardType
	}
	objectType = tc.getReducedType(objectType)
	// If the object type has a string index signature and no other members we know that the result will
	// always be the type of that index signature and we can simplify accordingly.
	if tc.isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlagsNullable) && tc.isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
		indexType = tc.stringType
	}
	// In noUncheckedIndexedAccess mode, indexed access operations that occur in an expression in a read position and resolve to
	// an index signature have 'undefined' included in their type.
	if tc.compilerOptions.noUncheckedIndexedAccess && accessFlags&AccessFlagsExpressionPosition {
		accessFlags |= AccessFlagsIncludeUndefined
	}
	// If the index type is generic, or if the object type is generic and doesn't originate in an expression and
	// the operation isn't exclusively indexing the fixed (non-variadic) portion of a tuple type, we are performing
	// a higher-order index access where we cannot meaningfully access the properties of the object type. Note that
	// for a generic T and a non-generic K, we eagerly resolve T[K] if it originates in an expression. This is to
	// preserve backwards compatibility. For example, an element access 'this["foo"]' has always been resolved
	// eagerly using the constraint type of 'this' at the given location.
	if tc.isGenericIndexType(indexType) || (__COND__(accessNode && accessNode.kind != SyntaxKindIndexedAccessType, tc.isGenericTupleType(objectType) && !tc.indexTypeLessThan(indexType, tc.getTotalFixedElementCount(objectType.target)), tc.isGenericObjectType(objectType) && !(tc.isTupleType(objectType) && tc.indexTypeLessThan(indexType, tc.getTotalFixedElementCount(objectType.target))) || tc.isGenericReducibleType(objectType))) {
		if objectType.flags & TypeFlagsAnyOrUnknown {
			return objectType
		}
		// Defer the operation by creating an indexed access type.
		persistentAccessFlags := accessFlags & AccessFlagsPersistent
		id := objectType.id + "," + indexType.id + "," + persistentAccessFlags + tc.getAliasId(aliasSymbol, aliasTypeArguments)
		type_ := tc.indexedAccessTypes.get(id)
		if !type_ {
			tc.indexedAccessTypes.set(id /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments) */, TODO)
		}

		return type_
	}
	// In the following we resolve T[K] to the type of the property in T selected by K.
	// We treat boolean as different from other unions to improve errors;
	// skipping straight to getPropertyTypeForIndexType gives errors with 'boolean' instead of 'true'.
	apparentObjectType := tc.getReducedApparentType(objectType)
	if indexType.flags&TypeFlagsUnion && !(indexType.flags & TypeFlagsBoolean) {
		var propTypes []Type = []never{}
		wasMissingProp := false
		for _, t := range (indexType /* as UnionType */).types {
			propType := tc.getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags|(__COND__(wasMissingProp, AccessFlagsSuppressNoImplicitAnyError, 0)))
			if propType {
				propTypes.push(propType)
			} else if !accessNode {
				// If there's no error node, we can immeditely stop, since error reporting is off
				return nil
			} else {
				// Otherwise we set a flag and return at the end of the loop so we still mark all errors
				wasMissingProp = true
			}
		}
		if wasMissingProp {
			return nil
		}
		if accessFlags & AccessFlagsWriting {
			return tc.getIntersectionType(propTypes, IntersectionFlagsNone, aliasSymbol, aliasTypeArguments)
		} else {
			return tc.getUnionType(propTypes, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
		}
	}
	return tc.getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags|AccessFlagsCacheSymbol|AccessFlagsReportDeprecated)
}

func (tc *TypeChecker) getTypeFromIndexedAccessTypeNode(node IndexedAccessTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		objectType := tc.getTypeFromTypeNode(node.objectType)
		indexType := tc.getTypeFromTypeNode(node.indexType)
		potentialAlias := tc.getAliasSymbolForTypeNode(node)
		links.resolvedType = tc.getIndexedAccessType(objectType, indexType, AccessFlagsNone, node, potentialAlias, tc.getTypeArgumentsForAliasSymbol(potentialAlias))
	}
	return links.resolvedType
}

func (tc *TypeChecker) getTypeFromMappedTypeNode(node MappedTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		type_ := tc.createObjectType(ObjectFlagsMapped, node.symbol) /* as MappedType */
		type_.declaration = node
		type_.aliasSymbol = tc.getAliasSymbolForTypeNode(node)
		type_.aliasTypeArguments = tc.getTypeArgumentsForAliasSymbol(type_.aliasSymbol)
		links.resolvedType = type_
		// Eagerly resolve the constraint type which forces an error if the constraint type circularly
		// references itself through one or more type aliases.
		tc.getConstraintTypeFromMappedType(type_)
	}
	return links.resolvedType
}

func (tc *TypeChecker) getActualTypeVariable(type_ Type) Type {
	if type_.flags & TypeFlagsSubstitution {
		return tc.getActualTypeVariable((type_ /* as SubstitutionType */).baseType)
	}
	if type_.flags&TypeFlagsIndexedAccess && ((type_ /* as IndexedAccessType */).objectType.flags&TypeFlagsSubstitution || (type_ /* as IndexedAccessType */).indexType.flags&TypeFlagsSubstitution) {
		return tc.getIndexedAccessType(tc.getActualTypeVariable((type_ /* as IndexedAccessType */).objectType), tc.getActualTypeVariable((type_ /* as IndexedAccessType */).indexType))
	}
	return type_
}

func (tc *TypeChecker) isSimpleTupleType(node TypeNode) bool {
	return isTupleTypeNode(node) && length(node.elements) > 0 && !some(node.elements, func(e /* TODO(TS-TO-GO) inferred type TypeNode | NamedTupleMember */ any) bool {
		return isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken)
	})
}

func (tc *TypeChecker) isDeferredType(type_ Type, checkTuples bool) bool {
	return tc.isGenericType(type_) || checkTuples && tc.isTupleType(type_) && some(tc.getElementTypes(type_), tc.isGenericType)
}

func (tc *TypeChecker) getConditionalType(root ConditionalRoot, mapper *TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	var result TODO
	var extraTypes *[]Type
	tailCount := 0
	// We loop here for an immediately nested conditional type in the false position, effectively treating
	// types of the form 'A extends B ? X : C extends D ? Y : E extends F ? Z : ...' as a single construct for
	// purposes of resolution. We also loop here when resolution of a conditional type ends in resolution of
	// another (or, through recursion, possibly the same) conditional type. In the potentially tail-recursive
	// cases we increment the tail recursion counter and stop after 1000 iterations.
	for true {
		if tailCount == 1000 {
			tc.error(tc.currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
			return tc.errorType
		}
		checkType := tc.instantiateType(tc.getActualTypeVariable(root.checkType), mapper)
		extendsType := tc.instantiateType(root.extendsType, mapper)
		if checkType == tc.errorType || extendsType == tc.errorType {
			return tc.errorType
		}
		if checkType == tc.wildcardType || extendsType == tc.wildcardType {
			return tc.wildcardType
		}
		checkTypeNode := skipTypeParentheses(root.node.checkType)
		extendsTypeNode := skipTypeParentheses(root.node.extendsType)
		// When the check and extends types are simple tuple types of the same arity, we defer resolution of the
		// conditional type when any tuple elements are generic. This is such that non-distributable conditional
		// types can be written `[X] extends [Y] ? ...` and be deferred similarly to `X extends Y ? ...`.
		checkTuples := tc.isSimpleTupleType(checkTypeNode) && tc.isSimpleTupleType(extendsTypeNode) && length((checkTypeNode /* as TupleTypeNode */).elements) == length((extendsTypeNode /* as TupleTypeNode */).elements)
		checkTypeDeferred := tc.isDeferredType(checkType, checkTuples)
		var combinedMapper *TypeMapper
		if root.inferTypeParameters {
			// When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be
			// instantiated with the context, so it doesn't need the mapper for the inference context - however the constraint
			// may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].
			// [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated
			// as `number`
			// Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`
			// [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`
			// which is in turn instantiated as `Q`, which is in turn instantiated as `number`.
			// So we need to:
			//    * combine `context.nonFixingMapper` with `mapper` so their constraints can be instantiated in the context of `mapper` (otherwise they'd only get inference context information)
			//    * incorporate all of the component mappers into the combined mapper for the true and false members
			// This means we have two mappers that need applying:
			//    * The original `mapper` used to create this conditional
			//    * The mapper that maps the infer type parameter to its inference result (`context.mapper`)
			context := tc.createInferenceContext(root.inferTypeParameters /*signature*/, nil, InferenceFlagsNone)
			if mapper {
				context.nonFixingMapper = tc.combineTypeMappers(context.nonFixingMapper, mapper)
			}
			if !checkTypeDeferred {
				// We don't want inferences from constraints as they may cause us to eagerly resolve the
				// conditional type instead of deferring resolution. Also, we always want strict function
				// types rules (i.e. proper contravariance) for inferences.
				tc.inferTypes(context.inferences, checkType, extendsType, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
			}
			// It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the
			// those type parameters are used in type references (see getInferredTypeParameterConstraint). For
			// that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.
			if mapper {
				combinedMapper = tc.combineTypeMappers(context.mapper, mapper)
			} else {
				combinedMapper = context.mapper
			}
		}
		// Instantiate the extends type including inferences for 'infer T' type parameters
		var inferredExtendsType Type
		if combinedMapper {
			inferredExtendsType = tc.instantiateType(root.extendsType, combinedMapper)
		} else {
			inferredExtendsType = extendsType
		}
		// We attempt to resolve the conditional type only when the check and extends types are non-generic
		if !checkTypeDeferred && !tc.isDeferredType(inferredExtendsType, checkTuples) {
			// Return falseType for a definitely false extends check. We check an instantiations of the two
			// types with type parameters mapped to the wildcard type, the most permissive instantiations
			// possible (the wildcard type is assignable to and from all types). If those are not related,
			// then no instantiations will be and we can just return the false branch type.
			if !(inferredExtendsType.flags & TypeFlagsAnyOrUnknown) && (checkType.flags&TypeFlagsAny || !tc.isTypeAssignableTo(tc.getPermissiveInstantiation(checkType), tc.getPermissiveInstantiation(inferredExtendsType))) {
				// Return union of trueType and falseType for 'any' since it matches anything. Furthermore, for a
				// distributive conditional type applied to the constraint of a type variable, include trueType if
				// there are possible values of the check type that are also possible values of the extends type.
				// We use a reverse assignability check as it is less expensive than the comparable relationship
				// and avoids false positives of a non-empty intersection check.
				if checkType.flags&TypeFlagsAny || forConstraint && !(inferredExtendsType.flags&TypeFlagsNever) && tc.someType(tc.getPermissiveInstantiation(inferredExtendsType), func(t Type) bool {
					return tc.isTypeAssignableTo(t, tc.getPermissiveInstantiation(checkType))
				}) {
					(extraTypes || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: extraTypes = [] */ TODO)).push(tc.instantiateType(tc.getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper))
				}
				// If falseType is an immediately nested conditional type that isn't distributive or has an
				// identical checkType, switch to that type and loop.
				falseType := tc.getTypeFromTypeNode(root.node.falseType)
				if falseType.flags & TypeFlagsConditional {
					newRoot := (falseType /* as ConditionalType */).root
					if newRoot.node.parent == root.node && (!newRoot.isDistributive || newRoot.checkType == root.checkType) {
						root = newRoot
						continue
					}
					if canTailRecurse(falseType, mapper) {
						continue
					}
				}
				result = tc.instantiateType(falseType, mapper)
				break
			}
			// Return trueType for a definitely true extends check. We check instantiations of the two
			// types with type parameters mapped to their restrictive form, i.e. a form of the type parameter
			// that has no constraint. This ensures that, for example, the type
			//   type Foo<T extends { x: any }> = T extends { x: string } ? string : number
			// doesn't immediately resolve to 'string' instead of being deferred.
			if inferredExtendsType.flags&TypeFlagsAnyOrUnknown || tc.isTypeAssignableTo(tc.getRestrictiveInstantiation(checkType), tc.getRestrictiveInstantiation(inferredExtendsType)) {
				trueType := tc.getTypeFromTypeNode(root.node.trueType)
				trueMapper := combinedMapper || mapper
				if canTailRecurse(trueType, trueMapper) {
					continue
				}
				result = tc.instantiateType(trueType, trueMapper)
				break
			}
		}
		// Return a deferred type for a check that is neither definitely true nor definitely false
		result = tc.createType(TypeFlagsConditional) /* as ConditionalType */
		result.root = root
		result.checkType = tc.instantiateType(root.checkType, mapper)
		result.extendsType = tc.instantiateType(root.extendsType, mapper)
		result.mapper = mapper
		result.combinedMapper = combinedMapper
		result.aliasSymbol = aliasSymbol || root.aliasSymbol
		if aliasSymbol {
			result.aliasTypeArguments = aliasTypeArguments
		} else {
			result.aliasTypeArguments = tc.instantiateTypes(root.aliasTypeArguments, mapper)
		}
		// TODO: GH#18217
		break
	}
	if extraTypes {
		return tc.getUnionType(append(extraTypes, result))
	} else {
		return result
	}
	// We tail-recurse for generic conditional types that (a) have not already been evaluated and cached, and
	// (b) are non distributive, have a check type that is unaffected by instantiation, or have a non-union check
	// type. Note that recursion is possible only through aliased conditional types, so we only increment the tail
	// recursion counter for those.
	canTailRecurse := func(newType Type, newMapper *TypeMapper) bool {
		if newType.flags&TypeFlagsConditional && newMapper {
			newRoot := (newType /* as ConditionalType */).root
			if newRoot.outerTypeParameters {
				typeParamMapper := tc.combineTypeMappers((newType /* as ConditionalType */).mapper, newMapper)
				typeArguments := map_(newRoot.outerTypeParameters, func(t TypeParameter) Type {
					return tc.getMappedType(t, typeParamMapper)
				})
				newRootMapper := tc.createTypeMapper(newRoot.outerTypeParameters, typeArguments)
				var newCheckType Type
				if newRoot.isDistributive {
					newCheckType = tc.getMappedType(newRoot.checkType, newRootMapper)
				} else {
					newCheckType = nil
				}
				if !newCheckType || newCheckType == newRoot.checkType || !(newCheckType.flags & (TypeFlagsUnion | TypeFlagsNever)) {
					root = newRoot
					mapper = newRootMapper
					aliasSymbol = nil
					aliasTypeArguments = nil
					if newRoot.aliasSymbol {
						tailCount++
					}
					return true
				}
			}
		}
		return false
	}

}

func (tc *TypeChecker) getTrueTypeFromConditionalType(type_ ConditionalType) Type {
	return type_.resolvedTrueType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper) */ TODO)
}

func (tc *TypeChecker) getFalseTypeFromConditionalType(type_ ConditionalType) Type {
	return type_.resolvedFalseType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper) */ TODO)
}

func (tc *TypeChecker) getInferredTrueTypeFromConditionalType(type_ ConditionalType) Type {
	return type_.resolvedInferredTrueType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type) */ TODO)
}

func (tc *TypeChecker) getInferTypeParameters(node ConditionalTypeNode) *[]TypeParameter {
	var result *[]TypeParameter
	if node.locals {
		node.locals.forEach(func(symbol Symbol) {
			if symbol.flags & SymbolFlagsTypeParameter {
				result = append(result, tc.getDeclaredTypeOfSymbol(symbol))
			}
		})
	}
	return result
}

func (tc *TypeChecker) isDistributionDependent(root ConditionalRoot) bool {
	return root.isDistributive && (tc.isTypeParameterPossiblyReferenced(root.checkType /* as TypeParameter */, root.node.trueType) || tc.isTypeParameterPossiblyReferenced(root.checkType /* as TypeParameter */, root.node.falseType))
}

func (tc *TypeChecker) getTypeFromConditionalTypeNode(node ConditionalTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		checkType := tc.getTypeFromTypeNode(node.checkType)
		aliasSymbol := tc.getAliasSymbolForTypeNode(node)
		aliasTypeArguments := tc.getTypeArgumentsForAliasSymbol(aliasSymbol)
		allOuterTypeParameters := tc.getOuterTypeParameters(node /*includeThisTypes*/, true)
		var outerTypeParameters *[]TypeParameter
		if aliasTypeArguments {
			outerTypeParameters = allOuterTypeParameters
		} else {
			outerTypeParameters = filter(allOuterTypeParameters, func(tp TypeParameter) bool {
				return tc.isTypeParameterPossiblyReferenced(tp, node)
			})
		}
		var root ConditionalRoot = map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"node":                node,
			"checkType":           checkType,
			"extendsType":         tc.getTypeFromTypeNode(node.extendsType),
			"isDistributive":      !!(checkType.flags & TypeFlagsTypeParameter),
			"inferTypeParameters": tc.getInferTypeParameters(node),
			"outerTypeParameters": outerTypeParameters,
			"instantiations":      nil,
			"aliasSymbol":         aliasSymbol,
			"aliasTypeArguments":  aliasTypeArguments,
		}
		links.resolvedType = tc.getConditionalType(root /*mapper*/, nil /*forConstraint*/, false)
		if outerTypeParameters {
			root.instantiations = NewMap[string, Type]()
			root.instantiations.set(tc.getTypeListId(outerTypeParameters), links.resolvedType)
		}
	}
	return links.resolvedType
}

func (tc *TypeChecker) getTypeFromInferTypeNode(node InferTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		links.resolvedType = tc.getDeclaredTypeOfTypeParameter(tc.getSymbolOfDeclaration(node.typeParameter))
	}
	return links.resolvedType
}

func (tc *TypeChecker) getIdentifierChain(node EntityName) []Identifier {
	if isIdentifier(node) {
		return []Identifier{node}
	} else {
		return append(tc.getIdentifierChain(node.left), node.right)
	}
}

func (tc *TypeChecker) getTypeFromImportTypeNode(node ImportTypeNode) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		if !isLiteralImportTypeNode(node) {
			tc.error(node.argument, Diagnostics.String_literal_expected)
			links.resolvedSymbol = tc.unknownSymbol
			links.resolvedType = tc.errorType
			return links.resolvedType
		}
		var targetMeaning number
		switch {
		case node.isTypeOf:
			targetMeaning = SymbolFlagsValue
		case node.flags & NodeFlagsJSDoc:
			targetMeaning = SymbolFlagsValue | SymbolFlagsType
		default:
			targetMeaning = SymbolFlagsType
		}
		// TODO: Future work: support unions/generics/whatever via a deferred import-type
		innerModuleSymbol := tc.resolveExternalModuleName(node, node.argument.literal)
		if !innerModuleSymbol {
			links.resolvedSymbol = tc.unknownSymbol
			links.resolvedType = tc.errorType
			return links.resolvedType
		}
		isExportEquals := !!innerModuleSymbol.exports. /* ? */ get(InternalSymbolNameExportEquals)
		moduleSymbol := tc.resolveExternalModuleSymbol(innerModuleSymbol /*dontResolveAlias*/, false)
		if !nodeIsMissing(node.qualifier) {
			var nameStack []Identifier = tc.getIdentifierChain(node.qualifier)
			currentNamespace := moduleSymbol
			var current *Identifier
			for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: current = nameStack.shift() */ TODO {
				var meaning number
				if nameStack.length {
					meaning = SymbolFlagsNamespace
				} else {
					meaning = targetMeaning
				}
				// typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`
				// That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from
				// the `exports` lookup process that only looks up namespace members which is used for most type references
				mergedResolvedSymbol := tc.getMergedSymbol(tc.resolveSymbol(currentNamespace))
				var symbolFromVariable Symbol
				if node.isTypeOf || isInJSFile(node) && isExportEquals {
					symbolFromVariable = tc.getPropertyOfType(tc.getTypeOfSymbol(mergedResolvedSymbol), current.escapedText /*skipObjectFunctionPropertyAugment*/, false /*includeTypeOnlyMembers*/, true)
				} else {
					symbolFromVariable = nil
				}
				var symbolFromModule Symbol
				if node.isTypeOf {
					symbolFromModule = nil
				} else {
					symbolFromModule = tc.getSymbol(tc.getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning)
				}
				next := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: symbolFromModule ?? symbolFromVariable */ TODO
				if !next {
					tc.error(current, Diagnostics.Namespace_0_has_no_exported_member_1, tc.getFullyQualifiedName(currentNamespace), declarationNameToString(current))
					links.resolvedType = tc.errorType
					return links.resolvedType
				}
				tc.getNodeLinks(current).resolvedSymbol = next
				tc.getNodeLinks(current.parent).resolvedSymbol = next
				currentNamespace = next
			}
			links.resolvedType = tc.resolveImportSymbolType(node, links, currentNamespace, targetMeaning)
		} else {
			if moduleSymbol.flags & targetMeaning {
				links.resolvedType = tc.resolveImportSymbolType(node, links, moduleSymbol, targetMeaning)
			} else {
				var errorMessage DiagnosticMessage
				if targetMeaning == SymbolFlagsValue {
					errorMessage = Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here
				} else {
					errorMessage = Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0
				}

				tc.error(node, errorMessage, node.argument.literal.text)

				links.resolvedSymbol = tc.unknownSymbol
				links.resolvedType = tc.errorType
			}
		}
	}
	return links.resolvedType
}

func (tc *TypeChecker) resolveImportSymbolType(node ImportTypeNode, links NodeLinks, symbol Symbol, meaning SymbolFlags) Type {
	resolvedSymbol := tc.resolveSymbol(symbol)
	links.resolvedSymbol = resolvedSymbol
	if meaning == SymbolFlagsValue {
		return tc.getInstantiationExpressionType(tc.getTypeOfSymbol(symbol), node)
		// intentionally doesn't use resolved symbol so type is cached as expected on the alias
	} else {
		return tc.getTypeReferenceType(node, resolvedSymbol)
		// getTypeReferenceType doesn't handle aliases - it must get the resolved symbol
	}
}

func (tc *TypeChecker) getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */ any) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		// Deferred resolution of members is handled by resolveObjectTypeMembers
		aliasSymbol := tc.getAliasSymbolForTypeNode(node)
		if tc.getMembersOfSymbol(node.symbol).size == 0 && !aliasSymbol {
			links.resolvedType = tc.emptyTypeLiteralType
		} else {
			type_ := tc.createObjectType(ObjectFlagsAnonymous, node.symbol)
			type_.aliasSymbol = aliasSymbol
			type_.aliasTypeArguments = tc.getTypeArgumentsForAliasSymbol(aliasSymbol)
			if isJSDocTypeLiteral(node) && node.isArrayType {
				type_ = tc.createArrayType(type_)
			}
			links.resolvedType = type_
		}
	}
	return links.resolvedType
}

func (tc *TypeChecker) getAliasSymbolForTypeNode(node Node) Symbol {
	host := node.parent
	for isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator == SyntaxKindReadonlyKeyword {
		host = host.parent
	}
	if isTypeAlias(host) {
		return tc.getSymbolOfDeclaration(host)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getTypeArgumentsForAliasSymbol(symbol Symbol) *[]TypeParameter {
	if symbol {
		return tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
	} else {
		return nil
	}
}

func (tc *TypeChecker) isNonGenericObjectType(type_ Type) bool {
	return !!(type_.flags & TypeFlagsObject) && !tc.isGenericMappedType(type_)
}

func (tc *TypeChecker) isEmptyObjectTypeOrSpreadsIntoEmptyObject(type_ Type) bool {
	return tc.isEmptyObjectType(type_) || !!(type_.flags & (TypeFlagsNull | TypeFlagsUndefined | TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex))
}

func (tc *TypeChecker) tryMergeUnionOfObjectTypeAndEmptyObject(type_ Type, readonly bool) Type {
	if !(type_.flags & TypeFlagsUnion) {
		return type_
	}
	if every((type_ /* as UnionType */).types, tc.isEmptyObjectTypeOrSpreadsIntoEmptyObject) {
		return find((type_ /* as UnionType */).types, tc.isEmptyObjectType) || tc.emptyObjectType
	}
	firstType := find((type_ /* as UnionType */).types, func(t Type) bool {
		return !tc.isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
	})
	if !firstType {
		return type_
	}
	secondType := find((type_ /* as UnionType */).types, func(t Type) bool {
		return t != firstType && !tc.isEmptyObjectTypeOrSpreadsIntoEmptyObject(t)
	})
	if secondType {
		return type_
	}
	return getAnonymousPartialType(firstType)

	getAnonymousPartialType := func(type_ Type) ResolvedType {
		// gets the type as if it had been spread, but where everything in the spread is made optional
		members := createSymbolTable()
		for _, prop := range tc.getPropertiesOfType(type_) {
			if getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				// do nothing, skip privates
			} else if tc.isSpreadableProperty(prop) {
				isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
				flags := SymbolFlagsProperty | SymbolFlagsOptional
				result := tc.createSymbol(flags, prop.escapedName, tc.getIsLateCheckFlag(prop)|(__COND__(readonly, CheckFlagsReadonly, 0)))
				if isSetonlyAccessor {
					result.links.type_ = tc.undefinedType
				} else {
					result.links.type_ = tc.addOptionality(tc.getTypeOfSymbol(prop) /*isProperty*/, true)
				}
				result.declarations = prop.declarations
				result.links.nameType = tc.getSymbolLinks(prop).nameType
				result.links.syntheticOrigin = prop
				members.set(prop.escapedName, result)
			}
		}
		spread := tc.createAnonymousType(type_.symbol, members, emptyArray, emptyArray, tc.getIndexInfosOfType(type_))
		spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		return spread
	}

}

/**
 * Since the source of spread types are object literals, which are not binary,
 * this function should be called in a left folding style, with left = previous result of getSpreadType
 * and right = the new element to be spread.
 */

func (tc *TypeChecker) getSpreadType(left Type, right Type, symbol Symbol, objectFlags ObjectFlags, readonly bool) Type {
	if left.flags&TypeFlagsAny || right.flags&TypeFlagsAny {
		return tc.anyType
	}
	if left.flags&TypeFlagsUnknown || right.flags&TypeFlagsUnknown {
		return tc.unknownType
	}
	if left.flags & TypeFlagsNever {
		return right
	}
	if right.flags & TypeFlagsNever {
		return left
	}
	left = tc.tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly)
	if left.flags & TypeFlagsUnion {
		if tc.checkCrossProductUnion([]Type{left, right}) {
			return tc.mapType(left, func(t Type) Type {
				return tc.getSpreadType(t, right, symbol, objectFlags, readonly)
			})
		} else {
			return tc.errorType
		}
	}
	right = tc.tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly)
	if right.flags & TypeFlagsUnion {
		if tc.checkCrossProductUnion([]Type{left, right}) {
			return tc.mapType(right, func(t Type) Type {
				return tc.getSpreadType(left, t, symbol, objectFlags, readonly)
			})
		} else {
			return tc.errorType
		}
	}
	if right.flags & (TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex) {
		return left
	}

	if tc.isGenericObjectType(left) || tc.isGenericObjectType(right) {
		if tc.isEmptyObjectType(left) {
			return right
		}
		// When the left type is an intersection, we may need to merge the last constituent of the
		// intersection with the right type. For example when the left type is 'T & { a: string }'
		// and the right type is '{ b: string }' we produce 'T & { a: string, b: string }'.
		if left.flags & TypeFlagsIntersection {
			types := (left /* as IntersectionType */).types
			lastLeft := types[types.length-1]
			if tc.isNonGenericObjectType(lastLeft) && tc.isNonGenericObjectType(right) {
				return tc.getIntersectionType(concatenate(types.slice(0, types.length-1), []Type{tc.getSpreadType(lastLeft, right, symbol, objectFlags, readonly)}))
			}
		}
		return tc.getIntersectionType([]Type{left, right})
	}

	members := createSymbolTable()
	skippedPrivateMembers := NewSet[__String]()
	var indexInfos []IndexInfo
	if left == tc.emptyObjectType {
		indexInfos = tc.getIndexInfosOfType(right)
	} else {
		indexInfos = tc.getUnionIndexInfos([]Type{left, right})
	}

	for _, rightProp := range tc.getPropertiesOfType(right) {
		if getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
			skippedPrivateMembers.add(rightProp.escapedName)
		} else if tc.isSpreadableProperty(rightProp) {
			members.set(rightProp.escapedName, tc.getSpreadSymbol(rightProp, readonly))
		}
	}

	for _, leftProp := range tc.getPropertiesOfType(left) {
		if skippedPrivateMembers.has(leftProp.escapedName) || !tc.isSpreadableProperty(leftProp) {
			continue
		}
		if members.has(leftProp.escapedName) {
			rightProp := members.get(leftProp.escapedName)
			rightType := tc.getTypeOfSymbol(rightProp)
			if rightProp.flags & SymbolFlagsOptional {
				declarations := concatenate(leftProp.declarations, rightProp.declarations)
				flags := SymbolFlagsProperty | (leftProp.flags & SymbolFlagsOptional)
				result := tc.createSymbol(flags, leftProp.escapedName)
				// Optimization: avoid calculating the union type if spreading into the exact same type.
				// This is common, e.g. spreading one options bag into another where the bags have the
				// same type, or have properties which overlap. If the unions are large, it may turn out
				// to be expensive to perform subtype reduction.
				leftType := tc.getTypeOfSymbol(leftProp)
				leftTypeWithoutUndefined := tc.removeMissingOrUndefinedType(leftType)
				rightTypeWithoutUndefined := tc.removeMissingOrUndefinedType(rightType)
				if leftTypeWithoutUndefined == rightTypeWithoutUndefined {
					result.links.type_ = leftType
				} else {
					result.links.type_ = tc.getUnionType([]Type{leftType, rightTypeWithoutUndefined}, UnionReductionSubtype)
				}
				result.links.leftSpread = leftProp
				result.links.rightSpread = rightProp
				result.declarations = declarations
				result.links.nameType = tc.getSymbolLinks(leftProp).nameType
				members.set(leftProp.escapedName, result)
			}
		} else {
			members.set(leftProp.escapedName, tc.getSpreadSymbol(leftProp, readonly))
		}
	}

	spread := tc.createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, func(info IndexInfo) IndexInfo {
		return tc.getIndexInfoWithReadonly(info, readonly)
	}))
	spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral | ObjectFlagsContainsSpread | objectFlags
	return spread
}

/** We approximate own properties as non-methods plus methods that are inside the object literal */

func (tc *TypeChecker) isSpreadableProperty(prop Symbol) bool {
	return !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) && (!(prop.flags & (SymbolFlagsMethod | SymbolFlagsGetAccessor | SymbolFlagsSetAccessor)) || !prop.declarations. /* ? */ some(func(decl Declaration) bool {
		return isClassLike(decl.parent)
	}))
}

func (tc *TypeChecker) getSpreadSymbol(prop Symbol, readonly bool) Symbol {
	isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
	if !isSetonlyAccessor && readonly == tc.isReadonlySymbol(prop) {
		return prop
	}
	flags := SymbolFlagsProperty | (prop.flags & SymbolFlagsOptional)
	result := tc.createSymbol(flags, prop.escapedName, tc.getIsLateCheckFlag(prop)|(__COND__(readonly, CheckFlagsReadonly, 0)))
	if isSetonlyAccessor {
		result.links.type_ = tc.undefinedType
	} else {
		result.links.type_ = tc.getTypeOfSymbol(prop)
	}
	result.declarations = prop.declarations
	result.links.nameType = tc.getSymbolLinks(prop).nameType
	result.links.syntheticOrigin = prop
	return result
}

func (tc *TypeChecker) getIndexInfoWithReadonly(info IndexInfo, readonly bool) IndexInfo {
	if info.isReadonly != readonly {
		return tc.createIndexInfo(info.keyType, info.type_, readonly, info.declaration)
	} else {
		return info
	}
}

func (tc *TypeChecker) createLiteralType(flags TypeFlags, value /* TODO(TS-TO-GO) TypeNode UnionType: string | number | PseudoBigInt */ any, symbol Symbol, regularType LiteralType) LiteralType {
	type_ := tc.createTypeWithSymbol(flags, symbol) /* as LiteralType */
	type_.value = value
	type_.regularType = regularType || type_
	return type_
}

func (tc *TypeChecker) getFreshTypeOfLiteralType(type_ Type) Type {
	if type_.flags & TypeFlagsFreshable {
		if !(type_ /* as FreshableType */).freshType {
			freshType := tc.createLiteralType(type_.flags, (type_ /* as LiteralType */).value, (type_ /* as LiteralType */).symbol, type_ /* as LiteralType */)
			freshType.freshType = freshType
			(type_ /* as FreshableType */).freshType = freshType
		}
		return (type_ /* as FreshableType */).freshType
	}
	return type_
}

func (tc *TypeChecker) getRegularTypeOfLiteralType(type_ Type) Type {
	switch {
	case type_.flags & TypeFlagsFreshable:
		return (type_ /* as FreshableType */).regularType
	case type_.flags & TypeFlagsUnion:
		return ((type_ /* as UnionType */).regularType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: (type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType */ TODO))
	default:
		return type_
	}
}

func (tc *TypeChecker) isFreshLiteralType(type_ Type) bool {
	return !!(type_.flags & TypeFlagsFreshable) && (type_ /* as LiteralType */).freshType == type_
}

func (tc *TypeChecker) getStringLiteralType(value string) StringLiteralType {
	var type_ TODO
	return tc.stringLiteralTypes.get(value) || ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type */ TODO)
}

func (tc *TypeChecker) getNumberLiteralType(value number) NumberLiteralType {
	var type_ TODO
	return tc.numberLiteralTypes.get(value) || ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type */ TODO)
}

func (tc *TypeChecker) getBigIntLiteralType(value PseudoBigInt) BigIntLiteralType {
	var type_ TODO
	key := pseudoBigIntToString(value)
	return tc.bigIntLiteralTypes.get(key) || ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type */ TODO)
}

func (tc *TypeChecker) getEnumLiteralType(value /* TODO(TS-TO-GO) TypeNode UnionType: string | number */ any, enumId number, symbol Symbol) LiteralType {
	var type_ TODO
	key := __TEMPLATE__(enumId, __COND__( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof value */ TODO == "string", "@", "#"), value)
	flags := TypeFlagsEnumLiteral | (__COND__( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof value */ TODO == "string", TypeFlagsStringLiteral, TypeFlagsNumberLiteral))
	return tc.enumLiteralTypes.get(key) || ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type */ TODO)
}

func (tc *TypeChecker) getTypeFromLiteralTypeNode(node LiteralTypeNode) Type {
	if node.literal.kind == SyntaxKindNullKeyword {
		return tc.nullType
	}
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		links.resolvedType = tc.getRegularTypeOfLiteralType(tc.checkExpression(node.literal))
	}
	return links.resolvedType
}

func (tc *TypeChecker) createUniqueESSymbolType(symbol Symbol) UniqueESSymbolType {
	type_ := tc.createTypeWithSymbol(TypeFlagsUniqueESSymbol, symbol)                                 /* as UniqueESSymbolType */
	type_.escapedName = __TEMPLATE__("__@", type_.symbol.escapedName, "@", getSymbolId(type_.symbol)) /* as __String */
	return type_
}

func (tc *TypeChecker) getESSymbolLikeTypeForNode(node Node) Type {
	if isInJSFile(node) && isJSDocTypeExpression(node) {
		host := getJSDocHost(node)
		if host {
			node = getSingleVariableOfVariableStatement(host) || host
		}
	}
	if isValidESSymbolDeclaration(node) {
		var symbol Symbol
		if isCommonJsExportPropertyAssignment(node) {
			symbol = tc.getSymbolOfNode((node /* as BinaryExpression */).left)
		} else {
			symbol = tc.getSymbolOfNode(node)
		}
		if symbol {
			links := tc.getSymbolLinks(symbol)
			return links.uniqueESSymbolType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.uniqueESSymbolType = createUniqueESSymbolType(symbol) */ TODO)
		}
	}
	return tc.esSymbolType
}

func (tc *TypeChecker) getThisType(node Node) Type {
	container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
	parent := container && container.parent
	if parent && (isClassLike(parent) || parent.kind == SyntaxKindInterfaceDeclaration) {
		if !isStatic(container) && (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body)) {
			return tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfDeclaration(parent /* as ClassLikeDeclaration | InterfaceDeclaration */)).thisType
		}
	}

	// inside x.prototype = { ... }
	if parent && isObjectLiteralExpression(parent) && isBinaryExpression(parent.parent) && getAssignmentDeclarationKind(parent.parent) == AssignmentDeclarationKindPrototype {
		return tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfNode(parent.parent.left).parent).thisType
	}
	// /** @return {this} */
	// x.prototype.m = function() { ... }
	var host *SignatureDeclaration
	if node.flags & NodeFlagsJSDoc {
		host = getHostSignatureFromJSDoc(node)
	} else {
		host = nil
	}
	if host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(host.parent) == AssignmentDeclarationKindPrototypeProperty {
		return tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfNode(host.parent.left).parent).thisType
	}
	// inside constructor function C() { ... }
	if tc.isJSConstructor(container) && isNodeDescendantOf(node, container.body) {
		return tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfDeclaration(container)).thisType
	}
	tc.error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface)
	return tc.errorType
}

func (tc *TypeChecker) getTypeFromThisTypeNode(node /* TODO(TS-TO-GO) TypeNode UnionType: ThisExpression | ThisTypeNode */ any) Type {
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		links.resolvedType = tc.getThisType(node)
	}
	return links.resolvedType
}

func (tc *TypeChecker) getTypeFromRestTypeNode(node /* TODO(TS-TO-GO) TypeNode UnionType: RestTypeNode | NamedTupleMember */ any) Type {
	return tc.getTypeFromTypeNode(tc.getArrayElementTypeNode(node.type_) || node.type_)
}

func (tc *TypeChecker) getArrayElementTypeNode(node TypeNode) *TypeNode {
	switch node.kind {
	case SyntaxKindParenthesizedType:
		return tc.getArrayElementTypeNode((node /* as ParenthesizedTypeNode */).type_)
	case SyntaxKindTupleType:
		if (node /* as TupleTypeNode */).elements.length == 1 {
			node = (node /* as TupleTypeNode */).elements[0]
			if node.kind == SyntaxKindRestType || node.kind == SyntaxKindNamedTupleMember && (node /* as NamedTupleMember */).dotDotDotToken {
				return tc.getArrayElementTypeNode((node /* as RestTypeNode | NamedTupleMember */).type_)
			}
		}
	case SyntaxKindArrayType:
		return (node /* as ArrayTypeNode */).elementType
	}
	return nil
}

func (tc *TypeChecker) getTypeFromNamedTupleTypeNode(node NamedTupleMember) Type {
	links := tc.getNodeLinks(node)
	return links.resolvedType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) : addOptionality(getTypeFromTypeNode(node.type), /*isProperty* / true, !!node.questionToken) */ TODO)
}

func (tc *TypeChecker) getTypeFromTypeNode(node TypeNode) Type {
	return tc.getConditionalFlowTypeOfType(tc.getTypeFromTypeNodeWorker(node), node)
}

func (tc *TypeChecker) getTypeFromTypeNodeWorker(node TypeNode) Type {
	switch node.kind {
	case SyntaxKindAnyKeyword,
		SyntaxKindJSDocAllType,
		SyntaxKindJSDocUnknownType:
		return tc.anyType
	case SyntaxKindUnknownKeyword:
		return tc.unknownType
	case SyntaxKindStringKeyword:
		return tc.stringType
	case SyntaxKindNumberKeyword:
		return tc.numberType
	case SyntaxKindBigIntKeyword:
		return tc.bigintType
	case SyntaxKindBooleanKeyword:
		return tc.booleanType
	case SyntaxKindSymbolKeyword:
		return tc.esSymbolType
	case SyntaxKindVoidKeyword:
		return tc.voidType
	case SyntaxKindUndefinedKeyword:
		return tc.undefinedType
	case SyntaxKindNullKeyword /* as TypeNodeSyntaxKind */ :
		return tc.nullType
	case SyntaxKindNeverKeyword:
		return tc.neverType
	case SyntaxKindObjectKeyword:
		if node.flags&NodeFlagsJavaScriptFile && !tc.noImplicitAny {
			return tc.anyType
		} else {
			return tc.nonPrimitiveType
		}
	case SyntaxKindIntrinsicKeyword:
		return tc.intrinsicMarkerType
	case SyntaxKindThisType,
		SyntaxKindThisKeyword /* as TypeNodeSyntaxKind */ :
		return tc.getTypeFromThisTypeNode(node /* as ThisExpression | ThisTypeNode */)
	case SyntaxKindLiteralType:
		return tc.getTypeFromLiteralTypeNode(node /* as LiteralTypeNode */)
	case SyntaxKindTypeReference:
		return tc.getTypeFromTypeReference(node /* as TypeReferenceNode */)
	case SyntaxKindTypePredicate:
		if (node /* as TypePredicateNode */).assertsModifier {
			return tc.voidType
		} else {
			return tc.booleanType
		}
	case SyntaxKindExpressionWithTypeArguments:
		return tc.getTypeFromTypeReference(node /* as ExpressionWithTypeArguments */)
	case SyntaxKindTypeQuery:
		return tc.getTypeFromTypeQueryNode(node /* as TypeQueryNode */)
	case SyntaxKindArrayType,
		SyntaxKindTupleType:
		return tc.getTypeFromArrayOrTupleTypeNode(node /* as ArrayTypeNode | TupleTypeNode */)
	case SyntaxKindOptionalType:
		return tc.getTypeFromOptionalTypeNode(node /* as OptionalTypeNode */)
	case SyntaxKindUnionType:
		return tc.getTypeFromUnionTypeNode(node /* as UnionTypeNode */)
	case SyntaxKindIntersectionType:
		return tc.getTypeFromIntersectionTypeNode(node /* as IntersectionTypeNode */)
	case SyntaxKindJSDocNullableType:
		return tc.getTypeFromJSDocNullableTypeNode(node /* as JSDocNullableType */)
	case SyntaxKindJSDocOptionalType:
		return tc.addOptionality(tc.getTypeFromTypeNode((node /* as JSDocOptionalType */).type_))
	case SyntaxKindNamedTupleMember:
		return tc.getTypeFromNamedTupleTypeNode(node /* as NamedTupleMember */)
	case SyntaxKindParenthesizedType,
		SyntaxKindJSDocNonNullableType,
		SyntaxKindJSDocTypeExpression:
		return tc.getTypeFromTypeNode((node /* as ParenthesizedTypeNode | JSDocTypeReferencingNode | JSDocTypeExpression | NamedTupleMember */).type_)
	case SyntaxKindRestType:
		return tc.getTypeFromRestTypeNode(node /* as RestTypeNode */)
	case SyntaxKindJSDocVariadicType:
		return tc.getTypeFromJSDocVariadicType(node /* as JSDocVariadicType */)
	case SyntaxKindFunctionType,
		SyntaxKindConstructorType,
		SyntaxKindTypeLiteral,
		SyntaxKindJSDocTypeLiteral,
		SyntaxKindJSDocFunctionType,
		SyntaxKindJSDocSignature:
		return tc.getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node /* as TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */)
	case SyntaxKindTypeOperator:
		return tc.getTypeFromTypeOperatorNode(node /* as TypeOperatorNode */)
	case SyntaxKindIndexedAccessType:
		return tc.getTypeFromIndexedAccessTypeNode(node /* as IndexedAccessTypeNode */)
	case SyntaxKindMappedType:
		return tc.getTypeFromMappedTypeNode(node /* as MappedTypeNode */)
	case SyntaxKindConditionalType:
		return tc.getTypeFromConditionalTypeNode(node /* as ConditionalTypeNode */)
	case SyntaxKindInferType:
		return tc.getTypeFromInferTypeNode(node /* as InferTypeNode */)
	case SyntaxKindTemplateLiteralType:
		return tc.getTypeFromTemplateTypeNode(node /* as TemplateLiteralTypeNode */)
	case SyntaxKindImportType:
		return tc.getTypeFromImportTypeNode(node /* as ImportTypeNode */)
	case SyntaxKindIdentifier, /* as TypeNodeSyntaxKind */
		SyntaxKindQualifiedName, /* as TypeNodeSyntaxKind */
		SyntaxKindPropertyAccessExpression /* as TypeNodeSyntaxKind */ :
		symbol := tc.getSymbolAtLocation(node)
		if symbol {
			return tc.getDeclaredTypeOfSymbol(symbol)
		} else {
			return tc.errorType
		}
	default:
		return tc.errorType
	}
}

/* OVERLOAD: function instantiateList<T>(items: readonly T[], mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[]; */
/* OVERLOAD: function instantiateList<T>(items: readonly T[] | undefined, mapper: TypeMapper, instantiator: (item: T, mapper: TypeMapper) => T): readonly T[] | undefined; */
func (tc *TypeChecker) instantiateList(items *[]T, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) *[]T {
	if items && items.length {
		for i := 0; i < items.length; i++ {
			item := items[i]
			mapped := instantiator(item, mapper)
			if item != mapped {
				var result []T
				if i == 0 {
					result = []never{}
				} else {
					result = items.slice(0, i)
				}
				result.push(mapped)
				for i++; i < items.length; i++ {
					result.push(instantiator(items[i], mapper))
				}
				return result
			}
		}
	}
	return items
}

/* OVERLOAD: function instantiateTypes(types: readonly Type[], mapper: TypeMapper): readonly Type[]; */
/* OVERLOAD: function instantiateTypes(types: readonly Type[] | undefined, mapper: TypeMapper): readonly Type[] | undefined; */
func (tc *TypeChecker) instantiateTypes(types *[]Type, mapper TypeMapper) *[]Type {
	return tc.instantiateList(types, mapper, tc.instantiateType)
}

func (tc *TypeChecker) instantiateSignatures(signatures []Signature, mapper TypeMapper) []Signature {
	return tc.instantiateList(signatures, mapper, tc.instantiateSignature)
}

func (tc *TypeChecker) instantiateIndexInfos(indexInfos []IndexInfo, mapper TypeMapper) []IndexInfo {
	return tc.instantiateList(indexInfos, mapper, tc.instantiateIndexInfo)
}

func (tc *TypeChecker) createTypeMapper(sources []TypeParameter, targets *[]Type) TypeMapper {
	if sources.length == 1 {
		return tc.makeUnaryTypeMapper(sources[0], __COND__(targets, targets[0], tc.anyType))
	} else {
		return tc.makeArrayTypeMapper(sources, targets)
	}
}

func (tc *TypeChecker) getMappedType(type_ Type, mapper TypeMapper) Type {
	switch mapper.kind {
	case TypeMapKindSimple:
		if type_ == mapper.source {
			return mapper.target
		} else {
			return type_
		}
	case TypeMapKindArray:
		sources := mapper.sources
		targets := mapper.targets
		for i := 0; i < sources.length; i++ {
			if type_ == sources[i] {
				if targets {
					return targets[i]
				} else {
					return tc.anyType
				}
			}
		}
		return type_
		fallthrough
	case TypeMapKindDeferred:
		sources := mapper.sources
		targets := mapper.targets
		for i := 0; i < sources.length; i++ {
			if type_ == sources[i] {
				return targets[i]()
			}
		}
		return type_
		fallthrough
	case TypeMapKindFunction:
		return mapper.func_(type_)
	case TypeMapKindComposite,
		TypeMapKindMerged:
		t1 := tc.getMappedType(type_, mapper.mapper1)
		if t1 != type_ && mapper.kind == TypeMapKindComposite {
			return tc.instantiateType(t1, mapper.mapper2)
		} else {
			return tc.getMappedType(t1, mapper.mapper2)
		}
	}
}

func (tc *TypeChecker) makeUnaryTypeMapper(source Type, target Type) TypeMapper {
	return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind":   TypeMapKindSimple,
		"source": source,
		"target": target,
	})
}

func (tc *TypeChecker) makeArrayTypeMapper(sources []TypeParameter, targets *[]Type) TypeMapper {
	return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind":    TypeMapKindArray,
		"sources": sources,
		"targets": targets,
	})
}

func (tc *TypeChecker) makeFunctionTypeMapper(func_ func(t Type) Type, debugInfo func() string) TypeMapper {
	return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind":      TypeMapKindFunction,
		"func_":     func_,
		"debugInfo": __COND__(Debug.isDebugging, debugInfo, nil),
	})
}

func (tc *TypeChecker) makeDeferredTypeMapper(sources []TypeParameter, targets []func() Type) TypeMapper {
	return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind":    TypeMapKindDeferred,
		"sources": sources,
		"targets": targets,
	})
}

func (tc *TypeChecker) makeCompositeTypeMapper(kind /* TODO(TS-TO-GO) TypeNode UnionType: TypeMapKind.Composite | TypeMapKind.Merged */ any, mapper1 TypeMapper, mapper2 TypeMapper) TypeMapper {
	return Debug.attachDebugPrototypeIfDebug(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind":    kind,
		"mapper1": mapper1,
		"mapper2": mapper2,
	})
}

func (tc *TypeChecker) createTypeEraser(sources []TypeParameter) TypeMapper {
	return tc.createTypeMapper(sources /*targets*/, nil)
}

/**
 * Maps forward-references to later types parameters to the empty object type.
 * This is used during inference when instantiating type parameter defaults.
 */

func (tc *TypeChecker) createBackreferenceMapper(context InferenceContext, index number) TypeMapper {
	forwardInferences := context.inferences.slice(index)
	return tc.createTypeMapper(map_(forwardInferences, func(i InferenceInfo) TypeParameter {
		return i.typeParameter
	}), map_(forwardInferences, func() IntrinsicType {
		return tc.unknownType
	}))
}

func (tc *TypeChecker) combineTypeMappers(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
	if mapper1 {
		return tc.makeCompositeTypeMapper(TypeMapKindComposite, mapper1, mapper2)
	} else {
		return mapper2
	}
}

func (tc *TypeChecker) mergeTypeMappers(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
	if mapper1 {
		return tc.makeCompositeTypeMapper(TypeMapKindMerged, mapper1, mapper2)
	} else {
		return mapper2
	}
}

func (tc *TypeChecker) prependTypeMapping(source Type, target Type, mapper *TypeMapper) TypeMapper {
	if !mapper {
		return tc.makeUnaryTypeMapper(source, target)
	} else {
		return tc.makeCompositeTypeMapper(TypeMapKindMerged, tc.makeUnaryTypeMapper(source, target), mapper)
	}
}

func (tc *TypeChecker) appendTypeMapping(mapper *TypeMapper, source Type, target Type) TypeMapper {
	if !mapper {
		return tc.makeUnaryTypeMapper(source, target)
	} else {
		return tc.makeCompositeTypeMapper(TypeMapKindMerged, mapper, tc.makeUnaryTypeMapper(source, target))
	}
}

func (tc *TypeChecker) getRestrictiveTypeParameter(tp TypeParameter) Type {
	if !tp.constraint && !tc.getConstraintDeclaration(tp) || tp.constraint == tc.noConstraintType {
		return tp
	} else {
		return tp.restrictiveInstantiation || ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation */ TODO)
	}
}

func (tc *TypeChecker) cloneTypeParameter(typeParameter TypeParameter) TypeParameter {
	result := tc.createTypeParameter(typeParameter.symbol)
	result.target = typeParameter
	return result
}

func (tc *TypeChecker) instantiateTypePredicate(predicate TypePredicate, mapper TypeMapper) TypePredicate {
	return tc.createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, tc.instantiateType(predicate.type_, mapper))
}

func (tc *TypeChecker) instantiateSignature(signature Signature, mapper TypeMapper, eraseTypeParameters bool) Signature {
	var freshTypeParameters *[]TypeParameter
	if signature.typeParameters && !eraseTypeParameters {
		// First create a fresh set of type parameters, then include a mapping from the old to the
		// new type parameters in the mapper function. Finally store this mapper in the new type
		// parameters such that we can use it when instantiating constraints.
		freshTypeParameters = map_(signature.typeParameters, tc.cloneTypeParameter)
		mapper = tc.combineTypeMappers(tc.createTypeMapper(signature.typeParameters, freshTypeParameters), mapper)
		for _, tp := range freshTypeParameters {
			tp.mapper = mapper
		}
	}
	// Don't compute resolvedReturnType and resolvedTypePredicate now,
	// because using `mapper` now could trigger inferences to become fixed. (See `createInferenceContext`.)
	// See GH#17600.
	result := tc.createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && tc.instantiateSymbol(signature.thisParameter, mapper), tc.instantiateList(signature.parameters, mapper, tc.instantiateSymbol) /*resolvedReturnType*/, nil /*resolvedTypePredicate*/, nil, signature.minArgumentCount, signature.flags&SignatureFlagsPropagatingFlags)
	result.target = signature
	result.mapper = mapper
	return result
}

func (tc *TypeChecker) instantiateSymbol(symbol Symbol, mapper TypeMapper) Symbol {
	links := tc.getSymbolLinks(symbol)
	// If the type of the symbol is already resolved, and if that type could not possibly
	// be affected by instantiation, simply return the symbol itself.
	if links.type_ && !tc.couldContainTypeVariables(links.type_) {
		if !(symbol.flags & SymbolFlagsSetAccessor) {
			return symbol
		}
		// If we're a setter, check writeType.
		if links.writeType && !tc.couldContainTypeVariables(links.writeType) {
			return symbol
		}
	}
	if getCheckFlags(symbol) & CheckFlagsInstantiated {
		// If symbol being instantiated is itself a instantiation, fetch the original target and combine the
		// type mappers. This ensures that original type identities are properly preserved and that aliases
		// always reference a non-aliases.
		symbol = links.target
		mapper = tc.combineTypeMappers(links.mapper, mapper)
	}
	// Keep the flags from the symbol we're instantiating.  Mark that is instantiated, and
	// also transient so that we can just store data on it directly.
	result := tc.createSymbol(symbol.flags, symbol.escapedName, CheckFlagsInstantiated|getCheckFlags(symbol)&(CheckFlagsReadonly|CheckFlagsLate|CheckFlagsOptionalParameter|CheckFlagsRestParameter))
	result.declarations = symbol.declarations
	result.parent = symbol.parent
	result.links.target = symbol
	result.links.mapper = mapper
	if symbol.valueDeclaration {
		result.valueDeclaration = symbol.valueDeclaration
	}
	if links.nameType {
		result.links.nameType = links.nameType
	}
	return result
}

func (tc *TypeChecker) getObjectTypeInstantiation(type_ /* TODO(TS-TO-GO) TypeNode UnionType: AnonymousType | DeferredTypeReference */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	var declaration /* TODO(TS-TO-GO) inferred type Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode */ any
	switch {
	case type_.objectFlags & ObjectFlagsReference:
		declaration = (type_ /* as TypeReference */).node
	case type_.objectFlags & ObjectFlagsInstantiationExpressionType:
		declaration = (type_ /* as InstantiationExpressionType */).node
	default:
		declaration = type_.symbol.declarations[0]
	}
	links := tc.getNodeLinks(declaration)
	var target AnonymousType
	switch {
	case type_.objectFlags & ObjectFlagsReference:
		target = links.resolvedType /* as DeferredTypeReference */
	case type_.objectFlags & ObjectFlagsInstantiated:
		target = type_.target
	default:
		target = type_
	}
	var typeParameters *[]TypeParameter
	if type_.objectFlags & ObjectFlagsSingleSignatureType {
		typeParameters = (type_ /* as SingleSignatureType */).outerTypeParameters
	} else {
		typeParameters = links.outerTypeParameters
	}
	if !typeParameters {
		// The first time an anonymous type is instantiated we compute and store a list of the type
		// parameters that are in scope (and therefore potentially referenced). For type literals that
		// aren't the right hand side of a generic type alias declaration we optimize by reducing the
		// set of type parameters to those that are possibly referenced in the literal.
		outerTypeParameters := tc.getOuterTypeParameters(declaration /*includeThisTypes*/, true)
		if tc.isJSConstructor(declaration) {
			templateTagParameters := tc.getTypeParametersFromDeclaration(declaration /* as DeclarationWithTypeParameters */)
			outerTypeParameters = addRange(outerTypeParameters, templateTagParameters)
		}
		typeParameters = outerTypeParameters || emptyArray
		var allDeclarations [] /* TODO(TS-TO-GO) inferred type (Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode) */ any
		if type_.objectFlags & (ObjectFlagsReference | ObjectFlagsInstantiationExpressionType) {
			allDeclarations = [] /* TODO(TS-TO-GO) inferred type Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode */ any{declaration}
		} else {
			allDeclarations = type_.symbol.declarations
		}
		if (target.objectFlags&(ObjectFlagsReference|ObjectFlagsInstantiationExpressionType) || target.symbol.flags&SymbolFlagsMethod || target.symbol.flags&SymbolFlagsTypeLiteral) && !target.aliasTypeArguments {
			typeParameters = filter(typeParameters, func(tp TypeParameter) bool {
				return some(allDeclarations, func(d /* TODO(TS-TO-GO) inferred type Declaration | NodeWithTypeArguments | ArrayTypeNode | TupleTypeNode */ any) bool {
					return tc.isTypeParameterPossiblyReferenced(tp, d)
				})
			})
		} else {
			typeParameters = typeParameters
		}
		links.outerTypeParameters = typeParameters
	}
	if typeParameters.length {
		// We are instantiating an anonymous type that has one or more type parameters in scope. Apply the
		// mapper to the type parameters to produce the effective list of type arguments, and compute the
		// instantiation cache key from the type IDs of the type arguments.
		combinedMapper := tc.combineTypeMappers(type_.mapper, mapper)
		typeArguments := map_(typeParameters, func(t TypeParameter) Type {
			return tc.getMappedType(t, combinedMapper)
		})
		newAliasSymbol := aliasSymbol || type_.aliasSymbol
		var newAliasTypeArguments *[]Type
		if aliasSymbol {
			newAliasTypeArguments = aliasTypeArguments
		} else {
			newAliasTypeArguments = tc.instantiateTypes(type_.aliasTypeArguments, mapper)
		}
		id := (__COND__(type_.objectFlags&ObjectFlagsSingleSignatureType, "S", "")) + tc.getTypeListId(typeArguments) + tc.getAliasId(newAliasSymbol, newAliasTypeArguments)
		if !target.instantiations {
			target.instantiations = NewMap[string, Type]()
			target.instantiations.set(tc.getTypeListId(typeParameters)+tc.getAliasId(target.aliasSymbol, target.aliasTypeArguments), target)
		}
		result := target.instantiations.get(id)
		if !result {
			if type_.objectFlags & ObjectFlagsSingleSignatureType {
				result = tc.instantiateAnonymousType(type_, mapper)
				target.instantiations.set(id, result)
				return result
			}
			newMapper := tc.createTypeMapper(typeParameters, typeArguments)
			switch {
			case target.objectFlags & ObjectFlagsReference:
				result = tc.createDeferredTypeReference((type_ /* as DeferredTypeReference */).target, (type_ /* as DeferredTypeReference */).node, newMapper, newAliasSymbol, newAliasTypeArguments)
			case target.objectFlags & ObjectFlagsMapped:
				result = tc.instantiateMappedType(target /* as MappedType */, newMapper, newAliasSymbol, newAliasTypeArguments)
			default:
				result = tc.instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments)
			}
			target.instantiations.set(id, result)
			// Set cached result early in case we recursively invoke instantiation while eagerly computing type variable visibility below
			resultObjectFlags := getObjectFlags(result)
			if result.flags&TypeFlagsObjectFlagsType && !(resultObjectFlags & ObjectFlagsCouldContainTypeVariablesComputed) {
				resultCouldContainTypeVariables := some(typeArguments, tc.couldContainTypeVariables)
				// one of the input type arguments might be or contain the result
				if !(getObjectFlags(result) & ObjectFlagsCouldContainTypeVariablesComputed) {
					// if `result` is one of the object types we tried to make (it may not be, due to how `instantiateMappedType` works), we can carry forward the type variable containment check from the input type arguments
					if resultObjectFlags & (ObjectFlagsMapped | ObjectFlagsAnonymous | ObjectFlagsReference) {
						(result /* as ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | (__COND__(resultCouldContainTypeVariables, ObjectFlagsCouldContainTypeVariables, 0))
					} else {
						if !resultCouldContainTypeVariables {
							(result /* as ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed
						} else {
							(result /* as ObjectFlagsType */).objectFlags |= 0
						}
					}
				}
			}
		}
		return result
	}
	return type_
}

func (tc *TypeChecker) maybeTypeParameterReference(node Node) bool {
	return !(node.parent.kind == SyntaxKindTypeReference && (node.parent /* as TypeReferenceNode */).typeArguments && node == (node.parent /* as TypeReferenceNode */).typeName || node.parent.kind == SyntaxKindImportType && (node.parent /* as ImportTypeNode */).typeArguments && node == (node.parent /* as ImportTypeNode */).qualifier)
}

func (tc *TypeChecker) isTypeParameterPossiblyReferenced(tp TypeParameter, node Node) bool {
	// If the type parameter doesn't have exactly one declaration, if there are intervening statement blocks
	// between the node and the type parameter declaration, if the node contains actual references to the
	// type parameter, or if the node contains type queries that we can't prove couldn't contain references to the type parameter,
	// we consider the type parameter possibly referenced.
	if tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length == 1 {
		container := tp.symbol.declarations[0].parent
		for n := node; n != container; n = n.parent {
			if !n || n.kind == SyntaxKindBlock || n.kind == SyntaxKindConditionalType && forEachChild((n /* as ConditionalTypeNode */).extendsType, containsReference) {
				return true
			}
		}
		return containsReference(node)
	}
	return true
	containsReference := func(node Node) bool {
		switch node.kind {
		case SyntaxKindThisType:
			return !!tp.isThisType
		case SyntaxKindIdentifier:
			return !tp.isThisType && isPartOfTypeNode(node) && tc.maybeTypeParameterReference(node) && tc.getTypeFromTypeNodeWorker(node /* as TypeNode */) == tp
			// use worker because we're looking for === equality
		case SyntaxKindTypeQuery:
			entityName := (node /* as TypeQueryNode */).exprName
			firstIdentifier := getFirstIdentifier(entityName)
			if !isThisIdentifier(firstIdentifier) {
				firstIdentifierSymbol := tc.getResolvedSymbol(firstIdentifier)
				tpDeclaration := tp.symbol.declarations[0]
				// There is exactly one declaration, otherwise `containsReference` is not called
				var tpScope Node
				switch {
				case tpDeclaration.kind == SyntaxKindTypeParameter:
					tpScope = tpDeclaration.parent
				case tp.isThisType:
					tpScope = tpDeclaration
				default:
					tpScope = nil
				}
				// Type parameter's declaration was unrecognized, e.g. comes from JSDoc annotation.
				if firstIdentifierSymbol.declarations && tpScope {
					return some(firstIdentifierSymbol.declarations, func(idDecl Declaration) bool {
						return isNodeDescendantOf(idDecl, tpScope)
					}) || some((node /* as TypeQueryNode */).typeArguments, containsReference)
				}
			}
			return true
		case SyntaxKindMethodDeclaration,
			SyntaxKindMethodSignature:
			return !(node /* as FunctionLikeDeclaration */).type_ && !!(node /* as FunctionLikeDeclaration */).body || some((node /* as FunctionLikeDeclaration */).typeParameters, containsReference) || some((node /* as FunctionLikeDeclaration */).parameters, containsReference) || !!(node /* as FunctionLikeDeclaration */).type_ && containsReference((node /* as FunctionLikeDeclaration */).type_)
		}
		return !!forEachChild(node, containsReference)
	}

}

func (tc *TypeChecker) getHomomorphicTypeVariable(type_ MappedType) *TypeParameter {
	constraintType := tc.getConstraintTypeFromMappedType(type_)
	if constraintType.flags & TypeFlagsIndex {
		typeVariable := tc.getActualTypeVariable((constraintType /* as IndexType */).type_)
		if typeVariable.flags & TypeFlagsTypeParameter {
			return typeVariable /* as TypeParameter */
		}
	}
	return nil
}

func (tc *TypeChecker) instantiateMappedType(type_ MappedType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	// For a homomorphic mapped type { [P in keyof T]: X }, where T is some type variable, the mapping
	// operation depends on T as follows:
	// * If T is a primitive type no mapping is performed and the result is simply T.
	// * If T is a union type we distribute the mapped type over the union.
	// * If T is an array we map to an array where the element type has been transformed.
	// * If T is a tuple we map to a tuple where the element types have been transformed.
	// * If T is an intersection of array or tuple types we map to an intersection of transformed array or tuple types.
	// * Otherwise we map to an object type where the type of each property has been transformed.
	// For example, when T is instantiated to a union type A | B, we produce { [P in keyof A]: X } |
	// { [P in keyof B]: X }, and when when T is instantiated to a union type A | undefined, we produce
	// { [P in keyof A]: X } | undefined.
	typeVariable := tc.getHomomorphicTypeVariable(type_)
	if typeVariable {
		mappedTypeVariable := tc.instantiateType(typeVariable, mapper)
		if typeVariable != mappedTypeVariable {
			return tc.mapTypeWithAlias(tc.getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments)
		}
	}
	// If the constraint type of the instantiation is the wildcard type, return the wildcard type.
	if tc.instantiateType(tc.getConstraintTypeFromMappedType(type_), mapper) == tc.wildcardType {
		return tc.wildcardType
	} else {
		return tc.instantiateAnonymousType(type_, mapper, aliasSymbol, aliasTypeArguments)
	}

	instantiateConstituent := func(t Type) Type {
		if t.flags&(TypeFlagsAnyOrUnknown|TypeFlagsInstantiableNonPrimitive|TypeFlagsObject|TypeFlagsIntersection) && t != tc.wildcardType && !tc.isErrorType(t) {
			if !type_.declaration.nameType {
				var constraint TODO
				if tc.isArrayType(t) || t.flags&TypeFlagsAny && tc.findResolutionCycleStartIndex(typeVariable, TypeSystemPropertyNameImmediateBaseConstraint) < 0 && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: constraint = getConstraintOfTypeParameter(typeVariable!) */ TODO) && tc.everyType(constraint, tc.isArrayOrTupleType) {
					return tc.instantiateMappedArrayType(t, type_, tc.prependTypeMapping(typeVariable, t, mapper))
				}
				if tc.isTupleType(t) {
					return tc.instantiateMappedTupleType(t, type_, typeVariable, mapper)
				}
				if tc.isArrayOrTupleOrIntersection(t) {
					return tc.getIntersectionType(map_((t /* as IntersectionType */).types, instantiateConstituent))
				}
			}
			return tc.instantiateAnonymousType(type_, tc.prependTypeMapping(typeVariable, t, mapper))
		}
		return t
	}

}

func (tc *TypeChecker) getModifiedReadonlyState(state bool, modifiers MappedTypeModifiers) bool {
	switch {
	case modifiers & MappedTypeModifiersIncludeReadonly:
		return true
	case modifiers & MappedTypeModifiersExcludeReadonly:
		return false
	default:
		return state
	}
}

func (tc *TypeChecker) instantiateMappedTupleType(tupleType TupleTypeReference, mappedType MappedType, typeVariable TypeVariable, mapper TypeMapper) Type {
	// We apply the mapped type's template type to each of the fixed part elements. For variadic elements, we
	// apply the mapped type itself to the variadic element type. For other elements in the variable part of the
	// tuple, we surround the element type with an array type and apply the mapped type to that. This ensures
	// that we get sequential property key types for the fixed part of the tuple, and property key type number
	// for the remaining elements. For example
	//
	//   type Keys<T> = { [K in keyof T]: K };
	//   type Foo<T extends any[]> = Keys<[string, string, ...T, string]>; // ["0", "1", ...Keys<T>, number]
	//
	elementFlags := tupleType.target.elementFlags
	fixedLength := tupleType.target.fixedLength
	var fixedMapper TypeMapper
	if fixedLength {
		fixedMapper = tc.prependTypeMapping(typeVariable, tupleType, mapper)
	} else {
		fixedMapper = mapper
	}
	newElementTypes := map_(tc.getElementTypes(tupleType), func(type_ Type, i number) Type {
		flags := elementFlags[i]
		switch {
		case i < fixedLength:
			return tc.instantiateMappedTypeTemplate(mappedType, tc.getStringLiteralType(""+i), !!(flags & ElementFlagsOptional), fixedMapper)
		case flags & ElementFlagsVariadic:
			return tc.instantiateType(mappedType, tc.prependTypeMapping(typeVariable, type_, mapper))
		default:
			return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType */ TODO
		}
	})
	modifiers := tc.getMappedTypeModifiers(mappedType)
	var newElementFlags []ElementFlags
	switch {
	case modifiers & MappedTypeModifiersIncludeOptional:
		newElementFlags = map_(elementFlags, func(f ElementFlags) ElementFlags {
			if f & ElementFlagsRequired {
				return ElementFlagsOptional
			} else {
				return f
			}
		})
	case modifiers & MappedTypeModifiersExcludeOptional:
		newElementFlags = map_(elementFlags, func(f ElementFlags) ElementFlags {
			if f & ElementFlagsOptional {
				return ElementFlagsRequired
			} else {
				return f
			}
		})
	default:
		newElementFlags = elementFlags
	}
	newReadonly := tc.getModifiedReadonlyState(tupleType.target.readonly, tc.getMappedTypeModifiers(mappedType))
	if contains(newElementTypes, tc.errorType) {
		return tc.errorType
	} else {
		return tc.createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations)
	}
}

func (tc *TypeChecker) instantiateMappedArrayType(arrayType Type, mappedType MappedType, mapper TypeMapper) /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any {
	elementType := tc.instantiateMappedTypeTemplate(mappedType, tc.numberType /*isOptional*/, true, mapper)
	if tc.isErrorType(elementType) {
		return tc.errorType
	} else {
		return tc.createArrayType(elementType, tc.getModifiedReadonlyState(tc.isReadonlyArrayType(arrayType), tc.getMappedTypeModifiers(mappedType)))
	}
}

func (tc *TypeChecker) instantiateMappedTypeTemplate(type_ MappedType, key Type, isOptional bool, mapper TypeMapper) Type {
	templateMapper := tc.appendTypeMapping(mapper, tc.getTypeParameterFromMappedType(type_), key)
	propType := tc.instantiateType(tc.getTemplateTypeFromMappedType(type_.target /* as MappedType */ || type_), templateMapper)
	modifiers := tc.getMappedTypeModifiers(type_)
	switch {
	case tc.strictNullChecks && modifiers&MappedTypeModifiersIncludeOptional && !tc.maybeTypeOfKind(propType, TypeFlagsUndefined|TypeFlagsVoid):
		return tc.getOptionalType(propType /*isProperty*/, true)
	case tc.strictNullChecks && modifiers&MappedTypeModifiersExcludeOptional && isOptional:
		return tc.getTypeWithFacts(propType, TypeFactsNEUndefined)
	default:
		return propType
	}
}

func (tc *TypeChecker) instantiateAnonymousType(type_ AnonymousType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) AnonymousType {
	Debug.assert(type_.symbol, "anonymous type must have symbol to be instantiated")
	result := tc.createObjectType(type_.objectFlags&~(ObjectFlagsCouldContainTypeVariablesComputed|ObjectFlagsCouldContainTypeVariables)|ObjectFlagsInstantiated, type_.symbol) /* as AnonymousType */
	if type_.objectFlags & ObjectFlagsMapped {
		(result /* as MappedType */).declaration = (type_ /* as MappedType */).declaration
		// C.f. instantiateSignature
		origTypeParameter := tc.getTypeParameterFromMappedType(type_ /* as MappedType */)
		freshTypeParameter := tc.cloneTypeParameter(origTypeParameter)
		(result /* as MappedType */).typeParameter = freshTypeParameter
		mapper = tc.combineTypeMappers(tc.makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper)
		freshTypeParameter.mapper = mapper
	}
	if type_.objectFlags & ObjectFlagsInstantiationExpressionType {
		(result /* as InstantiationExpressionType */).node = (type_ /* as InstantiationExpressionType */).node
	}
	if type_.objectFlags & ObjectFlagsSingleSignatureType {
		(result /* as SingleSignatureType */).outerTypeParameters = (type_ /* as SingleSignatureType */).outerTypeParameters
	}
	result.target = type_
	result.mapper = mapper
	result.aliasSymbol = aliasSymbol || type_.aliasSymbol
	if aliasSymbol {
		result.aliasTypeArguments = aliasTypeArguments
	} else {
		result.aliasTypeArguments = tc.instantiateTypes(type_.aliasTypeArguments, mapper)
	}
	if result.aliasTypeArguments {
		result.objectFlags |= tc.getPropagatingFlagsOfTypes(result.aliasTypeArguments)
	} else {
		result.objectFlags |= 0
	}
	return result
}

func (tc *TypeChecker) getConditionalTypeInstantiation(type_ ConditionalType, mapper TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
	root := type_.root
	if root.outerTypeParameters {
		// We are instantiating a conditional type that has one or more type parameters in scope. Apply the
		// mapper to the type parameters to produce the effective list of type arguments, and compute the
		// instantiation cache key from the type IDs of the type arguments.
		typeArguments := map_(root.outerTypeParameters, func(t TypeParameter) Type {
			return tc.getMappedType(t, mapper)
		})
		id := (__COND__(forConstraint, "C", "")) + tc.getTypeListId(typeArguments) + tc.getAliasId(aliasSymbol, aliasTypeArguments)
		result := root.instantiations.get(id)
		if !result {
			newMapper := tc.createTypeMapper(root.outerTypeParameters, typeArguments)
			checkType := root.checkType
			var distributionType Type
			if root.isDistributive {
				distributionType = tc.getReducedType(tc.getMappedType(checkType, newMapper))
			} else {
				distributionType = nil
			}
			// Distributive conditional types are distributed over union types. For example, when the
			// distributive conditional type T extends U ? X : Y is instantiated with A | B for T, the
			// result is (A extends U ? X : Y) | (B extends U ? X : Y).
			if distributionType && checkType != distributionType && distributionType.flags&(TypeFlagsUnion|TypeFlagsNever) {
				result = tc.mapTypeWithAlias(distributionType, func(t Type) Type {
					return tc.getConditionalType(root, tc.prependTypeMapping(checkType, t, newMapper), forConstraint)
				}, aliasSymbol, aliasTypeArguments)
			} else {
				result = tc.getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments)
			}
			root.instantiations.set(id, result)
		}
		return result
	}
	return type_
}

/* OVERLOAD: function instantiateType(type: Type, mapper: TypeMapper | undefined): Type; */
/* OVERLOAD: function instantiateType(type: Type | undefined, mapper: TypeMapper | undefined): Type | undefined; */
func (tc *TypeChecker) instantiateType(type_ Type, mapper *TypeMapper) Type {
	if type_ && mapper {
		return tc.instantiateTypeWithAlias(type_, mapper /*aliasSymbol*/, nil /*aliasTypeArguments*/, nil)
	} else {
		return type_
	}
}

func (tc *TypeChecker) instantiateTypeWithAlias(type_ Type, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments *[]Type) Type {
	if !tc.couldContainTypeVariables(type_) {
		return type_
	}
	if tc.instantiationDepth == 100 || tc.instantiationCount >= 5000000 {
		// We have reached 100 recursive type instantiations, or 5M type instantiations caused by the same statement
		// or expression. There is a very high likelyhood we're dealing with a combination of infinite generic types
		// that perpetually generate new type identities, so we stop the recursion here by yielding the error type.
		tracing. /* ? */ instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"typeId":             type_.id,
			"instantiationDepth": instantiationDepth,
			"instantiationCount": instantiationCount,
		})
		tc.error(tc.currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
		return tc.errorType
	}
	tc.totalInstantiationCount++
	tc.instantiationCount++
	tc.instantiationDepth++
	result := tc.instantiateTypeWorker(type_, mapper, aliasSymbol, aliasTypeArguments)
	tc.instantiationDepth--
	return result
}

func (tc *TypeChecker) instantiateTypeWorker(type_ Type, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments *[]Type) Type {
	flags := type_.flags
	if flags & TypeFlagsTypeParameter {
		return tc.getMappedType(type_, mapper)
	}
	if flags & TypeFlagsObject {
		objectFlags := (type_ /* as ObjectType */).objectFlags
		if objectFlags & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped) {
			if objectFlags&ObjectFlagsReference && !(type_ /* as TypeReference */).node {
				resolvedTypeArguments := (type_ /* as TypeReference */).resolvedTypeArguments
				newTypeArguments := tc.instantiateTypes(resolvedTypeArguments, mapper)
				if newTypeArguments != resolvedTypeArguments {
					return tc.createNormalizedTypeReference((type_ /* as TypeReference */).target, newTypeArguments)
				} else {
					return type_
				}
			}
			if objectFlags & ObjectFlagsReverseMapped {
				return tc.instantiateReverseMappedType(type_ /* as ReverseMappedType */, mapper)
			}
			return tc.getObjectTypeInstantiation(type_ /* as TypeReference | AnonymousType | MappedType */, mapper, aliasSymbol, aliasTypeArguments)
		}
		return type_
	}
	if flags & TypeFlagsUnionOrIntersection {
		var origin Type
		if type_.flags & TypeFlagsUnion {
			origin = (type_ /* as UnionType */).origin
		} else {
			origin = nil
		}
		var types []Type
		if origin && origin.flags&TypeFlagsUnionOrIntersection {
			types = (origin /* as UnionOrIntersectionType */).types
		} else {
			types = (type_ /* as UnionOrIntersectionType */).types
		}
		newTypes := tc.instantiateTypes(types, mapper)
		if newTypes == types && aliasSymbol == type_.aliasSymbol {
			return type_
		}
		newAliasSymbol := aliasSymbol || type_.aliasSymbol
		var newAliasTypeArguments *[]Type
		if aliasSymbol {
			newAliasTypeArguments = aliasTypeArguments
		} else {
			newAliasTypeArguments = tc.instantiateTypes(type_.aliasTypeArguments, mapper)
		}
		if flags&TypeFlagsIntersection || origin && origin.flags&TypeFlagsIntersection {
			return tc.getIntersectionType(newTypes, IntersectionFlagsNone, newAliasSymbol, newAliasTypeArguments)
		} else {
			return tc.getUnionType(newTypes, UnionReductionLiteral, newAliasSymbol, newAliasTypeArguments)
		}
	}
	if flags & TypeFlagsIndex {
		return tc.getIndexType(tc.instantiateType((type_ /* as IndexType */).type_, mapper))
	}
	if flags & TypeFlagsTemplateLiteral {
		return tc.getTemplateLiteralType((type_ /* as TemplateLiteralType */).texts, tc.instantiateTypes((type_ /* as TemplateLiteralType */).types, mapper))
	}
	if flags & TypeFlagsStringMapping {
		return tc.getStringMappingType((type_ /* as StringMappingType */).symbol, tc.instantiateType((type_ /* as StringMappingType */).type_, mapper))
	}
	if flags & TypeFlagsIndexedAccess {
		newAliasSymbol := aliasSymbol || type_.aliasSymbol
		var newAliasTypeArguments *[]Type
		if aliasSymbol {
			newAliasTypeArguments = aliasTypeArguments
		} else {
			newAliasTypeArguments = tc.instantiateTypes(type_.aliasTypeArguments, mapper)
		}
		return tc.getIndexedAccessType(tc.instantiateType((type_ /* as IndexedAccessType */).objectType, mapper), tc.instantiateType((type_ /* as IndexedAccessType */).indexType, mapper), (type_ /* as IndexedAccessType */).accessFlags /*accessNode*/, nil, newAliasSymbol, newAliasTypeArguments)
	}
	if flags & TypeFlagsConditional {
		return tc.getConditionalTypeInstantiation(type_ /* as ConditionalType */, tc.combineTypeMappers((type_ /* as ConditionalType */).mapper, mapper) /*forConstraint*/, false, aliasSymbol, aliasTypeArguments)
	}
	if flags & TypeFlagsSubstitution {
		newBaseType := tc.instantiateType((type_ /* as SubstitutionType */).baseType, mapper)
		if tc.isNoInferType(type_) {
			return tc.getNoInferType(newBaseType)
		}
		newConstraint := tc.instantiateType((type_ /* as SubstitutionType */).constraint, mapper)
		// A substitution type originates in the true branch of a conditional type and can be resolved
		// to just the base type in the same cases as the conditional type resolves to its true branch
		// (because the base type is then known to satisfy the constraint).
		if newBaseType.flags&TypeFlagsTypeVariable && tc.isGenericType(newConstraint) {
			return tc.getSubstitutionType(newBaseType, newConstraint)
		}
		if newConstraint.flags&TypeFlagsAnyOrUnknown || tc.isTypeAssignableTo(tc.getRestrictiveInstantiation(newBaseType), tc.getRestrictiveInstantiation(newConstraint)) {
			return newBaseType
		}
		if newBaseType.flags & TypeFlagsTypeVariable {
			return tc.getSubstitutionType(newBaseType, newConstraint)
		} else {
			return tc.getIntersectionType([]Type{newConstraint, newBaseType})
		}
	}
	return type_
}

func (tc *TypeChecker) instantiateReverseMappedType(type_ ReverseMappedType, mapper TypeMapper) Type {
	innerMappedType := tc.instantiateType(type_.mappedType, mapper)
	if !(getObjectFlags(innerMappedType) & ObjectFlagsMapped) {
		return type_
	}
	innerIndexType := tc.instantiateType(type_.constraintType, mapper)
	if !(innerIndexType.flags & TypeFlagsIndex) {
		return type_
	}
	instantiated := tc.inferTypeForHomomorphicMappedType(tc.instantiateType(type_.source, mapper), innerMappedType /* as MappedType */, innerIndexType /* as IndexType */)
	if instantiated {
		return instantiated
	}
	return type_
	// Nested invocation of `inferTypeForHomomorphicMappedType` or the `source` instantiated into something unmappable
}

func (tc *TypeChecker) getPermissiveInstantiation(type_ Type) Type {
	if type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever) {
		return type_
	} else {
		return type_.permissiveInstantiation || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type.permissiveInstantiation = instantiateType(type, permissiveMapper) */ TODO)
	}
}

func (tc *TypeChecker) getRestrictiveInstantiation(type_ Type) Type {
	if type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever) {
		return type_
	}
	if type_.restrictiveInstantiation {
		return type_.restrictiveInstantiation
	}
	type_.restrictiveInstantiation = tc.instantiateType(type_, tc.restrictiveMapper)
	// We set the following so we don't attempt to set the restrictive instance of a restrictive instance
	// which is redundant - we'll produce new type identities, but all type params have already been mapped.
	// This also gives us a way to detect restrictive instances upon comparisons and _disable_ the "distributeive constraint"
	// assignability check for them, which is distinctly unsafe, as once you have a restrctive instance, all the type parameters
	// are constrained to `unknown` and produce tons of false positives/negatives!
	type_.restrictiveInstantiation.restrictiveInstantiation = type_.restrictiveInstantiation
	return type_.restrictiveInstantiation
}

func (tc *TypeChecker) instantiateIndexInfo(info IndexInfo, mapper TypeMapper) IndexInfo {
	return tc.createIndexInfo(info.keyType, tc.instantiateType(info.type_, mapper), info.isReadonly, info.declaration)
}

// Returns true if the given expression contains (at any level of nesting) a function or arrow expression
// that is subject to contextual typing.
func (tc *TypeChecker) isContextSensitive(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild */ any) bool {
	Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
	switch node.kind {
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindMethodDeclaration,
		SyntaxKindFunctionDeclaration:
		return tc.isContextSensitiveFunctionLikeDeclaration(node /* as FunctionExpression | ArrowFunction | MethodDeclaration */)
	case SyntaxKindObjectLiteralExpression:
		return some((node /* as ObjectLiteralExpression */).properties, tc.isContextSensitive)
	case SyntaxKindArrayLiteralExpression:
		return some((node /* as ArrayLiteralExpression */).elements, tc.isContextSensitive)
	case SyntaxKindConditionalExpression:
		return tc.isContextSensitive((node /* as ConditionalExpression */).whenTrue) || tc.isContextSensitive((node /* as ConditionalExpression */).whenFalse)
	case SyntaxKindBinaryExpression:
		return ((node /* as BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken || (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindQuestionQuestionToken) && (tc.isContextSensitive((node /* as BinaryExpression */).left) || tc.isContextSensitive((node /* as BinaryExpression */).right))
	case SyntaxKindPropertyAssignment:
		return tc.isContextSensitive((node /* as PropertyAssignment */).initializer)
	case SyntaxKindParenthesizedExpression:
		return tc.isContextSensitive((node /* as ParenthesizedExpression */).expression)
	case SyntaxKindJsxAttributes:
		return some((node /* as JsxAttributes */).properties, tc.isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, tc.isContextSensitive)
	case SyntaxKindJsxAttribute:
		// If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.
		TODO_IDENTIFIER := node /* as JsxAttribute */
		return !!initializer && tc.isContextSensitive(initializer)
		fallthrough
	case SyntaxKindJsxExpression:
		// It is possible to that node.expression is undefined (e.g <div x={} />)
		TODO_IDENTIFIER := node /* as JsxExpression */
		return !!expression && tc.isContextSensitive(expression)
	}

	return false
}

func (tc *TypeChecker) isContextSensitiveFunctionLikeDeclaration(node FunctionLikeDeclaration) bool {
	return hasContextSensitiveParameters(node) || tc.hasContextSensitiveReturnExpression(node)
}

func (tc *TypeChecker) hasContextSensitiveReturnExpression(node FunctionLikeDeclaration) bool {
	if node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body {
		return false
	}
	if node.body.kind != SyntaxKindBlock {
		return tc.isContextSensitive(node.body)
	}
	return !!forEachReturnStatement(node.body /* as Block */, func(statement ReturnStatement) bool {
		return !!statement.expression && tc.isContextSensitive(statement.expression)
	})
}

func (tc *TypeChecker) isContextSensitiveFunctionOrObjectLiteralMethod(func_ Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: func is FunctionExpression | ArrowFunction | MethodDeclaration */ any {
	return (isFunctionExpressionOrArrowFunction(func_) || isObjectLiteralMethod(func_)) && tc.isContextSensitiveFunctionLikeDeclaration(func_)
}

func (tc *TypeChecker) getTypeWithoutSignatures(type_ Type) Type {
	if type_.flags & TypeFlagsObject {
		resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		if resolved.constructSignatures.length || resolved.callSignatures.length {
			result := tc.createObjectType(ObjectFlagsAnonymous, type_.symbol)
			result.members = resolved.members
			result.properties = resolved.properties
			result.callSignatures = emptyArray
			result.constructSignatures = emptyArray
			result.indexInfos = emptyArray
			return result
		}
	} else if type_.flags & TypeFlagsIntersection {
		return tc.getIntersectionType(map_((type_ /* as IntersectionType */).types, tc.getTypeWithoutSignatures))
	}
	return type_
}

// TYPE CHECKING

func (tc *TypeChecker) isTypeIdenticalTo(source Type, target Type) bool {
	return tc.isTypeRelatedTo(source, target, tc.identityRelation)
}

func (tc *TypeChecker) compareTypesIdentical(source Type, target Type) Ternary {
	if tc.isTypeRelatedTo(source, target, tc.identityRelation) {
		return TernaryTrue
	} else {
		return TernaryFalse
	}
}

func (tc *TypeChecker) compareTypesAssignable(source Type, target Type) Ternary {
	if tc.isTypeRelatedTo(source, target, tc.assignableRelation) {
		return TernaryTrue
	} else {
		return TernaryFalse
	}
}

func (tc *TypeChecker) compareTypesSubtypeOf(source Type, target Type) Ternary {
	if tc.isTypeRelatedTo(source, target, tc.subtypeRelation) {
		return TernaryTrue
	} else {
		return TernaryFalse
	}
}

func (tc *TypeChecker) isTypeSubtypeOf(source Type, target Type) bool {
	return tc.isTypeRelatedTo(source, target, tc.subtypeRelation)
}

func (tc *TypeChecker) isTypeStrictSubtypeOf(source Type, target Type) bool {
	return tc.isTypeRelatedTo(source, target, tc.strictSubtypeRelation)
}

func (tc *TypeChecker) isTypeAssignableTo(source Type, target Type) bool {
	return tc.isTypeRelatedTo(source, target, tc.assignableRelation)
}

// An object type S is considered to be derived from an object type T if
// S is a union type and every constituent of S is derived from T,
// T is a union type and S is derived from at least one constituent of T, or
// S is an intersection type and some constituent of S is derived from T, or
// S is a type variable with a base constraint that is derived from T, or
// T is {} and S is an object-like type (ensuring {} is less derived than Object), or
// T is one of the global types Object and Function and S is a subtype of T, or
// T occurs directly or indirectly in an 'extends' clause of S.
// Note that this check ignores type parameters and only considers the
// inheritance hierarchy.
func (tc *TypeChecker) isTypeDerivedFrom(source Type, target Type) bool {
	switch {
	case source.flags & TypeFlagsUnion:
		return every((source /* as UnionType */).types, func(t Type) bool {
			return tc.isTypeDerivedFrom(t, target)
		})
	case target.flags & TypeFlagsUnion:
		return some((target /* as UnionType */).types, func(t Type) bool {
			return tc.isTypeDerivedFrom(source, t)
		})
	case source.flags & TypeFlagsIntersection:
		return some((source /* as IntersectionType */).types, func(t Type) bool {
			return tc.isTypeDerivedFrom(t, target)
		})
	case source.flags & TypeFlagsInstantiableNonPrimitive:
		return tc.isTypeDerivedFrom(tc.getBaseConstraintOfType(source) || tc.unknownType, target)
	case tc.isEmptyAnonymousObjectType(target):
		return !!(source.flags & (TypeFlagsObject | TypeFlagsNonPrimitive))
	case target == tc.globalObjectType:
		return !!(source.flags & (TypeFlagsObject | TypeFlagsNonPrimitive)) && !tc.isEmptyAnonymousObjectType(source)
	case target == tc.globalFunctionType:
		return !!(source.flags & TypeFlagsObject) && tc.isFunctionObjectType(source /* as ObjectType */)
	default:
		return tc.hasBaseType(source, tc.getTargetType(target)) || (tc.isArrayType(target) && !tc.isReadonlyArrayType(target) && tc.isTypeDerivedFrom(source, tc.globalReadonlyArrayType))
	}
}

/**
 * This is *not* a bi-directional relationship.
 * If one needs to check both directions for comparability, use a second call to this function or 'checkTypeComparableTo'.
 *
 * A type S is comparable to a type T if some (but not necessarily all) of the possible values of S are also possible values of T.
 * It is used to check following cases:
 *   - the types of the left and right sides of equality/inequality operators (`===`, `!==`, `==`, `!=`).
 *   - the types of `case` clause expressions and their respective `switch` expressions.
 *   - the type of an expression in a type assertion with the type being asserted.
 */

func (tc *TypeChecker) isTypeComparableTo(source Type, target Type) bool {
	return tc.isTypeRelatedTo(source, target, tc.comparableRelation)
}

func (tc *TypeChecker) areTypesComparable(type1 Type, type2 Type) bool {
	return tc.isTypeComparableTo(type1, type2) || tc.isTypeComparableTo(type2, type1)
}

func (tc *TypeChecker) checkTypeAssignableTo(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputObject /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any) bool {
	return tc.checkTypeRelatedTo(source, target, tc.assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject)
}

/**
 * Like `checkTypeAssignableTo`, but if it would issue an error, instead performs structural comparisons of the types using the given expression node to
 * attempt to issue more specific errors on, for example, specific object literal properties or tuple members.
 */

func (tc *TypeChecker) checkTypeAssignableToAndOptionallyElaborate(source Type, target Type, errorNode Node, expr Expression, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
	return tc.checkTypeRelatedToAndOptionallyElaborate(source, target, tc.assignableRelation, errorNode, expr, headMessage, containingMessageChain /*errorOutputContainer*/, nil)
}

func (tc *TypeChecker) checkTypeRelatedToAndOptionallyElaborate(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, expr Expression, headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	if tc.isTypeRelatedTo(source, target, relation) {
		return true
	}
	if !errorNode || !tc.elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
		return tc.checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)
	}
	return false
}

func (tc *TypeChecker) isOrHasGenericConditional(type_ Type) bool {
	return !!(type_.flags&TypeFlagsConditional || (type_.flags&TypeFlagsIntersection && some((type_ /* as IntersectionType */).types, tc.isOrHasGenericConditional)))
}

func (tc *TypeChecker) elaborateError(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	if !node || tc.isOrHasGenericConditional(target) {
		return false
	}
	if !tc.checkTypeRelatedTo(source, target, relation /*errorNode*/, nil) && tc.elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
		return true
	}
	switch node.kind {
	case SyntaxKindAsExpression:
		if !isConstAssertion(node) {
			break
		}
		fallthrough
	case SyntaxKindJsxExpression,
		SyntaxKindParenthesizedExpression:
		return tc.elaborateError((node /* as AsExpression | ParenthesizedExpression | JsxExpression */).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
	case SyntaxKindBinaryExpression:
		switch (node /* as BinaryExpression */).operatorToken.kind {
		case SyntaxKindEqualsToken,
			SyntaxKindCommaToken:
			return tc.elaborateError((node /* as BinaryExpression */).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)
		}
	case SyntaxKindObjectLiteralExpression:
		return tc.elaborateObjectLiteral(node /* as ObjectLiteralExpression */, source, target, relation, containingMessageChain, errorOutputContainer)
	case SyntaxKindArrayLiteralExpression:
		return tc.elaborateArrayLiteral(node /* as ArrayLiteralExpression */, source, target, relation, containingMessageChain, errorOutputContainer)
	case SyntaxKindJsxAttributes:
		return tc.elaborateJsxComponents(node /* as JsxAttributes */, source, target, relation, containingMessageChain, errorOutputContainer)
	case SyntaxKindArrowFunction:
		return tc.elaborateArrowFunction(node /* as ArrowFunction */, source, target, relation, containingMessageChain, errorOutputContainer)
	}
	return false
}

func (tc *TypeChecker) elaborateDidYouMeanToCallOrConstruct(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	callSignatures := tc.getSignaturesOfType(source, SignatureKindCall)
	constructSignatures := tc.getSignaturesOfType(source, SignatureKindConstruct)
	for _, signatures := range [][]Signature{constructSignatures, callSignatures} {
		if some(signatures, func(s Signature) bool {
			returnType := tc.getReturnTypeOfSignature(s)
			return !(returnType.flags & (TypeFlagsAny | TypeFlagsNever)) && tc.checkTypeRelatedTo(returnType, target, relation /*errorNode*/, nil)
		}) {
			var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
			}
			tc.checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj)
			diagnostic := resultObj.errors[resultObj.errors.length-1]
			addRelatedInfo(diagnostic, createDiagnosticForNode(node, __COND__(signatures == constructSignatures, Diagnostics.Did_you_mean_to_use_new_with_this_expression, Diagnostics.Did_you_mean_to_call_this_expression)))
			return true
		}
	}
	return false
}

func (tc *TypeChecker) elaborateArrowFunction(node ArrowFunction, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	// Don't elaborate blocks
	if isBlock(node.body) {
		return false
	}
	// Or functions with annotated parameter types
	if some(node.parameters, hasType) {
		return false
	}
	sourceSig := tc.getSingleCallSignature(source)
	if !sourceSig {
		return false
	}
	targetSignatures := tc.getSignaturesOfType(target, SignatureKindCall)
	if !length(targetSignatures) {
		return false
	}
	returnExpression := node.body
	sourceReturn := tc.getReturnTypeOfSignature(sourceSig)
	targetReturn := tc.getUnionType(map_(targetSignatures, tc.getReturnTypeOfSignature))
	if !tc.checkTypeRelatedTo(sourceReturn, targetReturn, relation /*errorNode*/, nil) {
		elaborated := returnExpression && tc.elaborateError(returnExpression, sourceReturn, targetReturn, relation /*headMessage*/, nil, containingMessageChain, errorOutputContainer)
		if elaborated {
			return elaborated
		}
		var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
		}
		tc.checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression /*headMessage*/, nil, containingMessageChain, resultObj)
		if resultObj.errors {
			if target.symbol && length(target.symbol.declarations) {
				addRelatedInfo(resultObj.errors[resultObj.errors.length-1], createDiagnosticForNode(target.symbol.declarations[0], Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature))
			}
			if (getFunctionFlags(node)&FunctionFlagsAsync) == 0 && !tc.getTypeOfPropertyOfType(sourceReturn, "then" /* as __String */) && tc.checkTypeRelatedTo(tc.createPromiseType(sourceReturn), targetReturn, relation /*errorNode*/, nil) {
				addRelatedInfo(resultObj.errors[resultObj.errors.length-1], createDiagnosticForNode(node, Diagnostics.Did_you_mean_to_mark_this_function_as_async))
			}
			return true
		}
	}
	return false
}

func (tc *TypeChecker) getBestMatchIndexedAccessTypeOrUndefined(source Type, target Type, nameType Type) Type {
	idx := tc.getIndexedAccessTypeOrUndefined(target, nameType)
	if idx {
		return idx
	}
	if target.flags & TypeFlagsUnion {
		best := tc.getBestMatchingType(source, target /* as UnionType */)
		if best {
			return tc.getIndexedAccessTypeOrUndefined(best, nameType)
		}
	}
}

func (tc *TypeChecker) checkExpressionForMutableLocationWithContextualType(next Expression, sourcePropType Type) Type {
	tc.pushContextualType(next, sourcePropType /*isCache*/, false)
	result := tc.checkExpressionForMutableLocation(next, CheckModeContextual)
	tc.popContextualType()
	return result
}

/**
 * For every element returned from the iterator, checks that element to issue an error on a property of that element's type
 * If that element would issue an error, we first attempt to dive into that element's inner expression and issue a more specific error by recuring into `elaborateError`
 * Otherwise, we issue an error on _every_ element which fail the assignability check
 */

func (tc *TypeChecker) elaborateElementwise(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	// Assignability failure - check each prop individually, and if that fails, fall back on the bad error span
	reportedError := false
	for _, value := range iterator {
		TODO_IDENTIFIER := value
		targetPropType := tc.getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType)
		if !targetPropType || targetPropType.flags&TypeFlagsIndexedAccess {
			continue
			// Don't elaborate on indexes on generic variables
		}
		// Don't elaborate on indexes on generic variables
		sourcePropType := tc.getIndexedAccessTypeOrUndefined(source, nameType)
		if !sourcePropType {
			continue
		}
		propName := tc.getPropertyNameFromIndex(nameType /*accessNode*/, nil)
		if !tc.checkTypeRelatedTo(sourcePropType, targetPropType, relation /*errorNode*/, nil) {
			elaborated := next && tc.elaborateError(next, sourcePropType, targetPropType, relation /*headMessage*/, nil, containingMessageChain, errorOutputContainer)
			reportedError = true
			if !elaborated {
				// Issue error on the prop itself, since the prop couldn't elaborate the error
				var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
				}
				// Use the expression type, if available
				var specificSource Type
				if next {
					specificSource = tc.checkExpressionForMutableLocationWithContextualType(next, sourcePropType)
				} else {
					specificSource = sourcePropType
				}
				if tc.exactOptionalPropertyTypes && tc.isExactOptionalPropertyMismatch(specificSource, targetPropType) {
					diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, tc.typeToString(specificSource), tc.typeToString(targetPropType))
					tc.diagnostics.add(diag)
					resultObj.errors = []DiagnosticWithLocation{diag}
				} else {
					targetIsOptional := !!(propName && (tc.getPropertyOfType(target, propName) || tc.unknownSymbol).flags&SymbolFlagsOptional)
					sourceIsOptional := !!(propName && (tc.getPropertyOfType(source, propName) || tc.unknownSymbol).flags&SymbolFlagsOptional)
					targetPropType = tc.removeMissingType(targetPropType, targetIsOptional)
					sourcePropType = tc.removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
					result := tc.checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
					if result && specificSource != sourcePropType {
						// If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
						tc.checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
					}
				}
				if resultObj.errors {
					reportedDiag := resultObj.errors[resultObj.errors.length-1]
					var propertyName *__String
					if isTypeUsableAsPropertyName(nameType) {
						propertyName = getPropertyNameFromType(nameType)
					} else {
						propertyName = nil
					}
					var targetProp Symbol
					if propertyName != nil {
						targetProp = tc.getPropertyOfType(target, propertyName)
					} else {
						targetProp = nil
					}

					issuedElaboration := false
					if !targetProp {
						indexInfo := tc.getApplicableIndexInfo(target, nameType)
						if indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib {
							issuedElaboration = true
							addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature))
						}
					}

					if !issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations)) {
						var targetNode Declaration
						if targetProp && length(targetProp.declarations) {
							targetNode = targetProp.declarations[0]
						} else {
							targetNode = target.symbol.declarations[0]
						}
						if !getSourceFileOfNode(targetNode).hasNoDefaultLib {
							addRelatedInfo(reportedDiag, createDiagnosticForNode(targetNode, Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1, __COND__(propertyName && !(nameType.flags&TypeFlagsUniqueESSymbol), unescapeLeadingUnderscores(propertyName), tc.typeToString(nameType)), tc.typeToString(target)))
						}
					}
				}
			}
		}
	}
	return reportedError
}

/**
 * Assumes `target` type is assignable to the `Iterable` type, if `Iterable` is defined,
 * or that it's an array or tuple-like type, if `Iterable` is not defined.
 */

func (tc *TypeChecker) elaborateIterableOrArrayLikeTargetElementwise(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	tupleOrArrayLikeTargetParts := tc.filterType(target, tc.isArrayOrTupleLikeType)
	nonTupleOrArrayLikeTargetParts := tc.filterType(target, func(t Type) bool {
		return !tc.isArrayOrTupleLikeType(t)
	})
	// If `nonTupleOrArrayLikeTargetParts` is not `never`, then that should mean `Iterable` is defined.
	var iterationType Type
	if nonTupleOrArrayLikeTargetParts != tc.neverType {
		iterationType = tc.getIterationTypeOfIterable(IterationUseForOf, IterationTypeKindYield, nonTupleOrArrayLikeTargetParts /*errorNode*/, nil)
	} else {
		iterationType = nil
	}

	reportedError := false
	for status := iterator.next(); !status.done; status = iterator.next() {
		TODO_IDENTIFIER := status.value
		targetPropType := iterationType
		var targetIndexedPropType Type
		if tupleOrArrayLikeTargetParts != tc.neverType {
			targetIndexedPropType = tc.getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType)
		} else {
			targetIndexedPropType = nil
		}
		if targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlagsIndexedAccess) {
			if iterationType {
				targetPropType = tc.getUnionType([]Type{iterationType, targetIndexedPropType})
			} else {
				targetPropType = targetIndexedPropType
			}
		}
		if !targetPropType {
			continue
		}
		sourcePropType := tc.getIndexedAccessTypeOrUndefined(source, nameType)
		if !sourcePropType {
			continue
		}
		propName := tc.getPropertyNameFromIndex(nameType /*accessNode*/, nil)
		if !tc.checkTypeRelatedTo(sourcePropType, targetPropType, relation /*errorNode*/, nil) {
			elaborated := next && tc.elaborateError(next, sourcePropType, targetPropType, relation /*headMessage*/, nil, containingMessageChain, errorOutputContainer)
			reportedError = true
			if !elaborated {
				// Issue error on the prop itself, since the prop couldn't elaborate the error
				var resultObj /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; } */ any = errorOutputContainer || map[any]any{ /* TODO(TS-TO-GO): was object literal */
				}
				// Use the expression type, if available
				var specificSource Type
				if next {
					specificSource = tc.checkExpressionForMutableLocationWithContextualType(next, sourcePropType)
				} else {
					specificSource = sourcePropType
				}
				if tc.exactOptionalPropertyTypes && tc.isExactOptionalPropertyMismatch(specificSource, targetPropType) {
					diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, tc.typeToString(specificSource), tc.typeToString(targetPropType))
					tc.diagnostics.add(diag)
					resultObj.errors = []DiagnosticWithLocation{diag}
				} else {
					targetIsOptional := !!(propName && (tc.getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || tc.unknownSymbol).flags&SymbolFlagsOptional)
					sourceIsOptional := !!(propName && (tc.getPropertyOfType(source, propName) || tc.unknownSymbol).flags&SymbolFlagsOptional)
					targetPropType = tc.removeMissingType(targetPropType, targetIsOptional)
					sourcePropType = tc.removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
					result := tc.checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
					if result && specificSource != sourcePropType {
						// If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType
						tc.checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
					}
				}
			}
		}
	}
	return reportedError
}

func (tc *TypeChecker) generateJsxAttributes(node JsxAttributes) ElaborationIterator {
	if !length(node.properties) {
		return
	}
	for _, prop := range node.properties {
		if isJsxSpreadAttribute(prop) || tc.isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name)) {
			continue
		}
		yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"errorNode":       prop.name,
			"innerExpression": prop.initializer,
			"nameType":        tc.getStringLiteralType(getTextOfJsxAttributeName(prop.name)),
		})
	}
}

func (tc *TypeChecker) generateJsxChildren(node JsxElement, getInvalidTextDiagnostic func() DiagnosticMessage) ElaborationIterator {
	if !length(node.children) {
		return
	}
	memberOffset := 0
	for i := 0; i < node.children.length; i++ {
		child := node.children[i]
		nameType := tc.getNumberLiteralType(i - memberOffset)
		elem := tc.getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic)
		if elem {
			yield(elem)
		} else {
			memberOffset++
		}
	}
}

func (tc *TypeChecker) getElaborationElementForJsxChild(child JsxChild, nameType LiteralType, getInvalidTextDiagnostic func() DiagnosticMessage) * /* TODO(TS-TO-GO) inferred type { errorNode: JsxExpression; innerExpression: Expression | undefined; nameType: LiteralType; errorMessage?: undefined; } | { errorNode: JsxText; innerExpression: undefined; nameType: LiteralType; errorMessage: DiagnosticMessage; } | { errorNode: JsxElement | JsxSelfClosingElement | JsxFragment; innerExpression: JsxElement | JsxSelfClosingElement | JsxFragment; nameType: LiteralType; errorMessage?: undefined; } */ any {
	switch child.kind {
	case SyntaxKindJsxExpression:
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"errorNode":       child,
			"innerExpression": child.expression,
			"nameType":        nameType,
		}
	case SyntaxKindJsxText:
		if child.containsOnlyTriviaWhiteSpaces {
			break
			// Whitespace only jsx text isn't real jsx text
		}
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"errorNode":       child,
			"innerExpression": nil,
			"nameType":        nameType,
			"errorMessage":    getInvalidTextDiagnostic(),
		}
	case SyntaxKindJsxElement,
		SyntaxKindJsxSelfClosingElement,
		SyntaxKindJsxFragment:
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"errorNode":       child,
			"innerExpression": child,
			"nameType":        nameType,
		}
	default:
		return Debug.assertNever(child, "Found invalid jsx child")
	}
}

func (tc *TypeChecker) elaborateJsxComponents(node JsxAttributes, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	result := tc.elaborateElementwise(tc.generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer)
	var invalidTextDiagnostic *DiagnosticMessage
	if isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent) {
		containingElement := node.parent.parent
		childPropName := tc.getJsxElementChildrenPropertyName(tc.getJsxNamespaceAt(node))
		var childrenPropName string
		if childPropName == nil {
			childrenPropName = "children"
		} else {
			childrenPropName = unescapeLeadingUnderscores(childPropName)
		}
		childrenNameType := tc.getStringLiteralType(childrenPropName)
		childrenTargetType := tc.getIndexedAccessType(target, childrenNameType)
		validChildren := getSemanticJsxChildren(containingElement.children)
		if !length(validChildren) {
			return result
		}
		moreThanOneRealChildren := length(validChildren) > 1
		var arrayLikeTargetParts Type
		var nonArrayLikeTargetParts Type
		iterableType := tc.getGlobalIterableType(false)
		if iterableType != tc.emptyGenericType {
			anyIterable := tc.createIterableType(tc.anyType)
			arrayLikeTargetParts = tc.filterType(childrenTargetType, func(t Type) bool {
				return tc.isTypeAssignableTo(t, anyIterable)
			})
			nonArrayLikeTargetParts = tc.filterType(childrenTargetType, func(t Type) bool {
				return !tc.isTypeAssignableTo(t, anyIterable)
			})
		} else {
			arrayLikeTargetParts = tc.filterType(childrenTargetType, tc.isArrayOrTupleLikeType)
			nonArrayLikeTargetParts = tc.filterType(childrenTargetType, func(t Type) bool {
				return !tc.isArrayOrTupleLikeType(t)
			})
		}
		if moreThanOneRealChildren {
			if arrayLikeTargetParts != tc.neverType {
				realSource := tc.createTupleType(tc.checkJsxChildren(containingElement, CheckModeNormal))
				children := tc.generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic)
				result = tc.elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result
			} else if !tc.isTypeRelatedTo(tc.getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
				// arity mismatch
				result = true
				diag := tc.error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, tc.typeToString(childrenTargetType))
				if errorOutputContainer && errorOutputContainer.skipLogging {
					(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
				}
			}
		} else {
			if nonArrayLikeTargetParts != tc.neverType {
				child := validChildren[0]
				elem := tc.getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic)
				if elem {
					result = tc.elaborateElementwise((func /* generator */ () /* TODO(TS-TO-GO) inferred type Generator<{ errorNode: JsxExpression; innerExpression: Expression | undefined; nameType: LiteralType; errorMessage?: undefined; } | { errorNode: JsxText; innerExpression: undefined; nameType: LiteralType; errorMessage: DiagnosticMessage; } | { errorNode: JsxElement | JsxSelfClosingElement | JsxFragment; innerExpression: JsxElement | JsxSelfClosingElement | JsxFragment; nameType: LiteralType; errorMessage?: undefined; }, void, undefined> */ any {
						yield(elem)
					})(), source, target, relation, containingMessageChain, errorOutputContainer) || result
				}
			} else if !tc.isTypeRelatedTo(tc.getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
				// arity mismatch
				result = true
				diag := tc.error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, tc.typeToString(childrenTargetType))
				if errorOutputContainer && errorOutputContainer.skipLogging {
					(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
				}
			}
		}
	}
	return result

	getInvalidTextualChildDiagnostic := func() DiagnosticMessage {
		if !invalidTextDiagnostic {
			tagNameText := getTextOfNode(node.parent.tagName)
			childPropName := tc.getJsxElementChildrenPropertyName(tc.getJsxNamespaceAt(node))
			var childrenPropName string
			if childPropName == nil {
				childrenPropName = "children"
			} else {
				childrenPropName = unescapeLeadingUnderscores(childPropName)
			}
			childrenTargetType := tc.getIndexedAccessType(target, tc.getStringLiteralType(childrenPropName))
			diagnostic := Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2
			invalidTextDiagnostic = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				/* TODO(TS-TO-GO) Node SpreadAssignment: ...diagnostic */
				"key":     "!!ALREADY FORMATTED!!",
				"message": formatMessage(diagnostic, tagNameText, childrenPropName, tc.typeToString(childrenTargetType)),
			}
		}
		return invalidTextDiagnostic
	}

}

func (tc *TypeChecker) generateLimitedTupleElements(node ArrayLiteralExpression, target Type) ElaborationIterator {
	len := length(node.elements)
	if !len {
		return
	}
	for i := 0; i < len; i++ {
		// Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature
		if tc.isTupleLikeType(target) && !tc.getPropertyOfType(target, (""+i) /* as __String */) {
			continue
		}
		elem := node.elements[i]
		if isOmittedExpression(elem) {
			continue
		}
		nameType := tc.getNumberLiteralType(i)
		checkNode := tc.getEffectiveCheckNode(elem)
		yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"errorNode":       checkNode,
			"innerExpression": checkNode,
			"nameType":        nameType,
		})
	}
}

func (tc *TypeChecker) elaborateArrayLiteral(node ArrayLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
		return false
	}
	if tc.isTupleLikeType(source) {
		return tc.elaborateElementwise(tc.generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer)
	}
	// recreate a tuple from the elements, if possible
	// Since we're re-doing the expression type, we need to reapply the contextual type
	tc.pushContextualType(node, target /*isCache*/, false)
	tupleizedType := tc.checkArrayLiteral(node, CheckModeContextual /*forceTuple*/, true)
	tc.popContextualType()
	if tc.isTupleLikeType(tupleizedType) {
		return tc.elaborateElementwise(tc.generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer)
	}
	return false
}

func (tc *TypeChecker) generateObjectLiteralElements(node ObjectLiteralExpression) ElaborationIterator {
	if !length(node.properties) {
		return
	}
	for _, prop := range node.properties {
		if isSpreadAssignment(prop) {
			continue
		}
		type_ := tc.getLiteralTypeFromProperty(tc.getSymbolOfDeclaration(prop), TypeFlagsStringOrNumberLiteralOrUnique)
		if !type_ || (type_.flags & TypeFlagsNever) {
			continue
		}
		switch prop.kind {
		case SyntaxKindSetAccessor,
			SyntaxKindGetAccessor,
			SyntaxKindMethodDeclaration,
			SyntaxKindShorthandPropertyAssignment:
			yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorNode":       prop.name,
				"innerExpression": nil,
				"nameType":        type_,
			})
		case SyntaxKindPropertyAssignment:
			yield(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errorNode":       prop.name,
				"innerExpression": prop.initializer,
				"nameType":        type_,
				"errorMessage":    __COND__(isComputedNonLiteralName(prop.name), Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1, nil),
			})
		default:
			Debug.assertNever(prop)
		}
	}
}

func (tc *TypeChecker) elaborateObjectLiteral(node ObjectLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
		return false
	}
	return tc.elaborateElementwise(tc.generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer)
}

/**
 * This is *not* a bi-directional relationship.
 * If one needs to check both directions for comparability, use a second call to this function or 'isTypeComparableTo'.
 */

func (tc *TypeChecker) checkTypeComparableTo(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
	return tc.checkTypeRelatedTo(source, target, tc.comparableRelation, errorNode, headMessage, containingMessageChain)
}

func (tc *TypeChecker) isSignatureAssignableTo(source Signature, target Signature, ignoreReturnTypes bool) bool {
	return tc.compareSignaturesRelated(source, target, __COND__(ignoreReturnTypes, SignatureCheckModeIgnoreReturnTypes, SignatureCheckModeNone) /*reportErrors*/, false /*errorReporter*/, nil /*incompatibleErrorReporter*/, nil, tc.compareTypesAssignable /*reportUnreliableMarkers*/, nil) != TernaryFalse
}

/**
 * Returns true if `s` is `(...args: A) => R` where `A` is `any`, `any[]`, `never`, or `never[]`, and `R` is `any` or `unknown`.
 */

func (tc *TypeChecker) isTopSignature(s Signature) bool {
	if !s.typeParameters && (!s.thisParameter || tc.isTypeAny(tc.getTypeOfParameter(s.thisParameter))) && s.parameters.length == 1 && signatureHasRestParameter(s) {
		paramType := tc.getTypeOfParameter(s.parameters[0])
		var restType Type
		if tc.isArrayType(paramType) {
			restType = tc.getTypeArguments(paramType)[0]
		} else {
			restType = paramType
		}
		return !!(restType.flags&(TypeFlagsAny|TypeFlagsNever) && tc.getReturnTypeOfSignature(s).flags&TypeFlagsAnyOrUnknown)
	}
	return false
}

/**
 * See signatureRelatedTo, compareSignaturesIdentical
 */

func (tc *TypeChecker) compareSignaturesRelated(source Signature, target Signature, checkMode SignatureCheckMode, reportErrors bool, errorReporter *ErrorReporter, incompatibleErrorReporter *func(source Type, target Type), compareTypes TypeComparer, reportUnreliableMarkers *TypeMapper) Ternary {
	// TODO (drosen): De-duplicate code between related functions.
	if source == target {
		return TernaryTrue
	}

	if !(checkMode&SignatureCheckModeStrictTopSignature && tc.isTopSignature(source)) && tc.isTopSignature(target) {
		return TernaryTrue
	}
	if checkMode&SignatureCheckModeStrictTopSignature && tc.isTopSignature(source) && !tc.isTopSignature(target) {
		return TernaryFalse
	}

	targetCount := tc.getParameterCount(target)
	sourceHasMoreParameters := !tc.hasEffectiveRestParameter(target) && (__COND__(checkMode&SignatureCheckModeStrictArity, tc.hasEffectiveRestParameter(source) || tc.getParameterCount(source) > targetCount, tc.getMinArgumentCount(source) > targetCount))
	if sourceHasMoreParameters {
		if reportErrors && !(checkMode & SignatureCheckModeStrictArity) {
			// the second condition should be redundant, because there is no error reporting when comparing signatures by strict arity
			// since it is only done for subtype reduction
			errorReporter(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, tc.getMinArgumentCount(source), targetCount)
		}
		return TernaryFalse
	}

	if source.typeParameters && source.typeParameters != target.typeParameters {
		target = tc.getCanonicalSignature(target)
		source = tc.instantiateSignatureInContextOf(source, target /*inferenceContext*/, nil, compareTypes)
	}

	sourceCount := tc.getParameterCount(source)
	sourceRestType := tc.getNonArrayRestType(source)
	targetRestType := tc.getNonArrayRestType(target)
	if sourceRestType || targetRestType {
		tc.instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers)
	}

	var kind /* TODO(TS-TO-GO) inferred type SyntaxKind.Unknown | SyntaxKind.MethodSignature | SyntaxKind.MethodDeclaration | SyntaxKind.Constructor | SyntaxKind.GetAccessor | SyntaxKind.SetAccessor | SyntaxKind.CallSignature | SyntaxKind.ConstructSignature | SyntaxKind.IndexSignature | SyntaxKind.FunctionType | SyntaxKind.ConstructorType | SyntaxKind.FunctionExpression | SyntaxKind.ArrowFunction | SyntaxKind.FunctionDeclaration | SyntaxKind.JSDocFunctionType | SyntaxKind.JSDocSignature */ any
	if target.declaration {
		kind = target.declaration.kind
	} else {
		kind = SyntaxKindUnknown
	}
	strictVariance := !(checkMode & SignatureCheckModeCallback) && tc.strictFunctionTypes && kind != SyntaxKindMethodDeclaration && kind != SyntaxKindMethodSignature && kind != SyntaxKindConstructor
	result := TernaryTrue

	sourceThisType := tc.getThisTypeOfSignature(source)
	if sourceThisType && sourceThisType != tc.voidType {
		targetThisType := tc.getThisTypeOfSignature(target)
		if targetThisType {
			// void sources are assignable to anything.
			related := !strictVariance && compareTypes(sourceThisType, targetThisType /*reportErrors*/, false) || compareTypes(targetThisType, sourceThisType, reportErrors)
			if !related {
				if reportErrors {
					errorReporter(Diagnostics.The_this_types_of_each_signature_are_incompatible)
				}
				return TernaryFalse
			}
			result &= related
		}
	}

	var paramCount number
	if sourceRestType || targetRestType {
		paramCount = Math.min(sourceCount, targetCount)
	} else {
		paramCount = Math.max(sourceCount, targetCount)
	}
	var restIndex number
	if sourceRestType || targetRestType {
		restIndex = paramCount - 1
	} else {
		restIndex = -1
	}

	for i := 0; i < paramCount; i++ {
		var sourceType Type
		if i == restIndex {
			sourceType = tc.getRestOrAnyTypeAtPosition(source, i)
		} else {
			sourceType = tc.tryGetTypeAtPosition(source, i)
		}
		var targetType Type
		if i == restIndex {
			targetType = tc.getRestOrAnyTypeAtPosition(target, i)
		} else {
			targetType = tc.tryGetTypeAtPosition(target, i)
		}
		if sourceType && targetType && (sourceType != targetType || checkMode&SignatureCheckModeStrictArity) {
			// In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter
			// how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,
			// they naturally relate only contra-variantly). However, if the source and target parameters both have
			// function types with a single call signature, we know we are relating two callback parameters. In
			// that case it is sufficient to only relate the parameters of the signatures co-variantly because,
			// similar to return values, callback parameters are output positions. This means that a Promise<T>,
			// where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)
			// with respect to T.
			var sourceSig *Signature
			if checkMode&SignatureCheckModeCallback || tc.isInstantiatedGenericParameter(source, i) {
				sourceSig = nil
			} else {
				sourceSig = tc.getSingleCallSignature(tc.getNonNullableType(sourceType))
			}
			var targetSig *Signature
			if checkMode&SignatureCheckModeCallback || tc.isInstantiatedGenericParameter(target, i) {
				targetSig = nil
			} else {
				targetSig = tc.getSingleCallSignature(tc.getNonNullableType(targetType))
			}
			callbacks := sourceSig && targetSig && !tc.getTypePredicateOfSignature(sourceSig) && !tc.getTypePredicateOfSignature(targetSig) && tc.getTypeFacts(sourceType, TypeFactsIsUndefinedOrNull) == tc.getTypeFacts(targetType, TypeFactsIsUndefinedOrNull)
			var related Ternary
			if callbacks {
				related = tc.compareSignaturesRelated(targetSig, sourceSig, (checkMode&SignatureCheckModeStrictArity)|(__COND__(strictVariance, SignatureCheckModeStrictCallback, SignatureCheckModeBivariantCallback)), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers)
			} else {
				related = !(checkMode&SignatureCheckModeCallback) && !strictVariance && compareTypes(sourceType, targetType /*reportErrors*/, false) || compareTypes(targetType, sourceType, reportErrors)
			}
			// With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void
			if related && checkMode&SignatureCheckModeStrictArity && i >= tc.getMinArgumentCount(source) && i < tc.getMinArgumentCount(target) && compareTypes(sourceType, targetType /*reportErrors*/, false) {
				related = TernaryFalse
			}
			if !related {
				if reportErrors {
					errorReporter(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(tc.getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(tc.getParameterNameAtPosition(target, i)))
				}
				return TernaryFalse
			}
			result &= related
		}
	}

	if !(checkMode & SignatureCheckModeIgnoreReturnTypes) {
		// If a signature resolution is already in-flight, skip issuing a circularity error
		// here and just use the `any` type directly
		var targetReturnType Type
		switch {
		case tc.isResolvingReturnTypeOfSignature(target):
			targetReturnType = tc.anyType
		case target.declaration && tc.isJSConstructor(target.declaration):
			targetReturnType = tc.getDeclaredTypeOfClassOrInterface(tc.getMergedSymbol(target.declaration.symbol))
		default:
			targetReturnType = tc.getReturnTypeOfSignature(target)
		}
		if targetReturnType == tc.voidType || targetReturnType == tc.anyType {
			return result
		}
		var sourceReturnType Type
		switch {
		case tc.isResolvingReturnTypeOfSignature(source):
			sourceReturnType = tc.anyType
		case source.declaration && tc.isJSConstructor(source.declaration):
			sourceReturnType = tc.getDeclaredTypeOfClassOrInterface(tc.getMergedSymbol(source.declaration.symbol))
		default:
			sourceReturnType = tc.getReturnTypeOfSignature(source)
		}

		// The following block preserves behavior forbidding boolean returning functions from being assignable to type guard returning functions
		targetTypePredicate := tc.getTypePredicateOfSignature(target)
		if targetTypePredicate {
			sourceTypePredicate := tc.getTypePredicateOfSignature(source)
			if sourceTypePredicate {
				result &= tc.compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes)
			} else if isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate) {
				if reportErrors {
					errorReporter(Diagnostics.Signature_0_must_be_a_type_predicate, tc.signatureToString(source))
				}
				return TernaryFalse
			}
		} else {
			// When relating callback signatures, we still need to relate return types bi-variantly as otherwise
			// the containing type wouldn't be co-variant. For example, interface Foo<T> { add(cb: () => T): void }
			// wouldn't be co-variant for T without this rule.
			result &= checkMode&SignatureCheckModeBivariantCallback && compareTypes(targetReturnType, sourceReturnType /*reportErrors*/, false) || compareTypes(sourceReturnType, targetReturnType, reportErrors)
			if !result && reportErrors && incompatibleErrorReporter {
				incompatibleErrorReporter(sourceReturnType, targetReturnType)
			}
		}
	}

	return result
}

func (tc *TypeChecker) compareTypePredicateRelatedTo(source TypePredicate, target TypePredicate, reportErrors bool, errorReporter *ErrorReporter, compareTypes func(s Type, t Type, reportErrors bool) Ternary) Ternary {
	if source.kind != target.kind {
		if reportErrors {
			errorReporter(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard)
			errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, tc.typePredicateToString(source), tc.typePredicateToString(target))
		}
		return TernaryFalse
	}

	if source.kind == TypePredicateKindIdentifier || source.kind == TypePredicateKindAssertsIdentifier {
		if source.parameterIndex != (target /* as IdentifierTypePredicate */).parameterIndex {
			if reportErrors {
				errorReporter(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target /* as IdentifierTypePredicate */).parameterName)
				errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, tc.typePredicateToString(source), tc.typePredicateToString(target))
			}
			return TernaryFalse
		}
	}

	var related Ternary
	switch {
	case source.type_ == target.type_:
		related = TernaryTrue
	case source.type_ && target.type_:
		related = compareTypes(source.type_, target.type_, reportErrors)
	default:
		related = TernaryFalse
	}
	if related == TernaryFalse && reportErrors {
		errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, tc.typePredicateToString(source), tc.typePredicateToString(target))
	}
	return related
}

func (tc *TypeChecker) isImplementationCompatibleWithOverload(implementation Signature, overload Signature) bool {
	erasedSource := tc.getErasedSignature(implementation)
	erasedTarget := tc.getErasedSignature(overload)

	// First see if the return types are compatible in either direction.
	sourceReturnType := tc.getReturnTypeOfSignature(erasedSource)
	targetReturnType := tc.getReturnTypeOfSignature(erasedTarget)
	if targetReturnType == tc.voidType || tc.isTypeRelatedTo(targetReturnType, sourceReturnType, tc.assignableRelation) || tc.isTypeRelatedTo(sourceReturnType, targetReturnType, tc.assignableRelation) {
		return tc.isSignatureAssignableTo(erasedSource, erasedTarget /*ignoreReturnTypes*/, true)
	}

	return false
}

func (tc *TypeChecker) isEmptyResolvedType(t ResolvedType) bool {
	return t != tc.anyFunctionType && t.properties.length == 0 && t.callSignatures.length == 0 && t.constructSignatures.length == 0 && t.indexInfos.length == 0
}

func (tc *TypeChecker) isEmptyObjectType(type_ Type) bool {
	switch {
	case type_.flags & TypeFlagsObject:
		return !tc.isGenericMappedType(type_) && tc.isEmptyResolvedType(tc.resolveStructuredTypeMembers(type_ /* as ObjectType */))
	case type_.flags & TypeFlagsNonPrimitive:
		return true
	case type_.flags & TypeFlagsUnion:
		return some((type_ /* as UnionType */).types, tc.isEmptyObjectType)
	case type_.flags & TypeFlagsIntersection:
		return every((type_ /* as UnionType */).types, tc.isEmptyObjectType)
	default:
		return false
	}
}

func (tc *TypeChecker) isEmptyAnonymousObjectType(type_ Type) bool {
	return !!(getObjectFlags(type_)&ObjectFlagsAnonymous && ((type_ /* as ResolvedType */).members && tc.isEmptyResolvedType(type_ /* as ResolvedType */) || type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && tc.getMembersOfSymbol(type_.symbol).size == 0))
}

func (tc *TypeChecker) isUnknownLikeUnionType(type_ Type) bool {
	if tc.strictNullChecks && type_.flags&TypeFlagsUnion {
		if !((type_ /* as UnionType */).objectFlags & ObjectFlagsIsUnknownLikeUnionComputed) {
			types := (type_ /* as UnionType */).types
			(type_ /* as UnionType */).objectFlags |= ObjectFlagsIsUnknownLikeUnionComputed | (__COND__(types.length >= 3 && types[0].flags&TypeFlagsUndefined && types[1].flags&TypeFlagsNull && some(types, tc.isEmptyAnonymousObjectType), ObjectFlagsIsUnknownLikeUnion, 0))
		}
		return !!((type_ /* as UnionType */).objectFlags & ObjectFlagsIsUnknownLikeUnion)
	}
	return false
}

func (tc *TypeChecker) containsUndefinedType(type_ Type) bool {
	return !!((__COND__(type_.flags&TypeFlagsUnion, (type_ /* as UnionType */).types[0], type_)).flags & TypeFlagsUndefined)
}

func (tc *TypeChecker) containsNonMissingUndefinedType(type_ Type) bool {
	var candidate Type
	if type_.flags & TypeFlagsUnion {
		candidate = (type_ /* as UnionType */).types[0]
	} else {
		candidate = type_
	}
	return !!(candidate.flags & TypeFlagsUndefined) && candidate != tc.missingType
}

func (tc *TypeChecker) isStringIndexSignatureOnlyType(type_ Type) bool {
	return type_.flags&TypeFlagsObject && !tc.isGenericMappedType(type_) && tc.getPropertiesOfType(type_).length == 0 && tc.getIndexInfosOfType(type_).length == 1 && !!tc.getIndexInfoOfType(type_, tc.stringType) || type_.flags&TypeFlagsUnionOrIntersection && every((type_ /* as UnionOrIntersectionType */).types, tc.isStringIndexSignatureOnlyType) || false
}

func (tc *TypeChecker) isEnumTypeRelatedTo(source Symbol, target Symbol, errorReporter ErrorReporter) bool {
	var sourceSymbol Symbol
	if source.flags & SymbolFlagsEnumMember {
		sourceSymbol = tc.getParentOfSymbol(source)
	} else {
		sourceSymbol = source
	}
	var targetSymbol Symbol
	if target.flags & SymbolFlagsEnumMember {
		targetSymbol = tc.getParentOfSymbol(target)
	} else {
		targetSymbol = target
	}
	if sourceSymbol == targetSymbol {
		return true
	}
	if sourceSymbol.escapedName != targetSymbol.escapedName || !(sourceSymbol.flags & SymbolFlagsRegularEnum) || !(targetSymbol.flags & SymbolFlagsRegularEnum) {
		return false
	}
	id := getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol)
	entry := tc.enumRelation.get(id)
	if entry != nil && !(entry&RelationComparisonResultFailed && errorReporter) {
		return !!(entry & RelationComparisonResultSucceeded)
	}
	targetEnumType := tc.getTypeOfSymbol(targetSymbol)
	for _, sourceProperty := range tc.getPropertiesOfType(tc.getTypeOfSymbol(sourceSymbol)) {
		if sourceProperty.flags & SymbolFlagsEnumMember {
			targetProperty := tc.getPropertyOfType(targetEnumType, sourceProperty.escapedName)
			if !targetProperty || !(targetProperty.flags & SymbolFlagsEnumMember) {
				if errorReporter {
					errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(sourceProperty), tc.typeToString(tc.getDeclaredTypeOfSymbol(targetSymbol) /*enclosingDeclaration*/, nil, TypeFormatFlagsUseFullyQualifiedType))
				}
				tc.enumRelation.set(id, RelationComparisonResultFailed)
				return false
			}
			sourceValue := tc.getEnumMemberValue(getDeclarationOfKind(sourceProperty, SyntaxKindEnumMember)).value
			targetValue := tc.getEnumMemberValue(getDeclarationOfKind(targetProperty, SyntaxKindEnumMember)).value
			if sourceValue != targetValue {
				sourceIsString := /* TODO(TS-TO-GO) Node TypeOfExpression: typeof sourceValue */ TODO == "string"
				targetIsString := /* TODO(TS-TO-GO) Node TypeOfExpression: typeof targetValue */ TODO == "string"

				// If we have 2 enums with *known* values that differ, they are incompatible.
				if sourceValue != nil && targetValue != nil {
					if errorReporter {
						var escapedSource /* TODO(TS-TO-GO) inferred type string | number */ any
						if sourceIsString {
							escapedSource = __TEMPLATE__("\"", escapeString(sourceValue), "\"")
						} else {
							escapedSource = sourceValue
						}
						var escapedTarget /* TODO(TS-TO-GO) inferred type string | number */ any
						if targetIsString {
							escapedTarget = __TEMPLATE__("\"", escapeString(targetValue), "\"")
						} else {
							escapedTarget = targetValue
						}
						errorReporter(Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource)
					}
					tc.enumRelation.set(id, RelationComparisonResultFailed)
					return false
				}

				// At this point we know that at least one of the values is 'undefined'.
				// This may mean that we have an opaque member from an ambient enum declaration,
				// or that we were not able to calculate it (which is basically an error).
				//
				// Either way, we can assume that it's numeric.
				// If the other is a string, we have a mismatch in types.
				if sourceIsString || targetIsString {
					if errorReporter {
						knownStringValue := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: sourceValue ?? targetValue */ TODO
						Debug.assert( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof knownStringValue */ TODO == "string")
						escapedValue := __TEMPLATE__("\"", escapeString(knownStringValue), "\"")
						errorReporter(Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value, symbolName(targetSymbol), symbolName(targetProperty), escapedValue)
					}
					tc.enumRelation.set(id, RelationComparisonResultFailed)
					return false
				}
			}
		}
	}
	tc.enumRelation.set(id, RelationComparisonResultSucceeded)
	return true
}

func (tc *TypeChecker) isSimpleTypeRelatedTo(source Type, target Type, relation Map[string, RelationComparisonResult], errorReporter ErrorReporter) bool {
	s := source.flags
	t := target.flags
	if t&TypeFlagsAny || s&TypeFlagsNever || source == tc.wildcardType {
		return true
	}
	if t&TypeFlagsUnknown && !(relation == tc.strictSubtypeRelation && s&TypeFlagsAny) {
		return true
	}
	if t & TypeFlagsNever {
		return false
	}
	if s&TypeFlagsStringLike && t&TypeFlagsString {
		return true
	}
	if s&TypeFlagsStringLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsStringLiteral && !(t & TypeFlagsEnumLiteral) && (source /* as StringLiteralType */).value == (target /* as StringLiteralType */).value {
		return true
	}
	if s&TypeFlagsNumberLike && t&TypeFlagsNumber {
		return true
	}
	if s&TypeFlagsNumberLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsNumberLiteral && !(t & TypeFlagsEnumLiteral) && (source /* as NumberLiteralType */).value == (target /* as NumberLiteralType */).value {
		return true
	}
	if s&TypeFlagsBigIntLike && t&TypeFlagsBigInt {
		return true
	}
	if s&TypeFlagsBooleanLike && t&TypeFlagsBoolean {
		return true
	}
	if s&TypeFlagsESSymbolLike && t&TypeFlagsESSymbol {
		return true
	}
	if s&TypeFlagsEnum && t&TypeFlagsEnum && source.symbol.escapedName == target.symbol.escapedName && tc.isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
		return true
	}
	if s&TypeFlagsEnumLiteral && t&TypeFlagsEnumLiteral {
		if s&TypeFlagsUnion && t&TypeFlagsUnion && tc.isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
			return true
		}
		if s&TypeFlagsLiteral && t&TypeFlagsLiteral && (source /* as LiteralType */).value == (target /* as LiteralType */).value && tc.isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
			return true
		}
	}
	// In non-strictNullChecks mode, `undefined` and `null` are assignable to anything except `never`.
	// Since unions and intersections may reduce to `never`, we exclude them here.
	if s&TypeFlagsUndefined && (!tc.strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&(TypeFlagsUndefined|TypeFlagsVoid)) {
		return true
	}
	if s&TypeFlagsNull && (!tc.strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&TypeFlagsNull) {
		return true
	}
	if s&TypeFlagsObject && t&TypeFlagsNonPrimitive && !(relation == tc.strictSubtypeRelation && tc.isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlagsFreshLiteral)) {
		return true
	}
	if relation == tc.assignableRelation || relation == tc.comparableRelation {
		if s & TypeFlagsAny {
			return true
		}
		// Type number is assignable to any computed numeric enum type or any numeric enum literal type, and
		// a numeric literal type is assignable any computed numeric enum type or any numeric enum literal type
		// with a matching value. These rules exist such that enums can be used for bit-flag purposes.
		if s&TypeFlagsNumber && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral) {
			return true
		}
		if s&TypeFlagsNumberLiteral && !(s & TypeFlagsEnumLiteral) && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral && (source /* as NumberLiteralType */).value == (target /* as NumberLiteralType */).value) {
			return true
		}
		// Anything is assignable to a union containing undefined, null, and {}
		if tc.isUnknownLikeUnionType(target) {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) isTypeRelatedTo(source Type, target Type, relation Map[string, RelationComparisonResult]) bool {
	if tc.isFreshLiteralType(source) {
		source = (source /* as FreshableType */).regularType
	}
	if tc.isFreshLiteralType(target) {
		target = (target /* as FreshableType */).regularType
	}
	if source == target {
		return true
	}
	if relation != tc.identityRelation {
		if relation == tc.comparableRelation && !(target.flags&TypeFlagsNever) && tc.isSimpleTypeRelatedTo(target, source, relation) || tc.isSimpleTypeRelatedTo(source, target, relation) {
			return true
		}
	} else if !((source.flags | target.flags) & (TypeFlagsUnionOrIntersection | TypeFlagsIndexedAccess | TypeFlagsConditional | TypeFlagsSubstitution)) {
		// We have excluded types that may simplify to other forms, so types must have identical flags
		if source.flags != target.flags {
			return false
		}
		if source.flags & TypeFlagsSingleton {
			return true
		}
	}
	if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
		related := relation.get(tc.getRelationKey(source, target, IntersectionStateNone, relation /*ignoreConstraints*/, false))
		if related != nil {
			return !!(related & RelationComparisonResultSucceeded)
		}
	}
	if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
		return tc.checkTypeRelatedTo(source, target, relation /*errorNode*/, nil)
	}
	return false
}

func (tc *TypeChecker) isIgnoredJsxProperty(source Type, sourceProp Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
	return getObjectFlags(source)&ObjectFlagsJsxAttributes && tc.isHyphenatedJsxName(sourceProp.escapedName)
}

func (tc *TypeChecker) getNormalizedType(type_ Type, writing bool) Type {
	for true {
		var t Type
		switch {
		case tc.isFreshLiteralType(type_):
			t = (type_ /* as FreshableType */).regularType
		case tc.isGenericTupleType(type_):
			t = tc.getNormalizedTupleType(type_, writing)
		case getObjectFlags(type_) & ObjectFlagsReference:
			if (type_ /* as TypeReference */).node {
				t = tc.createTypeReference((type_ /* as TypeReference */).target, tc.getTypeArguments(type_ /* as TypeReference */))
			} else {
				t = tc.getSingleBaseForNonAugmentingSubtype(type_) || type_
			}
		case type_.flags & TypeFlagsUnionOrIntersection:
			t = tc.getNormalizedUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, writing)
		case type_.flags & TypeFlagsSubstitution:
			if writing {
				t = (type_ /* as SubstitutionType */).baseType
			} else {
				t = tc.getSubstitutionIntersection(type_ /* as SubstitutionType */)
			}
		case type_.flags & TypeFlagsSimplifiable:
			t = tc.getSimplifiedType(type_, writing)
		default:
			t = type_
		}
		if t == type_ {
			return t
		}
		type_ = t
	}
}

func (tc *TypeChecker) getNormalizedUnionOrIntersectionType(type_ UnionOrIntersectionType, writing bool) Type {
	reduced := tc.getReducedType(type_)
	if reduced != type_ {
		return reduced
	}
	if type_.flags&TypeFlagsIntersection && tc.shouldNormalizeIntersection(type_ /* as IntersectionType */) {
		// Normalization handles cases like
		// Partial<T>[K] & ({} | null) ==>
		// Partial<T>[K] & {} | Partial<T>[K} & null ==>
		// (T[K] | undefined) & {} | (T[K] | undefined) & null ==>
		// T[K] & {} | undefined & {} | T[K] & null | undefined & null ==>
		// T[K] & {} | T[K] & null
		normalizedTypes := sameMap(type_.types, func(t Type) Type {
			return tc.getNormalizedType(t, writing)
		})
		if normalizedTypes != type_.types {
			return tc.getIntersectionType(normalizedTypes)
		}
	}
	return type_
}

func (tc *TypeChecker) shouldNormalizeIntersection(type_ IntersectionType) bool {
	hasInstantiable := false
	hasNullableOrEmpty := false
	for _, t := range type_.types {
		hasInstantiable = hasInstantiable || !!(t.flags & TypeFlagsInstantiable)
		hasNullableOrEmpty = hasNullableOrEmpty || !!(t.flags & TypeFlagsNullable) || tc.isEmptyAnonymousObjectType(t)
		if hasInstantiable && hasNullableOrEmpty {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) getNormalizedTupleType(type_ TupleTypeReference, writing bool) Type {
	elements := tc.getElementTypes(type_)
	normalizedElements := sameMap(elements, func(t Type) Type {
		if t.flags & TypeFlagsSimplifiable {
			return tc.getSimplifiedType(t, writing)
		} else {
			return t
		}
	})
	if elements != normalizedElements {
		return tc.createNormalizedTupleType(type_.target, normalizedElements)
	} else {
		return type_
	}
}

/**
 * Checks if 'source' is related to 'target' (e.g.: is a assignable to).
 * @param source The left-hand-side of the relation.
 * @param target The right-hand-side of the relation.
 * @param relation The relation considered. One of 'identityRelation', 'subtypeRelation', 'assignableRelation', or 'comparableRelation'.
 * Used as both to determine which checks are performed and as a cache of previously computed results.
 * @param errorNode The suggested node upon which all errors will be reported, if defined. This may or may not be the actual node used.
 * @param headMessage If the error chain should be prepended by a head message, then headMessage will be used.
 * @param containingMessageChain A chain of errors to prepend any new errors found.
 * @param errorOutputContainer Return the diagnostic. Do not log if 'skipLogging' is truthy.
 */

func (tc *TypeChecker) checkTypeRelatedTo(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	var errorInfo *DiagnosticMessageChain
	var relatedInfo * /* TODO(TS-TO-GO) TypeNode TupleType: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] */ any
	var maybeKeys []string
	var maybeKeysSet Set[string]
	var sourceStack []Type
	var targetStack []Type
	maybeCount := 0
	sourceDepth := 0
	targetDepth := 0
	expandingFlags := ExpandingFlagsNone
	overflow := false
	overrideNextErrorInfo := 0
	// How many `reportRelationError` calls should be skipped in the elaboration pyramid
	skipParentCounter := 0
	// How many errors should be skipped 'above' in the elaboration pyramid
	var lastSkippedInfo * /* TODO(TS-TO-GO) TypeNode TupleType: [Type, Type] */ any
	var incompatibleStack *[]DiagnosticAndArguments
	// In Node.js, the maximum number of elements in a map is 2^24. We limit the number of entries an invocation
	// of checkTypeRelatedTo can add to a relation to 1/8th of its remaining capacity.
	relationCount := /* TODO(TS-TO-GO) GreaterThanGreaterThanToken BinaryExpression: (16_000_000 - relation.size) >> 3 */ TODO

	Debug.assert(relation != tc.identityRelation || !errorNode, "no error reporting in identity checking")

	result := isRelatedTo(source, target, RecursionFlagsBoth /*reportErrors*/, !!errorNode, headMessage)
	if incompatibleStack {
		reportIncompatibleStack()
	}
	if overflow {
		// Record this relation as having failed such that we don't attempt the overflowing operation again.
		id := tc.getRelationKey(source, target /*intersectionState*/, IntersectionStateNone, relation /*ignoreConstraints*/, false)
		relation.set(id, RelationComparisonResultFailed|(__COND__(relationCount <= 0, RelationComparisonResultComplexityOverflow, RelationComparisonResultStackDepthOverflow)))
		tracing. /* ? */ instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"sourceId":    source.id,
			"targetId":    target.id,
			"depth":       sourceDepth,
			"targetDepth": targetDepth,
		})
		var message DiagnosticMessage
		if relationCount <= 0 {
			message = Diagnostics.Excessive_complexity_comparing_types_0_and_1
		} else {
			message = Diagnostics.Excessive_stack_depth_comparing_types_0_and_1
		}
		diag := tc.error(errorNode || tc.currentNode, message, tc.typeToString(source), tc.typeToString(target))
		if errorOutputContainer {
			(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
		}
	} else if errorInfo {
		if containingMessageChain {
			chain := containingMessageChain()
			if chain {
				concatenateDiagnosticMessageChains(chain, errorInfo)
				errorInfo = chain
			}
		}

		var relatedInformation *[]DiagnosticRelatedInformation
		// Check if we should issue an extra diagnostic to produce a quickfix for a slightly incorrect import statement
		if headMessage && errorNode && !result && source.symbol {
			links := tc.getSymbolLinks(source.symbol)
			if links.originatingImport && !isImportCall(links.originatingImport) {
				helpfulRetry := tc.checkTypeRelatedTo(tc.getTypeOfSymbol(links.target), target, relation /*errorNode*/, nil)
				if helpfulRetry {
					// Likely an incorrect import. Issue a helpful diagnostic to produce a quickfix to change the import
					diag := createDiagnosticForNode(links.originatingImport, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead)
					relatedInformation = append(relatedInformation, diag)
					// Cause the error to appear with the error that triggered it
				}
			}
		}
		diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, errorInfo, relatedInformation)
		if relatedInfo {
			addRelatedInfo(diag, relatedInfo...)
		}
		if errorOutputContainer {
			(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
		}
		if !errorOutputContainer || !errorOutputContainer.skipLogging {
			tc.diagnostics.add(diag)
		}
	}
	if errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result == TernaryFalse {
		Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.")
	}

	return result != TernaryFalse

	resetErrorInfo := func(saved ReturnType[ /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof captureErrorCalculationState */ any]) {
		errorInfo = saved.errorInfo
		lastSkippedInfo = saved.lastSkippedInfo
		incompatibleStack = saved.incompatibleStack
		overrideNextErrorInfo = saved.overrideNextErrorInfo
		skipParentCounter = saved.skipParentCounter
		relatedInfo = saved.relatedInfo
	}

	captureErrorCalculationState := func() /* TODO(TS-TO-GO) inferred type { errorInfo: DiagnosticMessageChain | undefined; lastSkippedInfo: [Type, Type] | undefined; incompatibleStack: [message: DiagnosticMessage, ...args: (string | number)[]][] | undefined; overrideNextErrorInfo: number; skipParentCounter: number; relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined; } */ any {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"errorInfo":             errorInfo,
			"lastSkippedInfo":       lastSkippedInfo,
			"incompatibleStack":     incompatibleStack. /* ? */ slice(),
			"overrideNextErrorInfo": overrideNextErrorInfo,
			"skipParentCounter":     skipParentCounter,
			"relatedInfo":           relatedInfo. /* ? */ slice(), /* as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined */
		}
	}

	reportIncompatibleError := func(message DiagnosticMessage, args DiagnosticArguments) {
		overrideNextErrorInfo++
		// Suppress the next relation error
		lastSkippedInfo = nil
		// Reset skipped info cache
		( /* TODO(TS-TO-GO) BarBarEqualsToken BinaryExpression: incompatibleStack ||= [] */ TODO).push([]any{message /* TODO(TS-TO-GO) Node SpreadElement: ...args */})
	}

	reportIncompatibleStack := func() undefined {
		stack := incompatibleStack || []never{}
		incompatibleStack = nil
		info := lastSkippedInfo
		lastSkippedInfo = nil
		if stack.length == 1 {
			reportError(stack[0]...)
			if info {
				// Actually do the last relation error
				reportRelationError(nil, info...)
			}
			return
		}
		// The first error will be the innermost, while the last will be the outermost - so by popping off the end,
		// we can build from left to right
		path := ""
		var secondaryRootErrors []DiagnosticAndArguments = []never{}
		for stack.length {
			TODO_IDENTIFIER := stack.pop()
			switch msg.code {
			case Diagnostics.Types_of_property_0_are_incompatible.code:
				// Parenthesize a `new` if there is one
				if path.indexOf("new ") == 0 {
					path = __TEMPLATE__("(", path, ")")
				}
				str := "" + args[0]
				// If leading, just print back the arg (irrespective of if it's a valid identifier)
				if path.length == 0 {
					path = __TEMPLATE__(str)
				} else if isIdentifierText(str, getEmitScriptTarget(tc.compilerOptions)) {
					path = __TEMPLATE__(path, ".", str)
				} else if str[0] == "[" && str[str.length-1] == "]" {
					path = __TEMPLATE__(path, str)
				} else {
					path = __TEMPLATE__(path, "[", str, "]")
				}
				break
				fallthrough
			case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code,
				Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code,
				Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code,
				Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:
				if path.length == 0 {
					// Don't flatten signature compatability errors at the start of a chain - instead prefer
					// to unify (the with no arguments bit is excessive for printback) and print them back
					mappedMsg := msg
					if msg.code == Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
						mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible
					} else if msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
						mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible
					}
					secondaryRootErrors.unshift([]any{mappedMsg, args[0], args[1]})
				} else {
					var prefix /* TODO(TS-TO-GO) inferred type "" | "new " */ any
					if msg.code == Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code || msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
						prefix = "new "
					} else {
						prefix = ""
					}
					var params /* TODO(TS-TO-GO) inferred type "" | "..." */ any
					if msg.code == Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code || msg.code == Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code {
						params = ""
					} else {
						params = "..."
					}
					path = __TEMPLATE__(prefix, path, "(", params, ")")
				}
				break
				fallthrough
			case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code:
				secondaryRootErrors.unshift([]any{Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]})
				break
				fallthrough
			case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code:
				secondaryRootErrors.unshift([]any{Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]})
				break
				fallthrough
			default:
				return Debug.fail(__TEMPLATE__("Unhandled Diagnostic: ", msg.code))
			}
		}
		if path {
			reportError(__COND__(path[path.length-1] == ")", Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types, Diagnostics.The_types_of_0_are_incompatible_between_these_types), path)
		} else {
			// Remove the innermost secondary error as it will duplicate the error already reported by `reportRelationError` on entry
			secondaryRootErrors.shift()
		}
		for _, TODO_IDENTIFIER := range secondaryRootErrors {
			originalValue := msg.elidedInCompatabilityPyramid
			msg.elidedInCompatabilityPyramid = false
			// Temporarily override elision to ensure error is reported
			reportError(msg, args...)
			msg.elidedInCompatabilityPyramid = originalValue
		}
		if info {
			// Actually do the last relation error
			reportRelationError(nil, info...)
		}
	}

	reportError := func(message DiagnosticMessage, args DiagnosticArguments) {
		Debug.assert(!!errorNode)
		if incompatibleStack {
			reportIncompatibleStack()
		}
		if message.elidedInCompatabilityPyramid {
			return
		}
		if skipParentCounter == 0 {
			errorInfo = chainDiagnosticMessages(errorInfo, message, args...)
		} else {
			skipParentCounter--
		}
	}

	reportParentSkippedError := func(message DiagnosticMessage, args DiagnosticArguments) {
		reportError(message, args...)
		skipParentCounter++
	}

	associateRelatedInfo := func(info DiagnosticRelatedInformation) {
		Debug.assert(!!errorInfo)
		if !relatedInfo {
			relatedInfo = []any{info}
		} else {
			relatedInfo.push(info)
		}
	}

	reportRelationError := func(message *DiagnosticMessage, source Type, target Type) {
		if incompatibleStack {
			reportIncompatibleStack()
		}
		TODO_IDENTIFIER := tc.getTypeNamesForErrorDisplay(source, target)
		generalizedSource := source
		generalizedSourceType := sourceType

		// Don't generalize on 'never' - we really want the original type
		// to be displayed for use-cases like 'assertNever'.
		if !(target.flags & TypeFlagsNever) && tc.isLiteralType(source) && !tc.typeCouldHaveTopLevelSingletonTypes(target) {
			generalizedSource = tc.getBaseTypeOfLiteralType(source)
			Debug.assert(!tc.isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable")
			generalizedSourceType = tc.getTypeNameForErrorDisplay(generalizedSource)
		}

		// If `target` is of indexed access type (And `source` it is not), we use the object type of `target` for better error reporting
		var targetFlags TypeFlags
		if target.flags&TypeFlagsIndexedAccess && !(source.flags & TypeFlagsIndexedAccess) {
			targetFlags = (target /* as IndexedAccessType */).objectType.flags
		} else {
			targetFlags = target.flags
		}

		if targetFlags&TypeFlagsTypeParameter && target != tc.markerSuperTypeForCheck && target != tc.markerSubTypeForCheck {
			constraint := tc.getBaseConstraintOfType(target)
			var needsOriginalSource TODO
			if constraint && (tc.isTypeAssignableTo(generalizedSource, constraint) || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: needsOriginalSource = isTypeAssignableTo(source, constraint) */ TODO)) {
				reportError(Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2, __COND__(needsOriginalSource, sourceType, generalizedSourceType), targetType, tc.typeToString(constraint))
			} else {
				errorInfo = nil
				reportError(Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType)
			}
		}

		if !message {
			if relation == tc.comparableRelation {
				message = Diagnostics.Type_0_is_not_comparable_to_type_1
			} else if sourceType == targetType {
				message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated
			} else if tc.exactOptionalPropertyTypes && tc.getExactOptionalUnassignableProperties(source, target).length {
				message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
			} else {
				if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsUnion {
					suggestedType := tc.getSuggestedTypeForNonexistentStringLiteralType(source /* as StringLiteralType */, target /* as UnionType */)
					if suggestedType {
						reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, tc.typeToString(suggestedType))
						return
					}
				}
				message = Diagnostics.Type_0_is_not_assignable_to_type_1
			}
		} else if message == Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 && tc.exactOptionalPropertyTypes && tc.getExactOptionalUnassignableProperties(source, target).length {
			message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
		}

		reportError(message, generalizedSourceType, targetType)
	}

	tryElaborateErrorsForPrimitivesAndObjects := func(source Type, target Type) {
		var sourceType string
		if tc.symbolValueDeclarationIsContextSensitive(source.symbol) {
			sourceType = tc.typeToString(source, source.symbol.valueDeclaration)
		} else {
			sourceType = tc.typeToString(source)
		}
		var targetType string
		if tc.symbolValueDeclarationIsContextSensitive(target.symbol) {
			targetType = tc.typeToString(target, target.symbol.valueDeclaration)
		} else {
			targetType = tc.typeToString(target)
		}

		if (tc.globalStringType == source && tc.stringType == target) || (tc.globalNumberType == source && tc.numberType == target) || (tc.globalBooleanType == source && tc.booleanType == target) || (tc.getGlobalESSymbolType() == source && tc.esSymbolType == target) {
			reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType)
		}
	}

	/**
	 * Try and elaborate array and tuple errors. Returns false
	 * if we have found an elaboration, or we should ignore
	 * any other elaborations when relating the `source` and
	 * `target` types.
	 */

	tryElaborateArrayLikeErrors := func(source Type, target Type, reportErrors bool) bool {
		/**
		 * The spec for elaboration is:
		 * - If the source is a readonly tuple and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
		 * - If the source is a tuple then skip property elaborations if the target is an array or tuple.
		 * - If the source is a readonly array and the target is a mutable array or tuple, elaborate on mutability and skip property elaborations.
		 * - If the source an array then skip property elaborations if the target is a tuple.
		 */
		if tc.isTupleType(source) {
			if source.target.readonly && tc.isMutableArrayOrTuple(target) {
				if reportErrors {
					reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, tc.typeToString(source), tc.typeToString(target))
				}
				return false
			}
			return tc.isArrayOrTupleType(target)
		}
		if tc.isReadonlyArrayType(source) && tc.isMutableArrayOrTuple(target) {
			if reportErrors {
				reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, tc.typeToString(source), tc.typeToString(target))
			}
			return false
		}
		if tc.isTupleType(target) {
			return tc.isArrayType(source)
		}
		return true
	}

	isRelatedToWorker := func(source Type, target Type, reportErrors bool) Ternary {
		return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors)
	}

	/**
	 * Compare two types and return
	 * * Ternary.True if they are related with no assumptions,
	 * * Ternary.Maybe if they are related with assumptions of other relationships, or
	 * * Ternary.False if they are not related.
	 */

	isRelatedTo := func(originalSource Type, originalTarget Type, recursionFlags RecursionFlags /*  = RecursionFlags.Both */, reportErrors bool /*  = false */, headMessage DiagnosticMessage, intersectionState IntersectionState /*  = IntersectionState.None */) Ternary {
		if originalSource == originalTarget {
			return TernaryTrue
		}

		// Before normalization: if `source` is type an object type, and `target` is primitive,
		// skip all the checks we don't need and just return `isSimpleTypeRelatedTo` result
		if originalSource.flags&TypeFlagsObject && originalTarget.flags&TypeFlagsPrimitive {
			if relation == tc.comparableRelation && !(originalTarget.flags&TypeFlagsNever) && tc.isSimpleTypeRelatedTo(originalTarget, originalSource, relation) || tc.isSimpleTypeRelatedTo(originalSource, originalTarget, relation, __COND__(reportErrors, reportError, nil)) {
				return TernaryTrue
			}
			if reportErrors {
				reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage)
			}
			return TernaryFalse
		}

		// Normalize the source and target types: Turn fresh literal types into regular literal types,
		// turn deferred type references into regular type references, simplify indexed access and
		// conditional types, and resolve substitution types to either the substitution (on the source
		// side) or the type variable (on the target side).
		source := tc.getNormalizedType(originalSource /*writing*/, false)
		target := tc.getNormalizedType(originalTarget /*writing*/, true)

		if source == target {
			return TernaryTrue
		}

		if relation == tc.identityRelation {
			if source.flags != target.flags {
				return TernaryFalse
			}
			if source.flags & TypeFlagsSingleton {
				return TernaryTrue
			}
			traceUnionsOrIntersectionsTooLarge(source, target)
			return recursiveTypeRelatedTo(source, target /*reportErrors*/, false, IntersectionStateNone, recursionFlags)
		}

		// We fastpath comparing a type parameter to exactly its constraint, as this is _super_ common,
		// and otherwise, for type parameters in large unions, causes us to need to compare the union to itself,
		// as we break down the _target_ union first, _then_ get the source constraint - so for every
		// member of the target, we attempt to find a match in the source. This avoids that in cases where
		// the target is exactly the constraint.
		if source.flags&TypeFlagsTypeParameter && tc.getConstraintOfType(source) == target {
			return TernaryTrue
		}

		// See if we're relating a definitely non-nullable type to a union that includes null and/or undefined
		// plus a single non-nullable type. If so, remove null and/or undefined from the target type.
		if source.flags&TypeFlagsDefinitelyNonNullable && target.flags&TypeFlagsUnion {
			types := (target /* as UnionType */).types
			var candidate Type
			switch {
			case types.length == 2 && types[0].flags&TypeFlagsNullable:
				candidate = types[1]
			case types.length == 3 && types[0].flags&TypeFlagsNullable && types[1].flags&TypeFlagsNullable:
				candidate = types[2]
			default:
				candidate = nil
			}
			if candidate && !(candidate.flags & TypeFlagsNullable) {
				target = tc.getNormalizedType(candidate /*writing*/, true)
				if source == target {
					return TernaryTrue
				}
			}
		}

		if relation == tc.comparableRelation && !(target.flags&TypeFlagsNever) && tc.isSimpleTypeRelatedTo(target, source, relation) || tc.isSimpleTypeRelatedTo(source, target, relation, __COND__(reportErrors, reportError, nil)) {
			return TernaryTrue
		}

		if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
			isPerformingExcessPropertyChecks := !(intersectionState & IntersectionStateTarget) && (tc.isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral)
			if isPerformingExcessPropertyChecks {
				if hasExcessProperties(source /* as FreshObjectLiteralType */, target, reportErrors) {
					if reportErrors {
						reportRelationError(headMessage, source, __COND__(originalTarget.aliasSymbol, originalTarget, target))
					}
					return TernaryFalse
				}
			}

			isPerformingCommonPropertyChecks := (relation != tc.comparableRelation || tc.isUnitType(source)) && !(intersectionState & IntersectionStateTarget) && source.flags&(TypeFlagsPrimitive|TypeFlagsObject|TypeFlagsIntersection) && source != tc.globalObjectType && target.flags&(TypeFlagsObject|TypeFlagsIntersection) && tc.isWeakType(target) && (tc.getPropertiesOfType(source).length > 0 || tc.typeHasCallOrConstructSignatures(source))
			isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
			if isPerformingCommonPropertyChecks && !tc.hasCommonProperties(source, target, isComparingJsxAttributes) {
				if reportErrors {
					sourceString := tc.typeToString(__COND__(originalSource.aliasSymbol, originalSource, source))
					targetString := tc.typeToString(__COND__(originalTarget.aliasSymbol, originalTarget, target))
					calls := tc.getSignaturesOfType(source, SignatureKindCall)
					constructs := tc.getSignaturesOfType(source, SignatureKindConstruct)
					if calls.length > 0 && isRelatedTo(tc.getReturnTypeOfSignature(calls[0]), target, RecursionFlagsSource /*reportErrors*/, false) || constructs.length > 0 && isRelatedTo(tc.getReturnTypeOfSignature(constructs[0]), target, RecursionFlagsSource /*reportErrors*/, false) {
						reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString)
					} else {
						reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString)
					}
				}
				return TernaryFalse
			}

			traceUnionsOrIntersectionsTooLarge(source, target)

			skipCaching := source.flags&TypeFlagsUnion && (source /* as UnionType */).types.length < 4 && !(target.flags&TypeFlagsUnion) || target.flags&TypeFlagsUnion && (target /* as UnionType */).types.length < 4 && !(source.flags&TypeFlagsStructuredOrInstantiable)
			var result Ternary
			if skipCaching {
				result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState)
			} else {
				result = recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags)
			}
			if result {
				return result
			}
		}

		if reportErrors {
			reportErrorResults(originalSource, originalTarget, source, target, headMessage)
		}
		return TernaryFalse
	}

	reportErrorResults := func(originalSource Type, originalTarget Type, source Type, target Type, headMessage *DiagnosticMessage) {
		sourceHasBase := !!tc.getSingleBaseForNonAugmentingSubtype(originalSource)
		targetHasBase := !!tc.getSingleBaseForNonAugmentingSubtype(originalTarget)
		if originalSource.aliasSymbol || sourceHasBase {
			source = originalSource
		} else {
			source = source
		}
		if originalTarget.aliasSymbol || targetHasBase {
			target = originalTarget
		} else {
			target = target
		}
		maybeSuppress := overrideNextErrorInfo > 0
		if maybeSuppress {
			overrideNextErrorInfo--
		}
		if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
			currentError := errorInfo
			tryElaborateArrayLikeErrors(source, target /*reportErrors*/, true)
			if errorInfo != currentError {
				maybeSuppress = !!errorInfo
			}
		}
		if source.flags&TypeFlagsObject && target.flags&TypeFlagsPrimitive {
			tryElaborateErrorsForPrimitivesAndObjects(source, target)
		} else if source.symbol && source.flags&TypeFlagsObject && tc.globalObjectType == source {
			reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead)
		} else if getObjectFlags(source)&ObjectFlagsJsxAttributes && target.flags&TypeFlagsIntersection {
			targetTypes := (target /* as IntersectionType */).types
			intrinsicAttributes := tc.getJsxType(JsxNames.IntrinsicAttributes, errorNode)
			intrinsicClassAttributes := tc.getJsxType(JsxNames.IntrinsicClassAttributes, errorNode)
			if !tc.isErrorType(intrinsicAttributes) && !tc.isErrorType(intrinsicClassAttributes) && (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)) {
				// do not report top error
				return
			}
		} else {
			errorInfo = tc.elaborateNeverIntersection(errorInfo, originalTarget)
		}
		// Used by, eg, missing property checking to replace the top-level message with a more informative one.
		if !headMessage && maybeSuppress {
			// We suppress a call to `reportRelationError` or not depending on the state of the type checker, so
			// we call `reportRelationError` here and then undo its effects to figure out what would be the diagnostic
			// if we hadn't supress it, and save that as a canonical diagnostic for deduplication purposes.
			savedErrorState := captureErrorCalculationState()
			reportRelationError(headMessage, source, target)
			var canonical TODO
			if errorInfo && errorInfo != savedErrorState.errorInfo {
				canonical = map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"code":        errorInfo.code,
					"messageText": errorInfo.messageText,
				}
			}
			resetErrorInfo(savedErrorState)
			if canonical && errorInfo {
				errorInfo.canonicalHead = canonical
			}

			lastSkippedInfo = []any{source, target}
			return
		}
		reportRelationError(headMessage, source, target)
		if source.flags&TypeFlagsTypeParameter && source.symbol. /* ? */ declarations[0] && !tc.getConstraintOfType(source /* as TypeVariable */) {
			syntheticParam := tc.cloneTypeParameter(source /* as TypeParameter */)
			syntheticParam.constraint = tc.instantiateType(target, tc.makeUnaryTypeMapper(source, syntheticParam))
			if tc.hasNonCircularBaseConstraint(syntheticParam) {
				targetConstraintString := tc.typeToString(target, source.symbol.declarations[0])
				associateRelatedInfo(createDiagnosticForNode(source.symbol.declarations[0], Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString))
			}
		}
	}

	traceUnionsOrIntersectionsTooLarge := func(source Type, target Type) {
		if !tracing {
			return
		}

		if (source.flags & TypeFlagsUnionOrIntersection) && (target.flags & TypeFlagsUnionOrIntersection) {
			sourceUnionOrIntersection := source /* as UnionOrIntersectionType */
			targetUnionOrIntersection := target /* as UnionOrIntersectionType */

			if sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlagsPrimitiveUnion {
				// There's a fast path for comparing primitive unions
				return
			}

			sourceSize := sourceUnionOrIntersection.types.length
			targetSize := targetUnionOrIntersection.types.length
			if sourceSize*targetSize > 1e6 {
				tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"sourceId":   source.id,
					"sourceSize": sourceSize,
					"targetId":   target.id,
					"targetSize": targetSize,
					"pos":        errorNode. /* ? */ pos,
					"end":        errorNode. /* ? */ end,
				})
			}
		}
	}

	getTypeOfPropertyInTypes := func(types []Type, name __String) Type {
		appendPropType := func(propTypes *[]Type, type_ Type) []Type {
			type_ = tc.getApparentType(type_)
			var prop Symbol
			if type_.flags & TypeFlagsUnionOrIntersection {
				prop = tc.getPropertyOfUnionOrIntersectionType(type_ /* as UnionOrIntersectionType */, name)
			} else {
				prop = tc.getPropertyOfObjectType(type_, name)
			}
			propType := prop && tc.getTypeOfSymbol(prop) || tc.getApplicableIndexInfoForName(type_, name). /* ? */ type_ || tc.undefinedType
			return append(propTypes, propType)
		}
		return tc.getUnionType(reduceLeft(types, appendPropType /*initial*/, nil) || emptyArray)
	}

	hasExcessProperties := func(source FreshObjectLiteralType, target Type, reportErrors bool) bool {
		if !tc.isExcessPropertyCheckTarget(target) || !tc.noImplicitAny && getObjectFlags(target)&ObjectFlagsJSLiteral {
			return false
			// Disable excess property checks on JS literals to simulate having an implicit "index signature" - but only outside of noImplicitAny
		}
		isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
		if (relation == tc.assignableRelation || relation == tc.comparableRelation) && (tc.isTypeSubsetOf(tc.globalObjectType, target) || (!isComparingJsxAttributes && tc.isEmptyObjectType(target))) {
			return false
		}
		reducedTarget := target
		var checkTypes *[]Type
		if target.flags & TypeFlagsUnion {
			reducedTarget = tc.findMatchingDiscriminantType(source, target /* as UnionType */, isRelatedTo) || tc.filterPrimitivesIfContainsNonPrimitive(target /* as UnionType */)
			if reducedTarget.flags & TypeFlagsUnion {
				checkTypes = (reducedTarget /* as UnionType */).types
			} else {
				checkTypes = []Type{reducedTarget}
			}
		}
		for _, prop := range tc.getPropertiesOfType(source) {
			if shouldCheckAsExcessProperty(prop, source.symbol) && !tc.isIgnoredJsxProperty(source, prop) {
				if !tc.isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes) {
					if reportErrors {
						// Report error in terms of object types in the target as those are the only ones
						// we check in isKnownProperty.
						errorTarget := tc.filterType(reducedTarget, tc.isExcessPropertyCheckTarget)
						// We know *exactly* where things went wrong when comparing the types.
						// Use this property as the error node as this will be more helpful in
						// reasoning about what went wrong.
						if !errorNode {
							return Debug.fail()
						}
						if isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement(errorNode.parent) {
							// JsxAttributes has an object-literal flag and undergo same type-assignablity check as normal object-literal.
							// However, using an object-literal error message will be very confusing to the users so we give different a message.
							if prop.valueDeclaration && isJsxAttribute(prop.valueDeclaration) && getSourceFileOfNode(errorNode) == getSourceFileOfNode(prop.valueDeclaration.name) {
								// Note that extraneous children (as in `<NoChild>extra</NoChild>`) don't pass this check,
								// since `children` is a SyntaxKind.PropertySignature instead of a SyntaxKind.JsxAttribute.
								errorNode = prop.valueDeclaration.name
							}
							propName := tc.symbolToString(prop)
							suggestionSymbol := tc.getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget)
							var suggestion *string
							if suggestionSymbol {
								suggestion = tc.symbolToString(suggestionSymbol)
							} else {
								suggestion = nil
							}
							if suggestion {
								reportError(Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, tc.typeToString(errorTarget), suggestion)
							} else {
								reportError(Diagnostics.Property_0_does_not_exist_on_type_1, propName, tc.typeToString(errorTarget))
							}
						} else {
							// use the property's value declaration if the property is assigned inside the literal itself
							objectLiteralDeclaration := source.symbol. /* ? */ declarations && firstOrUndefined(source.symbol.declarations)
							var suggestion *string
							if prop.valueDeclaration && findAncestor(prop.valueDeclaration, func(d Node) bool {
								return d == objectLiteralDeclaration
							}) && getSourceFileOfNode(objectLiteralDeclaration) == getSourceFileOfNode(errorNode) {
								propDeclaration := prop.valueDeclaration /* as ObjectLiteralElementLike */
								Debug.assertNode(propDeclaration, isObjectLiteralElementLike)

								name := propDeclaration.name
								errorNode = name

								if isIdentifier(name) {
									suggestion = tc.getSuggestionForNonexistentProperty(name, errorTarget)
								}
							}
							if suggestion != nil {
								reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, tc.symbolToString(prop), tc.typeToString(errorTarget), suggestion)
							} else {
								reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, tc.symbolToString(prop), tc.typeToString(errorTarget))
							}
						}
					}
					return true
				}
				if checkTypes && !isRelatedTo(tc.getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), RecursionFlagsBoth, reportErrors) {
					if reportErrors {
						reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, tc.symbolToString(prop))
					}
					return true
				}
			}
		}
		return false
	}

	shouldCheckAsExcessProperty := func(prop Symbol, container Symbol) *bool {
		return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent == container.valueDeclaration
	}

	unionOrIntersectionRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
		// Note that these checks are specifically ordered to produce correct results. In particular,
		// we need to deconstruct unions before intersections (because unions are always at the top),
		// and we need to handle "each" relations before "some" relations for the same kind of type.
		if source.flags & TypeFlagsUnion {
			if target.flags & TypeFlagsUnion {
				// Intersections of union types are normalized into unions of intersection types, and such normalized
				// unions can get very large and expensive to relate. The following fast path checks if the source union
				// originated in an intersection. If so, and if that intersection contains the target type, then we know
				// the result to be true (for any two types A and B, A & B is related to both A and B).
				sourceOrigin := (source /* as UnionType */).origin
				if sourceOrigin && sourceOrigin.flags&TypeFlagsIntersection && target.aliasSymbol && contains((sourceOrigin /* as IntersectionType */).types, target) {
					return TernaryTrue
				}
				// Similarly, in unions of unions the we preserve the original list of unions. This original list is often
				// much shorter than the normalized result, so we scan it in the following fast path.
				targetOrigin := (target /* as UnionType */).origin
				if targetOrigin && targetOrigin.flags&TypeFlagsUnion && source.aliasSymbol && contains((targetOrigin /* as UnionType */).types, source) {
					return TernaryTrue
				}
			}
			if relation == tc.comparableRelation {
				return someTypeRelatedToType(source /* as UnionType */, target, reportErrors && !(source.flags&TypeFlagsPrimitive), intersectionState)
			} else {
				return eachTypeRelatedToType(source /* as UnionType */, target, reportErrors && !(source.flags&TypeFlagsPrimitive), intersectionState)
			}
		}
		if target.flags & TypeFlagsUnion {
			return typeRelatedToSomeType(tc.getRegularTypeOfObjectLiteral(source), target /* as UnionType */, reportErrors && !(source.flags&TypeFlagsPrimitive) && !(target.flags&TypeFlagsPrimitive), intersectionState)
		}
		if target.flags & TypeFlagsIntersection {
			return typeRelatedToEachType(source, target /* as IntersectionType */, reportErrors, IntersectionStateTarget)
		}
		// Source is an intersection. For the comparable relation, if the target is a primitive type we hoist the
		// constraints of all non-primitive types in the source into a new intersection. We do this because the
		// intersection may further constrain the constraints of the non-primitive types. For example, given a type
		// parameter 'T extends 1 | 2', the intersection 'T & 1' should be reduced to '1' such that it doesn't
		// appear to be comparable to '2'.
		if relation == tc.comparableRelation && target.flags&TypeFlagsPrimitive {
			constraints := sameMap((source /* as IntersectionType */).types, func(t Type) Type {
				if t.flags & TypeFlagsInstantiable {
					return tc.getBaseConstraintOfType(t) || tc.unknownType
				} else {
					return t
				}
			})
			if constraints != (source /* as IntersectionType */).types {
				source = tc.getIntersectionType(constraints)
				if source.flags & TypeFlagsNever {
					return TernaryFalse
				}
				if !(source.flags & TypeFlagsIntersection) {
					return isRelatedTo(source, target, RecursionFlagsSource /*reportErrors*/, false) || isRelatedTo(target, source, RecursionFlagsSource /*reportErrors*/, false)
				}
			}
		}
		// Check to see if any constituents of the intersection are immediately related to the target.
		// Don't report errors though. Elaborating on whether a source constituent is related to the target is
		// not actually useful and leads to some confusing error messages. Instead, we rely on the caller
		// checking whether the full intersection viewed as an object is related to the target.
		return someTypeRelatedToType(source /* as IntersectionType */, target /*reportErrors*/, false, IntersectionStateSource)
	}

	eachTypeRelatedToSomeType := func(source UnionOrIntersectionType, target UnionOrIntersectionType) Ternary {
		result := TernaryTrue
		sourceTypes := source.types
		for _, sourceType := range sourceTypes {
			related := typeRelatedToSomeType(sourceType, target /*reportErrors*/, false, IntersectionStateNone)
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		return result
	}

	typeRelatedToSomeType := func(source Type, target UnionOrIntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
		targetTypes := target.types
		if target.flags & TypeFlagsUnion {
			if tc.containsType(targetTypes, source) {
				return TernaryTrue
			}
			if relation != tc.comparableRelation && getObjectFlags(target)&ObjectFlagsPrimitiveUnion && !(source.flags & TypeFlagsEnumLiteral) && (source.flags&(TypeFlagsStringLiteral|TypeFlagsBooleanLiteral|TypeFlagsBigIntLiteral) || (relation == tc.subtypeRelation || relation == tc.strictSubtypeRelation) && source.flags&TypeFlagsNumberLiteral) {
				// When relating a literal type to a union of primitive types, we know the relation is false unless
				// the union contains the base primitive type or the literal type in one of its fresh/regular forms.
				// We exclude numeric literals for non-subtype relations because numeric literals are assignable to
				// numeric enum literals with the same value. Similarly, we exclude enum literal types because
				// identically named enum types are related (see isEnumTypeRelatedTo). We exclude the comparable
				// relation in entirety because it needs to be checked in both directions.
				var alternateForm FreshableType
				if source == (source /* as StringLiteralType */).regularType {
					alternateForm = (source /* as StringLiteralType */).freshType
				} else {
					alternateForm = (source /* as StringLiteralType */).regularType
				}
				var primitive *IntrinsicType
				switch {
				case source.flags & TypeFlagsStringLiteral:
					primitive = tc.stringType
				case source.flags & TypeFlagsNumberLiteral:
					primitive = tc.numberType
				case source.flags & TypeFlagsBigIntLiteral:
					primitive = tc.bigintType
				default:
					primitive = nil
				}
				if primitive && tc.containsType(targetTypes, primitive) || alternateForm && tc.containsType(targetTypes, alternateForm) {
					return TernaryTrue
				} else {
					return TernaryFalse
				}
			}
			match := tc.getMatchingUnionConstituentForType(target /* as UnionType */, source)
			if match {
				related := isRelatedTo(source, match, RecursionFlagsTarget /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
				if related {
					return related
				}
			}
		}
		for _, type_ := range targetTypes {
			related := isRelatedTo(source, type_, RecursionFlagsTarget /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
			if related {
				return related
			}
		}
		if reportErrors {
			// Elaborate only if we can find a best matching type in the target union
			bestMatchingType := tc.getBestMatchingType(source, target, isRelatedTo)
			if bestMatchingType {
				isRelatedTo(source, bestMatchingType, RecursionFlagsTarget /*reportErrors*/, true /*headMessage*/, nil, intersectionState)
			}
		}
		return TernaryFalse
	}

	typeRelatedToEachType := func(source Type, target IntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
		result := TernaryTrue
		targetTypes := target.types
		for _, targetType := range targetTypes {
			related := isRelatedTo(source, targetType, RecursionFlagsTarget, reportErrors /*headMessage*/, nil, intersectionState)
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		return result
	}

	someTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
		sourceTypes := source.types
		if source.flags&TypeFlagsUnion && tc.containsType(sourceTypes, target) {
			return TernaryTrue
		}
		len := sourceTypes.length
		for i := 0; i < len; i++ {
			related := isRelatedTo(sourceTypes[i], target, RecursionFlagsSource, reportErrors && i == len-1 /*headMessage*/, nil, intersectionState)
			if related {
				return related
			}
		}
		return TernaryFalse
	}

	getUndefinedStrippedTargetIfNeeded := func(source Type, target Type) Type {
		if source.flags&TypeFlagsUnion && target.flags&TypeFlagsUnion && !((source /* as UnionType */).types[0].flags & TypeFlagsUndefined) && (target /* as UnionType */).types[0].flags&TypeFlagsUndefined {
			return tc.extractTypesOfKind(target, ~TypeFlagsUndefined)
		}
		return target
	}

	eachTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
		result := TernaryTrue
		sourceTypes := source.types
		// We strip `undefined` from the target if the `source` trivially doesn't contain it for our correspondence-checking fastpath
		// since `undefined` is frequently added by optionality and would otherwise spoil a potentially useful correspondence
		undefinedStrippedTarget := getUndefinedStrippedTargetIfNeeded(source, target /* as UnionType */)
		for i := 0; i < sourceTypes.length; i++ {
			sourceType := sourceTypes[i]
			if undefinedStrippedTarget.flags&TypeFlagsUnion && sourceTypes.length >= (undefinedStrippedTarget /* as UnionType */).types.length && sourceTypes.length%(undefinedStrippedTarget /* as UnionType */).types.length == 0 {
				// many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison
				// such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large
				// union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,
				// the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`
				// - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union
				related := isRelatedTo(sourceType, (undefinedStrippedTarget /* as UnionType */).types[i%(undefinedStrippedTarget /* as UnionType */).types.length], RecursionFlagsBoth /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
				if related {
					result &= related
					continue
				}
			}
			related := isRelatedTo(sourceType, target, RecursionFlagsSource, reportErrors /*headMessage*/, nil, intersectionState)
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		return result
	}

	typeArgumentsRelatedTo := func(sources []Type /*  = emptyArray */, targets []Type /*  = emptyArray */, variances []VarianceFlags /*  = emptyArray */, reportErrors bool, intersectionState IntersectionState) Ternary {
		if sources.length != targets.length && relation == tc.identityRelation {
			return TernaryFalse
		}
		var length number
		if sources.length <= targets.length {
			length = sources.length
		} else {
			length = targets.length
		}
		result := TernaryTrue
		for i := 0; i < length; i++ {
			// When variance information isn't available we default to covariance. This happens
			// in the process of computing variance information for recursive types and when
			// comparing 'this' type arguments.
			var varianceFlags VarianceFlags
			if i < variances.length {
				varianceFlags = variances[i]
			} else {
				varianceFlags = VarianceFlagsCovariant
			}
			variance := varianceFlags & VarianceFlagsVarianceMask
			// We ignore arguments for independent type parameters (because they're never witnessed).
			if variance != VarianceFlagsIndependent {
				s := sources[i]
				t := targets[i]
				related := TernaryTrue
				if varianceFlags & VarianceFlagsUnmeasurable {
					// Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.
					// We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by
					// the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)
					if relation == tc.identityRelation {
						related = isRelatedTo(s, t, RecursionFlagsBoth /*reportErrors*/, false)
					} else {
						related = tc.compareTypesIdentical(s, t)
					}
				} else if variance == VarianceFlagsCovariant {
					related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
				} else if variance == VarianceFlagsContravariant {
					related = isRelatedTo(t, s, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
				} else if variance == VarianceFlagsBivariant {
					// In the bivariant case we first compare contravariantly without reporting
					// errors. Then, if that doesn't succeed, we compare covariantly with error
					// reporting. Thus, error elaboration will be based on the the covariant check,
					// which is generally easier to reason about.
					related = isRelatedTo(t, s, RecursionFlagsBoth /*reportErrors*/, false)
					if !related {
						related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
					}
				} else {
					// In the invariant case we first compare covariantly, and only when that
					// succeeds do we proceed to compare contravariantly. Thus, error elaboration
					// will typically be based on the covariant check.
					related = isRelatedTo(s, t, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
					if related {
						related &= isRelatedTo(t, s, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
					}
				}
				if !related {
					return TernaryFalse
				}
				result &= related
			}
		}
		return result
	}

	// Determine if possibly recursive types are related. First, check if the result is already available in the global cache.
	// Second, check if we have already started a comparison of the given two types in which case we assume the result to be true.
	// Third, check if both types are part of deeply nested chains of generic type instantiations and if so assume the types are
	// equal and infinitely expanding. Fourth, if we have reached a depth of 100 nested comparisons, assume we have runaway recursion
	// and issue an error. Otherwise, actually compare the structure of the two types.
	recursiveTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, recursionFlags RecursionFlags) Ternary {
		if overflow {
			return TernaryFalse
		}
		id := tc.getRelationKey(source, target, intersectionState, relation /*ignoreConstraints*/, false)
		entry := relation.get(id)
		if entry != nil {
			if reportErrors && entry&RelationComparisonResultFailed && !(entry & RelationComparisonResultOverflow) {
				// We are elaborating errors and the cached result is a failure not due to a comparison overflow,
				// so we will do the comparison again to generate an error message.
			} else {
				if tc.outofbandVarianceMarkerHandler {
					// We're in the middle of variance checking - integrate any unmeasurable/unreliable flags from this cached component
					saved := entry & RelationComparisonResultReportsMask
					if saved & RelationComparisonResultReportsUnmeasurable {
						tc.instantiateType(source, tc.reportUnmeasurableMapper)
					}
					if saved & RelationComparisonResultReportsUnreliable {
						tc.instantiateType(source, tc.reportUnreliableMapper)
					}
				}
				if reportErrors && entry&RelationComparisonResultOverflow {
					var message DiagnosticMessage
					if entry & RelationComparisonResultComplexityOverflow {
						message = Diagnostics.Excessive_complexity_comparing_types_0_and_1
					} else {
						message = Diagnostics.Excessive_stack_depth_comparing_types_0_and_1
					}
					reportError(message, tc.typeToString(source), tc.typeToString(target))
					overrideNextErrorInfo++
				}
				if entry & RelationComparisonResultSucceeded {
					return TernaryTrue
				} else {
					return TernaryFalse
				}
			}
		}
		if relationCount <= 0 {
			overflow = true
			return TernaryFalse
		}
		if !maybeKeys {
			maybeKeys = []never{}
			maybeKeysSet = NewSet()
			sourceStack = []never{}
			targetStack = []never{}
		} else {
			// If source and target are already being compared, consider them related with assumptions
			if maybeKeysSet.has(id) {
				return TernaryMaybe
			}

			// A key that starts with "*" is an indication that we have type references that reference constrained
			// type parameters. For such keys we also check against the key we would have gotten if all type parameters
			// were unconstrained.
			var broadestEquivalentId *string
			if id.startsWith("*") {
				broadestEquivalentId = tc.getRelationKey(source, target, intersectionState, relation /*ignoreConstraints*/, true)
			} else {
				broadestEquivalentId = nil
			}
			if broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId) {
				return TernaryMaybe
			}

			if sourceDepth == 100 || targetDepth == 100 {
				overflow = true
				return TernaryFalse
			}
		}
		maybeStart := maybeCount
		maybeKeys[maybeCount] = id
		maybeKeysSet.add(id)
		maybeCount++
		saveExpandingFlags := expandingFlags
		if recursionFlags & RecursionFlagsSource {
			sourceStack[sourceDepth] = source
			sourceDepth++
			if !(expandingFlags & ExpandingFlagsSource) && tc.isDeeplyNestedType(source, sourceStack, sourceDepth) {
				expandingFlags |= ExpandingFlagsSource
			}
		}
		if recursionFlags & RecursionFlagsTarget {
			targetStack[targetDepth] = target
			targetDepth++
			if !(expandingFlags & ExpandingFlagsTarget) && tc.isDeeplyNestedType(target, targetStack, targetDepth) {
				expandingFlags |= ExpandingFlagsTarget
			}
		}
		var originalHandler /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof outofbandVarianceMarkerHandler */ any
		propagatingVarianceFlags := 0 /* as RelationComparisonResult */
		if tc.outofbandVarianceMarkerHandler {
			originalHandler = tc.outofbandVarianceMarkerHandler
			tc.outofbandVarianceMarkerHandler = func(onlyUnreliable bool) {
				if onlyUnreliable {
					propagatingVarianceFlags |= RelationComparisonResultReportsUnreliable
				} else {
					propagatingVarianceFlags |= RelationComparisonResultReportsUnmeasurable
				}
				return originalHandler(onlyUnreliable)
			}
		}

		var result Ternary
		if expandingFlags == ExpandingFlagsBoth {
			tracing. /* ? */ instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"sourceId": source.id,
				"sourceIdStack": sourceStack.map_(func(t Type) number {
					return t.id
				}),
				"targetId": target.id,
				"targetIdStack": targetStack.map_(func(t Type) number {
					return t.id
				}),
				"depth":       sourceDepth,
				"targetDepth": targetDepth,
			})
			result = TernaryMaybe
		} else {
			tracing. /* ? */ push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"sourceId": source.id,
				"targetId": target.id,
			})
			result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState)
			tracing. /* ? */ pop()
		}

		if tc.outofbandVarianceMarkerHandler {
			tc.outofbandVarianceMarkerHandler = originalHandler
		}
		if recursionFlags & RecursionFlagsSource {
			sourceDepth--
		}
		if recursionFlags & RecursionFlagsTarget {
			targetDepth--
		}
		expandingFlags = saveExpandingFlags
		if result {
			if result == TernaryTrue || (sourceDepth == 0 && targetDepth == 0) {
				if result == TernaryTrue || result == TernaryMaybe {
					// If result is definitely true, record all maybe keys as having succeeded. Also, record Ternary.Maybe
					// results as having succeeded once we reach depth 0, but never record Ternary.Unknown results.
					resetMaybeStack(true)
				} else {
					resetMaybeStack(false)
				}
			}
			// Note: it's intentional that we don't reset in the else case;
			// we leave them on the stack such that when we hit depth zero
			// above, we can report all of them as successful.
		} else {
			// A false result goes straight into global cache (when something is false under
			// assumptions it will also be false without assumptions)
			relation.set(id, RelationComparisonResultFailed|propagatingVarianceFlags)
			relationCount--
			resetMaybeStack(false)
		}
		return result

		resetMaybeStack := func(markAllAsSucceeded bool) {
			for i := maybeStart; i < maybeCount; i++ {
				maybeKeysSet.delete(maybeKeys[i])
				if markAllAsSucceeded {
					relation.set(maybeKeys[i], RelationComparisonResultSucceeded|propagatingVarianceFlags)
					relationCount--
				}
			}
			maybeCount = maybeStart
		}

	}

	structuredTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
		saveErrorInfo := captureErrorCalculationState()
		result := structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo)
		if relation != tc.identityRelation {
			// The combined constraint of an intersection type is the intersection of the constraints of
			// the constituents. When an intersection type contains instantiable types with union type
			// constraints, there are situations where we need to examine the combined constraint. One is
			// when the target is a union type. Another is when the intersection contains types belonging
			// to one of the disjoint domains. For example, given type variables T and U, each with the
			// constraint 'string | number', the combined constraint of 'T & U' is 'string | number' and
			// we need to check this constraint against a union on the target side. Also, given a type
			// variable V constrained to 'string | number', 'V & number' has a combined constraint of
			// 'string & number | number & number' which reduces to just 'number'.
			// This also handles type parameters, as a type parameter with a union constraint compared against a union
			// needs to have its constraint hoisted into an intersection with said type parameter, this way
			// the type param can be compared with itself in the target (with the influence of its constraint to match other parts)
			// For example, if `T extends 1 | 2` and `U extends 2 | 3` and we compare `T & U` to `T & U & (1 | 2 | 3)`
			if !result && (source.flags&TypeFlagsIntersection || source.flags&TypeFlagsTypeParameter && target.flags&TypeFlagsUnion) {
				constraint := tc.getEffectiveConstraintOfIntersection(__COND__(source.flags&TypeFlagsIntersection, (source /* as IntersectionType */).types, []Type{source}), !!(target.flags & TypeFlagsUnion))
				if constraint && tc.everyType(constraint, func(c Type) bool {
					return c != source
				}) {
					// TODO: Stack errors so we get a pyramid for the "normal" comparison above, _and_ a second for this
					result = isRelatedTo(constraint, target, RecursionFlagsSource /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
				}
			}
			// When the target is an intersection we need an extra property check in order to detect nested excess
			// properties and nested weak types. The following are motivating examples that all should be errors, but
			// aren't without this extra property check:
			//
			//   let obj: { a: { x: string } } & { c: number } = { a: { x: 'hello', y: 2 }, c: 5 };  // Nested excess property
			//
			//   declare let wrong: { a: { y: string } };
			//   let weak: { a?: { x?: number } } & { c?: string } = wrong;  // Nested weak object type
			//
			if result && !(intersectionState & IntersectionStateTarget) && target.flags&TypeFlagsIntersection && !tc.isGenericObjectType(target) && source.flags&(TypeFlagsObject|TypeFlagsIntersection) {
				result &= propertiesRelatedTo(source, target, reportErrors /*excludedProperties*/, nil /*optionalsOnly*/, false, IntersectionStateNone)
				if result && tc.isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral {
					result &= indexSignaturesRelatedTo(source, target /*sourceIsPrimitive*/, false, reportErrors, IntersectionStateNone)
				}
			} else if result && tc.isNonGenericObjectType(target) && !tc.isArrayOrTupleType(target) && source.flags&TypeFlagsIntersection && tc.getApparentType(source).flags&TypeFlagsStructuredType && !some((source /* as IntersectionType */).types, func(t Type) bool {
				return t == target || !!(getObjectFlags(t) & ObjectFlagsNonInferrableType)
			}) {
				result &= propertiesRelatedTo(source, target, reportErrors /*excludedProperties*/, nil /*optionalsOnly*/, true, intersectionState)
			}
		}
		if result {
			resetErrorInfo(saveErrorInfo)
		}
		return result
	}

	getApparentMappedTypeKeys := func(nameType Type, targetType MappedType) Type {
		modifiersType := tc.getApparentType(tc.getModifiersTypeFromMappedType(targetType))
		var mappedKeys []Type = []never{}
		tc.forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, false, func(t Type) undefined {
			return mappedKeys.push(tc.instantiateType(nameType, tc.appendTypeMapping(targetType.mapper, tc.getTypeParameterFromMappedType(targetType), t)))
		})
		return tc.getUnionType(mappedKeys)
	}

	structuredTypeRelatedToWorker := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, saveErrorInfo ReturnType[ /* TODO(TS-TO-GO) TypeNode TypeQuery: typeof captureErrorCalculationState */ any]) Ternary {
		var result Ternary
		var originalErrorInfo *DiagnosticMessageChain
		varianceCheckFailed := false
		sourceFlags := source.flags
		targetFlags := target.flags
		if relation == tc.identityRelation {
			// We've already checked that source.flags and target.flags are identical
			if sourceFlags & TypeFlagsUnionOrIntersection {
				result := eachTypeRelatedToSomeType(source /* as UnionOrIntersectionType */, target /* as UnionOrIntersectionType */)
				if result {
					result &= eachTypeRelatedToSomeType(target /* as UnionOrIntersectionType */, source /* as UnionOrIntersectionType */)
				}
				return result
			}
			if sourceFlags & TypeFlagsIndex {
				return isRelatedTo((source /* as IndexType */).type_, (target /* as IndexType */).type_, RecursionFlagsBoth /*reportErrors*/, false)
			}
			if sourceFlags & TypeFlagsIndexedAccess {
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
					if /* TODO(TS-TO-GO) AmpersandEqualsToken BinaryExpression: result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						return result
					}
				}
			}
			if sourceFlags & TypeFlagsConditional {
				if (source /* as ConditionalType */).root.isDistributive == (target /* as ConditionalType */).root.isDistributive {
					if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(TS-TO-GO) AmpersandEqualsToken BinaryExpression: result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							if /* TODO(TS-TO-GO) AmpersandEqualsToken BinaryExpression: result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
								if /* TODO(TS-TO-GO) AmpersandEqualsToken BinaryExpression: result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
									return result
								}
							}
						}
					}
				}
			}
			if sourceFlags & TypeFlagsSubstitution {
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
					if /* TODO(TS-TO-GO) AmpersandEqualsToken BinaryExpression: result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						return result
					}
				}
			}
			if !(sourceFlags & TypeFlagsObject) {
				return TernaryFalse
			}
		} else if sourceFlags&TypeFlagsUnionOrIntersection || targetFlags&TypeFlagsUnionOrIntersection {
			if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) */ TODO {
				return result
			}
			// The ordered decomposition above doesn't handle all cases. Specifically, we also need to handle:
			// Source is instantiable (e.g. source has union or intersection constraint).
			// Source is an object, target is a union (e.g. { a, b: boolean } <=> { a, b: true } | { a, b: false }).
			// Source is an intersection, target is an object (e.g. { a } & { b } <=> { a, b }).
			// Source is an intersection, target is a union (e.g. { a } & { b: boolean } <=> { a, b: true } | { a, b: false }).
			// Source is an intersection, target instantiable (e.g. string & { tag } <=> T["a"] constrained to string & { tag }).
			if !(sourceFlags&TypeFlagsInstantiable || sourceFlags&TypeFlagsObject && targetFlags&TypeFlagsUnion || sourceFlags&TypeFlagsIntersection && targetFlags&(TypeFlagsObject|TypeFlagsUnion|TypeFlagsInstantiable)) {
				return TernaryFalse
			}
		}

		// We limit alias variance probing to only object and conditional types since their alias behavior
		// is more predictable than other, interned types, which may or may not have an alias depending on
		// the order in which things were checked.
		if sourceFlags&(TypeFlagsObject|TypeFlagsConditional) && source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol == target.aliasSymbol && !(tc.isMarkerType(source) || tc.isMarkerType(target)) {
			variances := tc.getAliasVariances(source.aliasSymbol)
			if variances == emptyArray {
				return TernaryUnknown
			}
			params := tc.getSymbolLinks(source.aliasSymbol).typeParameters
			minParams := tc.getMinTypeArgumentCount(params)
			sourceTypes := tc.fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
			targetTypes := tc.fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
			varianceResult := relateVariances(sourceTypes, targetTypes, variances, intersectionState)
			if varianceResult != nil {
				return varianceResult
			}
		}

		// For a generic type T and a type U that is assignable to T, [...U] is assignable to T, U is assignable to readonly [...T],
		// and U is assignable to [...T] when U is constrained to a mutable array or tuple type.
		if tc.isSingleElementGenericTupleType(source) && !source.target.readonly && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source) */ TODO) || tc.isSingleElementGenericTupleType(target) && (target.target.readonly || tc.isMutableArrayOrTuple(tc.getBaseConstraintOfType(source) || source)) && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target) */ TODO) {
			return result
		}

		if targetFlags & TypeFlagsTypeParameter {
			// A source type { [P in Q]: X } is related to a target type T if keyof T is related to Q and X is related to T[Q].
			if getObjectFlags(source)&ObjectFlagsMapped && !(source /* as MappedType */).declaration.nameType && isRelatedTo(tc.getIndexType(target), tc.getConstraintTypeFromMappedType(source /* as MappedType */), RecursionFlagsBoth) {
				if !(tc.getMappedTypeModifiers(source /* as MappedType */) & MappedTypeModifiersIncludeOptional) {
					templateType := tc.getTemplateTypeFromMappedType(source /* as MappedType */)
					indexedAccessType := tc.getIndexedAccessType(target, tc.getTypeParameterFromMappedType(source /* as MappedType */))
					if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors) */ TODO {
						return result
					}
				}
			}
			if relation == tc.comparableRelation && sourceFlags&TypeFlagsTypeParameter {
				// This is a carve-out in comparability to essentially forbid comparing a type parameter
				// with another type parameter unless one extends the other. (Remember: comparability is mostly bidirectional!)
				constraint := tc.getConstraintOfTypeParameter(source)
				if constraint {
					for constraint && tc.someType(constraint, func(c Type) bool {
						return !!(c.flags & TypeFlagsTypeParameter)
					}) {
						if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false) */ TODO {
							return result
						}
						constraint = tc.getConstraintOfTypeParameter(constraint)
					}
				}
				return TernaryFalse
			}
		} else if targetFlags & TypeFlagsIndex {
			targetType := (target /* as IndexType */).type_
			// A keyof S is related to a keyof T if T is related to S.
			if sourceFlags & TypeFlagsIndex {
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
					return result
				}
			}
			if tc.isTupleType(targetType) {
				// An index type can have a tuple type target when the tuple type contains variadic elements.
				// Check if the source is related to the known keys of the tuple type.
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors) */ TODO {
					return result
				}
			} else {
				// A type S is assignable to keyof T if S is assignable to keyof C, where C is the
				// simplified form of T or, if T doesn't simplify, the constraint of T.
				constraint := tc.getSimplifiedTypeOrConstraint(targetType)
				if constraint {
					// We require Ternary.True here such that circular constraints don't cause
					// false positives. For example, given 'T extends { [K in keyof T]: string }',
					// 'keyof T' has itself as its constraint and produces a Ternary.Maybe when
					// related to other types.
					if isRelatedTo(source, tc.getIndexType(constraint, (target /* as IndexType */).indexFlags|IndexFlagsNoReducibleCheck), RecursionFlagsTarget, reportErrors) == TernaryTrue {
						return TernaryTrue
					}
				} else if tc.isGenericMappedType(targetType) {
					// generic mapped types that don't simplify or have a constraint still have a very simple set of keys we can compare against
					// - their nameType or constraintType.
					// In many ways, this comparison is a deferred version of what `getIndexTypeForMappedType` does to actually resolve the keys for _non_-generic types

					nameType := tc.getNameTypeFromMappedType(targetType)
					constraintType := tc.getConstraintTypeFromMappedType(targetType)
					var targetKeys TODO
					if nameType && tc.isMappedTypeWithKeyofConstraintDeclaration(targetType) {
						// we need to get the apparent mappings and union them with the generic mappings, since some properties may be
						// missing from the `constraintType` which will otherwise be mapped in the object
						mappedKeys := getApparentMappedTypeKeys(nameType, targetType)
						// We still need to include the non-apparent (and thus still generic) keys in the target side of the comparison (in case they're in the source side)
						targetKeys = tc.getUnionType([]Type{mappedKeys, nameType})
					} else {
						targetKeys = nameType || constraintType
					}
					if isRelatedTo(source, targetKeys, RecursionFlagsTarget, reportErrors) == TernaryTrue {
						return TernaryTrue
					}
				}
			}
		} else if targetFlags & TypeFlagsIndexedAccess {
			if sourceFlags & TypeFlagsIndexedAccess {
				// Relate components directly before falling back to constraint relationships
				// A type S[K] is related to a type T[J] if S is related to T and K is related to J.
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors) */ TODO {
					result &= isRelatedTo((source /* as IndexedAccessType */).indexType, (target /* as IndexedAccessType */).indexType, RecursionFlagsBoth, reportErrors)
				}
				if result {
					return result
				}
				if reportErrors {
					originalErrorInfo = errorInfo
				}
			}
			// A type S is related to a type T[K] if S is related to C, where C is the base
			// constraint of T[K] for writing.
			if relation == tc.assignableRelation || relation == tc.comparableRelation {
				objectType := (target /* as IndexedAccessType */).objectType
				indexType := (target /* as IndexedAccessType */).indexType
				baseObjectType := tc.getBaseConstraintOfType(objectType) || objectType
				baseIndexType := tc.getBaseConstraintOfType(indexType) || indexType
				if !tc.isGenericObjectType(baseObjectType) && !tc.isGenericIndexType(baseIndexType) {
					accessFlags := AccessFlagsWriting | (__COND__(baseObjectType != objectType, AccessFlagsNoIndexSignatures, 0))
					constraint := tc.getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags)
					if constraint {
						if reportErrors && originalErrorInfo {
							// create a new chain for the constraint error
							resetErrorInfo(saveErrorInfo)
						}
						if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState) */ TODO {
							return result
						}
						// prefer the shorter chain of the constraint comparison chain, and the direct comparison chain
						if reportErrors && originalErrorInfo && errorInfo {
							if countMessageChainBreadth([]DiagnosticMessageChain{originalErrorInfo}) <= countMessageChainBreadth([]DiagnosticMessageChain{errorInfo}) {
								errorInfo = originalErrorInfo
							} else {
								errorInfo = errorInfo
							}
						}
					}
				}
			}
			if reportErrors {
				originalErrorInfo = nil
			}
		} else if tc.isGenericMappedType(target) && relation != tc.identityRelation {
			// Check if source type `S` is related to target type `{ [P in Q]: T }` or `{ [P in Q as R]: T}`.
			keysRemapped := !!target.declaration.nameType
			templateType := tc.getTemplateTypeFromMappedType(target)
			modifiers := tc.getMappedTypeModifiers(target)
			if !(modifiers & MappedTypeModifiersExcludeOptional) {
				// If the mapped type has shape `{ [P in Q]: T[P] }`,
				// source `S` is related to target if `T` = `S`, i.e. `S` is related to `{ [P in Q]: S[P] }`.
				if !keysRemapped && templateType.flags&TypeFlagsIndexedAccess && (templateType /* as IndexedAccessType */).objectType == source && (templateType /* as IndexedAccessType */).indexType == tc.getTypeParameterFromMappedType(target) {
					return TernaryTrue
				}
				if !tc.isGenericMappedType(source) {
					// If target has shape `{ [P in Q as R]: T}`, then its keys have type `R`.
					// If target has shape `{ [P in Q]: T }`, then its keys have type `Q`.
					var targetKeys Type
					if keysRemapped {
						targetKeys = tc.getNameTypeFromMappedType(target)
					} else {
						targetKeys = tc.getConstraintTypeFromMappedType(target)
					}
					// Type of the keys of source type `S`, i.e. `keyof S`.
					sourceKeys := tc.getIndexType(source, IndexFlagsNoIndexSignatures)
					includeOptional := modifiers & MappedTypeModifiersIncludeOptional
					var filteredByApplicability Type
					if includeOptional {
						filteredByApplicability = tc.intersectTypes(targetKeys, sourceKeys)
					} else {
						filteredByApplicability = nil
					}
					// A source type `S` is related to a target type `{ [P in Q]: T }` if `Q` is related to `keyof S` and `S[Q]` is related to `T`.
					// A source type `S` is related to a target type `{ [P in Q as R]: T }` if `R` is related to `keyof S` and `S[R]` is related to `T.
					// A source type `S` is related to a target type `{ [P in Q]?: T }` if some constituent `Q'` of `Q` is related to `keyof S` and `S[Q']` is related to `T`.
					// A source type `S` is related to a target type `{ [P in Q as R]?: T }` if some constituent `R'` of `R` is related to `keyof S` and `S[R']` is related to `T`.
					if __COND__(includeOptional, !(filteredByApplicability.flags & TypeFlagsNever), isRelatedTo(targetKeys, sourceKeys, RecursionFlagsBoth)) {
						templateType := tc.getTemplateTypeFromMappedType(target)
						typeParameter := tc.getTypeParameterFromMappedType(target)

						// Fastpath: When the template type has the form `Obj[P]` where `P` is the mapped type parameter, directly compare source `S` with `Obj`
						// to avoid creating the (potentially very large) number of new intermediate types made by manufacturing `S[P]`.
						nonNullComponent := tc.extractTypesOfKind(templateType, ~TypeFlagsNullable)
						if !keysRemapped && nonNullComponent.flags&TypeFlagsIndexedAccess && (nonNullComponent /* as IndexedAccessType */).indexType == typeParameter {
							if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors) */ TODO {
								return result
							}
						} else {
							// We need to compare the type of a property on the source type `S` to the type of the same property on the target type,
							// so we need to construct an indexing type representing a property, and then use indexing type to index the source type for comparison.

							// If the target type has shape `{ [P in Q]: T }`, then a property of the target has type `P`.
							// If the target type has shape `{ [P in Q]?: T }`, then a property of the target has type `P`,
							// but the property is optional, so we only want to compare properties `P` that are common between `keyof S` and `Q`.
							// If the target type has shape `{ [P in Q as R]: T }`, then a property of the target has type `R`.
							// If the target type has shape `{ [P in Q as R]?: T }`, then a property of the target has type `R`,
							// but the property is optional, so we only want to compare properties `R` that are common between `keyof S` and `R`.
							var indexingType Type
							switch {
							case keysRemapped:
								indexingType = (filteredByApplicability || targetKeys)
							case filteredByApplicability:
								indexingType = tc.getIntersectionType([]Type{filteredByApplicability, typeParameter})
							default:
								indexingType = typeParameter
							}
							indexedAccessType := tc.getIndexedAccessType(source, indexingType)
							// Compare `S[indexingType]` to `T`, where `T` is the type of a property of the target type.
							if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors) */ TODO {
								return result
							}
						}
					}
					originalErrorInfo = errorInfo
					resetErrorInfo(saveErrorInfo)
				}
			}
		} else if targetFlags & TypeFlagsConditional {
			// If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
			// conditional type and bail out with a Ternary.Maybe result.
			if tc.isDeeplyNestedType(target, targetStack, targetDepth, 10) {
				return TernaryMaybe
			}
			c := target /* as ConditionalType */
			// We check for a relationship to a conditional type target only when the conditional type has no
			// 'infer' positions, is not distributive or is distributive but doesn't reference the check type
			// parameter in either of the result types, and the source isn't an instantiation of the same
			// conditional type (as happens when computing variance).
			if !c.root.inferTypeParameters && !tc.isDistributionDependent(c.root) && !(source.flags&TypeFlagsConditional && (source /* as ConditionalType */).root == c.root) {
				// Check if the conditional is always true or always false but still deferred for distribution purposes.
				skipTrue := !tc.isTypeAssignableTo(tc.getPermissiveInstantiation(c.checkType), tc.getPermissiveInstantiation(c.extendsType))
				skipFalse := !skipTrue && tc.isTypeAssignableTo(tc.getRestrictiveInstantiation(c.checkType), tc.getRestrictiveInstantiation(c.extendsType))
				// TODO: Find a nice way to include potential conditional type breakdowns in error output, if they seem good (they usually don't)
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
					if skipFalse {
						result &= TernaryTrue
					} else {
						result &= isRelatedTo(source, tc.getFalseTypeFromConditionalType(c), RecursionFlagsTarget /*reportErrors*/, false /*headMessage*/, nil, intersectionState)
					}
					if result {
						return result
					}
				}
			}
		} else if targetFlags & TypeFlagsTemplateLiteral {
			if sourceFlags & TypeFlagsTemplateLiteral {
				if relation == tc.comparableRelation {
					if tc.templateLiteralTypesDefinitelyUnrelated(source /* as TemplateLiteralType */, target /* as TemplateLiteralType */) {
						return TernaryFalse
					} else {
						return TernaryTrue
					}
				}
				// Report unreliable variance for type variables referenced in template literal type placeholders.
				// For example, `foo-${number}` is related to `foo-${string}` even though number isn't related to string.
				tc.instantiateType(source, tc.reportUnreliableMapper)
			}
			if tc.isTypeMatchedByTemplateLiteralType(source, target /* as TemplateLiteralType */) {
				return TernaryTrue
			}
		} else if target.flags & TypeFlagsStringMapping {
			if !(source.flags & TypeFlagsStringMapping) {
				if tc.isMemberOfStringMapping(source, target) {
					return TernaryTrue
				}
			}
		}

		if sourceFlags & TypeFlagsTypeVariable {
			// IndexedAccess comparisons are handled above in the `targetFlags & TypeFlage.IndexedAccess` branch
			if !(sourceFlags&TypeFlagsIndexedAccess && targetFlags&TypeFlagsIndexedAccess) {
				constraint := tc.getConstraintOfType(source /* as TypeVariable */) || tc.unknownType
				// hi-speed no-this-instantiation check (less accurate, but avoids costly `this`-instantiation when the constraint will suffice), see #28231 for report on why this is needed
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
					return result
				} else if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage* / undefined, intersectionState) */ TODO {
					return result
				}
				if tc.isMappedTypeGenericIndexedAccess(source) {
					// For an indexed access type { [P in K]: E}[X], above we have already explored an instantiation of E with X
					// substituted for P. We also want to explore type { [P in K]: E }[C], where C is the constraint of X.
					indexConstraint := tc.getConstraintOfType((source /* as IndexedAccessType */).indexType)
					if indexConstraint {
						if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors) */ TODO {
							return result
						}
					}
				}
			}
		} else if sourceFlags & TypeFlagsIndex {
			isDeferredMappedIndex := tc.shouldDeferIndexType((source /* as IndexType */).type_, (source /* as IndexType */).indexFlags) && getObjectFlags((source /* as IndexType */).type_)&ObjectFlagsMapped
			if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex) */ TODO {
				return result
			}
			if isDeferredMappedIndex {
				mappedType := (source /* as IndexType */).type_ /* as MappedType */
				nameType := tc.getNameTypeFromMappedType(mappedType)
				// Unlike on the target side, on the source side we do *not* include the generic part of the `nameType`, since that comes from a
				// (potentially anonymous) mapped type local type parameter, so that'd never assign outside the mapped type body, but we still want to
				// allow assignments of index types of identical (or similar enough) mapped types.
				// eg, `keyof {[X in keyof A]: Obj[X]}` should be assignable to `keyof {[Y in keyof A]: Tup[Y]}` because both map over the same set of keys (`keyof A`).
				// Without this source-side breakdown, a `keyof {[X in keyof A]: Obj[X]}` style type won't be assignable to anything except itself, which is much too strict.
				var sourceMappedKeys Type
				if nameType && tc.isMappedTypeWithKeyofConstraintDeclaration(mappedType) {
					sourceMappedKeys = getApparentMappedTypeKeys(nameType, mappedType)
				} else {
					sourceMappedKeys = (nameType || tc.getConstraintTypeFromMappedType(mappedType))
				}
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors) */ TODO {
					return result
				}
			}
		} else if sourceFlags&TypeFlagsTemplateLiteral && !(targetFlags & TypeFlagsObject) {
			if !(targetFlags & TypeFlagsTemplateLiteral) {
				constraint := tc.getBaseConstraintOfType(source)
				if constraint && constraint != source && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
					return result
				}
			}
		} else if sourceFlags & TypeFlagsStringMapping {
			if targetFlags & TypeFlagsStringMapping {
				if (source /* as StringMappingType */).symbol != (target /* as StringMappingType */).symbol {
					return TernaryFalse
				}
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors) */ TODO {
					return result
				}
			} else {
				constraint := tc.getBaseConstraintOfType(source)
				if constraint && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
					return result
				}
			}
		} else if sourceFlags & TypeFlagsConditional {
			// If we reach 10 levels of nesting for the same conditional type, assume it is an infinitely expanding recursive
			// conditional type and bail out with a Ternary.Maybe result.
			if tc.isDeeplyNestedType(source, sourceStack, sourceDepth, 10) {
				return TernaryMaybe
			}
			if targetFlags & TypeFlagsConditional {
				// Two conditional types 'T1 extends U1 ? X1 : Y1' and 'T2 extends U2 ? X2 : Y2' are related if
				// one of T1 and T2 is related to the other, U1 and U2 are identical types, X1 is related to X2,
				// and Y1 is related to Y2.
				sourceParams := (source /* as ConditionalType */).root.inferTypeParameters
				sourceExtends := (source /* as ConditionalType */).extendsType
				var mapper *TypeMapper
				if sourceParams {
					// If the source has infer type parameters, we instantiate them in the context of the target
					ctx := tc.createInferenceContext(sourceParams /*signature*/, nil, InferenceFlagsNone, isRelatedToWorker)
					tc.inferTypes(ctx.inferences, (target /* as ConditionalType */).extendsType, sourceExtends, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
					sourceExtends = tc.instantiateType(sourceExtends, ctx.mapper)
					mapper = ctx.mapper
				}
				if tc.isTypeIdenticalTo(sourceExtends, (target /* as ConditionalType */).extendsType) && (isRelatedTo((source /* as ConditionalType */).checkType, (target /* as ConditionalType */).checkType, RecursionFlagsBoth) || isRelatedTo((target /* as ConditionalType */).checkType, (source /* as ConditionalType */).checkType, RecursionFlagsBoth)) {
					if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors) */ TODO {
						result &= isRelatedTo(tc.getFalseTypeFromConditionalType(source /* as ConditionalType */), tc.getFalseTypeFromConditionalType(target /* as ConditionalType */), RecursionFlagsBoth, reportErrors)
					}
					if result {
						return result
					}
				}
			}
			// conditionals can be related to one another via normal constraint, as, eg, `A extends B ? O : never` should be assignable to `O`
			// when `O` is a conditional (`never` is trivially assignable to `O`, as is `O`!).
			defaultConstraint := tc.getDefaultConstraintOfConditionalType(source /* as ConditionalType */)
			if defaultConstraint {
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
					return result
				}
			}
			// conditionals aren't related to one another via distributive constraint as it is much too inaccurate and allows way
			// more assignments than are desirable (since it maps the source check type to its constraint, it loses information).
			var distributiveConstraint Type
			if !(targetFlags & TypeFlagsConditional) && tc.hasNonCircularBaseConstraint(source) {
				distributiveConstraint = tc.getConstraintOfDistributiveConditionalType(source /* as ConditionalType */)
			} else {
				distributiveConstraint = nil
			}
			if distributiveConstraint {
				resetErrorInfo(saveErrorInfo)
				if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
					return result
				}
			}
		} else {
			// An empty object type is related to any mapped type that includes a '?' modifier.
			if relation != tc.subtypeRelation && relation != tc.strictSubtypeRelation && tc.isPartialMappedType(target) && tc.isEmptyObjectType(source) {
				return TernaryTrue
			}
			if tc.isGenericMappedType(target) {
				if tc.isGenericMappedType(source) {
					if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = mappedTypeRelatedTo(source, target, reportErrors) */ TODO {
						return result
					}
				}
				return TernaryFalse
			}
			sourceIsPrimitive := !!(sourceFlags & TypeFlagsPrimitive)
			if relation != tc.identityRelation {
				source = tc.getApparentType(source)
				sourceFlags = source.flags
			} else if tc.isGenericMappedType(source) {
				return TernaryFalse
			}
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && (source /* as TypeReference */).target == (target /* as TypeReference */).target && !tc.isTupleType(source) && !(tc.isMarkerType(source) || tc.isMarkerType(target)) {
				// When strictNullChecks is disabled, the element type of the empty array literal is undefinedWideningType,
				// and an empty array literal wouldn't be assignable to a `never[]` without this check.
				if tc.isEmptyArrayLiteralType(source) {
					return TernaryTrue
				}
				// We have type references to the same generic type, and the type references are not marker
				// type references (which are intended by be compared structurally). Obtain the variance
				// information for the type parameters and relate the type arguments accordingly.
				variances := tc.getVariances((source /* as TypeReference */).target)
				// We return Ternary.Maybe for a recursive invocation of getVariances (signalled by emptyArray). This
				// effectively means we measure variance only from type parameter occurrences that aren't nested in
				// recursive instantiations of the generic type.
				if variances == emptyArray {
					return TernaryUnknown
				}
				varianceResult := relateVariances(tc.getTypeArguments(source /* as TypeReference */), tc.getTypeArguments(target /* as TypeReference */), variances, intersectionState)
				if varianceResult != nil {
					return varianceResult
				}
			} else if __COND__(tc.isReadonlyArrayType(target), tc.everyType(source, tc.isArrayOrTupleType), tc.isArrayType(target) && tc.everyType(source, func(t Type) bool {
				return tc.isTupleType(t) && !t.target.readonly
			})) {
				if relation != tc.identityRelation {
					return isRelatedTo(tc.getIndexTypeOfType(source, tc.numberType) || tc.anyType, tc.getIndexTypeOfType(target, tc.numberType) || tc.anyType, RecursionFlagsBoth, reportErrors)
				} else {
					// By flags alone, we know that the `target` is a readonly array while the source is a normal array or tuple
					// or `target` is an array and source is a tuple - in both cases the types cannot be identical, by construction
					return TernaryFalse
				}
			} else if tc.isGenericTupleType(source) && tc.isTupleType(target) && !tc.isGenericTupleType(target) {
				constraint := tc.getBaseConstraintOrType(source)
				if constraint != source {
					return isRelatedTo(constraint, target, RecursionFlagsSource, reportErrors)
				}
			} else if (relation == tc.subtypeRelation || relation == tc.strictSubtypeRelation) && tc.isEmptyObjectType(target) && getObjectFlags(target)&ObjectFlagsFreshLiteral && !tc.isEmptyObjectType(source) {
				return TernaryFalse
			}
			// Even if relationship doesn't hold for unions, intersections, or generic type references,
			// it may hold in a structural comparison.
			// In a check of the form X = A & B, we will have previously checked if A relates to X or B relates
			// to X. Failing both of those we want to check if the aggregation of A and B's members structurally
			// relates to X. Thus, we include intersection types on the source side here.
			if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsObject {
				// Report structural errors only if we haven't reported any errors yet
				reportStructuralErrors := reportErrors && errorInfo == saveErrorInfo.errorInfo && !sourceIsPrimitive
				result = propertiesRelatedTo(source, target, reportStructuralErrors /*excludedProperties*/, nil /*optionalsOnly*/, false, intersectionState)
				if result {
					result &= signaturesRelatedTo(source, target, SignatureKindCall, reportStructuralErrors, intersectionState)
					if result {
						result &= signaturesRelatedTo(source, target, SignatureKindConstruct, reportStructuralErrors, intersectionState)
						if result {
							result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState)
						}
					}
				}
				if varianceCheckFailed && result {
					errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo
					// Use variance error (there is no structural one) and return false
				} else if result {
					return result
				}
			}
			// If S is an object type and T is a discriminated union, S may be related to T if
			// there exists a constituent of T for every combination of the discriminants of S
			// with respect to T. We do not report errors here, as we will use the existing
			// error result from checking each constituent of the union.
			if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsUnion {
				objectOnlyTarget := tc.extractTypesOfKind(target, TypeFlagsObject|TypeFlagsIntersection|TypeFlagsSubstitution)
				if objectOnlyTarget.flags & TypeFlagsUnion {
					result := typeRelatedToDiscriminatedType(source, objectOnlyTarget /* as UnionType */)
					if result {
						return result
					}
				}
			}
		}
		return TernaryFalse

		countMessageChainBreadth := func(info *[]DiagnosticMessageChain) number {
			if !info {
				return 0
			}
			return reduceLeft(info, func(value number, chain DiagnosticMessageChain) number {
				return value + 1 + countMessageChainBreadth(chain.next)
			}, 0)
		}

		relateVariances := func(sourceTypeArguments *[]Type, targetTypeArguments *[]Type, variances []VarianceFlags, intersectionState IntersectionState) *Ternary {
			if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState) */ TODO {
				return result
			}
			if some(variances, func(v VarianceFlags) bool {
				return !!(v & VarianceFlagsAllowsStructuralFallback)
			}) {
				// If some type parameter was `Unmeasurable` or `Unreliable`, and we couldn't pass by assuming it was identical, then we
				// have to allow a structural fallback check
				// We elide the variance-based error elaborations, since those might not be too helpful, since we'll potentially
				// be assuming identity of the type parameter.
				originalErrorInfo = nil
				resetErrorInfo(saveErrorInfo)
				return nil
			}
			allowStructuralFallback := targetTypeArguments && tc.hasCovariantVoidArgument(targetTypeArguments, variances)
			varianceCheckFailed = !allowStructuralFallback
			// The type arguments did not relate appropriately, but it may be because we have no variance
			// information (in which case typeArgumentsRelatedTo defaulted to covariance for all type
			// arguments). It might also be the case that the target type has a 'void' type argument for
			// a covariant type parameter that is only used in return positions within the generic type
			// (in which case any type argument is permitted on the source side). In those cases we proceed
			// with a structural comparison. Otherwise, we know for certain the instantiations aren't
			// related and we can return here.
			if variances != emptyArray && !allowStructuralFallback {
				// In some cases generic types that are covariant in regular type checking mode become
				// invariant in --strictFunctionTypes mode because one or more type parameters are used in
				// both co- and contravariant positions. In order to make it easier to diagnose *why* such
				// types are invariant, if any of the type parameters are invariant we reset the reported
				// errors and instead force a structural comparison (which will include elaborations that
				// reveal the reason).
				// We can switch on `reportErrors` here, since varianceCheckFailed guarantees we return `False`,
				// we can return `False` early here to skip calculating the structural error message we don't need.
				if varianceCheckFailed && !(reportErrors && some(variances, func(v VarianceFlags) bool {
					return (v & VarianceFlagsVarianceMask) == VarianceFlagsInvariant
				})) {
					return TernaryFalse
				}
				// We remember the original error information so we can restore it in case the structural
				// comparison unexpectedly succeeds. This can happen when the structural comparison result
				// is a Ternary.Maybe for example caused by the recursion depth limiter.
				originalErrorInfo = errorInfo
				resetErrorInfo(saveErrorInfo)
			}
		}

	}

	// A type [P in S]: X is related to a type [Q in T]: Y if T is related to S and X' is
	// related to Y, where X' is an instantiation of X in which P is replaced with Q. Notice
	// that S and T are contra-variant whereas X and Y are co-variant.
	mappedTypeRelatedTo := func(source MappedType, target MappedType, reportErrors bool) Ternary {
		modifiersRelated := relation == tc.comparableRelation || (__COND__(relation == tc.identityRelation, tc.getMappedTypeModifiers(source) == tc.getMappedTypeModifiers(target), tc.getCombinedMappedTypeOptionality(source) <= tc.getCombinedMappedTypeOptionality(target)))
		if modifiersRelated {
			var result Ternary
			targetConstraint := tc.getConstraintTypeFromMappedType(target)
			sourceConstraint := tc.instantiateType(tc.getConstraintTypeFromMappedType(source), __COND__(tc.getCombinedMappedTypeOptionality(source) < 0, tc.reportUnmeasurableMapper, tc.reportUnreliableMapper))
			if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors) */ TODO {
				mapper := tc.createTypeMapper([]TypeParameter{tc.getTypeParameterFromMappedType(source)}, []TypeParameter{tc.getTypeParameterFromMappedType(target)})
				if tc.instantiateType(tc.getNameTypeFromMappedType(source), mapper) == tc.instantiateType(tc.getNameTypeFromMappedType(target), mapper) {
					return result & isRelatedTo(tc.instantiateType(tc.getTemplateTypeFromMappedType(source), mapper), tc.getTemplateTypeFromMappedType(target), RecursionFlagsBoth, reportErrors)
				}
			}
		}
		return TernaryFalse
	}

	typeRelatedToDiscriminatedType := func(source Type, target UnionType) Ternary {
		// 1. Generate the combinations of discriminant properties & types 'source' can satisfy.
		//    a. If the number of combinations is above a set limit, the comparison is too complex.
		// 2. Filter 'target' to the subset of types whose discriminants exist in the matrix.
		//    a. If 'target' does not satisfy all discriminants in the matrix, 'source' is not related.
		// 3. For each type in the filtered 'target', determine if all non-discriminant properties of
		//    'target' are related to a property in 'source'.
		//
		// NOTE: See ~/tests/cases/conformance/types/typeRelationships/assignmentCompatibility/assignmentCompatWithDiscriminatedUnion.ts
		//       for examples.

		sourceProperties := tc.getPropertiesOfType(source)
		sourcePropertiesFiltered := tc.findDiscriminantProperties(sourceProperties, target)
		if !sourcePropertiesFiltered {
			return TernaryFalse
		}

		// Though we could compute the number of combinations as we generate
		// the matrix, this would incur additional memory overhead due to
		// array allocations. To reduce this overhead, we first compute
		// the number of combinations to ensure we will not surpass our
		// fixed limit before incurring the cost of any allocations:
		numCombinations := 1
		for _, sourceProperty := range sourcePropertiesFiltered {
			numCombinations *= tc.countTypes(tc.getNonMissingTypeOfSymbol(sourceProperty))
			if numCombinations > 25 {
				// We've reached the complexity limit.
				tracing. /* ? */ instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"sourceId":        source.id,
					"targetId":        target.id,
					"numCombinations": numCombinations,
				})
				return TernaryFalse
			}
		}

		// Compute the set of types for each discriminant property.
		var sourceDiscriminantTypes [][]Type = NewArray[[]Type](sourcePropertiesFiltered.length)
		excludedProperties := NewSet[__String]()
		for i := 0; i < sourcePropertiesFiltered.length; i++ {
			sourceProperty := sourcePropertiesFiltered[i]
			sourcePropertyType := tc.getNonMissingTypeOfSymbol(sourceProperty)
			if sourcePropertyType.flags & TypeFlagsUnion {
				sourceDiscriminantTypes[i] = (sourcePropertyType /* as UnionType */).types
			} else {
				sourceDiscriminantTypes[i] = []Type{sourcePropertyType}
			}
			excludedProperties.add(sourceProperty.escapedName)
		}

		// Match each combination of the cartesian product of discriminant properties to one or more
		// constituents of 'target'. If any combination does not have a match then 'source' is not relatable.
		discriminantCombinations := cartesianProduct(sourceDiscriminantTypes)
		var matchingTypes []Type = []never{}
		for _, combination := range discriminantCombinations {
			hasMatch := false
		outer:
			for _, type_ := range target.types {
				for i := 0; i < sourcePropertiesFiltered.length; i++ {
					sourceProperty := sourcePropertiesFiltered[i]
					targetProperty := tc.getPropertyOfType(type_, sourceProperty.escapedName)
					if !targetProperty {
						continue outer
					}
					if sourceProperty == targetProperty {
						continue
					}
					// We compare the source property to the target in the context of a single discriminant type.
					related := propertyRelatedTo(source, target, sourceProperty, targetProperty, func(_ Symbol) Type {
						return combination[i]
					}, /*reportErrors*/ false, IntersectionStateNone /*skipOptional*/, tc.strictNullChecks || relation == tc.comparableRelation)
					// If the target property could not be found, or if the properties were not related,
					// then this constituent is not a match.
					if !related {
						continue outer
					}
				}
				pushIfUnique(matchingTypes, type_, equateValues)
				hasMatch = true
			}
			if !hasMatch {
				// We failed to match any type for this combination.
				return TernaryFalse
			}
		}

		// Compare the remaining non-discriminant properties of each match.
		result := TernaryTrue
		for _, type_ := range matchingTypes {
			result &= propertiesRelatedTo(source, type_ /*reportErrors*/, false, excludedProperties /*optionalsOnly*/, false, IntersectionStateNone)
			if result {
				result &= signaturesRelatedTo(source, type_, SignatureKindCall /*reportErrors*/, false, IntersectionStateNone)
				if result {
					result &= signaturesRelatedTo(source, type_, SignatureKindConstruct /*reportErrors*/, false, IntersectionStateNone)
					if result && !(tc.isTupleType(source) && tc.isTupleType(type_)) {
						// Comparing numeric index types when both `source` and `type` are tuples is unnecessary as the
						// element types should be sufficiently covered by `propertiesRelatedTo`. It also causes problems
						// with index type assignability as the types for the excluded discriminants are still included
						// in the index type.
						result &= indexSignaturesRelatedTo(source, type_ /*sourceIsPrimitive*/, false /*reportErrors*/, false, IntersectionStateNone)
					}
				}
			}
			if !result {
				return result
			}
		}
		return result
	}

	excludeProperties := func(properties []Symbol, excludedProperties *Set[__String]) []Symbol {
		if !excludedProperties || properties.length == 0 {
			return properties
		}
		var result *[]Symbol
		for i := 0; i < properties.length; i++ {
			if !excludedProperties.has(properties[i].escapedName) {
				if result {
					result.push(properties[i])
				}
			} else if !result {
				result = properties.slice(0, i)
			}
		}
		return result || properties
	}

	isPropertySymbolTypeRelated := func(sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState) Ternary {
		targetIsOptional := tc.strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlagsPartial)
		effectiveTarget := tc.addOptionality(tc.getNonMissingTypeOfSymbol(targetProp) /*isProperty*/, false, targetIsOptional)
		effectiveSource := getTypeOfSourceProperty(sourceProp)
		return isRelatedTo(effectiveSource, effectiveTarget, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
	}

	propertyRelatedTo := func(source Type, target Type, sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState, skipOptional bool) Ternary {
		sourcePropFlags := getDeclarationModifierFlagsFromSymbol(sourceProp)
		targetPropFlags := getDeclarationModifierFlagsFromSymbol(targetProp)
		if sourcePropFlags&ModifierFlagsPrivate || targetPropFlags&ModifierFlagsPrivate {
			if sourceProp.valueDeclaration != targetProp.valueDeclaration {
				if reportErrors {
					if sourcePropFlags&ModifierFlagsPrivate && targetPropFlags&ModifierFlagsPrivate {
						reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, tc.symbolToString(targetProp))
					} else {
						reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, tc.symbolToString(targetProp), tc.typeToString(__COND__(sourcePropFlags&ModifierFlagsPrivate, source, target)), tc.typeToString(__COND__(sourcePropFlags&ModifierFlagsPrivate, target, source)))
					}
				}
				return TernaryFalse
			}
		} else if targetPropFlags & ModifierFlagsProtected {
			if !tc.isValidOverrideOf(sourceProp, targetProp) {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, tc.symbolToString(targetProp), tc.typeToString(tc.getDeclaringClass(sourceProp) || source), tc.typeToString(tc.getDeclaringClass(targetProp) || target))
				}
				return TernaryFalse
			}
		} else if sourcePropFlags & ModifierFlagsProtected {
			if reportErrors {
				reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, tc.symbolToString(targetProp), tc.typeToString(source), tc.typeToString(target))
			}
			return TernaryFalse
		}

		// Ensure {readonly a: whatever} is not a subtype of {a: whatever},
		// while {a: whatever} is a subtype of {readonly a: whatever}.
		// This ensures the subtype relationship is ordered, and preventing declaration order
		// from deciding which type "wins" in union subtype reduction.
		// They're still assignable to one another, since `readonly` doesn't affect assignability.
		// This is only applied during the strictSubtypeRelation -- currently used in subtype reduction
		if relation == tc.strictSubtypeRelation && tc.isReadonlySymbol(sourceProp) && !tc.isReadonlySymbol(targetProp) {
			return TernaryFalse
		}
		// If the target comes from a partial union prop, allow `undefined` in the target type
		related := isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState)
		if !related {
			if reportErrors {
				reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, tc.symbolToString(targetProp))
			}
			return TernaryFalse
		}
		// When checking for comparability, be more lenient with optional properties.
		if !skipOptional && sourceProp.flags&SymbolFlagsOptional && targetProp.flags&SymbolFlagsClassMember && !(targetProp.flags & SymbolFlagsOptional) {
			// TypeScript 1.0 spec (April 2014): 3.8.3
			// S is a subtype of a type T, and T is a supertype of S if ...
			// S' and T are object types and, for each member M in T..
			// M is a property and S' contains a property N where
			// if M is a required property, N is also a required property
			// (M - property in T)
			// (N - property in S)
			if reportErrors {
				reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, tc.symbolToString(targetProp), tc.typeToString(source), tc.typeToString(target))
			}
			return TernaryFalse
		}
		return related
	}

	reportUnmatchedProperty := func(source Type, target Type, unmatchedProperty Symbol, requireOptionalProperties bool) {
		shouldSkipElaboration := false
		// give specific error in case where private names have the same description
		if unmatchedProperty.valueDeclaration && isNamedDeclaration(unmatchedProperty.valueDeclaration) && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name) && source.symbol && source.symbol.flags&SymbolFlagsClass {
			privateIdentifierDescription := unmatchedProperty.valueDeclaration.name.escapedText
			symbolTableKey := getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription)
			if symbolTableKey && tc.getPropertyOfType(source, symbolTableKey) {
				sourceName := factory.getDeclarationName(source.symbol.valueDeclaration)
				targetName := factory.getDeclarationName(target.symbol.valueDeclaration)
				reportError(Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2, tc.diagnosticName(privateIdentifierDescription), tc.diagnosticName(__COND__(sourceName.escapedText == "", anon, sourceName)), tc.diagnosticName(__COND__(targetName.escapedText == "", anon, targetName)))
				return
			}
		}
		props := arrayFrom(tc.getUnmatchedProperties(source, target, requireOptionalProperties /*matchDiscriminantProperties*/, false))
		if !headMessage || (headMessage.code != Diagnostics.Class_0_incorrectly_implements_interface_1.code && headMessage.code != Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code) {
			shouldSkipElaboration = true
			// Retain top-level error for interface implementing issues, otherwise omit it
		}
		if props.length == 1 {
			propName := tc.symbolToString(unmatchedProperty /*enclosingDeclaration*/, nil, SymbolFlagsNone, SymbolFormatFlagsAllowAnyNodeKind|SymbolFormatFlagsWriteComputedProps)
			reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName, tc.getTypeNamesForErrorDisplay(source, target)...)
			if length(unmatchedProperty.declarations) {
				associateRelatedInfo(createDiagnosticForNode(unmatchedProperty.declarations[0], Diagnostics._0_is_declared_here, propName))
			}
			if shouldSkipElaboration && errorInfo {
				overrideNextErrorInfo++
			}
		} else if tryElaborateArrayLikeErrors(source, target /*reportErrors*/, false) {
			if props.length > 5 {
				reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, tc.typeToString(source), tc.typeToString(target), map_(props.slice(0, 4), func(p Symbol) string {
					return tc.symbolToString(p)
				}).join(", "), props.length-4)
			} else {
				reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, tc.typeToString(source), tc.typeToString(target), map_(props, func(p Symbol) string {
					return tc.symbolToString(p)
				}).join(", "))
			}
			if shouldSkipElaboration && errorInfo {
				overrideNextErrorInfo++
			}
		}
		// No array like or unmatched property error - just issue top level error (errorInfo = undefined)
	}

	propertiesRelatedTo := func(source Type, target Type, reportErrors bool, excludedProperties *Set[__String], optionalsOnly bool, intersectionState IntersectionState) Ternary {
		if relation == tc.identityRelation {
			return propertiesIdenticalTo(source, target, excludedProperties)
		}
		result := TernaryTrue
		if tc.isTupleType(target) {
			if tc.isArrayOrTupleType(source) {
				if !target.target.readonly && (tc.isReadonlyArrayType(source) || tc.isTupleType(source) && source.target.readonly) {
					return TernaryFalse
				}
				sourceArity := tc.getTypeReferenceArity(source)
				targetArity := tc.getTypeReferenceArity(target)
				var sourceRestFlag number
				if tc.isTupleType(source) {
					sourceRestFlag = source.target.combinedFlags & ElementFlagsRest
				} else {
					sourceRestFlag = ElementFlagsRest
				}
				targetHasRestElement := !!(target.target.combinedFlags & ElementFlagsVariable)
				var sourceMinLength number
				if tc.isTupleType(source) {
					sourceMinLength = source.target.minLength
				} else {
					sourceMinLength = 0
				}
				targetMinLength := target.target.minLength
				if !sourceRestFlag && sourceArity < targetMinLength {
					if reportErrors {
						reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength)
					}
					return TernaryFalse
				}
				if !targetHasRestElement && targetArity < sourceMinLength {
					if reportErrors {
						reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity)
					}
					return TernaryFalse
				}
				if !targetHasRestElement && (sourceRestFlag || targetArity < sourceArity) {
					if reportErrors {
						if sourceMinLength < targetMinLength {
							reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength)
						} else {
							reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity)
						}
					}
					return TernaryFalse
				}
				sourceTypeArguments := tc.getTypeArguments(source)
				targetTypeArguments := tc.getTypeArguments(target)
				targetStartCount := tc.getStartElementCount(target.target, ElementFlagsNonRest)
				targetEndCount := tc.getEndElementCount(target.target, ElementFlagsNonRest)
				canExcludeDiscriminants := !!excludedProperties
				for sourcePosition := 0; sourcePosition < sourceArity; sourcePosition++ {
					var sourceFlags ElementFlags
					if tc.isTupleType(source) {
						sourceFlags = source.target.elementFlags[sourcePosition]
					} else {
						sourceFlags = ElementFlagsRest
					}
					sourcePositionFromEnd := sourceArity - 1 - sourcePosition

					var targetPosition number
					if targetHasRestElement && sourcePosition >= targetStartCount {
						targetPosition = targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)
					} else {
						targetPosition = sourcePosition
					}

					targetFlags := target.target.elementFlags[targetPosition]

					if targetFlags&ElementFlagsVariadic && !(sourceFlags & ElementFlagsVariadic) {
						if reportErrors {
							reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition)
						}
						return TernaryFalse
					}
					if sourceFlags&ElementFlagsVariadic && !(targetFlags & ElementFlagsVariable) {
						if reportErrors {
							reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition)
						}
						return TernaryFalse
					}
					if targetFlags&ElementFlagsRequired && !(sourceFlags & ElementFlagsRequired) {
						if reportErrors {
							reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition)
						}
						return TernaryFalse
					}
					// We can only exclude discriminant properties if we have not yet encountered a variable-length element.
					if canExcludeDiscriminants {
						if sourceFlags&ElementFlagsVariable || targetFlags&ElementFlagsVariable {
							canExcludeDiscriminants = false
						}
						if canExcludeDiscriminants && excludedProperties. /* ? */ has(("" + sourcePosition) /* as __String */) {
							continue
						}
					}

					sourceType := tc.removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlagsOptional))
					targetType := targetTypeArguments[targetPosition]

					var targetCheckType Type
					if sourceFlags&ElementFlagsVariadic && targetFlags&ElementFlagsRest {
						targetCheckType = tc.createArrayType(targetType)
					} else {
						targetCheckType = tc.removeMissingType(targetType, !!(targetFlags & ElementFlagsOptional))
					}
					related := isRelatedTo(sourceType, targetCheckType, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
					if !related {
						if reportErrors && (targetArity > 1 || sourceArity > 1) {
							if targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount != sourceArity-targetEndCount-1 {
								reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity-targetEndCount-1, targetPosition)
							} else {
								reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition)
							}
						}
						return TernaryFalse
					}
					result &= related
				}
				return result
			}
			if target.target.combinedFlags & ElementFlagsVariable {
				return TernaryFalse
			}
		}
		requireOptionalProperties := (relation == tc.subtypeRelation || relation == tc.strictSubtypeRelation) && !tc.isObjectLiteralType(source) && !tc.isEmptyArrayLiteralType(source) && !tc.isTupleType(source)
		unmatchedProperty := tc.getUnmatchedProperty(source, target, requireOptionalProperties /*matchDiscriminantProperties*/, false)
		if unmatchedProperty {
			if reportErrors && shouldReportUnmatchedPropertyError(source, target) {
				reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties)
			}
			return TernaryFalse
		}
		if tc.isObjectLiteralType(target) {
			for _, sourceProp := range excludeProperties(tc.getPropertiesOfType(source), excludedProperties) {
				if !tc.getPropertyOfObjectType(target, sourceProp.escapedName) {
					sourceType := tc.getTypeOfSymbol(sourceProp)
					if !(sourceType.flags & TypeFlagsUndefined) {
						if reportErrors {
							reportError(Diagnostics.Property_0_does_not_exist_on_type_1, tc.symbolToString(sourceProp), tc.typeToString(target))
						}
						return TernaryFalse
					}
				}
			}
		}
		// We only call this for union target types when we're attempting to do excess property checking - in those cases, we want to get _all possible props_
		// from the target union, across all members
		properties := tc.getPropertiesOfType(target)
		numericNamesOnly := tc.isTupleType(source) && tc.isTupleType(target)
		for _, targetProp := range excludeProperties(properties, excludedProperties) {
			name := targetProp.escapedName
			if !(targetProp.flags & SymbolFlagsPrototype) && (!numericNamesOnly || isNumericLiteralName(name) || name == "length") && (!optionalsOnly || targetProp.flags&SymbolFlagsOptional) {
				sourceProp := tc.getPropertyOfType(source, name)
				if sourceProp && sourceProp != targetProp {
					related := propertyRelatedTo(source, target, sourceProp, targetProp, tc.getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation == tc.comparableRelation)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
		}
		return result
	}

	propertiesIdenticalTo := func(source Type, target Type, excludedProperties *Set[__String]) Ternary {
		if !(source.flags&TypeFlagsObject && target.flags&TypeFlagsObject) {
			return TernaryFalse
		}
		sourceProperties := excludeProperties(tc.getPropertiesOfObjectType(source), excludedProperties)
		targetProperties := excludeProperties(tc.getPropertiesOfObjectType(target), excludedProperties)
		if sourceProperties.length != targetProperties.length {
			return TernaryFalse
		}
		result := TernaryTrue
		for _, sourceProp := range sourceProperties {
			targetProp := tc.getPropertyOfObjectType(target, sourceProp.escapedName)
			if !targetProp {
				return TernaryFalse
			}
			related := tc.compareProperties(sourceProp, targetProp, isRelatedTo)
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		return result
	}

	signaturesRelatedTo := func(source Type, target Type, kind SignatureKind, reportErrors bool, intersectionState IntersectionState) Ternary {
		if relation == tc.identityRelation {
			return signaturesIdenticalTo(source, target, kind)
		}
		if target == tc.anyFunctionType || source == tc.anyFunctionType {
			return TernaryTrue
		}

		sourceIsJSConstructor := source.symbol && tc.isJSConstructor(source.symbol.valueDeclaration)
		targetIsJSConstructor := target.symbol && tc.isJSConstructor(target.symbol.valueDeclaration)

		sourceSignatures := tc.getSignaturesOfType(source, __COND__((sourceIsJSConstructor && kind == SignatureKindConstruct), SignatureKindCall, kind))
		targetSignatures := tc.getSignaturesOfType(target, __COND__((targetIsJSConstructor && kind == SignatureKindConstruct), SignatureKindCall, kind))

		if kind == SignatureKindConstruct && sourceSignatures.length && targetSignatures.length {
			sourceIsAbstract := !!(sourceSignatures[0].flags & SignatureFlagsAbstract)
			targetIsAbstract := !!(targetSignatures[0].flags & SignatureFlagsAbstract)
			if sourceIsAbstract && !targetIsAbstract {
				// An abstract constructor type is not assignable to a non-abstract constructor type
				// as it would otherwise be possible to new an abstract class. Note that the assignability
				// check we perform for an extends clause excludes construct signatures from the target,
				// so this check never proceeds.
				if reportErrors {
					reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type)
				}
				return TernaryFalse
			}
			if !constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors) {
				return TernaryFalse
			}
		}

		result := TernaryTrue
		var incompatibleReporter /* TODO(TS-TO-GO) inferred type (siga: Signature, sigb: Signature) => (source: Type, target: Type) => void */ any
		if kind == SignatureKindConstruct {
			incompatibleReporter = reportIncompatibleConstructSignatureReturn
		} else {
			incompatibleReporter = reportIncompatibleCallSignatureReturn
		}
		sourceObjectFlags := getObjectFlags(source)
		targetObjectFlags := getObjectFlags(target)
		if sourceObjectFlags&ObjectFlagsInstantiated && targetObjectFlags&ObjectFlagsInstantiated && source.symbol == target.symbol || sourceObjectFlags&ObjectFlagsReference && targetObjectFlags&ObjectFlagsReference && (source /* as TypeReference */).target == (target /* as TypeReference */).target {
			// We have instantiations of the same anonymous type (which typically will be the type of a
			// method). Simply do a pairwise comparison of the signatures in the two signature lists instead
			// of the much more expensive N * M comparison matrix we explore below. We erase type parameters
			// as they are known to always be the same.
			Debug.assertEqual(sourceSignatures.length, targetSignatures.length)
			for i := 0; i < targetSignatures.length; i++ {
				related := signatureRelatedTo(sourceSignatures[i], targetSignatures[i] /*erase*/, true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]))
				if !related {
					return TernaryFalse
				}
				result &= related
			}
		} else if sourceSignatures.length == 1 && targetSignatures.length == 1 {
			// For simple functions (functions with a single signature) we only erase type parameters for
			// the comparable relation. Otherwise, if the source signature is generic, we instantiate it
			// in the context of the target signature before checking the relationship. Ideally we'd do
			// this regardless of the number of signatures, but the potential costs are prohibitive due
			// to the quadratic nature of the logic below.
			eraseGenerics := relation == tc.comparableRelation
			sourceSignature := first(sourceSignatures)
			targetSignature := first(targetSignatures)
			result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature))
			if !result && reportErrors && kind == SignatureKindConstruct && (sourceObjectFlags & targetObjectFlags) && (targetSignature.declaration. /* ? */ kind == SyntaxKindConstructor || sourceSignature.declaration. /* ? */ kind == SyntaxKindConstructor) {
				constructSignatureToString := func(signature Signature) string {
					return tc.signatureToString(signature /*enclosingDeclaration*/, nil, TypeFormatFlagsWriteArrowStyleSignature, kind)
				}
				reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature))
				reportError(Diagnostics.Types_of_construct_signatures_are_incompatible)
				return result
			}
		} else {
		outer:
			for _, t := range targetSignatures {
				saveErrorInfo := captureErrorCalculationState()
				// Only elaborate errors from the first failure
				shouldElaborateErrors := reportErrors
				for _, s := range sourceSignatures {
					related := signatureRelatedTo(s, t /*erase*/, true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t))
					if related {
						result &= related
						resetErrorInfo(saveErrorInfo)
						continue outer
					}
					shouldElaborateErrors = false
				}
				if shouldElaborateErrors {
					reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, tc.typeToString(source), tc.signatureToString(t /*enclosingDeclaration*/, nil /*flags*/, nil, kind))
				}
				return TernaryFalse
			}
		}
		return result
	}

	shouldReportUnmatchedPropertyError := func(source Type, target Type) bool {
		typeCallSignatures := tc.getSignaturesOfStructuredType(source, SignatureKindCall)
		typeConstructSignatures := tc.getSignaturesOfStructuredType(source, SignatureKindConstruct)
		typeProperties := tc.getPropertiesOfObjectType(source)
		if (typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length {
			if (tc.getSignaturesOfType(target, SignatureKindCall).length && typeCallSignatures.length) || (tc.getSignaturesOfType(target, SignatureKindConstruct).length && typeConstructSignatures.length) {
				return true
				// target has similar signature kinds to source, still focus on the unmatched property
			}
			return false
		}
		return true
	}

	reportIncompatibleCallSignatureReturn := func(siga Signature, sigb Signature) /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => void */ any {
		if siga.parameters.length == 0 && sigb.parameters.length == 0 {
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, tc.typeToString(source), tc.typeToString(target))
			}
		}
		return func(source Type, target Type) {
			return reportIncompatibleError(Diagnostics.Call_signature_return_types_0_and_1_are_incompatible, tc.typeToString(source), tc.typeToString(target))
		}
	}

	reportIncompatibleConstructSignatureReturn := func(siga Signature, sigb Signature) /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => void */ any {
		if siga.parameters.length == 0 && sigb.parameters.length == 0 {
			return func(source Type, target Type) {
				return reportIncompatibleError(Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1, tc.typeToString(source), tc.typeToString(target))
			}
		}
		return func(source Type, target Type) {
			return reportIncompatibleError(Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible, tc.typeToString(source), tc.typeToString(target))
		}
	}

	/**
	 * See signatureAssignableTo, compareSignaturesIdentical
	 */

	signatureRelatedTo := func(source Signature, target Signature, erase bool, reportErrors bool, intersectionState IntersectionState, incompatibleReporter func(source Type, target Type)) Ternary {
		var checkMode number
		switch {
		case relation == tc.subtypeRelation:
			checkMode = SignatureCheckModeStrictTopSignature
		case relation == tc.strictSubtypeRelation:
			checkMode = SignatureCheckModeStrictTopSignature | SignatureCheckModeStrictArity
		default:
			checkMode = SignatureCheckModeNone
		}
		return tc.compareSignaturesRelated(__COND__(erase, tc.getErasedSignature(source), source), __COND__(erase, tc.getErasedSignature(target), target), checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, tc.reportUnreliableMapper)
		isRelatedToWorker := func(source Type, target Type, reportErrors bool) Ternary {
			return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
		}

	}

	signaturesIdenticalTo := func(source Type, target Type, kind SignatureKind) Ternary {
		sourceSignatures := tc.getSignaturesOfType(source, kind)
		targetSignatures := tc.getSignaturesOfType(target, kind)
		if sourceSignatures.length != targetSignatures.length {
			return TernaryFalse
		}
		result := TernaryTrue
		for i := 0; i < sourceSignatures.length; i++ {
			related := tc.compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i] /*partialMatch*/, false /*ignoreThisTypes*/, false /*ignoreReturnTypes*/, false, isRelatedTo)
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		return result
	}

	membersRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
		result := TernaryTrue
		keyType := targetInfo.keyType
		var props []Symbol
		if source.flags & TypeFlagsIntersection {
			props = tc.getPropertiesOfUnionOrIntersectionType(source /* as IntersectionType */)
		} else {
			props = tc.getPropertiesOfObjectType(source)
		}
		for _, prop := range props {
			// Skip over ignored JSX and symbol-named members
			if tc.isIgnoredJsxProperty(source, prop) {
				continue
			}
			if tc.isApplicableIndexType(tc.getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), keyType) {
				propType := tc.getNonMissingTypeOfSymbol(prop)
				var type_ Type
				if tc.exactOptionalPropertyTypes || propType.flags&TypeFlagsUndefined || keyType == tc.numberType || !(prop.flags & SymbolFlagsOptional) {
					type_ = propType
				} else {
					type_ = tc.getTypeWithFacts(propType, TypeFactsNEUndefined)
				}
				related := isRelatedTo(type_, targetInfo.type_, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
				if !related {
					if reportErrors {
						reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, tc.symbolToString(prop))
					}
					return TernaryFalse
				}
				result &= related
			}
		}
		for _, info := range tc.getIndexInfosOfType(source) {
			if tc.isApplicableIndexType(info.keyType, keyType) {
				related := indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
		}
		return result
	}

	indexInfoRelatedTo := func(sourceInfo IndexInfo, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
		related := isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth, reportErrors /*headMessage*/, nil, intersectionState)
		if !related && reportErrors {
			if sourceInfo.keyType == targetInfo.keyType {
				reportError(Diagnostics._0_index_signatures_are_incompatible, tc.typeToString(sourceInfo.keyType))
			} else {
				reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, tc.typeToString(sourceInfo.keyType), tc.typeToString(targetInfo.keyType))
			}
		}
		return related
	}

	indexSignaturesRelatedTo := func(source Type, target Type, sourceIsPrimitive bool, reportErrors bool, intersectionState IntersectionState) Ternary {
		if relation == tc.identityRelation {
			return indexSignaturesIdenticalTo(source, target)
		}
		indexInfos := tc.getIndexInfosOfType(target)
		targetHasStringIndex := some(indexInfos, func(info IndexInfo) bool {
			return info.keyType == tc.stringType
		})
		result := TernaryTrue
		for _, targetInfo := range indexInfos {
			var related Ternary
			switch {
			case relation != tc.strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type_.flags&TypeFlagsAny:
				related = TernaryTrue
			case tc.isGenericMappedType(source) && targetHasStringIndex:
				related = isRelatedTo(tc.getTemplateTypeFromMappedType(source), targetInfo.type_, RecursionFlagsBoth, reportErrors)
			default:
				related = typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
			}
			if !related {
				return TernaryFalse
			}
			result &= related
		}
		return result
	}

	typeRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
		sourceInfo := tc.getApplicableIndexInfo(source, targetInfo.keyType)
		if sourceInfo {
			return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState)
		}
		// Intersection constituents are never considered to have an inferred index signature. Also, in the strict subtype relation,
		// only fresh object literals are considered to have inferred index signatures. This ensures { [x: string]: xxx } <: {} but
		// not vice-versa. Without this rule, those types would be mutual strict subtypes.
		if !(intersectionState & IntersectionStateSource) && (relation != tc.strictSubtypeRelation || getObjectFlags(source)&ObjectFlagsFreshLiteral) && tc.isObjectTypeWithInferableIndex(source) {
			return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
		}
		if reportErrors {
			reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, tc.typeToString(targetInfo.keyType), tc.typeToString(source))
		}
		return TernaryFalse
	}

	indexSignaturesIdenticalTo := func(source Type, target Type) Ternary {
		sourceInfos := tc.getIndexInfosOfType(source)
		targetInfos := tc.getIndexInfosOfType(target)
		if sourceInfos.length != targetInfos.length {
			return TernaryFalse
		}
		for _, targetInfo := range targetInfos {
			sourceInfo := tc.getIndexInfoOfType(source, targetInfo.keyType)
			if !(sourceInfo && isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth) && sourceInfo.isReadonly == targetInfo.isReadonly) {
				return TernaryFalse
			}
		}
		return TernaryTrue
	}

	constructorVisibilitiesAreCompatible := func(sourceSignature Signature, targetSignature Signature, reportErrors bool) bool {
		if !sourceSignature.declaration || !targetSignature.declaration {
			return true
		}

		sourceAccessibility := getSelectedEffectiveModifierFlags(sourceSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
		targetAccessibility := getSelectedEffectiveModifierFlags(targetSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)

		// A public, protected and private signature is assignable to a private signature.
		if targetAccessibility == ModifierFlagsPrivate {
			return true
		}

		// A public and protected signature is assignable to a protected signature.
		if targetAccessibility == ModifierFlagsProtected && sourceAccessibility != ModifierFlagsPrivate {
			return true
		}

		// Only a public signature is assignable to public signature.
		if targetAccessibility != ModifierFlagsProtected && !sourceAccessibility {
			return true
		}

		if reportErrors {
			reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, tc.visibilityToString(sourceAccessibility), tc.visibilityToString(targetAccessibility))
		}

		return false
	}

}

func (tc *TypeChecker) typeCouldHaveTopLevelSingletonTypes(type_ Type) bool {
	// Okay, yes, 'boolean' is a union of 'true | false', but that's not useful
	// in error reporting scenarios. If you need to use this function but that detail matters,
	// feel free to add a flag.
	if type_.flags & TypeFlagsBoolean {
		return false
	}

	if type_.flags & TypeFlagsUnionOrIntersection {
		return !!forEach((type_ /* as IntersectionType */).types, tc.typeCouldHaveTopLevelSingletonTypes)
	}

	if type_.flags & TypeFlagsInstantiable {
		constraint := tc.getConstraintOfType(type_)
		if constraint && constraint != type_ {
			return tc.typeCouldHaveTopLevelSingletonTypes(constraint)
		}
	}

	return tc.isUnitType(type_) || !!(type_.flags & TypeFlagsTemplateLiteral) || !!(type_.flags & TypeFlagsStringMapping)
}

func (tc *TypeChecker) getExactOptionalUnassignableProperties(source Type, target Type) []Symbol {
	if tc.isTupleType(source) && tc.isTupleType(target) {
		return emptyArray
	}
	return tc.getPropertiesOfType(target).filter(func(targetProp Symbol) bool {
		return tc.isExactOptionalPropertyMismatch(tc.getTypeOfPropertyOfType(source, targetProp.escapedName), tc.getTypeOfSymbol(targetProp))
	})
}

func (tc *TypeChecker) isExactOptionalPropertyMismatch(source Type, target Type) bool {
	return !!source && !!target && tc.maybeTypeOfKind(source, TypeFlagsUndefined) && !!tc.containsMissingType(target)
}

func (tc *TypeChecker) getExactOptionalProperties(type_ Type) []Symbol {
	return tc.getPropertiesOfType(type_).filter(func(targetProp Symbol) bool {
		return tc.containsMissingType(tc.getTypeOfSymbol(targetProp))
	})
}

func (tc *TypeChecker) getBestMatchingType(source Type, target UnionOrIntersectionType, isRelatedTo /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => Ternary */ any /*  = compareTypesAssignable */) Type {
	return tc.findMatchingDiscriminantType(source, target, isRelatedTo) || tc.findMatchingTypeReferenceOrTypeAliasReference(source, target) || tc.findBestTypeForObjectLiteral(source, target) || tc.findBestTypeForInvokable(source, target) || tc.findMostOverlappyType(source, target)
}

func (tc *TypeChecker) discriminateTypeByDiscriminableItems(target UnionType, discriminators [] /* TODO(TS-TO-GO) TypeNode TupleType: [() => Type, __String] */ any, related func(source Type, target Type) /* TODO(TS-TO-GO) TypeNode UnionType: boolean | Ternary */ any) Type {
	types := target.types
	var include []Ternary = types.map_(func(t Type) /* TODO(TS-TO-GO) inferred type Ternary.False | Ternary.True */ any {
		if t.flags & TypeFlagsPrimitive {
			return TernaryFalse
		} else {
			return TernaryTrue
		}
	})
	for _, TODO_IDENTIFIER := range discriminators {
		// If the remaining target types include at least one with a matching discriminant, eliminate those that
		// have non-matching discriminants. This ensures that we ignore erroneous discriminators and gradually
		// refine the target set without eliminating every constituent (which would lead to `never`).
		matched := false
		for i := 0; i < types.length; i++ {
			if include[i] {
				targetType := tc.getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName)
				if targetType && tc.someType(getDiscriminatingType(), func(t Type) bool {
					return !!related(t, targetType)
				}) {
					matched = true
				} else {
					include[i] = TernaryMaybe
				}
			}
		}
		// Turn each Ternary.Maybe into Ternary.False if there was a match. Otherwise, revert to Ternary.True.
		for i := 0; i < types.length; i++ {
			if include[i] == TernaryMaybe {
				if matched {
					include[i] = TernaryFalse
				} else {
					include[i] = TernaryTrue
				}
			}
		}
	}
	var filtered Type
	if contains(include, TernaryFalse) {
		filtered = tc.getUnionType(types.filter(func(_ Type, i number) Ternary {
			return include[i]
		}), UnionReductionNone)
	} else {
		filtered = target
	}
	if filtered.flags & TypeFlagsNever {
		return target
	} else {
		return filtered
	}
}

/**
 * A type is 'weak' if it is an object type with at least one optional property
 * and no required properties, call/construct signatures or index signatures
 */

func (tc *TypeChecker) isWeakType(type_ Type) bool {
	if type_.flags & TypeFlagsObject {
		resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		return resolved.callSignatures.length == 0 && resolved.constructSignatures.length == 0 && resolved.indexInfos.length == 0 && resolved.properties.length > 0 && every(resolved.properties, func(p Symbol) bool {
			return !!(p.flags & SymbolFlagsOptional)
		})
	}
	if type_.flags & TypeFlagsSubstitution {
		return tc.isWeakType((type_ /* as SubstitutionType */).baseType)
	}
	if type_.flags & TypeFlagsIntersection {
		return every((type_ /* as IntersectionType */).types, tc.isWeakType)
	}
	return false
}

func (tc *TypeChecker) hasCommonProperties(source Type, target Type, isComparingJsxAttributes bool) bool {
	for _, prop := range tc.getPropertiesOfType(source) {
		if tc.isKnownProperty(target, prop.escapedName, isComparingJsxAttributes) {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) getVariances(type_ GenericType) []VarianceFlags {
	// Arrays and tuples are known to be covariant, no need to spend time computing this.
	if type_ == tc.globalArrayType || type_ == tc.globalReadonlyArrayType || type_.objectFlags&ObjectFlagsTuple {
		return tc.arrayVariances
	} else {
		return tc.getVariancesWorker(type_.symbol, type_.typeParameters)
	}
}

func (tc *TypeChecker) getAliasVariances(symbol Symbol) []VarianceFlags {
	return tc.getVariancesWorker(symbol, tc.getSymbolLinks(symbol).typeParameters)
}

// Return an array containing the variance of each type parameter. The variance is effectively
// a digest of the type comparisons that occur for each type argument when instantiations of the
// generic type are structurally compared. We infer the variance information by comparing
// instantiations of the generic type for type arguments with known relations. The function
// returns the emptyArray singleton when invoked recursively for the given generic type.
func (tc *TypeChecker) getVariancesWorker(symbol Symbol, typeParameters []TypeParameter /*  = emptyArray */) []VarianceFlags {
	links := tc.getSymbolLinks(symbol)
	if !links.variances {
		tracing. /* ? */ push(tracing.Phase.CheckTypes, "getVariancesWorker", map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"arity": typeParameters.length,
			"id":    tc.getTypeId(tc.getDeclaredTypeOfSymbol(symbol)),
		})
		oldVarianceComputation := tc.inVarianceComputation
		saveResolutionStart := tc.resolutionStart
		if !tc.inVarianceComputation {
			tc.inVarianceComputation = true
			tc.resolutionStart = tc.resolutionTargets.length
		}
		links.variances = emptyArray
		variances := []never{}
		for _, tp := range typeParameters {
			modifiers := tc.getTypeParameterModifiers(tp)
			var variance *VarianceFlags
			switch {
			case modifiers & ModifierFlagsOut:
				if modifiers & ModifierFlagsIn {
					variance = VarianceFlagsInvariant
				} else {
					variance = VarianceFlagsCovariant
				}
			case modifiers & ModifierFlagsIn:
				variance = VarianceFlagsContravariant
			default:
				variance = nil
			}
			if variance == nil {
				unmeasurable := false
				unreliable := false
				oldHandler := tc.outofbandVarianceMarkerHandler
				tc.outofbandVarianceMarkerHandler = func(onlyUnreliable bool) bool {
					if onlyUnreliable {
						return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: unreliable = true */ TODO
					} else {
						return /* TODO(TS-TO-GO) EqualsToken BinaryExpression: unmeasurable = true */ TODO
					}
				}
				// We first compare instantiations where the type parameter is replaced with
				// marker types that have a known subtype relationship. From this we can infer
				// invariance, covariance, contravariance or bivariance.
				typeWithSuper := tc.createMarkerType(symbol, tp, tc.markerSuperType)
				typeWithSub := tc.createMarkerType(symbol, tp, tc.markerSubType)
				variance = (__COND__(tc.isTypeAssignableTo(typeWithSub, typeWithSuper), VarianceFlagsCovariant, 0)) | (__COND__(tc.isTypeAssignableTo(typeWithSuper, typeWithSub), VarianceFlagsContravariant, 0))
				// If the instantiations appear to be related bivariantly it may be because the
				// type parameter is independent (i.e. it isn't witnessed anywhere in the generic
				// type). To determine this we compare instantiations where the type parameter is
				// replaced with marker types that are known to be unrelated.
				if variance == VarianceFlagsBivariant && tc.isTypeAssignableTo(tc.createMarkerType(symbol, tp, tc.markerOtherType), typeWithSuper) {
					variance = VarianceFlagsIndependent
				}
				tc.outofbandVarianceMarkerHandler = oldHandler
				if unmeasurable || unreliable {
					if unmeasurable {
						variance |= VarianceFlagsUnmeasurable
					}
					if unreliable {
						variance |= VarianceFlagsUnreliable
					}
				}
			}
			variances.push(variance)
		}
		if !oldVarianceComputation {
			tc.inVarianceComputation = false
			tc.resolutionStart = saveResolutionStart
		}
		links.variances = variances
		tracing. /* ? */ pop(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"variances": variances.map_(Debug.formatVariance),
		})
	}
	return links.variances
}

func (tc *TypeChecker) createMarkerType(symbol Symbol, source TypeParameter, target Type) Type {
	mapper := tc.makeUnaryTypeMapper(source, target)
	type_ := tc.getDeclaredTypeOfSymbol(symbol)
	if tc.isErrorType(type_) {
		return type_
	}
	var result Type
	if symbol.flags & SymbolFlagsTypeAlias {
		result = tc.getTypeAliasInstantiation(symbol, tc.instantiateTypes(tc.getSymbolLinks(symbol).typeParameters, mapper))
	} else {
		result = tc.createTypeReference(type_ /* as GenericType */, tc.instantiateTypes((type_ /* as GenericType */).typeParameters, mapper))
	}
	tc.markerTypes.add(tc.getTypeId(result))
	return result
}

func (tc *TypeChecker) isMarkerType(type_ Type) bool {
	return tc.markerTypes.has(tc.getTypeId(type_))
}

func (tc *TypeChecker) getTypeParameterModifiers(tp TypeParameter) ModifierFlags {
	return reduceLeft(tp.symbol. /* ? */ declarations, func(modifiers ModifierFlags, d Declaration) number {
		return modifiers | getEffectiveModifierFlags(d)
	}, ModifierFlagsNone) & (ModifierFlagsIn | ModifierFlagsOut | ModifierFlagsConst)
}

// Return true if the given type reference has a 'void' type argument for a covariant type parameter.
// See comment at call in recursiveTypeRelatedTo for when this case matters.
func (tc *TypeChecker) hasCovariantVoidArgument(typeArguments []Type, variances []VarianceFlags) bool {
	for i := 0; i < variances.length; i++ {
		if (variances[i]&VarianceFlagsVarianceMask) == VarianceFlagsCovariant && typeArguments[i].flags&TypeFlagsVoid {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) isUnconstrainedTypeParameter(type_ Type) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
	return type_.flags&TypeFlagsTypeParameter && !tc.getConstraintOfTypeParameter(type_ /* as TypeParameter */)
}

func (tc *TypeChecker) isNonDeferredTypeReference(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TypeReference */ any {
	return !!(getObjectFlags(type_) & ObjectFlagsReference) && !(type_ /* as TypeReference */).node
}

func (tc *TypeChecker) isTypeReferenceWithGenericArguments(type_ Type) bool {
	return tc.isNonDeferredTypeReference(type_) && some(tc.getTypeArguments(type_), func(t Type) bool {
		return !!(t.flags & TypeFlagsTypeParameter) || tc.isTypeReferenceWithGenericArguments(t)
	})
}

func (tc *TypeChecker) getGenericTypeReferenceRelationKey(source TypeReference, target TypeReference, postFix string, ignoreConstraints bool) string {
	var typeParameters []Type = []never{}
	constraintMarker := ""
	sourceId := getTypeReferenceId(source, 0)
	targetId := getTypeReferenceId(target, 0)
	return __TEMPLATE__(constraintMarker, sourceId, ",", targetId, postFix)
	// getTypeReferenceId(A<T, number, U>) returns "111=0-12=1"
	// where A.id=111 and number.id=12
	getTypeReferenceId := func(type_ TypeReference, depth number /*  = 0 */) string {
		result := "" + type_.target.id
		for _, t := range tc.getTypeArguments(type_) {
			if t.flags & TypeFlagsTypeParameter {
				if ignoreConstraints || tc.isUnconstrainedTypeParameter(t) {
					index := typeParameters.indexOf(t)
					if index < 0 {
						index = typeParameters.length
						typeParameters.push(t)
					}
					result += "=" + index
					continue
				}
				// We mark type references that reference constrained type parameters such that we know to obtain
				// and look for a "broadest equivalent key" in the cache.
				constraintMarker = "*"
			} else if depth < 4 && tc.isTypeReferenceWithGenericArguments(t) {
				result += "<" + getTypeReferenceId(t /* as TypeReference */, depth+1) + ">"
				continue
			}
			result += "-" + t.id
		}
		return result
	}

}

/**
 * To improve caching, the relation key for two generic types uses the target's id plus ids of the type parameters.
 * For other cases, the types ids are used.
 */

func (tc *TypeChecker) getRelationKey(source Type, target Type, intersectionState IntersectionState, relation Map[string, RelationComparisonResult], ignoreConstraints bool) string {
	if relation == tc.identityRelation && source.id > target.id {
		temp := source
		source = target
		target = temp
	}
	var postFix string
	if intersectionState {
		postFix = ":" + intersectionState
	} else {
		postFix = ""
	}
	if tc.isTypeReferenceWithGenericArguments(source) && tc.isTypeReferenceWithGenericArguments(target) {
		return tc.getGenericTypeReferenceRelationKey(source /* as TypeReference */, target /* as TypeReference */, postFix, ignoreConstraints)
	} else {
		return __TEMPLATE__(source.id, ",", target.id, postFix)
	}
}

// Invoke the callback for each underlying property symbol of the given symbol and return the first
// value that isn't undefined.
func (tc *TypeChecker) forEachProperty(prop Symbol, callback func(p Symbol) T) *T {
	if getCheckFlags(prop) & CheckFlagsSynthetic {
		// NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.Synthetic
		for _, t := range (prop /* as TransientSymbol */).links.containingType.types {
			p := tc.getPropertyOfType(t, prop.escapedName)
			result := p && tc.forEachProperty(p, callback)
			if result {
				return result
			}
		}
		return nil
	}
	return callback(prop)
}

// Return the declaring class type of a property or undefined if property not declared in class
func (tc *TypeChecker) getDeclaringClass(prop Symbol) *InterfaceType {
	if prop.parent && prop.parent.flags&SymbolFlagsClass {
		return tc.getDeclaredTypeOfSymbol(tc.getParentOfSymbol(prop)) /* as InterfaceType */
	} else {
		return nil
	}
}

// Return the inherited type of the given property or undefined if property doesn't exist in a base class.
func (tc *TypeChecker) getTypeOfPropertyInBaseClass(property Symbol) Type {
	classType := tc.getDeclaringClass(property)
	baseClassType := classType && tc.getBaseTypes(classType)[0]
	return baseClassType && tc.getTypeOfPropertyOfType(baseClassType, property.escapedName)
}

// Return true if some underlying source property is declared in a class that derives
// from the given base class.
func (tc *TypeChecker) isPropertyInClassDerivedFrom(prop Symbol, baseClass Type) *bool {
	return tc.forEachProperty(prop, func(sp Symbol) bool {
		sourceClass := tc.getDeclaringClass(sp)
		if sourceClass {
			return tc.hasBaseType(sourceClass, baseClass)
		} else {
			return false
		}
	})
}

// Return true if source property is a valid override of protected parts of target property.
func (tc *TypeChecker) isValidOverrideOf(sourceProp Symbol, targetProp Symbol) bool {
	return !tc.forEachProperty(targetProp, func(tp Symbol) bool {
		if getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlagsProtected {
			return !tc.isPropertyInClassDerivedFrom(sourceProp, tc.getDeclaringClass(tp))
		} else {
			return false
		}
	})
}

// Return true if the given class derives from each of the declaring classes of the protected
// constituents of the given property.
func (tc *TypeChecker) isClassDerivedFromDeclaringClasses(checkClass T, prop Symbol, writing bool) *T {
	if tc.forEachProperty(prop, func(p Symbol) bool {
		if getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlagsProtected {
			return !tc.hasBaseType(checkClass, tc.getDeclaringClass(p))
		} else {
			return false
		}
	}) {
		return nil
	} else {
		return checkClass
	}
}

// Return true if the given type is deeply nested. We consider this to be the case when the given stack contains
// maxDepth or more occurrences of types with the same recursion identity as the given type. The recursion identity
// provides a shared identity for type instantiations that repeat in some (possibly infinite) pattern. For example,
// in `type Deep<T> = { next: Deep<Deep<T>> }`, repeatedly referencing the `next` property leads to an infinite
// sequence of ever deeper instantiations with the same recursion identity (in this case the symbol associated with
// the object type literal).
// A homomorphic mapped type is considered deeply nested if its target type is deeply nested, and an intersection is
// considered deeply nested if any constituent of the intersection is deeply nested.
// It is possible, though highly unlikely, for the deeply nested check to be true in a situation where a chain of
// instantiations is not infinitely expanding. Effectively, we will generate a false positive when two types are
// structurally equal to at least maxDepth levels, but unequal at some level beyond that.
func (tc *TypeChecker) isDeeplyNestedType(type_ Type, stack []Type, depth number, maxDepth number /*  = 3 */) bool {
	if depth >= maxDepth {
		if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
			type_ = tc.getMappedTargetWithSymbol(type_)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_ /* as IntersectionType */).types, func(t Type) bool {
				return tc.isDeeplyNestedType(t, stack, depth, maxDepth)
			})
		}
		identity := tc.getRecursionIdentity(type_)
		count := 0
		lastTypeId := 0
		for i := 0; i < depth; i++ {
			t := stack[i]
			if tc.hasMatchingRecursionIdentity(t, identity) {
				// We only count occurrences with a higher type id than the previous occurrence, since higher
				// type ids are an indicator of newer instantiations caused by recursion.
				if t.id >= lastTypeId {
					count++
					if count >= maxDepth {
						return true
					}
				}
				lastTypeId = t.id
			}
		}
	}
	return false
}

// Unwrap nested homomorphic mapped types and return the deepest target type that has a symbol. This better
// preserves unique type identities for mapped types applied to explicitly written object literals. For example
// in `Mapped<{ x: Mapped<{ x: Mapped<{ x: string }>}>}>`, each of the mapped type applications will have a
// unique recursion identity (that of their target object type literal) and thus avoid appearing deeply nested.
func (tc *TypeChecker) getMappedTargetWithSymbol(type_ Type) Type {
	var target TODO
	for (getObjectFlags(type_)&ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: target = getModifiersTypeFromMappedType(type as MappedType) */ TODO) && (target.symbol || target.flags&TypeFlagsIntersection && some((target /* as IntersectionType */).types, func(t Type) true {
		return !!t.symbol
	})) {
		type_ = target
	}
	return type_
}

func (tc *TypeChecker) hasMatchingRecursionIdentity(type_ Type, identity any) bool {
	if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
		type_ = tc.getMappedTargetWithSymbol(type_)
	}
	if type_.flags & TypeFlagsIntersection {
		return some((type_ /* as IntersectionType */).types, func(t Type) bool {
			return tc.hasMatchingRecursionIdentity(t, identity)
		})
	}
	return tc.getRecursionIdentity(type_) == identity
}

// The recursion identity of a type is an object identity that is shared among multiple instantiations of the type.
// We track recursion identities in order to identify deeply nested and possibly infinite type instantiations with
// the same origin. For example, when type parameters are in scope in an object type such as { x: T }, all
// instantiations of that type have the same recursion identity. The default recursion identity is the object
// identity of the type, meaning that every type is unique. Generally, types with constituents that could circularly
// reference the type have a recursion identity that differs from the object identity.
func (tc *TypeChecker) getRecursionIdentity(type_ Type) any {
	// Object and array literals are known not to contain recursive references and don't need a recursion identity.
	if type_.flags&TypeFlagsObject && !tc.isObjectOrArrayLiteralType(type_) {
		if getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference */).node {
			// Deferred type references are tracked through their associated AST node. This gives us finer
			// granularity than using their associated target because each manifest type reference has a
			// unique AST node.
			return (type_ /* as TypeReference */).node
		}
		if type_.symbol && !(getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol.flags&SymbolFlagsClass) {
			// We track object types that have a symbol by that symbol (representing the origin of the type), but
			// exclude the static side of a class since it shares its symbol with the instance side.
			return type_.symbol
		}
		if tc.isTupleType(type_) {
			return type_.target
		}
	}
	if type_.flags & TypeFlagsTypeParameter {
		// We use the symbol of the type parameter such that all "fresh" instantiations of that type parameter
		// have the same recursion identity.
		return type_.symbol
	}
	if type_.flags & TypeFlagsIndexedAccess {
		// Identity is the leftmost object type in a chain of indexed accesses, eg, in A[P1][P2][P3] it is A.
		for ok := true; ok; ok = type_.flags & TypeFlagsIndexedAccess { // do-while loop
			type_ = (type_ /* as IndexedAccessType */).objectType
		}
		return type_
	}
	if type_.flags & TypeFlagsConditional {
		// The root object represents the origin of the conditional type
		return (type_ /* as ConditionalType */).root
	}
	return type_
}

func (tc *TypeChecker) isPropertyIdenticalTo(sourceProp Symbol, targetProp Symbol) bool {
	return tc.compareProperties(sourceProp, targetProp, tc.compareTypesIdentical) != TernaryFalse
}

func (tc *TypeChecker) compareProperties(sourceProp Symbol, targetProp Symbol, compareTypes func(source Type, target Type) Ternary) Ternary {
	// Two members are considered identical when
	// - they are public properties with identical names, optionality, and types,
	// - they are private or protected properties originating in the same declaration and having identical types
	if sourceProp == targetProp {
		return TernaryTrue
	}
	sourcePropAccessibility := getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlagsNonPublicAccessibilityModifier
	targetPropAccessibility := getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlagsNonPublicAccessibilityModifier
	if sourcePropAccessibility != targetPropAccessibility {
		return TernaryFalse
	}
	if sourcePropAccessibility {
		if tc.getTargetSymbol(sourceProp) != tc.getTargetSymbol(targetProp) {
			return TernaryFalse
		}
	} else {
		if (sourceProp.flags & SymbolFlagsOptional) != (targetProp.flags & SymbolFlagsOptional) {
			return TernaryFalse
		}
	}
	if tc.isReadonlySymbol(sourceProp) != tc.isReadonlySymbol(targetProp) {
		return TernaryFalse
	}
	return compareTypes(tc.getTypeOfSymbol(sourceProp), tc.getTypeOfSymbol(targetProp))
}

func (tc *TypeChecker) isMatchingSignature(source Signature, target Signature, partialMatch bool) bool {
	sourceParameterCount := tc.getParameterCount(source)
	targetParameterCount := tc.getParameterCount(target)
	sourceMinArgumentCount := tc.getMinArgumentCount(source)
	targetMinArgumentCount := tc.getMinArgumentCount(target)
	sourceHasRestParameter := tc.hasEffectiveRestParameter(source)
	targetHasRestParameter := tc.hasEffectiveRestParameter(target)
	// A source signature matches a target signature if the two signatures have the same number of required,
	// optional, and rest parameters.
	if sourceParameterCount == targetParameterCount && sourceMinArgumentCount == targetMinArgumentCount && sourceHasRestParameter == targetHasRestParameter {
		return true
	}
	// A source signature partially matches a target signature if the target signature has no fewer required
	// parameters
	if partialMatch && sourceMinArgumentCount <= targetMinArgumentCount {
		return true
	}
	return false
}

/**
 * See signatureRelatedTo, compareSignaturesIdentical
 */

func (tc *TypeChecker) compareSignaturesIdentical(source Signature, target Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool, compareTypes func(s Type, t Type) Ternary) Ternary {
	// TODO (drosen): De-duplicate code between related functions.
	if source == target {
		return TernaryTrue
	}
	if !(tc.isMatchingSignature(source, target, partialMatch)) {
		return TernaryFalse
	}
	// Check that the two signatures have the same number of type parameters.
	if length(source.typeParameters) != length(target.typeParameters) {
		return TernaryFalse
	}
	// Check that type parameter constraints and defaults match. If they do, instantiate the source
	// signature with the type parameters of the target signature and continue the comparison.
	if target.typeParameters {
		mapper := tc.createTypeMapper(source.typeParameters, target.typeParameters)
		for i := 0; i < target.typeParameters.length; i++ {
			s := source.typeParameters[i]
			t := target.typeParameters[i]
			if !(s == t || compareTypes(tc.instantiateType(tc.getConstraintFromTypeParameter(s), mapper) || tc.unknownType, tc.getConstraintFromTypeParameter(t) || tc.unknownType) && compareTypes(tc.instantiateType(tc.getDefaultFromTypeParameter(s), mapper) || tc.unknownType, tc.getDefaultFromTypeParameter(t) || tc.unknownType)) {
				return TernaryFalse
			}
		}
		source = tc.instantiateSignature(source, mapper /*eraseTypeParameters*/, true)
	}
	result := TernaryTrue
	if !ignoreThisTypes {
		sourceThisType := tc.getThisTypeOfSignature(source)
		if sourceThisType {
			targetThisType := tc.getThisTypeOfSignature(target)
			if targetThisType {
				related := compareTypes(sourceThisType, targetThisType)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
		}
	}
	targetLen := tc.getParameterCount(target)
	for i := 0; i < targetLen; i++ {
		s := tc.getTypeAtPosition(source, i)
		t := tc.getTypeAtPosition(target, i)
		related := compareTypes(t, s)
		if !related {
			return TernaryFalse
		}
		result &= related
	}
	if !ignoreReturnTypes {
		sourceTypePredicate := tc.getTypePredicateOfSignature(source)
		targetTypePredicate := tc.getTypePredicateOfSignature(target)
		if sourceTypePredicate || targetTypePredicate {
			result &= tc.compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes)
		} else {
			result &= compareTypes(tc.getReturnTypeOfSignature(source), tc.getReturnTypeOfSignature(target))
		}
	}
	return result
}

func (tc *TypeChecker) compareTypePredicatesIdentical(source *TypePredicate, target *TypePredicate, compareTypes func(s Type, t Type) Ternary) Ternary {
	switch {
	case !(source && target && tc.typePredicateKindsMatch(source, target)):
		return TernaryFalse
	case source.type_ == target.type_:
		return TernaryTrue
	case source.type_ && target.type_:
		return compareTypes(source.type_, target.type_)
	default:
		return TernaryFalse
	}
}

func (tc *TypeChecker) literalTypesWithSameBaseType(types []Type) bool {
	var commonBaseType Type
	for _, t := range types {
		if !(t.flags & TypeFlagsNever) {
			baseType := tc.getBaseTypeOfLiteralType(t)
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: commonBaseType ??= baseType */ TODO
			if baseType == t || baseType != commonBaseType {
				return false
			}
		}
	}
	return true
}

func (tc *TypeChecker) getCombinedTypeFlags(types []Type) TypeFlags {
	return reduceLeft(types, func(flags TypeFlags, t Type) number {
		return flags | (__COND__(t.flags&TypeFlagsUnion, tc.getCombinedTypeFlags((t /* as UnionType */).types), t.flags))
	}, 0 /* as TypeFlags */)
}

func (tc *TypeChecker) getCommonSupertype(types []Type) Type {
	if types.length == 1 {
		return types[0]
	}
	// Remove nullable types from each of the candidates.
	var primaryTypes []Type
	if tc.strictNullChecks {
		primaryTypes = sameMap(types, func(t Type) Type {
			return tc.filterType(t, func(u Type) bool {
				return !(u.flags & TypeFlagsNullable)
			})
		})
	} else {
		primaryTypes = types
	}
	// When the candidate types are all literal types with the same base type, return a union
	// of those literal types. Otherwise, return the leftmost type for which no type to the
	// right is a supertype.
	var superTypeOrUnion Type
	if tc.literalTypesWithSameBaseType(primaryTypes) {
		superTypeOrUnion = tc.getUnionType(primaryTypes)
	} else {
		superTypeOrUnion = reduceLeft(primaryTypes, func(s Type, t Type) Type {
			if tc.isTypeSubtypeOf(s, t) {
				return t
			} else {
				return s
			}
		})
	}
	// Add any nullable types that occurred in the candidates back to the result.
	if primaryTypes == types {
		return superTypeOrUnion
	} else {
		return tc.getNullableType(superTypeOrUnion, tc.getCombinedTypeFlags(types)&TypeFlagsNullable)
	}
}

// Return the leftmost type for which no type to the right is a subtype.
func (tc *TypeChecker) getCommonSubtype(types []Type) Type {
	return reduceLeft(types, func(s Type, t Type) Type {
		if tc.isTypeSubtypeOf(t, s) {
			return t
		} else {
			return s
		}
	})
}

func (tc *TypeChecker) isArrayType(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TypeReference */ any {
	return !!(getObjectFlags(type_) & ObjectFlagsReference) && ((type_ /* as TypeReference */).target == tc.globalArrayType || (type_ /* as TypeReference */).target == tc.globalReadonlyArrayType)
}

func (tc *TypeChecker) isReadonlyArrayType(type_ Type) bool {
	return !!(getObjectFlags(type_) & ObjectFlagsReference) && (type_ /* as TypeReference */).target == tc.globalReadonlyArrayType
}

func (tc *TypeChecker) isArrayOrTupleType(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TypeReference */ any {
	return tc.isArrayType(type_) || tc.isTupleType(type_)
}

func (tc *TypeChecker) isMutableArrayOrTuple(type_ Type) bool {
	return tc.isArrayType(type_) && !tc.isReadonlyArrayType(type_) || tc.isTupleType(type_) && !type_.target.readonly
}

func (tc *TypeChecker) getElementTypeOfArrayType(type_ Type) Type {
	if tc.isArrayType(type_) {
		return tc.getTypeArguments(type_)[0]
	} else {
		return nil
	}
}

func (tc *TypeChecker) isArrayLikeType(type_ Type) bool {
	// A type is array-like if it is a reference to the global Array or global ReadonlyArray type,
	// or if it is not the undefined or null type and if it is assignable to ReadonlyArray<any>
	return tc.isArrayType(type_) || !(type_.flags&TypeFlagsNullable) && tc.isTypeAssignableTo(type_, tc.anyReadonlyArrayType)
}

func (tc *TypeChecker) isMutableArrayLikeType(type_ Type) bool {
	// A type is mutable-array-like if it is a reference to the global Array type, or if it is not the
	// any, undefined or null type and if it is assignable to Array<any>
	return tc.isMutableArrayOrTuple(type_) || !(type_.flags&(TypeFlagsAny|TypeFlagsNullable)) && tc.isTypeAssignableTo(type_, tc.anyArrayType)
}

func (tc *TypeChecker) getSingleBaseForNonAugmentingSubtype(type_ Type) Type {
	if !(getObjectFlags(type_) & ObjectFlagsReference) || !(getObjectFlags((type_ /* as TypeReference */).target) & ObjectFlagsClassOrInterface) {
		return nil
	}
	if getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeCalculated {
		if getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeExists {
			return (type_ /* as TypeReference */).cachedEquivalentBaseType
		} else {
			return nil
		}
	}
	(type_ /* as TypeReference */).objectFlags |= ObjectFlagsIdenticalBaseTypeCalculated
	target := (type_ /* as TypeReference */).target /* as InterfaceType */
	if getObjectFlags(target) & ObjectFlagsClass {
		baseTypeNode := tc.getBaseTypeNodeOfClass(target)
		// A base type expression may circularly reference the class itself (e.g. as an argument to function call), so we only
		// check for base types specified as simple qualified names.
		if baseTypeNode && baseTypeNode.expression.kind != SyntaxKindIdentifier && baseTypeNode.expression.kind != SyntaxKindPropertyAccessExpression {
			return nil
		}
	}
	bases := tc.getBaseTypes(target)
	if bases.length != 1 {
		return nil
	}
	if tc.getMembersOfSymbol(type_.symbol).size {
		return nil
		// If the interface has any members, they may subtype members in the base, so we should do a full structural comparison
	}
	var instantiatedBase Type
	if !length(target.typeParameters) {
		instantiatedBase = bases[0]
	} else {
		instantiatedBase = tc.instantiateType(bases[0], tc.createTypeMapper(target.typeParameters, tc.getTypeArguments(type_ /* as TypeReference */).slice(0, target.typeParameters.length)))
	}
	if length(tc.getTypeArguments(type_ /* as TypeReference */)) > length(target.typeParameters) {
		instantiatedBase = tc.getTypeWithThisArgument(instantiatedBase, last(tc.getTypeArguments(type_ /* as TypeReference */)))
	}
	(type_ /* as TypeReference */).objectFlags |= ObjectFlagsIdenticalBaseTypeExists
	(type_ /* as TypeReference */).cachedEquivalentBaseType = instantiatedBase
	return (type_ /* as TypeReference */).cachedEquivalentBaseType
}

func (tc *TypeChecker) isEmptyLiteralType(type_ Type) bool {
	if tc.strictNullChecks {
		return type_ == tc.implicitNeverType
	} else {
		return type_ == tc.undefinedWideningType
	}
}

func (tc *TypeChecker) isEmptyArrayLiteralType(type_ Type) bool {
	elementType := tc.getElementTypeOfArrayType(type_)
	return !!elementType && tc.isEmptyLiteralType(elementType)
}

func (tc *TypeChecker) isTupleLikeType(type_ Type) bool {
	var lengthType TODO
	return tc.isTupleType(type_) || !!tc.getPropertyOfType(type_, "0" /* as __String */) || tc.isArrayLikeType(type_) && !!( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: lengthType = getTypeOfPropertyOfType(type, "length" as __String) */ TODO) && tc.everyType(lengthType, func(t Type) bool {
		return !!(t.flags & TypeFlagsNumberLiteral)
	})
}

func (tc *TypeChecker) isArrayOrTupleLikeType(type_ Type) bool {
	return tc.isArrayLikeType(type_) || tc.isTupleLikeType(type_)
}

func (tc *TypeChecker) getTupleElementType(type_ Type, index number) Type {
	propType := tc.getTypeOfPropertyOfType(type_, ""+index /* as __String */)
	if propType {
		return propType
	}
	if tc.everyType(type_, tc.isTupleType) {
		return tc.getTupleElementTypeOutOfStartCount(type_, index, __COND__(tc.compilerOptions.noUncheckedIndexedAccess, tc.undefinedType, nil))
	}
	return nil
}

func (tc *TypeChecker) isNeitherUnitTypeNorNever(type_ Type) bool {
	return !(type_.flags & (TypeFlagsUnit | TypeFlagsNever))
}

func (tc *TypeChecker) isUnitType(type_ Type) bool {
	return !!(type_.flags & TypeFlagsUnit)
}

func (tc *TypeChecker) isUnitLikeType(type_ Type) bool {
	// Intersections that reduce to 'never' (e.g. 'T & null' where 'T extends {}') are not unit types.
	t := tc.getBaseConstraintOrType(type_)
	// Scan intersections such that tagged literal types are considered unit types.
	if t.flags & TypeFlagsIntersection {
		return some((t /* as IntersectionType */).types, tc.isUnitType)
	} else {
		return tc.isUnitType(t)
	}
}

func (tc *TypeChecker) extractUnitType(type_ Type) Type {
	if type_.flags & TypeFlagsIntersection {
		return find((type_ /* as IntersectionType */).types, tc.isUnitType) || type_
	} else {
		return type_
	}
}

func (tc *TypeChecker) isLiteralType(type_ Type) bool {
	switch {
	case type_.flags & TypeFlagsBoolean:
		return true
	case type_.flags & TypeFlagsUnion:
		if type_.flags & TypeFlagsEnumLiteral {
			return true
		} else {
			return every((type_ /* as UnionType */).types, tc.isUnitType)
		}
	default:
		return tc.isUnitType(type_)
	}
}

func (tc *TypeChecker) getBaseTypeOfLiteralType(type_ Type) Type {
	switch {
	case type_.flags & TypeFlagsEnumLike:
		return tc.getBaseTypeOfEnumLikeType(type_ /* as LiteralType */)
	case type_.flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral | TypeFlagsStringMapping):
		return tc.stringType
	case type_.flags & TypeFlagsNumberLiteral:
		return tc.numberType
	case type_.flags & TypeFlagsBigIntLiteral:
		return tc.bigintType
	case type_.flags & TypeFlagsBooleanLiteral:
		return tc.booleanType
	case type_.flags & TypeFlagsUnion:
		return tc.getBaseTypeOfLiteralTypeUnion(type_ /* as UnionType */)
	default:
		return type_
	}
}

func (tc *TypeChecker) getBaseTypeOfLiteralTypeUnion(type_ UnionType) Type {
	key := __TEMPLATE__("B", tc.getTypeId(type_))
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType)) */ TODO
}

// This like getBaseTypeOfLiteralType, but instead treats enum literals as strings/numbers instead
// of returning their enum base type (which depends on the types of other literals in the enum).
func (tc *TypeChecker) getBaseTypeOfLiteralTypeForComparison(type_ Type) Type {
	switch {
	case type_.flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral | TypeFlagsStringMapping):
		return tc.stringType
	case type_.flags & (TypeFlagsNumberLiteral | TypeFlagsEnum):
		return tc.numberType
	case type_.flags & TypeFlagsBigIntLiteral:
		return tc.bigintType
	case type_.flags & TypeFlagsBooleanLiteral:
		return tc.booleanType
	case type_.flags & TypeFlagsUnion:
		return tc.mapType(type_, tc.getBaseTypeOfLiteralTypeForComparison)
	default:
		return type_
	}
}

func (tc *TypeChecker) getWidenedLiteralType(type_ Type) Type {
	switch {
	case type_.flags&TypeFlagsEnumLike && tc.isFreshLiteralType(type_):
		return tc.getBaseTypeOfEnumLikeType(type_ /* as LiteralType */)
	case type_.flags&TypeFlagsStringLiteral && tc.isFreshLiteralType(type_):
		return tc.stringType
	case type_.flags&TypeFlagsNumberLiteral && tc.isFreshLiteralType(type_):
		return tc.numberType
	case type_.flags&TypeFlagsBigIntLiteral && tc.isFreshLiteralType(type_):
		return tc.bigintType
	case type_.flags&TypeFlagsBooleanLiteral && tc.isFreshLiteralType(type_):
		return tc.booleanType
	case type_.flags & TypeFlagsUnion:
		return tc.mapType(type_ /* as UnionType */, tc.getWidenedLiteralType)
	default:
		return type_
	}
}

func (tc *TypeChecker) getWidenedUniqueESSymbolType(type_ Type) Type {
	switch {
	case type_.flags & TypeFlagsUniqueESSymbol:
		return tc.esSymbolType
	case type_.flags & TypeFlagsUnion:
		return tc.mapType(type_ /* as UnionType */, tc.getWidenedUniqueESSymbolType)
	default:
		return type_
	}
}

func (tc *TypeChecker) getWidenedLiteralLikeTypeForContextualType(type_ Type, contextualType Type) Type {
	if !tc.isLiteralOfContextualType(type_, contextualType) {
		type_ = tc.getWidenedUniqueESSymbolType(tc.getWidenedLiteralType(type_))
	}
	return tc.getRegularTypeOfLiteralType(type_)
}

func (tc *TypeChecker) getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(type_ Type, contextualSignatureReturnType Type, isAsync bool) Type {
	if type_ && tc.isUnitType(type_) {
		var contextualType Type
		switch {
		case !contextualSignatureReturnType:
			contextualType = nil
		case isAsync:
			contextualType = tc.getPromisedTypeOfPromise(contextualSignatureReturnType)
		default:
			contextualType = contextualSignatureReturnType
		}
		type_ = tc.getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
	}
	return type_
}

func (tc *TypeChecker) getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(type_ Type, contextualSignatureReturnType Type, kind IterationTypeKind, isAsyncGenerator bool) Type {
	if type_ && tc.isUnitType(type_) {
		var contextualType Type
		if !contextualSignatureReturnType {
			contextualType = nil
		} else {
			contextualType = tc.getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator)
		}
		type_ = tc.getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
	}
	return type_
}

/**
 * Check if a Type was written as a tuple type literal.
 * Prefer using isTupleLikeType() unless the use of `elementTypes`/`getTypeArguments` is required.
 */

func (tc *TypeChecker) isTupleType(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TupleTypeReference */ any {
	return !!(getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference */).target.objectFlags&ObjectFlagsTuple)
}

func (tc *TypeChecker) isGenericTupleType(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TupleTypeReference */ any {
	return tc.isTupleType(type_) && !!(type_.target.combinedFlags & ElementFlagsVariadic)
}

func (tc *TypeChecker) isSingleElementGenericTupleType(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is TupleTypeReference */ any {
	return tc.isGenericTupleType(type_) && type_.target.elementFlags.length == 1
}

func (tc *TypeChecker) getRestTypeOfTupleType(type_ TupleTypeReference) Type {
	return tc.getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength)
}

func (tc *TypeChecker) getTupleElementTypeOutOfStartCount(type_ Type, index number, undefinedOrMissingType Type) Type {
	return tc.mapType(type_, func(t Type) Type {
		tupleType := t /* as TupleTypeReference */
		restType := tc.getRestTypeOfTupleType(tupleType)
		if !restType {
			return tc.undefinedType
		}
		if tc.undefinedOrMissingType && index >= tc.getTotalFixedElementCount(tupleType.target) {
			return tc.getUnionType([]Type{restType, tc.undefinedOrMissingType})
		}
		return restType
	})
}

func (tc *TypeChecker) getRestArrayTypeOfTupleType(type_ TupleTypeReference) *ObjectType {
	restType := tc.getRestTypeOfTupleType(type_)
	return restType && tc.createArrayType(restType)
}

func (tc *TypeChecker) getElementTypeOfSliceOfTupleType(type_ TupleTypeReference, index number, endSkipCount number /*  = 0 */, writing bool /*  = false */, noReductions bool /*  = false */) Type {
	length := tc.getTypeReferenceArity(type_) - endSkipCount
	if index < length {
		typeArguments := tc.getTypeArguments(type_)
		var elementTypes []Type = []never{}
		for i := index; i < length; i++ {
			t := typeArguments[i]
			elementTypes.push(__COND__(type_.target.elementFlags[i]&ElementFlagsVariadic, tc.getIndexedAccessType(t, tc.numberType), t))
		}
		if writing {
			return tc.getIntersectionType(elementTypes)
		} else {
			return tc.getUnionType(elementTypes, __COND__(noReductions, UnionReductionNone, UnionReductionLiteral))
		}
	}
	return nil
}

func (tc *TypeChecker) isTupleTypeStructureMatching(t1 TupleTypeReference, t2 TupleTypeReference) bool {
	return tc.getTypeReferenceArity(t1) == tc.getTypeReferenceArity(t2) && every(t1.target.elementFlags, func(f ElementFlags, i number) bool {
		return (f & ElementFlagsVariable) == (t2.target.elementFlags[i] & ElementFlagsVariable)
	})
}

func (tc *TypeChecker) isZeroBigInt(TODO_IDENTIFIER BigIntLiteralType) bool {
	return value.base10Value == "0"
}

func (tc *TypeChecker) removeDefinitelyFalsyTypes(type_ Type) Type {
	return tc.filterType(type_, func(t Type) bool {
		return tc.hasTypeFacts(t, TypeFactsTruthy)
	})
}

func (tc *TypeChecker) extractDefinitelyFalsyTypes(type_ Type) Type {
	return tc.mapType(type_, tc.getDefinitelyFalsyPartOfType)
}

func (tc *TypeChecker) getDefinitelyFalsyPartOfType(type_ Type) Type {
	switch {
	case type_.flags & TypeFlagsString:
		return tc.emptyStringType
	case type_.flags & TypeFlagsNumber:
		return tc.zeroType
	case type_.flags & TypeFlagsBigInt:
		return tc.zeroBigIntType
	case type_ == tc.regularFalseType || type_ == tc.falseType || type_.flags&(TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull|TypeFlagsAnyOrUnknown) || type_.flags&TypeFlagsStringLiteral && (type_ /* as StringLiteralType */).value == "" || type_.flags&TypeFlagsNumberLiteral && (type_ /* as NumberLiteralType */).value == 0 || type_.flags&TypeFlagsBigIntLiteral && tc.isZeroBigInt(type_ /* as BigIntLiteralType */):
		return type_
	default:
		return tc.neverType
	}
}

/**
 * Add undefined or null or both to a type if they are missing.
 * @param type - type to add undefined and/or null to if not present
 * @param flags - Either TypeFlags.Undefined or TypeFlags.Null, or both
 */

func (tc *TypeChecker) getNullableType(type_ Type, flags TypeFlags) Type {
	missing := (flags & ~type_.flags) & (TypeFlagsUndefined | TypeFlagsNull)
	switch {
	case missing == 0:
		return type_
	case missing == TypeFlagsUndefined:
		return tc.getUnionType([]Type{type_, tc.undefinedType})
	case missing == TypeFlagsNull:
		return tc.getUnionType([]Type{type_, tc.nullType})
	default:
		return tc.getUnionType([]Type{type_, tc.undefinedType, tc.nullType})
	}
}

func (tc *TypeChecker) getOptionalType(type_ Type, isProperty bool /*  = false */) Type {
	Debug.assert(tc.strictNullChecks)
	var missingOrUndefined IntrinsicType
	if isProperty {
		missingOrUndefined = tc.undefinedOrMissingType
	} else {
		missingOrUndefined = tc.undefinedType
	}
	if type_ == missingOrUndefined || type_.flags&TypeFlagsUnion && (type_ /* as UnionType */).types[0] == missingOrUndefined {
		return type_
	} else {
		return tc.getUnionType([]Type{type_, missingOrUndefined})
	}
}

func (tc *TypeChecker) getGlobalNonNullableTypeInstantiation(type_ Type) Type {
	if !tc.deferredGlobalNonNullableTypeAlias {
		tc.deferredGlobalNonNullableTypeAlias = tc.getGlobalSymbol("NonNullable" /* as __String */, SymbolFlagsTypeAlias /*diagnostic*/, nil) || tc.unknownSymbol
	}
	if tc.deferredGlobalNonNullableTypeAlias != tc.unknownSymbol {
		return tc.getTypeAliasInstantiation(tc.deferredGlobalNonNullableTypeAlias, []Type{type_})
	} else {
		return tc.getIntersectionType([]Type{type_, tc.emptyObjectType})
	}
}

func (tc *TypeChecker) getNonNullableType(type_ Type) Type {
	if tc.strictNullChecks {
		return tc.getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
	} else {
		return type_
	}
}

func (tc *TypeChecker) addOptionalTypeMarker(type_ Type) Type {
	if tc.strictNullChecks {
		return tc.getUnionType([]Type{type_, tc.optionalType})
	} else {
		return type_
	}
}

func (tc *TypeChecker) removeOptionalTypeMarker(type_ Type) Type {
	if tc.strictNullChecks {
		return tc.removeType(type_, tc.optionalType)
	} else {
		return type_
	}
}

func (tc *TypeChecker) propagateOptionalTypeMarker(type_ Type, node OptionalChain, wasOptional bool) Type {
	switch {
	case wasOptional:
		if isOutermostOptionalChain(node) {
			return tc.getOptionalType(type_)
		} else {
			return tc.addOptionalTypeMarker(type_)
		}
	default:
		return type_
	}
}

func (tc *TypeChecker) getOptionalExpressionType(exprType Type, expression Expression) Type {
	switch {
	case isExpressionOfOptionalChainRoot(expression):
		return tc.getNonNullableType(exprType)
	case isOptionalChain(expression):
		return tc.removeOptionalTypeMarker(exprType)
	default:
		return exprType
	}
}

func (tc *TypeChecker) removeMissingType(type_ Type, isOptional bool) Type {
	if tc.exactOptionalPropertyTypes && isOptional {
		return tc.removeType(type_, tc.missingType)
	} else {
		return type_
	}
}

func (tc *TypeChecker) containsMissingType(type_ Type) bool {
	return type_ == tc.missingType || !!(type_.flags&TypeFlagsUnion) && (type_ /* as UnionType */).types[0] == tc.missingType
}

func (tc *TypeChecker) removeMissingOrUndefinedType(type_ Type) Type {
	if tc.exactOptionalPropertyTypes {
		return tc.removeType(type_, tc.missingType)
	} else {
		return tc.getTypeWithFacts(type_, TypeFactsNEUndefined)
	}
}

/**
 * Is source potentially coercible to target type under `==`.
 * Assumes that `source` is a constituent of a union, hence
 * the boolean literal flag on the LHS, but not on the RHS.
 *
 * This does not fully replicate the semantics of `==`. The
 * intention is to catch cases that are clearly not right.
 *
 * Comparing (string | number) to number should not remove the
 * string element.
 *
 * Comparing (string | number) to 1 will remove the string
 * element, though this is not sound. This is a pragmatic
 * choice.
 *
 * @see narrowTypeByEquality
 *
 * @param source
 * @param target
 */

func (tc *TypeChecker) isCoercibleUnderDoubleEquals(source Type, target Type) bool {
	return ((source.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBooleanLiteral)) != 0) && ((target.flags & (TypeFlagsNumber | TypeFlagsString | TypeFlagsBoolean)) != 0)
}

/**
 * Return true if type was inferred from an object literal, written as an object type literal, or is the shape of a module
 * with no call or construct signatures.
 */

func (tc *TypeChecker) isObjectTypeWithInferableIndex(type_ Type) bool {
	objectFlags := getObjectFlags(type_)
	if type_.flags & TypeFlagsIntersection {
		return every((type_ /* as IntersectionType */).types, tc.isObjectTypeWithInferableIndex)
	} else {
		return !!(type_.symbol && (type_.symbol.flags&(SymbolFlagsObjectLiteral|SymbolFlagsTypeLiteral|SymbolFlagsEnum|SymbolFlagsValueModule)) != 0 && !(type_.symbol.flags & SymbolFlagsClass) && !tc.typeHasCallOrConstructSignatures(type_)) || !!(objectFlags & ObjectFlagsObjectRestType) || !!(objectFlags&ObjectFlagsReverseMapped && tc.isObjectTypeWithInferableIndex((type_ /* as ReverseMappedType */).source))
	}
}

func (tc *TypeChecker) createSymbolWithType(source Symbol, type_ Type) TransientSymbol {
	symbol := tc.createSymbol(source.flags, source.escapedName, getCheckFlags(source)&CheckFlagsReadonly)
	symbol.declarations = source.declarations
	symbol.parent = source.parent
	symbol.links.type_ = type_
	symbol.links.target = source
	if source.valueDeclaration {
		symbol.valueDeclaration = source.valueDeclaration
	}
	nameType := tc.getSymbolLinks(source).nameType
	if nameType {
		symbol.links.nameType = nameType
	}
	return symbol
}

func (tc *TypeChecker) transformTypeOfMembers(type_ Type, f func(propertyType Type) Type) SymbolTable {
	members := createSymbolTable()
	for _, property := range tc.getPropertiesOfObjectType(type_) {
		original := tc.getTypeOfSymbol(property)
		updated := f(original)
		members.set(property.escapedName, __COND__(updated == original, property, tc.createSymbolWithType(property, updated)))
	}
	return members
}

/**
 * If the the provided object literal is subject to the excess properties check,
 * create a new that is exempt. Recursively mark object literal members as exempt.
 * Leave signatures alone since they are not subject to the check.
 */

func (tc *TypeChecker) getRegularTypeOfObjectLiteral(type_ Type) Type {
	if !(tc.isObjectLiteralType(type_) && getObjectFlags(type_)&ObjectFlagsFreshLiteral) {
		return type_
	}
	regularType := (type_ /* as FreshObjectLiteralType */).regularType
	if regularType {
		return regularType
	}

	resolved := type_ /* as ResolvedType */
	members := tc.transformTypeOfMembers(type_, tc.getRegularTypeOfObjectLiteral)
	regularNew := tc.createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos)
	regularNew.flags = resolved.flags
	regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlagsFreshLiteral
	(type_ /* as FreshObjectLiteralType */).regularType = regularNew
	return regularNew
}

func (tc *TypeChecker) createWideningContext(parent *WideningContext, propertyName *__String, siblings *[]Type) WideningContext {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"parent":             parent,
		"propertyName":       propertyName,
		"siblings":           siblings,
		"resolvedProperties": nil,
	}
}

func (tc *TypeChecker) getSiblingsOfContext(context WideningContext) []Type {
	if !context.siblings {
		var siblings []Type = []never{}
		for _, type_ := range tc.getSiblingsOfContext(context.parent) {
			if tc.isObjectLiteralType(type_) {
				prop := tc.getPropertyOfObjectType(type_, context.propertyName)
				if prop {
					tc.forEachType(tc.getTypeOfSymbol(prop), func(t Type) {
						siblings.push(t)
					})
				}
			}
		}
		context.siblings = siblings
	}
	return context.siblings
}

func (tc *TypeChecker) getPropertiesOfContext(context WideningContext) []Symbol {
	if !context.resolvedProperties {
		names := NewMap[__String, Symbol]()
		for _, t := range tc.getSiblingsOfContext(context) {
			if tc.isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlagsContainsSpread) {
				for _, prop := range tc.getPropertiesOfType(t) {
					names.set(prop.escapedName, prop)
				}
			}
		}
		context.resolvedProperties = arrayFrom(names.values())
	}
	return context.resolvedProperties
}

func (tc *TypeChecker) getWidenedProperty(prop Symbol, context *WideningContext) Symbol {
	if !(prop.flags & SymbolFlagsProperty) {
		// Since get accessors already widen their return value there is no need to
		// widen accessor based properties here.
		return prop
	}
	original := tc.getTypeOfSymbol(prop)
	propContext := context && tc.createWideningContext(context, prop.escapedName /*siblings*/, nil)
	widened := tc.getWidenedTypeWithContext(original, propContext)
	if widened == original {
		return prop
	} else {
		return tc.createSymbolWithType(prop, widened)
	}
}

func (tc *TypeChecker) getUndefinedProperty(prop Symbol) Symbol {
	cached := tc.undefinedProperties.get(prop.escapedName)
	if cached {
		return cached
	}
	result := tc.createSymbolWithType(prop, tc.undefinedOrMissingType)
	result.flags |= SymbolFlagsOptional
	tc.undefinedProperties.set(prop.escapedName, result)
	return result
}

func (tc *TypeChecker) getWidenedTypeOfObjectLiteral(type_ Type, context *WideningContext) Type {
	members := createSymbolTable()
	for _, prop := range tc.getPropertiesOfObjectType(type_) {
		members.set(prop.escapedName, tc.getWidenedProperty(prop, context))
	}
	if context {
		for _, prop := range tc.getPropertiesOfContext(context) {
			if !members.has(prop.escapedName) {
				members.set(prop.escapedName, tc.getUndefinedProperty(prop))
			}
		}
	}
	result := tc.createAnonymousType(type_.symbol, members, emptyArray, emptyArray, sameMap(tc.getIndexInfosOfType(type_), func(info IndexInfo) IndexInfo {
		return tc.createIndexInfo(info.keyType, tc.getWidenedType(info.type_), info.isReadonly)
	}))
	result.objectFlags |= getObjectFlags(type_) & (ObjectFlagsJSLiteral | ObjectFlagsNonInferrableType)
	// Retain js literal flag through widening
	return result
}

func (tc *TypeChecker) getWidenedType(type_ Type) Type {
	return tc.getWidenedTypeWithContext(type_ /*context*/, nil)
}

func (tc *TypeChecker) getWidenedTypeWithContext(type_ Type, context *WideningContext) Type {
	if getObjectFlags(type_) & ObjectFlagsRequiresWidening {
		if context == nil && type_.widened {
			return type_.widened
		}
		var result Type
		if type_.flags & (TypeFlagsAny | TypeFlagsNullable) {
			result = tc.anyType
		} else if tc.isObjectLiteralType(type_) {
			result = tc.getWidenedTypeOfObjectLiteral(type_, context)
		} else if type_.flags & TypeFlagsUnion {
			unionContext := context || tc.createWideningContext(nil /*propertyName*/, nil, (type_ /* as UnionType */).types)
			widenedTypes := sameMap((type_ /* as UnionType */).types, func(t Type) Type {
				if t.flags & TypeFlagsNullable {
					return t
				} else {
					return tc.getWidenedTypeWithContext(t, unionContext)
				}
			})
			// Widening an empty object literal transitions from a highly restrictive type to
			// a highly inclusive one. For that reason we perform subtype reduction here if the
			// union includes empty object types (e.g. reducing {} | string to just {}).
			result = tc.getUnionType(widenedTypes, __COND__(some(widenedTypes, tc.isEmptyObjectType), UnionReductionSubtype, UnionReductionLiteral))
		} else if type_.flags & TypeFlagsIntersection {
			result = tc.getIntersectionType(sameMap((type_ /* as IntersectionType */).types, tc.getWidenedType))
		} else if tc.isArrayOrTupleType(type_) {
			result = tc.createTypeReference(type_.target, sameMap(tc.getTypeArguments(type_), tc.getWidenedType))
		}
		if result && context == nil {
			type_.widened = result
		}
		return result || type_
	}
	return type_
}

/**
 * Reports implicit any errors that occur as a result of widening 'null' and 'undefined'
 * to 'any'. A call to reportWideningErrorsInType is normally accompanied by a call to
 * getWidenedType. But in some cases getWidenedType is called without reporting errors
 * (type argument inference is an example).
 *
 * The return value indicates whether an error was in fact reported. The particular circumstances
 * are on a best effort basis. Currently, if the null or undefined that causes widening is inside
 * an object literal property (arbitrarily deeply), this function reports an error. If no error is
 * reported, reportImplicitAnyError is a suitable fallback to report a general error.
 */

func (tc *TypeChecker) reportWideningErrorsInType(type_ Type) bool {
	errorReported := false
	if getObjectFlags(type_) & ObjectFlagsContainsWideningType {
		if type_.flags & TypeFlagsUnion {
			if some((type_ /* as UnionType */).types, tc.isEmptyObjectType) {
				errorReported = true
			} else {
				for _, t := range (type_ /* as UnionType */).types {
					errorReported = errorReported || tc.reportWideningErrorsInType(t)
				}
			}
		} else if tc.isArrayOrTupleType(type_) {
			for _, t := range tc.getTypeArguments(type_) {
				errorReported = errorReported || tc.reportWideningErrorsInType(t)
			}
		} else if tc.isObjectLiteralType(type_) {
			for _, p := range tc.getPropertiesOfObjectType(type_) {
				t := tc.getTypeOfSymbol(p)
				if getObjectFlags(t) & ObjectFlagsContainsWideningType {
					errorReported = tc.reportWideningErrorsInType(t)
					if !errorReported {
						// we need to account for property types coming from object literal type normalization in unions
						valueDeclaration := p.declarations. /* ? */ find(func(d Declaration) bool {
							return d.symbol.valueDeclaration. /* ? */ parent == type_.symbol.valueDeclaration
						})
						if valueDeclaration {
							tc.error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, tc.symbolToString(p), tc.typeToString(tc.getWidenedType(t)))
							errorReported = true
						}
					}
				}
			}
		}
	}
	return errorReported
}

func (tc *TypeChecker) reportImplicitAny(declaration Declaration, type_ Type, wideningKind WideningKind) {
	typeAsString := tc.typeToString(tc.getWidenedType(type_))
	if isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), tc.compilerOptions) {
		// Only report implicit any errors/suggestions in TS and ts-check JS files
		return
	}
	var diagnostic DiagnosticMessage
	switch declaration.kind {
	case SyntaxKindBinaryExpression,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature:
		if tc.noImplicitAny {
			diagnostic = Diagnostics.Member_0_implicitly_has_an_1_type
		} else {
			diagnostic = Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage
		}
	case SyntaxKindParameter:
		param := declaration /* as ParameterDeclaration */
		if isIdentifier(param.name) {
			originalKeywordKind := identifierToKeywordKind(param.name)
			if (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) && param.parent.parameters.includes(param) && (tc.resolveName(param, param.name.escapedText, SymbolFlagsType /*nameNotFoundMessage*/, nil /*isUse*/, true) || originalKeywordKind && isTypeNodeKind(originalKeywordKind)) {
				newName := "arg" + param.parent.parameters.indexOf(param)
				typeName := declarationNameToString(param.name) + (__COND__(param.dotDotDotToken, "[]", ""))
				tc.errorOrSuggestion(tc.noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName)
				return
			}
		}
		switch {
		case (declaration /* as ParameterDeclaration */).dotDotDotToken:
			if tc.noImplicitAny {
				diagnostic = Diagnostics.Rest_parameter_0_implicitly_has_an_any_type
			} else {
				diagnostic = Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage
			}
		case tc.noImplicitAny:
			diagnostic = Diagnostics.Parameter_0_implicitly_has_an_1_type
		default:
			diagnostic = Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage
		}
	case SyntaxKindBindingElement:
		diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type
		if !tc.noImplicitAny {
			// Don't issue a suggestion for binding elements since the codefix doesn't yet support them.
			return
		}
	case SyntaxKindJSDocFunctionType:
		tc.error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
		return
	case SyntaxKindJSDocSignature:
		if tc.noImplicitAny && isJSDocOverloadTag(declaration.parent) {
			tc.error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString)
		}
		return
	case SyntaxKindFunctionDeclaration,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		if tc.noImplicitAny && !(declaration /* as NamedDeclaration */).name {
			if wideningKind == WideningKindGeneratorYield {
				tc.error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString)
			} else {
				tc.error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString)
			}
			return
		}
		switch {
		case !tc.noImplicitAny:
			diagnostic = Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage
		case wideningKind == WideningKindGeneratorYield:
			diagnostic = Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type
		default:
			diagnostic = Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type
		}
	case SyntaxKindMappedType:
		if tc.noImplicitAny {
			tc.error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type)
		}
		return
	default:
		if tc.noImplicitAny {
			diagnostic = Diagnostics.Variable_0_implicitly_has_an_1_type
		} else {
			diagnostic = Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage
		}
	}
	tc.errorOrSuggestion(tc.noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString)
}

func (tc *TypeChecker) reportErrorsFromWidening(declaration Declaration, type_ Type, wideningKind WideningKind) {
	tc.addLazyDiagnostic(func() {
		if tc.noImplicitAny && getObjectFlags(type_)&ObjectFlagsContainsWideningType && (!wideningKind || !tc.getContextualSignatureForFunctionLikeDeclaration(declaration /* as FunctionLikeDeclaration */)) {
			// Report implicit any error within type if possible, otherwise report error on declaration
			if !tc.reportWideningErrorsInType(type_) {
				tc.reportImplicitAny(declaration, type_, wideningKind)
			}
		}
	})
}

func (tc *TypeChecker) applyToParameterTypes(source Signature, target Signature, callback func(s Type, t Type)) {
	sourceCount := tc.getParameterCount(source)
	targetCount := tc.getParameterCount(target)
	sourceRestType := tc.getEffectiveRestType(source)
	targetRestType := tc.getEffectiveRestType(target)
	var targetNonRestCount number
	if targetRestType {
		targetNonRestCount = targetCount - 1
	} else {
		targetNonRestCount = targetCount
	}
	var paramCount number
	if sourceRestType {
		paramCount = targetNonRestCount
	} else {
		paramCount = Math.min(sourceCount, targetNonRestCount)
	}
	sourceThisType := tc.getThisTypeOfSignature(source)
	if sourceThisType {
		targetThisType := tc.getThisTypeOfSignature(target)
		if targetThisType {
			callback(sourceThisType, targetThisType)
		}
	}
	for i := 0; i < paramCount; i++ {
		callback(tc.getTypeAtPosition(source, i), tc.getTypeAtPosition(target, i))
	}
	if targetRestType {
		callback(tc.getRestTypeAtPosition(source, paramCount /*readonly*/, tc.isConstTypeVariable(targetRestType) && !tc.someType(targetRestType, tc.isMutableArrayLikeType)), targetRestType)
	}
}

func (tc *TypeChecker) applyToReturnTypes(source Signature, target Signature, callback func(s Type, t Type)) {
	targetTypePredicate := tc.getTypePredicateOfSignature(target)
	if targetTypePredicate {
		sourceTypePredicate := tc.getTypePredicateOfSignature(source)
		if sourceTypePredicate && tc.typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type_ && targetTypePredicate.type_ {
			callback(sourceTypePredicate.type_, targetTypePredicate.type_)
			return
		}
	}
	targetReturnType := tc.getReturnTypeOfSignature(target)
	if tc.couldContainTypeVariables(targetReturnType) {
		callback(tc.getReturnTypeOfSignature(source), targetReturnType)
	}
}

func (tc *TypeChecker) createInferenceContext(typeParameters []TypeParameter, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
	return tc.createInferenceContextWorker(typeParameters.map_(tc.createInferenceInfo), signature, flags, compareTypes || tc.compareTypesAssignable)
}

func (tc *TypeChecker) cloneInferenceContext(context T, extraFlags InferenceFlags /*  = 0 */) /* TODO(TS-TO-GO) TypeNode UnionType: InferenceContext | T & undefined */ any {
	return context && tc.createInferenceContextWorker(map_(context.inferences, tc.cloneInferenceInfo), context.signature, context.flags|extraFlags, context.compareTypes)
}

func (tc *TypeChecker) createInferenceContextWorker(inferences []InferenceInfo, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
	var context InferenceContext = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"inferences":      inferences,
		"signature":       signature,
		"flags":           flags,
		"compareTypes":    compareTypes,
		"mapper":          tc.reportUnmeasurableMapper,
		"nonFixingMapper": tc.reportUnmeasurableMapper,
	}
	context.mapper = tc.makeFixingMapperForContext(context)
	context.nonFixingMapper = tc.makeNonFixingMapperForContext(context)
	return context
}

func (tc *TypeChecker) makeFixingMapperForContext(context InferenceContext) TypeMapper {
	return tc.makeDeferredTypeMapper(map_(context.inferences, func(i InferenceInfo) TypeParameter {
		return i.typeParameter
	}), map_(context.inferences, func(inference InferenceInfo, i number) /* TODO(TS-TO-GO) inferred type () => Type */ any {
		return func() Type {
			if !inference.isFixed {
				// Before we commit to a particular inference (and thus lock out any further inferences),
				// we infer from any intra-expression inference sites we have collected.
				tc.inferFromIntraExpressionSites(context)
				tc.clearCachedInferences(context.inferences)
				inference.isFixed = true
			}
			return tc.getInferredType(context, i)
		}
	}))
}

func (tc *TypeChecker) makeNonFixingMapperForContext(context InferenceContext) TypeMapper {
	return tc.makeDeferredTypeMapper(map_(context.inferences, func(i InferenceInfo) TypeParameter {
		return i.typeParameter
	}), map_(context.inferences, func(_ InferenceInfo, i number) /* TODO(TS-TO-GO) inferred type () => Type */ any {
		return func() Type {
			return tc.getInferredType(context, i)
		}
	}))
}

func (tc *TypeChecker) clearCachedInferences(inferences []InferenceInfo) {
	for _, inference := range inferences {
		if !inference.isFixed {
			inference.inferredType = nil
		}
	}
}

func (tc *TypeChecker) addIntraExpressionInferenceSite(context InferenceContext, node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration */ any, type_ Type) {
	( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: context.intraExpressionInferenceSites ??= [] */ TODO).push(map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"node":  node,
		"type_": type_,
	})
}

// We collect intra-expression inference sites within object and array literals to handle cases where
// inferred types flow between context sensitive element expressions. For example:
//
//	declare function foo<T>(arg: [(n: number) => T, (x: T) => void]): void;
//	foo([_a => 0, n => n.toFixed()]);
//
// Above, both arrow functions in the tuple argument are context sensitive, thus both are omitted from the
// pass that collects inferences from the non-context sensitive parts of the arguments. In the subsequent
// pass where nothing is omitted, we need to commit to an inference for T in order to contextually type the
// parameter in the second arrow function, but we want to first infer from the return type of the first
// arrow function. This happens automatically when the arrow functions are discrete arguments (because we
// infer from each argument before processing the next), but when the arrow functions are elements of an
// object or array literal, we need to perform intra-expression inferences early.
func (tc *TypeChecker) inferFromIntraExpressionSites(context InferenceContext) {
	if context.intraExpressionInferenceSites {
		for _, TODO_IDENTIFIER := range context.intraExpressionInferenceSites {
			var contextualType Type
			if node.kind == SyntaxKindMethodDeclaration {
				contextualType = tc.getContextualTypeForObjectLiteralMethod(node /* as MethodDeclaration */, ContextFlagsNoConstraints)
			} else {
				contextualType = tc.getContextualType(node, ContextFlagsNoConstraints)
			}
			if contextualType {
				tc.inferTypes(context.inferences, type_, contextualType)
			}
		}
		context.intraExpressionInferenceSites = nil
	}
}

func (tc *TypeChecker) createInferenceInfo(typeParameter TypeParameter) InferenceInfo {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"typeParameter":    typeParameter,
		"candidates":       nil,
		"contraCandidates": nil,
		"inferredType":     nil,
		"priority":         nil,
		"topLevel":         true,
		"isFixed":          false,
		"impliedArity":     nil,
	}
}

func (tc *TypeChecker) cloneInferenceInfo(inference InferenceInfo) InferenceInfo {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"typeParameter":    inference.typeParameter,
		"candidates":       inference.candidates && inference.candidates.slice(),
		"contraCandidates": inference.contraCandidates && inference.contraCandidates.slice(),
		"inferredType":     inference.inferredType,
		"priority":         inference.priority,
		"topLevel":         inference.topLevel,
		"isFixed":          inference.isFixed,
		"impliedArity":     inference.impliedArity,
	}
}

func (tc *TypeChecker) cloneInferredPartOfContext(context InferenceContext) *InferenceContext {
	inferences := filter(context.inferences, tc.hasInferenceCandidates)
	if inferences.length {
		return tc.createInferenceContextWorker(map_(inferences, tc.cloneInferenceInfo), context.signature, context.flags, context.compareTypes)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getMapperFromContext(context T) /* TODO(TS-TO-GO) TypeNode UnionType: TypeMapper | T & undefined */ any {
	return context && context.mapper
}

// Return true if the given type could possibly reference a type parameter for which
// we perform type inference (i.e. a type parameter of a generic function). We cache
// results for union and intersection types for performance reasons.
func (tc *TypeChecker) couldContainTypeVariables(type_ Type) bool {
	objectFlags := getObjectFlags(type_)
	if objectFlags & ObjectFlagsCouldContainTypeVariablesComputed {
		return !!(objectFlags & ObjectFlagsCouldContainTypeVariables)
	}
	result := !!(type_.flags&TypeFlagsInstantiable || type_.flags&TypeFlagsObject && !tc.isNonGenericTopLevelType(type_) && (objectFlags&ObjectFlagsReference && ((type_ /* as TypeReference */).node || some(tc.getTypeArguments(type_ /* as TypeReference */), tc.couldContainTypeVariables)) || objectFlags&ObjectFlagsSingleSignatureType && !!length((type_ /* as SingleSignatureType */).outerTypeParameters) || objectFlags&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod|SymbolFlagsClass|SymbolFlagsTypeLiteral|SymbolFlagsObjectLiteral) && type_.symbol.declarations || objectFlags&(ObjectFlagsMapped|ObjectFlagsReverseMapped|ObjectFlagsObjectRestType|ObjectFlagsInstantiationExpressionType)) || type_.flags&TypeFlagsUnionOrIntersection && !(type_.flags&TypeFlagsEnumLiteral) && !tc.isNonGenericTopLevelType(type_) && some((type_ /* as UnionOrIntersectionType */).types, tc.couldContainTypeVariables))
	if type_.flags & TypeFlagsObjectFlagsType {
		(type_ /* as ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | (__COND__(result, ObjectFlagsCouldContainTypeVariables, 0))
	}
	return result
}

func (tc *TypeChecker) isNonGenericTopLevelType(type_ Type) bool {
	if type_.aliasSymbol && !type_.aliasTypeArguments {
		declaration := getDeclarationOfKind(type_.aliasSymbol, SyntaxKindTypeAliasDeclaration)
		return !!(declaration && findAncestor(declaration.parent, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			switch {
			case n.kind == SyntaxKindSourceFile:
				return true
			case n.kind == SyntaxKindModuleDeclaration:
				return false
			default:
				return "quit"
			}
		}))
	}
	return false
}

func (tc *TypeChecker) isTypeParameterAtTopLevel(type_ Type, tp TypeParameter, depth number /*  = 0 */) bool {
	return !!(type_ == tp || type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as UnionOrIntersectionType */).types, func(t Type) bool {
		return tc.isTypeParameterAtTopLevel(t, tp, depth)
	}) || depth < 3 && type_.flags&TypeFlagsConditional && (tc.isTypeParameterAtTopLevel(tc.getTrueTypeFromConditionalType(type_ /* as ConditionalType */), tp, depth+1) || tc.isTypeParameterAtTopLevel(tc.getFalseTypeFromConditionalType(type_ /* as ConditionalType */), tp, depth+1)))
}

func (tc *TypeChecker) isTypeParameterAtTopLevelInReturnType(signature Signature, typeParameter TypeParameter) bool {
	typePredicate := tc.getTypePredicateOfSignature(signature)
	if typePredicate {
		return !!typePredicate.type_ && tc.isTypeParameterAtTopLevel(typePredicate.type_, typeParameter)
	} else {
		return tc.isTypeParameterAtTopLevel(tc.getReturnTypeOfSignature(signature), typeParameter)
	}
}

/** Create an object with properties named in the string literal type. Every property has type `any` */

func (tc *TypeChecker) createEmptyObjectTypeFromStringLiteral(type_ Type) ResolvedType {
	members := createSymbolTable()
	tc.forEachType(type_, func(t Type) {
		if !(t.flags & TypeFlagsStringLiteral) {
			return
		}
		name := escapeLeadingUnderscores((t /* as StringLiteralType */).value)
		literalProp := tc.createSymbol(SymbolFlagsProperty, name)
		literalProp.links.type_ = tc.anyType
		if t.symbol {
			literalProp.declarations = t.symbol.declarations
			literalProp.valueDeclaration = t.symbol.valueDeclaration
		}
		members.set(name, literalProp)
	})
	var indexInfos []IndexInfo
	if type_.flags & TypeFlagsString {
		indexInfos = []IndexInfo{tc.createIndexInfo(tc.stringType, tc.emptyObjectType /*isReadonly*/, false)}
	} else {
		indexInfos = emptyArray
	}
	return tc.createAnonymousType(nil, members, emptyArray, emptyArray, indexInfos)
}

/**
 * Infer a suitable input type for a homomorphic mapped type { [P in keyof T]: X }. We construct
 * an object type with the same set of properties as the source type, where the type of each
 * property is computed by inferring from the source property type to X for the type
 * variable T[P] (i.e. we treat the type T[P] as the type variable we're inferring for).
 */

func (tc *TypeChecker) inferTypeForHomomorphicMappedType(source Type, target MappedType, constraint IndexType) Type {
	cacheKey := source.id + "," + target.id + "," + constraint.id
	if tc.reverseHomomorphicMappedCache.has(cacheKey) {
		return tc.reverseHomomorphicMappedCache.get(cacheKey)
	}
	type_ := tc.createReverseMappedType(source, target, constraint)
	tc.reverseHomomorphicMappedCache.set(cacheKey, type_)
	return type_
}

// We consider a type to be partially inferable if it isn't marked non-inferable or if it is
// an object literal type with at least one property of an inferable type. For example, an object
// literal { a: 123, b: x => true } is marked non-inferable because it contains a context sensitive
// arrow function, but is considered partially inferable because property 'a' has an inferable type.
func (tc *TypeChecker) isPartiallyInferableType(type_ Type) bool {
	return !(getObjectFlags(type_) & ObjectFlagsNonInferrableType) || tc.isObjectLiteralType(type_) && some(tc.getPropertiesOfType(type_), func(prop Symbol) bool {
		return tc.isPartiallyInferableType(tc.getTypeOfSymbol(prop))
	}) || tc.isTupleType(type_) && some(tc.getElementTypes(type_), tc.isPartiallyInferableType)
}

func (tc *TypeChecker) createReverseMappedType(source Type, target MappedType, constraint IndexType) Type {
	// We consider a source type reverse mappable if it has a string index signature or if
	// it has one or more properties and is of a partially inferable type.
	if !(tc.getIndexInfoOfType(source, tc.stringType) || tc.getPropertiesOfType(source).length != 0 && tc.isPartiallyInferableType(source)) {
		return nil
	}
	// For arrays and tuples we infer new arrays and tuples where the reverse mapping has been
	// applied to the element type(s).
	if tc.isArrayType(source) {
		elementType := tc.inferReverseMappedType(tc.getTypeArguments(source)[0], target, constraint)
		if !elementType {
			return nil
		}
		return tc.createArrayType(elementType, tc.isReadonlyArrayType(source))
	}
	if tc.isTupleType(source) {
		elementTypes := map_(tc.getElementTypes(source), func(t Type) Type {
			return tc.inferReverseMappedType(t, target, constraint)
		})
		if !every(elementTypes, func(t Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: t is Type */ any {
			return !!t
		}) {
			return nil
		}
		var elementFlags []ElementFlags
		if tc.getMappedTypeModifiers(target) & MappedTypeModifiersIncludeOptional {
			elementFlags = sameMap(source.target.elementFlags, func(f ElementFlags) ElementFlags {
				if f & ElementFlagsOptional {
					return ElementFlagsRequired
				} else {
					return f
				}
			})
		} else {
			elementFlags = source.target.elementFlags
		}
		return tc.createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations)
	}
	// For all other object types we infer a new object type where the reverse mapping has been
	// applied to the type of each property.
	reversed := tc.createObjectType(ObjectFlagsReverseMapped|ObjectFlagsAnonymous /*symbol*/, nil) /* as ReverseMappedType */
	reversed.source = source
	reversed.mappedType = target
	reversed.constraintType = constraint
	return reversed
}

func (tc *TypeChecker) getTypeOfReverseMappedSymbol(symbol ReverseMappedSymbol) Type {
	links := tc.getSymbolLinks(symbol)
	if !links.type_ {
		links.type_ = tc.inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || tc.unknownType
	}
	return links.type_
}

func (tc *TypeChecker) inferReverseMappedTypeWorker(sourceType Type, target MappedType, constraint IndexType) Type {
	typeParameter := tc.getIndexedAccessType(constraint.type_, tc.getTypeParameterFromMappedType(target)) /* as TypeParameter */
	templateType := tc.getTemplateTypeFromMappedType(target)
	inference := tc.createInferenceInfo(typeParameter)
	tc.inferTypes([]InferenceInfo{inference}, sourceType, templateType)
	return tc.getTypeFromInference(inference) || tc.unknownType
}

func (tc *TypeChecker) inferReverseMappedType(source Type, target MappedType, constraint IndexType) Type {
	cacheKey := source.id + "," + target.id + "," + constraint.id
	if tc.reverseMappedCache.has(cacheKey) {
		return tc.reverseMappedCache.get(cacheKey) || tc.unknownType
	}
	tc.reverseMappedSourceStack.push(source)
	tc.reverseMappedTargetStack.push(target)
	saveExpandingFlags := tc.reverseExpandingFlags
	if tc.isDeeplyNestedType(source, tc.reverseMappedSourceStack, tc.reverseMappedSourceStack.length, 2) {
		tc.reverseExpandingFlags |= ExpandingFlagsSource
	}
	if tc.isDeeplyNestedType(target, tc.reverseMappedTargetStack, tc.reverseMappedTargetStack.length, 2) {
		tc.reverseExpandingFlags |= ExpandingFlagsTarget
	}
	var type_ TODO
	if tc.reverseExpandingFlags != ExpandingFlagsBoth {
		type_ = tc.inferReverseMappedTypeWorker(source, target, constraint)
	}
	tc.reverseMappedSourceStack.pop()
	tc.reverseMappedTargetStack.pop()
	tc.reverseExpandingFlags = saveExpandingFlags
	tc.reverseMappedCache.set(cacheKey, type_)
	return type_
}

func (tc *TypeChecker) getUnmatchedProperties(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) IterableIterator[Symbol] {
	properties := tc.getPropertiesOfType(target)
	for _, targetProp := range properties {
		// TODO: remove this when we support static private identifier fields and find other solutions to get privateNamesAndStaticFields test to pass
		if tc.isStaticPrivateIdentifierProperty(targetProp) {
			continue
		}
		if requireOptionalProperties || !(targetProp.flags&SymbolFlagsOptional || getCheckFlags(targetProp)&CheckFlagsPartial) {
			sourceProp := tc.getPropertyOfType(source, targetProp.escapedName)
			if !sourceProp {
				yield(targetProp)
			} else if matchDiscriminantProperties {
				targetType := tc.getTypeOfSymbol(targetProp)
				if targetType.flags & TypeFlagsUnit {
					sourceType := tc.getTypeOfSymbol(sourceProp)
					if !(sourceType.flags&TypeFlagsAny || tc.getRegularTypeOfLiteralType(sourceType) == tc.getRegularTypeOfLiteralType(targetType)) {
						yield(targetProp)
					}
				}
			}
		}
	}
}

func (tc *TypeChecker) getUnmatchedProperty(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) Symbol {
	return firstOrUndefinedIterator(tc.getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties))
}

func (tc *TypeChecker) tupleTypesDefinitelyUnrelated(source TupleTypeReference, target TupleTypeReference) bool {
	return !(target.target.combinedFlags&ElementFlagsVariadic) && target.target.minLength > source.target.minLength || !(target.target.combinedFlags&ElementFlagsVariable) && (!!(source.target.combinedFlags&ElementFlagsVariable) || target.target.fixedLength < source.target.fixedLength)
}

func (tc *TypeChecker) typesDefinitelyUnrelated(source Type, target Type) bool {
	// Two tuple types with incompatible arities are definitely unrelated.
	// Two object types that each have a property that is unmatched in the other are definitely unrelated.
	if tc.isTupleType(source) && tc.isTupleType(target) {
		return tc.tupleTypesDefinitelyUnrelated(source, target)
	} else {
		return !!tc.getUnmatchedProperty(source, target /*requireOptionalProperties*/, false /*matchDiscriminantProperties*/, true) && !!tc.getUnmatchedProperty(target, source /*requireOptionalProperties*/, false /*matchDiscriminantProperties*/, false)
	}
}

func (tc *TypeChecker) getTypeFromInference(inference InferenceInfo) Type {
	switch {
	case inference.candidates:
		return tc.getUnionType(inference.candidates, UnionReductionSubtype)
	case inference.contraCandidates:
		return tc.getIntersectionType(inference.contraCandidates)
	default:
		return nil
	}
}

func (tc *TypeChecker) hasSkipDirectInferenceFlag(node Node) bool {
	return !!tc.getNodeLinks(node).skipDirectInference
}

func (tc *TypeChecker) isFromInferenceBlockedSource(type_ Type) bool {
	return !!(type_.symbol && some(type_.symbol.declarations, tc.hasSkipDirectInferenceFlag))
}

func (tc *TypeChecker) templateLiteralTypesDefinitelyUnrelated(source TemplateLiteralType, target TemplateLiteralType) bool {
	// Two template literal types with diffences in their starting or ending text spans are definitely unrelated.
	sourceStart := source.texts[0]
	targetStart := target.texts[0]
	sourceEnd := source.texts[source.texts.length-1]
	targetEnd := target.texts[target.texts.length-1]
	startLen := Math.min(sourceStart.length, targetStart.length)
	endLen := Math.min(sourceEnd.length, targetEnd.length)
	return sourceStart.slice(0, startLen) != targetStart.slice(0, startLen) || sourceEnd.slice(sourceEnd.length-endLen) != targetEnd.slice(targetEnd.length-endLen)
}

/**
 * Tests whether the provided string can be parsed as a number.
 * @param s The string to test.
 * @param roundTripOnly Indicates the resulting number matches the input when converted back to a string.
 */

func (tc *TypeChecker) isValidNumberString(s string, roundTripOnly bool) bool {
	if s == "" {
		return false
	}
	n := +s
	return isFinite(n) && (!roundTripOnly || ""+n == s)
}

/**
 * @param text a valid bigint string excluding a trailing `n`, but including a possible prefix `-`. Use `isValidBigIntString(text, roundTripOnly)` before calling this function.
 */

func (tc *TypeChecker) parseBigIntLiteralType(text string) BigIntLiteralType {
	return tc.getBigIntLiteralType(parseValidBigInt(text))
}

func (tc *TypeChecker) isMemberOfStringMapping(source Type, target Type) bool {
	if target.flags & TypeFlagsAny {
		return true
	}
	if target.flags & (TypeFlagsString | TypeFlagsTemplateLiteral) {
		return tc.isTypeAssignableTo(source, target)
	}
	if target.flags & TypeFlagsStringMapping {
		// We need to see whether applying the same mappings of the target
		// onto the source would produce an identical type *and* that
		// it's compatible with the inner-most non-string-mapped type.
		//
		// The intuition here is that if same mappings don't affect the source at all,
		// and the source is compatible with the unmapped target, then they must
		// still reside in the same domain.
		mappingStack := []never{}
		for target.flags & TypeFlagsStringMapping {
			mappingStack.unshift(target.symbol)
			target = (target /* as StringMappingType */).type_
		}
		mappedSource := reduceLeft(mappingStack, func(memo Type, value Symbol) Type {
			return tc.getStringMappingType(value, memo)
		}, source)
		return mappedSource == source && tc.isMemberOfStringMapping(source, target)
	}
	return false
}

func (tc *TypeChecker) isValidTypeForTemplateLiteralPlaceholder(source Type, target Type) bool {
	if target.flags & TypeFlagsIntersection {
		return every((target /* as IntersectionType */).types, func(t Type) bool {
			return t == tc.emptyTypeLiteralType || tc.isValidTypeForTemplateLiteralPlaceholder(source, t)
		})
	}
	if target.flags&TypeFlagsString || tc.isTypeAssignableTo(source, target) {
		return true
	}
	if source.flags & TypeFlagsStringLiteral {
		value := (source /* as StringLiteralType */).value
		return !!(target.flags&TypeFlagsNumber && tc.isValidNumberString(value /*roundTripOnly*/, false) || target.flags&TypeFlagsBigInt && isValidBigIntString(value /*roundTripOnly*/, false) || target.flags&(TypeFlagsBooleanLiteral|TypeFlagsNullable) && value == (target /* as IntrinsicType */).intrinsicName || target.flags&TypeFlagsStringMapping && tc.isMemberOfStringMapping(tc.getStringLiteralType(value), target) || target.flags&TypeFlagsTemplateLiteral && tc.isTypeMatchedByTemplateLiteralType(source, target /* as TemplateLiteralType */))
	}
	if source.flags & TypeFlagsTemplateLiteral {
		texts := (source /* as TemplateLiteralType */).texts
		return texts.length == 2 && texts[0] == "" && texts[1] == "" && tc.isTypeAssignableTo((source /* as TemplateLiteralType */).types[0], target)
	}
	return false
}

func (tc *TypeChecker) inferTypesFromTemplateLiteralType(source Type, target TemplateLiteralType) *[]Type {
	switch {
	case source.flags & TypeFlagsStringLiteral:
		return tc.inferFromLiteralPartsToTemplateLiteral([]string{(source /* as StringLiteralType */).value}, emptyArray, target)
	case source.flags & TypeFlagsTemplateLiteral:
		if arrayIsEqualTo((source /* as TemplateLiteralType */).texts, target.texts) {
			return map_((source /* as TemplateLiteralType */).types, func(s Type, i number) Type {
				if tc.isTypeAssignableTo(tc.getBaseConstraintOrType(s), tc.getBaseConstraintOrType(target.types[i])) {
					return s
				} else {
					return tc.getStringLikeTypeForType(s)
				}
			})
		} else {
			return tc.inferFromLiteralPartsToTemplateLiteral((source /* as TemplateLiteralType */).texts, (source /* as TemplateLiteralType */).types, target)
		}
	default:
		return nil
	}
}

func (tc *TypeChecker) isTypeMatchedByTemplateLiteralType(source Type, target TemplateLiteralType) bool {
	inferences := tc.inferTypesFromTemplateLiteralType(source, target)
	return !!inferences && every(inferences, func(r Type, i number) bool {
		return tc.isValidTypeForTemplateLiteralPlaceholder(r, target.types[i])
	})
}

func (tc *TypeChecker) getStringLikeTypeForType(type_ Type) Type {
	if type_.flags & (TypeFlagsAny | TypeFlagsStringLike) {
		return type_
	} else {
		return tc.getTemplateLiteralType([]string{"", ""}, []Type{type_})
	}
}

// This function infers from the text parts and type parts of a source literal to a target template literal. The number
// of text parts is always one more than the number of type parts, and a source string literal is treated as a source
// with one text part and zero type parts. The function returns an array of inferred string or template literal types
// corresponding to the placeholders in the target template literal, or undefined if the source doesn't match the target.
//
// We first check that the starting source text part matches the starting target text part, and that the ending source
// text part ends matches the ending target text part. We then iterate through the remaining target text parts, finding
// a match for each in the source and inferring string or template literal types created from the segments of the source
// that occur between the matches. During this iteration, seg holds the index of the current text part in the sourceTexts
// array and pos holds the current character position in the current text part.
//
// Consider inference from type `<<${string}>.<${number}-${number}>>` to type `<${string}.${string}>`, i.e.
//
//	sourceTexts = ['<<', '>.<', '-', '>>']
//	sourceTypes = [string, number, number]
//	target.texts = ['<', '.', '>']
//
// We first match '<' in the target to the start of '<<' in the source and '>' in the target to the end of '>>' in
// the source. The first match for the '.' in target occurs at character 1 in the source text part at index 1, and thus
// the first inference is the template literal type `<${string}>`. The remainder of the source makes up the second
// inference, the template literal type `<${number}-${number}>`.
func (tc *TypeChecker) inferFromLiteralPartsToTemplateLiteral(sourceTexts []string, sourceTypes []Type, target TemplateLiteralType) *[]Type {
	lastSourceIndex := sourceTexts.length - 1
	sourceStartText := sourceTexts[0]
	sourceEndText := sourceTexts[lastSourceIndex]
	targetTexts := target.texts
	lastTargetIndex := targetTexts.length - 1
	targetStartText := targetTexts[0]
	targetEndText := targetTexts[lastTargetIndex]
	if lastSourceIndex == 0 && sourceStartText.length < targetStartText.length+targetEndText.length || !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText) {
		return nil
	}
	remainingEndText := sourceEndText.slice(0, sourceEndText.length-targetEndText.length)
	var matches []Type = []never{}
	seg := 0
	pos := targetStartText.length
	for i := 1; i < lastTargetIndex; i++ {
		delim := targetTexts[i]
		if delim.length > 0 {
			s := seg
			p := pos
			for true {
				p = getSourceText(s).indexOf(delim, p)
				if p >= 0 {
					break
				}
				s++
				if s == sourceTexts.length {
					return nil
				}
				p = 0
			}
			addMatch(s, p)
			pos += delim.length
		} else if pos < getSourceText(seg).length {
			addMatch(seg, pos+1)
		} else if seg < lastSourceIndex {
			addMatch(seg+1, 0)
		} else {
			return nil
		}
	}
	addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length)
	return matches
	getSourceText := func(index number) string {
		if index < lastSourceIndex {
			return sourceTexts[index]
		} else {
			return remainingEndText
		}
	}

	addMatch := func(s number, p number) {
		var matchType Type
		if s == seg {
			matchType = tc.getStringLiteralType(getSourceText(s).slice(pos, p))
		} else {
			matchType = tc.getTemplateLiteralType([]string{sourceTexts[seg].slice(pos) /* TODO(TS-TO-GO) Node SpreadElement: ...sourceTexts.slice(seg + 1, s) */, getSourceText(s).slice(0, p)}, sourceTypes.slice(seg, s))
		}
		matches.push(matchType)
		seg = s
		pos = p
	}

}

/**
 * @returns `true` if `type` has the shape `[T[0]]` where `T` is `typeParameter`
 */

func (tc *TypeChecker) isTupleOfSelf(typeParameter TypeParameter, type_ Type) bool {
	return tc.isTupleType(type_) && tc.getTupleElementType(type_, 0) == tc.getIndexedAccessType(typeParameter, tc.getNumberLiteralType(0)) && !tc.getTypeOfPropertyOfType(type_, "1" /* as __String */)
}

func (tc *TypeChecker) inferTypes(inferences []InferenceInfo, originalSource Type, originalTarget Type, priority InferencePriority /*  = InferencePriority.None */, contravariant bool /*  = false */) {
	bivariant := false
	var propagationType Type
	var inferencePriority number = InferencePriorityMaxValue
	var visited Map[string, number]
	var sourceStack []Type
	var targetStack []Type
	expandingFlags := ExpandingFlagsNone
	inferFromTypes(originalSource, originalTarget)

	inferFromTypes := func(source Type, target Type) {
		if !tc.couldContainTypeVariables(target) || tc.isNoInferType(target) {
			return
		}
		if source == tc.wildcardType || source == tc.blockedStringType {
			// We are inferring from an 'any' type. We want to infer this type for every type parameter
			// referenced in the target type, so we record it as the propagation type and infer from the
			// target to itself. Then, as we find candidates we substitute the propagation type.
			savePropagationType := propagationType
			propagationType = source
			inferFromTypes(target, target)
			propagationType = savePropagationType
			return
		}
		if source.aliasSymbol && source.aliasSymbol == target.aliasSymbol {
			if source.aliasTypeArguments {
				// Source and target are types originating in the same generic type alias declaration.
				// Simply infer from source type arguments to target type arguments, with defaults applied.
				params := tc.getSymbolLinks(source.aliasSymbol).typeParameters
				minParams := tc.getMinTypeArgumentCount(params)
				sourceTypes := tc.fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				targetTypes := tc.fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				inferFromTypeArguments(sourceTypes, targetTypes, tc.getAliasVariances(source.aliasSymbol))
			}
			// And if there weren't any type arguments, there's no reason to run inference as the types must be the same.
			return
		}
		if source == target && source.flags&TypeFlagsUnionOrIntersection {
			// When source and target are the same union or intersection type, just relate each constituent
			// type to itself.
			for _, t := range (source /* as UnionOrIntersectionType */).types {
				inferFromTypes(t, t)
			}
			return
		}
		if target.flags & TypeFlagsUnion {
			// First, infer between identically matching source and target constituents and remove the
			// matching types.
			TODO_IDENTIFIER := inferFromMatchingTypes(__COND__(source.flags&TypeFlagsUnion, (source /* as UnionType */).types, []Type{source}), (target /* as UnionType */).types, tc.isTypeOrBaseIdenticalTo)
			// Next, infer between closely matching source and target constituents and remove
			// the matching types. Types closely match when they are instantiations of the same
			// object type or instantiations of the same type alias.
			TODO_IDENTIFIER := inferFromMatchingTypes(tempSources, tempTargets, tc.isTypeCloselyMatchedBy)
			if targets.length == 0 {
				return
			}
			target = tc.getUnionType(targets)
			if sources.length == 0 {
				// All source constituents have been matched and there is nothing further to infer from.
				// However, simply making no inferences is undesirable because it could ultimately mean
				// inferring a type parameter constraint. Instead, make a lower priority inference from
				// the full source to whatever remains in the target. For example, when inferring from
				// string to 'string | T', make a lower priority inference of string for T.
				inferWithPriority(source, target, InferencePriorityNakedTypeVariable)
				return
			}
			source = tc.getUnionType(sources)
		} else if target.flags&TypeFlagsIntersection && !every((target /* as IntersectionType */).types, tc.isNonGenericObjectType) {
			// We reduce intersection types unless they're simple combinations of object types. For example,
			// when inferring from 'string[] & { extra: any }' to 'string[] & T' we want to remove string[] and
			// infer { extra: any } for T. But when inferring to 'string[] & Iterable<T>' we want to keep the
			// string[] on the source side and infer string for T.
			if !(source.flags & TypeFlagsUnion) {
				// Infer between identically matching source and target constituents and remove the matching types.
				TODO_IDENTIFIER := inferFromMatchingTypes(__COND__(source.flags&TypeFlagsIntersection, (source /* as IntersectionType */).types, []Type{source}), (target /* as IntersectionType */).types, tc.isTypeIdenticalTo)
				if sources.length == 0 || targets.length == 0 {
					return
				}
				source = tc.getIntersectionType(sources)
				target = tc.getIntersectionType(targets)
			}
		}
		if target.flags & (TypeFlagsIndexedAccess | TypeFlagsSubstitution) {
			if tc.isNoInferType(target) {
				return
			}
			target = tc.getActualTypeVariable(target)
		}
		if target.flags & TypeFlagsTypeVariable {
			// Skip inference if the source is "blocked", which is used by the language service to
			// prevent inference on nodes currently being edited.
			if tc.isFromInferenceBlockedSource(source) {
				return
			}
			inference := getInferenceInfoForType(target)
			if inference {
				// If target is a type parameter, make an inference, unless the source type contains
				// a "non-inferrable" type. Types with this flag set are markers used to prevent inference.
				//
				// For example:
				//     - anyFunctionType is a wildcard type that's used to avoid contextually typing functions;
				//       it's internal, so should not be exposed to the user by adding it as a candidate.
				//     - autoType (and autoArrayType) is a special "any" used in control flow; like anyFunctionType,
				//       it's internal and should not be observable.
				//     - silentNeverType is returned by getInferredType when instantiating a generic function for
				//       inference (and a type variable has no mapping).
				//
				// This flag is infectious; if we produce Box<never> (where never is silentNeverType), Box<never> is
				// also non-inferrable.
				//
				// As a special case, also ignore nonInferrableAnyType, which is a special form of the any type
				// used as a stand-in for binding elements when they are being inferred.
				if getObjectFlags(source)&ObjectFlagsNonInferrableType || source == tc.nonInferrableAnyType {
					return
				}
				if !inference.isFixed {
					candidate := propagationType || source
					if candidate == tc.blockedStringType {
						return
					}
					if inference.priority == nil || priority < inference.priority {
						inference.candidates = nil
						inference.contraCandidates = nil
						inference.topLevel = true
						inference.priority = priority
					}
					if priority == inference.priority {
						// Inferring A to [A[0]] is a zero information inference (it guarantees A becomes its constraint), but oft arises from generic argument list inferences
						// By discarding it early, we can allow more fruitful results to be used instead.
						if tc.isTupleOfSelf(inference.typeParameter, candidate) {
							return
						}
						// We make contravariant inferences only if we are in a pure contravariant position,
						// i.e. only if we have not descended into a bivariant position.
						if contravariant && !bivariant {
							if !contains(inference.contraCandidates, candidate) {
								inference.contraCandidates = append(inference.contraCandidates, candidate)
								tc.clearCachedInferences(inferences)
							}
						} else if !contains(inference.candidates, candidate) {
							inference.candidates = append(inference.candidates, candidate)
							tc.clearCachedInferences(inferences)
						}
					}
					if !(priority & InferencePriorityReturnType) && target.flags&TypeFlagsTypeParameter && inference.topLevel && !tc.isTypeParameterAtTopLevel(originalTarget, target /* as TypeParameter */) {
						inference.topLevel = false
						tc.clearCachedInferences(inferences)
					}
				}
				inferencePriority = Math.min(inferencePriority, priority)
				return
			}
			// Infer to the simplified version of an indexed access, if possible, to (hopefully) expose more bare type parameters to the inference engine
			simplified := tc.getSimplifiedType(target /*writing*/, false)
			if simplified != target {
				inferFromTypes(source, simplified)
			} else if target.flags & TypeFlagsIndexedAccess {
				indexType := tc.getSimplifiedType((target /* as IndexedAccessType */).indexType /*writing*/, false)
				// Generally simplifications of instantiable indexes are avoided to keep relationship checking correct, however if our target is an access, we can consider
				// that key of that access to be "instantiated", since we're looking to find the infernce goal in any way we can.
				if indexType.flags & TypeFlagsInstantiable {
					simplified := tc.distributeIndexOverObjectType(tc.getSimplifiedType((target /* as IndexedAccessType */).objectType /*writing*/, false), indexType /*writing*/, false)
					if simplified && simplified != target {
						inferFromTypes(source, simplified)
					}
				}
			}
		}
		if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source /* as TypeReference */).target == (target /* as TypeReference */).target || tc.isArrayType(source) && tc.isArrayType(target)) && !((source /* as TypeReference */).node && (target /* as TypeReference */).node) {
			// If source and target are references to the same generic type, infer from type arguments
			inferFromTypeArguments(tc.getTypeArguments(source /* as TypeReference */), tc.getTypeArguments(target /* as TypeReference */), tc.getVariances((source /* as TypeReference */).target))
		} else if source.flags&TypeFlagsIndex && target.flags&TypeFlagsIndex {
			inferFromContravariantTypes((source /* as IndexType */).type_, (target /* as IndexType */).type_)
		} else if (tc.isLiteralType(source) || source.flags&TypeFlagsString) && target.flags&TypeFlagsIndex {
			empty := tc.createEmptyObjectTypeFromStringLiteral(source)
			inferFromContravariantTypesWithPriority(empty, (target /* as IndexType */).type_, InferencePriorityLiteralKeyof)
		} else if source.flags&TypeFlagsIndexedAccess && target.flags&TypeFlagsIndexedAccess {
			inferFromTypes((source /* as IndexedAccessType */).objectType, (target /* as IndexedAccessType */).objectType)
			inferFromTypes((source /* as IndexedAccessType */).indexType, (target /* as IndexedAccessType */).indexType)
		} else if source.flags&TypeFlagsStringMapping && target.flags&TypeFlagsStringMapping {
			if (source /* as StringMappingType */).symbol == (target /* as StringMappingType */).symbol {
				inferFromTypes((source /* as StringMappingType */).type_, (target /* as StringMappingType */).type_)
			}
		} else if source.flags & TypeFlagsSubstitution {
			inferFromTypes((source /* as SubstitutionType */).baseType, target)
			inferWithPriority(tc.getSubstitutionIntersection(source /* as SubstitutionType */), target, InferencePrioritySubstituteSource)
			// Make substitute inference at a lower priority
		} else if target.flags & TypeFlagsConditional {
			invokeOnce(source, target /* as ConditionalType */, inferToConditionalType)
		} else if target.flags & TypeFlagsUnionOrIntersection {
			inferToMultipleTypes(source, (target /* as UnionOrIntersectionType */).types, target.flags)
		} else if source.flags & TypeFlagsUnion {
			// Source is a union or intersection type, infer from each constituent type
			sourceTypes := (source /* as UnionOrIntersectionType */).types
			for _, sourceType := range sourceTypes {
				inferFromTypes(sourceType, target)
			}
		} else if target.flags & TypeFlagsTemplateLiteral {
			inferToTemplateLiteralType(source, target /* as TemplateLiteralType */)
		} else {
			source = tc.getReducedType(source)
			if tc.isGenericMappedType(source) && tc.isGenericMappedType(target) {
				invokeOnce(source, target, inferFromGenericMappedTypes)
			}
			if !(priority&InferencePriorityNoConstraints && source.flags&(TypeFlagsIntersection|TypeFlagsInstantiable)) {
				apparentSource := tc.getApparentType(source)
				// getApparentType can return _any_ type, since an indexed access or conditional may simplify to any other type.
				// If that occurs and it doesn't simplify to an object or intersection, we'll need to restart `inferFromTypes`
				// with the simplified source.
				if apparentSource != source && !(apparentSource.flags & (TypeFlagsObject | TypeFlagsIntersection)) {
					return inferFromTypes(apparentSource, target)
				}
				source = apparentSource
			}
			if source.flags & (TypeFlagsObject | TypeFlagsIntersection) {
				invokeOnce(source, target, inferFromObjectTypes)
			}
		}
	}

	inferWithPriority := func(source Type, target Type, newPriority InferencePriority) {
		savePriority := priority
		priority |= newPriority
		inferFromTypes(source, target)
		priority = savePriority
	}

	inferFromContravariantTypesWithPriority := func(source Type, target Type, newPriority InferencePriority) {
		savePriority := priority
		priority |= newPriority
		inferFromContravariantTypes(source, target)
		priority = savePriority
	}

	inferToMultipleTypesWithPriority := func(source Type, targets []Type, targetFlags TypeFlags, newPriority InferencePriority) {
		savePriority := priority
		priority |= newPriority
		inferToMultipleTypes(source, targets, targetFlags)
		priority = savePriority
	}

	// Ensure an inference action is performed only once for the given source and target types.
	// This includes two things:
	// Avoiding inferring between the same pair of source and target types,
	// and avoiding circularly inferring between source and target types.
	// For an example of the last, consider if we are inferring between source type
	// `type Deep<T> = { next: Deep<Deep<T>> }` and target type `type Loop<U> = { next: Loop<U> }`.
	// We would then infer between the types of the `next` property: `Deep<Deep<T>>` = `{ next: Deep<Deep<Deep<T>>> }` and `Loop<U>` = `{ next: Loop<U> }`.
	// We will then infer again between the types of the `next` property:
	// `Deep<Deep<Deep<T>>>` and `Loop<U>`, and so on, such that we would be forever inferring
	// between instantiations of the same types `Deep` and `Loop`.
	// In particular, we would be inferring from increasingly deep instantiations of `Deep` to `Loop`,
	// such that we would go on inferring forever, even though we would never infer
	// between the same pair of types.
	invokeOnce := func(source Source, target Target, action func(source Source, target Target)) {
		key := source.id + "," + target.id
		status := visited && visited.get(key)
		if status != nil {
			inferencePriority = Math.min(inferencePriority, status)
			return
		}
		(visited || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: visited = new Map<string, number>() */ TODO)).set(key, InferencePriorityCircularity)
		saveInferencePriority := inferencePriority
		inferencePriority = InferencePriorityMaxValue
		// We stop inferring and report a circularity if we encounter duplicate recursion identities on both
		// the source side and the target side.
		saveExpandingFlags := expandingFlags
		( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: sourceStack ??= [] */ TODO).push(source)
		( /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: targetStack ??= [] */ TODO).push(target)
		if tc.isDeeplyNestedType(source, sourceStack, sourceStack.length, 2) {
			expandingFlags |= ExpandingFlagsSource
		}
		if tc.isDeeplyNestedType(target, targetStack, targetStack.length, 2) {
			expandingFlags |= ExpandingFlagsTarget
		}
		if expandingFlags != ExpandingFlagsBoth {
			action(source, target)
		} else {
			inferencePriority = InferencePriorityCircularity
		}
		targetStack.pop()
		sourceStack.pop()
		expandingFlags = saveExpandingFlags
		visited.set(key, inferencePriority)
		inferencePriority = Math.min(inferencePriority, saveInferencePriority)
	}

	inferFromMatchingTypes := func(sources []Type, targets []Type, matches func(s Type, t Type) bool) /* TODO(TS-TO-GO) TypeNode TupleType: [Type[], Type[]] */ any {
		var matchedSources *[]Type
		var matchedTargets *[]Type
		for _, t := range targets {
			for _, s := range sources {
				if matches(s, t) {
					inferFromTypes(s, t)
					matchedSources = appendIfUnique(matchedSources, s)
					matchedTargets = appendIfUnique(matchedTargets, t)
				}
			}
		}
		return []any{__COND__(matchedSources, filter(sources, func(t Type) bool {
			return !contains(matchedSources, t)
		}), sources), __COND__(matchedTargets, filter(targets, func(t Type) bool {
			return !contains(matchedTargets, t)
		}), targets)}
	}

	inferFromTypeArguments := func(sourceTypes []Type, targetTypes []Type, variances []VarianceFlags) {
		var count number
		if sourceTypes.length < targetTypes.length {
			count = sourceTypes.length
		} else {
			count = targetTypes.length
		}
		for i := 0; i < count; i++ {
			if i < variances.length && (variances[i]&VarianceFlagsVarianceMask) == VarianceFlagsContravariant {
				inferFromContravariantTypes(sourceTypes[i], targetTypes[i])
			} else {
				inferFromTypes(sourceTypes[i], targetTypes[i])
			}
		}
	}

	inferFromContravariantTypes := func(source Type, target Type) {
		contravariant = !contravariant
		inferFromTypes(source, target)
		contravariant = !contravariant
	}

	inferFromContravariantTypesIfStrictFunctionTypes := func(source Type, target Type) {
		if tc.strictFunctionTypes || priority&InferencePriorityAlwaysStrict {
			inferFromContravariantTypes(source, target)
		} else {
			inferFromTypes(source, target)
		}
	}

	getInferenceInfoForType := func(type_ Type) *InferenceInfo {
		if type_.flags & TypeFlagsTypeVariable {
			for _, inference := range inferences {
				if type_ == inference.typeParameter {
					return inference
				}
			}
		}
		return nil
	}

	getSingleTypeVariableFromIntersectionTypes := func(types []Type) Type {
		var typeVariable Type
		for _, type_ := range types {
			t := type_.flags&TypeFlagsIntersection && find((type_ /* as IntersectionType */).types, func(t Type) bool {
				return !!getInferenceInfoForType(t)
			})
			if !t || typeVariable && t != typeVariable {
				return nil
			}
			typeVariable = t
		}
		return typeVariable
	}

	inferToMultipleTypes := func(source Type, targets []Type, targetFlags TypeFlags) {
		typeVariableCount := 0
		if targetFlags & TypeFlagsUnion {
			var nakedTypeVariable Type
			var sources []Type
			if source.flags & TypeFlagsUnion {
				sources = (source /* as UnionType */).types
			} else {
				sources = []Type{source}
			}
			matched := NewArray[bool](sources.length)
			inferenceCircularity := false
			// First infer to types that are not naked type variables. For each source type we
			// track whether inferences were made from that particular type to some target with
			// equal priority (i.e. of equal quality) to what we would infer for a naked type
			// parameter.
			for _, t := range targets {
				if getInferenceInfoForType(t) {
					nakedTypeVariable = t
					typeVariableCount++
				} else {
					for i := 0; i < sources.length; i++ {
						saveInferencePriority := inferencePriority
						inferencePriority = InferencePriorityMaxValue
						inferFromTypes(sources[i], t)
						if inferencePriority == priority {
							matched[i] = true
						}
						inferenceCircularity = inferenceCircularity || inferencePriority == InferencePriorityCircularity
						inferencePriority = Math.min(inferencePriority, saveInferencePriority)
					}
				}
			}
			if typeVariableCount == 0 {
				// If every target is an intersection of types containing a single naked type variable,
				// make a lower priority inference to that type variable. This handles inferring from
				// 'A | B' to 'T & (X | Y)' where we want to infer 'A | B' for T.
				intersectionTypeVariable := getSingleTypeVariableFromIntersectionTypes(targets)
				if intersectionTypeVariable {
					inferWithPriority(source, intersectionTypeVariable, InferencePriorityNakedTypeVariable)
				}
				return
			}
			// If the target has a single naked type variable and no inference circularities were
			// encountered above (meaning we explored the types fully), create a union of the source
			// types from which no inferences have been made so far and infer from that union to the
			// naked type variable.
			if typeVariableCount == 1 && !inferenceCircularity {
				unmatched := flatMap(sources, func(s Type, i number) Type {
					if matched[i] {
						return nil
					} else {
						return s
					}
				})
				if unmatched.length {
					inferFromTypes(tc.getUnionType(unmatched), nakedTypeVariable)
					return
				}
			}
		} else {
			// We infer from types that are not naked type variables first so that inferences we
			// make from nested naked type variables and given slightly higher priority by virtue
			// of being first in the candidates array.
			for _, t := range targets {
				if getInferenceInfoForType(t) {
					typeVariableCount++
				} else {
					inferFromTypes(source, t)
				}
			}
		}
		// Inferences directly to naked type variables are given lower priority as they are
		// less specific. For example, when inferring from Promise<string> to T | Promise<T>,
		// we want to infer string for T, not Promise<string> | string. For intersection types
		// we only infer to single naked type variables.
		if __COND__(targetFlags&TypeFlagsIntersection, typeVariableCount == 1, typeVariableCount > 0) {
			for _, t := range targets {
				if getInferenceInfoForType(t) {
					inferWithPriority(source, t, InferencePriorityNakedTypeVariable)
				}
			}
		}
	}

	inferToMappedType := func(source Type, target MappedType, constraintType Type) bool {
		if (constraintType.flags & TypeFlagsUnion) || (constraintType.flags & TypeFlagsIntersection) {
			result := false
			for _, type_ := range (constraintType /* as (UnionType | IntersectionType) */).types {
				result = inferToMappedType(source, target, type_) || result
			}
			return result
		}
		if constraintType.flags & TypeFlagsIndex {
			// We're inferring from some source type S to a homomorphic mapped type { [P in keyof T]: X },
			// where T is a type variable. Use inferTypeForHomomorphicMappedType to infer a suitable source
			// type and then make a secondary inference from that type to T. We make a secondary inference
			// such that direct inferences to T get priority over inferences to Partial<T>, for example.
			inference := getInferenceInfoForType((constraintType /* as IndexType */).type_)
			if inference && !inference.isFixed && !tc.isFromInferenceBlockedSource(source) {
				inferredType := tc.inferTypeForHomomorphicMappedType(source, target, constraintType /* as IndexType */)
				if inferredType {
					// We assign a lower priority to inferences made from types containing non-inferrable
					// types because we may only have a partial result (i.e. we may have failed to make
					// reverse inferences for some properties).
					inferWithPriority(inferredType, inference.typeParameter, __COND__(getObjectFlags(source)&ObjectFlagsNonInferrableType, InferencePriorityPartialHomomorphicMappedType, InferencePriorityHomomorphicMappedType))
				}
			}
			return true
		}
		if constraintType.flags & TypeFlagsTypeParameter {
			// We're inferring from some source type S to a mapped type { [P in K]: X }, where K is a type
			// parameter. First infer from 'keyof S' to K.
			inferWithPriority(tc.getIndexType(source /*indexFlags*/, __COND__(!!source.pattern, IndexFlagsNoIndexSignatures, IndexFlagsNone)), constraintType, InferencePriorityMappedTypeConstraint)
			// If K is constrained to a type C, also infer to C. Thus, for a mapped type { [P in K]: X },
			// where K extends keyof T, we make the same inferences as for a homomorphic mapped type
			// { [P in keyof T]: X }. This enables us to make meaningful inferences when the target is a
			// Pick<T, K>.
			extendedConstraint := tc.getConstraintOfType(constraintType)
			if extendedConstraint && inferToMappedType(source, target, extendedConstraint) {
				return true
			}
			// If no inferences can be made to K's constraint, infer from a union of the property types
			// in the source to the template type X.
			propTypes := map_(tc.getPropertiesOfType(source), tc.getTypeOfSymbol)
			indexTypes := map_(tc.getIndexInfosOfType(source), func(info IndexInfo) Type {
				if info != tc.enumNumberIndexInfo {
					return info.type_
				} else {
					return tc.neverType
				}
			})
			inferFromTypes(tc.getUnionType(concatenate(propTypes, indexTypes)), tc.getTemplateTypeFromMappedType(target))
			return true
		}
		return false
	}

	inferToConditionalType := func(source Type, target ConditionalType) {
		if source.flags & TypeFlagsConditional {
			inferFromTypes((source /* as ConditionalType */).checkType, target.checkType)
			inferFromTypes((source /* as ConditionalType */).extendsType, target.extendsType)
			inferFromTypes(tc.getTrueTypeFromConditionalType(source /* as ConditionalType */), tc.getTrueTypeFromConditionalType(target))
			inferFromTypes(tc.getFalseTypeFromConditionalType(source /* as ConditionalType */), tc.getFalseTypeFromConditionalType(target))
		} else {
			targetTypes := []Type{tc.getTrueTypeFromConditionalType(target), tc.getFalseTypeFromConditionalType(target)}
			inferToMultipleTypesWithPriority(source, targetTypes, target.flags, __COND__(contravariant, InferencePriorityContravariantConditional, 0))
		}
	}

	inferToTemplateLiteralType := func(source Type, target TemplateLiteralType) {
		matches := tc.inferTypesFromTemplateLiteralType(source, target)
		types := target.types
		// When the target template literal contains only placeholders (meaning that inference is intended to extract
		// single characters and remainder strings) and inference fails to produce matches, we want to infer 'never' for
		// each placeholder such that instantiation with the inferred value(s) produces 'never', a type for which an
		// assignment check will fail. If we make no inferences, we'll likely end up with the constraint 'string' which,
		// upon instantiation, would collapse all the placeholders to just 'string', and an assignment check might
		// succeed. That would be a pointless and confusing outcome.
		if matches || every(target.texts, func(s string) bool {
			return s.length == 0
		}) {
			for i := 0; i < types.length; i++ {
				var source Type
				if matches {
					source = matches[i]
				} else {
					source = tc.neverType
				}
				target := types[i]

				// If we are inferring from a string literal type to a type variable whose constraint includes one of the
				// allowed template literal placeholder types, infer from a literal type corresponding to the constraint.
				if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsTypeVariable {
					inferenceContext := getInferenceInfoForType(target)
					var constraint Type
					if inferenceContext {
						constraint = tc.getBaseConstraintOfType(inferenceContext.typeParameter)
					} else {
						constraint = nil
					}
					if constraint && !tc.isTypeAny(constraint) {
						var constraintTypes []Type
						if constraint.flags & TypeFlagsUnion {
							constraintTypes = (constraint /* as UnionType */).types
						} else {
							constraintTypes = []Type{constraint}
						}
						var allTypeFlags TypeFlags = reduceLeft(constraintTypes, func(flags TypeFlags, t Type) number {
							return flags | t.flags
						}, 0 /* as TypeFlags */)

						// If the constraint contains `string`, we don't need to look for a more preferred type
						if !(allTypeFlags & TypeFlagsString) {
							str := (source /* as StringLiteralType */).value

							// If the type contains `number` or a number literal and the string isn't a valid number, exclude numbers
							if allTypeFlags&TypeFlagsNumberLike && !tc.isValidNumberString(str /*roundTripOnly*/, true) {
								allTypeFlags &= ~TypeFlagsNumberLike
							}

							// If the type contains `bigint` or a bigint literal and the string isn't a valid bigint, exclude bigints
							if allTypeFlags&TypeFlagsBigIntLike && !isValidBigIntString(str /*roundTripOnly*/, true) {
								allTypeFlags &= ~TypeFlagsBigIntLike
							}

							// for each type in the constraint, find the highest priority matching type
							matchingType := reduceLeft(constraintTypes, func(left Type, right Type) Type {
								switch {
								case !(right.flags & allTypeFlags):
									return left
								case left.flags & TypeFlagsString:
									return left
								case right.flags & TypeFlagsString:
									return source
								case left.flags & TypeFlagsTemplateLiteral:
									return left
								case right.flags&TypeFlagsTemplateLiteral && tc.isTypeMatchedByTemplateLiteralType(source, right /* as TemplateLiteralType */):
									return source
								case left.flags & TypeFlagsStringMapping:
									return left
								case right.flags&TypeFlagsStringMapping && str == tc.applyStringMapping(right.symbol, str):
									return source
								case left.flags & TypeFlagsStringLiteral:
									return left
								case right.flags&TypeFlagsStringLiteral && (right /* as StringLiteralType */).value == str:
									return right
								case left.flags & TypeFlagsNumber:
									return left
								case right.flags & TypeFlagsNumber:
									return tc.getNumberLiteralType(+str)
								case left.flags & TypeFlagsEnum:
									return left
								case right.flags & TypeFlagsEnum:
									return tc.getNumberLiteralType(+str)
								case left.flags & TypeFlagsNumberLiteral:
									return left
								case right.flags&TypeFlagsNumberLiteral && (right /* as NumberLiteralType */).value == +str:
									return right
								case left.flags & TypeFlagsBigInt:
									return left
								case right.flags & TypeFlagsBigInt:
									return tc.parseBigIntLiteralType(str)
								case left.flags & TypeFlagsBigIntLiteral:
									return left
								case right.flags&TypeFlagsBigIntLiteral && pseudoBigIntToString((right /* as BigIntLiteralType */).value) == str:
									return right
								case left.flags & TypeFlagsBoolean:
									return left
								case right.flags & TypeFlagsBoolean:
									switch {
									case str == "true":
										return tc.trueType
									case str == "false":
										return tc.falseType
									default:
										return tc.booleanType
									}
								case left.flags & TypeFlagsBooleanLiteral:
									return left
								case right.flags&TypeFlagsBooleanLiteral && (right /* as IntrinsicType */).intrinsicName == str:
									return right
								case left.flags & TypeFlagsUndefined:
									return left
								case right.flags&TypeFlagsUndefined && (right /* as IntrinsicType */).intrinsicName == str:
									return right
								case left.flags & TypeFlagsNull:
									return left
								case right.flags&TypeFlagsNull && (right /* as IntrinsicType */).intrinsicName == str:
									return right
								default:
									return left
								}
							}, tc.neverType /* as Type */)

							if !(matchingType.flags & TypeFlagsNever) {
								inferFromTypes(matchingType, target)
								continue
							}
						}
					}
				}

				inferFromTypes(source, target)
			}
		}
	}

	inferFromGenericMappedTypes := func(source MappedType, target MappedType) {
		// The source and target types are generic types { [P in S]: X } and { [P in T]: Y }, so we infer
		// from S to T and from X to Y.
		inferFromTypes(tc.getConstraintTypeFromMappedType(source), tc.getConstraintTypeFromMappedType(target))
		inferFromTypes(tc.getTemplateTypeFromMappedType(source), tc.getTemplateTypeFromMappedType(target))
		sourceNameType := tc.getNameTypeFromMappedType(source)
		targetNameType := tc.getNameTypeFromMappedType(target)
		if sourceNameType && targetNameType {
			inferFromTypes(sourceNameType, targetNameType)
		}
	}

	inferFromObjectTypes := func(source Type, target Type) {
		if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source /* as TypeReference */).target == (target /* as TypeReference */).target || tc.isArrayType(source) && tc.isArrayType(target)) {
			// If source and target are references to the same generic type, infer from type arguments
			inferFromTypeArguments(tc.getTypeArguments(source /* as TypeReference */), tc.getTypeArguments(target /* as TypeReference */), tc.getVariances((source /* as TypeReference */).target))
			return
		}
		if tc.isGenericMappedType(source) && tc.isGenericMappedType(target) {
			inferFromGenericMappedTypes(source, target)
		}
		if getObjectFlags(target)&ObjectFlagsMapped && !(target /* as MappedType */).declaration.nameType {
			constraintType := tc.getConstraintTypeFromMappedType(target /* as MappedType */)
			if inferToMappedType(source, target /* as MappedType */, constraintType) {
				return
			}
		}
		// Infer from the members of source and target only if the two types are possibly related
		if !tc.typesDefinitelyUnrelated(source, target) {
			if tc.isArrayOrTupleType(source) {
				if tc.isTupleType(target) {
					sourceArity := tc.getTypeReferenceArity(source)
					targetArity := tc.getTypeReferenceArity(target)
					elementTypes := tc.getTypeArguments(target)
					elementFlags := target.target.elementFlags
					// When source and target are tuple types with the same structure (fixed, variadic, and rest are matched
					// to the same kind in each position), simply infer between the element types.
					if tc.isTupleType(source) && tc.isTupleTypeStructureMatching(source, target) {
						for i := 0; i < targetArity; i++ {
							inferFromTypes(tc.getTypeArguments(source)[i], elementTypes[i])
						}
						return
					}
					var startLength number
					if tc.isTupleType(source) {
						startLength = Math.min(source.target.fixedLength, target.target.fixedLength)
					} else {
						startLength = 0
					}
					endLength := Math.min(__COND__(tc.isTupleType(source), tc.getEndElementCount(source.target, ElementFlagsFixed), 0), __COND__(target.target.combinedFlags&ElementFlagsVariable, tc.getEndElementCount(target.target, ElementFlagsFixed), 0))
					// Infer between starting fixed elements.
					for i := 0; i < startLength; i++ {
						inferFromTypes(tc.getTypeArguments(source)[i], elementTypes[i])
					}
					if !tc.isTupleType(source) || sourceArity-startLength-endLength == 1 && source.target.elementFlags[startLength]&ElementFlagsRest {
						// Single rest element remains in source, infer from that to every element in target
						restType := tc.getTypeArguments(source)[startLength]
						for i := startLength; i < targetArity-endLength; i++ {
							inferFromTypes(__COND__(elementFlags[i]&ElementFlagsVariadic, tc.createArrayType(restType), restType), elementTypes[i])
						}
					} else {
						middleLength := targetArity - startLength - endLength
						if middleLength == 2 {
							if elementFlags[startLength] & elementFlags[startLength+1] & ElementFlagsVariadic {
								// Middle of target is [...T, ...U] and source is tuple type
								targetInfo := getInferenceInfoForType(elementTypes[startLength])
								if targetInfo && targetInfo.impliedArity != nil {
									// Infer slices from source based on implied arity of T.
									inferFromTypes(tc.sliceTupleType(source, startLength, endLength+sourceArity-targetInfo.impliedArity), elementTypes[startLength])
									inferFromTypes(tc.sliceTupleType(source, startLength+targetInfo.impliedArity, endLength), elementTypes[startLength+1])
								}
							} else if elementFlags[startLength]&ElementFlagsVariadic && elementFlags[startLength+1]&ElementFlagsRest {
								// Middle of target is [...T, ...rest] and source is tuple type
								// if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
								param := getInferenceInfoForType(elementTypes[startLength]). /* ? */ typeParameter
								constraint := param && tc.getBaseConstraintOfType(param)
								if constraint && tc.isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
									impliedArity := constraint.target.fixedLength
									inferFromTypes(tc.sliceTupleType(source, startLength, sourceArity-(startLength+impliedArity)), elementTypes[startLength])
									inferFromTypes(tc.getElementTypeOfSliceOfTupleType(source, startLength+impliedArity, endLength), elementTypes[startLength+1])
								}
							} else if elementFlags[startLength]&ElementFlagsRest && elementFlags[startLength+1]&ElementFlagsVariadic {
								// Middle of target is [...rest, ...T] and source is tuple type
								// if T is constrained by a fixed-size tuple we might be able to use its arity to infer T
								param := getInferenceInfoForType(elementTypes[startLength+1]). /* ? */ typeParameter
								constraint := param && tc.getBaseConstraintOfType(param)
								if constraint && tc.isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
									impliedArity := constraint.target.fixedLength
									endIndex := sourceArity - tc.getEndElementCount(target.target, ElementFlagsFixed)
									startIndex := endIndex - impliedArity
									trailingSlice := tc.createTupleType(tc.getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex) /*readonly*/, false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex))

									inferFromTypes(tc.getElementTypeOfSliceOfTupleType(source, startLength, endLength+impliedArity), elementTypes[startLength])
									inferFromTypes(trailingSlice, elementTypes[startLength+1])
								}
							}
						} else if middleLength == 1 && elementFlags[startLength]&ElementFlagsVariadic {
							// Middle of target is exactly one variadic element. Infer the slice between the fixed parts in the source.
							// If target ends in optional element(s), make a lower priority a speculative inference.
							endsInOptional := target.target.elementFlags[targetArity-1] & ElementFlagsOptional
							sourceSlice := tc.sliceTupleType(source, startLength, endLength)
							inferWithPriority(sourceSlice, elementTypes[startLength], __COND__(endsInOptional, InferencePrioritySpeculativeTuple, 0))
						} else if middleLength == 1 && elementFlags[startLength]&ElementFlagsRest {
							// Middle of target is exactly one rest element. If middle of source is not empty, infer union of middle element types.
							restType := tc.getElementTypeOfSliceOfTupleType(source, startLength, endLength)
							if restType {
								inferFromTypes(restType, elementTypes[startLength])
							}
						}
					}
					// Infer between ending fixed elements
					for i := 0; i < endLength; i++ {
						inferFromTypes(tc.getTypeArguments(source)[sourceArity-i-1], elementTypes[targetArity-i-1])
					}
					return
				}
				if tc.isArrayType(target) {
					inferFromIndexTypes(source, target)
					return
				}
			}
			inferFromProperties(source, target)
			inferFromSignatures(source, target, SignatureKindCall)
			inferFromSignatures(source, target, SignatureKindConstruct)
			inferFromIndexTypes(source, target)
		}
	}

	inferFromProperties := func(source Type, target Type) {
		properties := tc.getPropertiesOfObjectType(target)
		for _, targetProp := range properties {
			sourceProp := tc.getPropertyOfType(source, targetProp.escapedName)
			if sourceProp && !some(sourceProp.declarations, tc.hasSkipDirectInferenceFlag) {
				inferFromTypes(tc.removeMissingType(tc.getTypeOfSymbol(sourceProp), !!(sourceProp.flags&SymbolFlagsOptional)), tc.removeMissingType(tc.getTypeOfSymbol(targetProp), !!(targetProp.flags&SymbolFlagsOptional)))
			}
		}
	}

	inferFromSignatures := func(source Type, target Type, kind SignatureKind) {
		sourceSignatures := tc.getSignaturesOfType(source, kind)
		sourceLen := sourceSignatures.length
		if sourceLen > 0 {
			// We match source and target signatures from the bottom up, and if the source has fewer signatures
			// than the target, we infer from the first source signature to the excess target signatures.
			targetSignatures := tc.getSignaturesOfType(target, kind)
			targetLen := targetSignatures.length
			for i := 0; i < targetLen; i++ {
				sourceIndex := Math.max(sourceLen-targetLen+i, 0)
				inferFromSignature(tc.getBaseSignature(sourceSignatures[sourceIndex]), tc.getErasedSignature(targetSignatures[i]))
			}
		}
	}

	inferFromSignature := func(source Signature, target Signature) {
		if !(source.flags & SignatureFlagsIsNonInferrable) {
			saveBivariant := bivariant
			var kind /* TODO(TS-TO-GO) inferred type SyntaxKind.Unknown | SyntaxKind.MethodSignature | SyntaxKind.MethodDeclaration | SyntaxKind.Constructor | SyntaxKind.GetAccessor | SyntaxKind.SetAccessor | SyntaxKind.CallSignature | SyntaxKind.ConstructSignature | SyntaxKind.IndexSignature | SyntaxKind.FunctionType | SyntaxKind.ConstructorType | SyntaxKind.FunctionExpression | SyntaxKind.ArrowFunction | SyntaxKind.FunctionDeclaration | SyntaxKind.JSDocFunctionType | SyntaxKind.JSDocSignature */ any
			if target.declaration {
				kind = target.declaration.kind
			} else {
				kind = SyntaxKindUnknown
			}
			// Once we descend into a bivariant signature we remain bivariant for all nested inferences
			bivariant = bivariant || kind == SyntaxKindMethodDeclaration || kind == SyntaxKindMethodSignature || kind == SyntaxKindConstructor
			tc.applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes)
			bivariant = saveBivariant
		}
		tc.applyToReturnTypes(source, target, inferFromTypes)
	}

	inferFromIndexTypes := func(source Type, target Type) {
		// Inferences across mapped type index signatures are pretty much the same a inferences to homomorphic variables
		var priority /* TODO(TS-TO-GO) inferred type 0 | InferencePriority.HomomorphicMappedType */ any
		if getObjectFlags(source) & getObjectFlags(target) & ObjectFlagsMapped {
			priority = InferencePriorityHomomorphicMappedType
		} else {
			priority = 0
		}
		indexInfos := tc.getIndexInfosOfType(target)
		if tc.isObjectTypeWithInferableIndex(source) {
			for _, targetInfo := range indexInfos {
				var propTypes []Type = []never{}
				for _, prop := range tc.getPropertiesOfType(source) {
					if tc.isApplicableIndexType(tc.getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), targetInfo.keyType) {
						propType := tc.getTypeOfSymbol(prop)
						propTypes.push(__COND__(prop.flags&SymbolFlagsOptional, tc.removeMissingOrUndefinedType(propType), propType))
					}
				}
				for _, info := range tc.getIndexInfosOfType(source) {
					if tc.isApplicableIndexType(info.keyType, targetInfo.keyType) {
						propTypes.push(info.type_)
					}
				}
				if propTypes.length {
					inferWithPriority(tc.getUnionType(propTypes), targetInfo.type_, priority)
				}
			}
		}
		for _, targetInfo := range indexInfos {
			sourceInfo := tc.getApplicableIndexInfo(source, targetInfo.keyType)
			if sourceInfo {
				inferWithPriority(sourceInfo.type_, targetInfo.type_, priority)
			}
		}
	}

}

func (tc *TypeChecker) isTypeOrBaseIdenticalTo(s Type, t Type) bool {
	if t == tc.missingType {
		return s == t
	} else {
		return (tc.isTypeIdenticalTo(s, t) || !!(t.flags&TypeFlagsString && s.flags&TypeFlagsStringLiteral || t.flags&TypeFlagsNumber && s.flags&TypeFlagsNumberLiteral))
	}
}

func (tc *TypeChecker) isTypeCloselyMatchedBy(s Type, t Type) bool {
	return !!(s.flags&TypeFlagsObject && t.flags&TypeFlagsObject && s.symbol && s.symbol == t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol == t.aliasSymbol)
}

func (tc *TypeChecker) hasPrimitiveConstraint(type_ TypeParameter) bool {
	constraint := tc.getConstraintOfTypeParameter(type_)
	return !!constraint && tc.maybeTypeOfKind(__COND__(constraint.flags&TypeFlagsConditional, tc.getDefaultConstraintOfConditionalType(constraint /* as ConditionalType */), constraint), TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
}

func (tc *TypeChecker) isObjectLiteralType(type_ Type) bool {
	return !!(getObjectFlags(type_) & ObjectFlagsObjectLiteral)
}

func (tc *TypeChecker) isObjectOrArrayLiteralType(type_ Type) bool {
	return !!(getObjectFlags(type_) & (ObjectFlagsObjectLiteral | ObjectFlagsArrayLiteral))
}

func (tc *TypeChecker) unionObjectAndArrayLiteralCandidates(candidates []Type) []Type {
	if candidates.length > 1 {
		objectLiterals := filter(candidates, tc.isObjectOrArrayLiteralType)
		if objectLiterals.length {
			literalsType := tc.getUnionType(objectLiterals, UnionReductionSubtype)
			return concatenate(filter(candidates, func(t Type) bool {
				return !tc.isObjectOrArrayLiteralType(t)
			}), []Type{literalsType})
		}
	}
	return candidates
}

func (tc *TypeChecker) getContravariantInference(inference InferenceInfo) Type {
	if inference.priority & InferencePriorityPriorityImpliesCombination {
		return tc.getIntersectionType(inference.contraCandidates)
	} else {
		return tc.getCommonSubtype(inference.contraCandidates)
	}
}

func (tc *TypeChecker) getCovariantInference(inference InferenceInfo, signature Signature) Type {
	// Extract all object and array literal types and replace them with a single widened and normalized type.
	candidates := tc.unionObjectAndArrayLiteralCandidates(inference.candidates)
	// We widen inferred literal types if
	// all inferences were made to top-level occurrences of the type parameter, and
	// the type parameter has no constraint or its constraint includes no primitive or literal types, and
	// the type parameter was fixed during inference or does not occur at top-level in the return type.
	primitiveConstraint := tc.hasPrimitiveConstraint(inference.typeParameter) || tc.isConstTypeVariable(inference.typeParameter)
	widenLiteralTypes := !primitiveConstraint && inference.topLevel && (inference.isFixed || !tc.isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter))
	var baseCandidates []Type
	switch {
	case primitiveConstraint:
		baseCandidates = sameMap(candidates, tc.getRegularTypeOfLiteralType)
	case widenLiteralTypes:
		baseCandidates = sameMap(candidates, tc.getWidenedLiteralType)
	default:
		baseCandidates = candidates
	}
	// If all inferences were made from a position that implies a combined result, infer a union type.
	// Otherwise, infer a common supertype.
	var unwidenedType Type
	if inference.priority & InferencePriorityPriorityImpliesCombination {
		unwidenedType = tc.getUnionType(baseCandidates, UnionReductionSubtype)
	} else {
		unwidenedType = tc.getCommonSupertype(baseCandidates)
	}
	return tc.getWidenedType(unwidenedType)
}

func (tc *TypeChecker) getInferredType(context InferenceContext, index number) Type {
	inference := context.inferences[index]
	if !inference.inferredType {
		var inferredType Type
		var fallbackType Type
		if context.signature {
			var inferredCovariantType Type
			if inference.candidates {
				inferredCovariantType = tc.getCovariantInference(inference, context.signature)
			} else {
				inferredCovariantType = nil
			}
			var inferredContravariantType Type
			if inference.contraCandidates {
				inferredContravariantType = tc.getContravariantInference(inference)
			} else {
				inferredContravariantType = nil
			}
			if inferredCovariantType || inferredContravariantType {
				// If we have both co- and contra-variant inferences, we prefer the co-variant inference if it is not 'never',
				// all co-variant inferences are assignable to it (i.e. it isn't one of a conflicting set of candidates), it is
				// assignable to some contra-variant inference, and no other type parameter is constrained to this type parameter
				// and has inferences that would conflict. Otherwise, we prefer the contra-variant inference.
				// Similarly ignore co-variant `any` inference when both are available as almost everything is assignable to it
				// and it would spoil the overall inference.
				preferCovariantType := inferredCovariantType && (!inferredContravariantType || !(inferredCovariantType.flags&(TypeFlagsNever|TypeFlagsAny)) && some(inference.contraCandidates, func(t Type) bool {
					return tc.isTypeAssignableTo(inferredCovariantType, t)
				}) && every(context.inferences, func(other InferenceInfo) bool {
					return other != inference && tc.getConstraintOfTypeParameter(other.typeParameter) != inference.typeParameter || every(other.candidates, func(t Type) bool {
						return tc.isTypeAssignableTo(t, inferredCovariantType)
					})
				}))
				if preferCovariantType {
					inferredType = inferredCovariantType
				} else {
					inferredType = inferredContravariantType
				}
				if preferCovariantType {
					fallbackType = inferredContravariantType
				} else {
					fallbackType = inferredCovariantType
				}
			} else if context.flags & InferenceFlagsNoDefault {
				// We use silentNeverType as the wildcard that signals no inferences.
				inferredType = tc.silentNeverType
			} else {
				// Infer either the default or the empty object type when no inferences were
				// made. It is important to remember that in this case, inference still
				// succeeds, meaning there is no error for not having inference candidates. An
				// inference error only occurs when there are *conflicting* candidates, i.e.
				// candidates with no common supertype.
				defaultType := tc.getDefaultFromTypeParameter(inference.typeParameter)
				if defaultType {
					// Instantiate the default type. Any forward reference to a type
					// parameter should be instantiated to the empty object type.
					inferredType = tc.instantiateType(defaultType, tc.mergeTypeMappers(tc.createBackreferenceMapper(context, index), context.nonFixingMapper))
				}
			}
		} else {
			inferredType = tc.getTypeFromInference(inference)
		}

		inference.inferredType = inferredType || tc.getDefaultTypeArgumentType(!!(context.flags & InferenceFlagsAnyDefault))

		constraint := tc.getConstraintOfTypeParameter(inference.typeParameter)
		if constraint {
			instantiatedConstraint := tc.instantiateType(constraint, context.nonFixingMapper)
			if !inferredType || !context.compareTypes(inferredType, tc.getTypeWithThisArgument(instantiatedConstraint, inferredType)) {
				// If the fallback type satisfies the constraint, we pick it. Otherwise, we pick the constraint.
				if fallbackType && context.compareTypes(fallbackType, tc.getTypeWithThisArgument(instantiatedConstraint, fallbackType)) {
					inference.inferredType = fallbackType
				} else {
					inference.inferredType = instantiatedConstraint
				}
			}
		}
	}

	return inference.inferredType
}

func (tc *TypeChecker) getDefaultTypeArgumentType(isInJavaScriptFile bool) Type {
	if isInJavaScriptFile {
		return tc.anyType
	} else {
		return tc.unknownType
	}
}

func (tc *TypeChecker) getInferredTypes(context InferenceContext) []Type {
	var result []Type = []never{}
	for i := 0; i < context.inferences.length; i++ {
		result.push(tc.getInferredType(context, i))
	}
	return result
}

// EXPRESSION TYPE CHECKING

func (tc *TypeChecker) getCannotFindNameDiagnosticForName(node Identifier) DiagnosticMessage {
	switch node.escapedText {
	case "document",
		"console":
		return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom
	case "$":
		if tc.compilerOptions.types {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig
		} else {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery
		}
	case "describe",
		"suite",
		"it",
		"test":
		if tc.compilerOptions.types {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig
		} else {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha
		}
	case "process",
		"require",
		"Buffer",
		"module":
		if tc.compilerOptions.types {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig
		} else {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode
		}
	case "Bun":
		if tc.compilerOptions.types {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig
		} else {
			return Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun
		}
	case "Map",
		"Set",
		"Promise",
		"Symbol",
		"WeakMap",
		"WeakSet",
		"Iterator",
		"AsyncIterator",
		"SharedArrayBuffer",
		"Atomics",
		"AsyncIterable",
		"AsyncIterableIterator",
		"AsyncGenerator",
		"AsyncGeneratorFunction",
		"BigInt",
		"Reflect",
		"BigInt64Array",
		"BigUint64Array":
		return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later
	case "await":
		if isCallExpression(node.parent) {
			return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function
		}
		fallthrough
	default:
		if node.parent.kind == SyntaxKindShorthandPropertyAssignment {
			return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer
		} else {
			return Diagnostics.Cannot_find_name_0
		}
	}
}

func (tc *TypeChecker) getResolvedSymbol(node Identifier) Symbol {
	links := tc.getNodeLinks(node)
	if !links.resolvedSymbol {
		links.resolvedSymbol = !nodeIsMissing(node) && tc.resolveName(node, node, SymbolFlagsValue|SymbolFlagsExportValue, tc.getCannotFindNameDiagnosticForName(node), !isWriteOnlyAccess(node), false) || tc.unknownSymbol
	}
	return links.resolvedSymbol
}

func (tc *TypeChecker) isInAmbientOrTypeNode(node Node) bool {
	return !!(node.flags&NodeFlagsAmbient || findAncestor(node, func(n Node) bool {
		return isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) || isTypeLiteralNode(n)
	}))
}

// Return the flow cache key for a "dotted name" (i.e. a sequence of identifiers
// separated by dots). The key consists of the id of the symbol referenced by the
// leftmost identifier followed by zero or more property names separated by dots.
// The result is undefined if the reference isn't a dotted name.
func (tc *TypeChecker) getFlowCacheKey(node Node, declaredType Type, initialType Type, flowContainer Node) *string {
	switch node.kind {
	case SyntaxKindIdentifier:
		if !isThisInTypeQuery(node) {
			symbol := tc.getResolvedSymbol(node /* as Identifier */)
			if symbol != tc.unknownSymbol {
				return __TEMPLATE__(__COND__(flowContainer, getNodeId(flowContainer), "-1"), "|", tc.getTypeId(declaredType), "|", tc.getTypeId(initialType), "|", getSymbolId(symbol))
			} else {
				return nil
			}
		}
		fallthrough
	case SyntaxKindThisKeyword:
		return __TEMPLATE__("0|", __COND__(flowContainer, getNodeId(flowContainer), "-1"), "|", tc.getTypeId(declaredType), "|", tc.getTypeId(initialType))
	case SyntaxKindNonNullExpression,
		SyntaxKindParenthesizedExpression:
		return tc.getFlowCacheKey((node /* as NonNullExpression | ParenthesizedExpression */).expression, declaredType, initialType, flowContainer)
	case SyntaxKindQualifiedName:
		left := tc.getFlowCacheKey((node /* as QualifiedName */).left, declaredType, initialType, flowContainer)
		return left && __TEMPLATE__(left, ".", (node /* as QualifiedName */).right.escapedText)
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		propName := tc.getAccessedPropertyName(node /* as AccessExpression */)
		if propName != nil {
			key := tc.getFlowCacheKey((node /* as AccessExpression */).expression, declaredType, initialType, flowContainer)
			return key && __TEMPLATE__(key, ".", propName)
		}
		if isElementAccessExpression(node) && isIdentifier(node.argumentExpression) {
			symbol := tc.getResolvedSymbol(node.argumentExpression)
			if tc.isConstantVariable(symbol) || tc.isParameterOrMutableLocalVariable(symbol) && !tc.isSymbolAssigned(symbol) {
				key := tc.getFlowCacheKey((node /* as AccessExpression */).expression, declaredType, initialType, flowContainer)
				return key && __TEMPLATE__(key, ".@", getSymbolId(symbol))
			}
		}
	case SyntaxKindObjectBindingPattern,
		SyntaxKindArrayBindingPattern,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindMethodDeclaration:
		return __TEMPLATE__(getNodeId(node), "#", tc.getTypeId(declaredType))
	}
	return nil
}

func (tc *TypeChecker) isMatchingReference(source Node, target Node) bool {
	switch target.kind {
	case SyntaxKindParenthesizedExpression,
		SyntaxKindNonNullExpression:
		return tc.isMatchingReference(source, (target /* as NonNullExpression | ParenthesizedExpression */).expression)
	case SyntaxKindBinaryExpression:
		return (isAssignmentExpression(target) && tc.isMatchingReference(source, target.left)) || (isBinaryExpression(target) && target.operatorToken.kind == SyntaxKindCommaToken && tc.isMatchingReference(source, target.right))
	}
	switch source.kind {
	case SyntaxKindMetaProperty:
		return target.kind == SyntaxKindMetaProperty && (source /* as MetaProperty */).keywordToken == (target /* as MetaProperty */).keywordToken && (source /* as MetaProperty */).name.escapedText == (target /* as MetaProperty */).name.escapedText
	case SyntaxKindIdentifier,
		SyntaxKindPrivateIdentifier:
		if isThisInTypeQuery(source) {
			return target.kind == SyntaxKindThisKeyword
		} else {
			return target.kind == SyntaxKindIdentifier && tc.getResolvedSymbol(source /* as Identifier */) == tc.getResolvedSymbol(target /* as Identifier */) || (isVariableDeclaration(target) || isBindingElement(target)) && tc.getExportSymbolOfValueSymbolIfExported(tc.getResolvedSymbol(source /* as Identifier */)) == tc.getSymbolOfDeclaration(target)
		}
	case SyntaxKindThisKeyword:
		return target.kind == SyntaxKindThisKeyword
	case SyntaxKindSuperKeyword:
		return target.kind == SyntaxKindSuperKeyword
	case SyntaxKindNonNullExpression,
		SyntaxKindParenthesizedExpression:
		return tc.isMatchingReference((source /* as NonNullExpression | ParenthesizedExpression */).expression, target)
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		sourcePropertyName := tc.getAccessedPropertyName(source /* as AccessExpression */)
		if sourcePropertyName != nil {
			var targetPropertyName *__String
			if isAccessExpression(target) {
				targetPropertyName = tc.getAccessedPropertyName(target)
			} else {
				targetPropertyName = nil
			}
			if targetPropertyName != nil {
				return targetPropertyName == sourcePropertyName && tc.isMatchingReference((source /* as AccessExpression */).expression, (target /* as AccessExpression */).expression)
			}
		}
		if isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression) {
			symbol := tc.getResolvedSymbol(source.argumentExpression)
			if symbol == tc.getResolvedSymbol(target.argumentExpression) && (tc.isConstantVariable(symbol) || tc.isParameterOrMutableLocalVariable(symbol) && !tc.isSymbolAssigned(symbol)) {
				return tc.isMatchingReference(source.expression, target.expression)
			}
		}
	case SyntaxKindQualifiedName:
		return isAccessExpression(target) && (source /* as QualifiedName */).right.escapedText == tc.getAccessedPropertyName(target) && tc.isMatchingReference((source /* as QualifiedName */).left, target.expression)
	case SyntaxKindBinaryExpression:
		return (isBinaryExpression(source) && source.operatorToken.kind == SyntaxKindCommaToken && tc.isMatchingReference(source.right, target))
	}
	return false
}

func (tc *TypeChecker) getAccessedPropertyName(access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any) *__String {
	if isPropertyAccessExpression(access) {
		return access.name.escapedText
	}
	if isElementAccessExpression(access) {
		return tc.tryGetElementAccessExpressionName(access)
	}
	if isBindingElement(access) {
		name := tc.getDestructuringPropertyName(access)
		if name {
			return escapeLeadingUnderscores(name)
		} else {
			return nil
		}
	}
	if isParameter(access) {
		return ("" + access.parent.parameters.indexOf(access)) /* as __String */
	}
	return nil
}

func (tc *TypeChecker) tryGetNameFromType(type_ Type) *__String {
	switch {
	case type_.flags & TypeFlagsUniqueESSymbol:
		return (type_ /* as UniqueESSymbolType */).escapedName
	case type_.flags & TypeFlagsStringOrNumberLiteral:
		return escapeLeadingUnderscores("" + (type_ /* as StringLiteralType | NumberLiteralType */).value)
	default:
		return nil
	}
}

func (tc *TypeChecker) tryGetElementAccessExpressionName(node ElementAccessExpression) *__String {
	switch {
	case isStringOrNumericLiteralLike(node.argumentExpression):
		return escapeLeadingUnderscores(node.argumentExpression.text)
	case isEntityNameExpression(node.argumentExpression):
		return tc.tryGetNameFromEntityNameExpression(node.argumentExpression)
	default:
		return nil
	}
}

func (tc *TypeChecker) tryGetNameFromEntityNameExpression(node EntityNameOrEntityNameExpression) *__String {
	symbol := tc.resolveEntityName(node, SymbolFlagsValue /*ignoreErrors*/, true)
	if !symbol || !(tc.isConstantVariable(symbol) || (symbol.flags & SymbolFlagsEnumMember)) {
		return nil
	}

	declaration := symbol.valueDeclaration
	if declaration == nil {
		return nil
	}

	type_ := tc.tryGetTypeFromEffectiveTypeNode(declaration)
	if type_ {
		name := tc.tryGetNameFromType(type_)
		if name != nil {
			return name
		}
	}
	if hasOnlyExpressionInitializer(declaration) && tc.isBlockScopedNameDeclaredBeforeUse(declaration, node) {
		initializer := getEffectiveInitializer(declaration)
		if initializer {
			var initializerType Type
			if isBindingPattern(declaration.parent) {
				initializerType = tc.getTypeForBindingElement(declaration /* as BindingElement */)
			} else {
				initializerType = tc.getTypeOfExpression(initializer)
			}
			return initializerType && tc.tryGetNameFromType(initializerType)
		}
		if isEnumMember(declaration) {
			return getTextOfPropertyName(declaration.name)
		}
	}
	return nil
}

func (tc *TypeChecker) containsMatchingReference(source Node, target Node) bool {
	for isAccessExpression(source) {
		source = source.expression
		if tc.isMatchingReference(source, target) {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) optionalChainContainsReference(source Node, target Node) bool {
	for isOptionalChain(source) {
		source = source.expression
		if tc.isMatchingReference(source, target) {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) isDiscriminantProperty(type_ Type, name __String) bool {
	if type_ && type_.flags&TypeFlagsUnion {
		prop := tc.getUnionOrIntersectionProperty(type_ /* as UnionType */, name)
		if prop && getCheckFlags(prop)&CheckFlagsSyntheticProperty {
			// NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty
			if (prop /* as TransientSymbol */).links.isDiscriminantProperty == nil {
				(prop /* as TransientSymbol */).links.isDiscriminantProperty = ((prop /* as TransientSymbol */).links.checkFlags&CheckFlagsDiscriminant) == CheckFlagsDiscriminant && !tc.isGenericType(tc.getTypeOfSymbol(prop))
			}
			return !!(prop /* as TransientSymbol */).links.isDiscriminantProperty
		}
	}
	return false
}

func (tc *TypeChecker) findDiscriminantProperties(sourceProperties []Symbol, target Type) *[]Symbol {
	var result *[]Symbol
	for _, sourceProperty := range sourceProperties {
		if tc.isDiscriminantProperty(target, sourceProperty.escapedName) {
			if result {
				result.push(sourceProperty)
				continue
			}
			result = []Symbol{sourceProperty}
		}
	}
	return result
}

// Given a set of constituent types and a property name, create and return a map keyed by the literal
// types of the property by that name in each constituent type. No map is returned if some key property
// has a non-literal type or if less than 10 or less than 50% of the constituents have a unique key.
// Entries with duplicate keys have unknownType as the value.
func (tc *TypeChecker) mapTypesByKeyProperty(types []Type, name __String) *Map[number, Type] {
	map_ := NewMap[TypeId, Type]()
	count := 0
	for _, type_ := range types {
		if type_.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsInstantiableNonPrimitive) {
			discriminant := tc.getTypeOfPropertyOfType(type_, name)
			if discriminant {
				if !tc.isLiteralType(discriminant) {
					return nil
				}
				duplicate := false
				tc.forEachType(discriminant, func(t Type) {
					id := tc.getTypeId(tc.getRegularTypeOfLiteralType(t))
					existing := map_.get(id)
					if !existing {
						map_.set(id, type_)
					} else if existing != tc.unknownType {
						map_.set(id, tc.unknownType)
						duplicate = true
					}
				})
				if !duplicate {
					count++
				}
			}
		}
	}
	if count >= 10 && count*2 >= types.length {
		return map_
	} else {
		return nil
	}
}

// Return the name of a discriminant property for which it was possible and feasible to construct a map of
// constituent types keyed by the literal types of the property by that name in each constituent type.
func (tc *TypeChecker) getKeyPropertyName(unionType UnionType) *__String {
	types := unionType.types
	// We only construct maps for unions with many non-primitive constituents.
	if types.length < 10 || getObjectFlags(unionType)&ObjectFlagsPrimitiveUnion || countWhere(types, func(t Type) bool {
		return !!(t.flags & (TypeFlagsObject | TypeFlagsInstantiableNonPrimitive))
	}) < 10 {
		return nil
	}
	if unionType.keyPropertyName == nil {
		// The candidate key property name is the name of the first property with a unit type in one of the
		// constituent types.
		keyPropertyName := forEach(types, func(t Type) * /* TODO(TS-TO-GO) inferred type (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | InternalSymbolName */ any {
			if t.flags & (TypeFlagsObject | TypeFlagsInstantiableNonPrimitive) {
				return forEach(tc.getPropertiesOfType(t), func(p Symbol) *__String {
					if tc.isUnitType(tc.getTypeOfSymbol(p)) {
						return p.escapedName
					} else {
						return nil
					}
				})
			} else {
				return nil
			}
		})
		mapByKeyProperty := keyPropertyName && tc.mapTypesByKeyProperty(types, keyPropertyName)
		if mapByKeyProperty {
			unionType.keyPropertyName = keyPropertyName
		} else {
			unionType.keyPropertyName = "" /* as __String */
		}
		unionType.constituentMap = mapByKeyProperty
	}
	if (unionType.keyPropertyName /* as string */).length {
		return unionType.keyPropertyName
	} else {
		return nil
	}
}

// Given a union type for which getKeyPropertyName returned a non-undefined result, return the constituent
// that corresponds to the given key type for that property name.
func (tc *TypeChecker) getConstituentTypeForKeyType(unionType UnionType, keyType Type) Type {
	result := unionType.constituentMap. /* ? */ get(tc.getTypeId(tc.getRegularTypeOfLiteralType(keyType)))
	if result != tc.unknownType {
		return result
	} else {
		return nil
	}
}

func (tc *TypeChecker) getMatchingUnionConstituentForType(unionType UnionType, type_ Type) Type {
	keyPropertyName := tc.getKeyPropertyName(unionType)
	propType := keyPropertyName && tc.getTypeOfPropertyOfType(type_, keyPropertyName)
	return propType && tc.getConstituentTypeForKeyType(unionType, propType)
}

func (tc *TypeChecker) getMatchingUnionConstituentForObjectLiteral(unionType UnionType, node ObjectLiteralExpression) Type {
	keyPropertyName := tc.getKeyPropertyName(unionType)
	propNode := keyPropertyName && find(node.properties, func(p /* TODO(TS-TO-GO) inferred type MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration | PropertyAssignment | ShorthandPropertyAssignment | SpreadAssignment */ any) bool {
		return p.symbol && p.kind == SyntaxKindPropertyAssignment && p.symbol.escapedName == keyPropertyName && tc.isPossiblyDiscriminantValue(p.initializer)
	})
	propType := propNode && tc.getContextFreeTypeOfExpression((propNode /* as PropertyAssignment */).initializer)
	return propType && tc.getConstituentTypeForKeyType(unionType, propType)
}

func (tc *TypeChecker) isOrContainsMatchingReference(source Node, target Node) bool {
	return tc.isMatchingReference(source, target) || tc.containsMatchingReference(source, target)
}

func (tc *TypeChecker) hasMatchingArgument(expression /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | NewExpression */ any, reference Node) bool {
	if expression.arguments {
		for _, argument := range expression.arguments {
			if tc.isOrContainsMatchingReference(reference, argument) || tc.optionalChainContainsReference(argument, reference) {
				return true
			}
		}
	}
	if expression.expression.kind == SyntaxKindPropertyAccessExpression && tc.isOrContainsMatchingReference(reference, (expression.expression /* as PropertyAccessExpression */).expression) {
		return true
	}
	return false
}

func (tc *TypeChecker) getFlowNodeId(flow FlowNode) number {
	if flow.id <= 0 {
		flow.id = nextFlowId
		nextFlowId++
	}
	return flow.id
}

func (tc *TypeChecker) typeMaybeAssignableTo(source Type, target Type) bool {
	if !(source.flags & TypeFlagsUnion) {
		return tc.isTypeAssignableTo(source, target)
	}
	for _, t := range (source /* as UnionType */).types {
		if tc.isTypeAssignableTo(t, target) {
			return true
		}
	}
	return false
}

// Remove those constituent types of declaredType to which no constituent type of assignedType is assignable.
// For example, when a variable of type number | string | boolean is assigned a value of type number | boolean,
// we remove type string.
func (tc *TypeChecker) getAssignmentReducedType(declaredType UnionType, assignedType Type) Type {
	if declaredType == assignedType {
		return declaredType
	}
	if assignedType.flags & TypeFlagsNever {
		return assignedType
	}
	key := __TEMPLATE__("A", tc.getTypeId(declaredType), ",", tc.getTypeId(assignedType))
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType)) */ TODO
}

func (tc *TypeChecker) getAssignmentReducedTypeWorker(declaredType UnionType, assignedType Type) Type {
	filteredType := tc.filterType(declaredType, func(t Type) bool {
		return tc.typeMaybeAssignableTo(assignedType, t)
	})
	// Ensure that we narrow to fresh types if the assignment is a fresh boolean literal type.
	var reducedType Type
	if assignedType.flags&TypeFlagsBooleanLiteral && tc.isFreshLiteralType(assignedType) {
		reducedType = tc.mapType(filteredType, tc.getFreshTypeOfLiteralType)
	} else {
		reducedType = filteredType
	}
	// Our crude heuristic produces an invalid result in some cases: see GH#26130.
	// For now, when that happens, we give up and don't narrow at all.  (This also
	// means we'll never narrow for erroneous assignments where the assigned type
	// is not assignable to the declared type.)
	if tc.isTypeAssignableTo(assignedType, reducedType) {
		return reducedType
	} else {
		return declaredType
	}
}

func (tc *TypeChecker) isFunctionObjectType(type_ ObjectType) bool {
	if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
		return false
	}
	// We do a quick check for a "bind" property before performing the more expensive subtype
	// check. This gives us a quicker out in the common case where an object type is not a function.
	resolved := tc.resolveStructuredTypeMembers(type_)
	return !!(resolved.callSignatures.length || resolved.constructSignatures.length || resolved.members.get("bind" /* as __String */) && tc.isTypeSubtypeOf(type_, tc.globalFunctionType))
}

func (tc *TypeChecker) getTypeFacts(type_ Type, mask TypeFacts) TypeFacts {
	return tc.getTypeFactsWorker(type_, mask) & mask
}

func (tc *TypeChecker) hasTypeFacts(type_ Type, mask TypeFacts) bool {
	return tc.getTypeFacts(type_, mask) != 0
}

func (tc *TypeChecker) getTypeFactsWorker(type_ Type, callerOnlyNeeds TypeFacts) TypeFacts {
	if type_.flags & (TypeFlagsIntersection | TypeFlagsInstantiable) {
		type_ = tc.getBaseConstraintOfType(type_) || tc.unknownType
	}
	flags := type_.flags
	if flags & (TypeFlagsString | TypeFlagsStringMapping) {
		if tc.strictNullChecks {
			return TypeFactsStringStrictFacts
		} else {
			return TypeFactsStringFacts
		}
	}
	if flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral) {
		isEmpty := flags&TypeFlagsStringLiteral && (type_ /* as StringLiteralType */).value == ""
		switch {
		case tc.strictNullChecks:
			if isEmpty {
				return TypeFactsEmptyStringStrictFacts
			} else {
				return TypeFactsNonEmptyStringStrictFacts
			}
		case isEmpty:
			return TypeFactsEmptyStringFacts
		default:
			return TypeFactsNonEmptyStringFacts
		}
	}
	if flags & (TypeFlagsNumber | TypeFlagsEnum) {
		if tc.strictNullChecks {
			return TypeFactsNumberStrictFacts
		} else {
			return TypeFactsNumberFacts
		}
	}
	if flags & TypeFlagsNumberLiteral {
		isZero := (type_ /* as NumberLiteralType */).value == 0
		switch {
		case tc.strictNullChecks:
			if isZero {
				return TypeFactsZeroNumberStrictFacts
			} else {
				return TypeFactsNonZeroNumberStrictFacts
			}
		case isZero:
			return TypeFactsZeroNumberFacts
		default:
			return TypeFactsNonZeroNumberFacts
		}
	}
	if flags & TypeFlagsBigInt {
		if tc.strictNullChecks {
			return TypeFactsBigIntStrictFacts
		} else {
			return TypeFactsBigIntFacts
		}
	}
	if flags & TypeFlagsBigIntLiteral {
		isZero := tc.isZeroBigInt(type_ /* as BigIntLiteralType */)
		switch {
		case tc.strictNullChecks:
			if isZero {
				return TypeFactsZeroBigIntStrictFacts
			} else {
				return TypeFactsNonZeroBigIntStrictFacts
			}
		case isZero:
			return TypeFactsZeroBigIntFacts
		default:
			return TypeFactsNonZeroBigIntFacts
		}
	}
	if flags & TypeFlagsBoolean {
		if tc.strictNullChecks {
			return TypeFactsBooleanStrictFacts
		} else {
			return TypeFactsBooleanFacts
		}
	}
	if flags & TypeFlagsBooleanLike {
		switch {
		case tc.strictNullChecks:
			if type_ == tc.falseType || type_ == tc.regularFalseType {
				return TypeFactsFalseStrictFacts
			} else {
				return TypeFactsTrueStrictFacts
			}
		case (type_ == tc.falseType || type_ == tc.regularFalseType):
			return TypeFactsFalseFacts
		default:
			return TypeFactsTrueFacts
		}
	}
	if flags & TypeFlagsObject {
		var possibleFacts number
		if tc.strictNullChecks {
			possibleFacts = TypeFactsEmptyObjectStrictFacts | TypeFactsFunctionStrictFacts | TypeFactsObjectStrictFacts
		} else {
			possibleFacts = TypeFactsEmptyObjectFacts | TypeFactsFunctionFacts | TypeFactsObjectFacts
		}

		if (callerOnlyNeeds & possibleFacts) == 0 {
			// If the caller doesn't care about any of the facts that we could possibly produce,
			// return zero so we can skip resolving members.
			return 0
		}

		switch {
		case getObjectFlags(type_)&ObjectFlagsAnonymous && tc.isEmptyObjectType(type_ /* as ObjectType */):
			if tc.strictNullChecks {
				return TypeFactsEmptyObjectStrictFacts
			} else {
				return TypeFactsEmptyObjectFacts
			}
		case tc.isFunctionObjectType(type_ /* as ObjectType */):
			if tc.strictNullChecks {
				return TypeFactsFunctionStrictFacts
			} else {
				return TypeFactsFunctionFacts
			}
		case tc.strictNullChecks:
			return TypeFactsObjectStrictFacts
		default:
			return TypeFactsObjectFacts
		}
	}
	if flags & TypeFlagsVoid {
		return TypeFactsVoidFacts
	}
	if flags & TypeFlagsUndefined {
		return TypeFactsUndefinedFacts
	}
	if flags & TypeFlagsNull {
		return TypeFactsNullFacts
	}
	if flags & TypeFlagsESSymbolLike {
		if tc.strictNullChecks {
			return TypeFactsSymbolStrictFacts
		} else {
			return TypeFactsSymbolFacts
		}
	}
	if flags & TypeFlagsNonPrimitive {
		if tc.strictNullChecks {
			return TypeFactsObjectStrictFacts
		} else {
			return TypeFactsObjectFacts
		}
	}
	if flags & TypeFlagsNever {
		return TypeFactsNone
	}
	if flags & TypeFlagsUnion {
		return reduceLeft((type_ /* as UnionType */).types, func(facts /* TODO(TS-TO-GO) inferred type TypeFacts.None */ any, t Type) number {
			return facts | tc.getTypeFactsWorker(t, callerOnlyNeeds)
		}, TypeFactsNone)
	}
	if flags & TypeFlagsIntersection {
		return tc.getIntersectionTypeFacts(type_ /* as IntersectionType */, callerOnlyNeeds)
	}
	return TypeFactsUnknownFacts
}

func (tc *TypeChecker) getIntersectionTypeFacts(type_ IntersectionType, callerOnlyNeeds TypeFacts) TypeFacts {
	// When an intersection contains a primitive type we ignore object type constituents as they are
	// presumably type tags. For example, in string & { __kind__: "name" } we ignore the object type.
	ignoreObjects := tc.maybeTypeOfKind(type_, TypeFlagsPrimitive)
	// When computing the type facts of an intersection type, certain type facts are computed as `and`
	// and others are computed as `or`.
	oredFacts := TypeFactsNone
	andedFacts := TypeFactsAll
	for _, t := range type_.types {
		if !(ignoreObjects && t.flags&TypeFlagsObject) {
			f := tc.getTypeFactsWorker(t, callerOnlyNeeds)
			oredFacts |= f
			andedFacts &= f
		}
	}
	return oredFacts&TypeFactsOrFactsMask | andedFacts&TypeFactsAndFactsMask
}

func (tc *TypeChecker) getTypeWithFacts(type_ Type, include TypeFacts) Type {
	return tc.filterType(type_, func(t Type) bool {
		return tc.hasTypeFacts(t, include)
	})
}

// This function is similar to getTypeWithFacts, except that in strictNullChecks mode it replaces type
// unknown with the union {} | null | undefined (and reduces that accordingly), and it intersects remaining
// instantiable types with {}, {} | null, or {} | undefined in order to remove null and/or undefined.
func (tc *TypeChecker) getAdjustedTypeWithFacts(type_ Type, facts TypeFacts) Type {
	reduced := tc.recombineUnknownType(tc.getTypeWithFacts(__COND__(tc.strictNullChecks && type_.flags&TypeFlagsUnknown, tc.unknownUnionType, type_), facts))
	if tc.strictNullChecks {
		switch facts {
		case TypeFactsNEUndefined:
			return tc.removeNullableByIntersection(reduced, TypeFactsEQUndefined, TypeFactsEQNull, TypeFactsIsNull, tc.nullType)
		case TypeFactsNENull:
			return tc.removeNullableByIntersection(reduced, TypeFactsEQNull, TypeFactsEQUndefined, TypeFactsIsUndefined, tc.undefinedType)
		case TypeFactsNEUndefinedOrNull,
			TypeFactsTruthy:
			return tc.mapType(reduced, func(t Type) Type {
				if tc.hasTypeFacts(t, TypeFactsEQUndefinedOrNull) {
					return tc.getGlobalNonNullableTypeInstantiation(t)
				} else {
					return t
				}
			})
		}
	}
	return reduced
}

func (tc *TypeChecker) removeNullableByIntersection(type_ Type, targetFacts TypeFacts, otherFacts TypeFacts, otherIncludesFacts TypeFacts, otherType Type) Type {
	facts := tc.getTypeFacts(type_, TypeFactsEQUndefined|TypeFactsEQNull|TypeFactsIsUndefined|TypeFactsIsNull)
	// Simply return the type if it never compares equal to the target nullable.
	if !(facts & targetFacts) {
		return type_
	}
	// By default we intersect with a union of {} and the opposite nullable.
	emptyAndOtherUnion := tc.getUnionType([]Type{tc.emptyObjectType, otherType})
	// For each constituent type that can compare equal to the target nullable, intersect with the above union
	// if the type doesn't already include the opppsite nullable and the constituent can compare equal to the
	// opposite nullable; otherwise, just intersect with {}.
	return tc.mapType(type_, func(t Type) Type {
		if tc.hasTypeFacts(t, targetFacts) {
			return tc.getIntersectionType([]Type{t, __COND__(!(facts&otherIncludesFacts) && tc.hasTypeFacts(t, otherFacts), emptyAndOtherUnion, tc.emptyObjectType)})
		} else {
			return t
		}
	})
}

func (tc *TypeChecker) recombineUnknownType(type_ Type) Type {
	if type_ == tc.unknownUnionType {
		return tc.unknownType
	} else {
		return type_
	}
}

func (tc *TypeChecker) getTypeWithDefault(type_ Type, defaultExpression Expression) Type {
	if defaultExpression {
		return tc.getUnionType([]Type{tc.getNonUndefinedType(type_), tc.getTypeOfExpression(defaultExpression)})
	} else {
		return type_
	}
}

func (tc *TypeChecker) getTypeOfDestructuredProperty(type_ Type, name PropertyName) Type {
	nameType := tc.getLiteralTypeFromPropertyName(name)
	if !isTypeUsableAsPropertyName(nameType) {
		return tc.errorType
	}
	text := getPropertyNameFromType(nameType)
	return tc.getTypeOfPropertyOfType(type_, text) || tc.includeUndefinedInIndexSignature(tc.getApplicableIndexInfoForName(type_, text). /* ? */ type_) || tc.errorType
}

func (tc *TypeChecker) getTypeOfDestructuredArrayElement(type_ Type, index number) Type {
	return tc.everyType(type_, tc.isTupleLikeType) && tc.getTupleElementType(type_, index) || tc.includeUndefinedInIndexSignature(tc.checkIteratedTypeOrElementType(IterationUseDestructuring, type_, tc.undefinedType /*errorNode*/, nil)) || tc.errorType
}

func (tc *TypeChecker) includeUndefinedInIndexSignature(type_ Type) Type {
	if !type_ {
		return type_
	}
	if tc.compilerOptions.noUncheckedIndexedAccess {
		return tc.getUnionType([]Type{type_, tc.missingType})
	} else {
		return type_
	}
}

func (tc *TypeChecker) getTypeOfDestructuredSpreadExpression(type_ Type) ObjectType {
	return tc.createArrayType(tc.checkIteratedTypeOrElementType(IterationUseDestructuring, type_, tc.undefinedType /*errorNode*/, nil) || tc.errorType)
}

func (tc *TypeChecker) getAssignedTypeOfBinaryExpression(node BinaryExpression) Type {
	isDestructuringDefaultAssignment := node.parent.kind == SyntaxKindArrayLiteralExpression && tc.isDestructuringAssignmentTarget(node.parent) || node.parent.kind == SyntaxKindPropertyAssignment && tc.isDestructuringAssignmentTarget(node.parent.parent)
	if isDestructuringDefaultAssignment {
		return tc.getTypeWithDefault(tc.getAssignedType(node), node.right)
	} else {
		return tc.getTypeOfExpression(node.right)
	}
}

func (tc *TypeChecker) isDestructuringAssignmentTarget(parent Node) bool {
	return parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent /* as BinaryExpression */).left == parent || parent.parent.kind == SyntaxKindForOfStatement && (parent.parent /* as ForOfStatement */).initializer == parent
}

func (tc *TypeChecker) getAssignedTypeOfArrayLiteralElement(node ArrayLiteralExpression, element Expression) Type {
	return tc.getTypeOfDestructuredArrayElement(tc.getAssignedType(node), node.elements.indexOf(element))
}

func (tc *TypeChecker) getAssignedTypeOfSpreadExpression(node SpreadElement) Type {
	return tc.getTypeOfDestructuredSpreadExpression(tc.getAssignedType(node.parent /* as ArrayLiteralExpression */))
}

func (tc *TypeChecker) getAssignedTypeOfPropertyAssignment(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAssignment | ShorthandPropertyAssignment */ any) Type {
	return tc.getTypeOfDestructuredProperty(tc.getAssignedType(node.parent), node.name)
}

func (tc *TypeChecker) getAssignedTypeOfShorthandPropertyAssignment(node ShorthandPropertyAssignment) Type {
	return tc.getTypeWithDefault(tc.getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer)
}

func (tc *TypeChecker) getAssignedType(node Expression) Type {
	TODO_IDENTIFIER := node
	switch parent.kind {
	case SyntaxKindForInStatement:
		return tc.stringType
	case SyntaxKindForOfStatement:
		return tc.checkRightHandSideOfForOf(parent /* as ForOfStatement */) || tc.errorType
	case SyntaxKindBinaryExpression:
		return tc.getAssignedTypeOfBinaryExpression(parent /* as BinaryExpression */)
	case SyntaxKindDeleteExpression:
		return tc.undefinedType
	case SyntaxKindArrayLiteralExpression:
		return tc.getAssignedTypeOfArrayLiteralElement(parent /* as ArrayLiteralExpression */, node)
	case SyntaxKindSpreadElement:
		return tc.getAssignedTypeOfSpreadExpression(parent /* as SpreadElement */)
	case SyntaxKindPropertyAssignment:
		return tc.getAssignedTypeOfPropertyAssignment(parent /* as PropertyAssignment */)
	case SyntaxKindShorthandPropertyAssignment:
		return tc.getAssignedTypeOfShorthandPropertyAssignment(parent /* as ShorthandPropertyAssignment */)
	}
	return tc.errorType
}

func (tc *TypeChecker) getInitialTypeOfBindingElement(node BindingElement) Type {
	pattern := node.parent
	parentType := tc.getInitialType(pattern.parent /* as VariableDeclaration | BindingElement */)
	var type_ Type
	switch {
	case pattern.kind == SyntaxKindObjectBindingPattern:
		type_ = tc.getTypeOfDestructuredProperty(parentType, node.propertyName || node.name /* as Identifier */)
	case !node.dotDotDotToken:
		type_ = tc.getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node))
	default:
		type_ = tc.getTypeOfDestructuredSpreadExpression(parentType)
	}
	return tc.getTypeWithDefault(type_, node.initializer)
}

func (tc *TypeChecker) getTypeOfInitializer(node Expression) Type {
	// Return the cached type if one is available. If the type of the variable was inferred
	// from its initializer, we'll already have cached the type. Otherwise we compute it now
	// without caching such that transient types are reflected.
	links := tc.getNodeLinks(node)
	return links.resolvedType || tc.getTypeOfExpression(node)
}

func (tc *TypeChecker) getInitialTypeOfVariableDeclaration(node VariableDeclaration) Type {
	if node.initializer {
		return tc.getTypeOfInitializer(node.initializer)
	}
	if node.parent.parent.kind == SyntaxKindForInStatement {
		return tc.stringType
	}
	if node.parent.parent.kind == SyntaxKindForOfStatement {
		return tc.checkRightHandSideOfForOf(node.parent.parent) || tc.errorType
	}
	return tc.errorType
}

func (tc *TypeChecker) getInitialType(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement */ any) Type {
	if node.kind == SyntaxKindVariableDeclaration {
		return tc.getInitialTypeOfVariableDeclaration(node)
	} else {
		return tc.getInitialTypeOfBindingElement(node)
	}
}

func (tc *TypeChecker) isEmptyArrayAssignment(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement | Expression */ any) bool {
	return node.kind == SyntaxKindVariableDeclaration && (node /* as VariableDeclaration */).initializer && tc.isEmptyArrayLiteral((node /* as VariableDeclaration */).initializer) || node.kind != SyntaxKindBindingElement && node.parent.kind == SyntaxKindBinaryExpression && tc.isEmptyArrayLiteral((node.parent /* as BinaryExpression */).right)
}

func (tc *TypeChecker) getReferenceCandidate(node Expression) Expression {
	switch node.kind {
	case SyntaxKindParenthesizedExpression:
		return tc.getReferenceCandidate((node /* as ParenthesizedExpression */).expression)
	case SyntaxKindBinaryExpression:
		switch (node /* as BinaryExpression */).operatorToken.kind {
		case SyntaxKindEqualsToken,
			SyntaxKindBarBarEqualsToken,
			SyntaxKindAmpersandAmpersandEqualsToken,
			SyntaxKindQuestionQuestionEqualsToken:
			return tc.getReferenceCandidate((node /* as BinaryExpression */).left)
		case SyntaxKindCommaToken:
			return tc.getReferenceCandidate((node /* as BinaryExpression */).right)
		}
	}
	return node
}

func (tc *TypeChecker) getReferenceRoot(node Node) Node {
	TODO_IDENTIFIER := node
	if parent.kind == SyntaxKindParenthesizedExpression || parent.kind == SyntaxKindBinaryExpression && (parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken && (parent /* as BinaryExpression */).left == node || parent.kind == SyntaxKindBinaryExpression && (parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindCommaToken && (parent /* as BinaryExpression */).right == node {
		return tc.getReferenceRoot(parent)
	} else {
		return node
	}
}

func (tc *TypeChecker) getTypeOfSwitchClause(clause /* TODO(TS-TO-GO) TypeNode UnionType: CaseClause | DefaultClause */ any) Type {
	if clause.kind == SyntaxKindCaseClause {
		return tc.getRegularTypeOfLiteralType(tc.getTypeOfExpression(clause.expression))
	}
	return tc.neverType
}

func (tc *TypeChecker) getSwitchClauseTypes(switchStatement SwitchStatement) []Type {
	links := tc.getNodeLinks(switchStatement)
	if !links.switchTypes {
		links.switchTypes = []never{}
		for _, clause := range switchStatement.caseBlock.clauses {
			links.switchTypes.push(tc.getTypeOfSwitchClause(clause))
		}
	}
	return links.switchTypes
}

// Get the type names from all cases in a switch on `typeof`. The default clause and/or duplicate type names are
// represented as undefined. Return undefined if one or more case clause expressions are not string literals.
func (tc *TypeChecker) getSwitchClauseTypeOfWitnesses(switchStatement SwitchStatement) *[]*string {
	if some(switchStatement.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
		return clause.kind == SyntaxKindCaseClause && !isStringLiteralLike(clause.expression)
	}) {
		return nil
	}
	var witnesses []*string = []never{}
	for _, clause := range switchStatement.caseBlock.clauses {
		var text *string
		if clause.kind == SyntaxKindCaseClause {
			text = (clause.expression /* as StringLiteralLike */).text
		} else {
			text = nil
		}
		witnesses.push(__COND__(text && !contains(witnesses, text), text, nil))
	}
	return witnesses
}

func (tc *TypeChecker) eachTypeContainedIn(source Type, types []Type) bool {
	if source.flags & TypeFlagsUnion {
		return !forEach((source /* as UnionType */).types, func(t Type) bool {
			return !contains(types, t)
		})
	} else {
		return contains(types, source)
	}
}

func (tc *TypeChecker) isTypeSubsetOf(source Type, target Type) bool {
	return !!(source == target || source.flags&TypeFlagsNever || target.flags&TypeFlagsUnion && tc.isTypeSubsetOfUnion(source, target /* as UnionType */))
}

func (tc *TypeChecker) isTypeSubsetOfUnion(source Type, target UnionType) bool {
	if source.flags & TypeFlagsUnion {
		for _, t := range (source /* as UnionType */).types {
			if !tc.containsType(target.types, t) {
				return false
			}
		}
		return true
	}
	if source.flags&TypeFlagsEnumLike && tc.getBaseTypeOfEnumLikeType(source /* as LiteralType */) == target {
		return true
	}
	return tc.containsType(target.types, source)
}

func (tc *TypeChecker) forEachType(type_ Type, f func(t Type) *T) *T {
	if type_.flags & TypeFlagsUnion {
		return forEach((type_ /* as UnionType */).types, f)
	} else {
		return f(type_)
	}
}

func (tc *TypeChecker) someType(type_ Type, f func(t Type) bool) bool {
	if type_.flags & TypeFlagsUnion {
		return some((type_ /* as UnionType */).types, f)
	} else {
		return f(type_)
	}
}

func (tc *TypeChecker) everyType(type_ Type, f func(t Type) bool) bool {
	if type_.flags & TypeFlagsUnion {
		return every((type_ /* as UnionType */).types, f)
	} else {
		return f(type_)
	}
}

func (tc *TypeChecker) everyContainedType(type_ Type, f func(t Type) bool) bool {
	if type_.flags & TypeFlagsUnionOrIntersection {
		return every((type_ /* as UnionOrIntersectionType */).types, f)
	} else {
		return f(type_)
	}
}

func (tc *TypeChecker) filterType(type_ Type, f func(t Type) bool) Type {
	if type_.flags & TypeFlagsUnion {
		types := (type_ /* as UnionType */).types
		filtered := filter(types, f)
		if filtered == types {
			return type_
		}
		origin := (type_ /* as UnionType */).origin
		var newOrigin Type
		if origin && origin.flags&TypeFlagsUnion {
			// If the origin type is a (denormalized) union type, filter its non-union constituents. If that ends
			// up removing a smaller number of types than in the normalized constituent set (meaning some of the
			// filtered types are within nested unions in the origin), then we can't construct a new origin type.
			// Otherwise, if we have exactly one type left in the origin set, return that as the filtered type.
			// Otherwise, construct a new filtered origin type.
			originTypes := (origin /* as UnionType */).types
			originFiltered := filter(originTypes, func(t Type) bool {
				return !!(t.flags & TypeFlagsUnion) || f(t)
			})
			if originTypes.length-originFiltered.length == types.length-filtered.length {
				if originFiltered.length == 1 {
					return originFiltered[0]
				}
				newOrigin = tc.createOriginUnionOrIntersectionType(TypeFlagsUnion, originFiltered)
			}
		}
		// filtering could remove intersections so `ContainsIntersections` might be forwarded "incorrectly"
		// it is purely an optimization hint so there is no harm in accidentally forwarding it
		return tc.getUnionTypeFromSortedList(filtered, (type_ /* as UnionType */).objectFlags&(ObjectFlagsPrimitiveUnion|ObjectFlagsContainsIntersections) /*aliasSymbol*/, nil /*aliasTypeArguments*/, nil, newOrigin)
	}
	if type_.flags&TypeFlagsNever || f(type_) {
		return type_
	} else {
		return tc.neverType
	}
}

func (tc *TypeChecker) removeType(type_ Type, targetType Type) Type {
	return tc.filterType(type_, func(t Type) bool {
		return t != targetType
	})
}

func (tc *TypeChecker) countTypes(type_ Type) number {
	if type_.flags & TypeFlagsUnion {
		return (type_ /* as UnionType */).types.length
	} else {
		return 1
	}
}

// Apply a mapping function to a type and return the resulting type. If the source type
// is a union type, the mapping function is applied to each constituent type and a union
// of the resulting types is returned.
/* OVERLOAD: function mapType(type: Type, mapper: (t: Type) => Type, noReductions?: boolean): Type; */
/* OVERLOAD: function mapType(type: Type, mapper: (t: Type) => Type | undefined, noReductions?: boolean): Type | undefined; */
func (tc *TypeChecker) mapType(type_ Type, mapper func(t Type) Type, noReductions bool) Type {
	if type_.flags & TypeFlagsNever {
		return type_
	}
	if !(type_.flags & TypeFlagsUnion) {
		return mapper(type_)
	}
	origin := (type_ /* as UnionType */).origin
	var types []Type
	if origin && origin.flags&TypeFlagsUnion {
		types = (origin /* as UnionType */).types
	} else {
		types = (type_ /* as UnionType */).types
	}
	var mappedTypes *[]Type
	changed := false
	for _, t := range types {
		var mapped Type
		if t.flags & TypeFlagsUnion {
			mapped = tc.mapType(t, mapper, noReductions)
		} else {
			mapped = mapper(t)
		}
		changed = changed || t != mapped
		if mapped {
			if !mappedTypes {
				mappedTypes = []Type{mapped}
			} else {
				mappedTypes.push(mapped)
			}
		}
	}
	if changed {
		return mappedTypes && tc.getUnionType(mappedTypes, __COND__(noReductions, UnionReductionNone, UnionReductionLiteral))
	} else {
		return type_
	}
}

func (tc *TypeChecker) mapTypeWithAlias(type_ Type, mapper func(t Type) Type, aliasSymbol Symbol, aliasTypeArguments *[]Type) Type {
	if type_.flags&TypeFlagsUnion && aliasSymbol {
		return tc.getUnionType(map_((type_ /* as UnionType */).types, mapper), UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
	} else {
		return tc.mapType(type_, mapper)
	}
}

func (tc *TypeChecker) extractTypesOfKind(type_ Type, kind TypeFlags) Type {
	return tc.filterType(type_, func(t Type) bool {
		return (t.flags & kind) != 0
	})
}

// Return a new type in which occurrences of the string, number and bigint primitives and placeholder template
// literal types in typeWithPrimitives have been replaced with occurrences of compatible and more specific types
// from typeWithLiterals. This is essentially a limited form of intersection between the two types. We avoid a
// true intersection because it is more costly and, when applied to union types, generates a large number of
// types we don't actually care about.
func (tc *TypeChecker) replacePrimitivesWithLiterals(typeWithPrimitives Type, typeWithLiterals Type) Type {
	if tc.maybeTypeOfKind(typeWithPrimitives, TypeFlagsString|TypeFlagsTemplateLiteral|TypeFlagsNumber|TypeFlagsBigInt) && tc.maybeTypeOfKind(typeWithLiterals, TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping|TypeFlagsNumberLiteral|TypeFlagsBigIntLiteral) {
		return tc.mapType(typeWithPrimitives, func(t Type) Type {
			switch {
			case t.flags & TypeFlagsString:
				return tc.extractTypesOfKind(typeWithLiterals, TypeFlagsString|TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
			case tc.isPatternLiteralType(t) && !tc.maybeTypeOfKind(typeWithLiterals, TypeFlagsString|TypeFlagsTemplateLiteral|TypeFlagsStringMapping):
				return tc.extractTypesOfKind(typeWithLiterals, TypeFlagsStringLiteral)
			case t.flags & TypeFlagsNumber:
				return tc.extractTypesOfKind(typeWithLiterals, TypeFlagsNumber|TypeFlagsNumberLiteral)
			case t.flags & TypeFlagsBigInt:
				return tc.extractTypesOfKind(typeWithLiterals, TypeFlagsBigInt|TypeFlagsBigIntLiteral)
			default:
				return t
			}
		})
	}
	return typeWithPrimitives
}

func (tc *TypeChecker) isIncomplete(flowType FlowType) bool {
	return flowType.flags == 0
}

func (tc *TypeChecker) getTypeFromFlowType(flowType FlowType) Type {
	if flowType.flags == 0 {
		return flowType.type_
	} else {
		return flowType /* as Type */
	}
}

func (tc *TypeChecker) createFlowType(type_ Type, incomplete bool) FlowType {
	if incomplete {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"flags": 0,
			"type_": __COND__(type_.flags&TypeFlagsNever, tc.silentNeverType, type_),
		}
	} else {
		return type_
	}
}

// An evolving array type tracks the element types that have so far been seen in an
// 'x.push(value)' or 'x[n] = value' operation along the control flow graph. Evolving
// array types are ultimately converted into manifest array types (using getFinalArrayType)
// and never escape the getFlowTypeOfReference function.
func (tc *TypeChecker) createEvolvingArrayType(elementType Type) EvolvingArrayType {
	result := tc.createObjectType(ObjectFlagsEvolvingArray) /* as EvolvingArrayType */
	result.elementType = elementType
	return result
}

func (tc *TypeChecker) getEvolvingArrayType(elementType Type) EvolvingArrayType {
	return tc.evolvingArrayTypes[elementType.id] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType) */ TODO)
}

// When adding evolving array element types we do not perform subtype reduction. Instead,
// we defer subtype reduction until the evolving array type is finalized into a manifest
// array type.
func (tc *TypeChecker) addEvolvingArrayElementType(evolvingArrayType EvolvingArrayType, node Expression) EvolvingArrayType {
	elementType := tc.getRegularTypeOfObjectLiteral(tc.getBaseTypeOfLiteralType(tc.getContextFreeTypeOfExpression(node)))
	if tc.isTypeSubsetOf(elementType, evolvingArrayType.elementType) {
		return evolvingArrayType
	} else {
		return tc.getEvolvingArrayType(tc.getUnionType([]Type{evolvingArrayType.elementType, elementType}))
	}
}

func (tc *TypeChecker) createFinalArrayType(elementType Type) Type {
	if elementType.flags & TypeFlagsNever {
		return tc.autoArrayType
	} else {
		return tc.createArrayType(__COND__(elementType.flags&TypeFlagsUnion, tc.getUnionType((elementType /* as UnionType */).types, UnionReductionSubtype), elementType))
	}
}

// We perform subtype reduction upon obtaining the final array type from an evolving array type.
func (tc *TypeChecker) getFinalArrayType(evolvingArrayType EvolvingArrayType) Type {
	return evolvingArrayType.finalArrayType || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType) */ TODO)
}

func (tc *TypeChecker) finalizeEvolvingArrayType(type_ Type) Type {
	if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
		return tc.getFinalArrayType(type_ /* as EvolvingArrayType */)
	} else {
		return type_
	}
}

func (tc *TypeChecker) getElementTypeOfEvolvingArrayType(type_ Type) Type {
	if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
		return (type_ /* as EvolvingArrayType */).elementType
	} else {
		return tc.neverType
	}
}

func (tc *TypeChecker) isEvolvingArrayTypeList(types []Type) bool {
	hasEvolvingArrayType := false
	for _, t := range types {
		if !(t.flags & TypeFlagsNever) {
			if !(getObjectFlags(t) & ObjectFlagsEvolvingArray) {
				return false
			}
			hasEvolvingArrayType = true
		}
	}
	return hasEvolvingArrayType
}

// Return true if the given node is 'x' in an 'x.length', x.push(value)', 'x.unshift(value)' or
// 'x[n] = value' operation, where 'n' is an expression of type any, undefined, or a number-like type.
func (tc *TypeChecker) isEvolvingArrayOperationTarget(node Node) bool {
	root := tc.getReferenceRoot(node)
	parent := root.parent
	isLengthPushOrUnshift := isPropertyAccessExpression(parent) && (parent.name.escapedText == "length" || parent.parent.kind == SyntaxKindCallExpression && isIdentifier(parent.name) && isPushOrUnshiftIdentifier(parent.name))
	isElementAssignment := parent.kind == SyntaxKindElementAccessExpression && (parent /* as ElementAccessExpression */).expression == root && parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken && (parent.parent /* as BinaryExpression */).left == parent && !isAssignmentTarget(parent.parent) && tc.isTypeAssignableToKind(tc.getTypeOfExpression((parent /* as ElementAccessExpression */).argumentExpression), TypeFlagsNumberLike)
	return isLengthPushOrUnshift || isElementAssignment
}

func (tc *TypeChecker) isDeclarationWithExplicitTypeAnnotation(node Declaration) bool {
	return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) && !!(getEffectiveTypeAnnotationNode(node) || isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer))
}

func (tc *TypeChecker) getExplicitTypeOfSymbol(symbol Symbol, diagnostic Diagnostic) Type {
	symbol = tc.resolveSymbol(symbol)
	if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsValueModule) {
		return tc.getTypeOfSymbol(symbol)
	}
	if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
		if getCheckFlags(symbol) & CheckFlagsMapped {
			origin := (symbol /* as MappedSymbol */).links.syntheticOrigin
			if origin && tc.getExplicitTypeOfSymbol(origin) {
				return tc.getTypeOfSymbol(symbol)
			}
		}
		declaration := symbol.valueDeclaration
		if declaration {
			if tc.isDeclarationWithExplicitTypeAnnotation(declaration) {
				return tc.getTypeOfSymbol(symbol)
			}
			if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
				statement := declaration.parent.parent
				expressionType := tc.getTypeOfDottedName(statement.expression /*diagnostic*/, nil)
				if expressionType {
					var use /* TODO(TS-TO-GO) inferred type IterationUse.ForOf | IterationUse.ForAwaitOf */ any
					if statement.awaitModifier {
						use = IterationUseForAwaitOf
					} else {
						use = IterationUseForOf
					}
					return tc.checkIteratedTypeOrElementType(use, expressionType, tc.undefinedType /*errorNode*/, nil)
				}
			}
			if diagnostic {
				addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, tc.symbolToString(symbol)))
			}
		}
	}
}

// We require the dotted function name in an assertion expression to be comprised of identifiers
// that reference function, method, class or value module symbols; or variable, property or
// parameter symbols with declarations that have explicit type annotations. Such references are
// resolvable with no possibility of triggering circularities in control flow analysis.
func (tc *TypeChecker) getTypeOfDottedName(node Expression, diagnostic *Diagnostic) Type {
	if !(node.flags & NodeFlagsInWithStatement) {
		switch node.kind {
		case SyntaxKindIdentifier:
			symbol := tc.getExportSymbolOfValueSymbolIfExported(tc.getResolvedSymbol(node /* as Identifier */))
			return tc.getExplicitTypeOfSymbol(symbol, diagnostic)
		case SyntaxKindThisKeyword:
			return tc.getExplicitThisType(node)
		case SyntaxKindSuperKeyword:
			return tc.checkSuperExpression(node)
		case SyntaxKindPropertyAccessExpression:
			type_ := tc.getTypeOfDottedName((node /* as PropertyAccessExpression */).expression, diagnostic)
			if type_ {
				name := (node /* as PropertyAccessExpression */).name
				var prop Symbol
				if isPrivateIdentifier(name) {
					if !type_.symbol {
						return nil
					}
					prop = tc.getPropertyOfType(type_, getSymbolNameForPrivateIdentifier(type_.symbol, name.escapedText))
				} else {
					prop = tc.getPropertyOfType(type_, name.escapedText)
				}
				return prop && tc.getExplicitTypeOfSymbol(prop, diagnostic)
			}
			return nil
			fallthrough
		case SyntaxKindParenthesizedExpression:
			return tc.getTypeOfDottedName((node /* as ParenthesizedExpression */).expression, diagnostic)
		}
	}
}

func (tc *TypeChecker) getEffectsSignature(node /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | InstanceofExpression */ any) *Signature {
	links := tc.getNodeLinks(node)
	signature := links.effectsSignature
	if signature == nil {
		// A call expression parented by an expression statement is a potential assertion. Other call
		// expressions are potential type predicate function calls. In order to avoid triggering
		// circularities in control flow analysis, we use getTypeOfDottedName when resolving the call
		// target expression of an assertion.
		var funcType Type
		if isBinaryExpression(node) {
			rightType := tc.checkNonNullExpression(node.right)
			funcType = tc.getSymbolHasInstanceMethodOfObjectType(rightType)
		} else if node.parent.kind == SyntaxKindExpressionStatement {
			funcType = tc.getTypeOfDottedName(node.expression /*diagnostic*/, nil)
		} else if node.expression.kind != SyntaxKindSuperKeyword {
			if isOptionalChain(node) {
				funcType = tc.checkNonNullType(tc.getOptionalExpressionType(tc.checkExpression(node.expression), node.expression), node.expression)
			} else {
				funcType = tc.checkNonNullExpression(node.expression)
			}
		}
		signatures := tc.getSignaturesOfType(funcType && tc.getApparentType(funcType) || tc.unknownType, SignatureKindCall)
		var candidate *Signature
		switch {
		case signatures.length == 1 && !signatures[0].typeParameters:
			candidate = signatures[0]
		case some(signatures, tc.hasTypePredicateOrNeverReturnType):
			candidate = tc.getResolvedSignature(node)
		default:
			candidate = nil
		}
		signature = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature */ TODO
	}
	if signature == tc.unknownSignature {
		return nil
	} else {
		return signature
	}
}

func (tc *TypeChecker) hasTypePredicateOrNeverReturnType(signature Signature) bool {
	return !!(tc.getTypePredicateOfSignature(signature) || signature.declaration && (tc.getReturnTypeFromAnnotation(signature.declaration) || tc.unknownType).flags&TypeFlagsNever)
}

func (tc *TypeChecker) getTypePredicateArgument(predicate TypePredicate, callExpression CallExpression) Expression {
	if predicate.kind == TypePredicateKindIdentifier || predicate.kind == TypePredicateKindAssertsIdentifier {
		return callExpression.arguments[predicate.parameterIndex]
	}
	invokedExpression := skipParentheses(callExpression.expression)
	if isAccessExpression(invokedExpression) {
		return skipParentheses(invokedExpression.expression)
	} else {
		return nil
	}
}

func (tc *TypeChecker) reportFlowControlError(node Node) {
	block := findAncestor(node, isFunctionOrModuleBlock) /* as Block | ModuleBlock | SourceFile */
	sourceFile := getSourceFileOfNode(node)
	span := getSpanOfTokenAtPosition(sourceFile, block.statements.pos)
	tc.diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis))
}

func (tc *TypeChecker) isReachableFlowNode(flow FlowNode) bool {
	result := tc.isReachableFlowNodeWorker(flow /*noCacheCheck*/, false)
	tc.lastFlowNode = flow
	tc.lastFlowNodeReachable = result
	return result
}

func (tc *TypeChecker) isFalseExpression(expr Expression) bool {
	node := skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
	return node.kind == SyntaxKindFalseKeyword || node.kind == SyntaxKindBinaryExpression && ((node /* as BinaryExpression */).operatorToken.kind == SyntaxKindAmpersandAmpersandToken && (tc.isFalseExpression((node /* as BinaryExpression */).left) || tc.isFalseExpression((node /* as BinaryExpression */).right)) || (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken && tc.isFalseExpression((node /* as BinaryExpression */).left) && tc.isFalseExpression((node /* as BinaryExpression */).right))
}

func (tc *TypeChecker) isReachableFlowNodeWorker(flow FlowNode, noCacheCheck bool) bool {
	for true {
		if flow == tc.lastFlowNode {
			return tc.lastFlowNodeReachable
		}
		flags := flow.flags
		if flags & FlowFlagsShared {
			if !noCacheCheck {
				id := tc.getFlowNodeId(flow)
				reachable := tc.flowNodeReachable[id]
				if reachable != nil {
					return reachable
				} else {
					return ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck* / true) */ TODO)
				}
			}
			noCacheCheck = false
		}
		if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation) {
			flow = (flow /* as FlowAssignment | FlowCondition | FlowArrayMutation */).antecedent
		} else if flags & FlowFlagsCall {
			signature := tc.getEffectsSignature((flow /* as FlowCall */).node)
			if signature {
				predicate := tc.getTypePredicateOfSignature(signature)
				if predicate && predicate.kind == TypePredicateKindAssertsIdentifier && !predicate.type_ {
					predicateArgument := (flow /* as FlowCall */).node.arguments[predicate.parameterIndex]
					if predicateArgument && tc.isFalseExpression(predicateArgument) {
						return false
					}
				}
				if tc.getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
					return false
				}
			}
			flow = (flow /* as FlowCall */).antecedent
		} else if flags & FlowFlagsBranchLabel {
			// A branching point is reachable if any branch is reachable.
			return some((flow /* as FlowLabel */).antecedent, func(f FlowNode) bool {
				return tc.isReachableFlowNodeWorker(f /*noCacheCheck*/, false)
			})
		} else if flags & FlowFlagsLoopLabel {
			antecedents := (flow /* as FlowLabel */).antecedent
			if antecedents == nil || antecedents.length == 0 {
				return false
			}
			// A loop is reachable if the control flow path that leads to the top is reachable.
			flow = antecedents[0]
		} else if flags & FlowFlagsSwitchClause {
			// The control flow path representing an unmatched value in a switch statement with
			// no default clause is unreachable if the switch statement is exhaustive.
			data := (flow /* as FlowSwitchClause */).node
			if data.clauseStart == data.clauseEnd && tc.isExhaustiveSwitchStatement(data.switchStatement) {
				return false
			}
			flow = (flow /* as FlowSwitchClause */).antecedent
		} else if flags & FlowFlagsReduceLabel {
			// Cache is unreliable once we start adjusting labels
			tc.lastFlowNode = nil
			target := (flow /* as FlowReduceLabel */).node.target
			saveAntecedents := target.antecedent
			target.antecedent = (flow /* as FlowReduceLabel */).node.antecedents
			result := tc.isReachableFlowNodeWorker((flow /* as FlowReduceLabel */).antecedent /*noCacheCheck*/, false)
			target.antecedent = saveAntecedents
			return result
		} else {
			return !(flags & FlowFlagsUnreachable)
		}
	}
}

// Return true if the given flow node is preceded by a 'super(...)' call in every possible code path
// leading to the node.
func (tc *TypeChecker) isPostSuperFlowNode(flow FlowNode, noCacheCheck bool) bool {
	for true {
		flags := flow.flags
		if flags & FlowFlagsShared {
			if !noCacheCheck {
				id := tc.getFlowNodeId(flow)
				postSuper := tc.flowNodePostSuper[id]
				if postSuper != nil {
					return postSuper
				} else {
					return ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck* / true) */ TODO)
				}
			}
			noCacheCheck = false
		}
		if flags & (FlowFlagsAssignment | FlowFlagsCondition | FlowFlagsArrayMutation | FlowFlagsSwitchClause) {
			flow = (flow /* as FlowAssignment | FlowCondition | FlowArrayMutation | FlowSwitchClause */).antecedent
		} else if flags & FlowFlagsCall {
			if (flow /* as FlowCall */).node.expression.kind == SyntaxKindSuperKeyword {
				return true
			}
			flow = (flow /* as FlowCall */).antecedent
		} else if flags & FlowFlagsBranchLabel {
			// A branching point is post-super if every branch is post-super.
			return every((flow /* as FlowLabel */).antecedent, func(f FlowNode) bool {
				return tc.isPostSuperFlowNode(f /*noCacheCheck*/, false)
			})
		} else if flags & FlowFlagsLoopLabel {
			// A loop is post-super if the control flow path that leads to the top is post-super.
			flow = (flow /* as FlowLabel */).antecedent[0]
		} else if flags & FlowFlagsReduceLabel {
			target := (flow /* as FlowReduceLabel */).node.target
			saveAntecedents := target.antecedent
			target.antecedent = (flow /* as FlowReduceLabel */).node.antecedents
			result := tc.isPostSuperFlowNode((flow /* as FlowReduceLabel */).antecedent /*noCacheCheck*/, false)
			target.antecedent = saveAntecedents
			return result
		} else {
			// Unreachable nodes are considered post-super to silence errors
			return !!(flags & FlowFlagsUnreachable)
		}
	}
}

func (tc *TypeChecker) isConstantReference(node Node) bool {
	switch node.kind {
	case SyntaxKindThisKeyword:
		return true
	case SyntaxKindIdentifier:
		if !isThisInTypeQuery(node) {
			symbol := tc.getResolvedSymbol(node /* as Identifier */)
			return tc.isConstantVariable(symbol) || tc.isParameterOrMutableLocalVariable(symbol) && !tc.isSymbolAssigned(symbol) || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration)
		}
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		return tc.isConstantReference((node /* as AccessExpression */).expression) && tc.isReadonlySymbol(tc.getNodeLinks(node).resolvedSymbol || tc.unknownSymbol)
	case SyntaxKindObjectBindingPattern,
		SyntaxKindArrayBindingPattern:
		rootDeclaration := getRootDeclaration(node.parent)
		if isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration) {
			return !tc.isSomeSymbolAssigned(rootDeclaration)
		} else {
			return isVariableDeclaration(rootDeclaration) && tc.isVarConstLike(rootDeclaration)
		}
	}
	return false
}

func (tc *TypeChecker) getFlowTypeOfReference(reference Node, declaredType Type, initialType Type /*  = declaredType */, flowContainer Node, flowNode *FlowNode /*  = tryCast(reference, canHaveFlowNode)?.flowNode */) Type {
	var key *string
	isKeySet := false
	flowDepth := 0
	if tc.flowAnalysisDisabled {
		return tc.errorType
	}
	if !flowNode {
		return declaredType
	}
	tc.flowInvocationCount++
	sharedFlowStart := tc.sharedFlowCount
	evolvedType := tc.getTypeFromFlowType(getTypeAtFlowNode(flowNode))
	tc.sharedFlowCount = sharedFlowStart
	// When the reference is 'x' in an 'x.length', 'x.push(value)', 'x.unshift(value)' or x[n] = value' operation,
	// we give type 'any[]' to 'x' instead of using the type determined by control flow analysis such that operations
	// on empty arrays are possible without implicit any errors and new element types can be inferred without
	// type mismatch errors.
	var resultType Type
	if getObjectFlags(evolvedType)&ObjectFlagsEvolvingArray && tc.isEvolvingArrayOperationTarget(reference) {
		resultType = tc.autoArrayType
	} else {
		resultType = tc.finalizeEvolvingArrayType(evolvedType)
	}
	if resultType == tc.unreachableNeverType || reference.parent && reference.parent.kind == SyntaxKindNonNullExpression && !(resultType.flags&TypeFlagsNever) && tc.getTypeWithFacts(resultType, TypeFactsNEUndefinedOrNull).flags&TypeFlagsNever {
		return declaredType
	}
	return resultType

	getOrSetCacheKey := func() *string {
		if isKeySet {
			return key
		}
		isKeySet = true
		key = tc.getFlowCacheKey(reference, declaredType, initialType, flowContainer)
		return key
	}

	getTypeAtFlowNode := func(flow FlowNode) FlowType {
		if flowDepth == 2000 {
			// We have made 2000 recursive invocations. To avoid overflowing the call stack we report an error
			// and disable further control flow analysis in the containing function or module body.
			tracing. /* ? */ instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit", map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"flowId": flow.id,
			})
			tc.flowAnalysisDisabled = true
			tc.reportFlowControlError(reference)
			return tc.errorType
		}
		flowDepth++
		var sharedFlow *FlowNode
		for true {
			flags := flow.flags
			if flags & FlowFlagsShared {
				// We cache results of flow type resolution for shared nodes that were previously visited in
				// the same getFlowTypeOfReference invocation. A node is considered shared when it is the
				// antecedent of more than one node.
				for i := sharedFlowStart; i < tc.sharedFlowCount; i++ {
					if tc.sharedFlowNodes[i] == flow {
						flowDepth--
						return tc.sharedFlowTypes[i]
					}
				}
				sharedFlow = flow
			}
			var type_ *FlowType
			if flags & FlowFlagsAssignment {
				type_ = getTypeAtFlowAssignment(flow /* as FlowAssignment */)
				if !type_ {
					flow = (flow /* as FlowAssignment */).antecedent
					continue
				}
			} else if flags & FlowFlagsCall {
				type_ = getTypeAtFlowCall(flow /* as FlowCall */)
				if !type_ {
					flow = (flow /* as FlowCall */).antecedent
					continue
				}
			} else if flags & FlowFlagsCondition {
				type_ = getTypeAtFlowCondition(flow /* as FlowCondition */)
			} else if flags & FlowFlagsSwitchClause {
				type_ = getTypeAtSwitchClause(flow /* as FlowSwitchClause */)
			} else if flags & FlowFlagsLabel {
				if (flow /* as FlowLabel */).antecedent.length == 1 {
					flow = (flow /* as FlowLabel */).antecedent[0]
					continue
				}
				if flags & FlowFlagsBranchLabel {
					type_ = getTypeAtFlowBranchLabel(flow /* as FlowLabel */)
				} else {
					type_ = getTypeAtFlowLoopLabel(flow /* as FlowLabel */)
				}
			} else if flags & FlowFlagsArrayMutation {
				type_ = getTypeAtFlowArrayMutation(flow /* as FlowArrayMutation */)
				if !type_ {
					flow = (flow /* as FlowArrayMutation */).antecedent
					continue
				}
			} else if flags & FlowFlagsReduceLabel {
				target := (flow /* as FlowReduceLabel */).node.target
				saveAntecedents := target.antecedent
				target.antecedent = (flow /* as FlowReduceLabel */).node.antecedents
				type_ = getTypeAtFlowNode((flow /* as FlowReduceLabel */).antecedent)
				target.antecedent = saveAntecedents
			} else if flags & FlowFlagsStart {
				// Check if we should continue with the control flow of the containing function.
				container := (flow /* as FlowStart */).node
				if container && container != flowContainer && reference.kind != SyntaxKindPropertyAccessExpression && reference.kind != SyntaxKindElementAccessExpression && !(reference.kind == SyntaxKindThisKeyword && container.kind != SyntaxKindArrowFunction) {
					flow = container.flowNode
					continue
				}
				// At the top of the flow we have the initial type.
				type_ = initialType
			} else {
				// Unreachable code errors are reported in the binding phase. Here we
				// simply return the non-auto declared type to reduce follow-on errors.
				type_ = tc.convertAutoToAny(declaredType)
			}
			if sharedFlow {
				// Record visited node and the associated type in the cache.
				tc.sharedFlowNodes[tc.sharedFlowCount] = sharedFlow
				tc.sharedFlowTypes[tc.sharedFlowCount] = type_
				tc.sharedFlowCount++
			}
			flowDepth--
			return type_
		}
	}

	getInitialOrAssignedType := func(flow FlowAssignment) Type {
		node := flow.node
		return tc.getNarrowableTypeForReference(__COND__(node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindBindingElement, tc.getInitialType(node /* as VariableDeclaration | BindingElement */), tc.getAssignedType(node)), reference)
	}

	getTypeAtFlowAssignment := func(flow FlowAssignment) *FlowType {
		node := flow.node
		// Assignments only narrow the computed type if the declared type is a union type. Thus, we
		// only need to evaluate the assigned type if the declared type is a union type.
		if tc.isMatchingReference(reference, node) {
			if !tc.isReachableFlowNode(flow) {
				return tc.unreachableNeverType
			}
			if getAssignmentTargetKind(node) == AssignmentKindCompound {
				flowType := getTypeAtFlowNode(flow.antecedent)
				return tc.createFlowType(tc.getBaseTypeOfLiteralType(tc.getTypeFromFlowType(flowType)), tc.isIncomplete(flowType))
			}
			if declaredType == tc.autoType || declaredType == tc.autoArrayType {
				if tc.isEmptyArrayAssignment(node) {
					return tc.getEvolvingArrayType(tc.neverType)
				}
				assignedType := tc.getWidenedLiteralType(getInitialOrAssignedType(flow))
				if tc.isTypeAssignableTo(assignedType, declaredType) {
					return assignedType
				} else {
					return tc.anyArrayType
				}
			}
			var t Type
			if isInCompoundLikeAssignment(node) {
				t = tc.getBaseTypeOfLiteralType(declaredType)
			} else {
				t = declaredType
			}
			if t.flags & TypeFlagsUnion {
				return tc.getAssignmentReducedType(t /* as UnionType */, getInitialOrAssignedType(flow))
			}
			return t
		}
		// We didn't have a direct match. However, if the reference is a dotted name, this
		// may be an assignment to a left hand part of the reference. For example, for a
		// reference 'x.y.z', we may be at an assignment to 'x.y' or 'x'. In that case,
		// return the declared type.
		if tc.containsMatchingReference(reference, node) {
			if !tc.isReachableFlowNode(flow) {
				return tc.unreachableNeverType
			}
			// A matching dotted name might also be an expando property on a function *expression*,
			// in which case we continue control flow analysis back to the function's declaration
			if isVariableDeclaration(node) && (isInJSFile(node) || tc.isVarConstLike(node)) {
				init := getDeclaredExpandoInitializer(node)
				if init && (init.kind == SyntaxKindFunctionExpression || init.kind == SyntaxKindArrowFunction) {
					return getTypeAtFlowNode(flow.antecedent)
				}
			}
			return declaredType
		}
		// for (const _ in ref) acts as a nonnull on ref
		if isVariableDeclaration(node) && node.parent.parent.kind == SyntaxKindForInStatement && (tc.isMatchingReference(reference, node.parent.parent.expression) || tc.optionalChainContainsReference(node.parent.parent.expression, reference)) {
			return tc.getNonNullableTypeIfNeeded(tc.finalizeEvolvingArrayType(tc.getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))))
		}
		// Assignment doesn't affect reference
		return nil
	}

	narrowTypeByAssertion := func(type_ Type, expr Expression) Type {
		node := skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
		if node.kind == SyntaxKindFalseKeyword {
			return tc.unreachableNeverType
		}
		if node.kind == SyntaxKindBinaryExpression {
			if (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
				return narrowTypeByAssertion(narrowTypeByAssertion(type_, (node /* as BinaryExpression */).left), (node /* as BinaryExpression */).right)
			}
			if (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken {
				return tc.getUnionType([]Type{narrowTypeByAssertion(type_, (node /* as BinaryExpression */).left), narrowTypeByAssertion(type_, (node /* as BinaryExpression */).right)})
			}
		}
		return narrowType(type_, node /*assumeTrue*/, true)
	}

	getTypeAtFlowCall := func(flow FlowCall) *FlowType {
		signature := tc.getEffectsSignature(flow.node)
		if signature {
			predicate := tc.getTypePredicateOfSignature(signature)
			if predicate && (predicate.kind == TypePredicateKindAssertsThis || predicate.kind == TypePredicateKindAssertsIdentifier) {
				flowType := getTypeAtFlowNode(flow.antecedent)
				type_ := tc.finalizeEvolvingArrayType(tc.getTypeFromFlowType(flowType))
				var narrowedType Type
				switch {
				case predicate.type_:
					narrowedType = narrowTypeByTypePredicate(type_, predicate, flow.node /*assumeTrue*/, true)
				case predicate.kind == TypePredicateKindAssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length:
					narrowedType = narrowTypeByAssertion(type_, flow.node.arguments[predicate.parameterIndex])
				default:
					narrowedType = type_
				}
				if narrowedType == type_ {
					return flowType
				} else {
					return tc.createFlowType(narrowedType, tc.isIncomplete(flowType))
				}
			}
			if tc.getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
				return tc.unreachableNeverType
			}
		}
		return nil
	}

	getTypeAtFlowArrayMutation := func(flow FlowArrayMutation) *FlowType {
		if declaredType == tc.autoType || declaredType == tc.autoArrayType {
			node := flow.node
			var expr LeftHandSideExpression
			if node.kind == SyntaxKindCallExpression {
				expr = (node.expression /* as PropertyAccessExpression */).expression
			} else {
				expr = (node.left /* as ElementAccessExpression */).expression
			}
			if tc.isMatchingReference(reference, tc.getReferenceCandidate(expr)) {
				flowType := getTypeAtFlowNode(flow.antecedent)
				type_ := tc.getTypeFromFlowType(flowType)
				if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
					evolvedType := type_ /* as EvolvingArrayType */
					if node.kind == SyntaxKindCallExpression {
						for _, arg := range node.arguments {
							evolvedType = tc.addEvolvingArrayElementType(evolvedType, arg)
						}
					} else {
						// We must get the context free expression type so as to not recur in an uncached fashion on the LHS (which causes exponential blowup in compile time)
						indexType := tc.getContextFreeTypeOfExpression((node.left /* as ElementAccessExpression */).argumentExpression)
						if tc.isTypeAssignableToKind(indexType, TypeFlagsNumberLike) {
							evolvedType = tc.addEvolvingArrayElementType(evolvedType, node.right)
						}
					}
					if evolvedType == type_ {
						return flowType
					} else {
						return tc.createFlowType(evolvedType, tc.isIncomplete(flowType))
					}
				}
				return flowType
			}
		}
		return nil
	}

	getTypeAtFlowCondition := func(flow FlowCondition) FlowType {
		flowType := getTypeAtFlowNode(flow.antecedent)
		type_ := tc.getTypeFromFlowType(flowType)
		if type_.flags & TypeFlagsNever {
			return flowType
		}
		// If we have an antecedent type (meaning we're reachable in some way), we first
		// attempt to narrow the antecedent type. If that produces the never type, and if
		// the antecedent type is incomplete (i.e. a transient type in a loop), then we
		// take the type guard as an indication that control *could* reach here once we
		// have the complete type. We proceed by switching to the silent never type which
		// doesn't report errors when operators are applied to it. Note that this is the
		// *only* place a silent never type is ever generated.
		assumeTrue := (flow.flags & FlowFlagsTrueCondition) != 0
		nonEvolvingType := tc.finalizeEvolvingArrayType(type_)
		narrowedType := narrowType(nonEvolvingType, flow.node, assumeTrue)
		if narrowedType == nonEvolvingType {
			return flowType
		}
		return tc.createFlowType(narrowedType, tc.isIncomplete(flowType))
	}

	getTypeAtSwitchClause := func(flow FlowSwitchClause) FlowType {
		expr := skipParentheses(flow.node.switchStatement.expression)
		flowType := getTypeAtFlowNode(flow.antecedent)
		type_ := tc.getTypeFromFlowType(flowType)
		if tc.isMatchingReference(reference, expr) {
			type_ = narrowTypeBySwitchOnDiscriminant(type_, flow.node)
		} else if expr.kind == SyntaxKindTypeOfExpression && tc.isMatchingReference(reference, (expr /* as TypeOfExpression */).expression) {
			type_ = narrowTypeBySwitchOnTypeOf(type_, flow.node)
		} else if expr.kind == SyntaxKindTrueKeyword {
			type_ = narrowTypeBySwitchOnTrue(type_, flow.node)
		} else {
			if tc.strictNullChecks {
				if tc.optionalChainContainsReference(expr, reference) {
					type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t Type) bool {
						return !(t.flags & (TypeFlagsUndefined | TypeFlagsNever))
					})
				} else if expr.kind == SyntaxKindTypeOfExpression && tc.optionalChainContainsReference((expr /* as TypeOfExpression */).expression, reference) {
					type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t Type) bool {
						return !(t.flags&TypeFlagsNever || t.flags&TypeFlagsStringLiteral && (t /* as StringLiteralType */).value == "undefined")
					})
				}
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				type_ = narrowTypeBySwitchOnDiscriminantProperty(type_, access, flow.node)
			}
		}
		return tc.createFlowType(type_, tc.isIncomplete(flowType))
	}

	getTypeAtFlowBranchLabel := func(flow FlowLabel) FlowType {
		var antecedentTypes []Type = []never{}
		subtypeReduction := false
		seenIncomplete := false
		var bypassFlow *FlowSwitchClause
		for _, antecedent := range flow.antecedent {
			if !bypassFlow && antecedent.flags&FlowFlagsSwitchClause && (antecedent /* as FlowSwitchClause */).node.clauseStart == (antecedent /* as FlowSwitchClause */).node.clauseEnd {
				// The antecedent is the bypass branch of a potentially exhaustive switch statement.
				bypassFlow = antecedent /* as FlowSwitchClause */
				continue
			}
			flowType := getTypeAtFlowNode(antecedent)
			type_ := tc.getTypeFromFlowType(flowType)
			// If the type at a particular antecedent path is the declared type and the
			// reference is known to always be assigned (i.e. when declared and initial types
			// are the same), there is no reason to process more antecedents since the only
			// possible outcome is subtypes that will be removed in the final union type anyway.
			if type_ == declaredType && declaredType == initialType {
				return type_
			}
			pushIfUnique(antecedentTypes, type_)
			// If an antecedent type is not a subset of the declared type, we need to perform
			// subtype reduction. This happens when a "foreign" type is injected into the control
			// flow using the instanceof operator or a user defined type predicate.
			if !tc.isTypeSubsetOf(type_, initialType) {
				subtypeReduction = true
			}
			if tc.isIncomplete(flowType) {
				seenIncomplete = true
			}
		}
		if bypassFlow {
			flowType := getTypeAtFlowNode(bypassFlow)
			type_ := tc.getTypeFromFlowType(flowType)
			// If the bypass flow contributes a type we haven't seen yet and the switch statement
			// isn't exhaustive, process the bypass flow type. Since exhaustiveness checks increase
			// the risk of circularities, we only want to perform them when they make a difference.
			if !(type_.flags & TypeFlagsNever) && !contains(antecedentTypes, type_) && !tc.isExhaustiveSwitchStatement(bypassFlow.node.switchStatement) {
				if type_ == declaredType && declaredType == initialType {
					return type_
				}
				antecedentTypes.push(type_)
				if !tc.isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if tc.isIncomplete(flowType) {
					seenIncomplete = true
				}
			}
		}
		return tc.createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, __COND__(subtypeReduction, UnionReductionSubtype, UnionReductionLiteral)), seenIncomplete)
	}

	getTypeAtFlowLoopLabel := func(flow FlowLabel) FlowType {
		// If we have previously computed the control flow type for the reference at
		// this flow loop junction, return the cached type.
		id := tc.getFlowNodeId(flow)
		cache := tc.flowLoopCaches[id] || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: flowLoopCaches[id] = new Map<string, Type>() */ TODO)
		key := getOrSetCacheKey()
		if !key {
			// No cache key is generated when binding patterns are in unnarrowable situations
			return declaredType
		}
		cached := cache.get(key)
		if cached {
			return cached
		}
		// If this flow loop junction and reference are already being processed, return
		// the union of the types computed for each branch so far, marked as incomplete.
		// It is possible to see an empty array in cases where loops are nested and the
		// back edge of the outer loop reaches an inner loop that is already being analyzed.
		// In such cases we restart the analysis of the inner loop, which will then see
		// a non-empty in-process array for the outer loop and eventually terminate because
		// the first antecedent of a loop junction is always the non-looping control flow
		// path that leads to the top.
		for i := tc.flowLoopStart; i < tc.flowLoopCount; i++ {
			if tc.flowLoopNodes[i] == flow && tc.flowLoopKeys[i] == key && tc.flowLoopTypes[i].length {
				return tc.createFlowType(getUnionOrEvolvingArrayType(tc.flowLoopTypes[i], UnionReductionLiteral) /*incomplete*/, true)
			}
		}
		// Add the flow loop junction and reference to the in-process stack and analyze
		// each antecedent code path.
		var antecedentTypes []Type = []never{}
		subtypeReduction := false
		var firstAntecedentType *FlowType
		for _, antecedent := range flow.antecedent {
			var flowType TODO
			if !firstAntecedentType {
				// The first antecedent of a loop junction is always the non-looping control
				// flow path that leads to the top.
				flowType = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: firstAntecedentType = getTypeAtFlowNode(antecedent) */ TODO
			} else {
				// All but the first antecedent are the looping control flow paths that lead
				// back to the loop junction. We track these on the flow loop stack.
				tc.flowLoopNodes[tc.flowLoopCount] = flow
				tc.flowLoopKeys[tc.flowLoopCount] = key
				tc.flowLoopTypes[tc.flowLoopCount] = antecedentTypes
				tc.flowLoopCount++
				saveFlowTypeCache := tc.flowTypeCache
				tc.flowTypeCache = nil
				flowType = getTypeAtFlowNode(antecedent)
				tc.flowTypeCache = saveFlowTypeCache
				tc.flowLoopCount--
				// If we see a value appear in the cache it is a sign that control flow analysis
				// was restarted and completed by checkExpressionCached. We can simply pick up
				// the resulting type and bail out.
				cached := cache.get(key)
				if cached {
					return cached
				}
			}
			type_ := tc.getTypeFromFlowType(flowType)
			pushIfUnique(antecedentTypes, type_)
			// If an antecedent type is not a subset of the declared type, we need to perform
			// subtype reduction. This happens when a "foreign" type is injected into the control
			// flow using the instanceof operator or a user defined type predicate.
			if !tc.isTypeSubsetOf(type_, initialType) {
				subtypeReduction = true
			}
			// If the type at a particular antecedent path is the declared type there is no
			// reason to process more antecedents since the only possible outcome is subtypes
			// that will be removed in the final union type anyway.
			if type_ == declaredType {
				break
			}
		}
		// The result is incomplete if the first antecedent (the non-looping control flow path)
		// is incomplete.
		result := getUnionOrEvolvingArrayType(antecedentTypes, __COND__(subtypeReduction, UnionReductionSubtype, UnionReductionLiteral))
		if tc.isIncomplete(firstAntecedentType) {
			return tc.createFlowType(result /*incomplete*/, true)
		}
		cache.set(key, result)
		return result
	}

	// At flow control branch or loop junctions, if the type along every antecedent code path
	// is an evolving array type, we construct a combined evolving array type. Otherwise we
	// finalize all evolving array types.
	getUnionOrEvolvingArrayType := func(types []Type, subtypeReduction UnionReduction) Type {
		if tc.isEvolvingArrayTypeList(types) {
			return tc.getEvolvingArrayType(tc.getUnionType(map_(types, tc.getElementTypeOfEvolvingArrayType)))
		}
		result := tc.recombineUnknownType(tc.getUnionType(sameMap(types, tc.finalizeEvolvingArrayType), subtypeReduction))
		if result != declaredType && result.flags&declaredType.flags&TypeFlagsUnion && arrayIsEqualTo((result /* as UnionType */).types, (declaredType /* as UnionType */).types) {
			return declaredType
		}
		return result
	}

	getCandidateDiscriminantPropertyAccess := func(expr Expression) * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | BindingElement | AccessExpression */ any {
		if isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference) {
			// When the reference is a binding pattern or function or arrow expression, we are narrowing a pesudo-reference in
			// getNarrowedTypeOfSymbol. An identifier for a destructuring variable declared in the same binding pattern or
			// parameter declared in the same parameter list is a candidate.
			if isIdentifier(expr) {
				symbol := tc.getResolvedSymbol(expr)
				declaration := symbol.valueDeclaration
				if declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference == declaration.parent && !declaration.initializer && !declaration.dotDotDotToken {
					return declaration
				}
			}
		} else if isAccessExpression(expr) {
			// An access expression is a candidate if the reference matches the left hand expression.
			if tc.isMatchingReference(reference, expr.expression) {
				return expr
			}
		} else if isIdentifier(expr) {
			symbol := tc.getResolvedSymbol(expr)
			if tc.isConstantVariable(symbol) {
				declaration := symbol.valueDeclaration
				// Given 'const x = obj.kind', allow 'x' as an alias for 'obj.kind'
				if isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isAccessExpression(declaration.initializer) && tc.isMatchingReference(reference, declaration.initializer.expression) {
					return declaration.initializer
				}
				// Given 'const { kind: x } = obj', allow 'x' as an alias for 'obj.kind'
				if isBindingElement(declaration) && !declaration.initializer {
					parent := declaration.parent.parent
					if isVariableDeclaration(parent) && !parent.type_ && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) && tc.isMatchingReference(reference, parent.initializer) {
						return declaration
					}
				}
			}
		}
		return nil
	}

	getDiscriminantPropertyAccess := func(expr Expression, computedType Type) * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | BindingElement | AccessExpression */ any {
		// As long as the computed type is a subset of the declared type, we use the full declared type to detect
		// a discriminant property. In cases where the computed type isn't a subset, e.g because of a preceding type
		// predicate narrowing, we use the actual computed type.
		if declaredType.flags&TypeFlagsUnion || computedType.flags&TypeFlagsUnion {
			access := getCandidateDiscriminantPropertyAccess(expr)
			if access {
				name := tc.getAccessedPropertyName(access)
				if name {
					var type_ Type
					if declaredType.flags&TypeFlagsUnion && tc.isTypeSubsetOf(computedType, declaredType) {
						type_ = declaredType
					} else {
						type_ = computedType
					}
					if tc.isDiscriminantProperty(type_, name) {
						return access
					}
				}
			}
		}
		return nil
	}

	narrowTypeByDiscriminant := func(type_ Type, access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any, narrowType func(t Type) Type) Type {
		propName := tc.getAccessedPropertyName(access)
		if propName == nil {
			return type_
		}
		optionalChain := isOptionalChain(access)
		removeNullable := tc.strictNullChecks && (optionalChain || isNonNullAccess(access)) && tc.maybeTypeOfKind(type_, TypeFlagsNullable)
		propType := tc.getTypeOfPropertyOfType(__COND__(removeNullable, tc.getTypeWithFacts(type_, TypeFactsNEUndefinedOrNull), type_), propName)
		if !propType {
			return type_
		}
		if removeNullable && optionalChain {
			propType = tc.getOptionalType(propType)
		} else {
			propType = propType
		}
		narrowedPropType := narrowType(propType)
		return tc.filterType(type_, func(t Type) bool {
			discriminantType := tc.getTypeOfPropertyOrIndexSignatureOfType(t, propName) || tc.unknownType
			return !(discriminantType.flags & TypeFlagsNever) && !(narrowedPropType.flags & TypeFlagsNever) && tc.areTypesComparable(narrowedPropType, discriminantType)
		})
	}

	narrowTypeByDiscriminantProperty := func(type_ Type, access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any, operator SyntaxKind, value Expression, assumeTrue bool) Type {
		if (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken) && type_.flags&TypeFlagsUnion {
			keyPropertyName := tc.getKeyPropertyName(type_ /* as UnionType */)
			if keyPropertyName && keyPropertyName == tc.getAccessedPropertyName(access) {
				candidate := tc.getConstituentTypeForKeyType(type_ /* as UnionType */, tc.getTypeOfExpression(value))
				if candidate {
					switch {
					case operator == (__COND__(assumeTrue, SyntaxKindEqualsEqualsEqualsToken, SyntaxKindExclamationEqualsEqualsToken)):
						return candidate
					case tc.isUnitType(tc.getTypeOfPropertyOfType(candidate, keyPropertyName) || tc.unknownType):
						return tc.removeType(type_, candidate)
					default:
						return type_
					}
				}
			}
		}
		return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
			return narrowTypeByEquality(t, operator, value, assumeTrue)
		})
	}

	narrowTypeBySwitchOnDiscriminantProperty := func(type_ Type, access /* TODO(TS-TO-GO) TypeNode UnionType: AccessExpression | BindingElement | ParameterDeclaration */ any, data FlowSwitchClauseData) Type {
		if data.clauseStart < data.clauseEnd && type_.flags&TypeFlagsUnion && tc.getKeyPropertyName(type_ /* as UnionType */) == tc.getAccessedPropertyName(access) {
			clauseTypes := tc.getSwitchClauseTypes(data.switchStatement).slice(data.clauseStart, data.clauseEnd)
			candidate := tc.getUnionType(map_(clauseTypes, func(t Type) Type {
				return tc.getConstituentTypeForKeyType(type_ /* as UnionType */, t) || tc.unknownType
			}))
			if candidate != tc.unknownType {
				return candidate
			}
		}
		return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
			return narrowTypeBySwitchOnDiscriminant(t, data)
		})
	}

	narrowTypeByTruthiness := func(type_ Type, expr Expression, assumeTrue bool) Type {
		if tc.isMatchingReference(reference, expr) {
			return tc.getAdjustedTypeWithFacts(type_, __COND__(assumeTrue, TypeFactsTruthy, TypeFactsFalsy))
		}
		if tc.strictNullChecks && assumeTrue && tc.optionalChainContainsReference(expr, reference) {
			type_ = tc.getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
		}
		access := getDiscriminantPropertyAccess(expr, type_)
		if access {
			return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
				return tc.getTypeWithFacts(t, __COND__(assumeTrue, TypeFactsTruthy, TypeFactsFalsy))
			})
		}
		return type_
	}

	isTypePresencePossible := func(type_ Type, propName __String, assumeTrue bool) bool {
		prop := tc.getPropertyOfType(type_, propName)
		if prop {
			return !!(prop.flags&SymbolFlagsOptional || getCheckFlags(prop)&CheckFlagsPartial) || assumeTrue
		} else {
			return !!tc.getApplicableIndexInfoForName(type_, propName) || !assumeTrue
		}
	}

	narrowTypeByInKeyword := func(type_ Type, nameType /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any, assumeTrue bool) Type {
		name := getPropertyNameFromType(nameType)
		isKnownProperty := tc.someType(type_, func(t Type) bool {
			return isTypePresencePossible(t, name /*assumeTrue*/, true)
		})
		if isKnownProperty {
			// If the check is for a known property (i.e. a property declared in some constituent of
			// the target type), we filter the target type by presence of absence of the property.
			return tc.filterType(type_, func(t Type) bool {
				return isTypePresencePossible(t, name, assumeTrue)
			})
		}
		if assumeTrue {
			// If the check is for an unknown property, we intersect the target type with `Record<X, unknown>`,
			// where X is the name of the property.
			recordSymbol := tc.getGlobalRecordSymbol()
			if recordSymbol {
				return tc.getIntersectionType([]Type{type_, tc.getTypeAliasInstantiation(recordSymbol, [] /* TODO(TS-TO-GO) inferred type IntrinsicType | StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any{nameType, tc.unknownType})})
			}
		}
		return type_
	}

	narrowTypeByBooleanComparison := func(type_ Type, expr Expression, bool BooleanLiteral, operator BinaryOperator, assumeTrue bool) Type {
		assumeTrue = (assumeTrue != (bool.kind == SyntaxKindTrueKeyword)) != (operator != SyntaxKindExclamationEqualsEqualsToken && operator != SyntaxKindExclamationEqualsToken)
		return narrowType(type_, expr, assumeTrue)
	}

	narrowTypeByBinaryExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
		switch expr.operatorToken.kind {
		case SyntaxKindEqualsToken,
			SyntaxKindBarBarEqualsToken,
			SyntaxKindAmpersandAmpersandEqualsToken,
			SyntaxKindQuestionQuestionEqualsToken:
			return narrowTypeByTruthiness(narrowType(type_, expr.right, assumeTrue), expr.left, assumeTrue)
		case SyntaxKindEqualsEqualsToken,
			SyntaxKindExclamationEqualsToken,
			SyntaxKindEqualsEqualsEqualsToken,
			SyntaxKindExclamationEqualsEqualsToken:
			operator := expr.operatorToken.kind
			left := tc.getReferenceCandidate(expr.left)
			right := tc.getReferenceCandidate(expr.right)
			if left.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(right) {
				return narrowTypeByTypeof(type_, left /* as TypeOfExpression */, operator, right, assumeTrue)
			}
			if right.kind == SyntaxKindTypeOfExpression && isStringLiteralLike(left) {
				return narrowTypeByTypeof(type_, right /* as TypeOfExpression */, operator, left, assumeTrue)
			}
			if tc.isMatchingReference(reference, left) {
				return narrowTypeByEquality(type_, operator, right, assumeTrue)
			}
			if tc.isMatchingReference(reference, right) {
				return narrowTypeByEquality(type_, operator, left, assumeTrue)
			}
			if tc.strictNullChecks {
				if tc.optionalChainContainsReference(left, reference) {
					type_ = narrowTypeByOptionalChainContainment(type_, operator, right, assumeTrue)
				} else if tc.optionalChainContainsReference(right, reference) {
					type_ = narrowTypeByOptionalChainContainment(type_, operator, left, assumeTrue)
				}
			}
			leftAccess := getDiscriminantPropertyAccess(left, type_)
			if leftAccess {
				return narrowTypeByDiscriminantProperty(type_, leftAccess, operator, right, assumeTrue)
			}
			rightAccess := getDiscriminantPropertyAccess(right, type_)
			if rightAccess {
				return narrowTypeByDiscriminantProperty(type_, rightAccess, operator, left, assumeTrue)
			}
			if isMatchingConstructorReference(left) {
				return narrowTypeByConstructor(type_, operator, right, assumeTrue)
			}
			if isMatchingConstructorReference(right) {
				return narrowTypeByConstructor(type_, operator, left, assumeTrue)
			}
			if isBooleanLiteral(right) && !isAccessExpression(left) {
				return narrowTypeByBooleanComparison(type_, left, right, operator, assumeTrue)
			}
			if isBooleanLiteral(left) && !isAccessExpression(right) {
				return narrowTypeByBooleanComparison(type_, right, left, operator, assumeTrue)
			}
		case SyntaxKindInstanceOfKeyword:
			return narrowTypeByInstanceof(type_, expr /* as InstanceofExpression */, assumeTrue)
		case SyntaxKindInKeyword:
			if isPrivateIdentifier(expr.left) {
				return narrowTypeByPrivateIdentifierInInExpression(type_, expr, assumeTrue)
			}
			target := tc.getReferenceCandidate(expr.right)
			if tc.containsMissingType(type_) && isAccessExpression(reference) && tc.isMatchingReference(reference.expression, target) {
				leftType := tc.getTypeOfExpression(expr.left)
				if isTypeUsableAsPropertyName(leftType) && tc.getAccessedPropertyName(reference) == getPropertyNameFromType(leftType) {
					return tc.getTypeWithFacts(type_, __COND__(assumeTrue, TypeFactsNEUndefined, TypeFactsEQUndefined))
				}
			}
			if tc.isMatchingReference(reference, target) {
				leftType := tc.getTypeOfExpression(expr.left)
				if isTypeUsableAsPropertyName(leftType) {
					return narrowTypeByInKeyword(type_, leftType, assumeTrue)
				}
			}
		case SyntaxKindCommaToken:
			return narrowType(type_, expr.right, assumeTrue)
		case SyntaxKindAmpersandAmpersandToken:
			if assumeTrue {
				return narrowType(narrowType(type_, expr.left /*assumeTrue*/, true), expr.right /*assumeTrue*/, true)
			} else {
				return tc.getUnionType([]Type{narrowType(type_, expr.left /*assumeTrue*/, false), narrowType(type_, expr.right /*assumeTrue*/, false)})
			}
		case SyntaxKindBarBarToken:
			if assumeTrue {
				return tc.getUnionType([]Type{narrowType(type_, expr.left /*assumeTrue*/, true), narrowType(type_, expr.right /*assumeTrue*/, true)})
			} else {
				return narrowType(narrowType(type_, expr.left /*assumeTrue*/, false), expr.right /*assumeTrue*/, false)
			}
		}
		return type_
	}

	narrowTypeByPrivateIdentifierInInExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
		target := tc.getReferenceCandidate(expr.right)
		if !tc.isMatchingReference(reference, target) {
			return type_
		}

		Debug.assertNode(expr.left, isPrivateIdentifier)
		symbol := tc.getSymbolForPrivateIdentifierExpression(expr.left)
		if symbol == nil {
			return type_
		}
		classSymbol := symbol.parent
		var targetType Type
		if hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration")) {
			targetType = tc.getTypeOfSymbol(classSymbol) /* as InterfaceType */
		} else {
			targetType = tc.getDeclaredTypeOfSymbol(classSymbol)
		}
		return getNarrowedType(type_, targetType, assumeTrue /*checkDerived*/, true)
	}

	narrowTypeByOptionalChainContainment := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
		// We are in a branch of obj?.foo === value (or any one of the other equality operators). We narrow obj as follows:
		// When operator is === and type of value excludes undefined, null and undefined is removed from type of obj in true branch.
		// When operator is !== and type of value excludes undefined, null and undefined is removed from type of obj in false branch.
		// When operator is == and type of value excludes null and undefined, null and undefined is removed from type of obj in true branch.
		// When operator is != and type of value excludes null and undefined, null and undefined is removed from type of obj in false branch.
		// When operator is === and type of value is undefined, null and undefined is removed from type of obj in false branch.
		// When operator is !== and type of value is undefined, null and undefined is removed from type of obj in true branch.
		// When operator is == and type of value is null or undefined, null and undefined is removed from type of obj in false branch.
		// When operator is != and type of value is null or undefined, null and undefined is removed from type of obj in true branch.
		equalsOperator := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
		var nullableFlags /* TODO(TS-TO-GO) inferred type TypeFlags.Undefined | TypeFlags.Nullable */ any
		if operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken {
			nullableFlags = TypeFlagsNullable
		} else {
			nullableFlags = TypeFlagsUndefined
		}
		valueType := tc.getTypeOfExpression(value)
		// Note that we include any and unknown in the exclusion test because their domain includes null and undefined.
		removeNullable := equalsOperator != assumeTrue && tc.everyType(valueType, func(t Type) bool {
			return !!(t.flags & nullableFlags)
		}) || equalsOperator == assumeTrue && tc.everyType(valueType, func(t Type) bool {
			return !(t.flags & (TypeFlagsAnyOrUnknown | nullableFlags))
		})
		if removeNullable {
			return tc.getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
		} else {
			return type_
		}
	}

	narrowTypeByEquality := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
		if type_.flags & TypeFlagsAny {
			return type_
		}
		if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
			assumeTrue = !assumeTrue
		}
		valueType := tc.getTypeOfExpression(value)
		doubleEquals := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken
		if valueType.flags & TypeFlagsNullable {
			if !tc.strictNullChecks {
				return type_
			}
			var facts /* TODO(TS-TO-GO) inferred type TypeFacts.EQUndefined | TypeFacts.EQNull | TypeFacts.EQUndefinedOrNull | TypeFacts.NEUndefined | TypeFacts.NENull | TypeFacts.NEUndefinedOrNull */ any
			switch {
			case doubleEquals:
				if assumeTrue {
					facts = TypeFactsEQUndefinedOrNull
				} else {
					facts = TypeFactsNEUndefinedOrNull
				}
			case valueType.flags & TypeFlagsNull:
				if assumeTrue {
					facts = TypeFactsEQNull
				} else {
					facts = TypeFactsNENull
				}
			case assumeTrue:
				facts = TypeFactsEQUndefined
			default:
				facts = TypeFactsNEUndefined
			}
			return tc.getAdjustedTypeWithFacts(type_, facts)
		}
		if assumeTrue {
			if !doubleEquals && (type_.flags&TypeFlagsUnknown || tc.someType(type_, tc.isEmptyAnonymousObjectType)) {
				if valueType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) || tc.isEmptyAnonymousObjectType(valueType) {
					return valueType
				}
				if valueType.flags & TypeFlagsObject {
					return tc.nonPrimitiveType
				}
			}
			filteredType := tc.filterType(type_, func(t Type) bool {
				return tc.areTypesComparable(t, valueType) || doubleEquals && tc.isCoercibleUnderDoubleEquals(t, valueType)
			})
			return tc.replacePrimitivesWithLiterals(filteredType, valueType)
		}
		if tc.isUnitType(valueType) {
			return tc.filterType(type_, func(t Type) bool {
				return !(tc.isUnitLikeType(t) && tc.areTypesComparable(t, valueType))
			})
		}
		return type_
	}

	narrowTypeByTypeof := func(type_ Type, typeOfExpr TypeOfExpression, operator SyntaxKind, literal LiteralExpression, assumeTrue bool) Type {
		// We have '==', '!=', '===', or !==' operator with 'typeof xxx' and string literal operands
		if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
			assumeTrue = !assumeTrue
		}
		target := tc.getReferenceCandidate(typeOfExpr.expression)
		if !tc.isMatchingReference(reference, target) {
			if tc.strictNullChecks && tc.optionalChainContainsReference(target, reference) && assumeTrue == (literal.text != "undefined") {
				type_ = tc.getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			}
			propertyAccess := getDiscriminantPropertyAccess(target, type_)
			if propertyAccess {
				return narrowTypeByDiscriminant(type_, propertyAccess, func(t Type) Type {
					return narrowTypeByLiteralExpression(t, literal, assumeTrue)
				})
			}
			return type_
		}
		return narrowTypeByLiteralExpression(type_, literal, assumeTrue)
	}

	narrowTypeByLiteralExpression := func(type_ Type, literal LiteralExpression, assumeTrue bool) Type {
		if assumeTrue {
			return narrowTypeByTypeName(type_, literal.text)
		} else {
			return tc.getAdjustedTypeWithFacts(type_, typeofNEFacts.get(literal.text) || TypeFactsTypeofNEHostObject)
		}
	}

	narrowTypeBySwitchOptionalChainContainment := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData, clauseCheck func(type_ Type) bool) Type {
		everyClauseChecks := clauseStart != clauseEnd && every(tc.getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck)
		if everyClauseChecks {
			return tc.getTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
		} else {
			return type_
		}
	}

	narrowTypeBySwitchOnDiscriminant := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
		// We only narrow if all case expressions specify
		// values with unit types, except for the case where
		// `type` is unknown. In this instance we map object
		// types to the nonPrimitive type and narrow with that.
		switchTypes := tc.getSwitchClauseTypes(switchStatement)
		if !switchTypes.length {
			return type_
		}
		clauseTypes := switchTypes.slice(clauseStart, clauseEnd)
		hasDefaultClause := clauseStart == clauseEnd || contains(clauseTypes, tc.neverType)
		if (type_.flags & TypeFlagsUnknown) && !hasDefaultClause {
			var groundClauseTypes *[]Type
			for i := 0; i < clauseTypes.length; i += 1 {
				t := clauseTypes[i]
				if t.flags & (TypeFlagsPrimitive | TypeFlagsNonPrimitive) {
					if groundClauseTypes != nil {
						groundClauseTypes.push(t)
					}
				} else if t.flags & TypeFlagsObject {
					if groundClauseTypes == nil {
						groundClauseTypes = clauseTypes.slice(0, i)
					}
					groundClauseTypes.push(tc.nonPrimitiveType)
				} else {
					return type_
				}
			}
			return tc.getUnionType(__COND__(groundClauseTypes == nil, clauseTypes, groundClauseTypes))
		}
		discriminantType := tc.getUnionType(clauseTypes)
		var caseType Type
		if discriminantType.flags & TypeFlagsNever {
			caseType = tc.neverType
		} else {
			caseType = tc.replacePrimitivesWithLiterals(tc.filterType(type_, func(t Type) bool {
				return tc.areTypesComparable(discriminantType, t)
			}), discriminantType)
		}
		if !hasDefaultClause {
			return caseType
		}
		defaultType := tc.filterType(type_, func(t Type) bool {
			return !(tc.isUnitLikeType(t) && contains(switchTypes, __COND__(t.flags&TypeFlagsUndefined, tc.undefinedType, tc.getRegularTypeOfLiteralType(tc.extractUnitType(t)))))
		})
		if caseType.flags & TypeFlagsNever {
			return defaultType
		} else {
			return tc.getUnionType([]Type{caseType, defaultType})
		}
	}

	narrowTypeByTypeName := func(type_ Type, typeName string) Type {
		switch typeName {
		case "string":
			return narrowTypeByTypeFacts(type_, tc.stringType, TypeFactsTypeofEQString)
		case "number":
			return narrowTypeByTypeFacts(type_, tc.numberType, TypeFactsTypeofEQNumber)
		case "bigint":
			return narrowTypeByTypeFacts(type_, tc.bigintType, TypeFactsTypeofEQBigInt)
		case "boolean":
			return narrowTypeByTypeFacts(type_, tc.booleanType, TypeFactsTypeofEQBoolean)
		case "symbol":
			return narrowTypeByTypeFacts(type_, tc.esSymbolType, TypeFactsTypeofEQSymbol)
		case "object":
			if type_.flags & TypeFlagsAny {
				return type_
			} else {
				return tc.getUnionType([]Type{narrowTypeByTypeFacts(type_, tc.nonPrimitiveType, TypeFactsTypeofEQObject), narrowTypeByTypeFacts(type_, tc.nullType, TypeFactsEQNull)})
			}
		case "function":
			if type_.flags & TypeFlagsAny {
				return type_
			} else {
				return narrowTypeByTypeFacts(type_, tc.globalFunctionType, TypeFactsTypeofEQFunction)
			}
		case "undefined":
			return narrowTypeByTypeFacts(type_, tc.undefinedType, TypeFactsEQUndefined)
		}
		return narrowTypeByTypeFacts(type_, tc.nonPrimitiveType, TypeFactsTypeofEQHostObject)
	}

	narrowTypeByTypeFacts := func(type_ Type, impliedType Type, facts TypeFacts) Type {
		return tc.mapType(type_, func(t Type) Type {
			switch {
			case tc.isTypeRelatedTo(t, impliedType, tc.strictSubtypeRelation):
				if tc.hasTypeFacts(t, facts) {
					return t
				} else {
					return tc.neverType
				}
			case tc.isTypeSubtypeOf(impliedType, t):
				return impliedType
			case tc.hasTypeFacts(t, facts):
				return tc.getIntersectionType([]Type{t, impliedType})
			default:
				return tc.neverType
			}
		})
	}

	narrowTypeBySwitchOnTypeOf := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
		witnesses := tc.getSwitchClauseTypeOfWitnesses(switchStatement)
		if !witnesses {
			return type_
		}
		// Equal start and end denotes implicit fallthrough; undefined marks explicit default clause.
		defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
			return clause.kind == SyntaxKindDefaultClause
		})
		hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
		if hasDefaultClause {
			// In the default clause we filter constituents down to those that are not-equal to all handled cases.
			notEqualFacts := tc.getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses)
			return tc.filterType(type_, func(t Type) bool {
				return tc.getTypeFacts(t, notEqualFacts) == notEqualFacts
			})
		}
		// In the non-default cause we create a union of the type narrowed by each of the listed cases.
		clauseWitnesses := witnesses.slice(clauseStart, clauseEnd)
		return tc.getUnionType(map_(clauseWitnesses, func(text *string) Type {
			if text {
				return narrowTypeByTypeName(type_, text)
			} else {
				return tc.neverType
			}
		}))
	}

	narrowTypeBySwitchOnTrue := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
		defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) bool {
			return clause.kind == SyntaxKindDefaultClause
		})
		hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)

		// First, narrow away all of the cases that preceded this set of cases.
		for i := 0; i < clauseStart; i++ {
			clause := switchStatement.caseBlock.clauses[i]
			if clause.kind == SyntaxKindCaseClause {
				type_ = narrowType(type_, clause.expression /*assumeTrue*/, false)
			}
		}

		// If our current set has a default, then none the other cases were hit either.
		// There's no point in narrowing by the the other cases in the set, since we can
		// get here through other paths.
		if hasDefaultClause {
			for i := clauseEnd; i < switchStatement.caseBlock.clauses.length; i++ {
				clause := switchStatement.caseBlock.clauses[i]
				if clause.kind == SyntaxKindCaseClause {
					type_ = narrowType(type_, clause.expression /*assumeTrue*/, false)
				}
			}
			return type_
		}

		// Now, narrow based on the cases in this set.
		clauses := switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd)
		return tc.getUnionType(map_(clauses, func(clause CaseOrDefaultClause) Type {
			if clause.kind == SyntaxKindCaseClause {
				return narrowType(type_, clause.expression /*assumeTrue*/, true)
			} else {
				return tc.neverType
			}
		}))
	}

	isMatchingConstructorReference := func(expr Expression) bool {
		return (isPropertyAccessExpression(expr) && idText(expr.name) == "constructor" || isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text == "constructor") && tc.isMatchingReference(reference, expr.expression)
	}

	narrowTypeByConstructor := func(type_ Type, operator SyntaxKind, identifier Expression, assumeTrue bool) Type {
		// Do not narrow when checking inequality.
		if __COND__(assumeTrue, (operator != SyntaxKindEqualsEqualsToken && operator != SyntaxKindEqualsEqualsEqualsToken), (operator != SyntaxKindExclamationEqualsToken && operator != SyntaxKindExclamationEqualsEqualsToken)) {
			return type_
		}

		// Get the type of the constructor identifier expression, if it is not a function then do not narrow.
		identifierType := tc.getTypeOfExpression(identifier)
		if !tc.isFunctionType(identifierType) && !tc.isConstructorType(identifierType) {
			return type_
		}

		// Get the prototype property of the type identifier so we can find out its type.
		prototypeProperty := tc.getPropertyOfType(identifierType, "prototype" /* as __String */)
		if !prototypeProperty {
			return type_
		}

		// Get the type of the prototype, if it is undefined, or the global `Object` or `Function` types then do not narrow.
		prototypeType := tc.getTypeOfSymbol(prototypeProperty)
		var candidate Type
		if !tc.isTypeAny(prototypeType) {
			candidate = prototypeType
		} else {
			candidate = nil
		}
		if !candidate || candidate == tc.globalObjectType || candidate == tc.globalFunctionType {
			return type_
		}

		// If the type that is being narrowed is `any` then just return the `candidate` type since every type is a subtype of `any`.
		if tc.isTypeAny(type_) {
			return candidate
		}

		// Filter out types that are not considered to be "constructed by" the `candidate` type.
		return tc.filterType(type_, func(t Type) bool {
			return isConstructedBy(t, candidate)
		})

		isConstructedBy := func(source Type, target Type) bool {
			// If either the source or target type are a class type then we need to check that they are the same exact type.
			// This is because you may have a class `A` that defines some set of properties, and another class `B`
			// that defines the same set of properties as class `A`, in that case they are structurally the same
			// type, but when you do something like `instanceOfA.constructor === B` it will return false.
			if source.flags&TypeFlagsObject && getObjectFlags(source)&ObjectFlagsClass || target.flags&TypeFlagsObject && getObjectFlags(target)&ObjectFlagsClass {
				return source.symbol == target.symbol
			}

			// For all other types just check that the `source` type is a subtype of the `target` type.
			return tc.isTypeSubtypeOf(source, target)
		}

	}

	narrowTypeByInstanceof := func(type_ Type, expr InstanceofExpression, assumeTrue bool) Type {
		left := tc.getReferenceCandidate(expr.left)
		if !tc.isMatchingReference(reference, left) {
			if assumeTrue && tc.strictNullChecks && tc.optionalChainContainsReference(left, reference) {
				return tc.getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			}
			return type_
		}
		right := expr.right
		rightType := tc.getTypeOfExpression(right)
		if !tc.isTypeDerivedFrom(rightType, tc.globalObjectType) {
			return type_
		}

		// if the right-hand side has an object type with a custom `[Symbol.hasInstance]` method, and that method
		// has a type predicate, use the type predicate to perform narrowing. This allows normal `object` types to
		// participate in `instanceof`, as per Step 2 of https://tc39.es/ecma262/#sec-instanceofoperator.
		signature := tc.getEffectsSignature(expr)
		predicate := signature && tc.getTypePredicateOfSignature(signature)
		if predicate && predicate.kind == TypePredicateKindIdentifier && predicate.parameterIndex == 0 {
			return getNarrowedType(type_, predicate.type_, assumeTrue /*checkDerived*/, true)
		}
		if !tc.isTypeDerivedFrom(rightType, tc.globalFunctionType) {
			return type_
		}
		instanceType := tc.mapType(rightType, getInstanceType)
		// Don't narrow from `any` if the target type is exactly `Object` or `Function`, and narrow
		// in the false branch only if the target is a non-empty object type.
		if tc.isTypeAny(type_) && (instanceType == tc.globalObjectType || instanceType == tc.globalFunctionType) || !assumeTrue && !(instanceType.flags&TypeFlagsObject && !tc.isEmptyAnonymousObjectType(instanceType)) {
			return type_
		}
		return getNarrowedType(type_, instanceType, assumeTrue /*checkDerived*/, true)
	}

	getInstanceType := func(constructorType Type) Type {
		prototypePropertyType := tc.getTypeOfPropertyOfType(constructorType, "prototype" /* as __String */)
		if prototypePropertyType && !tc.isTypeAny(prototypePropertyType) {
			return prototypePropertyType
		}
		constructSignatures := tc.getSignaturesOfType(constructorType, SignatureKindConstruct)
		if constructSignatures.length {
			return tc.getUnionType(map_(constructSignatures, func(signature Signature) Type {
				return tc.getReturnTypeOfSignature(tc.getErasedSignature(signature))
			}))
		}
		// We use the empty object type to indicate we don't know the type of objects created by
		// this constructor function.
		return tc.emptyObjectType
	}

	getNarrowedType := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
		var key *string
		if type_.flags & TypeFlagsUnion {
			key = __TEMPLATE__("N", tc.getTypeId(type_), ",", tc.getTypeId(candidate), ",", (__COND__(assumeTrue, 1, 0))|(__COND__(checkDerived, 2, 0)))
		} else {
			key = nil
		}
		return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived)) */ TODO
	}

	getNarrowedTypeWorker := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
		if !assumeTrue {
			if type_ == candidate {
				return tc.neverType
			}
			if checkDerived {
				return tc.filterType(type_, func(t Type) bool {
					return !tc.isTypeDerivedFrom(t, candidate)
				})
			}
			trueType := getNarrowedType(type_, candidate /*assumeTrue*/, true /*checkDerived*/, false)
			return tc.filterType(type_, func(t Type) bool {
				return !tc.isTypeSubsetOf(t, trueType)
			})
		}
		if type_.flags & TypeFlagsAnyOrUnknown {
			return candidate
		}
		if type_ == candidate {
			return candidate
		}

		// We first attempt to filter the current type, narrowing constituents as appropriate and removing
		// constituents that are unrelated to the candidate.
		var isRelated /* TODO(TS-TO-GO) inferred type (source: Type, target: Type) => boolean */ any
		if checkDerived {
			isRelated = tc.isTypeDerivedFrom
		} else {
			isRelated = tc.isTypeSubtypeOf
		}
		var keyPropertyName *__String
		if type_.flags & TypeFlagsUnion {
			keyPropertyName = tc.getKeyPropertyName(type_ /* as UnionType */)
		} else {
			keyPropertyName = nil
		}
		narrowedType := tc.mapType(candidate, func(c Type) Type {
			// If a discriminant property is available, use that to reduce the type.
			discriminant := keyPropertyName && tc.getTypeOfPropertyOfType(c, keyPropertyName)
			matching := discriminant && tc.getConstituentTypeForKeyType(type_ /* as UnionType */, discriminant)
			// For each constituent t in the current type, if t and and c are directly related, pick the most
			// specific of the two. When t and c are related in both directions, we prefer c for type predicates
			// because that is the asserted type, but t for `instanceof` because generics aren't reflected in
			// prototype object types.
			directlyRelated := tc.mapType(matching || type_, __COND__(checkDerived, func(t Type) Type {
				switch {
				case tc.isTypeDerivedFrom(t, c):
					return t
				case tc.isTypeDerivedFrom(c, t):
					return c
				default:
					return tc.neverType
				}
			}, func(t Type) Type {
				switch {
				case tc.isTypeStrictSubtypeOf(t, c):
					return t
				case tc.isTypeStrictSubtypeOf(c, t):
					return c
				case tc.isTypeSubtypeOf(t, c):
					return t
				case tc.isTypeSubtypeOf(c, t):
					return c
				default:
					return tc.neverType
				}
			}))
			// If no constituents are directly related, create intersections for any generic constituents that
			// are related by constraint.
			if directlyRelated.flags & TypeFlagsNever {
				return tc.mapType(type_, func(t Type) Type {
					if tc.maybeTypeOfKind(t, TypeFlagsInstantiable) && isRelated(c, tc.getBaseConstraintOfType(t) || tc.unknownType) {
						return tc.getIntersectionType([]Type{t, c})
					} else {
						return tc.neverType
					}
				})
			} else {
				return directlyRelated
			}
		})
		// If filtering produced a non-empty type, return that. Otherwise, pick the most specific of the two
		// based on assignability, or as a last resort produce an intersection.
		switch {
		case !(narrowedType.flags & TypeFlagsNever):
			return narrowedType
		case tc.isTypeSubtypeOf(candidate, type_):
			return candidate
		case tc.isTypeAssignableTo(type_, candidate):
			return type_
		case tc.isTypeAssignableTo(candidate, type_):
			return candidate
		default:
			return tc.getIntersectionType([]Type{type_, candidate})
		}
	}

	narrowTypeByCallExpression := func(type_ Type, callExpression CallExpression, assumeTrue bool) Type {
		if tc.hasMatchingArgument(callExpression, reference) {
			var signature *Signature
			if assumeTrue || !isCallChain(callExpression) {
				signature = tc.getEffectsSignature(callExpression)
			} else {
				signature = nil
			}
			predicate := signature && tc.getTypePredicateOfSignature(signature)
			if predicate && (predicate.kind == TypePredicateKindThis || predicate.kind == TypePredicateKindIdentifier) {
				return narrowTypeByTypePredicate(type_, predicate, callExpression, assumeTrue)
			}
		}
		if tc.containsMissingType(type_) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression) {
			callAccess := callExpression.expression
			if tc.isMatchingReference(reference.expression, tc.getReferenceCandidate(callAccess.expression)) && isIdentifier(callAccess.name) && callAccess.name.escapedText == "hasOwnProperty" && callExpression.arguments.length == 1 {
				argument := callExpression.arguments[0]
				if isStringLiteralLike(argument) && tc.getAccessedPropertyName(reference) == escapeLeadingUnderscores(argument.text) {
					return tc.getTypeWithFacts(type_, __COND__(assumeTrue, TypeFactsNEUndefined, TypeFactsEQUndefined))
				}
			}
		}
		return type_
	}

	narrowTypeByTypePredicate := func(type_ Type, predicate TypePredicate, callExpression CallExpression, assumeTrue bool) Type {
		// Don't narrow from 'any' if the predicate type is exactly 'Object' or 'Function'
		if predicate.type_ && !(tc.isTypeAny(type_) && (predicate.type_ == tc.globalObjectType || predicate.type_ == tc.globalFunctionType)) {
			predicateArgument := tc.getTypePredicateArgument(predicate, callExpression)
			if predicateArgument {
				if tc.isMatchingReference(reference, predicateArgument) {
					return getNarrowedType(type_, predicate.type_, assumeTrue /*checkDerived*/, false)
				}
				if tc.strictNullChecks && tc.optionalChainContainsReference(predicateArgument, reference) && (assumeTrue && !(tc.hasTypeFacts(predicate.type_, TypeFactsEQUndefined)) || !assumeTrue && tc.everyType(predicate.type_, tc.isNullableType)) {
					type_ = tc.getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				access := getDiscriminantPropertyAccess(predicateArgument, type_)
				if access {
					return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
						return getNarrowedType(t, predicate.type_, assumeTrue /*checkDerived*/, false)
					})
				}
			}
		}
		return type_
	}

	// Narrow the given type based on the given expression having the assumed boolean value. The returned type
	// will be a subtype or the same type as the argument.
	narrowType := func(type_ Type, expr Expression, assumeTrue bool) Type {
		// for `a?.b`, we emulate a synthetic `a !== null && a !== undefined` condition for `a`
		if isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionToken || expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionEqualsToken) && expr.parent.left == expr {
			return narrowTypeByOptionality(type_, expr, assumeTrue)
		}
		switch expr.kind {
		case SyntaxKindIdentifier:
			if !tc.isMatchingReference(reference, expr) && tc.inlineLevel < 5 {
				symbol := tc.getResolvedSymbol(expr /* as Identifier */)
				if tc.isConstantVariable(symbol) {
					declaration := symbol.valueDeclaration
					if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && tc.isConstantReference(reference) {
						tc.inlineLevel++
						result := narrowType(type_, declaration.initializer, assumeTrue)
						tc.inlineLevel--
						return result
					}
				}
			}
			fallthrough
		case SyntaxKindThisKeyword,
			SyntaxKindSuperKeyword,
			SyntaxKindPropertyAccessExpression,
			SyntaxKindElementAccessExpression:
			return narrowTypeByTruthiness(type_, expr, assumeTrue)
		case SyntaxKindCallExpression:
			return narrowTypeByCallExpression(type_, expr /* as CallExpression */, assumeTrue)
		case SyntaxKindParenthesizedExpression,
			SyntaxKindNonNullExpression:
			return narrowType(type_, (expr /* as ParenthesizedExpression | NonNullExpression */).expression, assumeTrue)
		case SyntaxKindBinaryExpression:
			return narrowTypeByBinaryExpression(type_, expr /* as BinaryExpression */, assumeTrue)
		case SyntaxKindPrefixUnaryExpression:
			if (expr /* as PrefixUnaryExpression */).operator == SyntaxKindExclamationToken {
				return narrowType(type_, (expr /* as PrefixUnaryExpression */).operand, !assumeTrue)
			}
		}
		return type_
	}

	narrowTypeByOptionality := func(type_ Type, expr Expression, assumePresent bool) Type {
		if tc.isMatchingReference(reference, expr) {
			return tc.getAdjustedTypeWithFacts(type_, __COND__(assumePresent, TypeFactsNEUndefinedOrNull, TypeFactsEQUndefinedOrNull))
		}
		access := getDiscriminantPropertyAccess(expr, type_)
		if access {
			return narrowTypeByDiscriminant(type_, access, func(t Type) Type {
				return tc.getTypeWithFacts(t, __COND__(assumePresent, TypeFactsNEUndefinedOrNull, TypeFactsEQUndefinedOrNull))
			})
		}
		return type_
	}

}

func (tc *TypeChecker) getTypeOfSymbolAtLocation(symbol Symbol, location Node) Type {
	symbol = tc.getExportSymbolOfValueSymbolIfExported(symbol)

	// If we have an identifier or a property access at the given location, if the location is
	// an dotted name expression, and if the location is not an assignment target, obtain the type
	// of the expression (which will reflect control flow analysis). If the expression indeed
	// resolved to the given symbol, return the narrowed type.
	if location.kind == SyntaxKindIdentifier || location.kind == SyntaxKindPrivateIdentifier {
		if isRightSideOfQualifiedNameOrPropertyAccess(location) {
			location = location.parent
		}
		if isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location)) {
			type_ := tc.removeOptionalTypeMarker(__COND__(isWriteAccess(location) && location.kind == SyntaxKindPropertyAccessExpression, tc.checkPropertyAccessExpression(location /* as PropertyAccessExpression */ /*checkMode*/, nil /*writeOnly*/, true), tc.getTypeOfExpression(location /* as Expression */)))
			if tc.getExportSymbolOfValueSymbolIfExported(tc.getNodeLinks(location).resolvedSymbol) == symbol {
				return type_
			}
		}
	}
	if isDeclarationName(location) && isSetAccessor(location.parent) && tc.getAnnotatedAccessorTypeNode(location.parent) {
		return tc.getWriteTypeOfAccessors(location.parent.symbol)
	}
	// The location isn't a reference to the given symbol, meaning we're being asked
	// a hypothetical question of what type the symbol would have if there was a reference
	// to it at the given location. Since we have no control flow information for the
	// hypothetical reference (control flow information is created and attached by the
	// binder), we simply return the declared type of the symbol.
	if isRightSideOfAccessExpression(location) && isWriteAccess(location.parent) {
		return tc.getWriteTypeOfSymbol(symbol)
	} else {
		return tc.getNonMissingTypeOfSymbol(symbol)
	}
}

func (tc *TypeChecker) getControlFlowContainer(node Node) Node {
	return findAncestor(node.parent, func(node Node) bool {
		return isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) || node.kind == SyntaxKindModuleBlock || node.kind == SyntaxKindSourceFile || node.kind == SyntaxKindPropertyDeclaration
	})
}

// Check if a parameter, catch variable, or mutable local variable is assigned anywhere definitely
func (tc *TypeChecker) isSymbolAssignedDefinitely(symbol Symbol) bool {
	if symbol.lastAssignmentPos != nil {
		return symbol.lastAssignmentPos < 0
	}
	return tc.isSymbolAssigned(symbol) && symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0
}

// Check if a parameter, catch variable, or mutable local variable is assigned anywhere
func (tc *TypeChecker) isSymbolAssigned(symbol Symbol) bool {
	return !tc.isPastLastAssignment(symbol /*location*/, nil)
}

// Return true if there are no assignments to the given symbol or if the given location
// is past the last assignment to the symbol.
func (tc *TypeChecker) isPastLastAssignment(symbol Symbol, location Node) *bool {
	parent := findAncestor(symbol.valueDeclaration, tc.isFunctionOrSourceFile)
	if !parent {
		return false
	}
	links := tc.getNodeLinks(parent)
	if !(links.flags & NodeCheckFlagsAssignmentsMarked) {
		links.flags |= NodeCheckFlagsAssignmentsMarked
		if !tc.hasParentWithAssignmentsMarked(parent) {
			tc.markNodeAssignments(parent)
		}
	}
	return !symbol.lastAssignmentPos || location && Math.abs(symbol.lastAssignmentPos) < location.pos
}

// Check if a parameter or catch variable (or their bindings elements) is assigned anywhere
func (tc *TypeChecker) isSomeSymbolAssigned(rootDeclaration Node) bool {
	Debug.assert(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration))
	return tc.isSomeSymbolAssignedWorker(rootDeclaration.name)
}

func (tc *TypeChecker) isSomeSymbolAssignedWorker(node BindingName) bool {
	if node.kind == SyntaxKindIdentifier {
		return tc.isSymbolAssigned(tc.getSymbolOfDeclaration(node.parent /* as Declaration */))
	}

	return some(node.elements, func(e /* TODO(TS-TO-GO) inferred type BindingElement | OmittedExpression */ any) bool {
		return e.kind != SyntaxKindOmittedExpression && tc.isSomeSymbolAssignedWorker(e.name)
	})
}

func (tc *TypeChecker) hasParentWithAssignmentsMarked(node Node) bool {
	return !!findAncestor(node.parent, func(node Node) bool {
		return tc.isFunctionOrSourceFile(node) && !!(tc.getNodeLinks(node).flags & NodeCheckFlagsAssignmentsMarked)
	})
}

func (tc *TypeChecker) isFunctionOrSourceFile(node Node) bool {
	return isFunctionLikeDeclaration(node) || isSourceFile(node)
}

// For all assignments within the given root node, record the last assignment source position for all
// referenced parameters and mutable local variables. When assignments occur in nested functions  or
// references occur in export specifiers, record Number.MAX_VALUE as the assignment position. When
// assignments occur in compound statements, record the ending source position of the compound statement
// as the assignment position (this is more conservative than full control flow analysis, but requires
// only a single walk over the AST).
func (tc *TypeChecker) markNodeAssignments(node Node) {
	switch node.kind {
	case SyntaxKindIdentifier:
		assigmentTarget := getAssignmentTargetKind(node)
		if assigmentTarget != AssignmentKindNone {
			symbol := tc.getResolvedSymbol(node /* as Identifier */)
			hasDefiniteAssignment := assigmentTarget == AssignmentKindDefinite || (symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0)
			if tc.isParameterOrMutableLocalVariable(symbol) {
				if symbol.lastAssignmentPos == nil || Math.abs(symbol.lastAssignmentPos) != Number.MAX_VALUE {
					referencingFunction := findAncestor(node, tc.isFunctionOrSourceFile)
					declaringFunction := findAncestor(symbol.valueDeclaration, tc.isFunctionOrSourceFile)
					if referencingFunction == declaringFunction {
						symbol.lastAssignmentPos = tc.extendAssignmentPosition(node, symbol.valueDeclaration)
					} else {
						symbol.lastAssignmentPos = Number.MAX_VALUE
					}
				}
				if hasDefiniteAssignment && symbol.lastAssignmentPos > 0 {
					symbol.lastAssignmentPos *= -1
				}
			}
		}
		return
	case SyntaxKindExportSpecifier:
		exportDeclaration := (node /* as ExportSpecifier */).parent.parent
		name := (node /* as ExportSpecifier */).propertyName || (node /* as ExportSpecifier */).name
		if !(node /* as ExportSpecifier */).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind != SyntaxKindStringLiteral {
			symbol := tc.resolveEntityName(name, SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, true)
			if symbol && tc.isParameterOrMutableLocalVariable(symbol) {
				var sign /* TODO(TS-TO-GO) inferred type 1 | -1 */ any
				if symbol.lastAssignmentPos != nil && symbol.lastAssignmentPos < 0 {
					sign = -1
				} else {
					sign = 1
				}
				symbol.lastAssignmentPos = sign * Number.MAX_VALUE
			}
		}
		return
	case SyntaxKindInterfaceDeclaration,
		SyntaxKindTypeAliasDeclaration,
		SyntaxKindEnumDeclaration:
		return
	}
	if isTypeNode(node) {
		return
	}
	forEachChild(node, tc.markNodeAssignments)
}

// Extend the position of the given assignment target node to the end of any intervening variable statement,
// expression statement, compound statement, or class declaration occurring between the node and the given
// declaration node.
func (tc *TypeChecker) extendAssignmentPosition(node Node, declaration Declaration) number {
	pos := node.pos
	for node && node.pos > declaration.pos {
		switch node.kind {
		case SyntaxKindVariableStatement,
			SyntaxKindExpressionStatement,
			SyntaxKindIfStatement,
			SyntaxKindDoStatement,
			SyntaxKindWhileStatement,
			SyntaxKindForStatement,
			SyntaxKindForInStatement,
			SyntaxKindForOfStatement,
			SyntaxKindWithStatement,
			SyntaxKindSwitchStatement,
			SyntaxKindTryStatement,
			SyntaxKindClassDeclaration:
			pos = node.end
		}
		node = node.parent
	}
	return pos
}

func (tc *TypeChecker) isConstantVariable(symbol Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
	return symbol.flags&SymbolFlagsVariable && (tc.getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant) != 0
}

func (tc *TypeChecker) isParameterOrMutableLocalVariable(symbol Symbol) bool {
	// Return true if symbol is a parameter, a catch clause variable, or a mutable local variable
	declaration := symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration)
	return !!declaration && (isParameter(declaration) || isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || tc.isMutableLocalVariableDeclaration(declaration)))
}

func (tc *TypeChecker) isMutableLocalVariableDeclaration(declaration VariableDeclaration) bool {
	// Return true if symbol is a non-exported and non-global `let` variable
	return !!(declaration.parent.flags & NodeFlagsLet) && !(getCombinedModifierFlags(declaration)&ModifierFlagsExport || declaration.parent.parent.kind == SyntaxKindVariableStatement && isGlobalSourceFile(declaration.parent.parent.parent))
}

func (tc *TypeChecker) parameterInitializerContainsUndefined(declaration ParameterDeclaration) bool {
	links := tc.getNodeLinks(declaration)

	if links.parameterInitializerContainsUndefined == nil {
		if !tc.pushTypeResolution(declaration, TypeSystemPropertyNameParameterInitializerContainsUndefined) {
			tc.reportCircularityError(declaration.symbol)
			return true
		}

		containsUndefined := !!(tc.hasTypeFacts(tc.checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined))

		if !tc.popTypeResolution() {
			tc.reportCircularityError(declaration.symbol)
			return true
		}

		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.parameterInitializerContainsUndefined ??= containsUndefined */
		TODO
	}

	return links.parameterInitializerContainsUndefined
}

/** remove undefined from the annotated type of a parameter when there is an initializer (that doesn't include undefined) */

func (tc *TypeChecker) removeOptionalityFromDeclaredType(declaredType Type, declaration VariableLikeDeclaration) Type {
	removeUndefined := tc.strictNullChecks && declaration.kind == SyntaxKindParameter && declaration.initializer && tc.hasTypeFacts(declaredType, TypeFactsIsUndefined) && !tc.parameterInitializerContainsUndefined(declaration)

	if removeUndefined {
		return tc.getTypeWithFacts(declaredType, TypeFactsNEUndefined)
	} else {
		return declaredType
	}
}

func (tc *TypeChecker) isConstraintPosition(type_ Type, node Node) bool {
	parent := node.parent
	// In an element access obj[x], we consider obj to be in a constraint position, except when obj is of
	// a generic type without a nullable constraint and x is a generic type. This is because when both obj
	// and x are of generic types T and K, we want the resulting type to be T[K].
	return parent.kind == SyntaxKindPropertyAccessExpression || parent.kind == SyntaxKindQualifiedName || parent.kind == SyntaxKindCallExpression && (parent /* as CallExpression */).expression == node || parent.kind == SyntaxKindNewExpression && (parent /* as NewExpression */).expression == node || parent.kind == SyntaxKindElementAccessExpression && (parent /* as ElementAccessExpression */).expression == node && !(tc.someType(type_, tc.isGenericTypeWithoutNullableConstraint) && tc.isGenericIndexType(tc.getTypeOfExpression((parent /* as ElementAccessExpression */).argumentExpression)))
}

func (tc *TypeChecker) isGenericTypeWithUnionConstraint(type_ Type) bool {
	if type_.flags & TypeFlagsIntersection {
		return some((type_ /* as IntersectionType */).types, tc.isGenericTypeWithUnionConstraint)
	} else {
		return !!(type_.flags&TypeFlagsInstantiable && tc.getBaseConstraintOrType(type_).flags&(TypeFlagsNullable|TypeFlagsUnion))
	}
}

func (tc *TypeChecker) isGenericTypeWithoutNullableConstraint(type_ Type) bool {
	if type_.flags & TypeFlagsIntersection {
		return some((type_ /* as IntersectionType */).types, tc.isGenericTypeWithoutNullableConstraint)
	} else {
		return !!(type_.flags&TypeFlagsInstantiable && !tc.maybeTypeOfKind(tc.getBaseConstraintOrType(type_), TypeFlagsNullable))
	}
}

func (tc *TypeChecker) hasContextualTypeWithNoGenericTypes(node Node, checkMode *CheckMode) *bool {
	// Computing the contextual type for a child of a JSX element involves resolving the type of the
	// element's tag name, so we exclude that here to avoid circularities.
	// If check mode has `CheckMode.RestBindingElement`, we skip binding pattern contextual types,
	// as we want the type of a rest element to be generic when possible.
	contextualType := (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) && !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName == node) && (__COND__(checkMode && checkMode&CheckModeRestBindingElement, tc.getContextualType(node, ContextFlagsSkipBindingPatterns), tc.getContextualType(node /*contextFlags*/, nil)))
	return contextualType && !tc.isGenericType(contextualType)
}

func (tc *TypeChecker) getNarrowableTypeForReference(type_ Type, reference Node, checkMode CheckMode) Type {
	if tc.isNoInferType(type_) {
		type_ = (type_ /* as SubstitutionType */).baseType
	}
	// When the type of a reference is or contains an instantiable type with a union type constraint, and
	// when the reference is in a constraint position (where it is known we'll obtain the apparent type) or
	// has a contextual type containing no top-level instantiables (meaning constraints will determine
	// assignability), we substitute constraints for all instantiables in the type of the reference to give
	// control flow analysis an opportunity to narrow it further. For example, for a reference of a type
	// parameter type 'T extends string | undefined' with a contextual type 'string', we substitute
	// 'string | undefined' to give control flow analysis the opportunity to narrow to type 'string'.
	substituteConstraints := !(checkMode && checkMode&CheckModeInferential) && tc.someType(type_, tc.isGenericTypeWithUnionConstraint) && (tc.isConstraintPosition(type_, reference) || tc.hasContextualTypeWithNoGenericTypes(reference, checkMode))
	if substituteConstraints {
		return tc.mapType(type_, tc.getBaseConstraintOrType)
	} else {
		return type_
	}
}

func (tc *TypeChecker) isExportOrExportExpression(location Node) bool {
	return !!findAncestor(location, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		parent := n.parent
		if parent == nil {
			return "quit"
		}
		if isExportAssignment(parent) {
			return parent.expression == n && isEntityNameExpression(n)
		}
		if isExportSpecifier(parent) {
			return parent.name == n || parent.propertyName == n
		}
		return false
	})
}

/**
 * This function marks all the imports the given location refers to as `.referenced` in `NodeLinks` (transitively through local import aliases).
 * (This corresponds to not getting elided in JS emit.)
 * It can be called on *most* nodes in the AST with `ReferenceHint.Unspecified` and will filter its inputs, but care should be taken to avoid calling it on the RHS of an `import =` or specifiers in a `import {} from "..."`,
 * unless you *really* want to *definitely* mark those as referenced.
 * These shouldn't be directly marked, and should only get marked transitively by the internals of this function.
 *
 * @param location The location to mark js import refernces for
 * @param hint The kind of reference `location` has already been checked to be
 * @param propSymbol The optional symbol of the property we're looking up - this is used for property accesses when `const enum`s do not count as references (no `isolatedModules`, no `preserveConstEnums` + export). It will be calculated if not provided.
 * @param parentType The optional type of the parent of the LHS of the property access - this will be recalculated if not provided (but is costly).
 */

/* OVERLOAD: function markLinkedReferences(location: PropertyAccessExpression | QualifiedName, hint: ReferenceHint.Property, propSymbol: Symbol | undefined, parentType: Type): void; */
/* OVERLOAD: function markLinkedReferences(location: Identifier, hint: ReferenceHint.Identifier): void; */
/* OVERLOAD: function markLinkedReferences(location: ExportAssignment, hint: ReferenceHint.ExportAssignment): void; */
/* OVERLOAD: function markLinkedReferences(location: JsxOpeningLikeElement | JsxOpeningFragment, hint: ReferenceHint.Jsx): void; */
/* OVERLOAD: function markLinkedReferences(location: FunctionLikeDeclaration | MethodSignature, hint: ReferenceHint.AsyncFunction): void; */
/* OVERLOAD: function markLinkedReferences(location: ImportEqualsDeclaration, hint: ReferenceHint.ExportImportEquals): void; */
/* OVERLOAD: function markLinkedReferences(location: ExportSpecifier, hint: ReferenceHint.ExportSpecifier): void; */
/* OVERLOAD: function markLinkedReferences(location: HasDecorators, hint: ReferenceHint.Decorator): void; */
/* OVERLOAD: function markLinkedReferences(location: Node, hint: ReferenceHint.Unspecified, propSymbol?: Symbol, parentType?: Type): void; */
func (tc *TypeChecker) markLinkedReferences(location Node, hint ReferenceHint, propSymbol Symbol, parentType Type) {
	if !tc.canCollectSymbolAliasAccessabilityData {
		return
	}
	if location.flags&NodeFlagsAmbient && !isPropertySignature(location) && !isPropertyDeclaration(location) {
		// References within types and declaration files are never going to contribute to retaining a JS import,
		// except for properties (which can be decorated).
		return
	}
	switch hint {
	case ReferenceHintIdentifier:
		return tc.markIdentifierAliasReferenced(location /* as Identifier */)
	case ReferenceHintProperty:
		return tc.markPropertyAliasReferenced(location /* as PropertyAccessExpression | QualifiedName */, propSymbol, parentType)
	case ReferenceHintExportAssignment:
		return tc.markExportAssignmentAliasReferenced(location /* as ExportAssignment */)
	case ReferenceHintJsx:
		return tc.markJsxAliasReferenced(location /* as JsxOpeningLikeElement | JsxOpeningFragment */)
	case ReferenceHintAsyncFunction:
		return tc.markAsyncFunctionAliasReferenced(location /* as FunctionLikeDeclaration | MethodSignature */)
	case ReferenceHintExportImportEquals:
		return tc.markImportEqualsAliasReferenced(location /* as ImportEqualsDeclaration */)
	case ReferenceHintExportSpecifier:
		return tc.markExportSpecifierAliasReferenced(location /* as ExportSpecifier */)
	case ReferenceHintDecorator:
		return tc.markDecoratorAliasReferenced(location /* as HasDecorators */)
	case ReferenceHintUnspecified:
		// Identifiers in expression contexts are emitted, so we need to follow their referenced aliases and mark them as used
		// Some non-expression identifiers are also treated as expression identifiers for this purpose, eg, `a` in `b = {a}` or `q` in `import r = q`
		// This is the exception, rather than the rule - most non-expression identifiers are declaration names.
		if isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference == location)) && tc.shouldMarkIdentifierAliasReferenced(location) {
			if isPropertyAccessOrQualifiedName(location.parent) {
				var left /* TODO(TS-TO-GO) inferred type LeftHandSideExpression | QualifiedName */ any
				if isPropertyAccessExpression(location.parent) {
					left = location.parent.expression
				} else {
					left = location.parent.left
				}
				if left != location {
					return
					// Only mark the LHS (the RHS is a property lookup)
				}
				// Only mark the LHS (the RHS is a property lookup)
			}
			tc.markIdentifierAliasReferenced(location)
			return
		}
		if isPropertyAccessOrQualifiedName(location) {
			var topProp Node = location
			for isPropertyAccessOrQualifiedName(topProp) {
				if isPartOfTypeNode(topProp) {
					return
				}
				topProp = topProp.parent
			}
			return tc.markPropertyAliasReferenced(location)
		}
		if isExportAssignment(location) {
			return tc.markExportAssignmentAliasReferenced(location)
		}
		if isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location) {
			return tc.markJsxAliasReferenced(location)
		}
		if isImportEqualsDeclaration(location) {
			if isInternalModuleImportEqualsDeclaration(location) || tc.checkExternalImportOrExportDeclaration(location) {
				return tc.markImportEqualsAliasReferenced(location)
			}
			return
		}
		if isExportSpecifier(location) {
			return tc.markExportSpecifierAliasReferenced(location)
		}
		if isFunctionLikeDeclaration(location) || isMethodSignature(location) {
			tc.markAsyncFunctionAliasReferenced(location)
			// Might be decorated, fall through to decorator final case
		}
		if !tc.compilerOptions.emitDecoratorMetadata {
			return
		}
		if !canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(tc.legacyDecorators, location, location.parent, location.parent.parent) {
			return
		}

		return tc.markDecoratorAliasReferenced(location)
		fallthrough
	default:
		Debug.assertNever(hint, __TEMPLATE__("Unhandled reference hint: ", hint))
	}
}

func (tc *TypeChecker) markIdentifierAliasReferenced(location Identifier) {
	symbol := tc.getResolvedSymbol(location)
	if symbol && symbol != tc.argumentsSymbol && symbol != tc.unknownSymbol && !isThisInTypeQuery(location) {
		tc.markAliasReferenced(symbol, location)
	}
}

func (tc *TypeChecker) markPropertyAliasReferenced(location /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName */ any, propSymbol Symbol, parentType Type) {
	var left /* TODO(TS-TO-GO) inferred type LeftHandSideExpression | QualifiedName */ any
	if isPropertyAccessExpression(location) {
		left = location.expression
	} else {
		left = location.left
	}
	if isThisIdentifier(left) || !isIdentifier(left) {
		return
	}
	parentSymbol := tc.getResolvedSymbol(left)
	if !parentSymbol || parentSymbol == tc.unknownSymbol {
		return
	}
	// In `Foo.Bar.Baz`, 'Foo' is not referenced if 'Bar' is a const enum or a module containing only const enums.
	// `Foo` is also not referenced in `enum FooCopy { Bar = Foo.Bar }`, because the enum member value gets inlined
	// here even if `Foo` is not a const enum.
	//
	// The exceptions are:
	//   1. if 'isolatedModules' is enabled, because the const enum value will not be inlined, and
	//   2. if 'preserveConstEnums' is enabled and the expression is itself an export, e.g. `export = Foo.Bar.Baz`.
	//
	// The property lookup is deferred as much as possible, in as many situations as possible, to avoid alias marking
	// pulling on types/symbols it doesn't strictly need to.
	if getIsolatedModules(tc.compilerOptions) || (shouldPreserveConstEnums(tc.compilerOptions) && tc.isExportOrExportExpression(location)) {
		tc.markAliasReferenced(parentSymbol, location)
		return
	}
	// Hereafter, this relies on type checking - but every check prior to this only used symbol information
	leftType := parentType || tc.checkExpressionCached(left)
	if tc.isTypeAny(leftType) || leftType == tc.silentNeverType {
		tc.markAliasReferenced(parentSymbol, location)
		return
	}
	prop := propSymbol
	if !prop && !parentType {
		var right MemberName
		if isPropertyAccessExpression(location) {
			right = location.name
		} else {
			right = location.right
		}
		lexicallyScopedSymbol := isPrivateIdentifier(right) && tc.lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
		assignmentKind := getAssignmentTargetKind(location)
		apparentType := tc.getApparentType(__COND__(assignmentKind != AssignmentKindNone || tc.isMethodAccessForCall(location), tc.getWidenedType(leftType), leftType))
		if isPrivateIdentifier(right) {
			prop = lexicallyScopedSymbol && tc.getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || nil
		} else {
			prop = tc.getPropertyOfType(apparentType, right.escapedText)
		}
	}
	if !(prop && (tc.isConstEnumOrConstEnumOnlyModule(prop) || prop.flags&SymbolFlagsEnumMember && location.parent.kind == SyntaxKindEnumMember)) {
		tc.markAliasReferenced(parentSymbol, location)
	}
	return
}

func (tc *TypeChecker) markExportAssignmentAliasReferenced(location ExportAssignment) {
	if isIdentifier(location.expression) {
		id := location.expression
		sym := tc.getExportSymbolOfValueSymbolIfExported(tc.resolveEntityName(id, SymbolFlagsAll /*ignoreErrors*/, true /*dontResolveAlias*/, true, location))
		if sym {
			tc.markAliasReferenced(sym, id)
		}
	}
}

func (tc *TypeChecker) markJsxAliasReferenced(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningLikeElement | JsxOpeningFragment */ any) {
	if !tc.getJsxNamespaceContainerForImplicitImport(node) {
		// The reactNamespace/jsxFactory's root symbol should be marked as 'used' so we don't incorrectly elide its import.
		// And if there is no reactNamespace/jsxFactory's symbol in scope when targeting React emit, we should issue an error.
		var jsxFactoryRefErr *DiagnosticMessage
		if tc.diagnostics && tc.compilerOptions.jsx == JsxEmitReact {
			jsxFactoryRefErr = Diagnostics.Cannot_find_name_0
		} else {
			jsxFactoryRefErr = nil
		}
		jsxFactoryNamespace := tc.getJsxNamespace(node)
		var jsxFactoryLocation /* TODO(TS-TO-GO) inferred type JsxTagNameExpression | JsxOpeningFragment */ any
		if isJsxOpeningLikeElement(node) {
			jsxFactoryLocation = node.tagName
		} else {
			jsxFactoryLocation = node
		}

		// allow null as jsxFragmentFactory
		var jsxFactorySym Symbol
		if !(isJsxOpeningFragment(node) && jsxFactoryNamespace == "null") {
			jsxFactorySym = tc.resolveName(jsxFactoryLocation, jsxFactoryNamespace, SymbolFlagsValue, jsxFactoryRefErr /*isUse*/, true)
		}

		if jsxFactorySym {
			// Mark local symbol as referenced here because it might not have been marked
			// if jsx emit was not jsxFactory as there wont be error being emitted
			jsxFactorySym.isReferenced = SymbolFlagsAll

			// If react/jsxFactory symbol is alias, mark it as refereced
			if tc.canCollectSymbolAliasAccessabilityData && jsxFactorySym.flags&SymbolFlagsAlias && !tc.getTypeOnlyAliasDeclaration(jsxFactorySym) {
				tc.markAliasSymbolAsReferenced(jsxFactorySym)
			}
		}

		// For JsxFragment, mark jsx pragma as referenced via resolveName
		if isJsxOpeningFragment(node) {
			file := getSourceFileOfNode(node)
			localJsxNamespace := tc.getLocalJsxNamespace(file)
			if localJsxNamespace {
				tc.resolveName(jsxFactoryLocation, localJsxNamespace, SymbolFlagsValue, jsxFactoryRefErr /*isUse*/, true)
			}
		}
	}
	return
}

func (tc *TypeChecker) markAsyncFunctionAliasReferenced(location /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any) {
	if tc.languageVersion < ScriptTargetES2015 {
		if getFunctionFlags(location) & FunctionFlagsAsync {
			returnTypeNode := getEffectiveReturnTypeNode(location)
			tc.markTypeNodeAsReferenced(returnTypeNode)
		}
	}
}

func (tc *TypeChecker) markImportEqualsAliasReferenced(location ImportEqualsDeclaration) {
	if hasSyntacticModifier(location, ModifierFlagsExport) {
		tc.markExportAsReferenced(location)
	}
}

func (tc *TypeChecker) markExportSpecifierAliasReferenced(location ExportSpecifier) {
	if !location.parent.parent.moduleSpecifier && !location.isTypeOnly && !location.parent.parent.isTypeOnly {
		exportedName := location.propertyName || location.name
		if exportedName.kind == SyntaxKindStringLiteral {
			return
			// Skip for invalid syntax like this: export { "x" }
		}
		symbol := tc.resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, true)
		if symbol && (symbol == tc.undefinedSymbol || symbol == tc.globalThisSymbol || symbol.declarations && isGlobalSourceFile(tc.getDeclarationContainer(symbol.declarations[0]))) {
			// Do nothing, non-local symbol
		} else {
			target := symbol && (__COND__(symbol.flags&SymbolFlagsAlias, tc.resolveAlias(symbol), symbol))
			if !target || tc.getSymbolFlags(target)&SymbolFlagsValue {
				tc.markExportAsReferenced(location)
				// marks export as used
				tc.markIdentifierAliasReferenced(exportedName)
				// marks target of export as used
			}
		}
		return
	}
}

func (tc *TypeChecker) markDecoratorAliasReferenced(node HasDecorators) {
	if tc.compilerOptions.emitDecoratorMetadata {
		firstDecorator := find(node.modifiers, isDecorator)
		if !firstDecorator {
			return
		}

		tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersMetadata)

		// we only need to perform these checks if we are emitting serialized type metadata for the target of a decorator.
		switch node.kind {
		case SyntaxKindClassDeclaration:
			constructor := getFirstConstructorWithBody(node)
			if constructor {
				for _, parameter := range constructor.parameters {
					tc.markDecoratorMedataDataTypeNodeAsReferenced(tc.getParameterTypeNodeForDecoratorCheck(parameter))
				}
			}
		case SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			var otherKind /* TODO(TS-TO-GO) inferred type SyntaxKind.GetAccessor | SyntaxKind.SetAccessor */ any
			if node.kind == SyntaxKindGetAccessor {
				otherKind = SyntaxKindSetAccessor
			} else {
				otherKind = SyntaxKindGetAccessor
			}
			otherAccessor := getDeclarationOfKind(tc.getSymbolOfDeclaration(node), otherKind)
			tc.markDecoratorMedataDataTypeNodeAsReferenced(tc.getAnnotatedAccessorTypeNode(node) || otherAccessor && tc.getAnnotatedAccessorTypeNode(otherAccessor))
		case SyntaxKindMethodDeclaration:
			for _, parameter := range node.parameters {
				tc.markDecoratorMedataDataTypeNodeAsReferenced(tc.getParameterTypeNodeForDecoratorCheck(parameter))
			}

			tc.markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node))
		case SyntaxKindPropertyDeclaration:
			tc.markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node))
		case SyntaxKindParameter:
			tc.markDecoratorMedataDataTypeNodeAsReferenced(tc.getParameterTypeNodeForDecoratorCheck(node))
			containingSignature := node.parent
			for _, parameter := range containingSignature.parameters {
				tc.markDecoratorMedataDataTypeNodeAsReferenced(tc.getParameterTypeNodeForDecoratorCheck(parameter))
			}
			tc.markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature))
		}
	}
}

func (tc *TypeChecker) markAliasReferenced(symbol Symbol, location Node) {
	if !tc.canCollectSymbolAliasAccessabilityData {
		return
	}
	if tc.isNonLocalAlias(symbol /*excludes*/, SymbolFlagsValue) && !isInTypeQuery(location) {
		target := tc.resolveAlias(symbol)
		if tc.getSymbolFlags(symbol /*excludeTypeOnlyMeanings*/, true) & (SymbolFlagsValue | SymbolFlagsExportValue) {
			// An alias resolving to a const enum cannot be elided if (1) 'isolatedModules' is enabled
			// (because the const enum value will not be inlined), or if (2) the alias is an export
			// of a const enum declaration that will be preserved.
			if getIsolatedModules(tc.compilerOptions) || shouldPreserveConstEnums(tc.compilerOptions) && tc.isExportOrExportExpression(location) || !tc.isConstEnumOrConstEnumOnlyModule(tc.getExportSymbolOfValueSymbolIfExported(target)) {
				tc.markAliasSymbolAsReferenced(symbol)
			}
		}
	}
}

// When an alias symbol is referenced, we need to mark the entity it references as referenced and in turn repeat that until
// we reach a non-alias or an exported entity (which is always considered referenced). We do this by checking the target of
// the alias as an expression (which recursively takes us back here if the target references another alias).
func (tc *TypeChecker) markAliasSymbolAsReferenced(symbol Symbol) undefined {
	Debug.assert(tc.canCollectSymbolAliasAccessabilityData)
	links := tc.getSymbolLinks(symbol)
	if !links.referenced {
		links.referenced = true
		node := tc.getDeclarationOfAliasSymbol(symbol)
		if !node {
			return Debug.fail()
		}
		// We defer checking of the reference of an `import =` until the import itself is referenced,
		// This way a chain of imports can be elided if ultimately the final input is only used in a type
		// position.
		if isInternalModuleImportEqualsDeclaration(node) {
			if tc.getSymbolFlags(tc.resolveSymbol(symbol)) & SymbolFlagsValue {
				// import foo = <symbol>
				left := getFirstIdentifier(node.moduleReference /* as EntityNameExpression */)
				tc.markIdentifierAliasReferenced(left)
			}
		}
	}
}

func (tc *TypeChecker) markExportAsReferenced(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ExportSpecifier */ any) {
	symbol := tc.getSymbolOfDeclaration(node)
	target := tc.resolveAlias(symbol)
	if target {
		markAlias := target == tc.unknownSymbol || ((tc.getSymbolFlags(symbol /*excludeTypeOnlyMeanings*/, true) & SymbolFlagsValue) && !tc.isConstEnumOrConstEnumOnlyModule(target))

		if markAlias {
			tc.markAliasSymbolAsReferenced(symbol)
		}
	}
}

func (tc *TypeChecker) markEntityNameOrEntityExpressionAsReference(typeName *EntityNameOrEntityNameExpression, forDecoratorMetadata bool) {
	if !typeName {
		return
	}

	rootName := getFirstIdentifier(typeName)
	meaning := (__COND__(typeName.kind == SyntaxKindIdentifier, SymbolFlagsType, SymbolFlagsNamespace)) | SymbolFlagsAlias
	rootSymbol := tc.resolveName(rootName, rootName.escapedText, meaning /*nameNotFoundMessage*/, nil /*isUse*/, true)
	if rootSymbol && rootSymbol.flags&SymbolFlagsAlias {
		if tc.canCollectSymbolAliasAccessabilityData && tc.symbolIsValue(rootSymbol) && !tc.isConstEnumOrConstEnumOnlyModule(tc.resolveAlias(rootSymbol)) && !tc.getTypeOnlyAliasDeclaration(rootSymbol) {
			tc.markAliasSymbolAsReferenced(rootSymbol)
		} else if forDecoratorMetadata && getIsolatedModules(tc.compilerOptions) && getEmitModuleKind(tc.compilerOptions) >= ModuleKindES2015 && !tc.symbolIsValue(rootSymbol) && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration) {
			diag := tc.error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled)
			aliasDeclaration := find(rootSymbol.declarations || emptyArray, tc.isAliasSymbolDeclaration)
			if aliasDeclaration {
				addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)))
			}
		}
	}
}

/**
 * If a TypeNode can be resolved to a value symbol imported from an external module, it is
 * marked as referenced to prevent import elision.
 */

func (tc *TypeChecker) markTypeNodeAsReferenced(node *TypeNode) {
	tc.markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node) /*forDecoratorMetadata*/, false)
}

/**
 * This function marks the type used for metadata decorator as referenced if it is import
 * from external module.
 * This is different from markTypeNodeAsReferenced because it tries to simplify type nodes in
 * union and intersection type
 * @param node
 */

func (tc *TypeChecker) markDecoratorMedataDataTypeNodeAsReferenced(node *TypeNode) {
	entityName := tc.getEntityNameForDecoratorMetadata(node)
	if entityName && isEntityName(entityName) {
		tc.markEntityNameOrEntityExpressionAsReference(entityName /*forDecoratorMetadata*/, true)
	}
}

func (tc *TypeChecker) getNarrowedTypeOfSymbol(symbol Symbol, location Identifier) Type {
	type_ := tc.getTypeOfSymbol(symbol)
	declaration := symbol.valueDeclaration
	if declaration {
		// If we have a non-rest binding element with no initializer declared as a const variable or a const-like
		// parameter (a parameter for which there are no assignments in the function body), and if the parent type
		// for the destructuring is a union type, one or more of the binding elements may represent discriminant
		// properties, and we want the effects of conditional checks on such discriminants to affect the types of
		// other binding elements from the same destructuring. Consider:
		//
		//   type Action =
		//       | { kind: 'A', payload: number }
		//       | { kind: 'B', payload: string };
		//
		//   function f({ kind, payload }: Action) {
		//       if (kind === 'A') {
		//           payload.toFixed();
		//       }
		//       if (kind === 'B') {
		//           payload.toUpperCase();
		//       }
		//   }
		//
		// Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
		// the binding pattern AST instance for '{ kind, payload }' as a pseudo-reference and narrow this reference
		// as if it occurred in the specified location. We then recompute the narrowed binding element type by
		// destructuring from the narrowed parent type.
		if isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2 {
			parent := declaration.parent.parent
			rootDeclaration := getRootDeclaration(parent)
			if rootDeclaration.kind == SyntaxKindVariableDeclaration && tc.getCombinedNodeFlagsCached(rootDeclaration)&NodeFlagsConstant || rootDeclaration.kind == SyntaxKindParameter {
				links := tc.getNodeLinks(parent)
				if !(links.flags & NodeCheckFlagsInCheckIdentifier) {
					links.flags |= NodeCheckFlagsInCheckIdentifier
					parentType := tc.getTypeForBindingElementParent(parent, CheckModeNormal)
					parentTypeConstraint := parentType && tc.mapType(parentType, tc.getBaseConstraintOrType)
					links.flags &= ~NodeCheckFlagsInCheckIdentifier
					if parentTypeConstraint && parentTypeConstraint.flags&TypeFlagsUnion && !(rootDeclaration.kind == SyntaxKindParameter && tc.isSomeSymbolAssigned(rootDeclaration)) {
						pattern := declaration.parent
						narrowedType := tc.getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint /*flowContainer*/, nil, location.flowNode)
						if narrowedType.flags & TypeFlagsNever {
							return tc.neverType
						}
						// Destructurings are validated against the parent type elsewhere. Here we disable tuple bounds
						// checks because the narrowed type may have lower arity than the full parent type. For example,
						// for the declaration [x, y]: [1, 2] | [3], we may have narrowed the parent type to just [3].
						return tc.getBindingElementTypeFromParentType(declaration, narrowedType /*noTupleBoundsCheck*/, true)
					}
				}
			}
		}
		// If we have a const-like parameter with no type annotation or initializer, and if the parameter is contextually
		// typed by a signature with a single rest parameter of a union of tuple types, one or more of the parameters may
		// represent discriminant tuple elements, and we want the effects of conditional checks on such discriminants to
		// affect the types of other parameters in the same parameter list. Consider:
		//
		//   type Action = [kind: 'A', payload: number] | [kind: 'B', payload: string];
		//
		//   const f: (...args: Action) => void = (kind, payload) => {
		//       if (kind === 'A') {
		//           payload.toFixed();
		//       }
		//       if (kind === 'B') {
		//           payload.toUpperCase();
		//       }
		//   }
		//
		// Above, we want the conditional checks on 'kind' to affect the type of 'payload'. To facilitate this, we use
		// the arrow function AST node for '(kind, payload) => ...' as a pseudo-reference and narrow this reference as
		// if it occurred in the specified location. We then recompute the narrowed parameter type by indexing into the
		// narrowed tuple type.
		if isParameter(declaration) && !declaration.type_ && !declaration.initializer && !declaration.dotDotDotToken {
			func_ := declaration.parent
			if func_.parameters.length >= 2 && tc.isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
				contextualSignature := tc.getContextualSignature(func_)
				if contextualSignature && contextualSignature.parameters.length == 1 && signatureHasRestParameter(contextualSignature) {
					restType := tc.getReducedApparentType(tc.instantiateType(tc.getTypeOfSymbol(contextualSignature.parameters[0]), tc.getInferenceContext(func_). /* ? */ nonFixingMapper))
					if restType.flags&TypeFlagsUnion && tc.everyType(restType, tc.isTupleType) && !some(func_.parameters, tc.isSomeSymbolAssigned) {
						narrowedType := tc.getFlowTypeOfReference(func_, restType, restType /*flowContainer*/, nil, location.flowNode)
						index := func_.parameters.indexOf(declaration) - (__COND__(getThisParameter(func_), 1, 0))
						return tc.getIndexedAccessType(narrowedType, tc.getNumberLiteralType(index))
					}
				}
			}
		}
	}
	return type_
}

/**
 * This part of `checkIdentifier` is kept seperate from the rest, so `NodeCheckFlags` (and related diagnostics) can be lazily calculated
 * without calculating the flow type of the identifier.
 */

func (tc *TypeChecker) checkIdentifierCalculateNodeCheckFlags(node Identifier, symbol Symbol) {
	if isThisInTypeQuery(node) {
		return
	}

	// As noted in ECMAScript 6 language spec, arrow functions never have an arguments objects.
	// Although in down-level emit of arrow function, we emit it using function expression which means that
	// arguments objects will be bound to the inner object; emitting arrow function natively in ES6, arguments objects
	// will be bound to non-arrow function that contain this arrow function. This results in inconsistent behavior.
	// To avoid that we will give an error to users if they use arguments objects in arrow function so that they
	// can explicitly bound arguments objects
	if symbol == tc.argumentsSymbol {
		if tc.isInPropertyInitializerOrClassStaticBlock(node) {
			tc.error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers)
			return
		}

		container := getContainingFunction(node)
		if container {
			if tc.languageVersion < ScriptTargetES2015 {
				if container.kind == SyntaxKindArrowFunction {
					tc.error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression)
				} else if hasSyntacticModifier(container, ModifierFlagsAsync) {
					tc.error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method)
				}
			}

			tc.getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
			for container && isArrowFunction(container) {
				container = getContainingFunction(container)
				if container {
					tc.getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
				}
			}
		}
		return
	}

	localOrExportSymbol := tc.getExportSymbolOfValueSymbolIfExported(symbol)
	targetSymbol := tc.resolveAliasWithDeprecationCheck(localOrExportSymbol, node)
	if tc.isDeprecatedSymbol(targetSymbol) && tc.isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations {
		tc.addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText /* as string */)
	}

	declaration := localOrExportSymbol.valueDeclaration
	if declaration && localOrExportSymbol.flags&SymbolFlagsClass {
		// When we downlevel classes we may emit some code outside of the class body. Due to the fact the
		// class name is double-bound, we must ensure we mark references to the class name so that we can
		// emit an alias to the class later.
		if isClassLike(declaration) && declaration.name != node {
			container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
			for container.kind != SyntaxKindSourceFile && container.parent != declaration {
				container = getThisContainer(container /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
			}

			if container.kind != SyntaxKindSourceFile {
				tc.getNodeLinks(declaration).flags |= NodeCheckFlagsContainsConstructorReference
				tc.getNodeLinks(container).flags |= NodeCheckFlagsContainsConstructorReference
				tc.getNodeLinks(node).flags |= NodeCheckFlagsConstructorReference
			}
		}
	}

	tc.checkNestedBlockScopedBinding(node, symbol)
}

func (tc *TypeChecker) checkIdentifier(node Identifier, checkMode *CheckMode) Type {
	if isThisInTypeQuery(node) {
		return tc.checkThisExpression(node)
	}

	symbol := tc.getResolvedSymbol(node)
	if symbol == tc.unknownSymbol {
		return tc.errorType
	}

	tc.checkIdentifierCalculateNodeCheckFlags(node, symbol)

	if symbol == tc.argumentsSymbol {
		if tc.isInPropertyInitializerOrClassStaticBlock(node) {
			return tc.errorType
		}
		return tc.getTypeOfSymbol(symbol)
	}

	if tc.shouldMarkIdentifierAliasReferenced(node) {
		tc.markLinkedReferences(node, ReferenceHintIdentifier)
	}

	localOrExportSymbol := tc.getExportSymbolOfValueSymbolIfExported(symbol)
	declaration := localOrExportSymbol.valueDeclaration
	immediateDeclaration := declaration

	// If the identifier is declared in a binding pattern for which we're currently computing the implied type and the
	// reference occurs with the same binding pattern, return the non-inferrable any type. This for example occurs in
	// 'const [a, b = a + 1] = [2]' when we're computing the contextual type for the array literal '[2]'.
	if declaration && declaration.kind == SyntaxKindBindingElement && contains(tc.contextualBindingPatterns, declaration.parent) && findAncestor(node, func(parent Node) bool {
		return parent == declaration.parent
	}) {
		return tc.nonInferrableAnyType
	}

	type_ := tc.getNarrowedTypeOfSymbol(localOrExportSymbol, node)
	assignmentKind := getAssignmentTargetKind(node)

	if assignmentKind {
		if !(localOrExportSymbol.flags & SymbolFlagsVariable) && !(isInJSFile(node) && localOrExportSymbol.flags&SymbolFlagsValueModule) {
			var assignmentError DiagnosticMessage
			switch {
			case localOrExportSymbol.flags & SymbolFlagsEnum:
				assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_an_enum
			case localOrExportSymbol.flags & SymbolFlagsClass:
				assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_a_class
			case localOrExportSymbol.flags & SymbolFlagsModule:
				assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace
			case localOrExportSymbol.flags & SymbolFlagsFunction:
				assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_a_function
			case localOrExportSymbol.flags & SymbolFlagsAlias:
				assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_an_import
			default:
				assignmentError = Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable
			}

			tc.error(node, assignmentError, tc.symbolToString(symbol))
			return tc.errorType
		}
		if tc.isReadonlySymbol(localOrExportSymbol) {
			if localOrExportSymbol.flags & SymbolFlagsVariable {
				tc.error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, tc.symbolToString(symbol))
			} else {
				tc.error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, tc.symbolToString(symbol))
			}
			return tc.errorType
		}
	}

	isAlias := localOrExportSymbol.flags & SymbolFlagsAlias

	// We only narrow variables and parameters occurring in a non-assignment position. For all other
	// entities we simply return the declared type.
	if localOrExportSymbol.flags & SymbolFlagsVariable {
		if assignmentKind == AssignmentKindDefinite {
			if isInCompoundLikeAssignment(node) {
				return tc.getBaseTypeOfLiteralType(type_)
			} else {
				return type_
			}
		}
	} else if isAlias {
		declaration = tc.getDeclarationOfAliasSymbol(symbol)
	} else {
		return type_
	}

	if !declaration {
		return type_
	}

	type_ = tc.getNarrowableTypeForReference(type_, node, checkMode)

	// The declaration container is the innermost function that encloses the declaration of the variable
	// or parameter. The flow container is the innermost function starting with which we analyze the control
	// flow graph to determine the control flow based type.
	isParameter := getRootDeclaration(declaration).kind == SyntaxKindParameter
	declarationContainer := tc.getControlFlowContainer(declaration)
	flowContainer := tc.getControlFlowContainer(node)
	isOuterVariable := flowContainer != declarationContainer
	isSpreadDestructuringAssignmentTarget := node.parent && node.parent.parent && isSpreadAssignment(node.parent) && tc.isDestructuringAssignmentTarget(node.parent.parent)
	isModuleExports := symbol.flags & SymbolFlagsModuleExports
	typeIsAutomatic := type_ == tc.autoType || type_ == tc.autoArrayType
	isAutomaticTypeInNonNull := typeIsAutomatic && node.parent.kind == SyntaxKindNonNullExpression
	// When the control flow originates in a function expression, arrow function, method, or accessor, and
	// we are referencing a closed-over const variable or parameter or mutable local variable past its last
	// assignment, we extend the origin of the control flow analysis to include the immediately enclosing
	// control flow container.
	for flowContainer != declarationContainer && (flowContainer.kind == SyntaxKindFunctionExpression || flowContainer.kind == SyntaxKindArrowFunction || isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)) && (tc.isConstantVariable(localOrExportSymbol) && type_ != tc.autoArrayType || tc.isParameterOrMutableLocalVariable(localOrExportSymbol) && tc.isPastLastAssignment(localOrExportSymbol, node)) {
		flowContainer = tc.getControlFlowContainer(flowContainer)
	}
	// We only look for uninitialized variables in strict null checking mode, and only when we can analyze
	// the entire control flow graph from the variable's declaration (i.e. when the flow container and
	// declaration container are the same).
	isNeverInitialized := immediateDeclaration && isVariableDeclaration(immediateDeclaration) && !immediateDeclaration.initializer && !immediateDeclaration.exclamationToken && tc.isMutableLocalVariableDeclaration(immediateDeclaration) && !tc.isSymbolAssignedDefinitely(symbol)
	assumeInitialized := isParameter || isAlias || (isOuterVariable && !isNeverInitialized) || isSpreadDestructuringAssignmentTarget || isModuleExports || tc.isSameScopedBindingElement(node, declaration) || type_ != tc.autoType && type_ != tc.autoArrayType && (!tc.strictNullChecks || (type_.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid)) != 0 || isInTypeQuery(node) || tc.isInAmbientOrTypeNode(node) || node.parent.kind == SyntaxKindExportSpecifier) || node.parent.kind == SyntaxKindNonNullExpression || declaration.kind == SyntaxKindVariableDeclaration && (declaration /* as VariableDeclaration */).exclamationToken || declaration.flags&NodeFlagsAmbient
	var initialType Type
	switch {
	case isAutomaticTypeInNonNull:
		initialType = tc.undefinedType
	case assumeInitialized:
		initialType = (__COND__(isParameter, tc.removeOptionalityFromDeclaredType(type_, declaration /* as VariableLikeDeclaration */), type_))
	case typeIsAutomatic:
		initialType = tc.undefinedType
	default:
		initialType = tc.getOptionalType(type_)
	}
	var flowType Type
	if isAutomaticTypeInNonNull {
		flowType = tc.getNonNullableType(tc.getFlowTypeOfReference(node, type_, initialType, flowContainer))
	} else {
		flowType = tc.getFlowTypeOfReference(node, type_, initialType, flowContainer)
	}
	// A variable is considered uninitialized when it is possible to analyze the entire control flow graph
	// from declaration to use, and when the variable's declared type doesn't include undefined but the
	// control flow based type does include undefined.
	if !tc.isEvolvingArrayOperationTarget(node) && (type_ == tc.autoType || type_ == tc.autoArrayType) {
		if flowType == tc.autoType || flowType == tc.autoArrayType {
			if tc.noImplicitAny {
				tc.error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, tc.symbolToString(symbol), tc.typeToString(flowType))
				tc.error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, tc.symbolToString(symbol), tc.typeToString(flowType))
			}
			return tc.convertAutoToAny(flowType)
		}
	} else if !assumeInitialized && !tc.containsUndefinedType(type_) && tc.containsUndefinedType(flowType) {
		tc.error(node, Diagnostics.Variable_0_is_used_before_being_assigned, tc.symbolToString(symbol))
		// Return the declared type to reduce follow-on errors
		return type_
	}
	if assignmentKind {
		return tc.getBaseTypeOfLiteralType(flowType)
	} else {
		return flowType
	}
}

func (tc *TypeChecker) isSameScopedBindingElement(node Identifier, declaration Declaration) *bool {
	if isBindingElement(declaration) {
		bindingElement := findAncestor(node, isBindingElement)
		return bindingElement && getRootDeclaration(bindingElement) == getRootDeclaration(declaration)
	}
}

func (tc *TypeChecker) shouldMarkIdentifierAliasReferenced(node Identifier) bool {
	parent := node.parent
	if parent {
		// A property access expression LHS? checkPropertyAccessExpression will handle that.
		if isPropertyAccessExpression(parent) && parent.expression == node {
			return false
		}
		// Next two check for an identifier inside a type only export.
		if isExportSpecifier(parent) && parent.isTypeOnly {
			return false
		}
		greatGrandparent := parent.parent. /* ? */ parent
		if greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly {
			return false
		}
	}
	return true
}

func (tc *TypeChecker) isInsideFunctionOrInstancePropertyInitializer(node Node, threshold Node) bool {
	return !!findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if n == threshold {
			return "quit"
		} else {
			return isFunctionLike(n) || (n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer == n)
		}
	})
}

func (tc *TypeChecker) getPartOfForStatementContainingNode(node Node, container ForStatement) Node {
	return findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if n == container {
			return "quit"
		} else {
			return n == container.initializer || n == container.condition || n == container.incrementor || n == container.statement
		}
	})
}

func (tc *TypeChecker) getEnclosingIterationStatement(node Node) Node {
	return findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if !n || nodeStartsNewLexicalEnvironment(n) {
			return "quit"
		} else {
			return isIterationStatement(n /*lookInLabeledStatements*/, false)
		}
	})
}

func (tc *TypeChecker) checkNestedBlockScopedBinding(node Identifier, symbol Symbol) {
	if tc.languageVersion >= ScriptTargetES2015 || (symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsClass)) == 0 || !symbol.valueDeclaration || isSourceFile(symbol.valueDeclaration) || symbol.valueDeclaration.parent.kind == SyntaxKindCatchClause {
		return
	}

	// 1. walk from the use site up to the declaration and check
	// if there is anything function like between declaration and use-site (is binding/class is captured in function).
	// 2. walk from the declaration up to the boundary of lexical environment and check
	// if there is an iteration statement in between declaration and boundary (is binding/class declared inside iteration statement)

	container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
	isCaptured := tc.isInsideFunctionOrInstancePropertyInitializer(node, container)

	enclosingIterationStatement := tc.getEnclosingIterationStatement(container)
	if enclosingIterationStatement {
		if isCaptured {
			// mark iteration statement as containing block-scoped binding captured in some function
			capturesBlockScopeBindingInLoopBody := true
			if isForStatement(container) {
				varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
				if varDeclList && varDeclList.parent == container {
					part := tc.getPartOfForStatementContainingNode(node.parent, container)
					if part {
						links := tc.getNodeLinks(part)
						links.flags |= NodeCheckFlagsContainsCapturedBlockScopeBinding

						capturedBindings := links.capturedBlockScopeBindings || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.capturedBlockScopeBindings = [] */ TODO)
						pushIfUnique(capturedBindings, symbol)

						if part == container.initializer {
							capturesBlockScopeBindingInLoopBody = false
							// Initializer is outside of loop body
						}
					}
				}
			}
			if capturesBlockScopeBindingInLoopBody {
				tc.getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
			}
		}

		// mark variables that are declared in loop initializer and reassigned inside the body of ForStatement.
		// if body of ForStatement will be converted to function then we'll need a extra machinery to propagate reassigned values back.
		if isForStatement(container) {
			varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
			if varDeclList && varDeclList.parent == container && tc.isAssignedInBodyOfForStatement(node, container) {
				tc.getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsNeedsLoopOutParameter
			}
		}

		// set 'declared inside loop' bit on the block-scoped binding
		tc.getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsBlockScopedBindingInLoop
	}

	if isCaptured {
		tc.getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsCapturedBlockScopedBinding
	}
}

func (tc *TypeChecker) isBindingCapturedByNode(node Node, decl /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement */ any) bool {
	links := tc.getNodeLinks(node)
	return !!links && contains(links.capturedBlockScopeBindings, tc.getSymbolOfDeclaration(decl))
}

func (tc *TypeChecker) isAssignedInBodyOfForStatement(node Identifier, container ForStatement) bool {
	// skip parenthesized nodes
	var current Node = node
	for current.parent.kind == SyntaxKindParenthesizedExpression {
		current = current.parent
	}

	// check if node is used as LHS in some assignment expression
	isAssigned := false
	if isAssignmentTarget(current) {
		isAssigned = true
	} else if current.parent.kind == SyntaxKindPrefixUnaryExpression || current.parent.kind == SyntaxKindPostfixUnaryExpression {
		expr := current.parent /* as PrefixUnaryExpression | PostfixUnaryExpression */
		isAssigned = expr.operator == SyntaxKindPlusPlusToken || expr.operator == SyntaxKindMinusMinusToken
	}

	if !isAssigned {
		return false
	}

	// at this point we know that node is the target of assignment
	// now check that modification happens inside the statement part of the ForStatement
	return !!findAncestor(current, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if n == container {
			return "quit"
		} else {
			return n == container.statement
		}
	})
}

func (tc *TypeChecker) captureLexicalThis(node Node, container Node) {
	tc.getNodeLinks(node).flags |= NodeCheckFlagsLexicalThis
	if container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindConstructor {
		classNode := container.parent
		tc.getNodeLinks(classNode).flags |= NodeCheckFlagsCaptureThis
	} else {
		tc.getNodeLinks(container).flags |= NodeCheckFlagsCaptureThis
	}
}

func (tc *TypeChecker) findFirstSuperCall(node Node) *SuperCall {
	switch {
	case isSuperCall(node):
		return node
	case isFunctionLike(node):
		return nil
	default:
		return forEachChild(node, tc.findFirstSuperCall)
	}
}

/**
 * Check if the given class-declaration extends null then return true.
 * Otherwise, return false
 * @param classDecl a class declaration to check if it extends null
 */

func (tc *TypeChecker) classDeclarationExtendsNull(classDecl ClassLikeDeclaration) bool {
	classSymbol := tc.getSymbolOfDeclaration(classDecl)
	classInstanceType := tc.getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */
	baseConstructorType := tc.getBaseConstructorTypeOfClass(classInstanceType)

	return baseConstructorType == tc.nullWideningType
}

func (tc *TypeChecker) checkThisBeforeSuper(node Node, container Node, diagnosticMessage DiagnosticMessage) {
	containingClassDecl := container.parent /* as ClassDeclaration */
	baseTypeNode := getClassExtendsHeritageElement(containingClassDecl)

	// If a containing class does not have extends clause or the class extends null
	// skip checking whether super statement is called before "this" accessing.
	if baseTypeNode && !tc.classDeclarationExtendsNull(containingClassDecl) {
		if canHaveFlowNode(node) && node.flowNode && !tc.isPostSuperFlowNode(node.flowNode /*noCacheCheck*/, false) {
			tc.error(node, diagnosticMessage)
		}
	}
}

func (tc *TypeChecker) checkThisInStaticClassFieldInitializerInDecoratedClass(thisExpression Node, container Node) {
	if isPropertyDeclaration(container) && hasStaticModifier(container) && tc.legacyDecorators && container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent) {
		tc.error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class)
	}
}

func (tc *TypeChecker) checkThisExpression(node Node) Type {
	isNodeInTypeQuery := isInTypeQuery(node)
	// Stop at the first arrow function so that we can
	// tell whether 'this' needs to be captured.
	container := getThisContainer(node /*includeArrowFunctions*/, true /*includeClassComputedPropertyName*/, true)
	capturedByArrowFunction := false
	thisInComputedPropertyName := false

	if container.kind == SyntaxKindConstructor {
		tc.checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class)
	}

	for true {
		// Now skip arrow functions to get the "real" owner of 'this'.
		if container.kind == SyntaxKindArrowFunction {
			container = getThisContainer(container /*includeArrowFunctions*/, false, !thisInComputedPropertyName)
			capturedByArrowFunction = true
		}

		if container.kind == SyntaxKindComputedPropertyName {
			container = getThisContainer(container, !capturedByArrowFunction /*includeClassComputedPropertyName*/, false)
			thisInComputedPropertyName = true
			continue
		}

		break
	}

	tc.checkThisInStaticClassFieldInitializerInDecoratedClass(node, container)
	if thisInComputedPropertyName {
		tc.error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name)
	} else {
		switch container.kind {
		case SyntaxKindModuleDeclaration:
			tc.error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body)
		case SyntaxKindEnumDeclaration:
			tc.error(node, Diagnostics.this_cannot_be_referenced_in_current_location)
		}
	}

	// When targeting es6, mark that we'll need to capture `this` in its lexically bound scope.
	if !isNodeInTypeQuery && capturedByArrowFunction && tc.languageVersion < ScriptTargetES2015 {
		tc.captureLexicalThis(node, container)
	}

	type_ := tc.tryGetThisTypeAt(node /*includeGlobalThis*/, true, container)
	if tc.noImplicitThis {
		globalThisType := tc.getTypeOfSymbol(tc.globalThisSymbol)
		if type_ == globalThisType && capturedByArrowFunction {
			tc.error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this)
		} else if !type_ {
			// With noImplicitThis, functions may not reference 'this' if it has type 'any'
			diag := tc.error(node, Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation)
			if !isSourceFile(container) {
				outsideThis := tc.tryGetThisTypeAt(container)
				if outsideThis && outsideThis != globalThisType {
					addRelatedInfo(diag, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container))
				}
			}
		}
	}
	return type_ || tc.anyType
}

func (tc *TypeChecker) tryGetThisTypeAt(node Node, includeGlobalThis bool /*  = true */, container ThisContainer /*  = getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false) */) Type {
	isInJS := isInJSFile(node)
	if isFunctionLike(container) && (!tc.isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container)) {
		thisType := tc.getThisTypeOfDeclaration(container) || isInJS && tc.getTypeForThisExpressionFromJSDoc(container)
		// Note: a parameter initializer should refer to class-this unless function-this is explicitly annotated.
		// If this is a function in a JS file, it might be a class method.
		if !thisType {
			className := tc.getClassNameFromPrototypeMethod(container)
			if isInJS && className {
				classSymbol := tc.checkExpression(className).symbol
				if classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlagsFunction) {
					thisType = (tc.getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */).thisType
				}
			} else if tc.isJSConstructor(container) {
				thisType = (tc.getDeclaredTypeOfSymbol(tc.getMergedSymbol(container.symbol)) /* as InterfaceType */).thisType
			}
			thisType = thisType || tc.getContextualThisParameterType(container)
		}

		if thisType {
			return tc.getFlowTypeOfReference(node, thisType)
		}
	}

	if isClassLike(container.parent) {
		symbol := tc.getSymbolOfDeclaration(container.parent)
		var type_ Type
		if isStatic(container) {
			type_ = tc.getTypeOfSymbol(symbol)
		} else {
			type_ = (tc.getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */).thisType
		}
		return tc.getFlowTypeOfReference(node, type_)
	}

	if isSourceFile(container) {
		// look up in the source file's locals or exports
		if container.commonJsModuleIndicator {
			fileSymbol := tc.getSymbolOfDeclaration(container)
			return fileSymbol && tc.getTypeOfSymbol(fileSymbol)
		} else if container.externalModuleIndicator {
			// TODO: Maybe issue a better error than 'object is possibly undefined'
			return tc.undefinedType
		} else if includeGlobalThis {
			return tc.getTypeOfSymbol(tc.globalThisSymbol)
		}
	}
}

func (tc *TypeChecker) getExplicitThisType(node Expression) Type {
	container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
	if isFunctionLike(container) {
		signature := tc.getSignatureFromDeclaration(container)
		if signature.thisParameter {
			return tc.getExplicitTypeOfSymbol(signature.thisParameter)
		}
	}
	if isClassLike(container.parent) {
		symbol := tc.getSymbolOfDeclaration(container.parent)
		if isStatic(container) {
			return tc.getTypeOfSymbol(symbol)
		} else {
			return (tc.getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */).thisType
		}
	}
}

func (tc *TypeChecker) getClassNameFromPrototypeMethod(container Node) *LeftHandSideExpression {
	// Check if it's the RHS of a x.prototype.y = function [name]() { .... }
	if container.kind == SyntaxKindFunctionExpression && isBinaryExpression(container.parent) && getAssignmentDeclarationKind(container.parent) == AssignmentDeclarationKindPrototypeProperty {
		// Get the 'x' of 'x.prototype.y = container'
		return ((container.parent.left /* as PropertyAccessExpression */).expression /* as PropertyAccessExpression */).expression
		// x
	} else if container.kind == SyntaxKindMethodDeclaration && container.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent) && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindPrototype {
		return (container.parent.parent.left /* as PropertyAccessExpression */).expression
	} else if container.kind == SyntaxKindFunctionExpression && container.parent.kind == SyntaxKindPropertyAssignment && container.parent.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent.parent) && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindPrototype {
		return (container.parent.parent.parent.left /* as PropertyAccessExpression */).expression
	} else if container.kind == SyntaxKindFunctionExpression && isPropertyAssignment(container.parent) && isIdentifier(container.parent.name) && (container.parent.name.escapedText == "value" || container.parent.name.escapedText == "get" || container.parent.name.escapedText == "set") && isObjectLiteralExpression(container.parent.parent) && isCallExpression(container.parent.parent.parent) && container.parent.parent.parent.arguments[2] == container.parent.parent && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
		return (container.parent.parent.parent.arguments[0] /* as PropertyAccessExpression */).expression
	} else if isMethodDeclaration(container) && isIdentifier(container.name) && (container.name.escapedText == "value" || container.name.escapedText == "get" || container.name.escapedText == "set") && isObjectLiteralExpression(container.parent) && isCallExpression(container.parent.parent) && container.parent.parent.arguments[2] == container.parent && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
		return (container.parent.parent.arguments[0] /* as PropertyAccessExpression */).expression
	}
}

func (tc *TypeChecker) getTypeForThisExpressionFromJSDoc(node SignatureDeclaration) Type {
	thisTag := getJSDocThisTag(node)
	if thisTag && thisTag.typeExpression {
		return tc.getTypeFromTypeNode(thisTag.typeExpression)
	}
	signature := tc.getSignatureOfTypeTag(node)
	if signature {
		return tc.getThisTypeOfSignature(signature)
	}
}

func (tc *TypeChecker) isInConstructorArgumentInitializer(node Node, constructorDecl Node) bool {
	return !!findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if isFunctionLikeDeclaration(n) {
			return "quit"
		} else {
			return n.kind == SyntaxKindParameter && n.parent == constructorDecl
		}
	})
}

func (tc *TypeChecker) checkSuperExpression(node Node) Type {
	isCallExpression := node.parent.kind == SyntaxKindCallExpression && (node.parent /* as CallExpression */).expression == node

	immediateContainer := getSuperContainer(node /*stopOnFunctions*/, true)
	container := immediateContainer
	needToCaptureLexicalThis := false
	inAsyncFunction := false

	// adjust the container reference in case if super is used inside arrow functions with arbitrarily deep nesting
	if !isCallExpression {
		for container && container.kind == SyntaxKindArrowFunction {
			if hasSyntacticModifier(container, ModifierFlagsAsync) {
				inAsyncFunction = true
			}
			container = getSuperContainer(container /*stopOnFunctions*/, true)
			needToCaptureLexicalThis = tc.languageVersion < ScriptTargetES2015
		}
		if container && hasSyntacticModifier(container, ModifierFlagsAsync) {
			inAsyncFunction = true
		}
	}

	var nodeCheckFlag NodeCheckFlags = 0

	if !container || !isLegalUsageOfSuperExpression(container) {
		// issue more specific error if super is used in computed property name
		// class A { foo() { return "1" }}
		// class B {
		//     [super.foo()]() {}
		// }
		current := findAncestor(node, func(n Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			if n == container {
				return "quit"
			} else {
				return n.kind == SyntaxKindComputedPropertyName
			}
		})
		if current && current.kind == SyntaxKindComputedPropertyName {
			tc.error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name)
		} else if isCallExpression {
			tc.error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors)
		} else if !container || !container.parent || !(isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression) {
			tc.error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions)
		} else {
			tc.error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class)
		}
		return tc.errorType
	}

	if !isCallExpression && immediateContainer.kind == SyntaxKindConstructor {
		tc.checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class)
	}

	if isStatic(container) || isCallExpression {
		nodeCheckFlag = NodeCheckFlagsSuperStatic
		if !isCallExpression && tc.languageVersion >= ScriptTargetES2015 && tc.languageVersion <= ScriptTargetES2021 && (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) {
			// for `super.x` or `super[x]` in a static initializer, mark all enclosing
			// block scope containers so that we can report potential collisions with
			// `Reflect`.
			forEachEnclosingBlockScopeContainer(node.parent, func(current Node) {
				if !isSourceFile(current) || isExternalOrCommonJsModule(current) {
					tc.getNodeLinks(current).flags |= NodeCheckFlagsContainsSuperPropertyInStaticInitializer
				}
			})
		}
	} else {
		nodeCheckFlag = NodeCheckFlagsSuperInstance
	}

	tc.getNodeLinks(node).flags |= nodeCheckFlag

	// Due to how we emit async functions, we need to specialize the emit for an async method that contains a `super` reference.
	// This is due to the fact that we emit the body of an async function inside of a generator function. As generator
	// functions cannot reference `super`, we emit a helper inside of the method body, but outside of the generator. This helper
	// uses an arrow function, which is permitted to reference `super`.
	//
	// There are two primary ways we can access `super` from within an async method. The first is getting the value of a property
	// or indexed access on super, either as part of a right-hand-side expression or call expression. The second is when setting the value
	// of a property or indexed access, either as part of an assignment expression or destructuring assignment.
	//
	// The simplest case is reading a value, in which case we will emit something like the following:
	//
	//  // ts
	//  ...
	//  async asyncMethod() {
	//    let x = await super.asyncMethod();
	//    return x;
	//  }
	//  ...
	//
	//  // js
	//  ...
	//  asyncMethod() {
	//      const _super = Object.create(null, {
	//        asyncMethod: { get: () => super.asyncMethod },
	//      });
	//      return __awaiter(this, arguments, Promise, function *() {
	//          let x = yield _super.asyncMethod.call(this);
	//          return x;
	//      });
	//  }
	//  ...
	//
	// The more complex case is when we wish to assign a value, especially as part of a destructuring assignment. As both cases
	// are legal in ES6, but also likely less frequent, we only emit setters if there is an assignment:
	//
	//  // ts
	//  ...
	//  async asyncMethod(ar: Promise<any[]>) {
	//      [super.a, super.b] = await ar;
	//  }
	//  ...
	//
	//  // js
	//  ...
	//  asyncMethod(ar) {
	//      const _super = Object.create(null, {
	//        a: { get: () => super.a, set: (v) => super.a = v },
	//        b: { get: () => super.b, set: (v) => super.b = v }
	//      };
	//      return __awaiter(this, arguments, Promise, function *() {
	//          [_super.a, _super.b] = yield ar;
	//      });
	//  }
	//  ...
	//
	// Creating an object that has getter and setters instead of just an accessor function is required for destructuring assignments
	// as a call expression cannot be used as the target of a destructuring assignment while a property access can.
	//
	// For element access expressions (`super[x]`), we emit a generic helper that forwards the element access in both situations.
	if container.kind == SyntaxKindMethodDeclaration && inAsyncFunction {
		if isSuperProperty(node.parent) && isAssignmentTarget(node.parent) {
			tc.getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync
		} else {
			tc.getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync
		}
	}

	if needToCaptureLexicalThis {
		// call expressions are allowed only in constructors so they should always capture correct 'this'
		// super property access expressions can also appear in arrow functions -
		// in this case they should also use correct lexical this
		tc.captureLexicalThis(node.parent, container)
	}

	if container.parent.kind == SyntaxKindObjectLiteralExpression {
		if tc.languageVersion < ScriptTargetES2015 {
			tc.error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher)
			return tc.errorType
		} else {
			// for object literal assume that type of 'super' is 'any'
			return tc.anyType
		}
	}

	// at this point the only legal case for parent is ClassLikeDeclaration
	classLikeDeclaration := container.parent /* as ClassLikeDeclaration */
	if !getClassExtendsHeritageElement(classLikeDeclaration) {
		tc.error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class)
		return tc.errorType
	}

	if tc.classDeclarationExtendsNull(classLikeDeclaration) {
		if isCallExpression {
			return tc.errorType
		} else {
			return tc.nullWideningType
		}
	}

	classType := tc.getDeclaredTypeOfSymbol(tc.getSymbolOfDeclaration(classLikeDeclaration)) /* as InterfaceType */
	baseClassType := classType && tc.getBaseTypes(classType)[0]
	if !baseClassType {
		return tc.errorType
	}

	if container.kind == SyntaxKindConstructor && tc.isInConstructorArgumentInitializer(node, container) {
		// issue custom error message for super property access in constructor arguments (to be aligned with old compiler)
		tc.error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments)
		return tc.errorType
	}

	if nodeCheckFlag == NodeCheckFlagsSuperStatic {
		return tc.getBaseConstructorTypeOfClass(classType)
	} else {
		return tc.getTypeWithThisArgument(baseClassType, classType.thisType)
	}

	isLegalUsageOfSuperExpression := func(container Node) bool {
		if isCallExpression {
			// TS 1.0 SPEC (April 2014): 4.8.1
			// Super calls are only permitted in constructors of derived classes
			return container.kind == SyntaxKindConstructor
		} else {
			// TS 1.0 SPEC (April 2014)
			// 'super' property access is allowed
			// - In a constructor, instance member function, instance member accessor, or instance member variable initializer where this references a derived class instance
			// - In a static member function or static member accessor

			// topmost container must be something that is directly nested in the class declaration\object literal expression
			if isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression {
				if isStatic(container) {
					return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindClassStaticBlockDeclaration
				} else {
					return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindPropertySignature || container.kind == SyntaxKindConstructor
				}
			}
		}

		return false
	}

}

func (tc *TypeChecker) getContainingObjectLiteral(func_ SignatureDeclaration) *ObjectLiteralExpression {
	switch {
	case (func_.kind == SyntaxKindMethodDeclaration || func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor) && func_.parent.kind == SyntaxKindObjectLiteralExpression:
		return func_.parent
	case func_.kind == SyntaxKindFunctionExpression && func_.parent.kind == SyntaxKindPropertyAssignment:
		return func_.parent.parent /* as ObjectLiteralExpression */
	default:
		return nil
	}
}

func (tc *TypeChecker) getThisTypeArgument(type_ Type) Type {
	if getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as TypeReference */).target == tc.globalThisType {
		return tc.getTypeArguments(type_ /* as TypeReference */)[0]
	} else {
		return nil
	}
}

func (tc *TypeChecker) getThisTypeFromContextualType(type_ Type) Type {
	return tc.mapType(type_, func(t Type) Type {
		if t.flags & TypeFlagsIntersection {
			return forEach((t /* as IntersectionType */).types, tc.getThisTypeArgument)
		} else {
			return tc.getThisTypeArgument(t)
		}
	})
}

func (tc *TypeChecker) getThisTypeOfObjectLiteralFromContextualType(containingLiteral ObjectLiteralExpression, contextualType Type) Type {
	literal := containingLiteral
	type_ := contextualType
	for type_ {
		thisType := tc.getThisTypeFromContextualType(type_)
		if thisType {
			return thisType
		}
		if literal.parent.kind != SyntaxKindPropertyAssignment {
			break
		}
		literal = literal.parent.parent /* as ObjectLiteralExpression */
		type_ = tc.getApparentTypeOfContextualType(literal /*contextFlags*/, nil)
	}
}

func (tc *TypeChecker) getContextualThisParameterType(func_ SignatureDeclaration) Type {
	if func_.kind == SyntaxKindArrowFunction {
		return nil
	}
	if tc.isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
		contextualSignature := tc.getContextualSignature(func_)
		if contextualSignature {
			thisParameter := contextualSignature.thisParameter
			if thisParameter {
				return tc.getTypeOfSymbol(thisParameter)
			}
		}
	}
	inJs := isInJSFile(func_)
	if tc.noImplicitThis || inJs {
		containingLiteral := tc.getContainingObjectLiteral(func_)
		if containingLiteral {
			// We have an object literal method. Check if the containing object literal has a contextual type
			// that includes a ThisType<T>. If so, T is the contextual type for 'this'. We continue looking in
			// any directly enclosing object literals.
			contextualType := tc.getApparentTypeOfContextualType(containingLiteral /*contextFlags*/, nil)
			thisType := tc.getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
			if thisType {
				return tc.instantiateType(thisType, tc.getMapperFromContext(tc.getInferenceContext(containingLiteral)))
			}
			// There was no contextual ThisType<T> for the containing object literal, so the contextual type
			// for 'this' is the non-null form of the contextual type for the containing object literal or
			// the type of the object literal itself.
			return tc.getWidenedType(__COND__(contextualType, tc.getNonNullableType(contextualType), tc.checkExpressionCached(containingLiteral)))
		}
		// In an assignment of the form 'obj.xxx = function(...)' or 'obj[xxx] = function(...)', the
		// contextual type for 'this' is 'obj'.
		parent := walkUpParenthesizedExpressions(func_.parent)
		if isAssignmentExpression(parent) {
			target := parent.left
			if isAccessExpression(target) {
				TODO_IDENTIFIER := target
				// Don't contextually type `this` as `exports` in `exports.Point = function(x, y) { this.x = x; this.y = y; }`
				if inJs && isIdentifier(expression) {
					sourceFile := getSourceFileOfNode(parent)
					if sourceFile.commonJsModuleIndicator && tc.getResolvedSymbol(expression) == sourceFile.symbol {
						return nil
					}
				}

				return tc.getWidenedType(tc.checkExpressionCached(expression))
			}
		}
	}
	return nil
}

// Return contextual type of parameter or undefined if no contextual type is available
func (tc *TypeChecker) getContextuallyTypedParameterType(parameter ParameterDeclaration) Type {
	func_ := parameter.parent
	if !tc.isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
		return nil
	}
	iife := getImmediatelyInvokedFunctionExpression(func_)
	if iife && iife.arguments {
		args := tc.getEffectiveCallArguments(iife)
		indexOfParameter := func_.parameters.indexOf(parameter)
		if parameter.dotDotDotToken {
			return tc.getSpreadArgumentType(args, indexOfParameter, args.length, tc.anyType /*context*/, nil, CheckModeNormal)
		}
		links := tc.getNodeLinks(iife)
		cached := links.resolvedSignature
		links.resolvedSignature = tc.anySignature
		var type_ Type
		switch {
		case indexOfParameter < args.length:
			type_ = tc.getWidenedLiteralType(tc.checkExpression(args[indexOfParameter]))
		case parameter.initializer:
			type_ = nil
		default:
			type_ = tc.undefinedWideningType
		}
		links.resolvedSignature = cached
		return type_
	}
	contextualSignature := tc.getContextualSignature(func_)
	if contextualSignature {
		index := func_.parameters.indexOf(parameter) - (__COND__(getThisParameter(func_), 1, 0))
		if parameter.dotDotDotToken && lastOrUndefined(func_.parameters) == parameter {
			return tc.getRestTypeAtPosition(contextualSignature, index)
		} else {
			return tc.tryGetTypeAtPosition(contextualSignature, index)
		}
	}
}

func (tc *TypeChecker) getContextualTypeForVariableLikeDeclaration(declaration VariableLikeDeclaration, contextFlags *ContextFlags) Type {
	typeNode := getEffectiveTypeAnnotationNode(declaration) || (__COND__(isInJSFile(declaration), tryGetJSDocSatisfiesTypeNode(declaration), nil))
	if typeNode {
		return tc.getTypeFromTypeNode(typeNode)
	}
	switch declaration.kind {
	case SyntaxKindParameter:
		return tc.getContextuallyTypedParameterType(declaration)
	case SyntaxKindBindingElement:
		return tc.getContextualTypeForBindingElement(declaration, contextFlags)
	case SyntaxKindPropertyDeclaration:
		if isStatic(declaration) {
			return tc.getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags)
		}
	}
}

func (tc *TypeChecker) getContextualTypeForBindingElement(declaration BindingElement, contextFlags *ContextFlags) Type {
	parent := declaration.parent.parent
	name := declaration.propertyName || declaration.name
	parentType := tc.getContextualTypeForVariableLikeDeclaration(parent, contextFlags) || parent.kind != SyntaxKindBindingElement && parent.initializer && tc.checkDeclarationInitializer(parent, __COND__(declaration.dotDotDotToken, CheckModeRestBindingElement, CheckModeNormal))
	if !parentType || isBindingPattern(name) || isComputedNonLiteralName(name) {
		return nil
	}
	if parent.name.kind == SyntaxKindArrayBindingPattern {
		index := indexOfNode(declaration.parent.elements, declaration)
		if index < 0 {
			return nil
		}
		return tc.getContextualTypeForElementExpression(parentType, index)
	}
	nameType := tc.getLiteralTypeFromPropertyName(name)
	if isTypeUsableAsPropertyName(nameType) {
		text := getPropertyNameFromType(nameType)
		return tc.getTypeOfPropertyOfType(parentType, text)
	}
}

func (tc *TypeChecker) getContextualTypeForStaticPropertyDeclaration(declaration PropertyDeclaration, contextFlags *ContextFlags) Type {
	parentType := isExpression(declaration.parent) && tc.getContextualType(declaration.parent, contextFlags)
	if !parentType {
		return nil
	}
	return tc.getTypeOfPropertyOfContextualType(parentType, tc.getSymbolOfDeclaration(declaration).escapedName)
}

// In a variable, parameter or property declaration with a type annotation,
//
//	the contextual type of an initializer expression is the type of the variable, parameter or property.
//
// Otherwise, in a parameter declaration of a contextually typed function expression,
//
//	the contextual type of an initializer expression is the contextual type of the parameter.
//
// Otherwise, in a variable or parameter declaration with a binding pattern name,
//
//	the contextual type of an initializer expression is the type implied by the binding pattern.
//
// Otherwise, in a binding pattern inside a variable or parameter declaration,
//
//	the contextual type of an initializer expression is the type annotation of the containing declaration, if present.
func (tc *TypeChecker) getContextualTypeForInitializerExpression(node Expression, contextFlags *ContextFlags) Type {
	declaration := node.parent /* as VariableLikeDeclaration */
	if hasInitializer(declaration) && node == declaration.initializer {
		result := tc.getContextualTypeForVariableLikeDeclaration(declaration, contextFlags)
		if result {
			return result
		}
		if !(contextFlags & ContextFlagsSkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0 {
			return tc.getTypeFromBindingPattern(declaration.name /*includePatternInType*/, true /*reportErrors*/, false)
		}
	}
	return nil
}

func (tc *TypeChecker) getContextualTypeForReturnExpression(node Expression, contextFlags *ContextFlags) Type {
	func_ := getContainingFunction(node)
	if func_ {
		contextualReturnType := tc.getContextualReturnType(func_, contextFlags)
		if contextualReturnType {
			functionFlags := getFunctionFlags(func_)
			if functionFlags & FunctionFlagsGenerator {
				isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
				if contextualReturnType.flags & TypeFlagsUnion {
					contextualReturnType = tc.filterType(contextualReturnType, func(type_ Type) bool {
						return !!tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
					})
				}
				iterationReturnType := tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, contextualReturnType, (functionFlags&FunctionFlagsAsync) != 0)
				if !iterationReturnType {
					return nil
				}
				contextualReturnType = iterationReturnType
				// falls through to unwrap Promise for AsyncGenerators
			}

			if functionFlags & FunctionFlagsAsync {
				// Get the awaited type without the `Awaited<T>` alias
				contextualAwaitedType := tc.mapType(contextualReturnType, tc.getAwaitedTypeNoAlias)
				return contextualAwaitedType && tc.getUnionType([]Type{contextualAwaitedType, tc.createPromiseLikeType(contextualAwaitedType)})
			}

			return contextualReturnType
			// Regular function or Generator function
		}
	}
	return nil
}

func (tc *TypeChecker) getContextualTypeForAwaitOperand(node AwaitExpression, contextFlags *ContextFlags) Type {
	contextualType := tc.getContextualType(node, contextFlags)
	if contextualType {
		contextualAwaitedType := tc.getAwaitedTypeNoAlias(contextualType)
		return contextualAwaitedType && tc.getUnionType([]Type{contextualAwaitedType, tc.createPromiseLikeType(contextualAwaitedType)})
	}
	return nil
}

func (tc *TypeChecker) getContextualTypeForYieldOperand(node YieldExpression, contextFlags *ContextFlags) Type {
	func_ := getContainingFunction(node)
	if func_ {
		functionFlags := getFunctionFlags(func_)
		contextualReturnType := tc.getContextualReturnType(func_, contextFlags)
		if contextualReturnType {
			isAsyncGenerator := (functionFlags & FunctionFlagsAsync) != 0
			if !node.asteriskToken && contextualReturnType.flags&TypeFlagsUnion {
				contextualReturnType = tc.filterType(contextualReturnType, func(type_ Type) bool {
					return !!tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, type_, isAsyncGenerator)
				})
			}
			if node.asteriskToken {
				iterationTypes := tc.getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator)
				yieldType := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: iterationTypes?.yieldType ?? silentNeverType */ TODO
				returnType := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getContextualType(node, contextFlags) ?? silentNeverType */ TODO
				nextType := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: iterationTypes?.nextType ?? unknownType */ TODO
				generatorType := tc.createGeneratorType(yieldType, returnType, nextType /*isAsyncGenerator*/, false)
				if isAsyncGenerator {
					asyncGeneratorType := tc.createGeneratorType(yieldType, returnType, nextType /*isAsyncGenerator*/, true)
					return tc.getUnionType([]ObjectType{generatorType, asyncGeneratorType})
				}
				return generatorType
			}
			return tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, contextualReturnType, isAsyncGenerator)
		}
	}

	return nil
}

func (tc *TypeChecker) isInParameterInitializerBeforeContainingFunction(node Node) bool {
	inBindingInitializer := false
	for node.parent && !isFunctionLike(node.parent) {
		if isParameter(node.parent) && (inBindingInitializer || node.parent.initializer == node) {
			return true
		}
		if isBindingElement(node.parent) && node.parent.initializer == node {
			inBindingInitializer = true
		}

		node = node.parent
	}

	return false
}

func (tc *TypeChecker) getContextualIterationType(kind IterationTypeKind, functionDecl SignatureDeclaration) Type {
	isAsync := !!(getFunctionFlags(functionDecl) & FunctionFlagsAsync)
	contextualReturnType := tc.getContextualReturnType(functionDecl /*contextFlags*/, nil)
	if contextualReturnType {
		return tc.getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || nil
	}

	return nil
}

func (tc *TypeChecker) getContextualReturnType(functionDecl SignatureDeclaration, contextFlags *ContextFlags) Type {
	// If the containing function has a return type annotation, is a constructor, or is a get accessor whose
	// corresponding set accessor has a type annotation, return statements in the function are contextually typed
	returnType := tc.getReturnTypeFromAnnotation(functionDecl)
	if returnType {
		return returnType
	}
	// Otherwise, if the containing function is contextually typed by a function type with exactly one call signature
	// and that call signature is non-generic, return statements are contextually typed by the return type of the signature
	signature := tc.getContextualSignatureForFunctionLikeDeclaration(functionDecl /* as FunctionExpression */)
	if signature && !tc.isResolvingReturnTypeOfSignature(signature) {
		returnType := tc.getReturnTypeOfSignature(signature)
		functionFlags := getFunctionFlags(functionDecl)
		if functionFlags & FunctionFlagsGenerator {
			return tc.filterType(returnType, func(t Type) bool {
				return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || tc.checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags /*errorNode*/, nil)
			})
		}
		if functionFlags & FunctionFlagsAsync {
			return tc.filterType(returnType, func(t Type) bool {
				return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || !!tc.getAwaitedTypeOfPromise(t)
			})
		}
		return returnType
	}
	iife := getImmediatelyInvokedFunctionExpression(functionDecl)
	if iife {
		return tc.getContextualType(iife, contextFlags)
	}
	return nil
}

// In a typed function call, an argument or substitution expression is contextually typed by the type of the corresponding parameter.
func (tc *TypeChecker) getContextualTypeForArgument(callTarget CallLikeExpression, arg Expression) Type {
	args := tc.getEffectiveCallArguments(callTarget)
	argIndex := args.indexOf(arg)
	// -1 for e.g. the expression of a CallExpression, or the tag of a TaggedTemplateExpression
	if argIndex == -1 {
		return nil
	} else {
		return tc.getContextualTypeForArgumentAtIndex(callTarget, argIndex)
	}
}

func (tc *TypeChecker) getContextualTypeForArgumentAtIndex(callTarget CallLikeExpression, argIndex number) Type {
	if isImportCall(callTarget) {
		switch {
		case argIndex == 0:
			return tc.stringType
		case argIndex == 1:
			return tc.getGlobalImportCallOptionsType(false)
		default:
			return tc.anyType
		}
	}

	// If we're already in the process of resolving the given signature, don't resolve again as
	// that could cause infinite recursion. Instead, return anySignature.
	var signature Signature
	if tc.getNodeLinks(callTarget).resolvedSignature == tc.resolvingSignature {
		signature = tc.resolvingSignature
	} else {
		signature = tc.getResolvedSignature(callTarget)
	}

	if isJsxOpeningLikeElement(callTarget) && argIndex == 0 {
		return tc.getEffectiveFirstArgumentForJsxSignature(signature, callTarget)
	}
	restIndex := signature.parameters.length - 1
	if signatureHasRestParameter(signature) && argIndex >= restIndex {
		return tc.getIndexedAccessType(tc.getTypeOfSymbol(signature.parameters[restIndex]), tc.getNumberLiteralType(argIndex-restIndex), AccessFlagsContextual)
	} else {
		return tc.getTypeAtPosition(signature, argIndex)
	}
}

func (tc *TypeChecker) getContextualTypeForDecorator(decorator Decorator) Type {
	signature := tc.getDecoratorCallSignature(decorator)
	if signature {
		return tc.getOrCreateTypeFromSignature(signature)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getContextualTypeForSubstitutionExpression(template TemplateExpression, substitutionExpression Expression) Type {
	if template.parent.kind == SyntaxKindTaggedTemplateExpression {
		return tc.getContextualTypeForArgument(template.parent /* as TaggedTemplateExpression */, substitutionExpression)
	}

	return nil
}

func (tc *TypeChecker) getContextualTypeForBinaryOperand(node Expression, contextFlags *ContextFlags) Type {
	binaryExpression := node.parent /* as BinaryExpression */
	TODO_IDENTIFIER := binaryExpression
	switch operatorToken.kind {
	case SyntaxKindEqualsToken,
		SyntaxKindAmpersandAmpersandEqualsToken,
		SyntaxKindBarBarEqualsToken,
		SyntaxKindQuestionQuestionEqualsToken:
		if node == right {
			return tc.getContextualTypeForAssignmentDeclaration(binaryExpression)
		} else {
			return nil
		}
	case SyntaxKindBarBarToken,
		SyntaxKindQuestionQuestionToken:
		type_ := tc.getContextualType(binaryExpression, contextFlags)
		if node == right && (type_ && type_.pattern || !type_ && !isDefaultedExpandoInitializer(binaryExpression)) {
			return tc.getTypeOfExpression(left)
		} else {
			return type_
		}
	case SyntaxKindAmpersandAmpersandToken,
		SyntaxKindCommaToken:
		if node == right {
			return tc.getContextualType(binaryExpression, contextFlags)
		} else {
			return nil
		}
	default:
		return nil
	}
}

/**
 * Try to find a resolved symbol for an expression without also resolving its type, as
 * getSymbolAtLocation would (as that could be reentrant into contextual typing)
 */

func (tc *TypeChecker) getSymbolForExpression(e Expression) Symbol {
	if canHaveSymbol(e) && e.symbol {
		return e.symbol
	}
	if isIdentifier(e) {
		return tc.getResolvedSymbol(e)
	}
	if isPropertyAccessExpression(e) {
		lhsType := tc.getTypeOfExpression(e.expression)
		if isPrivateIdentifier(e.name) {
			return tryGetPrivateIdentifierPropertyOfType(lhsType, e.name)
		} else {
			return tc.getPropertyOfType(lhsType, e.name.escapedText)
		}
	}
	if isElementAccessExpression(e) {
		propType := tc.checkExpressionCached(e.argumentExpression)
		if !isTypeUsableAsPropertyName(propType) {
			return nil
		}
		lhsType := tc.getTypeOfExpression(e.expression)
		return tc.getPropertyOfType(lhsType, getPropertyNameFromType(propType))
	}
	return nil

	tryGetPrivateIdentifierPropertyOfType := func(type_ Type, id PrivateIdentifier) Symbol {
		lexicallyScopedSymbol := tc.lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id)
		return lexicallyScopedSymbol && tc.getPrivateIdentifierPropertyOfType(type_, lexicallyScopedSymbol)
	}

}

// In an assignment expression, the right operand is contextually typed by the type of the left operand.
// Don't do this for assignment declarations unless there is a type tag on the assignment, to avoid circularity from checking the right operand.
func (tc *TypeChecker) getContextualTypeForAssignmentDeclaration(binaryExpression BinaryExpression) Type {
	kind := getAssignmentDeclarationKind(binaryExpression)
	switch kind {
	case AssignmentDeclarationKindNone,
		AssignmentDeclarationKindThisProperty:
		lhsSymbol := tc.getSymbolForExpression(binaryExpression.left)
		decl := lhsSymbol && lhsSymbol.valueDeclaration
		if decl && (isPropertyDeclaration(decl) || isPropertySignature(decl)) {
			overallAnnotation := getEffectiveTypeAnnotationNode(decl)
			return (overallAnnotation && tc.instantiateType(tc.getTypeFromTypeNode(overallAnnotation), tc.getSymbolLinks(lhsSymbol).mapper)) || (__COND__(isPropertyDeclaration(decl), decl.initializer && tc.getTypeOfExpression(binaryExpression.left), nil))
		}
		if kind == AssignmentDeclarationKindNone {
			return tc.getTypeOfExpression(binaryExpression.left)
		}
		return tc.getContextualTypeForThisPropertyAssignment(binaryExpression)
	case AssignmentDeclarationKindProperty:
		if tc.isPossiblyAliasedThisProperty(binaryExpression, kind) {
			return tc.getContextualTypeForThisPropertyAssignment(binaryExpression)
		} else if !canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol {
			return tc.getTypeOfExpression(binaryExpression.left)
		} else {
			decl := binaryExpression.left.symbol.valueDeclaration
			if !decl {
				return nil
			}
			lhs := cast(binaryExpression.left, isAccessExpression)
			overallAnnotation := getEffectiveTypeAnnotationNode(decl)
			if overallAnnotation {
				return tc.getTypeFromTypeNode(overallAnnotation)
			} else if isIdentifier(lhs.expression) {
				id := lhs.expression
				parentSymbol := tc.resolveName(id, id.escapedText, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
				if parentSymbol {
					annotated := parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration)
					if annotated {
						nameStr := getElementOrPropertyAccessName(lhs)
						if nameStr != nil {
							return tc.getTypeOfPropertyOfContextualType(tc.getTypeFromTypeNode(annotated), nameStr)
						}
					}
					return nil
				}
			}
			if isInJSFile(decl) || decl == binaryExpression.left {
				return nil
			} else {
				return tc.getTypeOfExpression(binaryExpression.left)
			}
		}
		fallthrough
	case AssignmentDeclarationKindExportsProperty,
		AssignmentDeclarationKindPrototype,
		AssignmentDeclarationKindPrototypeProperty,
		AssignmentDeclarationKindModuleExports:
		var valueDeclaration Declaration
		if kind != AssignmentDeclarationKindModuleExports {
			if canHaveSymbol(binaryExpression.left) {
				valueDeclaration = binaryExpression.left.symbol. /* ? */ valueDeclaration
			} else {
				valueDeclaration = nil
			}
		}
		valueDeclaration = valueDeclaration || binaryExpression.symbol. /* ? */ valueDeclaration
		annotated := valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration)
		if annotated {
			return tc.getTypeFromTypeNode(annotated)
		} else {
			return nil
		}
	case AssignmentDeclarationKindObjectDefinePropertyValue,
		AssignmentDeclarationKindObjectDefinePropertyExports,
		AssignmentDeclarationKindObjectDefinePrototypeProperty:
		return Debug.fail("Does not apply")
	default:
		return Debug.assertNever(kind)
	}
}

func (tc *TypeChecker) isPossiblyAliasedThisProperty(declaration BinaryExpression, kind AssignmentDeclarationKind /*  = getAssignmentDeclarationKind(declaration) */) bool {
	if kind == AssignmentDeclarationKindThisProperty {
		return true
	}
	if !isInJSFile(declaration) || kind != AssignmentDeclarationKindProperty || !isIdentifier((declaration.left /* as AccessExpression */).expression) {
		return false
	}
	name := ((declaration.left /* as AccessExpression */).expression /* as Identifier */).escapedText
	symbol := tc.resolveName(declaration.left, name, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true /*excludeGlobals*/, true)
	return isThisInitializedDeclaration(symbol. /* ? */ valueDeclaration)
}

func (tc *TypeChecker) getContextualTypeForThisPropertyAssignment(binaryExpression BinaryExpression) Type {
	if !binaryExpression.symbol {
		return tc.getTypeOfExpression(binaryExpression.left)
	}
	if binaryExpression.symbol.valueDeclaration {
		annotated := getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration)
		if annotated {
			type_ := tc.getTypeFromTypeNode(annotated)
			if type_ {
				return type_
			}
		}
	}
	thisAccess := cast(binaryExpression.left, isAccessExpression)
	if !isObjectLiteralMethod(getThisContainer(thisAccess.expression /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)) {
		return nil
	}
	thisType := tc.checkThisExpression(thisAccess.expression)
	nameStr := getElementOrPropertyAccessName(thisAccess)
	return nameStr != nil && tc.getTypeOfPropertyOfContextualType(thisType, nameStr) || nil
}

func (tc *TypeChecker) isCircularMappedProperty(symbol Symbol) bool {
	return !!(getCheckFlags(symbol)&CheckFlagsMapped && !(symbol /* as MappedSymbol */).links.type_ && tc.findResolutionCycleStartIndex(symbol, TypeSystemPropertyNameType) >= 0)
}

func (tc *TypeChecker) isExcludedMappedPropertyName(constraint Type, propertyNameType Type) bool {
	if constraint.flags & TypeFlagsConditional {
		type_ := constraint /* as ConditionalType */
		return !!(tc.getReducedType(tc.getTrueTypeFromConditionalType(type_)).flags & TypeFlagsNever) && tc.getActualTypeVariable(tc.getFalseTypeFromConditionalType(type_)) == tc.getActualTypeVariable(type_.checkType) && tc.isTypeAssignableTo(propertyNameType, type_.extendsType)
	}
	if constraint.flags & TypeFlagsIntersection {
		return some((constraint /* as IntersectionType */).types, func(t Type) bool {
			return tc.isExcludedMappedPropertyName(t, propertyNameType)
		})
	}
	return false
}

func (tc *TypeChecker) getTypeOfPropertyOfContextualType(type_ Type, name __String, nameType Type) Type {
	return tc.mapType(type_, func(t Type) Type {
		if t.flags & TypeFlagsIntersection {
			var types *[]Type
			var indexInfoCandidates *[]Type
			ignoreIndexInfos := false
			for _, constituentType := range (t /* as IntersectionType */).types {
				if !(constituentType.flags & TypeFlagsObject) {
					continue
				}
				if tc.isGenericMappedType(constituentType) && tc.getMappedTypeNameTypeKind(constituentType) != MappedTypeNameTypeKindRemapping {
					substitutedType := tc.getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType)
					types = tc.appendContextualPropertyTypeConstituent(types, substitutedType)
					continue
				}
				propertyType := tc.getTypeOfConcretePropertyOfContextualType(constituentType, name)
				if !propertyType {
					if !ignoreIndexInfos {
						indexInfoCandidates = append(indexInfoCandidates, constituentType)
					}
					continue
				}
				ignoreIndexInfos = true
				indexInfoCandidates = nil
				types = tc.appendContextualPropertyTypeConstituent(types, propertyType)
			}
			if indexInfoCandidates {
				for _, candidate := range indexInfoCandidates {
					indexInfoType := tc.getTypeFromIndexInfosOfContextualType(candidate, name, nameType)
					types = tc.appendContextualPropertyTypeConstituent(types, indexInfoType)
				}
			}
			if !types {
				return
			}
			if types.length == 1 {
				return types[0]
			}
			return tc.getIntersectionType(types)
		}
		if !(t.flags & TypeFlagsObject) {
			return
		}
		if tc.isGenericMappedType(t) && tc.getMappedTypeNameTypeKind(t) != MappedTypeNameTypeKindRemapping {
			return tc.getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)
		} else {
			return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType) */ TODO
		}
	}, /*noReductions*/ true)
}

func (tc *TypeChecker) appendContextualPropertyTypeConstituent(types *[]Type, type_ Type) *[]Type {
	// any doesn't provide any contextual information but could spoil the overall result by nullifying contextual information provided by other intersection constituents
	// so it gets replaced with `unknown` as `T & unknown` is just `T` and all types computed based on the contextual information provided by other constituens are still assignable to any
	if type_ {
		return append(types, __COND__(type_.flags&TypeFlagsAny, tc.unknownType, type_))
	} else {
		return types
	}
}

func (tc *TypeChecker) getIndexedMappedTypeSubstitutedTypeOfContextualType(type_ MappedType, name __String, nameType Type) Type {
	propertyNameType := nameType || tc.getStringLiteralType(unescapeLeadingUnderscores(name))
	constraint := tc.getConstraintTypeFromMappedType(type_)
	// special case for conditional types pretending to be negated types
	if type_.nameType && tc.isExcludedMappedPropertyName(type_.nameType, propertyNameType) || tc.isExcludedMappedPropertyName(constraint, propertyNameType) {
		return
	}
	constraintOfConstraint := tc.getBaseConstraintOfType(constraint) || constraint
	if !tc.isTypeAssignableTo(propertyNameType, constraintOfConstraint) {
		return
	}
	return tc.substituteIndexedMappedType(type_, propertyNameType)
}

func (tc *TypeChecker) getTypeOfConcretePropertyOfContextualType(type_ Type, name __String) Type {
	prop := tc.getPropertyOfType(type_, name)
	if !prop || tc.isCircularMappedProperty(prop) {
		return
	}
	return tc.removeMissingType(tc.getTypeOfSymbol(prop), !!(prop.flags & SymbolFlagsOptional))
}

func (tc *TypeChecker) getTypeFromIndexInfosOfContextualType(type_ Type, name __String, nameType Type) Type {
	if tc.isTupleType(type_) && isNumericLiteralName(name) && +name >= 0 {
		restType := tc.getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength /*endSkipCount*/, 0 /*writing*/, false /*noReductions*/, true)
		if restType {
			return restType
		}
	}
	return tc.findApplicableIndexInfo(tc.getIndexInfosOfStructuredType(type_), nameType || tc.getStringLiteralType(unescapeLeadingUnderscores(name))). /* ? */ type_
}

// In an object literal contextually typed by a type T, the contextual type of a property assignment is the type of
// the matching property in T, if one exists. Otherwise, it is the type of the numeric index signature in T, if one
// exists. Otherwise, it is the type of the string index signature in T, if one exists.
func (tc *TypeChecker) getContextualTypeForObjectLiteralMethod(node MethodDeclaration, contextFlags *ContextFlags) Type {
	Debug.assert(isObjectLiteralMethod(node))
	if node.flags & NodeFlagsInWithStatement {
		// We cannot answer semantic questions within a with block, do not proceed any further
		return nil
	}
	return tc.getContextualTypeForObjectLiteralElement(node, contextFlags)
}

func (tc *TypeChecker) getContextualTypeForObjectLiteralElement(element ObjectLiteralElementLike, contextFlags *ContextFlags) Type {
	objectLiteral := element.parent /* as ObjectLiteralExpression */
	propertyAssignmentType := isPropertyAssignment(element) && tc.getContextualTypeForVariableLikeDeclaration(element, contextFlags)
	if propertyAssignmentType {
		return propertyAssignmentType
	}
	type_ := tc.getApparentTypeOfContextualType(objectLiteral, contextFlags)
	if type_ {
		if tc.hasBindableName(element) {
			// For a (non-symbol) computed property, there is no reason to look up the name
			// in the type. It will just be "__computed", which does not appear in any
			// SymbolTable.
			symbol := tc.getSymbolOfDeclaration(element)
			return tc.getTypeOfPropertyOfContextualType(type_, symbol.escapedName, tc.getSymbolLinks(symbol).nameType)
		}
		if hasDynamicName(element) {
			name := getNameOfDeclaration(element)
			if name && isComputedPropertyName(name) {
				exprType := tc.checkExpression(name.expression)
				propType := isTypeUsableAsPropertyName(exprType) && tc.getTypeOfPropertyOfContextualType(type_, getPropertyNameFromType(exprType))
				if propType {
					return propType
				}
			}
		}
		if element.name {
			nameType := tc.getLiteralTypeFromPropertyName(element.name)
			// We avoid calling getApplicableIndexInfo here because it performs potentially expensive intersection reduction.
			return tc.mapType(type_, func(t Type) Type {
				return tc.findApplicableIndexInfo(tc.getIndexInfosOfStructuredType(t), nameType). /* ? */ type_
			}, /*noReductions*/ true)
		}
	}
	return nil
}

func (tc *TypeChecker) getSpreadIndices(elements []Node) /* TODO(TS-TO-GO) inferred type { first: number | undefined; last: number | undefined; } */ any {
	var first TODO
	var last TODO
	for i := 0; i < elements.length; i++ {
		if isSpreadElement(elements[i]) {
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: first ??= i */ TODO
			last = i
		}
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"first": first,
		"last":  last,
	}
}

func (tc *TypeChecker) getContextualTypeForElementExpression(type_ Type, index number, length number, firstSpreadIndex number, lastSpreadIndex number) Type {
	return type_ && tc.mapType(type_, func(t Type) Type {
		if tc.isTupleType(t) {
			// If index is before any spread element and within the fixed part of the contextual tuple type, return
			// the type of the contextual tuple element.
			if (firstSpreadIndex == nil || index < firstSpreadIndex) && index < t.target.fixedLength {
				return tc.removeMissingType(tc.getTypeArguments(t)[index], !!(t.target.elementFlags[index] && ElementFlagsOptional))
			}
			// When the length is known and the index is after all spread elements we compute the offset from the element
			// to the end and the number of ending fixed elements in the contextual tuple type.
			var offset number
			if length != nil && (lastSpreadIndex == nil || index > lastSpreadIndex) {
				offset = length - index
			} else {
				offset = 0
			}
			var fixedEndLength number
			if offset > 0 && (t.target.combinedFlags & ElementFlagsVariable) {
				fixedEndLength = tc.getEndElementCount(t.target, ElementFlagsFixed)
			} else {
				fixedEndLength = 0
			}
			// If the offset is within the ending fixed part of the contextual tuple type, return the type of the contextual
			// tuple element.
			if offset > 0 && offset <= fixedEndLength {
				return tc.getTypeArguments(t)[tc.getTypeReferenceArity(t)-offset]
			}
			// Return a union of the possible contextual element types with no subtype reduction.
			return tc.getElementTypeOfSliceOfTupleType(t, __COND__(firstSpreadIndex == nil, t.target.fixedLength, Math.min(t.target.fixedLength, firstSpreadIndex)), __COND__(length == nil || lastSpreadIndex == nil, fixedEndLength, Math.min(fixedEndLength, length-lastSpreadIndex)) /*writing*/, false /*noReductions*/, true)
		}
		// If element index is known and a contextual property with that name exists, return it. Otherwise return the
		// iterated or element type of the contextual type.
		return (!firstSpreadIndex || index < firstSpreadIndex) && tc.getTypeOfPropertyOfContextualType(t, ""+index /* as __String */) || tc.getIteratedTypeOrElementType(IterationUseElement, t, tc.undefinedType /*errorNode*/, nil /*checkAssignability*/, false)
	}, /*noReductions*/ true)
}

// In a contextually typed conditional expression, the true/false expressions are contextually typed by the same type.
func (tc *TypeChecker) getContextualTypeForConditionalOperand(node Expression, contextFlags *ContextFlags) Type {
	conditional := node.parent /* as ConditionalExpression */
	if node == conditional.whenTrue || node == conditional.whenFalse {
		return tc.getContextualType(conditional, contextFlags)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getContextualTypeForChildJsxExpression(node JsxElement, child JsxChild, contextFlags *ContextFlags) Type {
	attributesType := tc.getApparentTypeOfContextualType(node.openingElement.attributes, contextFlags)
	// JSX expression is in children of JSX Element, we will look for an "children" attribute (we get the name from JSX.ElementAttributesProperty)
	jsxChildrenPropertyName := tc.getJsxElementChildrenPropertyName(tc.getJsxNamespaceAt(node))
	if !(attributesType && !tc.isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName != "") {
		return nil
	}
	realChildren := getSemanticJsxChildren(node.children)
	childIndex := realChildren.indexOf(child)
	childFieldType := tc.getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName)
	return childFieldType && (__COND__(realChildren.length == 1, childFieldType, tc.mapType(childFieldType, func(t Type) Type {
		if tc.isArrayLikeType(t) {
			return tc.getIndexedAccessType(t, tc.getNumberLiteralType(childIndex))
		} else {
			return t
		}
	}, /*noReductions*/ true)))
}

func (tc *TypeChecker) getContextualTypeForJsxExpression(node JsxExpression, contextFlags *ContextFlags) Type {
	exprParent := node.parent
	switch {
	case isJsxAttributeLike(exprParent):
		return tc.getContextualType(node, contextFlags)
	case isJsxElement(exprParent):
		return tc.getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)
	default:
		return nil
	}
}

func (tc *TypeChecker) getContextualTypeForJsxAttribute(attribute /* TODO(TS-TO-GO) TypeNode UnionType: JsxAttribute | JsxSpreadAttribute */ any, contextFlags *ContextFlags) Type {
	// When we trying to resolve JsxOpeningLikeElement as a stateless function element, we will already give its attributes a contextual type
	// which is a type of the parameter of the signature we are trying out.
	// If there is no contextual type (e.g. we are trying to resolve stateful component), get attributes type from resolving element's tagName
	if isJsxAttribute(attribute) {
		attributesType := tc.getApparentTypeOfContextualType(attribute.parent, contextFlags)
		if !attributesType || tc.isTypeAny(attributesType) {
			return nil
		}
		return tc.getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName(attribute.name))
	} else {
		return tc.getContextualType(attribute.parent, contextFlags)
	}
}

// Return true if the given expression is possibly a discriminant value. We limit the kinds of
// expressions we check to those that don't depend on their contextual type in order not to cause
// recursive (and possibly infinite) invocations of getContextualType.
func (tc *TypeChecker) isPossiblyDiscriminantValue(node Expression) bool {
	switch node.kind {
	case SyntaxKindStringLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindTemplateExpression,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindNullKeyword,
		SyntaxKindIdentifier,
		SyntaxKindUndefinedKeyword:
		return true
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindParenthesizedExpression:
		return tc.isPossiblyDiscriminantValue((node /* as PropertyAccessExpression | ParenthesizedExpression */).expression)
	case SyntaxKindJsxExpression:
		return !(node /* as JsxExpression */).expression || tc.isPossiblyDiscriminantValue((node /* as JsxExpression */).expression)
	}
	return false
}

func (tc *TypeChecker) discriminateContextualTypeByObjectMembers(node ObjectLiteralExpression, contextualType UnionType) Type {
	key := __TEMPLATE__("D", getNodeId(node), ",", tc.getTypeId(contextualType))
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getCachedType(key) ?? setCachedType( key, getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems( contextualType, concatenate( map( filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => { if (!p.symbol) { return false; } if (p.kind === SyntaxKind.PropertyAssignment) { return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName); } if (p.kind === SyntaxKind.ShorthandPropertyAssignment) { return isDiscriminantProperty(contextualType, p.symbol.escapedName); } return false; }), prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const), ), map( filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)), s => [() => undefinedType, s.escapedName] as const, ), ), isTypeAssignableTo, ), ) */ TODO
}

func (tc *TypeChecker) discriminateContextualTypeByJSXAttributes(node JsxAttributes, contextualType UnionType) Type {
	key := __TEMPLATE__("D", getNodeId(node), ",", tc.getTypeId(contextualType))
	cached := tc.getCachedType(key)
	if cached {
		return cached
	}
	jsxChildrenPropertyName := tc.getJsxElementChildrenPropertyName(tc.getJsxNamespaceAt(node))
	return tc.setCachedType(key, tc.discriminateTypeByDiscriminableItems(contextualType, concatenate(map_(filter(node.properties, func(p /* TODO(TS-TO-GO) inferred type JsxAttribute | JsxSpreadAttribute */ any) bool {
		return !!p.symbol && p.kind == SyntaxKindJsxAttribute && tc.isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || tc.isPossiblyDiscriminantValue(p.initializer))
	}), func(prop /* TODO(TS-TO-GO) inferred type JsxAttribute | JsxSpreadAttribute */ any) /* TODO(TS-TO-GO) inferred type [() => Type, __String] */ any {
		return ([]any{__COND__(!(prop /* as JsxAttribute */).initializer, (func() FreshableIntrinsicType {
			return tc.trueType
		}), (func() Type {
			return tc.getContextFreeTypeOfExpression((prop /* as JsxAttribute */).initializer)
		})), prop.symbol.escapedName} /* as const */)
	}), map_(filter(tc.getPropertiesOfType(contextualType), func(s Symbol) bool {
		if !(s.flags & SymbolFlagsOptional) || !node. /* ? */ symbol. /* ? */ members {
			return false
		}
		element := node.parent.parent
		if s.escapedName == jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length {
			return false
		}
		return !node.symbol.members.has(s.escapedName) && tc.isDiscriminantProperty(contextualType, s.escapedName)
	}), func(s Symbol) /* TODO(TS-TO-GO) inferred type [() => IntrinsicType, __String] */ any {
		return []any{func() IntrinsicType {
			return tc.undefinedType
		}, s.escapedName} /* as const */
	})), tc.isTypeAssignableTo))
}

// Return the contextual type for a given expression node. During overload resolution, a contextual type may temporarily
// be "pushed" onto a node using the contextualType property.
func (tc *TypeChecker) getApparentTypeOfContextualType(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration */ any, contextFlags *ContextFlags) Type {
	var contextualType Type
	if isObjectLiteralMethod(node) {
		contextualType = tc.getContextualTypeForObjectLiteralMethod(node, contextFlags)
	} else {
		contextualType = tc.getContextualType(node, contextFlags)
	}
	instantiatedType := tc.instantiateContextualType(contextualType, node, contextFlags)
	if instantiatedType && !(contextFlags && contextFlags&ContextFlagsNoConstraints && instantiatedType.flags&TypeFlagsTypeVariable) {
		apparentType := tc.mapType(instantiatedType, func(t Type) Type {
			if getObjectFlags(t) & ObjectFlagsMapped {
				return t
			} else {
				return tc.getApparentType(t)
			}
		}, true)
		switch {
		case apparentType.flags&TypeFlagsUnion && isObjectLiteralExpression(node):
			return tc.discriminateContextualTypeByObjectMembers(node, apparentType /* as UnionType */)
		case apparentType.flags&TypeFlagsUnion && isJsxAttributes(node):
			return tc.discriminateContextualTypeByJSXAttributes(node, apparentType /* as UnionType */)
		default:
			return apparentType
		}
	}
}

// If the given contextual type contains instantiable types and if a mapper representing
// return type inferences is available, instantiate those types using that mapper.
func (tc *TypeChecker) instantiateContextualType(contextualType Type, node Node, contextFlags *ContextFlags) Type {
	if contextualType && tc.maybeTypeOfKind(contextualType, TypeFlagsInstantiable) {
		inferenceContext := tc.getInferenceContext(node)
		// If no inferences have been made, and none of the type parameters for which we are inferring
		// specify default types, nothing is gained from instantiating as type parameters would just be
		// replaced with their constraints similar to the apparent type.
		if inferenceContext && contextFlags&ContextFlagsSignature && some(inferenceContext.inferences, tc.hasInferenceCandidatesOrDefault) {
			// For contextual signatures we incorporate all inferences made so far, e.g. from return
			// types as well as arguments to the left in a function call.
			return tc.instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper)
		}
		if inferenceContext. /* ? */ returnMapper {
			// For other purposes (e.g. determining whether to produce literal types) we only
			// incorporate inferences made from the return type in a function call. We remove
			// the 'boolean' type from the contextual type such that contextually typed boolean
			// literals actually end up widening to 'boolean' (see #48363).
			type_ := tc.instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper)
			if type_.flags&TypeFlagsUnion && tc.containsType((type_ /* as UnionType */).types, tc.regularFalseType) && tc.containsType((type_ /* as UnionType */).types, tc.regularTrueType) {
				return tc.filterType(type_, func(t Type) bool {
					return t != tc.regularFalseType && t != tc.regularTrueType
				})
			} else {
				return type_
			}
		}
	}
	return contextualType
}

// This function is similar to instantiateType, except that (a) it only instantiates types that
// are classified as instantiable (i.e. it doesn't instantiate object types), and (b) it performs
// no reductions on instantiated union types.
func (tc *TypeChecker) instantiateInstantiableTypes(type_ Type, mapper TypeMapper) Type {
	if type_.flags & TypeFlagsInstantiable {
		return tc.instantiateType(type_, mapper)
	}
	if type_.flags & TypeFlagsUnion {
		return tc.getUnionType(map_((type_ /* as UnionType */).types, func(t Type) Type {
			return tc.instantiateInstantiableTypes(t, mapper)
		}), UnionReductionNone)
	}
	if type_.flags & TypeFlagsIntersection {
		return tc.getIntersectionType(map_((type_ /* as IntersectionType */).types, func(t Type) Type {
			return tc.instantiateInstantiableTypes(t, mapper)
		}))
	}
	return type_
}

/**
 * Whoa! Do you really want to use this function?
 *
 * Unless you're trying to get the *non-apparent* type for a
 * value-literal type or you're authoring relevant portions of this algorithm,
 * you probably meant to use 'getApparentTypeOfContextualType'.
 * Otherwise this may not be very useful.
 *
 * In cases where you *are* working on this function, you should understand
 * when it is appropriate to use 'getContextualType' and 'getApparentTypeOfContextualType'.
 *
 *   - Use 'getContextualType' when you are simply going to propagate the result to the expression.
 *   - Use 'getApparentTypeOfContextualType' when you're going to need the members of the type.
 *
 * @param node the expression whose contextual type will be returned.
 * @returns the contextual type of an expression.
 */

func (tc *TypeChecker) getContextualType(node Expression, contextFlags *ContextFlags) Type {
	if node.flags & NodeFlagsInWithStatement {
		// We cannot answer semantic questions within a with block, do not proceed any further
		return nil
	}
	// Cached contextual types are obtained with no ContextFlags, so we can only consult them for
	// requests with no ContextFlags.
	index := tc.findContextualNode(node /*includeCaches*/, !contextFlags)
	if index >= 0 {
		return tc.contextualTypes[index]
	}
	TODO_IDENTIFIER := node
	switch parent.kind {
	case SyntaxKindVariableDeclaration,
		SyntaxKindParameter,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature,
		SyntaxKindBindingElement:
		return tc.getContextualTypeForInitializerExpression(node, contextFlags)
	case SyntaxKindArrowFunction,
		SyntaxKindReturnStatement:
		return tc.getContextualTypeForReturnExpression(node, contextFlags)
	case SyntaxKindYieldExpression:
		return tc.getContextualTypeForYieldOperand(parent /* as YieldExpression */, contextFlags)
	case SyntaxKindAwaitExpression:
		return tc.getContextualTypeForAwaitOperand(parent /* as AwaitExpression */, contextFlags)
	case SyntaxKindCallExpression,
		SyntaxKindNewExpression:
		return tc.getContextualTypeForArgument(parent /* as CallExpression | NewExpression | Decorator */, node)
	case SyntaxKindDecorator:
		return tc.getContextualTypeForDecorator(parent /* as Decorator */)
	case SyntaxKindTypeAssertionExpression,
		SyntaxKindAsExpression:
		if isConstTypeReference((parent /* as AssertionExpression */).type_) {
			return tc.getContextualType(parent /* as AssertionExpression */, contextFlags)
		} else {
			return tc.getTypeFromTypeNode((parent /* as AssertionExpression */).type_)
		}
	case SyntaxKindBinaryExpression:
		return tc.getContextualTypeForBinaryOperand(node, contextFlags)
	case SyntaxKindPropertyAssignment,
		SyntaxKindShorthandPropertyAssignment:
		return tc.getContextualTypeForObjectLiteralElement(parent /* as PropertyAssignment | ShorthandPropertyAssignment */, contextFlags)
	case SyntaxKindSpreadAssignment:
		return tc.getContextualType(parent.parent /* as ObjectLiteralExpression */, contextFlags)
	case SyntaxKindArrayLiteralExpression:
		arrayLiteral := parent /* as ArrayLiteralExpression */
		type_ := tc.getApparentTypeOfContextualType(arrayLiteral, contextFlags)
		elementIndex := indexOfNode(arrayLiteral.elements, node)
		spreadIndices := /* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements) */ TODO
		return tc.getContextualTypeForElementExpression(type_, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last)
		fallthrough
	case SyntaxKindConditionalExpression:
		return tc.getContextualTypeForConditionalOperand(node, contextFlags)
	case SyntaxKindTemplateSpan:
		Debug.assert(parent.parent.kind == SyntaxKindTemplateExpression)
		return tc.getContextualTypeForSubstitutionExpression(parent.parent /* as TemplateExpression */, node)
	case SyntaxKindParenthesizedExpression:
		if isInJSFile(parent) {
			if isJSDocSatisfiesExpression(parent) {
				return tc.getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent))
			}
			// Like in `checkParenthesizedExpression`, an `/** @type {xyz} */` comment before a parenthesized expression acts as a type cast.
			typeTag := getJSDocTypeTag(parent)
			if typeTag && !isConstTypeReference(typeTag.typeExpression.type_) {
				return tc.getTypeFromTypeNode(typeTag.typeExpression.type_)
			}
		}
		return tc.getContextualType(parent /* as ParenthesizedExpression */, contextFlags)
		fallthrough
	case SyntaxKindNonNullExpression:
		return tc.getContextualType(parent /* as NonNullExpression */, contextFlags)
	case SyntaxKindSatisfiesExpression:
		return tc.getTypeFromTypeNode((parent /* as SatisfiesExpression */).type_)
	case SyntaxKindExportAssignment:
		return tc.tryGetTypeFromEffectiveTypeNode(parent /* as ExportAssignment */)
	case SyntaxKindJsxExpression:
		return tc.getContextualTypeForJsxExpression(parent /* as JsxExpression */, contextFlags)
	case SyntaxKindJsxAttribute,
		SyntaxKindJsxSpreadAttribute:
		return tc.getContextualTypeForJsxAttribute(parent /* as JsxAttribute | JsxSpreadAttribute */, contextFlags)
	case SyntaxKindJsxOpeningElement,
		SyntaxKindJsxSelfClosingElement:
		return tc.getContextualJsxElementAttributesType(parent /* as JsxOpeningLikeElement */, contextFlags)
	case SyntaxKindImportAttribute:
		return tc.getContextualImportAttributeType(parent /* as ImportAttribute */)
	}
	return nil
}

func (tc *TypeChecker) pushCachedContextualType(node Expression) {
	tc.pushContextualType(node, tc.getContextualType(node /*contextFlags*/, nil) /*isCache*/, true)
}

func (tc *TypeChecker) pushContextualType(node Expression, type_ Type, isCache bool) {
	tc.contextualTypeNodes[tc.contextualTypeCount] = node
	tc.contextualTypes[tc.contextualTypeCount] = type_
	tc.contextualIsCache[tc.contextualTypeCount] = isCache
	tc.contextualTypeCount++
}

func (tc *TypeChecker) popContextualType() {
	tc.contextualTypeCount--
}

func (tc *TypeChecker) findContextualNode(node Node, includeCaches bool) number {
	for i := tc.contextualTypeCount - 1; i >= 0; i-- {
		if node == tc.contextualTypeNodes[i] && (includeCaches || !tc.contextualIsCache[i]) {
			return i
		}
	}
	return -1
}

func (tc *TypeChecker) pushInferenceContext(node Node, inferenceContext *InferenceContext) {
	tc.inferenceContextNodes[tc.inferenceContextCount] = node
	tc.inferenceContexts[tc.inferenceContextCount] = inferenceContext
	tc.inferenceContextCount++
}

func (tc *TypeChecker) popInferenceContext() {
	tc.inferenceContextCount--
}

func (tc *TypeChecker) getInferenceContext(node Node) *InferenceContext {
	for i := tc.inferenceContextCount - 1; i >= 0; i-- {
		if isNodeDescendantOf(node, tc.inferenceContextNodes[i]) {
			return tc.inferenceContexts[i]
		}
	}
}

func (tc *TypeChecker) getContextualImportAttributeType(node ImportAttribute) Type {
	return tc.getTypeOfPropertyOfContextualType(tc.getGlobalImportAttributesType(false), getNameFromImportAttribute(node))
}

func (tc *TypeChecker) getContextualJsxElementAttributesType(node JsxOpeningLikeElement, contextFlags *ContextFlags) Type {
	if isJsxOpeningElement(node) && contextFlags != ContextFlagsCompletions {
		index := tc.findContextualNode(node.parent /*includeCaches*/, !contextFlags)
		if index >= 0 {
			// Contextually applied type is moved from attributes up to the outer jsx attributes so when walking up from the children they get hit
			// _However_ to hit them from the _attributes_ we must look for them here; otherwise we'll used the declared type
			// (as below) instead!
			return tc.contextualTypes[index]
		}
	}
	return tc.getContextualTypeForArgumentAtIndex(node, 0)
}

func (tc *TypeChecker) getEffectiveFirstArgumentForJsxSignature(signature Signature, node JsxOpeningLikeElement) Type {
	if tc.getJsxReferenceKind(node) != JsxReferenceKindComponent {
		return tc.getJsxPropsTypeFromCallSignature(signature, node)
	} else {
		return tc.getJsxPropsTypeFromClassType(signature, node)
	}
}

func (tc *TypeChecker) getJsxPropsTypeFromCallSignature(sig Signature, context JsxOpeningLikeElement) Type {
	propsType := tc.getTypeOfFirstParameterOfSignatureWithFallback(sig, tc.unknownType)
	propsType = tc.getJsxManagedAttributesFromLocatedAttributes(context, tc.getJsxNamespaceAt(context), propsType)
	intrinsicAttribs := tc.getJsxType(JsxNames.IntrinsicAttributes, context)
	if !tc.isErrorType(intrinsicAttribs) {
		propsType = tc.intersectTypes(intrinsicAttribs, propsType)
	}
	return propsType
}

func (tc *TypeChecker) getJsxPropsTypeForSignatureFromMember(sig Signature, forcedLookupLocation __String) Type {
	if sig.compositeSignatures {
		// JSX Elements using the legacy `props`-field based lookup (eg, react class components) need to treat the `props` member as an input
		// instead of an output position when resolving the signature. We need to go back to the input signatures of the composite signature,
		// get the type of `props` on each return type individually, and then _intersect them_, rather than union them (as would normally occur
		// for a union signature). It's an unfortunate quirk of looking in the output of the signature for the type we want to use for the input.
		// The default behavior of `getTypeOfFirstParameterOfSignatureWithFallback` when no `props` member name is defined is much more sane.
		var results []Type = []never{}
		for _, signature := range sig.compositeSignatures {
			instance := tc.getReturnTypeOfSignature(signature)
			if tc.isTypeAny(instance) {
				return instance
			}
			propType := tc.getTypeOfPropertyOfType(instance, forcedLookupLocation)
			if !propType {
				return
			}
			results.push(propType)
		}
		return tc.getIntersectionType(results)
		// Same result for both union and intersection signatures
	}
	instanceType := tc.getReturnTypeOfSignature(sig)
	if tc.isTypeAny(instanceType) {
		return instanceType
	} else {
		return tc.getTypeOfPropertyOfType(instanceType, forcedLookupLocation)
	}
}

func (tc *TypeChecker) getStaticTypeOfReferencedJsxConstructor(context JsxOpeningLikeElement) Type {
	if tc.isJsxIntrinsicTagName(context.tagName) {
		result := tc.getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context)
		fakeSignature := tc.createSignatureForJSXIntrinsic(context, result)
		return tc.getOrCreateTypeFromSignature(fakeSignature)
	}
	tagType := tc.checkExpressionCached(context.tagName)
	if tagType.flags & TypeFlagsStringLiteral {
		result := tc.getIntrinsicAttributesTypeFromStringLiteralType(tagType /* as StringLiteralType */, context)
		if !result {
			return tc.errorType
		}
		fakeSignature := tc.createSignatureForJSXIntrinsic(context, result)
		return tc.getOrCreateTypeFromSignature(fakeSignature)
	}
	return tagType
}

func (tc *TypeChecker) getJsxManagedAttributesFromLocatedAttributes(context JsxOpeningLikeElement, ns Symbol, attributesType Type) Type {
	managedSym := tc.getJsxLibraryManagedAttributes(ns)
	if managedSym {
		ctorType := tc.getStaticTypeOfReferencedJsxConstructor(context)
		result := tc.instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType)
		if result {
			return result
		}
	}
	return attributesType
}

func (tc *TypeChecker) getJsxPropsTypeFromClassType(sig Signature, context JsxOpeningLikeElement) Type {
	ns := tc.getJsxNamespaceAt(context)
	forcedLookupLocation := tc.getJsxElementPropertiesName(ns)
	var attributesType Type
	switch {
	case forcedLookupLocation == nil:
		attributesType = tc.getTypeOfFirstParameterOfSignatureWithFallback(sig, tc.unknownType)
	case forcedLookupLocation == "":
		attributesType = tc.getReturnTypeOfSignature(sig)
	default:
		attributesType = tc.getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation)
	}

	if !attributesType {
		// There is no property named 'props' on this instance type
		if !!forcedLookupLocation && !!length(context.attributes.properties) {
			tc.error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation))
		}
		return tc.unknownType
	}

	attributesType = tc.getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType)

	if tc.isTypeAny(attributesType) {
		// Props is of type 'any' or unknown
		return attributesType
	} else {
		// Normal case -- add in IntrinsicClassElements<T> and IntrinsicElements
		apparentAttributesType := attributesType
		intrinsicClassAttribs := tc.getJsxType(JsxNames.IntrinsicClassAttributes, context)
		if !tc.isErrorType(intrinsicClassAttribs) {
			typeParams := tc.getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol)
			hostClassType := tc.getReturnTypeOfSignature(sig)
			var libraryManagedAttributeType Type
			if typeParams {
				// apply JSX.IntrinsicClassElements<hostClassType, ...>
				inferredArgs := tc.fillMissingTypeArguments([]Type{hostClassType}, typeParams, tc.getMinTypeArgumentCount(typeParams), isInJSFile(context))
				libraryManagedAttributeType = tc.instantiateType(intrinsicClassAttribs, tc.createTypeMapper(typeParams, inferredArgs))
			} else {
				libraryManagedAttributeType = intrinsicClassAttribs
			}
			apparentAttributesType = tc.intersectTypes(libraryManagedAttributeType, apparentAttributesType)
		}

		intrinsicAttribs := tc.getJsxType(JsxNames.IntrinsicAttributes, context)
		if !tc.isErrorType(intrinsicAttribs) {
			apparentAttributesType = tc.intersectTypes(intrinsicAttribs, apparentAttributesType)
		}

		return apparentAttributesType
	}
}

func (tc *TypeChecker) getIntersectedSignatures(signatures []Signature) *Signature {
	if getStrictOptionValue(tc.compilerOptions, "noImplicitAny") {
		return reduceLeft(signatures, func(left *Signature, right *Signature) *Signature {
			switch {
			case left == right || !left:
				return left
			case tc.compareTypeParametersIdentical(left.typeParameters, right.typeParameters):
				return tc.combineSignaturesOfIntersectionMembers(left, right)
			default:
				return nil
			}
		})
	} else {
		return nil
	}
}

func (tc *TypeChecker) combineIntersectionThisParam(left Symbol, right Symbol, mapper *TypeMapper) Symbol {
	if !left || !right {
		return left || right
	}
	// A signature `this` type might be a read or a write position... It's very possible that it should be invariant
	// and we should refuse to merge signatures if there are `this` types and they do not match. However, so as to be
	// pessimistic when contextual typing, for now, we'll union the `this` types.
	thisType := tc.getUnionType([]Type{tc.getTypeOfSymbol(left), tc.instantiateType(tc.getTypeOfSymbol(right), mapper)})
	return tc.createSymbolWithType(left, thisType)
}

func (tc *TypeChecker) combineIntersectionParameters(left Signature, right Signature, mapper *TypeMapper) []Symbol {
	leftCount := tc.getParameterCount(left)
	rightCount := tc.getParameterCount(right)
	var longest Signature
	if leftCount >= rightCount {
		longest = left
	} else {
		longest = right
	}
	var shorter Signature
	if longest == left {
		shorter = right
	} else {
		shorter = left
	}
	var longestCount number
	if longest == left {
		longestCount = leftCount
	} else {
		longestCount = rightCount
	}
	eitherHasEffectiveRest := tc.hasEffectiveRestParameter(left) || tc.hasEffectiveRestParameter(right)
	needsExtraRestElement := eitherHasEffectiveRest && !tc.hasEffectiveRestParameter(longest)
	params := NewArray[Symbol](longestCount + (__COND__(needsExtraRestElement, 1, 0)))
	for i := 0; i < longestCount; i++ {
		longestParamType := tc.tryGetTypeAtPosition(longest, i)
		if longest == right {
			longestParamType = tc.instantiateType(longestParamType, mapper)
		}
		shorterParamType := tc.tryGetTypeAtPosition(shorter, i) || tc.unknownType
		if shorter == right {
			shorterParamType = tc.instantiateType(shorterParamType, mapper)
		}
		unionParamType := tc.getUnionType([]Type{longestParamType, shorterParamType})
		isRestParam := eitherHasEffectiveRest && !needsExtraRestElement && i == (longestCount-1)
		isOptional := i >= tc.getMinArgumentCount(longest) && i >= tc.getMinArgumentCount(shorter)
		var leftName *__String
		if i >= leftCount {
			leftName = nil
		} else {
			leftName = tc.getParameterNameAtPosition(left, i)
		}
		var rightName *__String
		if i >= rightCount {
			rightName = nil
		} else {
			rightName = tc.getParameterNameAtPosition(right, i)
		}

		var paramName *__String
		switch {
		case leftName == rightName:
			paramName = leftName
		case !leftName:
			paramName = rightName
		case !rightName:
			paramName = leftName
		default:
			paramName = nil
		}
		paramSymbol := tc.createSymbol(SymbolFlagsFunctionScopedVariable|(__COND__(isOptional && !isRestParam, SymbolFlagsOptional, 0)), paramName || __TEMPLATE__("arg", i) /* as __String */)
		if isRestParam {
			paramSymbol.links.type_ = tc.createArrayType(unionParamType)
		} else {
			paramSymbol.links.type_ = unionParamType
		}
		params[i] = paramSymbol
	}
	if needsExtraRestElement {
		restParamSymbol := tc.createSymbol(SymbolFlagsFunctionScopedVariable, "args" /* as __String */)
		restParamSymbol.links.type_ = tc.createArrayType(tc.getTypeAtPosition(shorter, longestCount))
		if shorter == right {
			restParamSymbol.links.type_ = tc.instantiateType(restParamSymbol.links.type_, mapper)
		}
		params[longestCount] = restParamSymbol
	}
	return params
}

func (tc *TypeChecker) combineSignaturesOfIntersectionMembers(left Signature, right Signature) Signature {
	typeParams := left.typeParameters || right.typeParameters
	var paramMapper *TypeMapper
	if left.typeParameters && right.typeParameters {
		paramMapper = tc.createTypeMapper(right.typeParameters, left.typeParameters)
		// We just use the type parameter defaults from the first signature
	}
	declaration := left.declaration
	params := tc.combineIntersectionParameters(left, right, paramMapper)
	thisParam := tc.combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper)
	minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
	result := tc.createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
	result.compositeKind = TypeFlagsIntersection
	result.compositeSignatures = concatenate(left.compositeKind == TypeFlagsIntersection && left.compositeSignatures || []Signature{left}, []Signature{right})
	if paramMapper {
		if left.compositeKind == TypeFlagsIntersection && left.mapper && left.compositeSignatures {
			result.mapper = tc.combineTypeMappers(left.mapper, paramMapper)
		} else {
			result.mapper = paramMapper
		}
	}
	return result
}

// If the given type is an object or union type with a single signature, and if that signature has at
// least as many parameters as the given function, return the signature. Otherwise return undefined.
func (tc *TypeChecker) getContextualCallSignature(type_ Type, node SignatureDeclaration) *Signature {
	signatures := tc.getSignaturesOfType(type_, SignatureKindCall)
	applicableByArity := filter(signatures, func(s Signature) bool {
		return !tc.isAritySmaller(s, node)
	})
	if applicableByArity.length == 1 {
		return applicableByArity[0]
	} else {
		return tc.getIntersectedSignatures(applicableByArity)
	}
}

/** If the contextual signature has fewer parameters than the function expression, do not use it */

func (tc *TypeChecker) isAritySmaller(signature Signature, target SignatureDeclaration) bool {
	targetParameterCount := 0
	for ; targetParameterCount < target.parameters.length; targetParameterCount++ {
		param := target.parameters[targetParameterCount]
		if param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param) {
			break
		}
	}
	if target.parameters.length && parameterIsThisKeyword(target.parameters[0]) {
		targetParameterCount--
	}
	return !tc.hasEffectiveRestParameter(signature) && tc.getParameterCount(signature) < targetParameterCount
}

func (tc *TypeChecker) getContextualSignatureForFunctionLikeDeclaration(node FunctionLikeDeclaration) *Signature {
	// Only function expressions, arrow functions, and object literal methods are contextually typed.
	if isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node) {
		return tc.getContextualSignature(node /* as FunctionExpression */)
	} else {
		return nil
	}
}

// Return the contextual signature for a given expression node. A contextual type provides a
// contextual signature if it has a single call signature and if that call signature is non-generic.
// If the contextual type is a union type, get the signature from each type possible and if they are
// all identical ignoring their return type, the result is same signature but with return type as
// union type of return types from these signatures
func (tc *TypeChecker) getContextualSignature(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionExpression | ArrowFunction | MethodDeclaration */ any) *Signature {
	Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
	typeTagSignature := tc.getSignatureOfTypeTag(node)
	if typeTagSignature {
		return typeTagSignature
	}
	type_ := tc.getApparentTypeOfContextualType(node, ContextFlagsSignature)
	if !type_ {
		return nil
	}
	if !(type_.flags & TypeFlagsUnion) {
		return tc.getContextualCallSignature(type_, node)
	}
	var signatureList *[]Signature
	types := (type_ /* as UnionType */).types
	for _, current := range types {
		signature := tc.getContextualCallSignature(current, node)
		if signature {
			if !signatureList {
				// This signature will contribute to contextual union signature
				signatureList = []Signature{signature}
			} else if !tc.compareSignaturesIdentical(signatureList[0], signature /*partialMatch*/, false /*ignoreThisTypes*/, true /*ignoreReturnTypes*/, true, tc.compareTypesIdentical) {
				// Signatures aren't identical, do not use
				return nil
			} else {
				// Use this signature for contextual union signature
				signatureList.push(signature)
			}
		}
	}
	// Result is union of signatures collected (return type is union of return types of this signature set)
	if signatureList {
		if signatureList.length == 1 {
			return signatureList[0]
		} else {
			return tc.createUnionSignature(signatureList[0], signatureList)
		}
	}
}

func (tc *TypeChecker) checkGrammarRegularExpressionLiteral(node RegularExpressionLiteral) bool {
	sourceFile := getSourceFileOfNode(node)
	if !tc.hasParseDiagnostics(sourceFile) && !node.isUnterminated {
		var lastError *DiagnosticWithLocation
		/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia* / true) */ TODO
		tc.scanner.setScriptTarget(sourceFile.languageVersion)
		tc.scanner.setLanguageVariant(sourceFile.languageVariant)
		tc.scanner.setOnError(func(message DiagnosticMessage, length number, arg0 any) {
			// For providing spelling suggestions
			start := tc.scanner.getTokenEnd()
			if message.category == DiagnosticCategoryMessage && lastError && start == lastError.start && length == lastError.length {
				error := createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0)
				addRelatedInfo(lastError, error)
			} else if !lastError || start != lastError.start {
				lastError = createFileDiagnostic(sourceFile, start, length, message, arg0)
				tc.diagnostics.add(lastError)
			}
		})
		tc.scanner.setText(sourceFile.text, node.pos, node.end-node.pos)
		{ // try
			tc.scanner.scan()
			Debug.assert(tc.scanner.reScanSlashToken(true) == SyntaxKindRegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral")
			return !!lastError
		}
		{ // finally
			tc.scanner.setText("")
			tc.scanner.setOnError(nil)
		}
	}
	return false
}

func (tc *TypeChecker) checkRegularExpressionLiteral(node RegularExpressionLiteral) ObjectType {
	nodeLinks := tc.getNodeLinks(node)
	if !(nodeLinks.flags & NodeCheckFlagsTypeChecked) {
		nodeLinks.flags |= NodeCheckFlagsTypeChecked
		tc.addLazyDiagnostic(func() bool {
			return tc.checkGrammarRegularExpressionLiteral(node)
		})
	}
	return tc.globalRegExpType
}

func (tc *TypeChecker) checkSpreadExpression(node SpreadElement, checkMode CheckMode) Type {
	if tc.languageVersion < LanguageFeatureMinimumTargetSpreadElements {
		tc.checkExternalEmitHelpers(node, __COND__(tc.compilerOptions.downlevelIteration, ExternalEmitHelpersSpreadIncludes, ExternalEmitHelpersSpreadArray))
	}

	arrayOrIterableType := tc.checkExpression(node.expression, checkMode)
	return tc.checkIteratedTypeOrElementType(IterationUseSpread, arrayOrIterableType, tc.undefinedType, node.expression)
}

func (tc *TypeChecker) checkSyntheticExpression(node SyntheticExpression) Type {
	if node.isSpread {
		return tc.getIndexedAccessType(node.type_, tc.numberType)
	} else {
		return node.type_
	}
}

func (tc *TypeChecker) hasDefaultValue(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | ObjectLiteralElementLike | Expression */ any) bool {
	return node.kind == SyntaxKindBindingElement && !!(node /* as BindingElement */).initializer || node.kind == SyntaxKindPropertyAssignment && tc.hasDefaultValue((node /* as PropertyAssignment */).initializer) || node.kind == SyntaxKindShorthandPropertyAssignment && !!(node /* as ShorthandPropertyAssignment */).objectAssignmentInitializer || node.kind == SyntaxKindBinaryExpression && (node /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken
}

func (tc *TypeChecker) isSpreadIntoCallOrNew(node ArrayLiteralExpression) bool {
	parent := walkUpParenthesizedExpressions(node.parent)
	return isSpreadElement(parent) && isCallOrNewExpression(parent.parent)
}

func (tc *TypeChecker) checkArrayLiteral(node ArrayLiteralExpression, checkMode *CheckMode, forceTuple *bool) Type {
	elements := node.elements
	elementCount := elements.length
	var elementTypes []Type = []never{}
	var elementFlags []ElementFlags = []never{}
	tc.pushCachedContextualType(node)
	inDestructuringPattern := isAssignmentTarget(node)
	inConstContext := tc.isConstContext(node)
	contextualType := tc.getApparentTypeOfContextualType(node /*contextFlags*/, nil)
	inTupleContext := tc.isSpreadIntoCallOrNew(node) || !!contextualType && tc.someType(contextualType, func(t Type) bool {
		return tc.isTupleLikeType(t) || tc.isGenericMappedType(t) && !t.nameType && !!tc.getHomomorphicTypeVariable(t.target /* as MappedType */ || t)
	})

	hasOmittedExpression := false
	for i := 0; i < elementCount; i++ {
		e := elements[i]
		if e.kind == SyntaxKindSpreadElement {
			if tc.languageVersion < LanguageFeatureMinimumTargetSpreadElements {
				tc.checkExternalEmitHelpers(e, __COND__(tc.compilerOptions.downlevelIteration, ExternalEmitHelpersSpreadIncludes, ExternalEmitHelpersSpreadArray))
			}
			spreadType := tc.checkExpression((e /* as SpreadElement */).expression, checkMode, forceTuple)
			if tc.isArrayLikeType(spreadType) {
				elementTypes.push(spreadType)
				elementFlags.push(ElementFlagsVariadic)
			} else if inDestructuringPattern {
				// Given the following situation:
				//    var c: {};
				//    [...c] = ["", 0];
				//
				// c is represented in the tree as a spread element in an array literal.
				// But c really functions as a rest element, and its purpose is to provide
				// a contextual type for the right hand side of the assignment. Therefore,
				// instead of calling checkExpression on "...c", which will give an error
				// if c is not iterable/array-like, we need to act as if we are trying to
				// get the contextual element type from it. So we do something similar to
				// getContextualTypeForElementExpression, which will crucially not error
				// if there is no index type / iterated type.
				restElementType := tc.getIndexTypeOfType(spreadType, tc.numberType) || tc.getIteratedTypeOrElementType(IterationUseDestructuring, spreadType, tc.undefinedType /*errorNode*/, nil /*checkAssignability*/, false) || tc.unknownType
				elementTypes.push(restElementType)
				elementFlags.push(ElementFlagsRest)
			} else {
				elementTypes.push(tc.checkIteratedTypeOrElementType(IterationUseSpread, spreadType, tc.undefinedType, (e /* as SpreadElement */).expression))
				elementFlags.push(ElementFlagsRest)
			}
		} else if tc.exactOptionalPropertyTypes && e.kind == SyntaxKindOmittedExpression {
			hasOmittedExpression = true
			elementTypes.push(tc.undefinedOrMissingType)
			elementFlags.push(ElementFlagsOptional)
		} else {
			type_ := tc.checkExpressionForMutableLocation(e, checkMode, forceTuple)
			elementTypes.push(tc.addOptionality(type_ /*isProperty*/, true, hasOmittedExpression))
			elementFlags.push(__COND__(hasOmittedExpression, ElementFlagsOptional, ElementFlagsRequired))
			if inTupleContext && checkMode && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && tc.isContextSensitive(e) {
				inferenceContext := tc.getInferenceContext(node)
				Debug.assert(inferenceContext)
				// In CheckMode.Inferential we should always have an inference context
				tc.addIntraExpressionInferenceSite(inferenceContext, e, type_)
			}
		}
	}
	tc.popContextualType()
	if inDestructuringPattern {
		return tc.createTupleType(elementTypes, elementFlags)
	}
	if forceTuple || inConstContext || inTupleContext {
		return tc.createArrayLiteralType(tc.createTupleType(elementTypes, elementFlags /*readonly*/, inConstContext && !(contextualType && tc.someType(contextualType, tc.isMutableArrayLikeType))))
	}
	return tc.createArrayLiteralType(tc.createArrayType(__COND__(elementTypes.length, tc.getUnionType(sameMap(elementTypes, func(t Type, i number) Type {
		if elementFlags[i] & ElementFlagsVariadic {
			return tc.getIndexedAccessTypeOrUndefined(t, tc.numberType) || tc.anyType
		} else {
			return t
		}
	}), UnionReductionSubtype), __COND__(tc.strictNullChecks, tc.implicitNeverType, tc.undefinedWideningType)), inConstContext))
}

func (tc *TypeChecker) createArrayLiteralType(type_ Type) Type {
	if !(getObjectFlags(type_) & ObjectFlagsReference) {
		return type_
	}
	literalType := (type_ /* as TypeReference */).literalType
	if !literalType {
		literalType = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: (type as TypeReference).literalType = cloneTypeReference(type as TypeReference) */ TODO
		literalType.objectFlags |= ObjectFlagsArrayLiteral | ObjectFlagsContainsObjectOrArrayLiteral
	}
	return literalType
}

func (tc *TypeChecker) isNumericName(name DeclarationName) bool {
	switch name.kind {
	case SyntaxKindComputedPropertyName:
		return tc.isNumericComputedName(name)
	case SyntaxKindIdentifier:
		return isNumericLiteralName(name.escapedText)
	case SyntaxKindNumericLiteral,
		SyntaxKindStringLiteral:
		return isNumericLiteralName(name.text)
	default:
		return false
	}
}

func (tc *TypeChecker) isNumericComputedName(name ComputedPropertyName) bool {
	// It seems odd to consider an expression of type Any to result in a numeric name,
	// but this behavior is consistent with checkIndexedAccess
	return tc.isTypeAssignableToKind(tc.checkComputedPropertyName(name), TypeFlagsNumberLike)
}

func (tc *TypeChecker) checkComputedPropertyName(node ComputedPropertyName) Type {
	links := tc.getNodeLinks(node.expression)
	if !links.resolvedType {
		if (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent)) && isBinaryExpression(node.expression) && node.expression.operatorToken.kind == SyntaxKindInKeyword && node.parent.kind != SyntaxKindGetAccessor && node.parent.kind != SyntaxKindSetAccessor {
			links.resolvedType = tc.errorType
			return links.resolvedType
		}
		links.resolvedType = tc.checkExpression(node.expression)
		// The computed property name of a non-static class field within a loop must be stored in a block-scoped binding.
		// (It needs to be bound at class evaluation time.)
		if isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent) {
			container := getEnclosingBlockScopeContainer(node.parent.parent)
			enclosingIterationStatement := tc.getEnclosingIterationStatement(container)
			if enclosingIterationStatement {
				// The computed field name will use a block scoped binding which can be unique for each iteration of the loop.
				tc.getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
				// The generated variable which stores the computed field name must be block-scoped.
				tc.getNodeLinks(node).flags |= NodeCheckFlagsBlockScopedBindingInLoop
				// The generated variable which stores the class must be block-scoped.
				tc.getNodeLinks(node.parent.parent).flags |= NodeCheckFlagsBlockScopedBindingInLoop
			}
		}
		// This will allow types number, string, symbol or any. It will also allow enums, the unknown
		// type, and any union of these types (like string | number).
		if links.resolvedType.flags&TypeFlagsNullable || !tc.isTypeAssignableToKind(links.resolvedType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) && !tc.isTypeAssignableTo(links.resolvedType, tc.stringNumberSymbolType) {
			tc.error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any)
		}
	}

	return links.resolvedType
}

func (tc *TypeChecker) isSymbolWithNumericName(symbol Symbol) *bool {
	firstDecl := symbol.declarations[0]
	return isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(firstDecl) && tc.isNumericName(firstDecl.name))
}

func (tc *TypeChecker) isSymbolWithSymbolName(symbol Symbol) *bool {
	firstDecl := symbol.declarations[0]
	return isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) && tc.isTypeAssignableToKind(tc.checkComputedPropertyName(firstDecl.name), TypeFlagsESSymbol))
}

func (tc *TypeChecker) getObjectLiteralIndexInfo(node ObjectLiteralExpression, offset number, properties []Symbol, keyType Type) IndexInfo {
	var propTypes []Type = []never{}
	for i := offset; i < properties.length; i++ {
		prop := properties[i]
		if keyType == tc.stringType && !tc.isSymbolWithSymbolName(prop) || keyType == tc.numberType && tc.isSymbolWithNumericName(prop) || keyType == tc.esSymbolType && tc.isSymbolWithSymbolName(prop) {
			propTypes.push(tc.getTypeOfSymbol(properties[i]))
		}
	}
	var unionType Type
	if propTypes.length {
		unionType = tc.getUnionType(propTypes, UnionReductionSubtype)
	} else {
		unionType = tc.undefinedType
	}
	return tc.createIndexInfo(keyType, unionType, tc.isConstContext(node))
}

func (tc *TypeChecker) getImmediateAliasedSymbol(symbol Symbol) Symbol {
	Debug.assert((symbol.flags&SymbolFlagsAlias) != 0, "Should only get Alias here.")
	links := tc.getSymbolLinks(symbol)
	if !links.immediateTarget {
		node := tc.getDeclarationOfAliasSymbol(symbol)
		if !node {
			return Debug.fail()
		}
		links.immediateTarget = tc.getTargetOfAliasDeclaration(node /*dontRecursivelyResolve*/, true)
	}

	return links.immediateTarget
}

func (tc *TypeChecker) checkObjectLiteral(node ObjectLiteralExpression, checkMode CheckMode /*  = CheckMode.Normal */) Type {
	inDestructuringPattern := isAssignmentTarget(node)
	// Grammar checking
	tc.checkGrammarObjectLiteralExpression(node, inDestructuringPattern)

	var allPropertiesTable *SymbolTable
	if tc.strictNullChecks {
		allPropertiesTable = createSymbolTable()
	} else {
		allPropertiesTable = nil
	}
	propertiesTable := createSymbolTable()
	var propertiesArray []Symbol = []never{}
	var spread Type = tc.emptyObjectType

	tc.pushCachedContextualType(node)
	contextualType := tc.getApparentTypeOfContextualType(node /*contextFlags*/, nil)
	contextualTypeHasPattern := contextualType && contextualType.pattern && (contextualType.pattern.kind == SyntaxKindObjectBindingPattern || contextualType.pattern.kind == SyntaxKindObjectLiteralExpression)
	inConstContext := tc.isConstContext(node)
	var checkFlags /* TODO(TS-TO-GO) inferred type 0 | CheckFlags.Readonly */ any
	if inConstContext {
		checkFlags = CheckFlagsReadonly
	} else {
		checkFlags = 0
	}
	isInJavascript := isInJSFile(node) && !isInJsonFile(node)
	var enumTag *JSDocEnumTag
	if isInJavascript {
		enumTag = getJSDocEnumTag(node)
	} else {
		enumTag = nil
	}
	isJSObjectLiteral := !contextualType && isInJavascript && !enumTag
	var objectFlags ObjectFlags = ObjectFlagsFreshLiteral
	patternWithComputedProperties := false
	hasComputedStringProperty := false
	hasComputedNumberProperty := false
	hasComputedSymbolProperty := false

	// Spreads may cause an early bail; ensure computed names are always checked (this is cached)
	// As otherwise they may not be checked until exports for the type at this position are retrieved,
	// which may never occur.
	for _, elem := range node.properties {
		if elem.name && isComputedPropertyName(elem.name) {
			tc.checkComputedPropertyName(elem.name)
		}
	}

	offset := 0
	for _, memberDecl := range node.properties {
		member := tc.getSymbolOfDeclaration(memberDecl)
		var computedNameType Type
		if memberDecl.name && memberDecl.name.kind == SyntaxKindComputedPropertyName {
			computedNameType = tc.checkComputedPropertyName(memberDecl.name)
		} else {
			computedNameType = nil
		}
		if memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindShorthandPropertyAssignment || isObjectLiteralMethod(memberDecl) {
			var type_ Type
			switch {
			case memberDecl.kind == SyntaxKindPropertyAssignment:
				type_ = tc.checkPropertyAssignment(memberDecl, checkMode)
			case memberDecl.kind == SyntaxKindShorthandPropertyAssignment:
				type_ = tc.checkExpressionForMutableLocation(__COND__(!inDestructuringPattern && memberDecl.objectAssignmentInitializer, memberDecl.objectAssignmentInitializer, memberDecl.name), checkMode)
			default:
				type_ = tc.checkObjectLiteralMethod(memberDecl, checkMode)
			}
			if isInJavascript {
				jsDocType := tc.getTypeForDeclarationFromJSDocComment(memberDecl)
				if jsDocType {
					tc.checkTypeAssignableTo(type_, jsDocType, memberDecl)
					type_ = jsDocType
				} else if enumTag && enumTag.typeExpression {
					tc.checkTypeAssignableTo(type_, tc.getTypeFromTypeNode(enumTag.typeExpression), memberDecl)
				}
			}
			objectFlags |= getObjectFlags(type_) & ObjectFlagsPropagatingFlags
			var nameType * /* TODO(TS-TO-GO) inferred type StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any
			if computedNameType && isTypeUsableAsPropertyName(computedNameType) {
				nameType = computedNameType
			} else {
				nameType = nil
			}
			var prop TransientSymbol
			if nameType {
				prop = tc.createSymbol(SymbolFlagsProperty|member.flags, getPropertyNameFromType(nameType), checkFlags|CheckFlagsLate)
			} else {
				prop = tc.createSymbol(SymbolFlagsProperty|member.flags, member.escapedName, checkFlags)
			}
			if nameType {
				prop.links.nameType = nameType
			}

			if inDestructuringPattern && tc.hasDefaultValue(memberDecl) {
				// If object literal is an assignment pattern and if the assignment pattern specifies a default value
				// for the property, make the property optional.
				prop.flags |= SymbolFlagsOptional
			} else if contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlagsObjectLiteralPatternWithComputedProperties) {
				// If object literal is contextually typed by the implied type of a binding pattern, and if the
				// binding pattern specifies a default value for the property, make the property optional.
				impliedProp := tc.getPropertyOfType(contextualType, member.escapedName)
				if impliedProp {
					prop.flags |= impliedProp.flags & SymbolFlagsOptional
				} else if !tc.getIndexInfoOfType(contextualType, tc.stringType) {
					tc.error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, tc.symbolToString(member), tc.typeToString(contextualType))
				}
			}

			prop.declarations = member.declarations
			prop.parent = member.parent
			if member.valueDeclaration {
				prop.valueDeclaration = member.valueDeclaration
			}

			prop.links.type_ = type_
			prop.links.target = member
			member = prop
			allPropertiesTable. /* ? */ set(prop.escapedName, prop)

			if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && (memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindMethodDeclaration) && tc.isContextSensitive(memberDecl) {
				inferenceContext := tc.getInferenceContext(node)
				Debug.assert(inferenceContext)
				// In CheckMode.Inferential we should always have an inference context
				var inferenceNode /* TODO(TS-TO-GO) inferred type Expression | MethodDeclaration */ any
				if memberDecl.kind == SyntaxKindPropertyAssignment {
					inferenceNode = memberDecl.initializer
				} else {
					inferenceNode = memberDecl
				}
				tc.addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type_)
			}
		} else if memberDecl.kind == SyntaxKindSpreadAssignment {
			if tc.languageVersion < LanguageFeatureMinimumTargetObjectAssign {
				tc.checkExternalEmitHelpers(memberDecl, ExternalEmitHelpersAssign)
			}
			if propertiesArray.length > 0 {
				spread = tc.getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
				propertiesArray = []never{}
				propertiesTable = createSymbolTable()
				hasComputedStringProperty = false
				hasComputedNumberProperty = false
				hasComputedSymbolProperty = false
			}
			type_ := tc.getReducedType(tc.checkExpression(memberDecl.expression, checkMode&CheckModeInferential))
			if tc.isValidSpreadType(type_) {
				mergedType := tc.tryMergeUnionOfObjectTypeAndEmptyObject(type_, inConstContext)
				if allPropertiesTable {
					tc.checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl)
				}
				offset = propertiesArray.length
				if tc.isErrorType(spread) {
					continue
				}
				spread = tc.getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext)
			} else {
				tc.error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types)
				spread = tc.errorType
			}
			continue
		} else {
			// TypeScript 1.0 spec (April 2014)
			// A get accessor declaration is processed in the same manner as
			// an ordinary function declaration(section 6.1) with no parameters.
			// A set accessor declaration is processed in the same manner
			// as an ordinary function declaration with a single parameter and a Void return type.
			Debug.assert(memberDecl.kind == SyntaxKindGetAccessor || memberDecl.kind == SyntaxKindSetAccessor)
			tc.checkNodeDeferred(memberDecl)
		}

		if computedNameType && !(computedNameType.flags & TypeFlagsStringOrNumberLiteralOrUnique) {
			if tc.isTypeAssignableTo(computedNameType, tc.stringNumberSymbolType) {
				if tc.isTypeAssignableTo(computedNameType, tc.numberType) {
					hasComputedNumberProperty = true
				} else if tc.isTypeAssignableTo(computedNameType, tc.esSymbolType) {
					hasComputedSymbolProperty = true
				} else {
					hasComputedStringProperty = true
				}
				if inDestructuringPattern {
					patternWithComputedProperties = true
				}
			}
		} else {
			propertiesTable.set(member.escapedName, member)
		}
		propertiesArray.push(member)
	}
	tc.popContextualType()

	if tc.isErrorType(spread) {
		return tc.errorType
	}

	if spread != tc.emptyObjectType {
		if propertiesArray.length > 0 {
			spread = tc.getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
			propertiesArray = []never{}
			propertiesTable = createSymbolTable()
			hasComputedStringProperty = false
			hasComputedNumberProperty = false
		}
		// remap the raw emptyObjectType fed in at the top into a fresh empty object literal type, unique to this use site
		return tc.mapType(spread, func(t Type) Type {
			if t == tc.emptyObjectType {
				return createObjectLiteralType()
			} else {
				return t
			}
		})
	}

	return createObjectLiteralType()

	createObjectLiteralType := func() ResolvedType {
		indexInfos := []never{}
		if hasComputedStringProperty {
			indexInfos.push(tc.getObjectLiteralIndexInfo(node, offset, propertiesArray, tc.stringType))
		}
		if hasComputedNumberProperty {
			indexInfos.push(tc.getObjectLiteralIndexInfo(node, offset, propertiesArray, tc.numberType))
		}
		if hasComputedSymbolProperty {
			indexInfos.push(tc.getObjectLiteralIndexInfo(node, offset, propertiesArray, tc.esSymbolType))
		}
		result := tc.createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos)
		result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		if isJSObjectLiteral {
			result.objectFlags |= ObjectFlagsJSLiteral
		}
		if patternWithComputedProperties {
			result.objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
		}
		if inDestructuringPattern {
			result.pattern = node
		}
		return result
	}

}

func (tc *TypeChecker) isValidSpreadType(type_ Type) bool {
	t := tc.removeDefinitelyFalsyTypes(tc.mapType(type_, tc.getBaseConstraintOrType))
	return !!(t.flags&(TypeFlagsAny|TypeFlagsNonPrimitive|TypeFlagsObject|TypeFlagsInstantiableNonPrimitive) || t.flags&TypeFlagsUnionOrIntersection && every((t /* as UnionOrIntersectionType */).types, tc.isValidSpreadType))
}

func (tc *TypeChecker) checkJsxSelfClosingElementDeferred(node JsxSelfClosingElement) {
	tc.checkJsxOpeningLikeElementOrOpeningFragment(node)
}

func (tc *TypeChecker) checkJsxSelfClosingElement(node JsxSelfClosingElement, _checkMode *CheckMode) Type {
	tc.checkNodeDeferred(node)
	return tc.getJsxElementTypeAt(node) || tc.anyType
}

func (tc *TypeChecker) checkJsxElementDeferred(node JsxElement) {
	// Check attributes
	tc.checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement)

	// Perform resolution on the closing tag so that rename/go to definition/etc work
	if tc.isJsxIntrinsicTagName(node.closingElement.tagName) {
		tc.getIntrinsicTagSymbol(node.closingElement)
	} else {
		tc.checkExpression(node.closingElement.tagName)
	}

	tc.checkJsxChildren(node)
}

func (tc *TypeChecker) checkJsxElement(node JsxElement, _checkMode *CheckMode) Type {
	tc.checkNodeDeferred(node)

	return tc.getJsxElementTypeAt(node) || tc.anyType
}

func (tc *TypeChecker) checkJsxFragment(node JsxFragment) Type {
	tc.checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment)

	// by default, jsx:'react' will use jsxFactory = React.createElement and jsxFragmentFactory = React.Fragment
	// if jsxFactory compiler option is provided, ensure jsxFragmentFactory compiler option or @jsxFrag pragma is provided too
	nodeSourceFile := getSourceFileOfNode(node)
	if getJSXTransformEnabled(tc.compilerOptions) && (tc.compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx")) && !tc.compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag") {
		tc.error(node, __COND__(tc.compilerOptions.jsxFactory, Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option, Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments))
	}

	tc.checkJsxChildren(node)
	return tc.getJsxElementTypeAt(node) || tc.anyType
}

func (tc *TypeChecker) isHyphenatedJsxName(name /* TODO(TS-TO-GO) TypeNode UnionType: string | __String */ any) bool {
	return (name /* as string */).includes("-")
}

/**
 * Returns true iff React would emit this tag name as a string rather than an identifier or qualified name
 */

func (tc *TypeChecker) isJsxIntrinsicTagName(tagName Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: tagName is Identifier | JsxNamespacedName */ any {
	return isIdentifier(tagName) && isIntrinsicJsxName(tagName.escapedText) || isJsxNamespacedName(tagName)
}

func (tc *TypeChecker) checkJsxAttribute(node JsxAttribute, checkMode CheckMode) Type {
	if node.initializer {
		return tc.checkExpressionForMutableLocation(node.initializer, checkMode)
	} else {
		return tc.trueType
	}
	// <Elem attr /> is sugar for <Elem attr={true} />
}

/**
 * Get attributes type of the JSX opening-like element. The result is from resolving "attributes" property of the opening-like element.
 *
 * @param openingLikeElement a JSX opening-like element
 * @param filter a function to remove attributes that will not participate in checking whether attributes are assignable
 * @return an anonymous type (similar to the one returned by checkObjectLiteral) in which its properties are attributes property.
 * @remarks Because this function calls getSpreadType, it needs to use the same checks as checkObjectLiteral,
 * which also calls getSpreadType.
 */

func (tc *TypeChecker) createJsxAttributesTypeFromAttributesProperty(openingLikeElement JsxOpeningLikeElement, checkMode CheckMode /*  = CheckMode.Normal */) Type {
	attributes := openingLikeElement.attributes
	contextualType := tc.getContextualType(attributes, ContextFlagsNone)
	var allAttributesTable *SymbolTable
	if tc.strictNullChecks {
		allAttributesTable = createSymbolTable()
	} else {
		allAttributesTable = nil
	}
	attributesTable := createSymbolTable()
	var spread Type = tc.emptyJsxObjectType
	hasSpreadAnyType := false
	var typeToIntersect Type
	explicitlySpecifyChildrenAttribute := false
	var objectFlags ObjectFlags = ObjectFlagsJsxAttributes
	jsxChildrenPropertyName := tc.getJsxElementChildrenPropertyName(tc.getJsxNamespaceAt(openingLikeElement))

	for _, attributeDecl := range attributes.properties {
		member := attributeDecl.symbol
		if isJsxAttribute(attributeDecl) {
			exprType := tc.checkJsxAttribute(attributeDecl, checkMode)
			objectFlags |= getObjectFlags(exprType) & ObjectFlagsPropagatingFlags

			attributeSymbol := tc.createSymbol(SymbolFlagsProperty|member.flags, member.escapedName)
			attributeSymbol.declarations = member.declarations
			attributeSymbol.parent = member.parent
			if member.valueDeclaration {
				attributeSymbol.valueDeclaration = member.valueDeclaration
			}
			attributeSymbol.links.type_ = exprType
			attributeSymbol.links.target = member
			attributesTable.set(attributeSymbol.escapedName, attributeSymbol)
			allAttributesTable. /* ? */ set(attributeSymbol.escapedName, attributeSymbol)
			if getEscapedTextOfJsxAttributeName(attributeDecl.name) == jsxChildrenPropertyName {
				explicitlySpecifyChildrenAttribute = true
			}
			if contextualType {
				prop := tc.getPropertyOfType(contextualType, member.escapedName)
				if prop && prop.declarations && tc.isDeprecatedSymbol(prop) && isIdentifier(attributeDecl.name) {
					tc.addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText /* as string */)
				}
			}
			if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && tc.isContextSensitive(attributeDecl) {
				inferenceContext := tc.getInferenceContext(attributes)
				Debug.assert(inferenceContext)
				// In CheckMode.Inferential we should always have an inference context
				inferenceNode := (attributeDecl.initializer /* as JsxExpression */).expression
				tc.addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType)
			}
		} else {
			Debug.assert(attributeDecl.kind == SyntaxKindJsxSpreadAttribute)
			if attributesTable.size > 0 {
				spread = tc.getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags /*readonly*/, false)
				attributesTable = createSymbolTable()
			}
			exprType := tc.getReducedType(tc.checkExpression(attributeDecl.expression, checkMode&CheckModeInferential))
			if tc.isTypeAny(exprType) {
				hasSpreadAnyType = true
			}
			if tc.isValidSpreadType(exprType) {
				spread = tc.getSpreadType(spread, exprType, attributes.symbol, objectFlags /*readonly*/, false)
				if allAttributesTable {
					tc.checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl)
				}
			} else {
				tc.error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types)
				if typeToIntersect {
					typeToIntersect = tc.getIntersectionType([]Type{typeToIntersect, exprType})
				} else {
					typeToIntersect = exprType
				}
			}
		}
	}

	if !hasSpreadAnyType {
		if attributesTable.size > 0 {
			spread = tc.getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags /*readonly*/, false)
		}
	}

	// Handle children attribute
	var parent *JsxElement
	if openingLikeElement.parent.kind == SyntaxKindJsxElement {
		parent = openingLikeElement.parent /* as JsxElement */
	} else {
		parent = nil
	}
	// We have to check that openingElement of the parent is the one we are visiting as this may not be true for selfClosingElement
	if parent && parent.openingElement == openingLikeElement && getSemanticJsxChildren(parent.children).length > 0 {
		var childrenTypes []Type = tc.checkJsxChildren(parent, checkMode)

		if !hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName != "" {
			// Error if there is a attribute named "children" explicitly specified and children element.
			// This is because children element will overwrite the value from attributes.
			// Note: we will not warn "children" attribute overwritten if "children" attribute is specified in object spread.
			if explicitlySpecifyChildrenAttribute {
				tc.error(attributes, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName))
			}

			contextualType := tc.getApparentTypeOfContextualType(openingLikeElement.attributes /*contextFlags*/, nil)
			childrenContextualType := contextualType && tc.getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName)
			// If there are children in the body of JSX element, create dummy attribute "children" with the union of children types so that it will pass the attribute checking process
			childrenPropSymbol := tc.createSymbol(SymbolFlagsProperty, jsxChildrenPropertyName)
			switch {
			case childrenTypes.length == 1:
				childrenPropSymbol.links.type_ = childrenTypes[0]
			case childrenContextualType && tc.someType(childrenContextualType, tc.isTupleLikeType):
				childrenPropSymbol.links.type_ = tc.createTupleType(childrenTypes)
			default:
				childrenPropSymbol.links.type_ = tc.createArrayType(tc.getUnionType(childrenTypes))
			}
			// Fake up a property declaration for the children
			childrenPropSymbol.valueDeclaration = factory.createPropertySignature(nil, unescapeLeadingUnderscores(jsxChildrenPropertyName) /*questionToken*/, nil /*type*/, nil)
			setParent(childrenPropSymbol.valueDeclaration, attributes)
			childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol
			childPropMap := createSymbolTable()
			childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol)
			spread = tc.getSpreadType(spread, tc.createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags /*readonly*/, false)
		}
	}

	if hasSpreadAnyType {
		return tc.anyType
	}
	if typeToIntersect && spread != tc.emptyJsxObjectType {
		return tc.getIntersectionType([]Type{typeToIntersect, spread})
	}
	return typeToIntersect || (__COND__(spread == tc.emptyJsxObjectType, createJsxAttributesType(), spread))
	/**
	 * Create anonymous type from given attributes symbol table.
	 * @param symbol a symbol of JsxAttributes containing attributes corresponding to attributesTable
	 * @param attributesTable a symbol table of attributes property
	 */

	createJsxAttributesType := func() ResolvedType {
		objectFlags |= ObjectFlagsFreshLiteral
		result := tc.createAnonymousType(attributes.symbol, attributesTable, emptyArray, emptyArray, emptyArray)
		result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		return result
	}

}

func (tc *TypeChecker) checkJsxChildren(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxElement | JsxFragment */ any, checkMode CheckMode) []Type {
	var childrenTypes []Type = []never{}
	for _, child := range node.children {
		// In React, JSX text that contains only whitespaces will be ignored so we don't want to type-check that
		// because then type of children property will have constituent of string type.
		if child.kind == SyntaxKindJsxText {
			if !child.containsOnlyTriviaWhiteSpaces {
				childrenTypes.push(tc.stringType)
			}
		} else if child.kind == SyntaxKindJsxExpression && !child.expression {
			continue
			// empty jsx expressions don't *really* count as present children
		} else {
			childrenTypes.push(tc.checkExpressionForMutableLocation(child, checkMode))
		}
	}
	return childrenTypes
}

func (tc *TypeChecker) checkSpreadPropOverrides(type_ Type, props SymbolTable, spread /* TODO(TS-TO-GO) TypeNode UnionType: SpreadAssignment | JsxSpreadAttribute */ any) {
	for _, right := range tc.getPropertiesOfType(type_) {
		if !(right.flags & SymbolFlagsOptional) {
			left := props.get(right.escapedName)
			if left {
				diagnostic := tc.error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName))
				addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property))
			}
		}
	}
}

/**
 * Check attributes property of opening-like element. This function is called during chooseOverload to get call signature of a JSX opening-like element.
 * (See "checkApplicableSignatureForJsxOpeningLikeElement" for how the function is used)
 * @param node a JSXAttributes to be resolved of its type
 */

func (tc *TypeChecker) checkJsxAttributes(node JsxAttributes, checkMode *CheckMode) Type {
	return tc.createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode)
}

func (tc *TypeChecker) getJsxType(name __String, location Node) Type {
	namespace := tc.getJsxNamespaceAt(location)
	exports := namespace && tc.getExportsOfSymbol(namespace)
	typeSymbol := exports && tc.getSymbol(exports, name, SymbolFlagsType)
	if typeSymbol {
		return tc.getDeclaredTypeOfSymbol(typeSymbol)
	} else {
		return tc.errorType
	}
}

/**
 * Looks up an intrinsic tag name and returns a symbol that either points to an intrinsic
 * property (in which case nodeLinks.jsxFlags will be IntrinsicNamedElement) or an intrinsic
 * string index signature (in which case nodeLinks.jsxFlags will be IntrinsicIndexedElement).
 * May also return unknownSymbol if both of these lookups fail.
 */

func (tc *TypeChecker) getIntrinsicTagSymbol(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningLikeElement | JsxClosingElement */ any) Symbol {
	links := tc.getNodeLinks(node)
	if !links.resolvedSymbol {
		intrinsicElementsType := tc.getJsxType(JsxNames.IntrinsicElements, node)
		if !tc.isErrorType(intrinsicElementsType) {
			// Property case
			if !isIdentifier(node.tagName) && !isJsxNamespacedName(node.tagName) {
				return Debug.fail()
			}
			var propName __String
			if isJsxNamespacedName(node.tagName) {
				propName = getEscapedTextOfJsxNamespacedName(node.tagName)
			} else {
				propName = node.tagName.escapedText
			}
			intrinsicProp := tc.getPropertyOfType(intrinsicElementsType, propName)
			if intrinsicProp {
				links.jsxFlags |= JsxFlagsIntrinsicNamedElement
				links.resolvedSymbol = intrinsicProp
				return links.resolvedSymbol
			}

			// Intrinsic string indexer case
			indexSymbol := tc.getApplicableIndexSymbol(intrinsicElementsType, tc.getStringLiteralType(unescapeLeadingUnderscores(propName)))
			if indexSymbol {
				links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
				links.resolvedSymbol = indexSymbol
				return links.resolvedSymbol
			}

			if tc.getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName) {
				links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
				links.resolvedSymbol = intrinsicElementsType.symbol
				return links.resolvedSymbol
			}

			// Wasn't found
			tc.error(node, Diagnostics.Property_0_does_not_exist_on_type_1, intrinsicTagNameToString(node.tagName), "JSX."+JsxNames.IntrinsicElements)
			links.resolvedSymbol = tc.unknownSymbol
			return links.resolvedSymbol
		} else {
			if tc.noImplicitAny {
				tc.error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements))
			}
			links.resolvedSymbol = tc.unknownSymbol
			return links.resolvedSymbol
		}
	}
	return links.resolvedSymbol
}

func (tc *TypeChecker) getJsxNamespaceContainerForImplicitImport(location Node) Symbol {
	file := location && getSourceFileOfNode(location)
	links := file && tc.getNodeLinks(file)
	if links && links.jsxImplicitImportContainer == false {
		return nil
	}
	if links && links.jsxImplicitImportContainer {
		return links.jsxImplicitImportContainer
	}
	runtimeImportSpecifier := getJSXRuntimeImport(getJSXImplicitImportBase(tc.compilerOptions, file), tc.compilerOptions)
	if !runtimeImportSpecifier {
		return nil
	}
	isClassic := getEmitModuleResolutionKind(tc.compilerOptions) == ModuleResolutionKindClassic
	var errorMessage DiagnosticMessage
	if isClassic {
		errorMessage = Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option
	} else {
		errorMessage = Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations
	}
	specifier := tc.getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier)
	mod := tc.resolveExternalModule(specifier || location, runtimeImportSpecifier, errorMessage, location)
	var result Symbol
	if mod && mod != tc.unknownSymbol {
		result = tc.getMergedSymbol(tc.resolveSymbol(mod))
	} else {
		result = nil
	}
	if links {
		links.jsxImplicitImportContainer = result || false
	}
	return result
}

func (tc *TypeChecker) getJsxNamespaceAt(location Node) Symbol {
	links := location && tc.getNodeLinks(location)
	if links && links.jsxNamespace {
		return links.jsxNamespace
	}
	if !links || links.jsxNamespace != false {
		resolvedNamespace := tc.getJsxNamespaceContainerForImplicitImport(location)

		if !resolvedNamespace || resolvedNamespace == tc.unknownSymbol {
			namespaceName := tc.getJsxNamespace(location)
			resolvedNamespace = tc.resolveName(location, namespaceName, SymbolFlagsNamespace /*nameNotFoundMessage*/, nil /*isUse*/, false)
		}

		if resolvedNamespace {
			candidate := tc.resolveSymbol(tc.getSymbol(tc.getExportsOfSymbol(tc.resolveSymbol(resolvedNamespace)), JsxNames.JSX, SymbolFlagsNamespace))
			if candidate && candidate != tc.unknownSymbol {
				if links {
					links.jsxNamespace = candidate
				}
				return candidate
			}
		}
		if links {
			links.jsxNamespace = false
		}
	}
	// JSX global fallback
	s := tc.resolveSymbol(tc.getGlobalSymbol(JsxNames.JSX, SymbolFlagsNamespace /*diagnostic*/, nil))
	if s == tc.unknownSymbol {
		return nil
		// TODO: GH#18217
	}
	return s
	// TODO: GH#18217
}

/**
 * Look into JSX namespace and then look for container with matching name as nameOfAttribPropContainer.
 * Get a single property from that container if existed. Report an error if there are more than one property.
 *
 * @param nameOfAttribPropContainer a string of value JsxNames.ElementAttributesPropertyNameContainer or JsxNames.ElementChildrenAttributeNameContainer
 *          if other string is given or the container doesn't exist, return undefined.
 */

func (tc *TypeChecker) getNameFromJsxElementAttributesContainer(nameOfAttribPropContainer __String, jsxNamespace Symbol) *__String {
	// JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [symbol]
	jsxElementAttribPropInterfaceSym := jsxNamespace && tc.getSymbol(jsxNamespace.exports, nameOfAttribPropContainer, SymbolFlagsType)
	// JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute [type]
	jsxElementAttribPropInterfaceType := jsxElementAttribPropInterfaceSym && tc.getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym)
	// The properties of JSX.ElementAttributesProperty | JSX.ElementChildrenAttribute
	propertiesOfJsxElementAttribPropInterface := jsxElementAttribPropInterfaceType && tc.getPropertiesOfType(jsxElementAttribPropInterfaceType)
	if propertiesOfJsxElementAttribPropInterface {
		// Element Attributes has zero properties, so the element attributes type will be the class instance type
		if propertiesOfJsxElementAttribPropInterface.length == 0 {
			return "" /* as __String */
		} else if propertiesOfJsxElementAttribPropInterface.length == 1 {
			return propertiesOfJsxElementAttribPropInterface[0].escapedName
		} else if propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations {
			// More than one property on ElementAttributesProperty is an error
			tc.error(jsxElementAttribPropInterfaceSym.declarations[0], Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer))
		}
	}
	return nil
}

func (tc *TypeChecker) getJsxLibraryManagedAttributes(jsxNamespace Symbol) Symbol {
	// JSX.LibraryManagedAttributes [symbol]
	return jsxNamespace && tc.getSymbol(jsxNamespace.exports, JsxNames.LibraryManagedAttributes, SymbolFlagsType)
}

func (tc *TypeChecker) getJsxElementTypeSymbol(jsxNamespace Symbol) Symbol {
	// JSX.ElementType [symbol]
	return jsxNamespace && tc.getSymbol(jsxNamespace.exports, JsxNames.ElementType, SymbolFlagsType)
}

// / e.g. "props" for React.d.ts,
// / or 'undefined' if ElementAttributesProperty doesn't exist (which means all
// /     non-intrinsic elements' attributes type is 'any'),
// / or ” if it has 0 properties (which means every
// /     non-intrinsic elements' attributes type is the element instance type)
func (tc *TypeChecker) getJsxElementPropertiesName(jsxNamespace Symbol) *__String {
	return tc.getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace)
}

func (tc *TypeChecker) getJsxElementChildrenPropertyName(jsxNamespace Symbol) *__String {
	return tc.getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace)
}

func (tc *TypeChecker) getUninstantiatedJsxSignaturesOfType(elementType Type, caller JsxOpeningLikeElement) []Signature {
	if elementType.flags & TypeFlagsString {
		return []Signature{tc.anySignature}
	} else if elementType.flags & TypeFlagsStringLiteral {
		intrinsicType := tc.getIntrinsicAttributesTypeFromStringLiteralType(elementType /* as StringLiteralType */, caller)
		if !intrinsicType {
			tc.error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, (elementType /* as StringLiteralType */).value, "JSX."+JsxNames.IntrinsicElements)
			return emptyArray
		} else {
			fakeSignature := tc.createSignatureForJSXIntrinsic(caller, intrinsicType)
			return []Signature{fakeSignature}
		}
	}
	apparentElemType := tc.getApparentType(elementType)
	// Resolve the signatures, preferring constructor
	signatures := tc.getSignaturesOfType(apparentElemType, SignatureKindConstruct)
	if signatures.length == 0 {
		// No construct signatures, try call signatures
		signatures = tc.getSignaturesOfType(apparentElemType, SignatureKindCall)
	}
	if signatures.length == 0 && apparentElemType.flags&TypeFlagsUnion {
		// If each member has some combination of new/call signatures; make a union signature list for those
		signatures = tc.getUnionSignatures(map_((apparentElemType /* as UnionType */).types, func(t Type) []Signature {
			return tc.getUninstantiatedJsxSignaturesOfType(t, caller)
		}))
	}
	return signatures
}

func (tc *TypeChecker) getIntrinsicAttributesTypeFromStringLiteralType(type_ StringLiteralType, location Node) Type {
	// If the elemType is a stringLiteral type, we can then provide a check to make sure that the string literal type is one of the Jsx intrinsic element type
	// For example:
	//      var CustomTag: "h1" = "h1";
	//      <CustomTag> Hello World </CustomTag>
	intrinsicElementsType := tc.getJsxType(JsxNames.IntrinsicElements, location)
	if !tc.isErrorType(intrinsicElementsType) {
		stringLiteralTypeName := type_.value
		intrinsicProp := tc.getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName))
		if intrinsicProp {
			return tc.getTypeOfSymbol(intrinsicProp)
		}
		indexSignatureType := tc.getIndexTypeOfType(intrinsicElementsType, tc.stringType)
		if indexSignatureType {
			return indexSignatureType
		}
		return nil
	}
	// If we need to report an error, we already done so here. So just return any to prevent any more error downstream
	return tc.anyType
}

func (tc *TypeChecker) checkJsxReturnAssignableToAppropriateBound(refKind JsxReferenceKind, elemInstanceType Type, openingLikeElement JsxOpeningLikeElement) {
	if refKind == JsxReferenceKindFunction {
		sfcReturnConstraint := tc.getJsxStatelessElementTypeAt(openingLikeElement)
		if sfcReturnConstraint {
			tc.checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, tc.assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
		}
	} else if refKind == JsxReferenceKindComponent {
		classConstraint := tc.getJsxElementClassTypeAt(openingLikeElement)
		if classConstraint {
			// Issue an error if this return type isn't assignable to JSX.ElementClass, failing that
			tc.checkTypeRelatedTo(elemInstanceType, classConstraint, tc.assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
		}
	} else {
		sfcReturnConstraint := tc.getJsxStatelessElementTypeAt(openingLikeElement)
		classConstraint := tc.getJsxElementClassTypeAt(openingLikeElement)
		if !sfcReturnConstraint || !classConstraint {
			return
		}
		combined := tc.getUnionType([]Type{sfcReturnConstraint, classConstraint})
		tc.checkTypeRelatedTo(elemInstanceType, combined, tc.assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
	}

	generateInitialErrorChain := func() DiagnosticMessageChain {
		componentName := getTextOfNode(openingLikeElement.tagName)
		return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
	}

}

/**
 * Get attributes type of the given intrinsic opening-like Jsx element by resolving the tag name.
 * The function is intended to be called from a function which has checked that the opening element is an intrinsic element.
 * @param node an intrinsic JSX opening-like element
 */

func (tc *TypeChecker) getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node JsxOpeningLikeElement) Type {
	Debug.assert(tc.isJsxIntrinsicTagName(node.tagName))
	links := tc.getNodeLinks(node)
	if !links.resolvedJsxElementAttributesType {
		symbol := tc.getIntrinsicTagSymbol(node)
		if links.jsxFlags & JsxFlagsIntrinsicNamedElement {
			links.resolvedJsxElementAttributesType = tc.getTypeOfSymbol(symbol) || tc.errorType
			return links.resolvedJsxElementAttributesType
		} else if links.jsxFlags & JsxFlagsIntrinsicIndexedElement {
			var propName __String
			if isJsxNamespacedName(node.tagName) {
				propName = getEscapedTextOfJsxNamespacedName(node.tagName)
			} else {
				propName = node.tagName.escapedText
			}
			links.resolvedJsxElementAttributesType = tc.getApplicableIndexInfoForName(tc.getJsxType(JsxNames.IntrinsicElements, node), propName). /* ? */ type_ || tc.errorType
			return links.resolvedJsxElementAttributesType
		} else {
			links.resolvedJsxElementAttributesType = tc.errorType
			return links.resolvedJsxElementAttributesType
		}
	}
	return links.resolvedJsxElementAttributesType
}

func (tc *TypeChecker) getJsxElementClassTypeAt(location Node) Type {
	type_ := tc.getJsxType(JsxNames.ElementClass, location)
	if tc.isErrorType(type_) {
		return nil
	}
	return type_
}

func (tc *TypeChecker) getJsxElementTypeAt(location Node) Type {
	return tc.getJsxType(JsxNames.Element, location)
}

func (tc *TypeChecker) getJsxStatelessElementTypeAt(location Node) Type {
	jsxElementType := tc.getJsxElementTypeAt(location)
	if jsxElementType {
		return tc.getUnionType([]Type{jsxElementType, tc.nullType})
	}
}

func (tc *TypeChecker) getJsxElementTypeTypeAt(location Node) Type {
	ns := tc.getJsxNamespaceAt(location)
	if !ns {
		return nil
	}
	sym := tc.getJsxElementTypeSymbol(ns)
	if !sym {
		return nil
	}
	type_ := tc.instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location))
	if !type_ || tc.isErrorType(type_) {
		return nil
	}
	return type_
}

func (tc *TypeChecker) instantiateAliasOrInterfaceWithDefaults(managedSym Symbol, inJs bool, typeArguments []Type) Type {
	declaredManagedType := tc.getDeclaredTypeOfSymbol(managedSym)
	// fetches interface type, or initializes symbol links type parmaeters
	if managedSym.flags & SymbolFlagsTypeAlias {
		params := tc.getSymbolLinks(managedSym).typeParameters
		if length(params) >= typeArguments.length {
			args := tc.fillMissingTypeArguments(typeArguments, params, typeArguments.length, inJs)
			if length(args) == 0 {
				return declaredManagedType
			} else {
				return tc.getTypeAliasInstantiation(managedSym, args)
			}
		}
	}
	if length((declaredManagedType /* as GenericType */).typeParameters) >= typeArguments.length {
		args := tc.fillMissingTypeArguments(typeArguments, (declaredManagedType /* as GenericType */).typeParameters, typeArguments.length, inJs)
		return tc.createTypeReference(declaredManagedType /* as GenericType */, args)
	}
	return nil
}

/**
 * Returns all the properties of the Jsx.IntrinsicElements interface
 */

func (tc *TypeChecker) getJsxIntrinsicTagNamesAt(location Node) []Symbol {
	intrinsics := tc.getJsxType(JsxNames.IntrinsicElements, location)
	if intrinsics {
		return tc.getPropertiesOfType(intrinsics)
	} else {
		return emptyArray
	}
}

func (tc *TypeChecker) checkJsxPreconditions(errorNode Node) {
	// Preconditions for using JSX
	if (tc.compilerOptions.jsx || JsxEmitNone) == JsxEmitNone {
		tc.error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided)
	}

	if tc.getJsxElementTypeAt(errorNode) == nil {
		if tc.noImplicitAny {
			tc.error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist)
		}
	}
}

func (tc *TypeChecker) checkJsxOpeningLikeElementOrOpeningFragment(node /* TODO(TS-TO-GO) TypeNode UnionType: JsxOpeningLikeElement | JsxOpeningFragment */ any) {
	isNodeOpeningLikeElement := isJsxOpeningLikeElement(node)

	if isNodeOpeningLikeElement {
		tc.checkGrammarJsxElement(node)
	}

	tc.checkJsxPreconditions(node)

	tc.markJsxAliasReferenced(node)

	if isNodeOpeningLikeElement {
		jsxOpeningLikeNode := node
		sig := tc.getResolvedSignature(jsxOpeningLikeNode)
		tc.checkDeprecatedSignature(sig, node)

		elementTypeConstraint := tc.getJsxElementTypeTypeAt(jsxOpeningLikeNode)
		if elementTypeConstraint != nil {
			tagName := jsxOpeningLikeNode.tagName
			var tagType Type
			if tc.isJsxIntrinsicTagName(tagName) {
				tagType = tc.getStringLiteralType(intrinsicTagNameToString(tagName))
			} else {
				tagType = tc.checkExpression(tagName)
			}
			tc.checkTypeRelatedTo(tagType, elementTypeConstraint, tc.assignableRelation, tagName, Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type, func() DiagnosticMessageChain {
				componentName := getTextOfNode(tagName)
				return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
			})
		} else {
			tc.checkJsxReturnAssignableToAppropriateBound(tc.getJsxReferenceKind(jsxOpeningLikeNode), tc.getReturnTypeOfSignature(sig), jsxOpeningLikeNode)
		}
	}
}

/**
 * Check if a property with the given name is known anywhere in the given type. In an object type, a property
 * is considered known if
 * 1. the object type is empty and the check is for assignability, or
 * 2. if the object type has index signatures, or
 * 3. if the property is actually declared in the object type
 *    (this means that 'toString', for example, is not usually a known property).
 * 4. In a union or intersection type,
 *    a property is considered known if it is known in any constituent type.
 * @param targetType a type to search a given name in
 * @param name a property name to search
 * @param isComparingJsxAttributes a boolean flag indicating whether we are searching in JsxAttributesType
 */

func (tc *TypeChecker) isKnownProperty(targetType Type, name __String, isComparingJsxAttributes bool) bool {
	if targetType.flags & TypeFlagsObject {
		// For backwards compatibility a symbol-named property is satisfied by a string index signature. This
		// is incorrect and inconsistent with element access expressions, where it is an error, so eventually
		// we should remove this exception.
		if tc.getPropertyOfObjectType(targetType, name) || tc.getApplicableIndexInfoForName(targetType, name) || tc.isLateBoundName(name) && tc.getIndexInfoOfType(targetType, tc.stringType) || isComparingJsxAttributes && tc.isHyphenatedJsxName(name) {
			// For JSXAttributes, if the attribute has a hyphenated name, consider that the attribute to be known.
			return true
		}
	}
	if targetType.flags & TypeFlagsSubstitution {
		return tc.isKnownProperty((targetType /* as SubstitutionType */).baseType, name, isComparingJsxAttributes)
	}
	if targetType.flags&TypeFlagsUnionOrIntersection && tc.isExcessPropertyCheckTarget(targetType) {
		for _, t := range (targetType /* as UnionOrIntersectionType */).types {
			if tc.isKnownProperty(t, name, isComparingJsxAttributes) {
				return true
			}
		}
	}
	return false
}

func (tc *TypeChecker) isExcessPropertyCheckTarget(type_ Type) bool {
	return !!(type_.flags&TypeFlagsObject && !(getObjectFlags(type_)&ObjectFlagsObjectLiteralPatternWithComputedProperties) || type_.flags&TypeFlagsNonPrimitive || type_.flags&TypeFlagsSubstitution && tc.isExcessPropertyCheckTarget((type_ /* as SubstitutionType */).baseType) || type_.flags&TypeFlagsUnion && some((type_ /* as UnionType */).types, tc.isExcessPropertyCheckTarget) || type_.flags&TypeFlagsIntersection && every((type_ /* as IntersectionType */).types, tc.isExcessPropertyCheckTarget))
}

func (tc *TypeChecker) checkJsxExpression(node JsxExpression, checkMode CheckMode) Type {
	tc.checkGrammarJsxExpression(node)
	if node.expression {
		type_ := tc.checkExpression(node.expression, checkMode)
		if node.dotDotDotToken && type_ != tc.anyType && !tc.isArrayType(type_) {
			tc.error(node, Diagnostics.JSX_spread_child_must_be_an_array_type)
		}
		return type_
	} else {
		return tc.errorType
	}
}

func (tc *TypeChecker) getDeclarationNodeFlagsFromSymbol(s Symbol) NodeFlags {
	if s.valueDeclaration {
		return tc.getCombinedNodeFlagsCached(s.valueDeclaration)
	} else {
		return 0
	}
}

/**
 * Return whether this symbol is a member of a prototype somewhere
 * Note that this is not tracked well within the compiler, so the answer may be incorrect.
 */

func (tc *TypeChecker) isPrototypeProperty(symbol Symbol) *bool {
	if symbol.flags&SymbolFlagsMethod || getCheckFlags(symbol)&CheckFlagsSyntheticMethod {
		return true
	}
	if isInJSFile(symbol.valueDeclaration) {
		parent := symbol.valueDeclaration.parent
		return parent && isBinaryExpression(parent) && getAssignmentDeclarationKind(parent) == AssignmentDeclarationKindPrototypeProperty
	}
}

/**
 * Check whether the requested property access is valid.
 * Returns true if node is a valid property access, and false otherwise.
 * @param node The node to be checked.
 * @param isSuper True if the access is from `super.`.
 * @param type The type of the object whose property is being accessed. (Not the type of the property.)
 * @param prop The symbol for the property being accessed.
 */

func (tc *TypeChecker) checkPropertyAccessibility(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement */ any, isSuper bool, writing bool, type_ Type, prop Symbol, reportError bool /*  = true */) bool {
	var errorNode * /* TODO(TS-TO-GO) inferred type ObjectBindingPattern | ArrayBindingPattern | PropertyName | ImportTypeNode */ any
	switch {
	case !reportError:
		errorNode = nil
	case node.kind == SyntaxKindQualifiedName:
		errorNode = node.right
	case node.kind == SyntaxKindImportType:
		errorNode = node
	case node.kind == SyntaxKindBindingElement && node.propertyName:
		errorNode = node.propertyName
	default:
		errorNode = node.name
	}

	return tc.checkPropertyAccessibilityAtLocation(node, isSuper, writing, type_, prop, errorNode)
}

/**
 * Check whether the requested property can be accessed at the requested location.
 * Returns true if node is a valid property access, and false otherwise.
 * @param location The location node where we want to check if the property is accessible.
 * @param isSuper True if the access is from `super.`.
 * @param writing True if this is a write property access, false if it is a read property access.
 * @param containingType The type of the object whose property is being accessed. (Not the type of the property.)
 * @param prop The symbol for the property being accessed.
 * @param errorNode The node where we should report an invalid property access error, or undefined if we should not report errors.
 */

func (tc *TypeChecker) checkPropertyAccessibilityAtLocation(location Node, isSuper bool, writing bool, containingType Type, prop Symbol, errorNode Node) bool {
	flags := getDeclarationModifierFlagsFromSymbol(prop, writing)

	if isSuper {
		// TS 1.0 spec (April 2014): 4.8.2
		// - In a constructor, instance member function, instance member accessor, or
		//   instance member variable initializer where this references a derived class instance,
		//   a super property access is permitted and must specify a public instance member function of the base class.
		// - In a static member function or static member accessor
		//   where this references the constructor function object of a derived class,
		//   a super property access is permitted and must specify a public static member function of the base class.
		if tc.languageVersion < ScriptTargetES2015 {
			if tc.symbolHasNonMethodDeclaration(prop) {
				if errorNode {
					tc.error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword)
				}
				return false
			}
		}
		if flags & ModifierFlagsAbstract {
			// A method cannot be accessed in a super property access if the method is abstract.
			// This error could mask a private property access error. But, a member
			// cannot simultaneously be private and abstract, so this will trigger an
			// additional error elsewhere.
			if errorNode {
				tc.error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, tc.symbolToString(prop), tc.typeToString(tc.getDeclaringClass(prop)))
			}
			return false
		}
		// A class field cannot be accessed via super.* from a derived class.
		// This is true for both [[Set]] (old) and [[Define]] (ES spec) semantics.
		if !(flags & ModifierFlagsStatic) && prop.declarations. /* ? */ some(isClassInstanceProperty) {
			if errorNode {
				tc.error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, tc.symbolToString(prop))
			}
			return false
		}
	}

	// Referencing abstract properties within their own constructors is not allowed
	if (flags & ModifierFlagsAbstract) && tc.symbolHasNonMethodDeclaration(prop) && (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent)) {
		declaringClassDeclaration := getClassLikeDeclarationOfSymbol(tc.getParentOfSymbol(prop))
		if declaringClassDeclaration && tc.isNodeUsedDuringClassInitialization(location) {
			if errorNode {
				tc.error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, tc.symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name))
			}
			return false
		}
	}

	// Public properties are otherwise accessible.
	if !(flags & ModifierFlagsNonPublicAccessibilityModifier) {
		return true
	}

	// Property is known to be private or protected at this point

	// Private property is accessible if the property is within the declaring class
	if flags & ModifierFlagsPrivate {
		declaringClassDeclaration := getClassLikeDeclarationOfSymbol(tc.getParentOfSymbol(prop))
		if !tc.isNodeWithinClass(location, declaringClassDeclaration) {
			if errorNode {
				tc.error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, tc.symbolToString(prop), tc.typeToString(tc.getDeclaringClass(prop)))
			}
			return false
		}
		return true
	}

	// Property is known to be protected at this point

	// All protected properties of a supertype are accessible in a super access
	if isSuper {
		return true
	}

	// Find the first enclosing class that has the declaring classes of the protected constituents
	// of the property as base classes
	enclosingClass := tc.forEachEnclosingClass(location, func(enclosingDeclaration ClassLikeDeclaration) *InterfaceType {
		enclosingClass := tc.getDeclaredTypeOfSymbol(tc.getSymbolOfDeclaration(enclosingDeclaration)) /* as InterfaceType */
		return tc.isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
	})
	// A protected property is accessible if the property is within the declaring class or classes derived from it
	if !enclosingClass {
		// allow PropertyAccessibility if context is in function with this parameter
		// static member access is disallowed
		enclosingClass = tc.getEnclosingClassFromThisParameter(location)
		enclosingClass = enclosingClass && tc.isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
		if flags&ModifierFlagsStatic || !enclosingClass {
			if errorNode {
				tc.error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, tc.symbolToString(prop), tc.typeToString(tc.getDeclaringClass(prop) || containingType))
			}
			return false
		}
	}
	// No further restrictions for static properties
	if flags & ModifierFlagsStatic {
		return true
	}
	if containingType.flags & TypeFlagsTypeParameter {
		// get the original type -- represented as the type constraint of the 'this' type
		if (containingType /* as TypeParameter */).isThisType {
			containingType = tc.getConstraintOfTypeParameter(containingType /* as TypeParameter */)
		} else {
			containingType = tc.getBaseConstraintOfType(containingType /* as TypeParameter */)
		}
		// TODO: GH#18217 Use a different variable that's allowed to be undefined
	}
	if !containingType || !tc.hasBaseType(containingType, enclosingClass) {
		if errorNode {
			tc.error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, tc.symbolToString(prop), tc.typeToString(enclosingClass), tc.typeToString(containingType))
		}
		return false
	}
	return true
}

func (tc *TypeChecker) getEnclosingClassFromThisParameter(node Node) *InterfaceType {
	// 'this' type for a node comes from, in priority order...
	// 1. The type of a syntactic 'this' parameter in the enclosing function scope
	thisParameter := tc.getThisParameterFromNodeContext(node)
	thisType := thisParameter. /* ? */ type_ && tc.getTypeFromTypeNode(thisParameter.type_)
	if thisType {
		// 2. The constraint of a type parameter used for an explicit 'this' parameter
		if thisType.flags & TypeFlagsTypeParameter {
			thisType = tc.getConstraintOfTypeParameter(thisType /* as TypeParameter */)
		}
	} else {
		// 3. The 'this' parameter of a contextual type
		thisContainer := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		if isFunctionLike(thisContainer) {
			thisType = tc.getContextualThisParameterType(thisContainer)
		}
	}
	if thisType && getObjectFlags(thisType)&(ObjectFlagsClassOrInterface|ObjectFlagsReference) {
		return tc.getTargetType(thisType) /* as InterfaceType */
	}
	return nil
}

func (tc *TypeChecker) getThisParameterFromNodeContext(node Node) *ParameterDeclaration {
	thisContainer := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
	if thisContainer && isFunctionLike(thisContainer) {
		return getThisParameter(thisContainer)
	} else {
		return nil
	}
}

func (tc *TypeChecker) symbolHasNonMethodDeclaration(symbol Symbol) bool {
	return !!tc.forEachProperty(symbol, func(prop Symbol) bool {
		return !(prop.flags & SymbolFlagsMethod)
	})
}

func (tc *TypeChecker) checkNonNullExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any) Type {
	return tc.checkNonNullType(tc.checkExpression(node), node)
}

func (tc *TypeChecker) isNullableType(type_ Type) bool {
	return tc.hasTypeFacts(type_, TypeFactsIsUndefinedOrNull)
}

func (tc *TypeChecker) getNonNullableTypeIfNeeded(type_ Type) Type {
	if tc.isNullableType(type_) {
		return tc.getNonNullableType(type_)
	} else {
		return type_
	}
}

func (tc *TypeChecker) reportObjectPossiblyNullOrUndefinedError(node Node, facts TypeFacts) {
	var nodeText *string
	if isEntityNameExpression(node) {
		nodeText = entityNameToString(node)
	} else {
		nodeText = nil
	}
	if node.kind == SyntaxKindNullKeyword {
		tc.error(node, Diagnostics.The_value_0_cannot_be_used_here, "null")
		return
	}
	if nodeText != nil && nodeText.length < 100 {
		if isIdentifier(node) && nodeText == "undefined" {
			tc.error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined")
			return
		}
		tc.error(node, __COND__(facts&TypeFactsIsUndefined, __COND__(facts&TypeFactsIsNull, Diagnostics._0_is_possibly_null_or_undefined, Diagnostics._0_is_possibly_undefined), Diagnostics._0_is_possibly_null), nodeText)
	} else {
		tc.error(node, __COND__(facts&TypeFactsIsUndefined, __COND__(facts&TypeFactsIsNull, Diagnostics.Object_is_possibly_null_or_undefined, Diagnostics.Object_is_possibly_undefined), Diagnostics.Object_is_possibly_null))
	}
}

func (tc *TypeChecker) reportCannotInvokePossiblyNullOrUndefinedError(node Node, facts TypeFacts) {
	tc.error(node, __COND__(facts&TypeFactsIsUndefined, __COND__(facts&TypeFactsIsNull, Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined, Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined), Diagnostics.Cannot_invoke_an_object_which_is_possibly_null))
}

func (tc *TypeChecker) checkNonNullTypeWithReporter(type_ Type, node Node, reportError func(node Node, facts TypeFacts)) Type {
	if tc.strictNullChecks && type_.flags&TypeFlagsUnknown {
		if isEntityNameExpression(node) {
			nodeText := entityNameToString(node)
			if nodeText.length < 100 {
				tc.error(node, Diagnostics._0_is_of_type_unknown, nodeText)
				return tc.errorType
			}
		}
		tc.error(node, Diagnostics.Object_is_of_type_unknown)
		return tc.errorType
	}
	facts := tc.getTypeFacts(type_, TypeFactsIsUndefinedOrNull)
	if facts & TypeFactsIsUndefinedOrNull {
		reportError(node, facts)
		t := tc.getNonNullableType(type_)
		if t.flags & (TypeFlagsNullable | TypeFlagsNever) {
			return tc.errorType
		} else {
			return t
		}
	}
	return type_
}

func (tc *TypeChecker) checkNonNullType(type_ Type, node Node) Type {
	return tc.checkNonNullTypeWithReporter(type_, node, tc.reportObjectPossiblyNullOrUndefinedError)
}

func (tc *TypeChecker) checkNonNullNonVoidType(type_ Type, node Node) Type {
	nonNullType := tc.checkNonNullType(type_, node)
	if nonNullType.flags & TypeFlagsVoid {
		if isEntityNameExpression(node) {
			nodeText := entityNameToString(node)
			if isIdentifier(node) && nodeText == "undefined" {
				tc.error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText)
				return nonNullType
			}
			if nodeText.length < 100 {
				tc.error(node, Diagnostics._0_is_possibly_undefined, nodeText)
				return nonNullType
			}
		}
		tc.error(node, Diagnostics.Object_is_possibly_undefined)
	}
	return nonNullType
}

func (tc *TypeChecker) checkPropertyAccessExpression(node PropertyAccessExpression, checkMode *CheckMode, writeOnly bool) Type {
	if node.flags & NodeFlagsOptionalChain {
		return tc.checkPropertyAccessChain(node /* as PropertyAccessChain */, checkMode)
	} else {
		return tc.checkPropertyAccessExpressionOrQualifiedName(node, node.expression, tc.checkNonNullExpression(node.expression), node.name, checkMode, writeOnly)
	}
}

func (tc *TypeChecker) checkPropertyAccessChain(node PropertyAccessChain, checkMode *CheckMode) Type {
	leftType := tc.checkExpression(node.expression)
	nonOptionalType := tc.getOptionalExpressionType(leftType, node.expression)
	return tc.propagateOptionalTypeMarker(tc.checkPropertyAccessExpressionOrQualifiedName(node, node.expression, tc.checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType != leftType)
}

func (tc *TypeChecker) checkQualifiedName(node QualifiedName, checkMode *CheckMode) Type {
	var leftType Type
	if isPartOfTypeQuery(node) && isThisIdentifier(node.left) {
		leftType = tc.checkNonNullType(tc.checkThisExpression(node.left), node.left)
	} else {
		leftType = tc.checkNonNullExpression(node.left)
	}
	return tc.checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode)
}

func (tc *TypeChecker) isMethodAccessForCall(node Node) bool {
	for node.parent.kind == SyntaxKindParenthesizedExpression {
		node = node.parent
	}
	return isCallOrNewExpression(node.parent) && node.parent.expression == node
}

// Lookup the private identifier lexically.
func (tc *TypeChecker) lookupSymbolForPrivateIdentifierDeclaration(propName __String, location Node) Symbol {
	for containingClass := getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass) {
		TODO_IDENTIFIER := containingClass
		name := getSymbolNameForPrivateIdentifier(symbol, propName)
		prop := (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name))
		if prop {
			return prop
		}
	}
}

func (tc *TypeChecker) checkGrammarPrivateIdentifierExpression(privId PrivateIdentifier) bool {
	if !getContainingClass(privId) {
		return tc.grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
	}

	if !isForInStatement(privId.parent) {
		if !isExpressionNode(privId) {
			return tc.grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression)
		}

		isInOperation := isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind == SyntaxKindInKeyword
		if !tc.getSymbolForPrivateIdentifierExpression(privId) && !isInOperation {
			return tc.grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId))
		}
	}

	return false
}

func (tc *TypeChecker) checkPrivateIdentifierExpression(privId PrivateIdentifier) Type {
	tc.checkGrammarPrivateIdentifierExpression(privId)
	symbol := tc.getSymbolForPrivateIdentifierExpression(privId)
	if symbol {
		tc.markPropertyAsReferenced(symbol /*nodeForCheckWriteOnly*/, nil /*isSelfTypeAccess*/, false)
	}
	return tc.anyType
}

func (tc *TypeChecker) getSymbolForPrivateIdentifierExpression(privId PrivateIdentifier) Symbol {
	if !isExpressionNode(privId) {
		return nil
	}

	links := tc.getNodeLinks(privId)
	if links.resolvedSymbol == nil {
		links.resolvedSymbol = tc.lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId)
	}
	return links.resolvedSymbol
}

func (tc *TypeChecker) getPrivateIdentifierPropertyOfType(leftType Type, lexicallyScopedIdentifier Symbol) Symbol {
	return tc.getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName)
}

func (tc *TypeChecker) checkPrivateIdentifierPropertyAccess(leftType Type, right PrivateIdentifier, lexicallyScopedIdentifier Symbol) bool {
	// Either the identifier could not be looked up in the lexical scope OR the lexically scoped identifier did not exist on the type.
	// Find a private identifier with the same description on the type.
	var propertyOnType Symbol
	properties := tc.getPropertiesOfType(leftType)
	if properties {
		forEach(properties, func(symbol Symbol) *true {
			decl := symbol.valueDeclaration
			if decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText == right.escapedText {
				propertyOnType = symbol
				return true
			}
		})
	}
	diagName := tc.diagnosticName(right)
	if propertyOnType {
		typeValueDecl := Debug.checkDefined(propertyOnType.valueDeclaration)
		typeClass := Debug.checkDefined(getContainingClass(typeValueDecl))
		// We found a private identifier property with the same description.
		// Either:
		// - There is a lexically scoped private identifier AND it shadows the one we found on the type.
		// - It is an attempt to access the private identifier outside of the class.
		if lexicallyScopedIdentifier. /* ? */ valueDeclaration {
			lexicalValueDecl := lexicallyScopedIdentifier.valueDeclaration
			lexicalClass := getContainingClass(lexicalValueDecl)
			Debug.assert(!!lexicalClass)
			if findAncestor(lexicalClass, func(n Node) bool {
				return typeClass == n
			}) {
				diagnostic := tc.error(right, Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling, diagName, tc.typeToString(leftType))

				addRelatedInfo(diagnostic, createDiagnosticForNode(lexicalValueDecl, Diagnostics.The_shadowing_declaration_of_0_is_defined_here, diagName), createDiagnosticForNode(typeValueDecl, Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName))
				return true
			}
		}
		tc.error(right, Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, tc.diagnosticName(typeClass.name || anon))
		return true
	}
	return false
}

func (tc *TypeChecker) isThisPropertyAccessInConstructor(node /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol) *bool {
	return (tc.isConstructorDeclaredProperty(prop) || isThisProperty(node) && tc.isAutoTypedProperty(prop)) && getThisContainer(node /*includeArrowFunctions*/, true /*includeClassComputedPropertyName*/, false) == tc.getDeclaringConstructor(prop)
}

func (tc *TypeChecker) checkPropertyAccessExpressionOrQualifiedName(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName */ any, left /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, leftType Type, right /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any, checkMode *CheckMode, writeOnly bool) Type {
	parentSymbol := tc.getNodeLinks(left).resolvedSymbol
	assignmentKind := getAssignmentTargetKind(node)
	apparentType := tc.getApparentType(__COND__(assignmentKind != AssignmentKindNone || tc.isMethodAccessForCall(node), tc.getWidenedType(leftType), leftType))
	isAnyLike := tc.isTypeAny(apparentType) || apparentType == tc.silentNeverType
	var prop Symbol
	if isPrivateIdentifier(right) {
		if tc.languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || tc.languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !tc.useDefineForClassFields {
			if assignmentKind != AssignmentKindNone {
				tc.checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldSet)
			}
			if assignmentKind != AssignmentKindDefinite {
				tc.checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldGet)
			}
		}

		lexicallyScopedSymbol := tc.lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
		if assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration) {
			tc.grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right))
		}
		if isAnyLike {
			if lexicallyScopedSymbol {
				if tc.isErrorType(apparentType) {
					return tc.errorType
				} else {
					return apparentType
				}
			}
			if getContainingClassExcludingClassDecorators(right) == nil {
				tc.grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
				return tc.anyType
			}
		}

		prop = lexicallyScopedSymbol && tc.getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol)
		if prop == nil {
			// Check for private-identifier-specific shadowing and lexical-scoping errors.
			if tc.checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol) {
				return tc.errorType
			}
			containingClass := getContainingClassExcludingClassDecorators(right)
			if containingClass && isPlainJsFile(getSourceFileOfNode(containingClass), tc.compilerOptions.checkJs) {
				tc.grammarErrorOnNode(right, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class, idText(right))
			}
		} else {
			isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
			if isSetonlyAccessor && assignmentKind != AssignmentKindDefinite {
				tc.error(node, Diagnostics.Private_accessor_was_defined_without_a_getter)
			}
		}
	} else {
		if isAnyLike {
			if isIdentifier(left) && parentSymbol {
				tc.markLinkedReferences(node, ReferenceHintProperty /*propSymbol*/, nil, leftType)
			}
			if tc.isErrorType(apparentType) {
				return tc.errorType
			} else {
				return apparentType
			}
		}
		prop = tc.getPropertyOfType(apparentType, right.escapedText /*skipObjectFunctionPropertyAugment*/, tc.isConstEnumObjectType(apparentType) /*includeTypeOnlyMembers*/, node.kind == SyntaxKindQualifiedName)
	}
	tc.markLinkedReferences(node, ReferenceHintProperty, prop, leftType)

	var propType Type
	if !prop {
		var indexInfo *IndexInfo
		if !isPrivateIdentifier(right) && (assignmentKind == AssignmentKindNone || !tc.isGenericObjectType(leftType) || isThisTypeParameter(leftType)) {
			indexInfo = tc.getApplicableIndexInfoForName(apparentType, right.escapedText)
		} else {
			indexInfo = nil
		}
		if !(indexInfo && indexInfo.type_) {
			isUncheckedJS := tc.isUncheckedJSSuggestion(node, leftType.symbol /*excludeClasses*/, true)
			if !isUncheckedJS && tc.isJSLiteralType(leftType) {
				return tc.anyType
			}
			if leftType.symbol == tc.globalThisSymbol {
				if tc.globalThisSymbol.exports.has(right.escapedText) && (tc.globalThisSymbol.exports.get(right.escapedText).flags & SymbolFlagsBlockScoped) {
					tc.error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), tc.typeToString(leftType))
				} else if tc.noImplicitAny {
					tc.error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, tc.typeToString(leftType))
				}
				return tc.anyType
			}
			if right.escapedText && !tc.checkAndReportErrorForExtendingInterface(node) {
				tc.reportNonexistentProperty(right, __COND__(isThisTypeParameter(leftType), apparentType, leftType), isUncheckedJS)
			}
			return tc.errorType
		}
		if indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node)) {
			tc.error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, tc.typeToString(apparentType))
		}

		propType = indexInfo.type_
		if tc.compilerOptions.noUncheckedIndexedAccess && getAssignmentTargetKind(node) != AssignmentKindDefinite {
			propType = tc.getUnionType([]Type{propType, tc.missingType})
		}
		if tc.compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node) {
			tc.error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText))
		}
		if indexInfo.declaration && tc.isDeprecatedDeclaration(indexInfo.declaration) {
			tc.addDeprecatedSuggestion(right, []IndexSignatureDeclaration{indexInfo.declaration}, right.escapedText /* as string */)
		}
	} else {
		targetPropSymbol := tc.resolveAliasWithDeprecationCheck(prop, right)
		if tc.isDeprecatedSymbol(targetPropSymbol) && tc.isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations {
			tc.addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.escapedText /* as string */)
		}
		tc.checkPropertyNotUsedBeforeDeclaration(prop, node, right)
		tc.markPropertyAsReferenced(prop, node, tc.isSelfTypeAccess(left, parentSymbol))
		tc.getNodeLinks(node).resolvedSymbol = prop
		tc.checkPropertyAccessibility(node, left.kind == SyntaxKindSuperKeyword, isWriteAccess(node), apparentType, prop)
		if tc.isAssignmentToReadonlyEntity(node /* as Expression */, prop, assignmentKind) {
			tc.error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right))
			return tc.errorType
		}

		switch {
		case tc.isThisPropertyAccessInConstructor(node, prop):
			propType = tc.autoType
		case writeOnly || isWriteOnlyAccess(node):
			propType = tc.getWriteTypeOfSymbol(prop)
		default:
			propType = tc.getTypeOfSymbol(prop)
		}
	}

	return tc.getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
}

/**
 * Determines whether a did-you-mean error should be a suggestion in an unchecked JS file.
 * Only applies to unchecked JS files without checkJS, // @ts-check or // @ts-nocheck
 * It does not suggest when the suggestion:
 * - Is from a global file that is different from the reference file, or
 * - (optionally) Is a class, or is a this.x property access expression
 */

func (tc *TypeChecker) isUncheckedJSSuggestion(node Node, suggestion Symbol, excludeClasses bool) bool {
	file := getSourceFileOfNode(node)
	if file {
		if tc.compilerOptions.checkJs == nil && file.checkJsDirective == nil && (file.scriptKind == ScriptKindJS || file.scriptKind == ScriptKindJSX) {
			declarationFile := forEach(suggestion. /* ? */ declarations, getSourceFileOfNode)
			suggestionHasNoExtendsOrDecorators := !suggestion. /* ? */ valueDeclaration || !isClassLike(suggestion.valueDeclaration) || suggestion.valueDeclaration.heritageClauses. /* ? */ length || classOrConstructorParameterIsDecorated(false, suggestion.valueDeclaration)
			return !(file != declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile)) && !(excludeClasses && suggestion && suggestion.flags&SymbolFlagsClass && suggestionHasNoExtendsOrDecorators) && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword && suggestionHasNoExtendsOrDecorators)
		}
	}
	return false
}

func (tc *TypeChecker) getFlowTypeOfAccessExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol, propType Type, errorNode Node, checkMode *CheckMode) Type {
	// Only compute control flow type if this is a property access expression that isn't an
	// assignment target, and the referenced property was declared as a variable, property,
	// accessor, or optional method.
	assignmentKind := getAssignmentTargetKind(node)
	if assignmentKind == AssignmentKindDefinite {
		return tc.removeMissingType(propType, !!(prop && prop.flags&SymbolFlagsOptional))
	}
	if prop && !(prop.flags & (SymbolFlagsVariable | SymbolFlagsProperty | SymbolFlagsAccessor)) && !(prop.flags&SymbolFlagsMethod && propType.flags&TypeFlagsUnion) && !tc.isDuplicatedCommonJSExport(prop.declarations) {
		return propType
	}
	if propType == tc.autoType {
		return tc.getFlowTypeOfProperty(node, prop)
	}
	propType = tc.getNarrowableTypeForReference(propType, node, checkMode)
	// If strict null checks and strict property initialization checks are enabled, if we have
	// a this.xxx property access, if the property is an instance property without an initializer,
	// and if we are in a constructor of the same class as the property declaration, assume that
	// the property is uninitialized at the top of the control flow.
	assumeUninitialized := false
	if tc.strictNullChecks && tc.strictPropertyInitialization && isAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword {
		declaration := prop && prop.valueDeclaration
		if declaration && tc.isPropertyWithoutInitializer(declaration) {
			if !isStatic(declaration) {
				flowContainer := tc.getControlFlowContainer(node)
				if flowContainer.kind == SyntaxKindConstructor && flowContainer.parent == declaration.parent && !(declaration.flags & NodeFlagsAmbient) {
					assumeUninitialized = true
				}
			}
		}
	} else if tc.strictNullChecks && prop && prop.valueDeclaration && isPropertyAccessExpression(prop.valueDeclaration) && getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) && tc.getControlFlowContainer(node) == tc.getControlFlowContainer(prop.valueDeclaration) {
		assumeUninitialized = true
	}
	flowType := tc.getFlowTypeOfReference(node, propType, __COND__(assumeUninitialized, tc.getOptionalType(propType), propType))
	if assumeUninitialized && !tc.containsUndefinedType(propType) && tc.containsUndefinedType(flowType) {
		tc.error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, tc.symbolToString(prop))
		// Return the declared type to reduce follow-on errors
		return propType
	}
	if assignmentKind {
		return tc.getBaseTypeOfLiteralType(flowType)
	} else {
		return flowType
	}
}

func (tc *TypeChecker) checkPropertyNotUsedBeforeDeclaration(prop Symbol, node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName */ any, right /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any) {
	TODO_IDENTIFIER := prop
	if !valueDeclaration || getSourceFileOfNode(node).isDeclarationFile {
		return
	}

	var diagnosticMessage TODO
	declarationName := idText(right)
	if tc.isInPropertyInitializerOrClassStaticBlock(node) && !tc.isOptionalPropertyDeclaration(valueDeclaration) && !(isAccessExpression(node) && isAccessExpression(node.expression)) && !tc.isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) && !(isMethodDeclaration(valueDeclaration) && tc.getCombinedModifierFlagsCached(valueDeclaration)&ModifierFlagsStatic) && (tc.useDefineForClassFields || !tc.isPropertyDeclaredInAncestorClass(prop)) {
		diagnosticMessage = tc.error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName)
	} else if valueDeclaration.kind == SyntaxKindClassDeclaration && node.parent.kind != SyntaxKindTypeReference && !(valueDeclaration.flags & NodeFlagsAmbient) && !tc.isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) {
		diagnosticMessage = tc.error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName)
	}

	if diagnosticMessage {
		addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName))
	}
}

func (tc *TypeChecker) isInPropertyInitializerOrClassStaticBlock(node Node) bool {
	return !!findAncestor(node, func(node Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		switch node.kind {
		case SyntaxKindPropertyDeclaration:
			return true
		case SyntaxKindPropertyAssignment,
			SyntaxKindMethodDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor,
			SyntaxKindSpreadAssignment,
			SyntaxKindComputedPropertyName,
			SyntaxKindTemplateSpan,
			SyntaxKindJsxExpression,
			SyntaxKindJsxAttribute,
			SyntaxKindJsxAttributes,
			SyntaxKindJsxSpreadAttribute,
			SyntaxKindJsxOpeningElement,
			SyntaxKindExpressionWithTypeArguments,
			SyntaxKindHeritageClause:
			return false
		case SyntaxKindArrowFunction,
			SyntaxKindExpressionStatement:
			if isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent) {
				return true
			} else {
				return "quit"
			}
		default:
			if isExpressionNode(node) {
				return false
			} else {
				return "quit"
			}
		}
	})
}

/**
 * It's possible that "prop.valueDeclaration" is a local declaration, but the property was also declared in a superclass.
 * In that case we won't consider it used before its declaration, because it gets its value from the superclass' declaration.
 */

func (tc *TypeChecker) isPropertyDeclaredInAncestorClass(prop Symbol) bool {
	if !(prop.parent.flags & SymbolFlagsClass) {
		return false
	}
	var classType *InterfaceType = tc.getTypeOfSymbol(prop.parent) /* as InterfaceType */
	for true {
		classType = classType.symbol && tc.getSuperClass(classType) /* as InterfaceType | undefined */
		if !classType {
			return false
		}
		superProperty := tc.getPropertyOfType(classType, prop.escapedName)
		if superProperty && superProperty.valueDeclaration {
			return true
		}
	}
}

func (tc *TypeChecker) getSuperClass(classType InterfaceType) Type {
	x := tc.getBaseTypes(classType)
	if x.length == 0 {
		return nil
	}
	return tc.getIntersectionType(x)
}

func (tc *TypeChecker) reportNonexistentProperty(propNode /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any, containingType Type, isUncheckedJS bool) {
	var errorInfo *DiagnosticMessageChain
	var relatedInfo *Diagnostic
	if !isPrivateIdentifier(propNode) && containingType.flags&TypeFlagsUnion && !(containingType.flags & TypeFlagsPrimitive) {
		for _, subtype := range (containingType /* as UnionType */).types {
			if !tc.getPropertyOfType(subtype, propNode.escapedText) && !tc.getApplicableIndexInfoForName(subtype, propNode.escapedText) {
				errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), tc.typeToString(subtype))
				break
			}
		}
	}
	if tc.typeHasStaticProperty(propNode.escapedText, containingType) {
		propName := declarationNameToString(propNode)
		typeName := tc.typeToString(containingType)
		errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName+"."+propName)
	} else {
		promisedType := tc.getPromisedTypeOfPromise(containingType)
		if promisedType && tc.getPropertyOfType(promisedType, propNode.escapedText) {
			errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), tc.typeToString(containingType))
			relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await)
		} else {
			missingProperty := declarationNameToString(propNode)
			container := tc.typeToString(containingType)
			libSuggestion := tc.getSuggestedLibForNonExistentProperty(missingProperty, containingType)
			if libSuggestion != nil {
				errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion)
			} else {
				suggestion := tc.getSuggestedSymbolForNonexistentProperty(propNode, containingType)
				if suggestion != nil {
					suggestedName := symbolName(suggestion)
					var message DiagnosticMessage
					if isUncheckedJS {
						message = Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2
					} else {
						message = Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2
					}
					errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName)
					relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName)
				} else {
					var diagnostic DiagnosticMessage
					if tc.containerSeemsToBeEmptyDomElement(containingType) {
						diagnostic = Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom
					} else {
						diagnostic = Diagnostics.Property_0_does_not_exist_on_type_1
					}
					errorInfo = chainDiagnosticMessages(tc.elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container)
				}
			}
		}
	}
	resultDiagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo)
	if relatedInfo {
		addRelatedInfo(resultDiagnostic, relatedInfo)
	}
	tc.addErrorOrSuggestion(!isUncheckedJS || errorInfo.code != Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic)
}

func (tc *TypeChecker) containerSeemsToBeEmptyDomElement(containingType Type) *bool {
	return (tc.compilerOptions.lib && !tc.compilerOptions.lib.includes("dom")) && tc.everyContainedType(containingType, func(type_ Type) bool {
		return type_.symbol && regexp.MustParse(`^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$`).test(unescapeLeadingUnderscores(type_.symbol.escapedName))
	}) && tc.isEmptyObjectType(containingType)
}

func (tc *TypeChecker) typeHasStaticProperty(propName __String, containingType Type) bool {
	prop := containingType.symbol && tc.getPropertyOfType(tc.getTypeOfSymbol(containingType.symbol), propName)
	return prop != nil && !!prop.valueDeclaration && isStatic(prop.valueDeclaration)
}

func (tc *TypeChecker) getSuggestedLibForNonExistentName(name /* TODO(TS-TO-GO) TypeNode UnionType: __String | Identifier */ any) *string {
	missingName := tc.diagnosticName(name)
	allFeatures := getScriptTargetFeatures()
	typeFeatures := allFeatures.get(missingName)
	return typeFeatures && firstIterator(typeFeatures.keys())
}

func (tc *TypeChecker) getSuggestedLibForNonExistentProperty(missingProperty string, containingType Type) *string {
	container := tc.getApparentType(containingType).symbol
	if !container {
		return nil
	}
	containingTypeName := symbolName(container)
	allFeatures := getScriptTargetFeatures()
	typeFeatures := allFeatures.get(containingTypeName)
	if typeFeatures {
		for _, TODO_IDENTIFIER := range typeFeatures {
			if contains(featuresOfType, missingProperty) {
				return libTarget
			}
		}
	}
}

func (tc *TypeChecker) getSuggestedSymbolForNonexistentClassMember(name string, baseType Type) Symbol {
	return tc.getSpellingSuggestionForName(name, tc.getPropertiesOfType(baseType), SymbolFlagsClassMember)
}

func (tc *TypeChecker) getSuggestedSymbolForNonexistentProperty(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | string */ any, containingType Type) Symbol {
	props := tc.getPropertiesOfType(containingType)
	if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof name */ TODO != "string" {
		parent := name.parent
		if isPropertyAccessExpression(parent) {
			props = filter(props, func(prop Symbol) bool {
				return tc.isValidPropertyAccessForCompletions(parent, containingType, prop)
			})
		}
		name = idText(name)
	}
	return tc.getSpellingSuggestionForName(name, props, SymbolFlagsValue)
}

func (tc *TypeChecker) getSuggestedSymbolForNonexistentJSXAttribute(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | string */ any, containingType Type) Symbol {
	var strName string
	if isString(name) {
		strName = name
	} else {
		strName = idText(name)
	}
	properties := tc.getPropertiesOfType(containingType)
	var jsxSpecific Symbol
	switch {
	case strName == "for":
		jsxSpecific = find(properties, func(x Symbol) bool {
			return symbolName(x) == "htmlFor"
		})
	case strName == "class":
		jsxSpecific = find(properties, func(x Symbol) bool {
			return symbolName(x) == "className"
		})
	default:
		jsxSpecific = nil
	}
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value) */ TODO
}

func (tc *TypeChecker) getSuggestionForNonexistentProperty(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | string */ any, containingType Type) *string {
	suggestion := tc.getSuggestedSymbolForNonexistentProperty(name, containingType)
	return suggestion && symbolName(suggestion)
}

func (tc *TypeChecker) getSuggestionForSymbolNameLookup(symbols SymbolTable, name __String, meaning SymbolFlags) Symbol {
	symbol := tc.getSymbol(symbols, name, meaning)
	// Sometimes the symbol is found when location is a return type of a function: `typeof x` and `x` is declared in the body of the function
	// So the table *contains* `x` but `x` isn't actually in scope.
	// However, resolveNameHelper will continue and call this callback again, so we'll eventually get a correct suggestion.
	if symbol {
		return symbol
	}
	var candidates []Symbol
	if symbols == tc.globals {
		primitives := mapDefined([]string{"string", "number", "boolean", "object", "bigint", "symbol"}, func(s string) Symbol {
			if symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) /* as __String */) {
				return tc.createSymbol(SymbolFlagsTypeAlias, s /* as __String */) /* as Symbol */
			} else {
				return nil
			}
		})
		candidates = primitives.concat(arrayFrom(symbols.values()))
	} else {
		candidates = arrayFrom(symbols.values())
	}
	return tc.getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning)
}

func (tc *TypeChecker) getSuggestedSymbolForNonexistentSymbol(location Node, outerName __String, meaning SymbolFlags) Symbol {
	Debug.assert(outerName != nil, "outername should always be defined")
	result := tc.resolveNameForSymbolSuggestion(location, outerName, meaning /*nameNotFoundMessage*/, nil /*isUse*/, false /*excludeGlobals*/, false)
	return result
}

func (tc *TypeChecker) getSuggestedSymbolForNonexistentModule(name Identifier, targetModule Symbol) Symbol {
	return targetModule.exports && tc.getSpellingSuggestionForName(idText(name), tc.getExportsOfModuleAsArray(targetModule), SymbolFlagsModuleMember)
}

func (tc *TypeChecker) getSuggestionForNonexistentIndexSignature(objectType Type, expr ElementAccessExpression, keyedType Type) *string {
	// check if object type has setter or getter
	hasProp := func(name /* TODO(TS-TO-GO) TypeNode UnionType: "set" | "get" */ any) bool {
		prop := tc.getPropertyOfObjectType(objectType, name /* as __String */)
		if prop {
			s := tc.getSingleCallSignature(tc.getTypeOfSymbol(prop))
			return !!s && tc.getMinArgumentCount(s) >= 1 && tc.isTypeAssignableTo(keyedType, tc.getTypeAtPosition(s, 0))
		}
		return false
	}

	var suggestedMethod /* TODO(TS-TO-GO) inferred type "set" | "get" */ any
	if isAssignmentTarget(expr) {
		suggestedMethod = "set"
	} else {
		suggestedMethod = "get"
	}
	if !hasProp(suggestedMethod) {
		return nil
	}

	suggestion := tryGetPropertyAccessOrIdentifierToString(expr.expression)
	if suggestion == nil {
		suggestion = suggestedMethod
	} else {
		suggestion += "." + suggestedMethod
	}

	return suggestion
}

func (tc *TypeChecker) getSuggestedTypeForNonexistentStringLiteralType(source StringLiteralType, target UnionType) *StringLiteralType {
	candidates := target.types.filter(func(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is StringLiteralType */ any {
		return !!(type_.flags & TypeFlagsStringLiteral)
	})
	return getSpellingSuggestion(source.value, candidates, func(type_ StringLiteralType) string {
		return type_.value
	})
}

/**
 * Given a name and a list of symbols whose names are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
 * Names less than length 3 only check for case-insensitive equality, not levenshtein distance.
 *
 * If there is a candidate that's the same except for case, return that.
 * If there is a candidate that's within one edit of the name, return that.
 * Otherwise, return the candidate with the smallest Levenshtein distance,
 *    except for candidates:
 *      * With no name
 *      * Whose meaning doesn't match the `meaning` parameter.
 *      * Whose length differs from the target name by more than 0.34 of the length of the name.
 *      * Whose levenshtein distance is more than 0.4 of the length of the name
 *        (0.4 allows 1 substitution/transposition for every 5 characters,
 *         and 1 insertion/deletion at 3 characters)
 */

func (tc *TypeChecker) getSpellingSuggestionForName(name string, symbols []Symbol, meaning SymbolFlags) Symbol {
	return getSpellingSuggestion(name, symbols, getCandidateName)

	getCandidateName := func(candidate Symbol) *string {
		candidateName := symbolName(candidate)
		if startsWith(candidateName, "\"") {
			return nil
		}

		if candidate.flags & meaning {
			return candidateName
		}

		if candidate.flags & SymbolFlagsAlias {
			alias := tc.tryResolveAlias(candidate)
			if alias && alias.flags&meaning {
				return candidateName
			}
		}

		return nil
	}

}

func (tc *TypeChecker) markPropertyAsReferenced(prop Symbol, nodeForCheckWriteOnly Node, isSelfTypeAccess bool) {
	valueDeclaration := prop && (prop.flags & SymbolFlagsClassMember) && prop.valueDeclaration
	if !valueDeclaration {
		return
	}
	hasPrivateModifier := hasEffectiveModifier(valueDeclaration, ModifierFlagsPrivate)
	hasPrivateIdentifier := prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name)
	if !hasPrivateModifier && !hasPrivateIdentifier {
		return
	}
	if nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlagsSetAccessor) {
		return
	}
	if tc.isSelfTypeAccess {
		// Find any FunctionLikeDeclaration because those create a new 'this' binding. But this should only matter for methods (or getters/setters).
		containingMethod := findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration)
		if containingMethod && containingMethod.symbol == prop {
			return
		}
	}

	(__COND__(getCheckFlags(prop)&CheckFlagsInstantiated, tc.getSymbolLinks(prop).target, prop)).isReferenced = SymbolFlagsAll
}

func (tc *TypeChecker) isSelfTypeAccess(name /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, parent Symbol) bool {
	return name.kind == SyntaxKindThisKeyword || !!parent && isEntityNameExpression(name) && parent == tc.getResolvedSymbol(getFirstIdentifier(name))
}

func (tc *TypeChecker) isValidPropertyAccess(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName __String) bool {
	switch node.kind {
	case SyntaxKindPropertyAccessExpression:
		return tc.isValidPropertyAccessWithType(node, node.expression.kind == SyntaxKindSuperKeyword, propertyName, tc.getWidenedType(tc.checkExpression(node.expression)))
	case SyntaxKindQualifiedName:
		return tc.isValidPropertyAccessWithType(node /*isSuper*/, false, propertyName, tc.getWidenedType(tc.checkExpression(node.left)))
	case SyntaxKindImportType:
		return tc.isValidPropertyAccessWithType(node /*isSuper*/, false, propertyName, tc.getTypeFromTypeNode(node))
	}
}

/**
 * Checks if an existing property access is valid for completions purposes.
 * @param node a property access-like node where we want to check if we can access a property.
 * This node does not need to be an access of the property we are checking.
 * e.g. in completions, this node will often be an incomplete property access node, as in `foo.`.
 * Besides providing a location (i.e. scope) used to check property accessibility, we use this node for
 * computing whether this is a `super` property access.
 * @param type the type whose property we are checking.
 * @param property the accessed property's symbol.
 */

func (tc *TypeChecker) isValidPropertyAccessForCompletions(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | ImportTypeNode | QualifiedName */ any, type_ Type, property Symbol) bool {
	return tc.isPropertyAccessible(node, node.kind == SyntaxKindPropertyAccessExpression && node.expression.kind == SyntaxKindSuperKeyword /*isWrite*/, false, type_, property)
	// Previously we validated the 'this' type of methods but this adversely affected performance. See #31377 for more context.
}

func (tc *TypeChecker) isValidPropertyAccessWithType(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, isSuper bool, propertyName __String, type_ Type) bool {
	// Short-circuiting for improved performance.
	if tc.isTypeAny(type_) {
		return true
	}

	prop := tc.getPropertyOfType(type_, propertyName)
	return !!prop && tc.isPropertyAccessible(node, isSuper /*isWrite*/, false, type_, prop)
}

/**
 * Checks if a property can be accessed in a location.
 * The location is given by the `node` parameter.
 * The node does not need to be a property access.
 * @param node location where to check property accessibility
 * @param isSuper whether to consider this a `super` property access, e.g. `super.foo`.
 * @param isWrite whether this is a write access, e.g. `++foo.x`.
 * @param containingType type where the property comes from.
 * @param property property symbol.
 */

func (tc *TypeChecker) isPropertyAccessible(node Node, isSuper bool, isWrite bool, containingType Type, property Symbol) bool {
	// Short-circuiting for improved performance.
	if tc.isTypeAny(containingType) {
		return true
	}

	// A #private property access in an optional chain is an error dealt with by the parser.
	// The checker does not check for it, so we need to do our own check here.
	if property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration) {
		declClass := getContainingClass(property.valueDeclaration)
		return !isOptionalChain(node) && !!findAncestor(node, func(parent Node) bool {
			return parent == declClass
		})
	}

	return tc.checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property)
}

/**
 * Return the symbol of the for-in variable declared or referenced by the given for-in statement.
 */

func (tc *TypeChecker) getForInVariableSymbol(node ForInStatement) Symbol {
	initializer := node.initializer
	if initializer.kind == SyntaxKindVariableDeclarationList {
		variable := (initializer /* as VariableDeclarationList */).declarations[0]
		if variable && !isBindingPattern(variable.name) {
			return tc.getSymbolOfDeclaration(variable)
		}
	} else if initializer.kind == SyntaxKindIdentifier {
		return tc.getResolvedSymbol(initializer /* as Identifier */)
	}
	return nil
}

/**
 * Return true if the given type is considered to have numeric property names.
 */

func (tc *TypeChecker) hasNumericPropertyNames(type_ Type) bool {
	return tc.getIndexInfosOfType(type_).length == 1 && !!tc.getIndexInfoOfType(type_, tc.numberType)
}

/**
 * Return true if given node is an expression consisting of an identifier (possibly parenthesized)
 * that references a for-in variable for an object with numeric property names.
 */

func (tc *TypeChecker) isForInVariableForNumericPropertyNames(expr Expression) bool {
	e := skipParentheses(expr)
	if e.kind == SyntaxKindIdentifier {
		symbol := tc.getResolvedSymbol(e /* as Identifier */)
		if symbol.flags & SymbolFlagsVariable {
			var child Node = expr
			node := expr.parent
			for node {
				if node.kind == SyntaxKindForInStatement && child == (node /* as ForInStatement */).statement && tc.getForInVariableSymbol(node /* as ForInStatement */) == symbol && tc.hasNumericPropertyNames(tc.getTypeOfExpression((node /* as ForInStatement */).expression)) {
					return true
				}
				child = node
				node = node.parent
			}
		}
	}
	return false
}

func (tc *TypeChecker) checkIndexedAccess(node ElementAccessExpression, checkMode *CheckMode) Type {
	if node.flags & NodeFlagsOptionalChain {
		return tc.checkElementAccessChain(node /* as ElementAccessChain */, checkMode)
	} else {
		return tc.checkElementAccessExpression(node, tc.checkNonNullExpression(node.expression), checkMode)
	}
}

func (tc *TypeChecker) checkElementAccessChain(node ElementAccessChain, checkMode *CheckMode) Type {
	exprType := tc.checkExpression(node.expression)
	nonOptionalType := tc.getOptionalExpressionType(exprType, node.expression)
	return tc.propagateOptionalTypeMarker(tc.checkElementAccessExpression(node, tc.checkNonNullType(nonOptionalType, node.expression), checkMode), node, nonOptionalType != exprType)
}

func (tc *TypeChecker) checkElementAccessExpression(node ElementAccessExpression, exprType Type, checkMode *CheckMode) Type {
	var objectType Type
	if getAssignmentTargetKind(node) != AssignmentKindNone || tc.isMethodAccessForCall(node) {
		objectType = tc.getWidenedType(exprType)
	} else {
		objectType = exprType
	}
	indexExpression := node.argumentExpression
	indexType := tc.checkExpression(indexExpression)

	if tc.isErrorType(objectType) || objectType == tc.silentNeverType {
		return objectType
	}

	if tc.isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) {
		tc.error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal)
		return tc.errorType
	}

	var effectiveIndexType Type
	if tc.isForInVariableForNumericPropertyNames(indexExpression) {
		effectiveIndexType = tc.numberType
	} else {
		effectiveIndexType = indexType
	}
	assignmentTargetKind := getAssignmentTargetKind(node)
	var accessFlags AccessFlags
	if assignmentTargetKind == AssignmentKindNone {
		accessFlags = AccessFlagsExpressionPosition
	} else {
		accessFlags = AccessFlagsWriting | (__COND__(tc.isGenericObjectType(objectType) && !isThisTypeParameter(objectType), AccessFlagsNoIndexSignatures, 0))
		if assignmentTargetKind == AssignmentKindCompound {
			accessFlags |= AccessFlagsExpressionPosition
		}
	}
	indexedAccessType := tc.getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || tc.errorType
	return tc.checkIndexedAccessIndexType(tc.getFlowTypeOfAccessExpression(node, tc.getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node)
}

func (tc *TypeChecker) callLikeExpressionMayHaveTypeArguments(node CallLikeExpression) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement */ any {
	return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node)
}

func (tc *TypeChecker) resolveUntypedCall(node CallLikeExpression) Signature {
	if tc.callLikeExpressionMayHaveTypeArguments(node) {
		// Check type arguments even though we will give an error that untyped calls may not accept type arguments.
		// This gets us diagnostics for the type arguments and marks them as referenced.
		forEach(node.typeArguments, tc.checkSourceElement)
	}

	if node.kind == SyntaxKindTaggedTemplateExpression {
		tc.checkExpression(node.template)
	} else if isJsxOpeningLikeElement(node) {
		tc.checkExpression(node.attributes)
	} else if isBinaryExpression(node) {
		tc.checkExpression(node.left)
	} else if isCallOrNewExpression(node) {
		forEach(node.arguments, func(argument Expression) {
			tc.checkExpression(argument)
		})
	}
	return tc.anySignature
}

func (tc *TypeChecker) resolveErrorCall(node CallLikeExpression) Signature {
	tc.resolveUntypedCall(node)
	return tc.unknownSignature
}

// Re-order candidate signatures into the result array. Assumes the result array to be empty.
// The candidate list orders groups in reverse, but within a group signatures are kept in declaration order
// A nit here is that we reorder only signatures that belong to the same symbol,
// so order how inherited signatures are processed is still preserved.
// interface A { (x: string): void }
// interface B extends A { (x: 'foo'): string }
// const b: B;
// b('foo') // <- here overloads should be processed as [(x:'foo'): string, (x: string): void]
func (tc *TypeChecker) reorderCandidates(signatures []Signature, result []Signature, callChainFlags SignatureFlags) {
	var lastParent Node
	var lastSymbol Symbol
	cutoffIndex := 0
	var index *number
	specializedIndex := -1
	var spliceIndex number
	Debug.assert(!result.length)
	for _, signature := range signatures {
		symbol := signature.declaration && tc.getSymbolOfDeclaration(signature.declaration)
		parent := signature.declaration && signature.declaration.parent
		if !lastSymbol || symbol == lastSymbol {
			if lastParent && parent == lastParent {
				index = index + 1
			} else {
				lastParent = parent
				index = cutoffIndex
			}
		} else {
			// current declaration belongs to a different symbol
			// set cutoffIndex so re-orderings in the future won't change result set from 0 to cutoffIndex
			index = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: cutoffIndex = result.length */ TODO
			lastParent = parent
		}
		lastSymbol = symbol

		// specialized signatures always need to be placed before non-specialized signatures regardless
		// of the cutoff position; see GH#1133
		if signatureHasLiteralTypes(signature) {
			specializedIndex++
			spliceIndex = specializedIndex
			// The cutoff index always needs to be greater than or equal to the specialized signature index
			// in order to prevent non-specialized signatures from being added before a specialized
			// signature.
			cutoffIndex++
		} else {
			spliceIndex = index
		}

		result.splice(spliceIndex, 0, __COND__(callChainFlags, tc.getOptionalCallSignature(signature, callChainFlags), signature))
	}
}

func (tc *TypeChecker) isSpreadArgument(arg Expression) /* TODO(TS-TO-GO) TypeNode TypePredicate: arg is Expression */ any {
	return !!arg && (arg.kind == SyntaxKindSpreadElement || arg.kind == SyntaxKindSyntheticExpression && (arg /* as SyntheticExpression */).isSpread)
}

func (tc *TypeChecker) getSpreadArgumentIndex(args []Expression) number {
	return findIndex(args, tc.isSpreadArgument)
}

func (tc *TypeChecker) acceptsVoid(t Type) bool {
	return !!(t.flags & TypeFlagsVoid)
}

func (tc *TypeChecker) acceptsVoidUndefinedUnknownOrAny(t Type) bool {
	return !!(t.flags & (TypeFlagsVoid | TypeFlagsUndefined | TypeFlagsUnknown | TypeFlagsAny))
}

func (tc *TypeChecker) hasCorrectArity(node CallLikeExpression, args []Expression, signature Signature, signatureHelpTrailingComma bool /*  = false */) bool {
	var argCount number
	callIsIncomplete := false
	// In incomplete call we want to be lenient when we have too few arguments
	effectiveParameterCount := tc.getParameterCount(signature)
	effectiveMinimumArguments := tc.getMinArgumentCount(signature)

	if node.kind == SyntaxKindTaggedTemplateExpression {
		argCount = args.length
		if node.template.kind == SyntaxKindTemplateExpression {
			// If a tagged template expression lacks a tail literal, the call is incomplete.
			// Specifically, a template only can end in a TemplateTail or a Missing literal.
			lastSpan := last(node.template.templateSpans)
			// we should always have at least one span.
			callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated
		} else {
			// If the template didn't end in a backtick, or its beginning occurred right prior to EOF,
			// then this might actually turn out to be a TemplateHead in the future;
			// so we consider the call to be incomplete.
			templateLiteral := node.template /* as LiteralExpression */
			Debug.assert(templateLiteral.kind == SyntaxKindNoSubstitutionTemplateLiteral)
			callIsIncomplete = !!templateLiteral.isUnterminated
		}
	} else if node.kind == SyntaxKindDecorator {
		argCount = tc.getDecoratorArgumentCount(node, signature)
	} else if node.kind == SyntaxKindBinaryExpression {
		argCount = 1
	} else if isJsxOpeningLikeElement(node) {
		callIsIncomplete = node.attributes.end == node.end
		if callIsIncomplete {
			return true
		}
		if effectiveMinimumArguments == 0 {
			argCount = args.length
		} else {
			argCount = 1
		}
		if args.length == 0 {
			effectiveParameterCount = effectiveParameterCount
		} else {
			effectiveParameterCount = 1
		}
		// class may have argumentless ctor functions - still resolve ctor and compare vs props member type
		effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1)
		// sfc may specify context argument - handled by framework and not typechecked
	} else if !node.arguments {
		// This only happens when we have something of the form: 'new C'
		Debug.assert(node.kind == SyntaxKindNewExpression)
		return tc.getMinArgumentCount(signature) == 0
	} else {
		if signatureHelpTrailingComma {
			argCount = args.length + 1
		} else {
			argCount = args.length
		}

		// If we are missing the close parenthesis, the call is incomplete.
		callIsIncomplete = node.arguments.end == node.end

		// If a spread argument is present, check that it corresponds to a rest parameter or at least that it's in the valid range.
		spreadArgIndex := tc.getSpreadArgumentIndex(args)
		if spreadArgIndex >= 0 {
			return spreadArgIndex >= tc.getMinArgumentCount(signature) && (tc.hasEffectiveRestParameter(signature) || spreadArgIndex < tc.getParameterCount(signature))
		}
	}

	// Too many arguments implies incorrect arity.
	if !tc.hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount {
		return false
	}

	// If the call is incomplete, we should skip the lower bound check.
	// JSX signatures can have extra parameters provided by the library which we don't check
	if callIsIncomplete || argCount >= effectiveMinimumArguments {
		return true
	}
	for i := argCount; i < effectiveMinimumArguments; i++ {
		type_ := tc.getTypeAtPosition(signature, i)
		if tc.filterType(type_, __COND__(isInJSFile(node) && !tc.strictNullChecks, tc.acceptsVoidUndefinedUnknownOrAny, tc.acceptsVoid)).flags & TypeFlagsNever {
			return false
		}
	}
	return true
}

func (tc *TypeChecker) hasCorrectTypeArgumentArity(signature Signature, typeArguments *NodeArray[TypeNode]) bool {
	// If the user supplied type arguments, but the number of type arguments does not match
	// the declared number of type parameters, the call has an incorrect arity.
	numTypeParameters := length(signature.typeParameters)
	minTypeArgumentCount := tc.getMinTypeArgumentCount(signature.typeParameters)
	return !some(typeArguments) || (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters)
}

func (tc *TypeChecker) isInstantiatedGenericParameter(signature Signature, pos number) bool {
	var type_ TODO
	return !!(signature.target && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: type = tryGetTypeAtPosition(signature.target, pos) */ TODO) && tc.isGenericType(type_))
}

// If type has a single call signature and no other members, return that signature. Otherwise, return undefined.
func (tc *TypeChecker) getSingleCallSignature(type_ Type) *Signature {
	return tc.getSingleSignature(type_, SignatureKindCall /*allowMembers*/, false)
}

func (tc *TypeChecker) getSingleCallOrConstructSignature(type_ Type) *Signature {
	return tc.getSingleSignature(type_, SignatureKindCall /*allowMembers*/, false) || tc.getSingleSignature(type_, SignatureKindConstruct /*allowMembers*/, false)
}

func (tc *TypeChecker) getSingleSignature(type_ Type, kind SignatureKind, allowMembers bool) *Signature {
	if type_.flags & TypeFlagsObject {
		resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
		if allowMembers || resolved.properties.length == 0 && resolved.indexInfos.length == 0 {
			if kind == SignatureKindCall && resolved.callSignatures.length == 1 && resolved.constructSignatures.length == 0 {
				return resolved.callSignatures[0]
			}
			if kind == SignatureKindConstruct && resolved.constructSignatures.length == 1 && resolved.callSignatures.length == 0 {
				return resolved.constructSignatures[0]
			}
		}
	}
	return nil
}

// Instantiate a generic signature in the context of a non-generic signature (section 3.8.5 in TypeScript spec)
func (tc *TypeChecker) instantiateSignatureInContextOf(signature Signature, contextualSignature Signature, inferenceContext InferenceContext, compareTypes TypeComparer) Signature {
	context := tc.createInferenceContext(tc.getTypeParametersForMapper(signature), signature, InferenceFlagsNone, compareTypes)
	// We clone the inferenceContext to avoid fixing. For example, when the source signature is <T>(x: T) => T[] and
	// the contextual signature is (...args: A) => B, we want to infer the element type of A's constraint (say 'any')
	// for T but leave it possible to later infer '[any]' back to A.
	restType := tc.getEffectiveRestType(contextualSignature)
	mapper := inferenceContext && (__COND__(restType && restType.flags&TypeFlagsTypeParameter, inferenceContext.nonFixingMapper, inferenceContext.mapper))
	var sourceSignature Signature
	if mapper {
		sourceSignature = tc.instantiateSignature(contextualSignature, mapper)
	} else {
		sourceSignature = contextualSignature
	}
	tc.applyToParameterTypes(sourceSignature, signature, func(source Type, target Type) {
		// Type parameters from outer context referenced by source type are fixed by instantiation of the source type
		tc.inferTypes(context.inferences, source, target)
	})
	if !inferenceContext {
		tc.applyToReturnTypes(contextualSignature, signature, func(source Type, target Type) {
			tc.inferTypes(context.inferences, source, target, InferencePriorityReturnType)
		})
	}
	return tc.getSignatureInstantiation(signature, tc.getInferredTypes(context), isInJSFile(contextualSignature.declaration))
}

func (tc *TypeChecker) inferJsxTypeArguments(node JsxOpeningLikeElement, signature Signature, checkMode CheckMode, context InferenceContext) []Type {
	paramType := tc.getEffectiveFirstArgumentForJsxSignature(signature, node)
	checkAttrType := tc.checkExpressionWithContextualType(node.attributes, paramType, context, checkMode)
	tc.inferTypes(context.inferences, checkAttrType, paramType)
	return tc.getInferredTypes(context)
}

func (tc *TypeChecker) getThisArgumentType(thisArgumentNode Expression) Type {
	if !thisArgumentNode {
		return tc.voidType
	}
	thisArgumentType := tc.checkExpression(thisArgumentNode)
	switch {
	case isRightSideOfInstanceofExpression(thisArgumentNode):
		return thisArgumentType
	case isOptionalChainRoot(thisArgumentNode.parent):
		return tc.getNonNullableType(thisArgumentType)
	case isOptionalChain(thisArgumentNode.parent):
		return tc.removeOptionalTypeMarker(thisArgumentType)
	default:
		return thisArgumentType
	}
}

func (tc *TypeChecker) inferTypeArguments(node CallLikeExpression, signature Signature, args []Expression, checkMode CheckMode, context InferenceContext) []Type {
	if isJsxOpeningLikeElement(node) {
		return tc.inferJsxTypeArguments(node, signature, checkMode, context)
	}

	// If a contextual type is available, infer from that type to the return type of the call expression. For
	// example, given a 'function wrap<T, U>(cb: (x: T) => U): (x: T) => U' and a call expression
	// 'let f: (x: string) => number = wrap(s => s.length)', we infer from the declared type of 'f' to the
	// return type of 'wrap'.
	if node.kind != SyntaxKindDecorator && node.kind != SyntaxKindBinaryExpression {
		skipBindingPatterns := every(signature.typeParameters, func(p TypeParameter) bool {
			return !!tc.getDefaultFromTypeParameter(p)
		})
		contextualType := tc.getContextualType(node, __COND__(skipBindingPatterns, ContextFlagsSkipBindingPatterns, ContextFlagsNone))
		if contextualType {
			inferenceTargetType := tc.getReturnTypeOfSignature(signature)
			if tc.couldContainTypeVariables(inferenceTargetType) {
				outerContext := tc.getInferenceContext(node)
				isFromBindingPattern := !skipBindingPatterns && tc.getContextualType(node, ContextFlagsSkipBindingPatterns) != contextualType
				// A return type inference from a binding pattern can be used in instantiating the contextual
				// type of an argument later in inference, but cannot stand on its own as the final return type.
				// It is incorporated into `context.returnMapper` which is used in `instantiateContextualType`,
				// but doesn't need to go into `context.inferences`. This allows a an array binding pattern to
				// produce a tuple for `T` in
				//   declare function f<T>(cb: () => T): T;
				//   const [e1, e2, e3] = f(() => [1, "hi", true]);
				// but does not produce any inference for `T` in
				//   declare function f<T>(): T;
				//   const [e1, e2, e3] = f();
				if !isFromBindingPattern {
					// We clone the inference context to avoid disturbing a resolution in progress for an
					// outer call expression. Effectively we just want a snapshot of whatever has been
					// inferred for any outer call expression so far.
					outerMapper := tc.getMapperFromContext(tc.cloneInferenceContext(outerContext, InferenceFlagsNoDefault))
					instantiatedType := tc.instantiateType(contextualType, outerMapper)
					// If the contextual type is a generic function type with a single call signature, we
					// instantiate the type with its own type parameters and type arguments. This ensures that
					// the type parameters are not erased to type any during type inference such that they can
					// be inferred as actual types from the contextual type. For example:
					//   declare function arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[];
					//   const boxElements: <A>(a: A[]) => { value: A }[] = arrayMap(value => ({ value }));
					// Above, the type of the 'value' parameter is inferred to be 'A'.
					contextualSignature := tc.getSingleCallSignature(instantiatedType)
					var inferenceSourceType Type
					if contextualSignature && contextualSignature.typeParameters {
						inferenceSourceType = tc.getOrCreateTypeFromSignature(tc.getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters))
					} else {
						inferenceSourceType = instantiatedType
					}
					// Inferences made from return types have lower priority than all other inferences.
					tc.inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriorityReturnType)
				}
				// Create a type mapper for instantiating generic contextual types using the inferences made
				// from the return type. We need a separate inference pass here because (a) instantiation of
				// the source type uses the outer context's return mapper (which excludes inferences made from
				// outer arguments), and (b) we don't want any further inferences going into this context.
				returnContext := tc.createInferenceContext(signature.typeParameters, signature, context.flags)
				returnSourceType := tc.instantiateType(contextualType, outerContext && outerContext.returnMapper)
				tc.inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType)
				if some(returnContext.inferences, tc.hasInferenceCandidates) {
					context.returnMapper = tc.getMapperFromContext(tc.cloneInferredPartOfContext(returnContext))
				} else {
					context.returnMapper = nil
				}
			}
		}
	}

	restType := tc.getNonArrayRestType(signature)
	var argCount number
	if restType {
		argCount = Math.min(tc.getParameterCount(signature)-1, args.length)
	} else {
		argCount = args.length
	}
	if restType && restType.flags&TypeFlagsTypeParameter {
		info := find(context.inferences, func(info InferenceInfo) bool {
			return info.typeParameter == restType
		})
		if info {
			if findIndex(args, tc.isSpreadArgument, argCount) < 0 {
				info.impliedArity = args.length - argCount
			} else {
				info.impliedArity = nil
			}
		}
	}

	thisType := tc.getThisTypeOfSignature(signature)
	if thisType && tc.couldContainTypeVariables(thisType) {
		thisArgumentNode := tc.getThisArgumentOfCall(node)
		tc.inferTypes(context.inferences, tc.getThisArgumentType(thisArgumentNode), thisType)
	}

	for i := 0; i < argCount; i++ {
		arg := args[i]
		if arg.kind != SyntaxKindOmittedExpression {
			paramType := tc.getTypeAtPosition(signature, i)
			if tc.couldContainTypeVariables(paramType) {
				argType := tc.checkExpressionWithContextualType(arg, paramType, context, checkMode)
				tc.inferTypes(context.inferences, argType, paramType)
			}
		}
	}

	if restType && tc.couldContainTypeVariables(restType) {
		spreadType := tc.getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode)
		tc.inferTypes(context.inferences, spreadType, restType)
	}

	return tc.getInferredTypes(context)
}

func (tc *TypeChecker) getMutableArrayOrTupleType(type_ Type) Type {
	switch {
	case type_.flags & TypeFlagsUnion:
		return tc.mapType(type_, tc.getMutableArrayOrTupleType)
	case type_.flags&TypeFlagsAny || tc.isMutableArrayOrTuple(tc.getBaseConstraintOfType(type_) || type_):
		return type_
	case tc.isTupleType(type_):
		return tc.createTupleType(tc.getElementTypes(type_), type_.target.elementFlags /*readonly*/, false, type_.target.labeledElementDeclarations)
	default:
		return tc.createTupleType([]Type{type_}, [] /* TODO(TS-TO-GO) inferred type ElementFlags.Variadic */ any{ElementFlagsVariadic})
	}
}

func (tc *TypeChecker) getSpreadArgumentType(args []Expression, index number, argCount number, restType Type, context *InferenceContext, checkMode CheckMode) Type {
	inConstContext := tc.isConstTypeVariable(restType)

	if index >= argCount-1 {
		arg := args[argCount-1]
		if tc.isSpreadArgument(arg) {
			// We are inferring from a spread expression in the last argument position, i.e. both the parameter
			// and the argument are ...x forms.
			var spreadType Type
			if arg.kind == SyntaxKindSyntheticExpression {
				spreadType = (arg /* as SyntheticExpression */).type_
			} else {
				spreadType = tc.checkExpressionWithContextualType((arg /* as SpreadElement */).expression, restType, context, checkMode)
			}

			if tc.isArrayLikeType(spreadType) {
				return tc.getMutableArrayOrTupleType(spreadType)
			}

			return tc.createArrayType(tc.checkIteratedTypeOrElementType(IterationUseSpread, spreadType, tc.undefinedType, __COND__(arg.kind == SyntaxKindSpreadElement, (arg /* as SpreadElement */).expression, arg)), inConstContext)
		}
	}
	types := []never{}
	flags := []never{}
	names := []never{}
	for i := index; i < argCount; i++ {
		arg := args[i]
		if tc.isSpreadArgument(arg) {
			var spreadType Type
			if arg.kind == SyntaxKindSyntheticExpression {
				spreadType = (arg /* as SyntheticExpression */).type_
			} else {
				spreadType = tc.checkExpression((arg /* as SpreadElement */).expression)
			}
			if tc.isArrayLikeType(spreadType) {
				types.push(spreadType)
				flags.push(ElementFlagsVariadic)
			} else {
				types.push(tc.checkIteratedTypeOrElementType(IterationUseSpread, spreadType, tc.undefinedType, __COND__(arg.kind == SyntaxKindSpreadElement, (arg /* as SpreadElement */).expression, arg)))
				flags.push(ElementFlagsRest)
			}
		} else {
			var contextualType Type
			if tc.isTupleType(restType) {
				contextualType = tc.getContextualTypeForElementExpression(restType, i-index, argCount-index) || tc.unknownType
			} else {
				contextualType = tc.getIndexedAccessType(restType, tc.getNumberLiteralType(i-index), AccessFlagsContextual)
			}
			argType := tc.checkExpressionWithContextualType(arg, contextualType, context, checkMode)
			hasPrimitiveContextualType := inConstContext || tc.maybeTypeOfKind(contextualType, TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
			types.push(__COND__(hasPrimitiveContextualType, tc.getRegularTypeOfLiteralType(argType), tc.getWidenedLiteralType(argType)))
			flags.push(ElementFlagsRequired)
		}
		if arg.kind == SyntaxKindSyntheticExpression && (arg /* as SyntheticExpression */).tupleNameSource {
			names.push((arg /* as SyntheticExpression */).tupleNameSource)
		} else {
			names.push(nil)
		}
	}
	return tc.createTupleType(types, flags, inConstContext && !tc.someType(restType, tc.isMutableArrayLikeType), names)
}

func (tc *TypeChecker) checkTypeArguments(signature Signature, typeArgumentNodes []TypeNode, reportErrors bool, headMessage DiagnosticMessage) *[]Type {
	isJavascript := isInJSFile(signature.declaration)
	typeParameters := signature.typeParameters
	typeArgumentTypes := tc.fillMissingTypeArguments(map_(typeArgumentNodes, tc.getTypeFromTypeNode), typeParameters, tc.getMinTypeArgumentCount(typeParameters), isJavascript)
	var mapper *TypeMapper
	for i := 0; i < typeArgumentNodes.length; i++ {
		Debug.assert(typeParameters[i] != nil, "Should not call checkTypeArguments with too many type arguments")
		constraint := tc.getConstraintOfTypeParameter(typeParameters[i])
		if constraint {
			var errorInfo * /* TODO(TS-TO-GO) inferred type (() => DiagnosticMessageChain) */ any
			if reportErrors && headMessage {
				errorInfo = (func() DiagnosticMessageChain {
					return chainDiagnosticMessages(nil, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
				})
			} else {
				errorInfo = nil
			}
			typeArgumentHeadMessage := headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1
			if !mapper {
				mapper = tc.createTypeMapper(typeParameters, typeArgumentTypes)
			}
			typeArgument := typeArgumentTypes[i]
			if !tc.checkTypeAssignableTo(typeArgument, tc.getTypeWithThisArgument(tc.instantiateType(constraint, mapper), typeArgument), __COND__(reportErrors, typeArgumentNodes[i], nil), typeArgumentHeadMessage, errorInfo) {
				return nil
			}
		}
	}
	return typeArgumentTypes
}

func (tc *TypeChecker) getJsxReferenceKind(node JsxOpeningLikeElement) JsxReferenceKind {
	if tc.isJsxIntrinsicTagName(node.tagName) {
		return JsxReferenceKindMixed
	}
	tagType := tc.getApparentType(tc.checkExpression(node.tagName))
	if length(tc.getSignaturesOfType(tagType, SignatureKindConstruct)) {
		return JsxReferenceKindComponent
	}
	if length(tc.getSignaturesOfType(tagType, SignatureKindCall)) {
		return JsxReferenceKindFunction
	}
	return JsxReferenceKindMixed
}

/**
 * Check if the given signature can possibly be a signature called by the JSX opening-like element.
 * @param node a JSX opening-like element we are trying to figure its call signature
 * @param signature a candidate signature we are trying whether it is a call signature
 * @param relation a relationship to check parameter and argument type
 */

func (tc *TypeChecker) checkApplicableSignatureForJsxOpeningLikeElement(node JsxOpeningLikeElement, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain *func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
	// Stateless function components can have maximum of three arguments: "props", "context", and "updater".
	// However "context" and "updater" are implicit and can't be specify by users. Only the first parameter, props,
	// can be specified by users through attributes property.
	paramType := tc.getEffectiveFirstArgumentForJsxSignature(signature, node)
	attributesType := tc.checkExpressionWithContextualType(node.attributes, paramType /*inferenceContext*/, nil, checkMode)
	var checkAttributesType Type
	if checkMode & CheckModeSkipContextSensitive {
		checkAttributesType = tc.getRegularTypeOfObjectLiteral(attributesType)
	} else {
		checkAttributesType = attributesType
	}
	return checkTagNameDoesNotExpectTooManyArguments() && tc.checkTypeRelatedToAndOptionallyElaborate(checkAttributesType, paramType, relation, __COND__(reportErrors, node.tagName, nil), node.attributes, nil, containingMessageChain, errorOutputContainer)

	checkTagNameDoesNotExpectTooManyArguments := func() bool {
		if tc.getJsxNamespaceContainerForImplicitImport(node) {
			return true
			// factory is implicitly jsx/jsxdev - assume it fits the bill, since we don't strongly look for the jsx/jsxs/jsxDEV factory APIs anywhere else (at least not yet)
		}
		var tagType Type
		if (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(tc.isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)) {
			tagType = tc.checkExpression(node.tagName)
		} else {
			tagType = nil
		}
		if !tagType {
			return true
		}
		tagCallSignatures := tc.getSignaturesOfType(tagType, SignatureKindCall)
		if !length(tagCallSignatures) {
			return true
		}
		factory := tc.getJsxFactoryEntity(node)
		if !factory {
			return true
		}
		factorySymbol := tc.resolveEntityName(factory, SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, false, node)
		if !factorySymbol {
			return true
		}

		factoryType := tc.getTypeOfSymbol(factorySymbol)
		callSignatures := tc.getSignaturesOfType(factoryType, SignatureKindCall)
		if !length(callSignatures) {
			return true
		}

		hasFirstParamSignatures := false
		maxParamCount := 0
		// Check that _some_ first parameter expects a FC-like thing, and that some overload of the SFC expects an acceptable number of arguments
		for _, sig := range callSignatures {
			firstparam := tc.getTypeAtPosition(sig, 0)
			signaturesOfParam := tc.getSignaturesOfType(firstparam, SignatureKindCall)
			if !length(signaturesOfParam) {
				continue
			}
			for _, paramSig := range signaturesOfParam {
				hasFirstParamSignatures = true
				if tc.hasEffectiveRestParameter(paramSig) {
					return true
					// some signature has a rest param, so function components can have an arbitrary number of arguments
				}
				paramCount := tc.getParameterCount(paramSig)
				if paramCount > maxParamCount {
					maxParamCount = paramCount
				}
			}
		}
		if !hasFirstParamSignatures {
			// Not a single signature had a first parameter which expected a signature - for back compat, and
			// to guard against generic factories which won't have signatures directly, do not error
			return true
		}
		absoluteMinArgCount := Infinity
		for _, tagSig := range tagCallSignatures {
			tagRequiredArgCount := tc.getMinArgumentCount(tagSig)
			if tagRequiredArgCount < absoluteMinArgCount {
				absoluteMinArgCount = tagRequiredArgCount
			}
		}
		if absoluteMinArgCount <= maxParamCount {
			return true
			// some signature accepts the number of arguments the function component provides
		}

		if reportErrors {
			diag := createDiagnosticForNode(node.tagName, Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, entityNameToString(node.tagName), absoluteMinArgCount, entityNameToString(factory), maxParamCount)
			tagNameDeclaration := tc.getSymbolAtLocation(node.tagName). /* ? */ valueDeclaration
			if tagNameDeclaration {
				addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(node.tagName)))
			}
			if errorOutputContainer && errorOutputContainer.skipLogging {
				(errorOutputContainer.errors || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
			if !errorOutputContainer.skipLogging {
				tc.diagnostics.add(diag)
			}
		}
		return false
	}

}

func (tc *TypeChecker) getEffectiveCheckNode(argument Expression) Expression {
	argument = skipParentheses(argument)
	if isSatisfiesExpression(argument) {
		return skipParentheses(argument.expression)
	} else {
		return argument
	}
}

func (tc *TypeChecker) getSignatureApplicabilityError(node CallLikeExpression, args []Expression, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain *func() *DiagnosticMessageChain, inferenceContext *InferenceContext) *[]Diagnostic {
	var errorOutputContainer /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors?: Diagnostic[]; skipLogging?: boolean; } */ any = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"errors":      nil,
		"skipLogging": true,
	}
	if isJsxOpeningLikeElement(node) {
		if !tc.checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
			Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors")
			return errorOutputContainer.errors || emptyArray
		}
		return nil
	}
	thisType := tc.getThisTypeOfSignature(signature)
	if thisType && thisType != tc.voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression)) {
		// If the called expression is not of the form `x.f` or `x["f"]`, then sourceType = voidType
		// If the signature's 'this' type is voidType, then the check is skipped -- anything is compatible.
		// If the expression is a new expression or super call expression, then the check is skipped.
		thisArgumentNode := tc.getThisArgumentOfCall(node)
		thisArgumentType := tc.getThisArgumentType(thisArgumentNode)
		var errorNode * /* TODO(TS-TO-GO) inferred type Expression | Decorator */ any
		if reportErrors {
			errorNode = (thisArgumentNode || node)
		} else {
			errorNode = nil
		}
		headMessage := Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1
		if !tc.checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
			Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors")
			return errorOutputContainer.errors || emptyArray
		}
	}
	headMessage := Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
	restType := tc.getNonArrayRestType(signature)
	var argCount number
	if restType {
		argCount = Math.min(tc.getParameterCount(signature)-1, args.length)
	} else {
		argCount = args.length
	}
	for i := 0; i < argCount; i++ {
		arg := args[i]
		if arg.kind != SyntaxKindOmittedExpression {
			paramType := tc.getTypeAtPosition(signature, i)
			argType := tc.checkExpressionWithContextualType(arg, paramType /*inferenceContext*/, nil, checkMode)
			// If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),
			// we obtain the regular type of any object literal arguments because we may not have inferred complete
			// parameter types yet and therefore excess property checks may yield false positives (see #17041).
			var regularArgType Type
			if checkMode & CheckModeSkipContextSensitive {
				regularArgType = tc.getRegularTypeOfObjectLiteral(argType)
			} else {
				regularArgType = argType
			}
			// If this was inferred under a given inference context, we may need to instantiate the expression type to finish resolving
			// the type variables in the expression.
			var checkArgType Type
			if inferenceContext {
				checkArgType = tc.instantiateType(regularArgType, inferenceContext.nonFixingMapper)
			} else {
				checkArgType = regularArgType
			}
			effectiveCheckArgumentNode := tc.getEffectiveCheckNode(arg)
			if !tc.checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, __COND__(reportErrors, effectiveCheckArgumentNode, nil), effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors")
				maybeAddMissingAwaitInfo(arg, checkArgType, paramType)
				return errorOutputContainer.errors || emptyArray
			}
		}
	}
	if restType {
		spreadType := tc.getSpreadArgumentType(args, argCount, args.length, restType /*context*/, nil, checkMode)
		restArgCount := args.length - argCount
		var errorNode * /* TODO(TS-TO-GO) inferred type Expression | Decorator */ any
		switch {
		case !reportErrors:
			errorNode = nil
		case restArgCount == 0:
			errorNode = node
		case restArgCount == 1:
			errorNode = tc.getEffectiveCheckNode(args[argCount])
		default:
			errorNode = setTextRangePosEnd(tc.createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length-1].end)
		}
		if !tc.checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage /*containingMessageChain*/, nil, errorOutputContainer) {
			Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors")
			maybeAddMissingAwaitInfo(errorNode, spreadType, restType)
			return errorOutputContainer.errors || emptyArray
		}
	}
	return nil

	maybeAddMissingAwaitInfo := func(errorNode Node, source Type, target Type) {
		if errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length {
			// Bail if target is Promise-like---something else is wrong
			if tc.getAwaitedTypeOfPromise(target) {
				return
			}
			awaitedTypeOfSource := tc.getAwaitedTypeOfPromise(source)
			if awaitedTypeOfSource && tc.isTypeRelatedTo(awaitedTypeOfSource, target, relation) {
				addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await))
			}
		}
	}

}

/**
 * Returns the this argument in calls like x.f(...) and x[f](...). Undefined otherwise.
 */

func (tc *TypeChecker) getThisArgumentOfCall(node CallLikeExpression) Expression {
	if node.kind == SyntaxKindBinaryExpression {
		return node.right
	}

	var expression *LeftHandSideExpression
	switch {
	case node.kind == SyntaxKindCallExpression:
		expression = node.expression
	case node.kind == SyntaxKindTaggedTemplateExpression:
		expression = node.tag
	case node.kind == SyntaxKindDecorator && !tc.legacyDecorators:
		expression = node.expression
	default:
		expression = nil
	}
	if expression {
		callee := skipOuterExpressions(expression)
		if isAccessExpression(callee) {
			return callee.expression
		}
	}
}

func (tc *TypeChecker) createSyntheticExpression(parent Node, type_ Type, isSpread bool, tupleNameSource /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | NamedTupleMember */ any) SyntheticExpression {
	result := parseNodeFactory.createSyntheticExpression(type_, isSpread, tupleNameSource)
	setTextRangeWorker(result, parent)
	setParent(result, parent)
	return result
}

/**
 * Returns the effective arguments for an expression that works like a function invocation.
 */

func (tc *TypeChecker) getEffectiveCallArguments(node CallLikeExpression) []Expression {
	if node.kind == SyntaxKindTaggedTemplateExpression {
		template := node.template
		var args []Expression = []SyntheticExpression{tc.createSyntheticExpression(template, tc.getGlobalTemplateStringsArrayType())}
		if template.kind == SyntaxKindTemplateExpression {
			forEach(template.templateSpans, func(span TemplateSpan) {
				args.push(span.expression)
			})
		}
		return args
	}
	if node.kind == SyntaxKindDecorator {
		return tc.getEffectiveDecoratorArguments(node)
	}
	if node.kind == SyntaxKindBinaryExpression {
		return []Expression{node.left}
	}
	if isJsxOpeningLikeElement(node) {
		if node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0) {
			return []JsxAttributes{node.attributes}
		} else {
			return emptyArray
		}
	}
	args := node.arguments || emptyArray
	spreadIndex := tc.getSpreadArgumentIndex(args)
	if spreadIndex >= 0 {
		// Create synthetic arguments from spreads of tuple types.
		effectiveArgs := args.slice(0, spreadIndex)
		for i := spreadIndex; i < args.length; i++ {
			arg := args[i]
			// We can call checkExpressionCached because spread expressions never have a contextual type.
			spreadType := arg.kind == SyntaxKindSpreadElement && (__COND__(tc.flowLoopCount, tc.checkExpression((arg /* as SpreadElement */).expression), tc.checkExpressionCached((arg /* as SpreadElement */).expression)))
			if spreadType && tc.isTupleType(spreadType) {
				forEach(tc.getElementTypes(spreadType), func(t Type, i number) {
					flags := spreadType.target.elementFlags[i]
					syntheticArg := tc.createSyntheticExpression(arg, __COND__(flags&ElementFlagsRest, tc.createArrayType(t), t), !!(flags & ElementFlagsVariable), spreadType.target.labeledElementDeclarations[i])
					effectiveArgs.push(syntheticArg)
				})
			} else {
				effectiveArgs.push(arg)
			}
		}
		return effectiveArgs
	}
	return args
}

/**
 * Returns the synthetic argument list for a decorator invocation.
 */

func (tc *TypeChecker) getEffectiveDecoratorArguments(node Decorator) []Expression {
	expr := node.expression
	signature := tc.getDecoratorCallSignature(node)
	if signature {
		var args []Expression = []never{}
		for _, param := range signature.parameters {
			type_ := tc.getTypeOfSymbol(param)
			args.push(tc.createSyntheticExpression(expr, type_))
		}
		return args
	}
	return Debug.fail()
}

/**
 * Returns the argument count for a decorator node that works like a function invocation.
 */

func (tc *TypeChecker) getDecoratorArgumentCount(node Decorator, signature Signature) number {
	if tc.compilerOptions.experimentalDecorators {
		return tc.getLegacyDecoratorArgumentCount(node, signature)
	} else {
		return Math.min(Math.max(tc.getParameterCount(signature), 1), 2)
	}
}

/**
 * Returns the argument count for a decorator node that works like a function invocation.
 */

func (tc *TypeChecker) getLegacyDecoratorArgumentCount(node Decorator, signature Signature) /* TODO(TS-TO-GO) inferred type 1 | 2 | 3 */ any {
	switch node.parent.kind {
	case SyntaxKindClassDeclaration,
		SyntaxKindClassExpression:
		return 1
	case SyntaxKindPropertyDeclaration:
		if hasAccessorModifier(node.parent) {
			return 3
		} else {
			return 2
		}
	case SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor:
		if signature.parameters.length <= 2 {
			return 2
		} else {
			return 3
		}
	case SyntaxKindParameter:
		return 3
	default:
		return Debug.fail()
	}
}

func (tc *TypeChecker) getDiagnosticSpanForCallNode(node CallExpression) /* TODO(TS-TO-GO) inferred type { start: number; length: number; sourceFile: SourceFile; } */ any {
	sourceFile := getSourceFileOfNode(node)
	TODO_IDENTIFIER := getErrorSpanForNode(sourceFile, __COND__(isPropertyAccessExpression(node.expression), node.expression.name, node.expression))
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"start":      start,
		"length":     length,
		"sourceFile": sourceFile,
	}
}

func (tc *TypeChecker) getDiagnosticForCallNode(node CallLikeExpression, message /* TODO(TS-TO-GO) TypeNode UnionType: DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) DiagnosticWithLocation {
	if isCallExpression(node) {
		TODO_IDENTIFIER := tc.getDiagnosticSpanForCallNode(node)
		if /* TODO(TS-TO-GO) InKeyword BinaryExpression: "message" in message */ TODO {
			return createFileDiagnostic(sourceFile, start, length, message, args...)
		}
		return createDiagnosticForFileFromMessageChain(sourceFile, message)
	} else {
		if /* TODO(TS-TO-GO) InKeyword BinaryExpression: "message" in message */ TODO {
			return createDiagnosticForNode(node, message, args...)
		}
		return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message)
	}
}

func (tc *TypeChecker) getErrorNodeForCallNode(callLike CallLikeExpression) Node {
	if isCallOrNewExpression(callLike) {
		if isPropertyAccessExpression(callLike.expression) {
			return callLike.expression.name
		} else {
			return callLike.expression
		}
	}
	if isTaggedTemplateExpression(callLike) {
		if isPropertyAccessExpression(callLike.tag) {
			return callLike.tag.name
		} else {
			return callLike.tag
		}
	}
	if isJsxOpeningLikeElement(callLike) {
		return callLike.tagName
	}
	return callLike
}

func (tc *TypeChecker) isPromiseResolveArityError(node CallLikeExpression) bool {
	if !isCallExpression(node) || !isIdentifier(node.expression) {
		return false
	}

	symbol := tc.resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false)
	decl := symbol. /* ? */ valueDeclaration
	if !decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression) {
		return false
	}

	globalPromiseSymbol := tc.getGlobalPromiseConstructorSymbol(false)
	if !globalPromiseSymbol {
		return false
	}

	constructorSymbol := tc.getSymbolAtLocation(decl.parent.parent.expression /*ignoreErrors*/, true)
	return constructorSymbol == globalPromiseSymbol
}

func (tc *TypeChecker) getArgumentArityError(node CallLikeExpression, signatures []Signature, args []Expression, headMessage DiagnosticMessage) Diagnostic {
	spreadIndex := tc.getSpreadArgumentIndex(args)
	if spreadIndex > -1 {
		return createDiagnosticForNode(args[spreadIndex], Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter)
	}
	min := Number.POSITIVE_INFINITY
	// smallest parameter count
	max := Number.NEGATIVE_INFINITY
	// largest parameter count
	maxBelow := Number.NEGATIVE_INFINITY
	// largest parameter count that is smaller than the number of arguments
	minAbove := Number.POSITIVE_INFINITY
	// smallest parameter count that is larger than the number of arguments

	var closestSignature *Signature
	for _, sig := range signatures {
		minParameter := tc.getMinArgumentCount(sig)
		maxParameter := tc.getParameterCount(sig)
		// smallest/largest parameter counts
		if minParameter < min {
			min = minParameter
			closestSignature = sig
		}
		max = Math.max(max, maxParameter)
		// shortest parameter count *longer than the call*/longest parameter count *shorter than the call*
		if minParameter < args.length && minParameter > maxBelow {
			maxBelow = minParameter
		}
		if args.length < maxParameter && maxParameter < minAbove {
			minAbove = maxParameter
		}
	}
	hasRestParameter := some(signatures, tc.hasEffectiveRestParameter)
	var parameterRange /* TODO(TS-TO-GO) inferred type string | number */ any
	switch {
	case hasRestParameter:
		parameterRange = min
	case min < max:
		parameterRange = min + "-" + max
	default:
		parameterRange = min
	}
	isVoidPromiseError := !hasRestParameter && parameterRange == 1 && args.length == 0 && tc.isPromiseResolveArityError(node)
	if isVoidPromiseError && isInJSFile(node) {
		return tc.getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments)
	}
	var error DiagnosticMessage
	switch {
	case isDecorator(node):
		if hasRestParameter {
			error = Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0
		} else {
			error = Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0
		}
	case hasRestParameter:
		error = Diagnostics.Expected_at_least_0_arguments_but_got_1
	case isVoidPromiseError:
		error = Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise
	default:
		error = Diagnostics.Expected_0_arguments_but_got_1
	}

	if min < args.length && args.length < max {
		// between min and max, but with no matching overload
		if headMessage {
			chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
			chain = chainDiagnosticMessages(chain, headMessage)
			return tc.getDiagnosticForCallNode(node, chain)
		}
		return tc.getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
	} else if args.length < min {
		// too short: put the error span on the call expression, not any of the args
		var diagnostic Diagnostic
		if headMessage {
			chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
			chain = chainDiagnosticMessages(chain, headMessage)
			diagnostic = tc.getDiagnosticForCallNode(node, chain)
		} else {
			diagnostic = tc.getDiagnosticForCallNode(node, error, parameterRange, args.length)
		}
		parameter := closestSignature. /* ? */ declaration. /* ? */ parameters[__COND__(closestSignature.thisParameter, args.length+1, args.length)]
		if parameter {
			var messageAndArgs DiagnosticAndArguments
			switch {
			case isBindingPattern(parameter.name):
				messageAndArgs = []any{Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided}
			case isRestParameter(parameter):
				messageAndArgs = []any{Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))}
			default:
				messageAndArgs = []any{Diagnostics.An_argument_for_0_was_not_provided, __COND__(!parameter.name, args.length, idText(getFirstIdentifier(parameter.name)))}
			}
			parameterError := createDiagnosticForNode(parameter, messageAndArgs...)
			return addRelatedInfo(diagnostic, parameterError)
		}
		return diagnostic
	} else {
		// too long; error goes on the excess parameters
		errorSpan := factory.createNodeArray(args.slice(max))
		pos := first(errorSpan).pos
		end := last(errorSpan).end
		if end == pos {
			end++
		}
		setTextRangePosEnd(errorSpan, pos, end)
		if headMessage {
			chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
			chain = chainDiagnosticMessages(chain, headMessage)
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange, args.length)
	}
}

func (tc *TypeChecker) getTypeArgumentArityError(node Node, signatures []Signature, typeArguments NodeArray[TypeNode], headMessage DiagnosticMessage) DiagnosticWithLocation {
	argCount := typeArguments.length
	// No overloads exist
	if signatures.length == 1 {
		sig := signatures[0]
		min := tc.getMinTypeArgumentCount(sig.typeParameters)
		max := length(sig.typeParameters)
		if headMessage {
			chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(min < max, min+"-"+max, min), argCount)
			chain = chainDiagnosticMessages(chain, headMessage)
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(min < max, min+"-"+max, min), argCount)
	}
	// Overloads exist
	belowArgCount := -Infinity
	aboveArgCount := Infinity
	for _, sig := range signatures {
		min := tc.getMinTypeArgumentCount(sig.typeParameters)
		max := length(sig.typeParameters)
		if min > argCount {
			aboveArgCount = Math.min(aboveArgCount, min)
		} else if max < argCount {
			belowArgCount = Math.max(belowArgCount, max)
		}
	}
	if belowArgCount != -Infinity && aboveArgCount != Infinity {
		if headMessage {
			chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
			chain = chainDiagnosticMessages(chain, headMessage)
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
	}
	if headMessage {
		chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(belowArgCount == -Infinity, aboveArgCount, belowArgCount), argCount)
		chain = chainDiagnosticMessages(chain, headMessage)
		return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
	}
	return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, __COND__(belowArgCount == -Infinity, aboveArgCount, belowArgCount), argCount)
}

func (tc *TypeChecker) resolveCall(node CallLikeExpression, signatures []Signature, candidatesOutArray *[]Signature, checkMode CheckMode, callChainFlags SignatureFlags, headMessage DiagnosticMessage) Signature {
	isTaggedTemplate := node.kind == SyntaxKindTaggedTemplateExpression
	isDecorator := node.kind == SyntaxKindDecorator
	isJsxOpeningOrSelfClosingElement := isJsxOpeningLikeElement(node)
	isInstanceof := node.kind == SyntaxKindBinaryExpression
	reportErrors := !tc.isInferencePartiallyBlocked && !candidatesOutArray

	var typeArguments *NodeArray[TypeNode]

	if !isDecorator && !isInstanceof && !isSuperCall(node) {
		typeArguments = (node /* as CallExpression */).typeArguments

		// We already perform checking on the type arguments on the class declaration itself.
		if isTaggedTemplate || isJsxOpeningOrSelfClosingElement || (node /* as CallExpression */).expression.kind != SyntaxKindSuperKeyword {
			forEach(typeArguments, tc.checkSourceElement)
		}
	}

	candidates := candidatesOutArray || []never{}
	// reorderCandidates fills up the candidates array directly
	tc.reorderCandidates(signatures, candidates, callChainFlags)
	Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this")

	args := tc.getEffectiveCallArguments(node)

	// The excludeArgument array contains true for each context sensitive argument (an argument
	// is context sensitive it is susceptible to a one-time permanent contextual typing).
	//
	// The idea is that we will perform type argument inference & assignability checking once
	// without using the susceptible parameters that are functions, and once more for those
	// parameters, contextually typing each as we go along.
	//
	// For a tagged template, then the first argument be 'undefined' if necessary because it
	// represents a TemplateStringsArray.
	//
	// For a decorator, no arguments are susceptible to contextual typing due to the fact
	// decorators are applied to a declaration by the emitter, and not to an expression.
	isSingleNonGenericCandidate := candidates.length == 1 && !candidates[0].typeParameters
	var argCheckMode CheckMode
	if !isDecorator && !isSingleNonGenericCandidate && some(args, tc.isContextSensitive) {
		argCheckMode = CheckModeSkipContextSensitive
	} else {
		argCheckMode = CheckModeNormal
	}

	// The following variables are captured and modified by calls to chooseOverload.
	// If overload resolution or type argument inference fails, we want to report the
	// best error possible. The best error is one which says that an argument was not
	// assignable to a parameter. This implies that everything else about the overload
	// was fine. So if there is any overload that is only incorrect because of an
	// argument, we will report an error on that one.
	//
	//     function foo(s: string): void;
	//     function foo(n: number): void; // Report argument error on this overload
	//     function foo(): void;
	//     foo(true);
	//
	// If none of the overloads even made it that far, there are two possibilities.
	// There was a problem with type arguments for some overload, in which case
	// report an error on that. Or none of the overloads even had correct arity,
	// in which case give an arity error.
	//
	//     function foo<T extends string>(x: T): void; // Report type argument error
	//     function foo(): void;
	//     foo<number>(0);
	//
	var candidatesForArgumentError *[]Signature
	var candidateForArgumentArityError *Signature
	var candidateForTypeArgumentError *Signature
	var result *Signature

	// If we are in signature help, a trailing comma indicates that we intend to provide another argument,
	// so we will only accept overloads with arity at least 1 higher than the current number of provided arguments.
	signatureHelpTrailingComma := !!(checkMode & CheckModeIsForSignatureHelp) && node.kind == SyntaxKindCallExpression && node.arguments.hasTrailingComma

	// Section 4.12.1:
	// if the candidate list contains one or more signatures for which the type of each argument
	// expression is a subtype of each corresponding parameter type, the return type of the first
	// of those signatures becomes the return type of the function call.
	// Otherwise, the return type of the first signature in the candidate list becomes the return
	// type of the function call.
	//
	// Whether the call is an error is determined by assignability of the arguments. The subtype pass
	// is just important for choosing the best signature. So in the case where there is only one
	// signature, the subtype pass is useless. So skipping it is an optimization.
	if candidates.length > 1 {
		result = chooseOverload(candidates, tc.subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
	}
	if !result {
		result = chooseOverload(candidates, tc.assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
	}
	if result {
		return result
	}

	result = tc.getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode)
	// Preemptively cache the result; getResolvedSignature will do this after we return, but
	// we need to ensure that the result is present for the error checks below so that if
	// this signature is encountered again, we handle the circularity (rather than producing a
	// different result which may produce no errors and assert). Callers of getResolvedSignature
	// don't hit this issue because they only observe this result after it's had a chance to
	// be cached, but the error reporting code below executes before getResolvedSignature sets
	// resolvedSignature.
	tc.getNodeLinks(node).resolvedSignature = result

	// No signatures were applicable. Now report errors based on the last applicable signature with
	// no arguments excluded from assignability checks.
	// If candidate is undefined, it means that no candidates had a suitable arity. In that case,
	// skip the checkApplicableSignature check.
	if reportErrors {
		// If the call expression is a synthetic call to a `[Symbol.hasInstance]` method then we will produce a head
		// message when reporting diagnostics that explains how we got to `right[Symbol.hasInstance](left)` from
		// `left instanceof right`, as it pertains to "Argument" related messages reported for the call.
		if !headMessage && isInstanceof {
			headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method
		}
		if candidatesForArgumentError {
			if candidatesForArgumentError.length == 1 || candidatesForArgumentError.length > 3 {
				last := candidatesForArgumentError[candidatesForArgumentError.length-1]
				var chain *DiagnosticMessageChain
				if candidatesForArgumentError.length > 3 {
					chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error)
					chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call)
				}
				if headMessage {
					chain = chainDiagnosticMessages(chain, headMessage)
				}
				diags := tc.getSignatureApplicabilityError(node, args, last, tc.assignableRelation, CheckModeNormal /*reportErrors*/, true, func() *DiagnosticMessageChain {
					return chain
				}, /*inferenceContext*/ nil)
				if diags {
					for _, d := range diags {
						if last.declaration && candidatesForArgumentError.length > 3 {
							addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here))
						}
						addImplementationSuccessElaboration(last, d)
						tc.diagnostics.add(d)
					}
				} else {
					Debug.fail("No error for last overload signature")
				}
			} else {
				var allDiagnostics [][]DiagnosticRelatedInformation = []never{}
				max := 0
				min := Number.MAX_VALUE
				minIndex := 0
				i := 0
				for _, c := range candidatesForArgumentError {
					chain := func() DiagnosticMessageChain {
						return chainDiagnosticMessages(nil, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i+1, candidates.length, tc.signatureToString(c))
					}
					diags := tc.getSignatureApplicabilityError(node, args, c, tc.assignableRelation, CheckModeNormal /*reportErrors*/, true, chain /*inferenceContext*/, nil)
					if diags {
						if diags.length <= min {
							min = diags.length
							minIndex = i
						}
						max = Math.max(max, diags.length)
						allDiagnostics.push(diags)
					} else {
						Debug.fail("No error for 3 or fewer overload signatures")
					}
					i++
				}

				var diags []DiagnosticRelatedInformation
				if max > 1 {
					diags = allDiagnostics[minIndex]
				} else {
					diags = flatten(allDiagnostics)
				}
				Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures")
				chain := chainDiagnosticMessages(map_(diags, createDiagnosticMessageChainFromDiagnostic), Diagnostics.No_overload_matches_this_call)
				if headMessage {
					chain = chainDiagnosticMessages(chain, headMessage)
				}
				// The below is a spread to guarantee we get a new (mutable) array - our `flatMap` helper tries to do "smart" optimizations where it reuses input
				// arrays and the emptyArray singleton where possible, which is decidedly not what we want while we're still constructing this diagnostic
				related := []DiagnosticRelatedInformation{ /* TODO(TS-TO-GO) Node SpreadElement: ...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[] */ }
				var diag Diagnostic
				if every(diags, func(d DiagnosticRelatedInformation) bool {
					return d.start == diags[0].start && d.length == diags[0].length && d.file == diags[0].file
				}) {
					TODO_IDENTIFIER := diags[0]
					diag = map[any]any{ /* TODO(TS-TO-GO): was object literal */
						"file":               file,
						"start":              start,
						"length":             length,
						"code":               chain.code,
						"category":           chain.category,
						"messageText":        chain,
						"relatedInformation": related,
					}
				} else {
					diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), tc.getErrorNodeForCallNode(node), chain, related)
				}
				addImplementationSuccessElaboration(candidatesForArgumentError[0], diag)
				tc.diagnostics.add(diag)
			}
		} else if candidateForArgumentArityError {
			tc.diagnostics.add(tc.getArgumentArityError(node, []Signature{candidateForArgumentArityError}, args, headMessage))
		} else if candidateForTypeArgumentError {
			tc.checkTypeArguments(candidateForTypeArgumentError, (node /* as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement */).typeArguments /*reportErrors*/, true, headMessage)
		} else {
			signaturesWithCorrectTypeArgumentArity := filter(signatures, func(s Signature) bool {
				return tc.hasCorrectTypeArgumentArity(s, typeArguments)
			})
			if signaturesWithCorrectTypeArgumentArity.length == 0 {
				tc.diagnostics.add(tc.getTypeArgumentArityError(node, signatures, typeArguments, headMessage))
			} else {
				tc.diagnostics.add(tc.getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage))
			}
		}
	}

	return result

	addImplementationSuccessElaboration := func(failed Signature, diagnostic Diagnostic) {
		oldCandidatesForArgumentError := candidatesForArgumentError
		oldCandidateForArgumentArityError := candidateForArgumentArityError
		oldCandidateForTypeArgumentError := candidateForTypeArgumentError

		failedSignatureDeclarations := failed.declaration. /* ? */ symbol. /* ? */ declarations || emptyArray
		isOverload := failedSignatureDeclarations.length > 1
		var implDecl Declaration
		if isOverload {
			implDecl = find(failedSignatureDeclarations, func(d Declaration) bool {
				return isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)
			})
		} else {
			implDecl = nil
		}
		if implDecl {
			candidate := tc.getSignatureFromDeclaration(implDecl /* as FunctionLikeDeclaration */)
			isSingleNonGenericCandidate := !candidate.typeParameters
			if chooseOverload([]Signature{candidate}, tc.assignableRelation, isSingleNonGenericCandidate) {
				addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible))
			}
		}

		candidatesForArgumentError = oldCandidatesForArgumentError
		candidateForArgumentArityError = oldCandidateForArgumentArityError
		candidateForTypeArgumentError = oldCandidateForTypeArgumentError
	}

	chooseOverload := func(candidates []Signature, relation Map[string, RelationComparisonResult], isSingleNonGenericCandidate bool, signatureHelpTrailingComma bool /*  = false */) *Signature {
		candidatesForArgumentError = nil
		candidateForArgumentArityError = nil
		candidateForTypeArgumentError = nil

		if isSingleNonGenericCandidate {
			candidate := candidates[0]
			if some(typeArguments) || !tc.hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
				return nil
			}
			if tc.getSignatureApplicabilityError(node, args, candidate, relation, CheckModeNormal /*reportErrors*/, false /*containingMessageChain*/, nil /*inferenceContext*/, nil) {
				candidatesForArgumentError = []Signature{candidate}
				return nil
			}
			return candidate
		}

		for candidateIndex := 0; candidateIndex < candidates.length; candidateIndex++ {
			candidate := candidates[candidateIndex]
			if !tc.hasCorrectTypeArgumentArity(candidate, typeArguments) || !tc.hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
				continue
			}

			var checkCandidate Signature
			var inferenceContext *InferenceContext

			if candidate.typeParameters {
				// If we are *inside the body of candidate*, we need to create a clone of `candidate` with differing type parameter identities,
				// so our inference results for this call doesn't pollute expression types referencing the outer type parameter!
				paramLocation := candidate.typeParameters[0].symbol.declarations[0]. /* ? */ parent
				candidateParameterContext := paramLocation || (__COND__(candidate.declaration && isConstructorDeclaration(candidate.declaration), candidate.declaration.parent, candidate.declaration))
				if candidateParameterContext && findAncestor(node, func(a Node) bool {
					return a == candidateParameterContext
				}) {
					candidate = tc.getImplementationSignature(candidate)
				}
				var typeArgumentTypes *[]Type
				if some(typeArguments) {
					typeArgumentTypes = tc.checkTypeArguments(candidate, typeArguments /*reportErrors*/, false)
					if !typeArgumentTypes {
						candidateForTypeArgumentError = candidate
						continue
					}
				} else {
					inferenceContext = tc.createInferenceContext(candidate.typeParameters, candidate /*flags*/, __COND__(isInJSFile(node), InferenceFlagsAnyDefault, InferenceFlagsNone))
					// The resulting type arguments are instantiated with the inference context mapper, as the inferred types may still contain references to the inference context's
					//  type variables via contextual projection. These are kept generic until all inferences are locked in, so the dependencies expressed can pass constraint checks.
					typeArgumentTypes = tc.instantiateTypes(tc.inferTypeArguments(node, candidate, args, argCheckMode|CheckModeSkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper)
					if inferenceContext.flags & InferenceFlagsSkippedGenericFunction {
						argCheckMode |= CheckModeSkipGenericFunctions
					} else {
						argCheckMode |= CheckModeNormal
					}
				}
				checkCandidate = tc.getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters)
				// If the original signature has a generic rest type, instantiation may produce a
				// signature with different arity and we need to perform another arity check.
				if tc.getNonArrayRestType(candidate) && !tc.hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma) {
					candidateForArgumentArityError = checkCandidate
					continue
				}
			} else {
				checkCandidate = candidate
			}
			if tc.getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode /*reportErrors*/, false /*containingMessageChain*/, nil, inferenceContext) {
				// Give preference to error candidates that have no rest parameters (as they are more specific)
				(candidatesForArgumentError || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: candidatesForArgumentError = [] */ TODO)).push(checkCandidate)
				continue
			}
			if argCheckMode {
				// If one or more context sensitive arguments were excluded, we start including
				// them now (and keeping do so for any subsequent candidates) and perform a second
				// round of type inference and applicability checking for this particular candidate.
				argCheckMode = CheckModeNormal
				if inferenceContext {
					typeArgumentTypes := tc.instantiateTypes(tc.inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper)
					checkCandidate = tc.getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters)
					// If the original signature has a generic rest type, instantiation may produce a
					// signature with different arity and we need to perform another arity check.
					if tc.getNonArrayRestType(candidate) && !tc.hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma) {
						candidateForArgumentArityError = checkCandidate
						continue
					}
				}
				if tc.getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode /*reportErrors*/, false /*containingMessageChain*/, nil, inferenceContext) {
					// Give preference to error candidates that have no rest parameters (as they are more specific)
					(candidatesForArgumentError || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: candidatesForArgumentError = [] */ TODO)).push(checkCandidate)
					continue
				}
			}
			candidates[candidateIndex] = checkCandidate
			return checkCandidate
		}

		return nil
	}

}

// No signature was applicable. We have already reported the errors for the invalid signature.
func (tc *TypeChecker) getCandidateForOverloadFailure(node CallLikeExpression, candidates []Signature, args []Expression, hasCandidatesOutArray bool, checkMode CheckMode) Signature {
	Debug.assert(candidates.length > 0)
	// Else should not have called this.
	tc.checkNodeDeferred(node)
	// Normally we will combine overloads. Skip this if they have type parameters since that's hard to combine.
	// Don't do this if there is a `candidatesOutArray`,
	// because then we want the chosen best candidate to be one of the overloads, not a combination.
	if hasCandidatesOutArray || candidates.length == 1 || candidates.some(func(c Signature) bool {
		return !!c.typeParameters
	}) {
		return tc.pickLongestCandidateSignature(node, candidates, args, checkMode)
	} else {
		return tc.createUnionOfSignaturesForOverloadFailure(candidates)
	}
}

func (tc *TypeChecker) createUnionOfSignaturesForOverloadFailure(candidates []Signature) Signature {
	thisParameters := mapDefined(candidates, func(c Signature) Symbol {
		return c.thisParameter
	})
	var thisParameter Symbol
	if thisParameters.length {
		thisParameter = tc.createCombinedSymbolFromTypes(thisParameters, thisParameters.map_(tc.getTypeOfParameter))
	}
	TODO_IDENTIFIER := minAndMax(candidates, tc.getNumNonRestParameters)
	var parameters []Symbol = []never{}
	for i := 0; i < maxNonRestParam; i++ {
		symbols := mapDefined(candidates, func(s Signature) Symbol {
			switch {
			case signatureHasRestParameter(s):
				if i < s.parameters.length-1 {
					return s.parameters[i]
				} else {
					return last(s.parameters)
				}
			case i < s.parameters.length:
				return s.parameters[i]
			default:
				return nil
			}
		})
		Debug.assert(symbols.length != 0)
		parameters.push(tc.createCombinedSymbolFromTypes(symbols, mapDefined(candidates, func(candidate Signature) Type {
			return tc.tryGetTypeAtPosition(candidate, i)
		})))
	}
	restParameterSymbols := mapDefined(candidates, func(c Signature) Symbol {
		if signatureHasRestParameter(c) {
			return last(c.parameters)
		} else {
			return nil
		}
	})
	flags := SignatureFlagsIsSignatureCandidateForOverloadFailure
	if restParameterSymbols.length != 0 {
		type_ := tc.createArrayType(tc.getUnionType(mapDefined(candidates, tc.tryGetRestTypeOfSignature), UnionReductionSubtype))
		parameters.push(tc.createCombinedSymbolForOverloadFailure(restParameterSymbols, type_))
		flags |= SignatureFlagsHasRestParameter
	}
	if candidates.some(signatureHasLiteralTypes) {
		flags |= SignatureFlagsHasLiteralTypes
	}
	return tc.createSignature(candidates[0].declaration, nil, thisParameter, parameters, tc.getIntersectionType(candidates.map_(tc.getReturnTypeOfSignature)), nil, minArgumentCount, flags)
}

func (tc *TypeChecker) getNumNonRestParameters(signature Signature) number {
	numParams := signature.parameters.length
	if signatureHasRestParameter(signature) {
		return numParams - 1
	} else {
		return numParams
	}
}

func (tc *TypeChecker) createCombinedSymbolFromTypes(sources []Symbol, types []Type) Symbol {
	return tc.createCombinedSymbolForOverloadFailure(sources, tc.getUnionType(types, UnionReductionSubtype))
}

func (tc *TypeChecker) createCombinedSymbolForOverloadFailure(sources []Symbol, type_ Type) Symbol {
	// This function is currently only used for erroneous overloads, so it's good enough to just use the first source.
	return tc.createSymbolWithType(first(sources), type_)
}

func (tc *TypeChecker) pickLongestCandidateSignature(node CallLikeExpression, candidates []Signature, args []Expression, checkMode CheckMode) Signature {
	// Pick the longest signature. This way we can get a contextual type for cases like:
	//     declare function f(a: { xa: number; xb: number; }, b: number);
	//     f({ |
	// Also, use explicitly-supplied type arguments if they are provided, so we can get a contextual signature in cases like:
	//     declare function f<T>(k: keyof T);
	//     f<Foo>("
	bestIndex := tc.getLongestCandidateIndex(candidates, __COND__(tc.apparentArgumentCount == nil, args.length, tc.apparentArgumentCount))
	candidate := candidates[bestIndex]
	TODO_IDENTIFIER := candidate
	if !typeParameters {
		return candidate
	}

	var typeArgumentNodes *[]TypeNode
	if tc.callLikeExpressionMayHaveTypeArguments(node) {
		typeArgumentNodes = node.typeArguments
	} else {
		typeArgumentNodes = nil
	}
	var instantiated Signature
	if typeArgumentNodes {
		instantiated = tc.createSignatureInstantiation(candidate, tc.getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))
	} else {
		instantiated = tc.inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode)
	}
	candidates[bestIndex] = instantiated
	return instantiated
}

func (tc *TypeChecker) getTypeArgumentsFromNodes(typeArgumentNodes []TypeNode, typeParameters []TypeParameter, isJs bool) []Type {
	typeArguments := typeArgumentNodes.map_(tc.getTypeOfNode)
	for typeArguments.length > typeParameters.length {
		typeArguments.pop()
	}
	for typeArguments.length < typeParameters.length {
		typeArguments.push(tc.getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || tc.getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || tc.getDefaultTypeArgumentType(isJs))
	}
	return typeArguments
}

func (tc *TypeChecker) inferSignatureInstantiationForOverloadFailure(node CallLikeExpression, typeParameters []TypeParameter, candidate Signature, args []Expression, checkMode CheckMode) Signature {
	inferenceContext := tc.createInferenceContext(typeParameters, candidate /*flags*/, __COND__(isInJSFile(node), InferenceFlagsAnyDefault, InferenceFlagsNone))
	typeArgumentTypes := tc.inferTypeArguments(node, candidate, args, checkMode|CheckModeSkipContextSensitive|CheckModeSkipGenericFunctions, inferenceContext)
	return tc.createSignatureInstantiation(candidate, typeArgumentTypes)
}

func (tc *TypeChecker) getLongestCandidateIndex(candidates []Signature, argsCount number) number {
	maxParamsIndex := -1
	maxParams := -1

	for i := 0; i < candidates.length; i++ {
		candidate := candidates[i]
		paramCount := tc.getParameterCount(candidate)
		if tc.hasEffectiveRestParameter(candidate) || paramCount >= argsCount {
			return i
		}
		if paramCount > maxParams {
			maxParams = paramCount
			maxParamsIndex = i
		}
	}

	return maxParamsIndex
}

func (tc *TypeChecker) resolveCallExpression(node CallExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	if node.expression.kind == SyntaxKindSuperKeyword {
		superType := tc.checkSuperExpression(node.expression)
		if tc.isTypeAny(superType) {
			for _, arg := range node.arguments {
				tc.checkExpression(arg)
				// Still visit arguments so they get marked for visibility, etc
			}
			return tc.anySignature
		}
		if !tc.isErrorType(superType) {
			// In super call, the candidate signatures are the matching arity signatures of the base constructor function instantiated
			// with the type arguments specified in the extends clause.
			baseTypeNode := getEffectiveBaseTypeNode(getContainingClass(node))
			if baseTypeNode {
				baseConstructors := tc.getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode)
				return tc.resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlagsNone)
			}
		}
		return tc.resolveUntypedCall(node)
	}

	var callChainFlags SignatureFlags
	funcType := tc.checkExpression(node.expression)
	if isCallChain(node) {
		nonOptionalType := tc.getOptionalExpressionType(funcType, node.expression)
		switch {
		case nonOptionalType == funcType:
			callChainFlags = SignatureFlagsNone
		case isOutermostOptionalChain(node):
			callChainFlags = SignatureFlagsIsOuterCallChain
		default:
			callChainFlags = SignatureFlagsIsInnerCallChain
		}
		funcType = nonOptionalType
	} else {
		callChainFlags = SignatureFlagsNone
	}

	funcType = tc.checkNonNullTypeWithReporter(funcType, node.expression, tc.reportCannotInvokePossiblyNullOrUndefinedError)

	if funcType == tc.silentNeverType {
		return tc.silentNeverSignature
	}

	apparentType := tc.getApparentType(funcType)
	if tc.isErrorType(apparentType) {
		// Another error has already been reported
		return tc.resolveErrorCall(node)
	}

	// Technically, this signatures list may be incomplete. We are taking the apparent type,
	// but we are not including call signatures that may have been added to the Object or
	// Function interface, since they have none by default. This is a bit of a leap of faith
	// that the user will not add any.
	callSignatures := tc.getSignaturesOfType(apparentType, SignatureKindCall)
	numConstructSignatures := tc.getSignaturesOfType(apparentType, SignatureKindConstruct).length

	// TS 1.0 Spec: 4.12
	// In an untyped function call no TypeArgs are permitted, Args can be any argument list, no contextual
	// types are provided for the argument expressions, and the result is always of type Any.
	if tc.isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
		// The unknownType indicates that an error already occurred (and was reported).  No
		// need to report another error in this case.
		if !tc.isErrorType(funcType) && node.typeArguments {
			tc.error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
		}
		return tc.resolveUntypedCall(node)
	}
	// If FuncExpr's apparent type(section 3.8.1) is a function type, the call is a typed function call.
	// TypeScript employs overload resolution in typed function calls in order to support functions
	// with multiple call signatures.
	if !callSignatures.length {
		if numConstructSignatures {
			tc.error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, tc.typeToString(funcType))
		} else {
			var relatedInformation *DiagnosticRelatedInformation
			if node.arguments.length == 1 {
				text := getSourceFileOfNode(node).text
				if isLineBreak(text.charCodeAt(skipTrivia(text, node.expression.end /*stopAfterLineBreak*/, true) - 1)) {
					relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon)
				}
			}
			tc.invocationError(node.expression, apparentType, SignatureKindCall, relatedInformation)
		}
		return tc.resolveErrorCall(node)
	}
	// When a call to a generic function is an argument to an outer call to a generic function for which
	// inference is in process, we have a choice to make. If the inner call relies on inferences made from
	// its contextual type to its return type, deferring the inner call processing allows the best possible
	// contextual type to accumulate. But if the outer call relies on inferences made from the return type of
	// the inner call, the inner call should be processed early. There's no sure way to know which choice is
	// right (only a full unification algorithm can determine that), so we resort to the following heuristic:
	// If no type arguments are specified in the inner call and at least one call signature is generic and
	// returns a function type, we choose to defer processing. This narrowly permits function composition
	// operators to flow inferences through return types, but otherwise processes calls right away. We
	// use the resolvingSignature singleton to indicate that we deferred processing. This result will be
	// propagated out and eventually turned into silentNeverType (a type that is assignable to anything and
	// from which we never make inferences).
	if checkMode&CheckModeSkipGenericFunctions && !node.typeArguments && callSignatures.some(tc.isGenericFunctionReturningFunction) {
		tc.skippedGenericFunction(node, checkMode)
		return tc.resolvingSignature
	}
	// If the function is explicitly marked with `@class`, then it must be constructed.
	if callSignatures.some(func(sig Signature) bool {
		return isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration)
	}) {
		tc.error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, tc.typeToString(funcType))
		return tc.resolveErrorCall(node)
	}

	return tc.resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags)
}

func (tc *TypeChecker) isGenericFunctionReturningFunction(signature Signature) bool {
	return !!(signature.typeParameters && tc.isFunctionType(tc.getReturnTypeOfSignature(signature)))
}

/**
 * TS 1.0 spec: 4.12
 * If FuncExpr is of type Any, or of an object type that has no call or construct signatures
 * but is a subtype of the Function interface, the call is an untyped function call.
 */

func (tc *TypeChecker) isUntypedFunctionCall(funcType Type, apparentFuncType Type, numCallSignatures number, numConstructSignatures number) bool {
	// We exclude union types because we may have a union of function types that happen to have no common signatures.
	return tc.isTypeAny(funcType) || tc.isTypeAny(apparentFuncType) && !!(funcType.flags&TypeFlagsTypeParameter) || !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags&TypeFlagsUnion) && !(tc.getReducedType(apparentFuncType).flags&TypeFlagsNever) && tc.isTypeAssignableTo(funcType, tc.globalFunctionType)
}

func (tc *TypeChecker) resolveNewExpression(node NewExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	expressionType := tc.checkNonNullExpression(node.expression)
	if expressionType == tc.silentNeverType {
		return tc.silentNeverSignature
	}

	// If expressionType's apparent type(section 3.8.1) is an object type with one or
	// more construct signatures, the expression is processed in the same manner as a
	// function call, but using the construct signatures as the initial set of candidate
	// signatures for overload resolution. The result type of the function call becomes
	// the result type of the operation.
	expressionType = tc.getApparentType(expressionType)
	if tc.isErrorType(expressionType) {
		// Another error has already been reported
		return tc.resolveErrorCall(node)
	}

	// TS 1.0 spec: 4.11
	// If expressionType is of type Any, Args can be any argument
	// list and the result of the operation is of type Any.
	if tc.isTypeAny(expressionType) {
		if node.typeArguments {
			tc.error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
		}
		return tc.resolveUntypedCall(node)
	}

	// Technically, this signatures list may be incomplete. We are taking the apparent type,
	// but we are not including construct signatures that may have been added to the Object or
	// Function interface, since they have none by default. This is a bit of a leap of faith
	// that the user will not add any.
	constructSignatures := tc.getSignaturesOfType(expressionType, SignatureKindConstruct)
	if constructSignatures.length {
		if !tc.isConstructorAccessible(node, constructSignatures[0]) {
			return tc.resolveErrorCall(node)
		}
		// If the expression is a class of abstract type, or an abstract construct signature,
		// then it cannot be instantiated.
		// In the case of a merged class-module or class-interface declaration,
		// only the class declaration node will have the Abstract flag set.
		if tc.someSignature(constructSignatures, func(signature Signature) bool {
			return !!(signature.flags & SignatureFlagsAbstract)
		}) {
			tc.error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
			return tc.resolveErrorCall(node)
		}
		valueDecl := expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol)
		if valueDecl && hasSyntacticModifier(valueDecl, ModifierFlagsAbstract) {
			tc.error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
			return tc.resolveErrorCall(node)
		}

		return tc.resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}

	// If expressionType's apparent type is an object type with no construct signatures but
	// one or more call signatures, the expression is processed as a function call. A compile-time
	// error occurs if the result of the function call is not Void. The type of the result of the
	// operation is Any. It is an error to have a Void this type.
	callSignatures := tc.getSignaturesOfType(expressionType, SignatureKindCall)
	if callSignatures.length {
		signature := tc.resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
		if !tc.noImplicitAny {
			if signature.declaration && !tc.isJSConstructor(signature.declaration) && tc.getReturnTypeOfSignature(signature) != tc.voidType {
				tc.error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword)
			}
			if tc.getThisTypeOfSignature(signature) == tc.voidType {
				tc.error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void)
			}
		}
		return signature
	}

	tc.invocationError(node.expression, expressionType, SignatureKindConstruct)
	return tc.resolveErrorCall(node)
}

func (tc *TypeChecker) someSignature(signatures /* TODO(TS-TO-GO) TypeNode UnionType: Signature | readonly Signature[] */ any, f func(s Signature) bool) bool {
	if isArray(signatures) {
		return some(signatures, func(signature Signature) bool {
			return tc.someSignature(signature, f)
		})
	}
	if signatures.compositeKind == TypeFlagsUnion {
		return some(signatures.compositeSignatures, f)
	} else {
		return f(signatures)
	}
}

func (tc *TypeChecker) typeHasProtectedAccessibleBase(target Symbol, type_ InterfaceType) bool {
	baseTypes := tc.getBaseTypes(type_)
	if !length(baseTypes) {
		return false
	}
	firstBase := baseTypes[0]
	if firstBase.flags & TypeFlagsIntersection {
		types := (firstBase /* as IntersectionType */).types
		mixinFlags := tc.findMixins(types)
		i := 0
		for _, intersectionMember := range (firstBase /* as IntersectionType */).types {
			// We want to ignore mixin ctors
			if !mixinFlags[i] {
				if getObjectFlags(intersectionMember) & (ObjectFlagsClass | ObjectFlagsInterface) {
					if intersectionMember.symbol == target {
						return true
					}
					if tc.typeHasProtectedAccessibleBase(target, intersectionMember /* as InterfaceType */) {
						return true
					}
				}
			}
			i++
		}
		return false
	}
	if firstBase.symbol == target {
		return true
	}
	return tc.typeHasProtectedAccessibleBase(target, firstBase /* as InterfaceType */)
}

func (tc *TypeChecker) isConstructorAccessible(node NewExpression, signature Signature) bool {
	if !signature || !signature.declaration {
		return true
	}

	declaration := signature.declaration
	modifiers := getSelectedEffectiveModifierFlags(declaration, ModifierFlagsNonPublicAccessibilityModifier)

	// (1) Public constructors and (2) constructor functions are always accessible.
	if !modifiers || declaration.kind != SyntaxKindConstructor {
		return true
	}

	declaringClassDeclaration := getClassLikeDeclarationOfSymbol(declaration.parent.symbol)
	declaringClass := tc.getDeclaredTypeOfSymbol(declaration.parent.symbol) /* as InterfaceType */

	// A private or protected constructor can only be instantiated within its own class (or a subclass, for protected)
	if !tc.isNodeWithinClass(node, declaringClassDeclaration) {
		containingClass := getContainingClass(node)
		if containingClass && modifiers&ModifierFlagsProtected {
			containingType := tc.getTypeOfNode(containingClass)
			if tc.typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType /* as InterfaceType */) {
				return true
			}
		}
		if modifiers & ModifierFlagsPrivate {
			tc.error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, tc.typeToString(declaringClass))
		}
		if modifiers & ModifierFlagsProtected {
			tc.error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, tc.typeToString(declaringClass))
		}
		return false
	}

	return true
}

func (tc *TypeChecker) invocationErrorDetails(errorTarget Node, apparentType Type, kind SignatureKind) /* TODO(TS-TO-GO) TypeNode TypeLiteral: { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } */ any {
	var errorInfo *DiagnosticMessageChain
	isCall := kind == SignatureKindCall
	awaitedType := tc.getAwaitedType(apparentType)
	maybeMissingAwait := awaitedType && tc.getSignaturesOfType(awaitedType, kind).length > 0
	if apparentType.flags & TypeFlagsUnion {
		types := (apparentType /* as UnionType */).types
		hasSignatures := false
		for _, constituent := range types {
			signatures := tc.getSignaturesOfType(constituent, kind)
			if signatures.length != 0 {
				hasSignatures = true
				if errorInfo {
					// Bail early if we already have an error, no chance of "No constituent of type is callable"
					break
				}
			} else {
				// Error on the first non callable constituent only
				if !errorInfo {
					errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Type_0_has_no_call_signatures, Diagnostics.Type_0_has_no_construct_signatures), tc.typeToString(constituent))
					errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Not_all_constituents_of_type_0_are_callable, Diagnostics.Not_all_constituents_of_type_0_are_constructable), tc.typeToString(apparentType))
				}
				if hasSignatures {
					// Bail early if we already found a siganture, no chance of "No constituent of type is callable"
					break
				}
			}
		}
		if !hasSignatures {
			errorInfo = chainDiagnosticMessages(nil, __COND__(isCall, Diagnostics.No_constituent_of_type_0_is_callable, Diagnostics.No_constituent_of_type_0_is_constructable), tc.typeToString(apparentType))
		}
		if !errorInfo {
			errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other, Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other), tc.typeToString(apparentType))
		}
	} else {
		errorInfo = chainDiagnosticMessages(errorInfo, __COND__(isCall, Diagnostics.Type_0_has_no_call_signatures, Diagnostics.Type_0_has_no_construct_signatures), tc.typeToString(apparentType))
	}

	var headMessage DiagnosticMessage
	if isCall {
		headMessage = Diagnostics.This_expression_is_not_callable
	} else {
		headMessage = Diagnostics.This_expression_is_not_constructable
	}

	// Diagnose get accessors incorrectly called as functions
	if isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length == 0 {
		TODO_IDENTIFIER := tc.getNodeLinks(errorTarget)
		if resolvedSymbol && resolvedSymbol.flags&SymbolFlagsGetAccessor {
			headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without
		}
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"messageChain":   chainDiagnosticMessages(errorInfo, headMessage),
		"relatedMessage": __COND__(maybeMissingAwait, Diagnostics.Did_you_forget_to_use_await, nil),
	}
}

func (tc *TypeChecker) invocationError(errorTarget Node, apparentType Type, kind SignatureKind, relatedInformation DiagnosticRelatedInformation) {
	TODO_IDENTIFIER := tc.invocationErrorDetails(errorTarget, apparentType, kind)
	diagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain)
	if relatedInfo {
		addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo))
	}
	if isCallExpression(errorTarget.parent) {
		TODO_IDENTIFIER := tc.getDiagnosticSpanForCallNode(errorTarget.parent)
		diagnostic.start = start
		diagnostic.length = length
	}
	tc.diagnostics.add(diagnostic)
	tc.invocationErrorRecovery(apparentType, kind, __COND__(relatedInformation, addRelatedInfo(diagnostic, relatedInformation), diagnostic))
}

func (tc *TypeChecker) invocationErrorRecovery(apparentType Type, kind SignatureKind, diagnostic Diagnostic) {
	if !apparentType.symbol {
		return
	}
	importNode := tc.getSymbolLinks(apparentType.symbol).originatingImport
	// Create a diagnostic on the originating import if possible onto which we can attach a quickfix
	//  An import call expression cannot be rewritten into another form to correct the error - the only solution is to use `.default` at the use-site
	if importNode && !isImportCall(importNode) {
		sigs := tc.getSignaturesOfType(tc.getTypeOfSymbol(tc.getSymbolLinks(apparentType.symbol).target), kind)
		if !sigs || !sigs.length {
			return
		}

		addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead))
	}
}

func (tc *TypeChecker) resolveTaggedTemplateExpression(node TaggedTemplateExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	tagType := tc.checkExpression(node.tag)
	apparentType := tc.getApparentType(tagType)

	if tc.isErrorType(apparentType) {
		// Another error has already been reported
		return tc.resolveErrorCall(node)
	}

	callSignatures := tc.getSignaturesOfType(apparentType, SignatureKindCall)
	numConstructSignatures := tc.getSignaturesOfType(apparentType, SignatureKindConstruct).length

	if tc.isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures) {
		return tc.resolveUntypedCall(node)
	}

	if !callSignatures.length {
		if isArrayLiteralExpression(node.parent) {
			diagnostic := createDiagnosticForNode(node.tag, Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked)
			tc.diagnostics.add(diagnostic)
			return tc.resolveErrorCall(node)
		}

		tc.invocationError(node.tag, apparentType, SignatureKindCall)
		return tc.resolveErrorCall(node)
	}

	return tc.resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
}

/**
 * Gets the localized diagnostic head message to use for errors when resolving a decorator as a call expression.
 */

func (tc *TypeChecker) getDiagnosticHeadMessageForDecoratorResolution(node Decorator) DiagnosticMessage {
	switch node.parent.kind {
	case SyntaxKindClassDeclaration,
		SyntaxKindClassExpression:
		return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression
	case SyntaxKindParameter:
		return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression
	case SyntaxKindPropertyDeclaration:
		return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression
	case SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor:
		return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression
	default:
		return Debug.fail()
	}
}

/**
 * Resolves a decorator as if it were a call expression.
 */

func (tc *TypeChecker) resolveDecorator(node Decorator, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	funcType := tc.checkExpression(node.expression)
	apparentType := tc.getApparentType(funcType)
	if tc.isErrorType(apparentType) {
		return tc.resolveErrorCall(node)
	}

	callSignatures := tc.getSignaturesOfType(apparentType, SignatureKindCall)
	numConstructSignatures := tc.getSignaturesOfType(apparentType, SignatureKindConstruct).length
	if tc.isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
		return tc.resolveUntypedCall(node)
	}

	if tc.isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression) {
		nodeStr := getTextOfNode(node.expression /*includeTrivia*/, false)
		tc.error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr)
		return tc.resolveErrorCall(node)
	}

	headMessage := tc.getDiagnosticHeadMessageForDecoratorResolution(node)
	if !callSignatures.length {
		errorDetails := tc.invocationErrorDetails(node.expression, apparentType, SignatureKindCall)
		messageChain := chainDiagnosticMessages(errorDetails.messageChain, headMessage)
		diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node.expression), node.expression, messageChain)
		if errorDetails.relatedMessage {
			addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage))
		}
		tc.diagnostics.add(diag)
		tc.invocationErrorRecovery(apparentType, SignatureKindCall, diag)
		return tc.resolveErrorCall(node)
	}

	return tc.resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone, headMessage)
}

func (tc *TypeChecker) createSignatureForJSXIntrinsic(node JsxOpeningLikeElement, result Type) Signature {
	namespace := tc.getJsxNamespaceAt(node)
	exports := namespace && tc.getExportsOfSymbol(namespace)
	// We fake up a SFC signature for each intrinsic, however a more specific per-element signature drawn from the JSX declaration
	// file would probably be preferable.
	typeSymbol := exports && tc.getSymbol(exports, JsxNames.Element, SymbolFlagsType)
	returnNode := typeSymbol && tc.nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlagsType, node)
	declaration := factory.createFunctionTypeNode(nil, []ParameterDeclaration{factory.createParameterDeclaration(nil /*dotDotDotToken*/, nil, "props" /*questionToken*/, nil, tc.nodeBuilder.typeToTypeNode(result, node))}, __COND__(returnNode, factory.createTypeReferenceNode(returnNode /*typeArguments*/, nil), factory.createKeywordTypeNode(SyntaxKindAnyKeyword)))
	parameterSymbol := tc.createSymbol(SymbolFlagsFunctionScopedVariable, "props" /* as __String */)
	parameterSymbol.links.type_ = result
	return tc.createSignature(declaration, nil, nil, []TransientSymbol{parameterSymbol}, __COND__(typeSymbol, tc.getDeclaredTypeOfSymbol(typeSymbol), tc.errorType), nil, 1, SignatureFlagsNone)
}

func (tc *TypeChecker) resolveJsxOpeningLikeElement(node JsxOpeningLikeElement, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	if tc.isJsxIntrinsicTagName(node.tagName) {
		result := tc.getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node)
		fakeSignature := tc.createSignatureForJSXIntrinsic(node, result)
		tc.checkTypeAssignableToAndOptionallyElaborate(tc.checkExpressionWithContextualType(node.attributes, tc.getEffectiveFirstArgumentForJsxSignature(fakeSignature, node) /*inferenceContext*/, nil, CheckModeNormal), result, node.tagName, node.attributes)
		if length(node.typeArguments) {
			forEach(node.typeArguments, tc.checkSourceElement)
			tc.diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), node.typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments)))
		}
		return fakeSignature
	}
	exprTypes := tc.checkExpression(node.tagName)
	apparentType := tc.getApparentType(exprTypes)
	if tc.isErrorType(apparentType) {
		return tc.resolveErrorCall(node)
	}

	signatures := tc.getUninstantiatedJsxSignaturesOfType(exprTypes, node)
	if tc.isUntypedFunctionCall(exprTypes, apparentType, signatures.length /*constructSignatures*/, 0) {
		return tc.resolveUntypedCall(node)
	}

	if signatures.length == 0 {
		// We found no signatures at all, which is an error
		tc.error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName))
		return tc.resolveErrorCall(node)
	}

	return tc.resolveCall(node, signatures, candidatesOutArray, checkMode, SignatureFlagsNone)
}

func (tc *TypeChecker) resolveInstanceofExpression(node InstanceofExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	// if rightType is an object type with a custom `[Symbol.hasInstance]` method, then it is potentially
	// valid on the right-hand side of the `instanceof` operator. This allows normal `object` types to
	// participate in `instanceof`, as per Step 2 of https://tc39.es/ecma262/#sec-instanceofoperator.
	rightType := tc.checkExpression(node.right)
	if !tc.isTypeAny(rightType) {
		hasInstanceMethodType := tc.getSymbolHasInstanceMethodOfObjectType(rightType)
		if hasInstanceMethodType {
			apparentType := tc.getApparentType(hasInstanceMethodType)
			if tc.isErrorType(apparentType) {
				return tc.resolveErrorCall(node)
			}

			callSignatures := tc.getSignaturesOfType(apparentType, SignatureKindCall)
			constructSignatures := tc.getSignaturesOfType(apparentType, SignatureKindConstruct)
			if tc.isUntypedFunctionCall(hasInstanceMethodType, apparentType, callSignatures.length, constructSignatures.length) {
				return tc.resolveUntypedCall(node)
			}

			if callSignatures.length {
				return tc.resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
			}
		} else if !(tc.typeHasCallOrConstructSignatures(rightType) || tc.isTypeSubtypeOf(rightType, tc.globalFunctionType)) {
			tc.error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method)
			return tc.resolveErrorCall(node)
		}
	}
	// fall back to a default signature
	return tc.anySignature
}

/**
 * Sometimes, we have a decorator that could accept zero arguments,
 * but is receiving too many arguments as part of the decorator invocation.
 * In those cases, a user may have meant to *call* the expression before using it as a decorator.
 */

func (tc *TypeChecker) isPotentiallyUncalledDecorator(decorator Decorator, signatures []Signature) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
	return signatures.length && every(signatures, func(signature Signature) bool {
		return signature.minArgumentCount == 0 && !signatureHasRestParameter(signature) && signature.parameters.length < tc.getDecoratorArgumentCount(decorator, signature)
	})
}

func (tc *TypeChecker) resolveSignature(node CallLikeExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	switch node.kind {
	case SyntaxKindCallExpression:
		return tc.resolveCallExpression(node, candidatesOutArray, checkMode)
	case SyntaxKindNewExpression:
		return tc.resolveNewExpression(node, candidatesOutArray, checkMode)
	case SyntaxKindTaggedTemplateExpression:
		return tc.resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode)
	case SyntaxKindDecorator:
		return tc.resolveDecorator(node, candidatesOutArray, checkMode)
	case SyntaxKindJsxOpeningElement,
		SyntaxKindJsxSelfClosingElement:
		return tc.resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode)
	case SyntaxKindBinaryExpression:
		return tc.resolveInstanceofExpression(node, candidatesOutArray, checkMode)
	}
	Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.")
}

/**
 * Resolve a signature of a given call-like expression.
 * @param node a call-like expression to try resolve a signature for
 * @param candidatesOutArray an array of signature to be filled in by the function. It is passed by signature help in the language service;
 *                           the function will fill it up with appropriate candidate signatures
 * @return a signature of the call-like expression or undefined if one can't be found
 */

func (tc *TypeChecker) getResolvedSignature(node CallLikeExpression, candidatesOutArray *[]Signature, checkMode CheckMode) Signature {
	links := tc.getNodeLinks(node)
	// If getResolvedSignature has already been called, we will have cached the resolvedSignature.
	// However, it is possible that either candidatesOutArray was not passed in the first time,
	// or that a different candidatesOutArray was passed in. Therefore, we need to redo the work
	// to correctly fill the candidatesOutArray.
	cached := links.resolvedSignature
	if cached && cached != tc.resolvingSignature && !candidatesOutArray {
		return cached
	}
	saveResolutionStart := tc.resolutionStart
	if !cached {
		// If we haven't already done so, temporarily reset the resolution stack. This allows us to
		// handle "inverted" situations where, for example, an API client asks for the type of a symbol
		// containined in a function call argument whose contextual type depends on the symbol itself
		// through resolution of the containing function call. By resetting the resolution stack we'll
		// retry the symbol type resolution with the resolvingSignature marker in place to suppress
		// the contextual type circularity.
		tc.resolutionStart = tc.resolutionTargets.length
	}
	links.resolvedSignature = tc.resolvingSignature
	result := tc.resolveSignature(node, candidatesOutArray, checkMode || CheckModeNormal)
	tc.resolutionStart = saveResolutionStart
	// When CheckMode.SkipGenericFunctions is set we use resolvingSignature to indicate that call
	// resolution should be deferred.
	if result != tc.resolvingSignature {
		// if the signature resolution originated on a node that itself depends on the contextual type
		// then it's possible that the resolved signature might not be the same as the one that would be computed in source order
		// since resolving such signature leads to resolving the potential outer signature, its arguments and thus the very same signature
		// it's possible that this inner resolution sets the resolvedSignature first.
		// In such a case we ignore the local result and reuse the correct one that was cached.
		if links.resolvedSignature != tc.resolvingSignature {
			result = links.resolvedSignature
		}
		// If signature resolution originated in control flow type analysis (for example to compute the
		// assigned type in a flow assignment) we don't cache the result as it may be based on temporary
		// types from the control flow analysis.
		if tc.flowLoopStart == tc.flowLoopCount {
			links.resolvedSignature = result
		} else {
			links.resolvedSignature = cached
		}
	}
	return result
}

/**
 * Indicates whether a declaration can be treated as a constructor in a JavaScript
 * file.
 */

func (tc *TypeChecker) isJSConstructor(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is FunctionDeclaration | FunctionExpression */ any {
	if !node || !isInJSFile(node) {
		return false
	}
	var func_ * /* TODO(TS-TO-GO) inferred type FunctionDeclaration | FunctionExpression */ any
	switch {
	case isFunctionDeclaration(node) || isFunctionExpression(node):
		func_ = node
	case (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer):
		func_ = node.initializer
	default:
		func_ = nil
	}
	if func_ {
		// If the node has a @class or @constructor tag, treat it like a constructor.
		if getJSDocClassTag(node) {
			return true
		}

		// If the node is a property of an object literal.
		if isPropertyAssignment(walkUpParenthesizedExpressions(func_.parent)) {
			return false
		}

		// If the symbol of the node has members, treat it like a constructor.
		symbol := tc.getSymbolOfDeclaration(func_)
		return !!symbol. /* ? */ members. /* ? */ size
	}
	return false
}

func (tc *TypeChecker) mergeJSSymbols(target Symbol, source Symbol) *TransientSymbol {
	if source {
		links := tc.getSymbolLinks(source)
		if !links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target)) {
			var inferred TransientSymbol
			if isTransientSymbol(target) {
				inferred = target
			} else {
				inferred = tc.cloneSymbol(target)
			}
			inferred.exports = inferred.exports || createSymbolTable()
			inferred.members = inferred.members || createSymbolTable()
			inferred.flags |= source.flags & SymbolFlagsClass
			if source.exports. /* ? */ size {
				tc.mergeSymbolTable(inferred.exports, source.exports)
			}
			if source.members. /* ? */ size {
				tc.mergeSymbolTable(inferred.members, source.members)
			}
			(links.inferredClassSymbol || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.inferredClassSymbol = new Map() */ TODO)).set(getSymbolId(inferred), inferred)
			return inferred
		}
		return links.inferredClassSymbol.get(getSymbolId(target))
	}
}

func (tc *TypeChecker) getAssignedClassSymbol(decl Declaration) Symbol {
	assignmentSymbol := decl && tc.getSymbolOfExpando(decl /*allowDeclaration*/, true)
	prototype := assignmentSymbol. /* ? */ exports. /* ? */ get("prototype" /* as __String */)
	init := prototype. /* ? */ valueDeclaration && tc.getAssignedJSPrototype(prototype.valueDeclaration)
	if init {
		return tc.getSymbolOfDeclaration(init)
	} else {
		return nil
	}
}

func (tc *TypeChecker) getSymbolOfExpando(node Node, allowDeclaration bool) Symbol {
	if !node.parent {
		return nil
	}
	var name /* TODO(TS-TO-GO) TypeNode UnionType: Expression | BindingName | undefined */ any
	var decl Node
	if isVariableDeclaration(node.parent) && node.parent.initializer == node {
		if !isInJSFile(node) && !(tc.isVarConstLike(node.parent) && isFunctionLikeDeclaration(node)) {
			return nil
		}
		name = node.parent.name
		decl = node.parent
	} else if isBinaryExpression(node.parent) {
		parentNode := node.parent
		parentNodeOperator := node.parent.operatorToken.kind
		if parentNodeOperator == SyntaxKindEqualsToken && (allowDeclaration || parentNode.right == node) {
			name = parentNode.left
			decl = name
		} else if parentNodeOperator == SyntaxKindBarBarToken || parentNodeOperator == SyntaxKindQuestionQuestionToken {
			if isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer == parentNode {
				name = parentNode.parent.name
				decl = parentNode.parent
			} else if isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind == SyntaxKindEqualsToken && (allowDeclaration || parentNode.parent.right == parentNode) {
				name = parentNode.parent.left
				decl = name
			}

			if !name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left) {
				return nil
			}
		}
	} else if allowDeclaration && isFunctionDeclaration(node) {
		name = node.name
		decl = node
	}

	if !decl || !name || (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) {
		return nil
	}
	return tc.getSymbolOfNode(decl)
}

func (tc *TypeChecker) getAssignedJSPrototype(node Node) * /* TODO(TS-TO-GO) inferred type false | ObjectLiteralExpression */ any {
	if !node.parent {
		return false
	}
	var parent Node = node.parent
	for parent && parent.kind == SyntaxKindPropertyAccessExpression {
		parent = parent.parent
	}
	if parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind == SyntaxKindEqualsToken {
		right := getInitializerOfBinaryExpression(parent)
		return isObjectLiteralExpression(right) && right
	}
}

/**
 * Syntactically and semantically checks a call or new expression.
 * @param node The call/new expression to be checked.
 * @returns On success, the expression's signature's return type. On failure, anyType.
 */

func (tc *TypeChecker) checkCallExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: CallExpression | NewExpression */ any, checkMode CheckMode) Type {
	tc.checkGrammarTypeArguments(node, node.typeArguments)

	signature := tc.getResolvedSignature(node /*candidatesOutArray*/, nil, checkMode)
	if signature == tc.resolvingSignature {
		// CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
		// returns a function type. We defer checking and return silentNeverType.
		return tc.silentNeverType
	}

	tc.checkDeprecatedSignature(signature, node)

	if node.expression.kind == SyntaxKindSuperKeyword {
		return tc.voidType
	}

	if node.kind == SyntaxKindNewExpression {
		declaration := signature.declaration

		if declaration && declaration.kind != SyntaxKindConstructor && declaration.kind != SyntaxKindConstructSignature && declaration.kind != SyntaxKindConstructorType && !(isJSDocSignature(declaration) && getJSDocRoot(declaration). /* ? */ parent. /* ? */ kind == SyntaxKindConstructor) && !isJSDocConstructSignature(declaration) && !tc.isJSConstructor(declaration) {
			// When resolved signature is a call signature (and not a construct signature) the result type is any
			if tc.noImplicitAny {
				tc.error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type)
			}
			return tc.anyType
		}
	}

	// In JavaScript files, calls to any identifier 'require' are treated as external module imports
	if isInJSFile(node) && tc.isCommonJsRequire(node) {
		return tc.resolveExternalModuleTypeByLiteral(node.arguments[0] /* as StringLiteral */)
	}

	returnType := tc.getReturnTypeOfSignature(signature)
	// Treat any call to the global 'Symbol' function that is part of a const variable or readonly property
	// as a fresh unique symbol literal type.
	if returnType.flags&TypeFlagsESSymbolLike && tc.isSymbolOrSymbolForCall(node) {
		return tc.getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent))
	}
	if node.kind == SyntaxKindCallExpression && !node.questionDotToken && node.parent.kind == SyntaxKindExpressionStatement && returnType.flags&TypeFlagsVoid && tc.getTypePredicateOfSignature(signature) {
		if !isDottedName(node.expression) {
			tc.error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name)
		} else if !tc.getEffectsSignature(node) {
			diagnostic := tc.error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation)
			tc.getTypeOfDottedName(node.expression, diagnostic)
		}
	}

	if isInJSFile(node) {
		jsSymbol := tc.getSymbolOfExpando(node /*allowDeclaration*/, false)
		if jsSymbol. /* ? */ exports. /* ? */ size {
			jsAssignmentType := tc.createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray)
			jsAssignmentType.objectFlags |= ObjectFlagsJSLiteral
			return tc.getIntersectionType([]Type{returnType, jsAssignmentType})
		}
	}

	return returnType
}

func (tc *TypeChecker) checkDeprecatedSignature(signature Signature, node CallLikeExpression) {
	if signature.flags & SignatureFlagsIsSignatureCandidateForOverloadFailure {
		return
	}
	if signature.declaration && signature.declaration.flags&NodeFlagsDeprecated {
		suggestionNode := tc.getDeprecatedSuggestionNode(node)
		name := tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node))
		tc.addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, tc.signatureToString(signature))
	}
}

func (tc *TypeChecker) getDeprecatedSuggestionNode(node Node) Node {
	node = skipParentheses(node)
	switch node.kind {
	case SyntaxKindCallExpression,
		SyntaxKindDecorator,
		SyntaxKindNewExpression:
		return tc.getDeprecatedSuggestionNode((node /* as Decorator | CallExpression | NewExpression */).expression)
	case SyntaxKindTaggedTemplateExpression:
		return tc.getDeprecatedSuggestionNode((node /* as TaggedTemplateExpression */).tag)
	case SyntaxKindJsxOpeningElement,
		SyntaxKindJsxSelfClosingElement:
		return tc.getDeprecatedSuggestionNode((node /* as JsxOpeningLikeElement */).tagName)
	case SyntaxKindElementAccessExpression:
		return (node /* as ElementAccessExpression */).argumentExpression
	case SyntaxKindPropertyAccessExpression:
		return (node /* as PropertyAccessExpression */).name
	case SyntaxKindTypeReference:
		typeReference := node /* as TypeReferenceNode */
		if isQualifiedName(typeReference.typeName) {
			return typeReference.typeName.right
		} else {
			return typeReference
		}
	default:
		return node
	}
}

func (tc *TypeChecker) isSymbolOrSymbolForCall(node Node) bool {
	if !isCallExpression(node) {
		return false
	}
	left := node.expression
	if isPropertyAccessExpression(left) && left.name.escapedText == "for" {
		left = left.expression
	}
	if !isIdentifier(left) || left.escapedText != "Symbol" {
		return false
	}

	// make sure `Symbol` is the global symbol
	globalESSymbol := tc.getGlobalESSymbolConstructorSymbol(false)
	if !globalESSymbol {
		return false
	}

	return globalESSymbol == tc.resolveName(left, "Symbol" /* as __String */, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false)
}

func (tc *TypeChecker) checkImportCallExpression(node ImportCall) Type {
	// Check grammar of dynamic import
	tc.checkGrammarImportCallExpression(node)

	if node.arguments.length == 0 {
		return tc.createPromiseReturnType(node, tc.anyType)
	}

	specifier := node.arguments[0]
	specifierType := tc.checkExpressionCached(specifier)
	var optionsType Type
	if node.arguments.length > 1 {
		optionsType = tc.checkExpressionCached(node.arguments[1])
	} else {
		optionsType = nil
	}
	// Even though multiple arguments is grammatically incorrect, type-check extra arguments for completion
	for i := 2; i < node.arguments.length; i++ {
		tc.checkExpressionCached(node.arguments[i])
	}

	if specifierType.flags&TypeFlagsUndefined || specifierType.flags&TypeFlagsNull || !tc.isTypeAssignableTo(specifierType, tc.stringType) {
		tc.error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, tc.typeToString(specifierType))
	}

	if optionsType {
		importCallOptionsType := tc.getGlobalImportCallOptionsType(true)
		if importCallOptionsType != tc.emptyObjectType {
			tc.checkTypeAssignableTo(optionsType, tc.getNullableType(importCallOptionsType, TypeFlagsUndefined), node.arguments[1])
		}
	}

	// resolveExternalModuleName will return undefined if the moduleReferenceExpression is not a string literal
	moduleSymbol := tc.resolveExternalModuleName(node, specifier)
	if moduleSymbol {
		esModuleSymbol := tc.resolveESModuleSymbol(moduleSymbol, specifier /*dontResolveAlias*/, true /*suppressInteropError*/, false)
		if esModuleSymbol {
			return tc.createPromiseReturnType(node, tc.getTypeWithSyntheticDefaultOnly(tc.getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) || tc.getTypeWithSyntheticDefaultImportType(tc.getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier))
		}
	}
	return tc.createPromiseReturnType(node, tc.anyType)
}

func (tc *TypeChecker) createDefaultPropertyWrapperForModule(symbol Symbol, originalSymbol Symbol, anonymousSymbol Symbol) ResolvedType {
	memberTable := createSymbolTable()
	newSymbol := tc.createSymbol(SymbolFlagsAlias, InternalSymbolNameDefault)
	newSymbol.parent = originalSymbol
	newSymbol.links.nameType = tc.getStringLiteralType("default")
	newSymbol.links.aliasTarget = tc.resolveSymbol(symbol)
	memberTable.set(InternalSymbolNameDefault, newSymbol)
	return tc.createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray)
}

func (tc *TypeChecker) getTypeWithSyntheticDefaultOnly(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
	hasDefaultOnly := tc.isOnlyImportableAsDefault(moduleSpecifier)
	if hasDefaultOnly && type_ && !tc.isErrorType(type_) {
		synthType := type_ /* as SyntheticDefaultModuleType */
		if !synthType.defaultOnlyType {
			type_ := tc.createDefaultPropertyWrapperForModule(symbol, originalSymbol)
			synthType.defaultOnlyType = type_
		}
		return synthType.defaultOnlyType
	}
	return nil
}

func (tc *TypeChecker) getTypeWithSyntheticDefaultImportType(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
	if tc.allowSyntheticDefaultImports && type_ && !tc.isErrorType(type_) {
		synthType := type_ /* as SyntheticDefaultModuleType */
		if !synthType.syntheticType {
			file := originalSymbol.declarations. /* ? */ find(isSourceFile)
			hasSyntheticDefault := tc.canHaveSyntheticDefault(file, originalSymbol /*dontResolveAlias*/, false, moduleSpecifier)
			if hasSyntheticDefault {
				anonymousSymbol := tc.createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
				defaultContainingObject := tc.createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol)
				anonymousSymbol.links.type_ = defaultContainingObject
				if tc.isValidSpreadType(type_) {
					synthType.syntheticType = tc.getSpreadType(type_, defaultContainingObject, anonymousSymbol /*objectFlags*/, 0 /*readonly*/, false)
				} else {
					synthType.syntheticType = defaultContainingObject
				}
			} else {
				synthType.syntheticType = type_
			}
		}
		return synthType.syntheticType
	}
	return type_
}

func (tc *TypeChecker) isCommonJsRequire(node Node) bool {
	if !isRequireCall(node /*requireStringLiteralLikeArgument*/, true) {
		return false
	}

	// Make sure require is not a local function
	if !isIdentifier(node.expression) {
		return Debug.fail()
	}
	resolvedRequire := tc.resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, true)
	// TODO: GH#18217
	if resolvedRequire == tc.requireSymbol {
		return true
	}
	// project includes symbol named 'require' - make sure that it is ambient and local non-alias
	if resolvedRequire.flags & SymbolFlagsAlias {
		return false
	}

	var targetDeclarationKind /* TODO(TS-TO-GO) inferred type SyntaxKind.Unknown | SyntaxKind.VariableDeclaration | SyntaxKind.FunctionDeclaration */ any
	switch {
	case resolvedRequire.flags & SymbolFlagsFunction:
		targetDeclarationKind = SyntaxKindFunctionDeclaration
	case resolvedRequire.flags & SymbolFlagsVariable:
		targetDeclarationKind = SyntaxKindVariableDeclaration
	default:
		targetDeclarationKind = SyntaxKindUnknown
	}
	if targetDeclarationKind != SyntaxKindUnknown {
		decl := getDeclarationOfKind(resolvedRequire, targetDeclarationKind)
		// function/variable declaration should be ambient
		return !!decl && !!(decl.flags & NodeFlagsAmbient)
	}
	return false
}

func (tc *TypeChecker) checkTaggedTemplateExpression(node TaggedTemplateExpression) Type {
	if !tc.checkGrammarTaggedTemplateChain(node) {
		tc.checkGrammarTypeArguments(node, node.typeArguments)
	}
	if tc.languageVersion < LanguageFeatureMinimumTargetTaggedTemplates {
		tc.checkExternalEmitHelpers(node, ExternalEmitHelpersMakeTemplateObject)
	}
	signature := tc.getResolvedSignature(node)
	tc.checkDeprecatedSignature(signature, node)
	return tc.getReturnTypeOfSignature(signature)
}

func (tc *TypeChecker) checkAssertion(node AssertionExpression, checkMode *CheckMode) Type {
	if node.kind == SyntaxKindTypeAssertionExpression {
		file := getSourceFileOfNode(node)
		if file && fileExtensionIsOneOf(file.fileName, []Extension{ExtensionCts, ExtensionMts}) {
			tc.grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead)
		}
	}
	return tc.checkAssertionWorker(node, checkMode)
}

func (tc *TypeChecker) isValidConstAssertionArgument(node Node) bool {
	switch node.kind {
	case SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindArrayLiteralExpression,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindTemplateExpression:
		return true
	case SyntaxKindParenthesizedExpression:
		return tc.isValidConstAssertionArgument((node /* as ParenthesizedExpression */).expression)
	case SyntaxKindPrefixUnaryExpression:
		op := (node /* as PrefixUnaryExpression */).operator
		arg := (node /* as PrefixUnaryExpression */).operand
		return op == SyntaxKindMinusToken && (arg.kind == SyntaxKindNumericLiteral || arg.kind == SyntaxKindBigIntLiteral) || op == SyntaxKindPlusToken && arg.kind == SyntaxKindNumericLiteral
	case SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		expr := skipParentheses((node /* as PropertyAccessExpression | ElementAccessExpression */).expression)
		var symbol Symbol
		if isEntityNameExpression(expr) {
			symbol = tc.resolveEntityName(expr, SymbolFlagsValue /*ignoreErrors*/, true)
		} else {
			symbol = nil
		}
		return !!(symbol && symbol.flags&SymbolFlagsEnum)
	}
	return false
}

func (tc *TypeChecker) checkAssertionWorker(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeAssertion | AssertionExpression */ any, checkMode *CheckMode) Type {
	TODO_IDENTIFIER := tc.getAssertionTypeAndExpression(node)
	exprType := tc.checkExpression(expression, checkMode)
	if isConstTypeReference(type_) {
		if !tc.isValidConstAssertionArgument(expression) {
			tc.error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals)
		}
		return tc.getRegularTypeOfLiteralType(exprType)
	}
	links := tc.getNodeLinks(node)
	links.assertionExpressionType = exprType
	tc.checkSourceElement(type_)
	tc.checkNodeDeferred(node)
	return tc.getTypeFromTypeNode(type_)
}

func (tc *TypeChecker) getAssertionTypeAndExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeAssertion | AssertionExpression */ any) /* TODO(TS-TO-GO) inferred type { type: TypeNode; expression: Expression; } */ any {
	var type_ TypeNode
	var expression Expression
	switch node.kind {
	case SyntaxKindAsExpression,
		SyntaxKindTypeAssertionExpression:
		type_ = node.type_
		expression = node.expression
	case SyntaxKindParenthesizedExpression:
		type_ = getJSDocTypeAssertionType(node)
		expression = node.expression
	}

	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"type_":      type_,
		"expression": expression,
	}
}

func (tc *TypeChecker) checkAssertionDeferred(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypeAssertion | AssertionExpression */ any) {
	TODO_IDENTIFIER := tc.getAssertionTypeAndExpression(node)
	var errNode /* TODO(TS-TO-GO) inferred type TypeNode | AssertionExpression */ any
	if isParenthesizedExpression(node) {
		errNode = type_
	} else {
		errNode = node
	}
	links := tc.getNodeLinks(node)
	Debug.assertIsDefined(links.assertionExpressionType)
	exprType := tc.getRegularTypeOfObjectLiteral(tc.getBaseTypeOfLiteralType(links.assertionExpressionType))
	targetType := tc.getTypeFromTypeNode(type_)
	if !tc.isErrorType(targetType) {
		tc.addLazyDiagnostic(func() {
			widenedType := tc.getWidenedType(exprType)
			if !tc.isTypeComparableTo(targetType, widenedType) {
				tc.checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first)
			}
		})
	}
}

func (tc *TypeChecker) checkNonNullChain(node NonNullChain) Type {
	leftType := tc.checkExpression(node.expression)
	nonOptionalType := tc.getOptionalExpressionType(leftType, node.expression)
	return tc.propagateOptionalTypeMarker(tc.getNonNullableType(nonOptionalType), node, nonOptionalType != leftType)
}

func (tc *TypeChecker) checkNonNullAssertion(node NonNullExpression) Type {
	if node.flags & NodeFlagsOptionalChain {
		return tc.checkNonNullChain(node /* as NonNullChain */)
	} else {
		return tc.getNonNullableType(tc.checkExpression(node.expression))
	}
}

func (tc *TypeChecker) checkExpressionWithTypeArguments(node /* TODO(TS-TO-GO) TypeNode UnionType: ExpressionWithTypeArguments | TypeQueryNode */ any) Type {
	tc.checkGrammarExpressionWithTypeArguments(node)
	forEach(node.typeArguments, tc.checkSourceElement)
	if node.kind == SyntaxKindExpressionWithTypeArguments {
		parent := walkUpParenthesizedExpressions(node.parent)
		if parent.kind == SyntaxKindBinaryExpression && (parent /* as BinaryExpression */).operatorToken.kind == SyntaxKindInstanceOfKeyword && isNodeDescendantOf(node, (parent /* as BinaryExpression */).right) {
			tc.error(node, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression)
		}
	}
	var exprType Type
	switch {
	case node.kind == SyntaxKindExpressionWithTypeArguments:
		exprType = tc.checkExpression(node.expression)
	case isThisIdentifier(node.exprName):
		exprType = tc.checkThisExpression(node.exprName)
	default:
		exprType = tc.checkExpression(node.exprName)
	}
	return tc.getInstantiationExpressionType(exprType, node)
}

func (tc *TypeChecker) getInstantiationExpressionType(exprType Type, node NodeWithTypeArguments) Type {
	typeArguments := node.typeArguments
	if exprType == tc.silentNeverType || tc.isErrorType(exprType) || !some(typeArguments) {
		return exprType
	}
	hasSomeApplicableSignature := false
	var nonApplicableType Type
	result := getInstantiatedType(exprType)
	var errorType Type
	if hasSomeApplicableSignature {
		errorType = nonApplicableType
	} else {
		errorType = exprType
	}
	if errorType {
		tc.diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, tc.typeToString(errorType)))
	}
	return result

	getInstantiatedType := func(type_ Type) Type {
		hasSignatures := false
		hasApplicableSignature := false
		result := getInstantiatedTypePart(type_)
		hasSomeApplicableSignature = hasSomeApplicableSignature || hasApplicableSignature
		if hasSignatures && !hasApplicableSignature {
			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: nonApplicableType ??= type */ TODO
		}
		return result

		getInstantiatedTypePart := func(type_ Type) Type {
			if type_.flags & TypeFlagsObject {
				resolved := tc.resolveStructuredTypeMembers(type_ /* as ObjectType */)
				callSignatures := getInstantiatedSignatures(resolved.callSignatures)
				constructSignatures := getInstantiatedSignatures(resolved.constructSignatures)
				hasSignatures = hasSignatures || resolved.callSignatures.length != 0 || resolved.constructSignatures.length != 0
				hasApplicableSignature = hasApplicableSignature || callSignatures.length != 0 || constructSignatures.length != 0
				if callSignatures != resolved.callSignatures || constructSignatures != resolved.constructSignatures {
					result := tc.createAnonymousType(tc.createSymbol(SymbolFlagsNone, InternalSymbolNameInstantiationExpression), resolved.members, callSignatures, constructSignatures, resolved.indexInfos) /* as ResolvedType & InstantiationExpressionType */
					result.objectFlags |= ObjectFlagsInstantiationExpressionType
					result.node = node
					return result
				}
			} else if type_.flags & TypeFlagsInstantiableNonPrimitive {
				constraint := tc.getBaseConstraintOfType(type_)
				if constraint {
					instantiated := getInstantiatedTypePart(constraint)
					if instantiated != constraint {
						return instantiated
					}
				}
			} else if type_.flags & TypeFlagsUnion {
				return tc.mapType(type_, getInstantiatedType)
			} else if type_.flags & TypeFlagsIntersection {
				return tc.getIntersectionType(sameMap((type_ /* as IntersectionType */).types, getInstantiatedTypePart))
			}
			return type_
		}

	}

	getInstantiatedSignatures := func(signatures []Signature) []Signature {
		applicableSignatures := filter(signatures, func(sig Signature) bool {
			return !!sig.typeParameters && tc.hasCorrectTypeArgumentArity(sig, typeArguments)
		})
		return sameMap(applicableSignatures, func(sig Signature) Signature {
			typeArgumentTypes := tc.checkTypeArguments(sig, typeArguments /*reportErrors*/, true)
			if typeArgumentTypes {
				return tc.getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration))
			} else {
				return sig
			}
		})
	}

}

func (tc *TypeChecker) checkSatisfiesExpression(node SatisfiesExpression) Type {
	tc.checkSourceElement(node.type_)
	return tc.checkSatisfiesExpressionWorker(node.expression, node.type_)
}

func (tc *TypeChecker) checkSatisfiesExpressionWorker(expression Expression, target TypeNode, checkMode CheckMode) Type {
	exprType := tc.checkExpression(expression, checkMode)
	targetType := tc.getTypeFromTypeNode(target)
	if tc.isErrorType(targetType) {
		return targetType
	}
	errorNode := findAncestor(target.parent, func(n Node) bool {
		return n.kind == SyntaxKindSatisfiesExpression || n.kind == SyntaxKindJSDocSatisfiesTag
	})
	tc.checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1)
	return exprType
}

func (tc *TypeChecker) checkMetaProperty(node MetaProperty) Type {
	tc.checkGrammarMetaProperty(node)

	if node.keywordToken == SyntaxKindNewKeyword {
		return tc.checkNewTargetMetaProperty(node)
	}

	if node.keywordToken == SyntaxKindImportKeyword {
		return tc.checkImportMetaProperty(node)
	}

	return Debug.assertNever(node.keywordToken)
}

func (tc *TypeChecker) checkMetaPropertyKeyword(node MetaProperty) Type {
	switch node.keywordToken {
	case SyntaxKindImportKeyword:
		return tc.getGlobalImportMetaExpressionType()
	case SyntaxKindNewKeyword:
		type_ := tc.checkNewTargetMetaProperty(node)
		if tc.isErrorType(type_) {
			return tc.errorType
		} else {
			return tc.createNewTargetExpressionType(type_)
		}
	default:
		Debug.assertNever(node.keywordToken)
	}
}

func (tc *TypeChecker) checkNewTargetMetaProperty(node MetaProperty) Type {
	container := getNewTargetContainer(node)
	if !container {
		tc.error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target")
		return tc.errorType
	} else if container.kind == SyntaxKindConstructor {
		symbol := tc.getSymbolOfDeclaration(container.parent)
		return tc.getTypeOfSymbol(symbol)
	} else {
		symbol := tc.getSymbolOfDeclaration(container)
		return tc.getTypeOfSymbol(symbol)
	}
}

func (tc *TypeChecker) checkImportMetaProperty(node MetaProperty) /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any {
	if tc.moduleKind == ModuleKindNode16 || tc.moduleKind == ModuleKindNodeNext {
		if getSourceFileOfNode(node).impliedNodeFormat != ModuleKindESNext {
			tc.error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output)
		}
	} else if tc.moduleKind < ModuleKindES2020 && tc.moduleKind != ModuleKindSystem {
		tc.error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext)
	}
	file := getSourceFileOfNode(node)
	Debug.assert(!!(file.flags & NodeFlagsPossiblyContainsImportMeta), "Containing file is missing import meta node flag.")
	if node.name.escapedText == "meta" {
		return tc.getGlobalImportMetaType()
	} else {
		return tc.errorType
	}
}

func (tc *TypeChecker) getTypeOfParameter(symbol Symbol) Type {
	declaration := symbol.valueDeclaration
	return tc.addOptionality(tc.getTypeOfSymbol(symbol), false, !!declaration && (hasInitializer(declaration) || isOptionalDeclaration(declaration)))
}

/**
 * Gets a tuple element label by recursively walking `ArrayBindingPattern` nodes in a `BindingName`.
 * @param node The source node from which to derive a label
 * @param index The index into the tuple
 * @param elementFlags The {@see ElementFlags} of the tuple element
 */

func (tc *TypeChecker) getTupleElementLabelFromBindingElement(node /* TODO(TS-TO-GO) TypeNode UnionType: BindingElement | ParameterDeclaration */ any, index number, elementFlags ElementFlags) __String {
	switch node.name.kind {
	case SyntaxKindIdentifier:
		name := node.name.escapedText
		if node.dotDotDotToken {
			// given
			//   (...[x, y, ...z]: [number, number, ...number[]]) => ...
			// this produces
			//   (x: number, y: number, ...z: number[]) => ...
			// which preserves rest elements of 'z'

			// given
			//   (...[x, y, ...z]: [number, number, ...[...number[], number]]) => ...
			// this produces
			//   (x: number, y: number, ...z: number[], z_1: number) => ...
			// which preserves rest elements of z but gives distinct numbers to fixed elements of 'z'
			if elementFlags & ElementFlagsVariable {
				return name
			} else {
				return __TEMPLATE__(name, "_", index) /* as __String */
			}
		} else {
			// given
			//   (...[x]: [number]) => ...
			// this produces
			//   (x: number) => ...
			// which preserves fixed elements of 'x'

			// given
			//   (...[x]: ...number[]) => ...
			// this produces
			//   (x_0: number) => ...
			// which which numbers fixed elements of 'x' whose tuple element type is variable
			if elementFlags & ElementFlagsFixed {
				return name
			} else {
				return __TEMPLATE__(name, "_n") /* as __String */
			}
		}
		fallthrough
	case SyntaxKindArrayBindingPattern:
		if node.dotDotDotToken {
			elements := node.name.elements
			lastElement := tryCast(lastOrUndefined(elements), isBindingElement)
			elementCount := elements.length - (__COND__(lastElement. /* ? */ dotDotDotToken, 1, 0))
			if index < elementCount {
				element := elements[index]
				if isBindingElement(element) {
					return tc.getTupleElementLabelFromBindingElement(element, index, elementFlags)
				}
			} else if lastElement. /* ? */ dotDotDotToken {
				return tc.getTupleElementLabelFromBindingElement(lastElement, index-elementCount, elementFlags)
			}
		}
		break
	}
	return __TEMPLATE__("arg_", index) /* as __String */
}

/* OVERLOAD: function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember): __String; */
/* OVERLOAD: function getTupleElementLabel(d: ParameterDeclaration | NamedTupleMember | undefined, index: number, elementFlags: ElementFlags, restSymbol?: Symbol): __String; */
func (tc *TypeChecker) getTupleElementLabel(d /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | NamedTupleMember | undefined */ any, index number /*  = 0 */, elementFlags ElementFlags /*  = ElementFlags.Fixed */, restSymbol Symbol) __String {
	if !d {
		restParameter := tryCast(restSymbol. /* ? */ valueDeclaration, isParameter)
		if restParameter {
			return tc.getTupleElementLabelFromBindingElement(restParameter, index, elementFlags)
		} else {
			return __TEMPLATE__( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: restSymbol?.escapedName ?? "arg" */ TODO, "_", index) /* as __String */
		}
	}
	Debug.assert(isIdentifier(d.name))
	// Parameter declarations could be binding patterns, but we only allow identifier names
	return d.name.escapedText
}

func (tc *TypeChecker) getParameterNameAtPosition(signature Signature, pos number, overrideRestType Type) __String {
	paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
	if pos < paramCount {
		return signature.parameters[pos].escapedName
	}
	restParameter := signature.parameters[paramCount] || tc.unknownSymbol
	restType := overrideRestType || tc.getTypeOfSymbol(restParameter)
	if tc.isTupleType(restType) {
		tupleType := (restType /* as TypeReference */).target /* as TupleType */
		index := pos - paramCount
		associatedName := tupleType.labeledElementDeclarations[index]
		elementFlags := tupleType.elementFlags[index]
		return tc.getTupleElementLabel(associatedName, index, elementFlags, restParameter)
	}
	return restParameter.escapedName
}

func (tc *TypeChecker) getParameterIdentifierInfoAtPosition(signature Signature, pos number) * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } */ any {
	if signature.declaration. /* ? */ kind == SyntaxKindJSDocFunctionType {
		return nil
	}
	paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
	if pos < paramCount {
		param := signature.parameters[pos]
		paramIdent := tc.getParameterDeclarationIdentifier(param)
		if paramIdent {
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"parameter":       paramIdent,
				"parameterName":   param.escapedName,
				"isRestParameter": false,
			}
		} else {
			return nil
		}
	}

	restParameter := signature.parameters[paramCount] || tc.unknownSymbol
	restIdent := tc.getParameterDeclarationIdentifier(restParameter)
	if !restIdent {
		return nil
	}

	restType := tc.getTypeOfSymbol(restParameter)
	if tc.isTupleType(restType) {
		associatedNames := ((restType /* as TypeReference */).target /* as TupleType */).labeledElementDeclarations
		index := pos - paramCount
		associatedName := associatedNames[index]
		isRestTupleElement := !!associatedName. /* ? */ dotDotDotToken

		if associatedName {
			Debug.assert(isIdentifier(associatedName.name))
			return map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"parameter":       associatedName.name,
				"parameterName":   associatedName.name.escapedText,
				"isRestParameter": isRestTupleElement,
			}
		}

		return nil
	}

	if pos == paramCount {
		return map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"parameter":       restIdent,
			"parameterName":   restParameter.escapedName,
			"isRestParameter": true,
		}
	}
	return nil
}

func (tc *TypeChecker) getParameterDeclarationIdentifier(symbol Symbol) * /* TODO(TS-TO-GO) inferred type false | Identifier */ any {
	return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name) && symbol.valueDeclaration.name
}

func (tc *TypeChecker) isValidDeclarationForTupleLabel(d Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) */ any {
	return d.kind == SyntaxKindNamedTupleMember || (isParameter(d) && d.name && isIdentifier(d.name))
}

func (tc *TypeChecker) getNameableDeclarationAtPosition(signature Signature, pos number) * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | NamedTupleMember */ any {
	paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
	if pos < paramCount {
		decl := signature.parameters[pos].valueDeclaration
		if decl && tc.isValidDeclarationForTupleLabel(decl) {
			return decl
		} else {
			return nil
		}
	}
	restParameter := signature.parameters[paramCount] || tc.unknownSymbol
	restType := tc.getTypeOfSymbol(restParameter)
	if tc.isTupleType(restType) {
		associatedNames := ((restType /* as TypeReference */).target /* as TupleType */).labeledElementDeclarations
		index := pos - paramCount
		return associatedNames && associatedNames[index]
	}
	if restParameter.valueDeclaration && tc.isValidDeclarationForTupleLabel(restParameter.valueDeclaration) {
		return restParameter.valueDeclaration
	} else {
		return nil
	}
}

func (tc *TypeChecker) getTypeAtPosition(signature Signature, pos number) Type {
	return tc.tryGetTypeAtPosition(signature, pos) || tc.anyType
}

func (tc *TypeChecker) tryGetTypeAtPosition(signature Signature, pos number) Type {
	paramCount := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
	if pos < paramCount {
		return tc.getTypeOfParameter(signature.parameters[pos])
	}
	if signatureHasRestParameter(signature) {
		// We want to return the value undefined for an out of bounds parameter position,
		// so we need to check bounds here before calling getIndexedAccessType (which
		// otherwise would return the type 'undefined').
		restType := tc.getTypeOfSymbol(signature.parameters[paramCount])
		index := pos - paramCount
		if !tc.isTupleType(restType) || restType.target.combinedFlags&ElementFlagsVariable || index < restType.target.fixedLength {
			return tc.getIndexedAccessType(restType, tc.getNumberLiteralType(index))
		}
	}
	return nil
}

func (tc *TypeChecker) getRestTypeAtPosition(source Signature, pos number, readonly bool) Type {
	parameterCount := tc.getParameterCount(source)
	minArgumentCount := tc.getMinArgumentCount(source)
	restType := tc.getEffectiveRestType(source)
	if restType && pos >= parameterCount-1 {
		if pos == parameterCount-1 {
			return restType
		} else {
			return tc.createArrayType(tc.getIndexedAccessType(restType, tc.numberType))
		}
	}
	types := []never{}
	flags := []never{}
	names := []never{}
	for i := pos; i < parameterCount; i++ {
		if !restType || i < parameterCount-1 {
			types.push(tc.getTypeAtPosition(source, i))
			flags.push(__COND__(i < minArgumentCount, ElementFlagsRequired, ElementFlagsOptional))
		} else {
			types.push(restType)
			flags.push(ElementFlagsVariadic)
		}
		names.push(tc.getNameableDeclarationAtPosition(source, i))
	}
	return tc.createTupleType(types, flags, readonly, names)
}

// Return the rest type at the given position, transforming `any[]` into just `any`. We do this because
// in signatures we want `any[]` in a rest position to be compatible with anything, but `any[]` isn't
// assignable to tuple types with required elements.
func (tc *TypeChecker) getRestOrAnyTypeAtPosition(source Signature, pos number) Type {
	restType := tc.getRestTypeAtPosition(source, pos)
	elementType := restType && tc.getElementTypeOfArrayType(restType)
	if elementType && tc.isTypeAny(elementType) {
		return tc.anyType
	} else {
		return restType
	}
}

// Return the number of parameters in a signature. The rest parameter, if present, counts as one
// parameter. For example, the parameter count of (x: number, y: number, ...z: string[]) is 3 and
// the parameter count of (x: number, ...args: [number, ...string[], boolean])) is also 3. In the
// latter example, the effective rest type is [...string[], boolean].
func (tc *TypeChecker) getParameterCount(signature Signature) number {
	length := signature.parameters.length
	if signatureHasRestParameter(signature) {
		restType := tc.getTypeOfSymbol(signature.parameters[length-1])
		if tc.isTupleType(restType) {
			return length + restType.target.fixedLength - (__COND__(restType.target.combinedFlags&ElementFlagsVariable, 0, 1))
		}
	}
	return length
}

func (tc *TypeChecker) getMinArgumentCount(signature Signature, flags MinArgumentCountFlags) number {
	strongArityForUntypedJS := flags & MinArgumentCountFlagsStrongArityForUntypedJS
	voidIsNonOptional := flags & MinArgumentCountFlagsVoidIsNonOptional
	if voidIsNonOptional || signature.resolvedMinArgumentCount == nil {
		var minArgumentCount *number
		if signatureHasRestParameter(signature) {
			restType := tc.getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
			if tc.isTupleType(restType) {
				firstOptionalIndex := findIndex(restType.target.elementFlags, func(f ElementFlags) bool {
					return !(f & ElementFlagsRequired)
				})
				var requiredCount number
				if firstOptionalIndex < 0 {
					requiredCount = restType.target.fixedLength
				} else {
					requiredCount = firstOptionalIndex
				}
				if requiredCount > 0 {
					minArgumentCount = signature.parameters.length - 1 + requiredCount
				}
			}
		}
		if minArgumentCount == nil {
			if !strongArityForUntypedJS && signature.flags&SignatureFlagsIsUntypedSignatureInJSFile {
				return 0
			}
			minArgumentCount = signature.minArgumentCount
		}
		if voidIsNonOptional {
			return minArgumentCount
		}
		for i := minArgumentCount - 1; i >= 0; i-- {
			type_ := tc.getTypeAtPosition(signature, i)
			if tc.filterType(type_, tc.acceptsVoid).flags & TypeFlagsNever {
				break
			}
			minArgumentCount = i
		}
		signature.resolvedMinArgumentCount = minArgumentCount
	}
	return signature.resolvedMinArgumentCount
}

func (tc *TypeChecker) hasEffectiveRestParameter(signature Signature) bool {
	if signatureHasRestParameter(signature) {
		restType := tc.getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
		return !tc.isTupleType(restType) || !!(restType.target.combinedFlags & ElementFlagsVariable)
	}
	return false
}

func (tc *TypeChecker) getEffectiveRestType(signature Signature) Type {
	if signatureHasRestParameter(signature) {
		restType := tc.getTypeOfSymbol(signature.parameters[signature.parameters.length-1])
		if !tc.isTupleType(restType) {
			if tc.isTypeAny(restType) {
				return tc.anyArrayType
			} else {
				return restType
			}
		}
		if restType.target.combinedFlags & ElementFlagsVariable {
			return tc.sliceTupleType(restType, restType.target.fixedLength)
		}
	}
	return nil
}

func (tc *TypeChecker) getNonArrayRestType(signature Signature) Type {
	restType := tc.getEffectiveRestType(signature)
	if restType && !tc.isArrayType(restType) && !tc.isTypeAny(restType) {
		return restType
	} else {
		return nil
	}
}

func (tc *TypeChecker) getTypeOfFirstParameterOfSignature(signature Signature) Type {
	return tc.getTypeOfFirstParameterOfSignatureWithFallback(signature, tc.neverType)
}

func (tc *TypeChecker) getTypeOfFirstParameterOfSignatureWithFallback(signature Signature, fallbackType Type) Type {
	if signature.parameters.length > 0 {
		return tc.getTypeAtPosition(signature, 0)
	} else {
		return fallbackType
	}
}

func (tc *TypeChecker) inferFromAnnotatedParameters(signature Signature, context Signature, inferenceContext InferenceContext) {
	len := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
	for i := 0; i < len; i++ {
		declaration := signature.parameters[i].valueDeclaration /* as ParameterDeclaration */
		typeNode := getEffectiveTypeAnnotationNode(declaration)
		if typeNode {
			source := tc.addOptionality(tc.getTypeFromTypeNode(typeNode) /*isProperty*/, false, isOptionalDeclaration(declaration))
			target := tc.getTypeAtPosition(context, i)
			tc.inferTypes(inferenceContext.inferences, source, target)
		}
	}
}

func (tc *TypeChecker) assignContextualParameterTypes(signature Signature, context Signature) {
	if context.typeParameters {
		if !signature.typeParameters {
			signature.typeParameters = context.typeParameters
		} else {
			return
			// This signature has already has a contextual inference performed and cached on it!
		}
	}
	if context.thisParameter {
		parameter := signature.thisParameter
		if !parameter || parameter.valueDeclaration && !(parameter.valueDeclaration /* as ParameterDeclaration */).type_ {
			if !parameter {
				signature.thisParameter = tc.createSymbolWithType(context.thisParameter /*type*/, nil)
			}
			tc.assignParameterType(signature.thisParameter, tc.getTypeOfSymbol(context.thisParameter))
		}
	}
	len := signature.parameters.length - (__COND__(signatureHasRestParameter(signature), 1, 0))
	for i := 0; i < len; i++ {
		parameter := signature.parameters[i]
		declaration := parameter.valueDeclaration /* as ParameterDeclaration */
		if !getEffectiveTypeAnnotationNode(declaration) {
			type_ := tc.tryGetTypeAtPosition(context, i)
			if type_ && declaration.initializer {
				initializerType := tc.checkDeclarationInitializer(declaration, CheckModeNormal)
				if !tc.isTypeAssignableTo(initializerType, type_) && tc.isTypeAssignableTo(type_ /* TODO(TS-TO-GO) EqualsToken BinaryExpression: initializerType = widenTypeInferredFromInitializer(declaration, initializerType) */, TODO) {
					type_ = initializerType
				}
			}
			tc.assignParameterType(parameter, type_)
		}
	}
	if signatureHasRestParameter(signature) {
		// parameter might be a transient symbol generated by use of `arguments` in the function body.
		parameter := last(signature.parameters)
		if __COND__(parameter.valueDeclaration, !getEffectiveTypeAnnotationNode(parameter.valueDeclaration /* as ParameterDeclaration */), !!(getCheckFlags(parameter) & CheckFlagsDeferredType)) {
			contextualParameterType := tc.getRestTypeAtPosition(context, len)
			tc.assignParameterType(parameter, contextualParameterType)
		}
	}
}

func (tc *TypeChecker) assignNonContextualParameterTypes(signature Signature) {
	if signature.thisParameter {
		tc.assignParameterType(signature.thisParameter)
	}
	for _, parameter := range signature.parameters {
		tc.assignParameterType(parameter)
	}
}

func (tc *TypeChecker) assignParameterType(parameter Symbol, contextualType Type) {
	links := tc.getSymbolLinks(parameter)
	if !links.type_ {
		declaration := parameter.valueDeclaration /* as ParameterDeclaration | undefined */
		links.type_ = tc.addOptionality(contextualType || (__COND__(declaration, tc.getWidenedTypeForVariableLikeDeclaration(declaration /*reportErrors*/, true), tc.getTypeOfSymbol(parameter))), false, !!declaration && !declaration.initializer && isOptionalDeclaration(declaration))
		if declaration && declaration.name.kind != SyntaxKindIdentifier {
			// if inference didn't come up with anything but unknown, fall back to the binding pattern if present.
			if links.type_ == tc.unknownType {
				links.type_ = tc.getTypeFromBindingPattern(declaration.name)
			}
			tc.assignBindingElementTypes(declaration.name, links.type_)
		}
	} else if contextualType {
		Debug.assertEqual(links.type_, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type")
	}
}

// When contextual typing assigns a type to a parameter that contains a binding pattern, we also need to push
// the destructured type into the contained binding elements.
func (tc *TypeChecker) assignBindingElementTypes(pattern BindingPattern, parentType Type) {
	for _, element := range pattern.elements {
		if !isOmittedExpression(element) {
			type_ := tc.getBindingElementTypeFromParentType(element, parentType /*noTupleBoundsCheck*/, false)
			if element.name.kind == SyntaxKindIdentifier {
				tc.getSymbolLinks(tc.getSymbolOfDeclaration(element)).type_ = type_
			} else {
				tc.assignBindingElementTypes(element.name, type_)
			}
		}
	}
}

func (tc *TypeChecker) createClassDecoratorContextType(classType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassDecoratorContextType(true), []Type{classType})
}

func (tc *TypeChecker) createClassMethodDecoratorContextType(thisType Type, valueType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassMethodDecoratorContextType(true), []Type{thisType, valueType})
}

func (tc *TypeChecker) createClassGetterDecoratorContextType(thisType Type, valueType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassGetterDecoratorContextType(true), []Type{thisType, valueType})
}

func (tc *TypeChecker) createClassSetterDecoratorContextType(thisType Type, valueType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassSetterDecoratorContextType(true), []Type{thisType, valueType})
}

func (tc *TypeChecker) createClassAccessorDecoratorContextType(thisType Type, valueType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassAccessorDecoratorContextType(true), []Type{thisType, valueType})
}

func (tc *TypeChecker) createClassFieldDecoratorContextType(thisType Type, valueType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassFieldDecoratorContextType(true), []Type{thisType, valueType})
}

/**
 * Gets a type like `{ name: "foo", private: false, static: true }` that is used to provided member-specific
 * details that will be intersected with a decorator context type.
 */

func (tc *TypeChecker) getClassMemberDecoratorContextOverrideType(nameType Type, isPrivate bool, isStatic bool) Type {
	key := __TEMPLATE__(__COND__(isPrivate, "p", "P"), __COND__(isStatic, "s", "S"), nameType.id) /* as const */
	overrideType := tc.decoratorContextOverrideTypeCache.get(key)
	if !overrideType {
		members := createSymbolTable()
		members.set("name" /* as __String */, tc.createProperty("name" /* as __String */, nameType))
		members.set("private" /* as __String */, tc.createProperty("private" /* as __String */, __COND__(isPrivate, tc.trueType, tc.falseType)))
		members.set("static" /* as __String */, tc.createProperty("static" /* as __String */, __COND__(isStatic, tc.trueType, tc.falseType)))
		overrideType = tc.createAnonymousType(nil, members, emptyArray, emptyArray, emptyArray)
		tc.decoratorContextOverrideTypeCache.set(key, overrideType)
	}
	return overrideType
}

func (tc *TypeChecker) createClassMemberDecoratorContextTypeForNode(node /* TODO(TS-TO-GO) TypeNode UnionType: MethodDeclaration | AccessorDeclaration | PropertyDeclaration */ any, thisType Type, valueType Type) Type {
	isStatic := hasStaticModifier(node)
	isPrivate := isPrivateIdentifier(node.name)
	var nameType Type
	if isPrivate {
		nameType = tc.getStringLiteralType(idText(node.name))
	} else {
		nameType = tc.getLiteralTypeFromPropertyName(node.name)
	}
	var contextType Type
	switch {
	case isMethodDeclaration(node):
		contextType = tc.createClassMethodDecoratorContextType(thisType, valueType)
	case isGetAccessorDeclaration(node):
		contextType = tc.createClassGetterDecoratorContextType(thisType, valueType)
	case isSetAccessorDeclaration(node):
		contextType = tc.createClassSetterDecoratorContextType(thisType, valueType)
	case isAutoAccessorPropertyDeclaration(node):
		contextType = tc.createClassAccessorDecoratorContextType(thisType, valueType)
	case isPropertyDeclaration(node):
		contextType = tc.createClassFieldDecoratorContextType(thisType, valueType)
	default:
		contextType = Debug.failBadSyntaxKind(node)
	}
	overrideType := tc.getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic)
	return tc.getIntersectionType([]Type{contextType, overrideType})
}

func (tc *TypeChecker) createClassAccessorDecoratorTargetType(thisType Type, valueType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassAccessorDecoratorTargetType(true), []Type{thisType, valueType})
}

func (tc *TypeChecker) createClassAccessorDecoratorResultType(thisType Type, valueType Type) Type {
	return tc.tryCreateTypeReference(tc.getGlobalClassAccessorDecoratorResultType(true), []Type{thisType, valueType})
}

func (tc *TypeChecker) createClassFieldDecoratorInitializerMutatorType(thisType Type, valueType Type) ObjectType {
	thisParam := tc.createParameter("this" /* as __String */, thisType)
	valueParam := tc.createParameter("value" /* as __String */, valueType)
	return tc.createFunctionType(nil, thisParam, []TransientSymbol{valueParam}, valueType /*typePredicate*/, nil, 1)
}

/**
 * Creates a call signature for an ES Decorator. This method is used by the semantics of
 * `getESDecoratorCallSignature`, which you should probably be using instead.
 */

func (tc *TypeChecker) createESDecoratorCallSignature(targetType Type, contextType Type, nonOptionalReturnType Type) Signature {
	targetParam := tc.createParameter("target" /* as __String */, targetType)
	contextParam := tc.createParameter("context" /* as __String */, contextType)
	returnType := tc.getUnionType([]Type{nonOptionalReturnType, tc.voidType})
	return tc.createCallSignature(nil /*thisParameter*/, nil, []TransientSymbol{targetParam, contextParam}, returnType)
}

/**
 * Gets a call signature that should be used when resolving `decorator` as a call. This does not use the value
 * of the decorator itself, but instead uses the declaration on which it is placed along with its relative
 * position amongst other decorators on the same declaration to determine the applicable signature. The
 * resulting signature can be used for call resolution, inference, and contextual typing.
 */

func (tc *TypeChecker) getESDecoratorCallSignature(decorator Decorator) *Signature {
	// We are considering a future change that would allow the type of a decorator to affect the type of the
	// class and its members, such as a `@Stringify` decorator changing the type of a `number` field to `string`, or
	// a `@Callable` decorator adding a call signature to a `class`. The type arguments for the various context
	// types may eventually change to reflect such mutations.
	//
	// In some cases we describe such potential mutations as coming from a "prior decorator application". It is
	// important to note that, while decorators are *evaluated* left to right, they are *applied* right to left
	// to preserve f ৹ g -> f(g(x)) application order. In these cases, a "prior" decorator usually means the
	// next decorator following this one in document order.
	//
	// The "original type" of a class or member is the type it was declared as, or the type we infer from
	// initializers, before _any_ decorators are applied.
	//
	// The type of a class or member that is a result of a prior decorator application represents the
	// "current type", i.e., the type for the declaration at the time the decorator is _applied_.
	//
	// The type of a class or member that is the result of the application of *all* relevant decorators is the
	// "final type".
	//
	// Any decorator that allows mutation or replacement will also refer to an "input type" and an
	// "output type". The "input type" corresponds to the "current type" of the declaration, while the
	// "output type" will become either the "input type/current type" for a subsequent decorator application,
	// or the "final type" for the decorated declaration.
	//
	// It is important to understand decorator application order as it relates to how the "current", "input",
	// "output", and "final" types will be determined:
	//
	//  @E2 @E1 class SomeClass {
	//      @A2 @A1 static f() {}
	//      @B2 @B1 g() {}
	//      @C2 @C1 static x;
	//      @D2 @D1 y;
	//  }
	//
	// Per [the specification][1], decorators are applied in the following order:
	//
	// 1. For each static method (incl. get/set methods and `accessor` fields), in document order:
	//    a. Apply each decorator for that method, in reverse order (`A1`, `A2`).
	// 2. For each instance method (incl. get/set methods and `accessor` fields), in document order:
	//    a. Apply each decorator for that method, in reverse order (`B1`, `B2`).
	// 3. For each static field (excl. auto-accessors), in document order:
	//    a. Apply each decorator for that field, in reverse order (`C1`, `C2`).
	// 4. For each instance field (excl. auto-accessors), in document order:
	//    a. Apply each decorator for that field, in reverse order (`D1`, `D2`).
	// 5. Apply each decorator for the class, in reverse order (`E1`, `E2`).
	//
	// As a result, "current" types at each decorator application are as follows:
	// - For `A1`, the "current" types of the class and method are their "original" types.
	// - For `A2`, the "current type" of the method is the "output type" of `A1`, and the "current type" of the
	//   class is the type of `SomeClass` where `f` is the "output type" of `A1`. This becomes the "final type"
	//   of `f`.
	// - For `B1`, the "current type" of the method is its "original type", and the "current type" of the class
	//   is the type of `SomeClass` where `f` now has its "final type".
	// - etc.
	//
	// [1]: https://arai-a.github.io/ecma262-compare/?pr=2417&id=sec-runtime-semantics-classdefinitionevaluation
	//
	// This seems complicated at first glance, but is not unlike our existing inference for functions:
	//
	//  declare function pipe<Original, A1, A2, B1, B2, C1, C2, D1, D2, E1, E2>(
	//      original: Original,
	//      a1: (input: Original, context: Context<E2>) => A1,
	//      a2: (input: A1, context: Context<E2>) => A2,
	//      b1: (input: A2, context: Context<E2>) => B1,
	//      b2: (input: B1, context: Context<E2>) => B2,
	//      c1: (input: B2, context: Context<E2>) => C1,
	//      c2: (input: C1, context: Context<E2>) => C2,
	//      d1: (input: C2, context: Context<E2>) => D1,
	//      d2: (input: D1, context: Context<E2>) => D2,
	//      e1: (input: D2, context: Context<E2>) => E1,
	//      e2: (input: E1, context: Context<E2>) => E2,
	//  ): E2;

	// When a decorator is applied, it is passed two arguments: "target", which is a value representing the
	// thing being decorated (constructors for classes, functions for methods/accessors, `undefined` for fields,
	// and a `{ get, set }` object for auto-accessors), and "context", which is an object that provides
	// reflection information about the decorated element, as well as the ability to add additional "extra"
	// initializers. In most cases, the "target" argument corresponds to the "input type" in some way, and the
	// return value similarly corresponds to the "output type" (though if the "output type" is `void` or
	// `undefined` then the "output type" is the "input type").

	TODO_IDENTIFIER := decorator
	links := tc.getNodeLinks(parent)
	if !links.decoratorSignature {
		links.decoratorSignature = tc.anySignature
		switch parent.kind {
		case SyntaxKindClassDeclaration,
			SyntaxKindClassExpression:
			// Class decorators have a `context` of `ClassDecoratorContext<Class>`, where the `Class` type
			// argument will be the "final type" of the class after all decorators are applied.

			node := parent /* as ClassDeclaration | ClassExpression */
			targetType := tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node))
			contextType := tc.createClassDecoratorContextType(targetType)
			links.decoratorSignature = tc.createESDecoratorCallSignature(targetType, contextType, targetType)
			break
			fallthrough
		case SyntaxKindMethodDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			node := parent /* as MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration */
			if !isClassLike(node.parent) {
				break
			}

			// Method decorators have a `context` of `ClassMethodDecoratorContext<This, Value>`, where the
			// `Value` type argument corresponds to the "final type" of the method.
			//
			// Getter decorators have a `context` of `ClassGetterDecoratorContext<This, Value>`, where the
			// `Value` type argument corresponds to the "final type" of the value returned by the getter.
			//
			// Setter decorators have a `context` of `ClassSetterDecoratorContext<This, Value>`, where the
			// `Value` type argument corresponds to the "final type" of the parameter of the setter.
			//
			// In all three cases, the `This` type argument is the "final type" of either the class or
			// instance, depending on whether the member was `static`.

			var valueType Type
			if isMethodDeclaration(node) {
				valueType = tc.getOrCreateTypeFromSignature(tc.getSignatureFromDeclaration(node))
			} else {
				valueType = tc.getTypeOfNode(node)
			}

			var thisType Type
			if hasStaticModifier(node) {
				thisType = tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node.parent))
			} else {
				thisType = tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfDeclaration(node.parent))
			}

			// We wrap the "input type", if necessary, to match the decoration target. For getters this is
			// something like `() => inputType`, for setters it's `(value: inputType) => void` and for
			// methods it is just the input type.
			var targetType Type
			switch {
			case isGetAccessorDeclaration(node):
				targetType = tc.createGetterFunctionType(valueType)
			case isSetAccessorDeclaration(node):
				targetType = tc.createSetterFunctionType(valueType)
			default:
				targetType = valueType
			}

			contextType := tc.createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)

			// We also wrap the "output type", as needed.
			var returnType Type
			switch {
			case isGetAccessorDeclaration(node):
				returnType = tc.createGetterFunctionType(valueType)
			case isSetAccessorDeclaration(node):
				returnType = tc.createSetterFunctionType(valueType)
			default:
				returnType = valueType
			}

			links.decoratorSignature = tc.createESDecoratorCallSignature(targetType, contextType, returnType)
			break
			fallthrough
		case SyntaxKindPropertyDeclaration:
			node := parent /* as PropertyDeclaration */
			if !isClassLike(node.parent) {
				break
			}

			// Field decorators have a `context` of `ClassFieldDecoratorContext<This, Value>` and
			// auto-accessor decorators have a `context` of `ClassAccessorDecoratorContext<This, Value>. In
			// both cases, the `This` type argument is the "final type" of either the class or instance,
			// depending on whether the member was `static`, and the `Value` type argument corresponds to
			// the "final type" of the value stored in the field.

			valueType := tc.getTypeOfNode(node)
			var thisType Type
			if hasStaticModifier(node) {
				thisType = tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node.parent))
			} else {
				thisType = tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfDeclaration(node.parent))
			}

			// The `target` of an auto-accessor decorator is a `{ get, set }` object, representing the
			// runtime-generated getter and setter that are added to the class/prototype. The `target` of a
			// regular field decorator is always `undefined` as it isn't installed until it is initialized.
			var targetType Type
			if hasAccessorModifier(node) {
				targetType = tc.createClassAccessorDecoratorTargetType(thisType, valueType)
			} else {
				targetType = tc.undefinedType
			}

			contextType := tc.createClassMemberDecoratorContextTypeForNode(node, thisType, valueType)

			// We wrap the "output type" depending on the declaration. For auto-accessors, we wrap the
			// "output type" in a `ClassAccessorDecoratorResult<This, In, Out>` type, which allows for
			// mutation of the runtime-generated getter and setter, as well as the injection of an
			// initializer mutator. For regular fields, we wrap the "output type" in an initializer mutator.
			var returnType Type
			if hasAccessorModifier(node) {
				returnType = tc.createClassAccessorDecoratorResultType(thisType, valueType)
			} else {
				returnType = tc.createClassFieldDecoratorInitializerMutatorType(thisType, valueType)
			}

			links.decoratorSignature = tc.createESDecoratorCallSignature(targetType, contextType, returnType)
			break
		}
	}
	if links.decoratorSignature == tc.anySignature {
		return nil
	} else {
		return links.decoratorSignature
	}
}

func (tc *TypeChecker) getLegacyDecoratorCallSignature(decorator Decorator) *Signature {
	TODO_IDENTIFIER := decorator
	links := tc.getNodeLinks(parent)
	if !links.decoratorSignature {
		links.decoratorSignature = tc.anySignature
		switch parent.kind {
		case SyntaxKindClassDeclaration,
			SyntaxKindClassExpression:
			node := parent /* as ClassDeclaration | ClassExpression */
			// For a class decorator, the `target` is the type of the class (e.g. the
			// "static" or "constructor" side of the class).
			targetType := tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node))
			targetParam := tc.createParameter("target" /* as __String */, targetType)
			links.decoratorSignature = tc.createCallSignature(nil, nil, []TransientSymbol{targetParam}, tc.getUnionType([]Type{targetType, tc.voidType}))
			break
			fallthrough
		case SyntaxKindParameter:
			node := parent /* as ParameterDeclaration */
			if !isConstructorDeclaration(node.parent) && !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent)) {
				break
			}

			if getThisParameter(node.parent) == node {
				break
			}

			var index number
			if getThisParameter(node.parent) {
				index = node.parent.parameters.indexOf(node) - 1
			} else {
				index = node.parent.parameters.indexOf(node)
			}
			Debug.assert(index >= 0)

			// A parameter declaration decorator will have three arguments (see `ParameterDecorator` in
			// core.d.ts).

			var targetType Type
			if isConstructorDeclaration(node.parent) {
				targetType = tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node.parent.parent))
			} else {
				targetType = tc.getParentTypeOfClassElement(node.parent)
			}

			var keyType Type
			if isConstructorDeclaration(node.parent) {
				keyType = tc.undefinedType
			} else {
				keyType = tc.getClassElementPropertyKeyType(node.parent)
			}

			indexType := tc.getNumberLiteralType(index)

			targetParam := tc.createParameter("target" /* as __String */, targetType)
			keyParam := tc.createParameter("propertyKey" /* as __String */, keyType)
			indexParam := tc.createParameter("parameterIndex" /* as __String */, indexType)
			links.decoratorSignature = tc.createCallSignature(nil, nil, []TransientSymbol{targetParam, keyParam, indexParam}, tc.voidType)
			break
			fallthrough
		case SyntaxKindMethodDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor,
			SyntaxKindPropertyDeclaration:
			node := parent /* as MethodDeclaration | AccessorDeclaration | PropertyDeclaration */
			if !isClassLike(node.parent) {
				break
			}

			// A method or accessor declaration decorator will have either two or three arguments (see
			// `PropertyDecorator` and `MethodDecorator` in core.d.ts).

			targetType := tc.getParentTypeOfClassElement(node)
			targetParam := tc.createParameter("target" /* as __String */, targetType)

			keyType := tc.getClassElementPropertyKeyType(node)
			keyParam := tc.createParameter("propertyKey" /* as __String */, keyType)

			var returnType Type
			if isPropertyDeclaration(node) {
				returnType = tc.voidType
			} else {
				returnType = tc.createTypedPropertyDescriptorType(tc.getTypeOfNode(node))
			}

			hasPropDesc := !isPropertyDeclaration(parent) || hasAccessorModifier(parent)
			if hasPropDesc {
				descriptorType := tc.createTypedPropertyDescriptorType(tc.getTypeOfNode(node))
				descriptorParam := tc.createParameter("descriptor" /* as __String */, descriptorType)
				links.decoratorSignature = tc.createCallSignature(nil, nil, []TransientSymbol{targetParam, keyParam, descriptorParam}, tc.getUnionType([]Type{returnType, tc.voidType}))
			} else {
				links.decoratorSignature = tc.createCallSignature(nil, nil, []TransientSymbol{targetParam, keyParam}, tc.getUnionType([]Type{returnType, tc.voidType}))
			}
			break
		}
	}
	if links.decoratorSignature == tc.anySignature {
		return nil
	} else {
		return links.decoratorSignature
	}
}

func (tc *TypeChecker) getDecoratorCallSignature(decorator Decorator) *Signature {
	if tc.legacyDecorators {
		return tc.getLegacyDecoratorCallSignature(decorator)
	} else {
		return tc.getESDecoratorCallSignature(decorator)
	}
}

func (tc *TypeChecker) createPromiseType(promisedType Type) Type {
	// creates a `Promise<T>` type where `T` is the promisedType argument
	globalPromiseType := tc.getGlobalPromiseType(true)
	if globalPromiseType != tc.emptyGenericType {
		// if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
		// Unwrap an `Awaited<T>` to `T` to improve inference.
		promisedType = tc.getAwaitedTypeNoAlias(tc.unwrapAwaitedType(promisedType)) || tc.unknownType
		return tc.createTypeReference(globalPromiseType, []Type{promisedType})
	}

	return tc.unknownType
}

func (tc *TypeChecker) createPromiseLikeType(promisedType Type) Type {
	// creates a `PromiseLike<T>` type where `T` is the promisedType argument
	globalPromiseLikeType := tc.getGlobalPromiseLikeType(true)
	if globalPromiseLikeType != tc.emptyGenericType {
		// if the promised type is itself a promise, get the underlying type; otherwise, fallback to the promised type
		// Unwrap an `Awaited<T>` to `T` to improve inference.
		promisedType = tc.getAwaitedTypeNoAlias(tc.unwrapAwaitedType(promisedType)) || tc.unknownType
		return tc.createTypeReference(globalPromiseLikeType, []Type{promisedType})
	}

	return tc.unknownType
}

func (tc *TypeChecker) createPromiseReturnType(func_ /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | ImportCall */ any, promisedType Type) Type {
	promiseType := tc.createPromiseType(promisedType)
	if promiseType == tc.unknownType {
		tc.error(func_, __COND__(isImportCall(func_), Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option, Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option))
		return tc.errorType
	} else if !tc.getGlobalPromiseConstructorSymbol(true) {
		tc.error(func_, __COND__(isImportCall(func_), Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option))
	}

	return promiseType
}

func (tc *TypeChecker) createNewTargetExpressionType(targetType Type) Type {
	// Create a synthetic type `NewTargetExpression { target: TargetType; }`
	symbol := tc.createSymbol(SymbolFlagsNone, "NewTargetExpression" /* as __String */)

	targetPropertySymbol := tc.createSymbol(SymbolFlagsProperty, "target" /* as __String */, CheckFlagsReadonly)
	targetPropertySymbol.parent = symbol
	targetPropertySymbol.links.type_ = targetType

	members := createSymbolTable([]TransientSymbol{targetPropertySymbol})
	symbol.members = members
	return tc.createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
}

func (tc *TypeChecker) getReturnTypeFromBody(func_ FunctionLikeDeclaration, checkMode CheckMode) Type {
	if !func_.body {
		return tc.errorType
	}

	functionFlags := getFunctionFlags(func_)
	isAsync := (functionFlags & FunctionFlagsAsync) != 0
	isGenerator := (functionFlags & FunctionFlagsGenerator) != 0

	var returnType Type
	var yieldType Type
	var nextType Type
	var fallbackReturnType Type = tc.voidType
	if func_.body.kind != SyntaxKindBlock {
		returnType = tc.checkExpressionCached(func_.body, checkMode && checkMode&~CheckModeSkipGenericFunctions)
		if isAsync {
			// From within an async function you can return either a non-promise value or a promise. Any
			// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
			// return type of the body should be unwrapped to its awaited type, which we will wrap in
			// the native Promise<T> type later in this function.
			returnType = tc.unwrapAwaitedType(tc.checkAwaitedType(returnType /*withAlias*/, false /*errorNode*/, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
		}
	} else if isGenerator {
		returnTypes := tc.checkAndAggregateReturnExpressionTypes(func_, checkMode)
		if !returnTypes {
			fallbackReturnType = tc.neverType
		} else if returnTypes.length > 0 {
			returnType = tc.getUnionType(returnTypes, UnionReductionSubtype)
		}
		TODO_IDENTIFIER := tc.checkAndAggregateYieldOperandTypes(func_, checkMode)
		if some(yieldTypes) {
			yieldType = tc.getUnionType(yieldTypes, UnionReductionSubtype)
		} else {
			yieldType = nil
		}
		if some(nextTypes) {
			nextType = tc.getIntersectionType(nextTypes)
		} else {
			nextType = nil
		}
	} else {
		types := tc.checkAndAggregateReturnExpressionTypes(func_, checkMode)
		if !types {
			// For an async function, the return type will not be never, but rather a Promise for never.
			if functionFlags & FunctionFlagsAsync {
				return tc.createPromiseReturnType(func_, tc.neverType)
			} else {
				return tc.neverType
			}
			// Normal function
		}
		if types.length == 0 {
			// For an async function, the return type will not be void/undefined, but rather a Promise for void/undefined.
			contextualReturnType := tc.getContextualReturnType(func_ /*contextFlags*/, nil)
			var returnType IntrinsicType
			if contextualReturnType && (tc.unwrapReturnType(contextualReturnType, functionFlags) || tc.voidType).flags&TypeFlagsUndefined {
				returnType = tc.undefinedType
			} else {
				returnType = tc.voidType
			}
			if functionFlags & FunctionFlagsAsync {
				return tc.createPromiseReturnType(func_, returnType)
			} else {
				return returnType
			}
			// Normal function
		}

		// Return a union of the return expression types.
		returnType = tc.getUnionType(types, UnionReductionSubtype)
	}

	if returnType || yieldType || nextType {
		if yieldType {
			tc.reportErrorsFromWidening(func_, yieldType, WideningKindGeneratorYield)
		}
		if returnType {
			tc.reportErrorsFromWidening(func_, returnType, WideningKindFunctionReturn)
		}
		if nextType {
			tc.reportErrorsFromWidening(func_, nextType, WideningKindGeneratorNext)
		}
		if returnType && tc.isUnitType(returnType) || yieldType && tc.isUnitType(yieldType) || nextType && tc.isUnitType(nextType) {
			contextualSignature := tc.getContextualSignatureForFunctionLikeDeclaration(func_)
			var contextualType Type
			switch {
			case !contextualSignature:
				contextualType = nil
			case contextualSignature == tc.getSignatureFromDeclaration(func_):
				if isGenerator {
					contextualType = nil
				} else {
					contextualType = returnType
				}
			default:
				contextualType = tc.instantiateContextualType(tc.getReturnTypeOfSignature(contextualSignature), func_ /*contextFlags*/, nil)
			}
			if isGenerator {
				yieldType = tc.getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKindYield, isAsync)
				returnType = tc.getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKindReturn, isAsync)
				nextType = tc.getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKindNext, isAsync)
			} else {
				returnType = tc.getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync)
			}
		}

		if yieldType {
			yieldType = tc.getWidenedType(yieldType)
		}
		if returnType {
			returnType = tc.getWidenedType(returnType)
		}
		if nextType {
			nextType = tc.getWidenedType(nextType)
		}
	}

	if isGenerator {
		return tc.createGeneratorType(yieldType || tc.neverType, returnType || fallbackReturnType, nextType || tc.getContextualIterationType(IterationTypeKindNext, func_) || tc.unknownType, isAsync)
	} else {
		// From within an async function you can return either a non-promise value or a promise. Any
		// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
		// return type of the body is awaited type of the body, wrapped in a native Promise<T> type.
		if isAsync {
			return tc.createPromiseType(returnType || fallbackReturnType)
		} else {
			return returnType || fallbackReturnType
		}
	}
}

func (tc *TypeChecker) createGeneratorType(yieldType Type, returnType Type, nextType Type, isAsyncGenerator bool) ObjectType {
	var resolver IterationTypesResolver
	if isAsyncGenerator {
		resolver = tc.asyncIterationTypesResolver
	} else {
		resolver = tc.syncIterationTypesResolver
	}
	globalGeneratorType := resolver.getGlobalGeneratorType(false)
	yieldType = resolver.resolveIterationType(yieldType /*errorNode*/, nil) || tc.unknownType
	returnType = resolver.resolveIterationType(returnType /*errorNode*/, nil) || tc.unknownType
	if globalGeneratorType == tc.emptyGenericType {
		// Fall back to the global IterableIterator type.
		globalIterableIteratorType := resolver.getGlobalIterableIteratorType(false)
		if globalIterableIteratorType != tc.emptyGenericType {
			return tc.createTypeFromGenericGlobalType(globalIterableIteratorType, []Type{yieldType, returnType, nextType})
		}

		// The global Generator type doesn't exist, so report an error
		resolver.getGlobalIterableIteratorType(true)
		return tc.emptyObjectType
	}

	return tc.createTypeFromGenericGlobalType(globalGeneratorType, []Type{yieldType, returnType, nextType})
}

func (tc *TypeChecker) checkAndAggregateYieldOperandTypes(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(TS-TO-GO) inferred type { yieldTypes: Type[]; nextTypes: Type[]; } */ any {
	var yieldTypes []Type = []never{}
	var nextTypes []Type = []never{}
	isAsync := (getFunctionFlags(func_) & FunctionFlagsAsync) != 0
	forEachYieldExpression(func_.body /* as Block */, func(yieldExpression YieldExpression) {
		var yieldExpressionType Type
		if yieldExpression.expression {
			yieldExpressionType = tc.checkExpression(yieldExpression.expression, checkMode)
		} else {
			yieldExpressionType = tc.undefinedWideningType
		}
		pushIfUnique(yieldTypes, tc.getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, tc.anyType, isAsync))
		var nextType Type
		if yieldExpression.asteriskToken {
			iterationTypes := tc.getIterationTypesOfIterable(yieldExpressionType, __COND__(isAsync, IterationUseAsyncYieldStar, IterationUseYieldStar), yieldExpression.expression)
			nextType = iterationTypes && iterationTypes.nextType
		} else {
			nextType = tc.getContextualType(yieldExpression /*contextFlags*/, nil)
		}
		if nextType {
			pushIfUnique(nextTypes, nextType)
		}
	})
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"yieldTypes": yieldTypes,
		"nextTypes":  nextTypes,
	}
}

func (tc *TypeChecker) getYieldedTypeOfYieldExpression(node YieldExpression, expressionType Type, sentType Type, isAsync bool) Type {
	errorNode := node.expression || node
	// A `yield*` expression effectively yields everything that its operand yields
	var yieldedType Type
	if node.asteriskToken {
		yieldedType = tc.checkIteratedTypeOrElementType(__COND__(isAsync, IterationUseAsyncYieldStar, IterationUseYieldStar), expressionType, sentType, errorNode)
	} else {
		yieldedType = expressionType
	}
	if !isAsync {
		return yieldedType
	} else {
		return tc.getAwaitedType(yieldedType, errorNode, __COND__(node.asteriskToken, Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member, Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
	}
}

// Return the combined not-equal type facts for all cases except those between the start and end indices.
func (tc *TypeChecker) getNotEqualFactsFromTypeofSwitch(start number, end number, witnesses []*string) TypeFacts {
	var facts TypeFacts = TypeFactsNone
	for i := 0; i < witnesses.length; i++ {
		var witness *string
		if i < start || i >= end {
			witness = witnesses[i]
		} else {
			witness = nil
		}
		if witness != nil {
			facts |= typeofNEFacts.get(witness) || TypeFactsTypeofNEHostObject
		} else {
			facts |= 0
		}
	}
	return facts
}

func (tc *TypeChecker) isExhaustiveSwitchStatement(node SwitchStatement) bool {
	links := tc.getNodeLinks(node)
	if links.isExhaustive == nil {
		links.isExhaustive = 0
		// Indicate resolution is in process
		exhaustive := tc.computeExhaustiveSwitchStatement(node)
		if links.isExhaustive == 0 {
			links.isExhaustive = exhaustive
		}
	} else if links.isExhaustive == 0 {
		links.isExhaustive = false
		// Resolve circularity to false
	}
	return links.isExhaustive
}

func (tc *TypeChecker) computeExhaustiveSwitchStatement(node SwitchStatement) bool {
	if node.expression.kind == SyntaxKindTypeOfExpression {
		witnesses := tc.getSwitchClauseTypeOfWitnesses(node)
		if !witnesses {
			return false
		}
		operandConstraint := tc.getBaseConstraintOrType(tc.checkExpressionCached((node.expression /* as TypeOfExpression */).expression))
		// Get the not-equal flags for all handled cases.
		notEqualFacts := tc.getNotEqualFactsFromTypeofSwitch(0, 0, witnesses)
		if operandConstraint.flags & TypeFlagsAnyOrUnknown {
			// We special case the top types to be exhaustive when all cases are handled.
			return (TypeFactsAllTypeofNE & notEqualFacts) == TypeFactsAllTypeofNE
		}
		// A missing not-equal flag indicates that the type wasn't handled by some case.
		return !tc.someType(operandConstraint, func(t Type) bool {
			return tc.getTypeFacts(t, notEqualFacts) == notEqualFacts
		})
	}
	type_ := tc.checkExpressionCached(node.expression)
	if !tc.isLiteralType(type_) {
		return false
	}
	switchTypes := tc.getSwitchClauseTypes(node)
	if !switchTypes.length || some(switchTypes, tc.isNeitherUnitTypeNorNever) {
		return false
	}
	return tc.eachTypeContainedIn(tc.mapType(type_, tc.getRegularTypeOfLiteralType), switchTypes)
}

func (tc *TypeChecker) functionHasImplicitReturn(func_ FunctionLikeDeclaration) *bool {
	return func_.endFlowNode && tc.isReachableFlowNode(func_.endFlowNode)
}

/** NOTE: Return value of `[]` means a different thing than `undefined`. `[]` means func returns `void`, `undefined` means it returns `never`. */

func (tc *TypeChecker) checkAndAggregateReturnExpressionTypes(func_ FunctionLikeDeclaration, checkMode *CheckMode) *[]Type {
	functionFlags := getFunctionFlags(func_)
	var aggregatedTypes []Type = []never{}
	hasReturnWithNoExpression := tc.functionHasImplicitReturn(func_)
	hasReturnOfTypeNever := false
	forEachReturnStatement(func_.body /* as Block */, func(returnStatement ReturnStatement) {
		expr := returnStatement.expression
		if expr {
			expr = skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
			// Bare calls to this same function don't contribute to inference
			// and `return await` is also safe to unwrap here
			if functionFlags&FunctionFlagsAsync && expr.kind == SyntaxKindAwaitExpression {
				expr = skipParentheses((expr /* as AwaitExpression */).expression /*excludeJSDocTypeAssertions*/, true)
			}
			if expr.kind == SyntaxKindCallExpression && (expr /* as CallExpression */).expression.kind == SyntaxKindIdentifier && tc.checkExpressionCached((expr /* as CallExpression */).expression).symbol == tc.getMergedSymbol(func_.symbol) && (!isFunctionExpressionOrArrowFunction(func_.symbol.valueDeclaration) || tc.isConstantReference((expr /* as CallExpression */).expression)) {
				hasReturnOfTypeNever = true
				return
			}

			type_ := tc.checkExpressionCached(expr, checkMode && checkMode&~CheckModeSkipGenericFunctions)
			if functionFlags & FunctionFlagsAsync {
				// From within an async function you can return either a non-promise value or a promise. Any
				// Promise/A+ compatible implementation will always assimilate any foreign promise, so the
				// return type of the body should be unwrapped to its awaited type, which should be wrapped in
				// the native Promise<T> type by the caller.
				type_ = tc.unwrapAwaitedType(tc.checkAwaitedType(type_ /*withAlias*/, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
			}
			if type_.flags & TypeFlagsNever {
				hasReturnOfTypeNever = true
			}
			pushIfUnique(aggregatedTypes, type_)
		} else {
			hasReturnWithNoExpression = true
		}
	})
	if aggregatedTypes.length == 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || tc.mayReturnNever(func_)) {
		return nil
	}
	if tc.strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(tc.isJSConstructor(func_) && aggregatedTypes.some(func(t Type) bool {
		return t.symbol == func_.symbol
	})) {
		// Javascript "callable constructors", containing eg `if (!(this instanceof A)) return new A()` should not add undefined
		pushIfUnique(aggregatedTypes, tc.undefinedType)
	}
	return aggregatedTypes
}

func (tc *TypeChecker) mayReturnNever(func_ FunctionLikeDeclaration) bool {
	switch func_.kind {
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return true
	case SyntaxKindMethodDeclaration:
		return func_.parent.kind == SyntaxKindObjectLiteralExpression
	default:
		return false
	}
}

func (tc *TypeChecker) getTypePredicateFromBody(func_ FunctionLikeDeclaration) *TypePredicate {
	switch func_.kind {
	case SyntaxKindConstructor,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor:
		return nil
	}
	functionFlags := getFunctionFlags(func_)
	if functionFlags != FunctionFlagsNormal {
		return nil
	}

	// Only attempt to infer a type predicate if there's exactly one return.
	var singleReturn Expression
	if func_.body && func_.body.kind != SyntaxKindBlock {
		singleReturn = func_.body
		// arrow function
	} else {
		bailedEarly := forEachReturnStatement(func_.body /* as Block */, func(returnStatement ReturnStatement) *true {
			if singleReturn || !returnStatement.expression {
				return true
			}
			singleReturn = returnStatement.expression
		})
		if bailedEarly || !singleReturn || tc.functionHasImplicitReturn(func_) {
			return nil
		}
	}
	return tc.checkIfExpressionRefinesAnyParameter(func_, singleReturn)
}

func (tc *TypeChecker) checkIfExpressionRefinesAnyParameter(func_ FunctionLikeDeclaration, expr Expression) *TypePredicate {
	expr = skipParentheses(expr /*excludeJSDocTypeAssertions*/, true)
	returnType := tc.checkExpressionCached(expr)
	if !(returnType.flags & TypeFlagsBoolean) {
		return nil
	}

	return forEach(func_.parameters, func(param ParameterDeclaration, i number) *TypePredicate {
		initType := tc.getTypeOfSymbol(param.symbol)
		if !initType || initType.flags&TypeFlagsBoolean || !isIdentifier(param.name) || tc.isSymbolAssigned(param.symbol) || isRestParameter(param) {
			// Refining "x: boolean" to "x is true" or "x is false" isn't useful.
			return
		}
		trueType := tc.checkIfExpressionRefinesParameter(func_, expr, param, initType)
		if trueType {
			return tc.createTypePredicate(TypePredicateKindIdentifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType)
		}
	})
}

func (tc *TypeChecker) checkIfExpressionRefinesParameter(func_ FunctionLikeDeclaration, expr Expression, param ParameterDeclaration, initType Type) Type {
	antecedent := (expr /* as Expression & { flowNode?: FlowNode; } */).flowNode || expr.parent.kind == SyntaxKindReturnStatement && (expr.parent /* as ReturnStatement */).flowNode || createFlowNode(FlowFlagsStart /*node*/, nil /*antecedent*/, nil)
	trueCondition := createFlowNode(FlowFlagsTrueCondition, expr, antecedent)

	trueType := tc.getFlowTypeOfReference(param.name, initType, initType, func_, trueCondition)
	if trueType == initType {
		return nil
	}

	// "x is T" means that x is T if and only if it returns true. If it returns false then x is not T.
	// This means that if the function is called with an argument of type trueType, there can't be anything left in the `else` branch. It must reduce to `never`.
	falseCondition := createFlowNode(FlowFlagsFalseCondition, expr, antecedent)
	falseSubtype := tc.getFlowTypeOfReference(param.name, initType, trueType, func_, falseCondition)
	if falseSubtype.flags & TypeFlagsNever {
		return trueType
	} else {
		return nil
	}
}

/**
 * TypeScript Specification 1.0 (6.3) - July 2014
 *   An explicitly typed function whose return type isn't the Void type,
 *   the Any type, or a union type containing the Void or Any type as a constituent
 *   must have at least one return statement somewhere in its body.
 *   An exception to this rule is if the function implementation consists of a single 'throw' statement.
 *
 * @param returnType - return type of the function, can be undefined if return type is not explicitly specified
 */

func (tc *TypeChecker) checkAllCodePathsInNonVoidFunctionReturnOrThrow(func_ /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any, returnType Type) {
	tc.addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics)
	return

	checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics := func() {
		functionFlags := getFunctionFlags(func_)
		type_ := returnType && tc.unwrapReturnType(returnType, functionFlags)

		// Functions with an explicitly specified return type that includes `void` or is exactly `any` or `undefined` don't
		// need any return statements.
		if type_ && (tc.maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)) {
			return
		}

		// If all we have is a function signature, or an arrow function with an expression body, then there is nothing to check.
		// also if HasImplicitReturn flag is not set this means that all codepaths in function body end with return or throw
		if func_.kind == SyntaxKindMethodSignature || nodeIsMissing(func_.body) || func_.body.kind != SyntaxKindBlock || !tc.functionHasImplicitReturn(func_) {
			return
		}

		hasExplicitReturn := func_.flags & NodeFlagsHasExplicitReturn
		errorNode := getEffectiveReturnTypeNode(func_) || func_

		if type_ && type_.flags&TypeFlagsNever {
			tc.error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point)
		} else if type_ && !hasExplicitReturn {
			// minimal check: function has syntactic return type annotation and no explicit return statements in the body
			// this function does not conform to the specification.
			tc.error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value)
		} else if type_ && tc.strictNullChecks && !tc.isTypeAssignableTo(tc.undefinedType, type_) {
			tc.error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined)
		} else if tc.compilerOptions.noImplicitReturns {
			if !type_ {
				// If return type annotation is omitted check if function has any explicit return statements.
				// If it does not have any - its inferred return type is void - don't do any checks.
				// Otherwise get inferred return type from function body and report error only if it is not void / anytype
				if !hasExplicitReturn {
					return
				}
				inferredReturnType := tc.getReturnTypeOfSignature(tc.getSignatureFromDeclaration(func_))
				if tc.isUnwrappedReturnTypeUndefinedVoidOrAny(func_, inferredReturnType) {
					return
				}
			}
			tc.error(errorNode, Diagnostics.Not_all_code_paths_return_a_value)
		}
	}

}

func (tc *TypeChecker) checkFunctionExpressionOrObjectLiteralMethod(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) Type {
	Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))
	tc.checkNodeDeferred(node)

	if isFunctionExpression(node) {
		tc.checkCollisionsForDeclarationName(node, node.name)
	}

	// The identityMapper object is used to indicate that function expressions are wildcards
	if checkMode && checkMode&CheckModeSkipContextSensitive && tc.isContextSensitive(node) {
		// Skip parameters, return signature with return type that retains noncontextual parts so inferences can still be drawn in an early stage
		if !getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node) {
			// Return plain anyFunctionType if there is no possibility we'll make inferences from the return type
			contextualSignature := tc.getContextualSignature(node)
			if contextualSignature && tc.couldContainTypeVariables(tc.getReturnTypeOfSignature(contextualSignature)) {
				links := tc.getNodeLinks(node)
				if links.contextFreeType {
					return links.contextFreeType
				}
				returnType := tc.getReturnTypeFromBody(node, checkMode)
				returnOnlySignature := tc.createSignature(nil /*typeParameters*/, nil /*thisParameter*/, nil, emptyArray, returnType /*resolvedTypePredicate*/, nil, 0, SignatureFlagsIsNonInferrable)
				returnOnlyType := tc.createAnonymousType(node.symbol, tc.emptySymbols, []Signature{returnOnlySignature}, emptyArray, emptyArray)
				returnOnlyType.objectFlags |= ObjectFlagsNonInferrableType
				links.contextFreeType = returnOnlyType
				return links.contextFreeType
			}
		}
		return tc.anyFunctionType
	}

	// Grammar checking
	hasGrammarError := tc.checkGrammarFunctionLikeDeclaration(node)
	if !hasGrammarError && node.kind == SyntaxKindFunctionExpression {
		tc.checkGrammarForGenerator(node)
	}

	tc.contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode)

	return tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node))
}

func (tc *TypeChecker) contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) {
	links := tc.getNodeLinks(node)
	// Check if function expression is contextually typed and assign parameter types if so.
	if !(links.flags & NodeCheckFlagsContextChecked) {
		contextualSignature := tc.getContextualSignature(node)
		// If a type check is started at a function expression that is an argument of a function call, obtaining the
		// contextual type may recursively get back to here during overload resolution of the call. If so, we will have
		// already assigned contextual types.
		if !(links.flags & NodeCheckFlagsContextChecked) {
			links.flags |= NodeCheckFlagsContextChecked
			signature := firstOrUndefined(tc.getSignaturesOfType(tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node)), SignatureKindCall))
			if !signature {
				return
			}
			if tc.isContextSensitive(node) {
				if contextualSignature {
					inferenceContext := tc.getInferenceContext(node)
					var instantiatedContextualSignature *Signature
					if checkMode && checkMode&CheckModeInferential {
						tc.inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
						restType := tc.getEffectiveRestType(contextualSignature)
						if restType && restType.flags&TypeFlagsTypeParameter {
							instantiatedContextualSignature = tc.instantiateSignature(contextualSignature, inferenceContext.nonFixingMapper)
						}
					}
					if inferenceContext {
						instantiatedContextualSignature = instantiatedContextualSignature || tc.instantiateSignature(contextualSignature, inferenceContext.mapper)
					} else {
						instantiatedContextualSignature = instantiatedContextualSignature || contextualSignature
					}
					tc.assignContextualParameterTypes(signature, instantiatedContextualSignature)
				} else {
					// Force resolution of all parameter types such that the absence of a contextual type is consistently reflected.
					tc.assignNonContextualParameterTypes(signature)
				}
			} else if contextualSignature && !node.typeParameters && contextualSignature.parameters.length > node.parameters.length {
				inferenceContext := tc.getInferenceContext(node)
				if checkMode && checkMode&CheckModeInferential {
					tc.inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext)
				}
			}
			if contextualSignature && !tc.getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType {
				returnType := tc.getReturnTypeFromBody(node, checkMode)
				if !signature.resolvedReturnType {
					signature.resolvedReturnType = returnType
				}
			}
			tc.checkSignatureDeclaration(node)
		}
	}
}

func (tc *TypeChecker) checkFunctionExpressionOrObjectLiteralMethodDeferred(node /* TODO(TS-TO-GO) TypeNode UnionType: ArrowFunction | FunctionExpression | MethodDeclaration */ any) {
	Debug.assert(node.kind != SyntaxKindMethodDeclaration || isObjectLiteralMethod(node))

	functionFlags := getFunctionFlags(node)
	returnType := tc.getReturnTypeFromAnnotation(node)
	tc.checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)

	if node.body {
		if !getEffectiveReturnTypeNode(node) {
			// There are some checks that are only performed in getReturnTypeFromBody, that may produce errors
			// we need. An example is the noImplicitAny errors resulting from widening the return expression
			// of a function. Because checking of function expression bodies is deferred, there was never an
			// appropriate time to do this during the main walk of the file (see the comment at the top of
			// checkFunctionExpressionBodies). So it must be done now.
			tc.getReturnTypeOfSignature(tc.getSignatureFromDeclaration(node))
		}

		if node.body.kind == SyntaxKindBlock {
			tc.checkSourceElement(node.body)
		} else {
			// From within an async function you can return either a non-promise value or a promise. Any
			// Promise/A+ compatible implementation will always assimilate any foreign promise, so we
			// should not be checking assignability of a promise to the return type. Instead, we need to
			// check assignability of the awaited type of the expression body against the promised type of
			// its return type annotation.
			exprType := tc.checkExpression(node.body)
			returnOrPromisedType := returnType && tc.unwrapReturnType(returnType, functionFlags)
			if returnOrPromisedType {
				effectiveCheckNode := tc.getEffectiveCheckNode(node.body)
				if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
					awaitedType := tc.checkAwaitedType(exprType /*withAlias*/, false, effectiveCheckNode, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
					tc.checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
				} else {
					tc.checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
				}
			}
		}
	}
}

func (tc *TypeChecker) checkArithmeticOperandType(operand Node, type_ Type, diagnostic DiagnosticMessage, isAwaitValid bool /*  = false */) bool {
	if !tc.isTypeAssignableTo(type_, tc.numberOrBigIntType) {
		awaitedType := isAwaitValid && tc.getAwaitedTypeOfPromise(type_)
		tc.errorAndMaybeSuggestAwait(operand, !!awaitedType && tc.isTypeAssignableTo(awaitedType, tc.numberOrBigIntType), diagnostic)
		return false
	}
	return true
}

func (tc *TypeChecker) isReadonlyAssignmentDeclaration(d Declaration) bool {
	if !isCallExpression(d) {
		return false
	}
	if !isBindableObjectDefinePropertyCall(d) {
		return false
	}
	objectLitType := tc.checkExpressionCached(d.arguments[2])
	valueType := tc.getTypeOfPropertyOfType(objectLitType, "value" /* as __String */)
	if valueType {
		writableProp := tc.getPropertyOfType(objectLitType, "writable" /* as __String */)
		writableType := writableProp && tc.getTypeOfSymbol(writableProp)
		if !writableType || writableType == tc.falseType || writableType == tc.regularFalseType {
			return true
		}
		// We include this definition whereupon we walk back and check the type at the declaration because
		// The usual definition of `Object.defineProperty` will _not_ cause literal types to be preserved in the
		// argument types, should the type be contextualized by the call itself.
		if writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration) {
			initializer := writableProp.valueDeclaration.initializer
			rawOriginalType := tc.checkExpression(initializer)
			if rawOriginalType == tc.falseType || rawOriginalType == tc.regularFalseType {
				return true
			}
		}
		return false
	}
	setProp := tc.getPropertyOfType(objectLitType, "set" /* as __String */)
	return !setProp
}

func (tc *TypeChecker) isReadonlySymbol(symbol Symbol) bool {
	// The following symbols are considered read-only:
	// Properties with a 'readonly' modifier
	// Variables declared with 'const'
	// Get accessors without matching set accessors
	// Enum members
	// Object.defineProperty assignments with writable false or no setter
	// Unions and intersections of the above (unions and intersections eagerly set isReadonly on creation)
	return !!(getCheckFlags(symbol)&CheckFlagsReadonly || symbol.flags&SymbolFlagsProperty && getDeclarationModifierFlagsFromSymbol(symbol)&ModifierFlagsReadonly || symbol.flags&SymbolFlagsVariable && tc.getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant || symbol.flags&SymbolFlagsAccessor && !(symbol.flags&SymbolFlagsSetAccessor) || symbol.flags&SymbolFlagsEnumMember || some(symbol.declarations, tc.isReadonlyAssignmentDeclaration))
}

func (tc *TypeChecker) isAssignmentToReadonlyEntity(expr Expression, symbol Symbol, assignmentKind AssignmentKind) bool {
	if assignmentKind == AssignmentKindNone {
		// no assigment means it doesn't matter whether the entity is readonly
		return false
	}
	if tc.isReadonlySymbol(symbol) {
		// Allow assignments to readonly properties within constructors of the same class declaration.
		if symbol.flags&SymbolFlagsProperty && isAccessExpression(expr) && expr.expression.kind == SyntaxKindThisKeyword {
			// Look for if this is the constructor for the class that `symbol` is a property of.
			ctor := getContainingFunction(expr)
			if !(ctor && (ctor.kind == SyntaxKindConstructor || tc.isJSConstructor(ctor))) {
				return true
			}
			if symbol.valueDeclaration {
				isAssignmentDeclaration := isBinaryExpression(symbol.valueDeclaration)
				isLocalPropertyDeclaration := ctor.parent == symbol.valueDeclaration.parent
				isLocalParameterProperty := ctor == symbol.valueDeclaration.parent
				isLocalThisPropertyAssignment := isAssignmentDeclaration && symbol.parent. /* ? */ valueDeclaration == ctor.parent
				isLocalThisPropertyAssignmentConstructorFunction := isAssignmentDeclaration && symbol.parent. /* ? */ valueDeclaration == ctor
				isWriteableSymbol := isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction
				return !isWriteableSymbol
			}
		}
		return true
	}
	if isAccessExpression(expr) {
		// references through namespace import should be readonly
		node := skipParentheses(expr.expression)
		if node.kind == SyntaxKindIdentifier {
			symbol := tc.getNodeLinks(node).resolvedSymbol
			if symbol.flags & SymbolFlagsAlias {
				declaration := tc.getDeclarationOfAliasSymbol(symbol)
				return !!declaration && declaration.kind == SyntaxKindNamespaceImport
			}
		}
	}
	return false
}

func (tc *TypeChecker) checkReferenceExpression(expr Expression, invalidReferenceMessage DiagnosticMessage, invalidOptionalChainMessage DiagnosticMessage) bool {
	// References are combinations of identifiers, parentheses, and property accesses.
	node := skipOuterExpressions(expr, OuterExpressionKindsAssertions|OuterExpressionKindsParentheses)
	if node.kind != SyntaxKindIdentifier && !isAccessExpression(node) {
		tc.error(expr, invalidReferenceMessage)
		return false
	}
	if node.flags & NodeFlagsOptionalChain {
		tc.error(expr, invalidOptionalChainMessage)
		return false
	}
	return true
}

func (tc *TypeChecker) checkDeleteExpression(node DeleteExpression) Type {
	tc.checkExpression(node.expression)
	expr := skipParentheses(node.expression)
	if !isAccessExpression(expr) {
		tc.error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference)
		return tc.booleanType
	}
	if isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name) {
		tc.error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier)
	}
	links := tc.getNodeLinks(expr)
	symbol := tc.getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol)
	if symbol {
		if tc.isReadonlySymbol(symbol) {
			tc.error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property)
		} else {
			tc.checkDeleteExpressionMustBeOptional(expr, symbol)
		}
	}
	return tc.booleanType
}

func (tc *TypeChecker) checkDeleteExpressionMustBeOptional(expr AccessExpression, symbol Symbol) {
	type_ := tc.getTypeOfSymbol(symbol)
	if tc.strictNullChecks && !(type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsNever)) && !(__COND__(tc.exactOptionalPropertyTypes, symbol.flags&SymbolFlagsOptional, tc.hasTypeFacts(type_, TypeFactsIsUndefined))) {
		tc.error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional)
	}
}

func (tc *TypeChecker) checkTypeOfExpression(node TypeOfExpression) Type {
	tc.checkExpression(node.expression)
	return tc.typeofType
}

func (tc *TypeChecker) checkVoidExpression(node VoidExpression) Type {
	tc.checkNodeDeferred(node)
	return tc.undefinedWideningType
}

func (tc *TypeChecker) checkAwaitGrammar(node /* TODO(TS-TO-GO) TypeNode UnionType: AwaitExpression | VariableDeclarationList */ any) bool {
	// Grammar checking
	hasError := false
	container := getContainingFunctionOrClassStaticBlock(node)
	if container && isClassStaticBlockDeclaration(container) {
		// NOTE: We report this regardless as to whether there are parse diagnostics.
		var message DiagnosticMessage
		if isAwaitExpression(node) {
			message = Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block
		} else {
			message = Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block
		}
		tc.error(node, message)
		hasError = true
	} else if !(node.flags & NodeFlagsAwaitContext) {
		if isInTopLevelContext(node) {
			sourceFile := getSourceFileOfNode(node)
			if !tc.hasParseDiagnostics(sourceFile) {
				var span *TextSpan
				if !isEffectiveExternalModule(sourceFile, tc.compilerOptions) {
					/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
					var message DiagnosticMessage
					if isAwaitExpression(node) {
						message = Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module
					} else {
						message = Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module
					}
					diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
					tc.diagnostics.add(diagnostic)
					hasError = true
				}
				switch tc.moduleKind {
				case ModuleKindNode16,
					ModuleKindNodeNext:
					if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
						/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
						tc.diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
						hasError = true
						break
					}
					fallthrough
				case ModuleKindES2022,
					ModuleKindESNext,
					ModuleKindPreserve,
					ModuleKindSystem:
					if tc.languageVersion >= ScriptTargetES2017 {
						break
					}
					fallthrough
				default:
					/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: span ??= getSpanOfTokenAtPosition(sourceFile, node.pos) */ TODO
					var message DiagnosticMessage
					if isAwaitExpression(node) {
						message = Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher
					} else {
						message = Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher
					}
					tc.diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message))
					hasError = true
				}
			}
		} else {
			// use of 'await' in non-async function
			sourceFile := getSourceFileOfNode(node)
			if !tc.hasParseDiagnostics(sourceFile) {
				span := getSpanOfTokenAtPosition(sourceFile, node.pos)
				var message DiagnosticMessage
				if isAwaitExpression(node) {
					message = Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules
				} else {
					message = Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules
				}
				diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
				if container && container.kind != SyntaxKindConstructor && (getFunctionFlags(container)&FunctionFlagsAsync) == 0 {
					relatedInfo := createDiagnosticForNode(container, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
					addRelatedInfo(diagnostic, relatedInfo)
				}
				tc.diagnostics.add(diagnostic)
				hasError = true
			}
		}
	}

	if isAwaitExpression(node) && tc.isInParameterInitializerBeforeContainingFunction(node) {
		// NOTE: We report this regardless as to whether there are parse diagnostics.
		tc.error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer)
		hasError = true
	}

	return hasError
}

func (tc *TypeChecker) checkAwaitExpression(node AwaitExpression) Type {
	tc.addLazyDiagnostic(func() bool {
		return tc.checkAwaitGrammar(node)
	})

	operandType := tc.checkExpression(node.expression)
	awaitedType := tc.checkAwaitedType(operandType /*withAlias*/, true, node, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
	if awaitedType == operandType && !tc.isErrorType(awaitedType) && !(operandType.flags & TypeFlagsAnyOrUnknown) {
		tc.addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression))
	}
	return awaitedType
}

func (tc *TypeChecker) checkPrefixUnaryExpression(node PrefixUnaryExpression) Type {
	operandType := tc.checkExpression(node.operand)
	if operandType == tc.silentNeverType {
		return tc.silentNeverType
	}
	switch node.operand.kind {
	case SyntaxKindNumericLiteral:
		switch node.operator {
		case SyntaxKindMinusToken:
			return tc.getFreshTypeOfLiteralType(tc.getNumberLiteralType(-(node.operand /* as NumericLiteral */).text))
		case SyntaxKindPlusToken:
			return tc.getFreshTypeOfLiteralType(tc.getNumberLiteralType(+(node.operand /* as NumericLiteral */).text))
		}
	case SyntaxKindBigIntLiteral:
		if node.operator == SyntaxKindMinusToken {
			return tc.getFreshTypeOfLiteralType(tc.getBigIntLiteralType(map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"negative":    true,
				"base10Value": parsePseudoBigInt((node.operand /* as BigIntLiteral */).text),
			}))
		}
	}
	switch node.operator {
	case SyntaxKindPlusToken,
		SyntaxKindMinusToken,
		SyntaxKindTildeToken:
		tc.checkNonNullType(operandType, node.operand)
		if tc.maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsESSymbolLike) {
			tc.error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator))
		}
		if node.operator == SyntaxKindPlusToken {
			if tc.maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlagsBigIntLike) {
				tc.error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), tc.typeToString(tc.getBaseTypeOfLiteralType(operandType)))
			}
			return tc.numberType
		}
		return tc.getUnaryResultType(operandType)
	case SyntaxKindExclamationToken:
		tc.checkTruthinessOfType(operandType, node.operand)
		facts := tc.getTypeFacts(operandType, TypeFactsTruthy|TypeFactsFalsy)
		switch {
		case facts == TypeFactsTruthy:
			return tc.falseType
		case facts == TypeFactsFalsy:
			return tc.trueType
		default:
			return tc.booleanType
		}
	case SyntaxKindPlusPlusToken,
		SyntaxKindMinusMinusToken:
		ok := tc.checkArithmeticOperandType(node.operand, tc.checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
		if ok {
			// run check only if former checks succeeded to avoid reporting cascading errors
			tc.checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
		}
		return tc.getUnaryResultType(operandType)
	}
	return tc.errorType
}

func (tc *TypeChecker) checkPostfixUnaryExpression(node PostfixUnaryExpression) Type {
	operandType := tc.checkExpression(node.operand)
	if operandType == tc.silentNeverType {
		return tc.silentNeverType
	}
	ok := tc.checkArithmeticOperandType(node.operand, tc.checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
	if ok {
		// run check only if former checks succeeded to avoid reporting cascading errors
		tc.checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
	}
	return tc.getUnaryResultType(operandType)
}

func (tc *TypeChecker) getUnaryResultType(operandType Type) Type {
	if tc.maybeTypeOfKind(operandType, TypeFlagsBigIntLike) {
		if tc.isTypeAssignableToKind(operandType, TypeFlagsAnyOrUnknown) || tc.maybeTypeOfKind(operandType, TypeFlagsNumberLike) {
			return tc.numberOrBigIntType
		} else {
			return tc.bigintType
		}
	}
	// If it's not a bigint type, implicit coercion will result in a number
	return tc.numberType
}

func (tc *TypeChecker) maybeTypeOfKindConsideringBaseConstraint(type_ Type, kind TypeFlags) bool {
	if tc.maybeTypeOfKind(type_, kind) {
		return true
	}

	baseConstraint := tc.getBaseConstraintOrType(type_)
	return !!baseConstraint && tc.maybeTypeOfKind(baseConstraint, kind)
}

// Return true if type might be of the given kind. A union or intersection type might be of a given
// kind if at least one constituent type is of the given kind.
func (tc *TypeChecker) maybeTypeOfKind(type_ Type, kind TypeFlags) bool {
	if type_.flags & kind {
		return true
	}
	if type_.flags & TypeFlagsUnionOrIntersection {
		types := (type_ /* as UnionOrIntersectionType */).types
		for _, t := range types {
			if tc.maybeTypeOfKind(t, kind) {
				return true
			}
		}
	}
	return false
}

func (tc *TypeChecker) isTypeAssignableToKind(source Type, kind TypeFlags, strict bool) bool {
	if source.flags & kind {
		return true
	}
	if strict && source.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull) {
		return false
	}
	return !!(kind&TypeFlagsNumberLike) && tc.isTypeAssignableTo(source, tc.numberType) || !!(kind&TypeFlagsBigIntLike) && tc.isTypeAssignableTo(source, tc.bigintType) || !!(kind&TypeFlagsStringLike) && tc.isTypeAssignableTo(source, tc.stringType) || !!(kind&TypeFlagsBooleanLike) && tc.isTypeAssignableTo(source, tc.booleanType) || !!(kind&TypeFlagsVoid) && tc.isTypeAssignableTo(source, tc.voidType) || !!(kind&TypeFlagsNever) && tc.isTypeAssignableTo(source, tc.neverType) || !!(kind&TypeFlagsNull) && tc.isTypeAssignableTo(source, tc.nullType) || !!(kind&TypeFlagsUndefined) && tc.isTypeAssignableTo(source, tc.undefinedType) || !!(kind&TypeFlagsESSymbol) && tc.isTypeAssignableTo(source, tc.esSymbolType) || !!(kind&TypeFlagsNonPrimitive) && tc.isTypeAssignableTo(source, tc.nonPrimitiveType)
}

func (tc *TypeChecker) allTypesAssignableToKind(source Type, kind TypeFlags, strict bool) bool {
	if source.flags & TypeFlagsUnion {
		return every((source /* as UnionType */).types, func(subType Type) bool {
			return tc.allTypesAssignableToKind(subType, kind, strict)
		})
	} else {
		return tc.isTypeAssignableToKind(source, kind, strict)
	}
}

func (tc *TypeChecker) isConstEnumObjectType(type_ Type) bool {
	return !!(getObjectFlags(type_) & ObjectFlagsAnonymous) && !!type_.symbol && tc.isConstEnumSymbol(type_.symbol)
}

func (tc *TypeChecker) isConstEnumSymbol(symbol Symbol) bool {
	return (symbol.flags & SymbolFlagsConstEnum) != 0
}

/**
 * Get the type of the `[Symbol.hasInstance]` method of an object type.
 */

func (tc *TypeChecker) getSymbolHasInstanceMethodOfObjectType(type_ Type) Type {
	hasInstancePropertyName := tc.getPropertyNameForKnownSymbolName("hasInstance")
	if tc.allTypesAssignableToKind(type_, TypeFlagsNonPrimitive) {
		hasInstanceProperty := tc.getPropertyOfType(type_, hasInstancePropertyName)
		if hasInstanceProperty {
			hasInstancePropertyType := tc.getTypeOfSymbol(hasInstanceProperty)
			if hasInstancePropertyType && tc.getSignaturesOfType(hasInstancePropertyType, SignatureKindCall).length != 0 {
				return hasInstancePropertyType
			}
		}
	}
}

func (tc *TypeChecker) checkInstanceOfExpression(left Expression, right Expression, leftType Type, rightType Type, checkMode CheckMode) Type {
	if leftType == tc.silentNeverType || rightType == tc.silentNeverType {
		return tc.silentNeverType
	}

	// TypeScript 1.0 spec (April 2014): 4.15.4
	// The instanceof operator requires the left operand to be of type Any, an object type, or a type parameter type,
	// and the right operand to be of type Any, a subtype of the 'Function' interface type, or have a call or construct signature.
	// The result is always of the Boolean primitive type.
	// NOTE: do not raise error if leftType is unknown as related error was already reported
	if !tc.isTypeAny(leftType) && tc.allTypesAssignableToKind(leftType, TypeFlagsPrimitive) {
		tc.error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter)
	}

	Debug.assert(isInstanceOfExpression(left.parent))
	signature := tc.getResolvedSignature(left.parent /*candidatesOutArray*/, nil, checkMode)
	if signature == tc.resolvingSignature {
		// CheckMode.SkipGenericFunctions is enabled and this is a call to a generic function that
		// returns a function type. We defer checking and return silentNeverType.
		return tc.silentNeverType
	}

	// If rightType has a `[Symbol.hasInstance]` method that is not `(value: unknown) => boolean`, we
	// must check the expression as if it were a call to `right[Symbol.hasInstance](left)`. The call to
	// `getResolvedSignature`, below, will check that leftType is assignable to the type of the first
	// parameter.
	returnType := tc.getReturnTypeOfSignature(signature)

	// We also verify that the return type of the `[Symbol.hasInstance]` method is assignable to
	// `boolean`. According to the spec, the runtime will actually perform `ToBoolean` on the result,
	// but this is more type-safe.
	tc.checkTypeAssignableTo(returnType, tc.booleanType, right, Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression)

	return tc.booleanType
}

func (tc *TypeChecker) hasEmptyObjectIntersection(type_ Type) bool {
	return tc.someType(type_, func(t Type) bool {
		return t == tc.unknownEmptyObjectType || !!(t.flags&TypeFlagsIntersection) && tc.isEmptyAnonymousObjectType(tc.getBaseConstraintOrType(t))
	})
}

func (tc *TypeChecker) checkInExpression(left Expression, right Expression, leftType Type, rightType Type) Type {
	if leftType == tc.silentNeverType || rightType == tc.silentNeverType {
		return tc.silentNeverType
	}
	if isPrivateIdentifier(left) {
		if tc.languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || tc.languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !tc.useDefineForClassFields {
			tc.checkExternalEmitHelpers(left, ExternalEmitHelpersClassPrivateFieldIn)
		}
		// Unlike in 'checkPrivateIdentifierExpression' we now have access to the RHS type
		// which provides us with the opportunity to emit more detailed errors
		if !tc.getNodeLinks(left).resolvedSymbol && getContainingClass(left) {
			isUncheckedJS := tc.isUncheckedJSSuggestion(left, rightType.symbol /*excludeClasses*/, true)
			tc.reportNonexistentProperty(left, rightType, isUncheckedJS)
		}
	} else {
		// The type of the lef operand must be assignable to string, number, or symbol.
		tc.checkTypeAssignableTo(tc.checkNonNullType(leftType, left), tc.stringNumberSymbolType, left)
	}
	// The type of the right operand must be assignable to 'object'.
	if tc.checkTypeAssignableTo(tc.checkNonNullType(rightType, right), tc.nonPrimitiveType, right) {
		// The {} type is assignable to the object type, yet {} might represent a primitive type. Here we
		// detect and error on {} that results from narrowing the unknown type, as well as intersections
		// that include {} (we know that the other types in such intersections are assignable to object
		// since we already checked for that).
		if tc.hasEmptyObjectIntersection(rightType) {
			tc.error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, tc.typeToString(rightType))
		}
	}
	// The result is always of the Boolean primitive type.
	return tc.booleanType
}

func (tc *TypeChecker) checkObjectLiteralAssignment(node ObjectLiteralExpression, sourceType Type, rightIsThis bool) Type {
	properties := node.properties
	if tc.strictNullChecks && properties.length == 0 {
		return tc.checkNonNullType(sourceType, node)
	}
	for i := 0; i < properties.length; i++ {
		tc.checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis)
	}
	return sourceType
}

/** Note: If property cannot be a SpreadAssignment, then allProperties does not need to be provided */

func (tc *TypeChecker) checkObjectLiteralDestructuringPropertyAssignment(node ObjectLiteralExpression, objectLiteralType Type, propertyIndex number, allProperties NodeArray[ObjectLiteralElementLike], rightIsThis bool /*  = false */) Type {
	properties := node.properties
	property := properties[propertyIndex]
	if property.kind == SyntaxKindPropertyAssignment || property.kind == SyntaxKindShorthandPropertyAssignment {
		name := property.name
		exprType := tc.getLiteralTypeFromPropertyName(name)
		if isTypeUsableAsPropertyName(exprType) {
			text := getPropertyNameFromType(exprType)
			prop := tc.getPropertyOfType(objectLiteralType, text)
			if prop {
				tc.markPropertyAsReferenced(prop, property, rightIsThis)
				tc.checkPropertyAccessibility(property /*isSuper*/, false /*writing*/, true, objectLiteralType, prop)
			}
		}
		elementType := tc.getIndexedAccessType(objectLiteralType, exprType, AccessFlagsExpressionPosition|(__COND__(tc.hasDefaultValue(property), AccessFlagsAllowMissing, 0)), name)
		type_ := tc.getFlowTypeOfDestructuring(property, elementType)
		return tc.checkDestructuringAssignment(__COND__(property.kind == SyntaxKindShorthandPropertyAssignment, property, property.initializer), type_)
	} else if property.kind == SyntaxKindSpreadAssignment {
		if propertyIndex < properties.length-1 {
			tc.error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
		} else {
			if tc.languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
				tc.checkExternalEmitHelpers(property, ExternalEmitHelpersRest)
			}
			var nonRestNames []PropertyName = []never{}
			if allProperties {
				for _, otherProperty := range allProperties {
					if !isSpreadAssignment(otherProperty) {
						nonRestNames.push(otherProperty.name)
					}
				}
			}
			type_ := tc.getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol)
			tc.checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
			return tc.checkDestructuringAssignment(property.expression, type_)
		}
	} else {
		tc.error(property, Diagnostics.Property_assignment_expected)
	}
}

func (tc *TypeChecker) checkArrayLiteralAssignment(node ArrayLiteralExpression, sourceType Type, checkMode CheckMode) Type {
	elements := node.elements
	if tc.languageVersion < LanguageFeatureMinimumTargetDestructuringAssignment && tc.compilerOptions.downlevelIteration {
		tc.checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
	}
	// This elementType will be used if the specific property corresponding to this index is not
	// present (aka the tuple element property). This call also checks that the parentType is in
	// fact an iterable or array (depending on target language).
	possiblyOutOfBoundsType := tc.checkIteratedTypeOrElementType(IterationUseDestructuring|IterationUsePossiblyOutOfBounds, sourceType, tc.undefinedType, node) || tc.errorType
	var inBoundsType Type
	if tc.compilerOptions.noUncheckedIndexedAccess {
		inBoundsType = nil
	} else {
		inBoundsType = possiblyOutOfBoundsType
	}
	for i := 0; i < elements.length; i++ {
		type_ := possiblyOutOfBoundsType
		if node.elements[i].kind == SyntaxKindSpreadElement {
			type_ = /* TODO(TS-TO-GO) EqualsToken BinaryExpression: inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType) */ TODO
		}
		tc.checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type_, checkMode)
	}
	return sourceType
}

func (tc *TypeChecker) checkArrayLiteralDestructuringElementAssignment(node ArrayLiteralExpression, sourceType Type, elementIndex number, elementType Type, checkMode CheckMode) Type {
	elements := node.elements
	element := elements[elementIndex]
	if element.kind != SyntaxKindOmittedExpression {
		if element.kind != SyntaxKindSpreadElement {
			indexType := tc.getNumberLiteralType(elementIndex)
			if tc.isArrayLikeType(sourceType) {
				// We create a synthetic expression so that getIndexedAccessType doesn't get confused
				// when the element is a SyntaxKind.ElementAccessExpression.
				accessFlags := AccessFlagsExpressionPosition | (__COND__(tc.hasDefaultValue(element), AccessFlagsAllowMissing, 0))
				elementType := tc.getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, tc.createSyntheticExpression(element, indexType)) || tc.errorType
				var assignedType Type
				if tc.hasDefaultValue(element) {
					assignedType = tc.getTypeWithFacts(elementType, TypeFactsNEUndefined)
				} else {
					assignedType = elementType
				}
				type_ := tc.getFlowTypeOfDestructuring(element, assignedType)
				return tc.checkDestructuringAssignment(element, type_, checkMode)
			}
			return tc.checkDestructuringAssignment(element, elementType, checkMode)
		}
		if elementIndex < elements.length-1 {
			tc.error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
		} else {
			restExpression := (element /* as SpreadElement */).expression
			if restExpression.kind == SyntaxKindBinaryExpression && (restExpression /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken {
				tc.error((restExpression /* as BinaryExpression */).operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer)
			} else {
				tc.checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
				var type_ Type
				if tc.everyType(sourceType, tc.isTupleType) {
					type_ = tc.mapType(sourceType, func(t Type) Type {
						return tc.sliceTupleType(t /* as TupleTypeReference */, elementIndex)
					})
				} else {
					type_ = tc.createArrayType(elementType)
				}
				return tc.checkDestructuringAssignment(restExpression, type_, checkMode)
			}
		}
	}
	return nil
}

func (tc *TypeChecker) checkDestructuringAssignment(exprOrAssignment /* TODO(TS-TO-GO) TypeNode UnionType: Expression | ShorthandPropertyAssignment */ any, sourceType Type, checkMode CheckMode, rightIsThis bool) Type {
	var target Expression
	if exprOrAssignment.kind == SyntaxKindShorthandPropertyAssignment {
		prop := exprOrAssignment /* as ShorthandPropertyAssignment */
		if prop.objectAssignmentInitializer {
			// In strict null checking mode, if a default value of a non-undefined type is specified, remove
			// undefined from the final type.
			if tc.strictNullChecks && !(tc.hasTypeFacts(tc.checkExpression(prop.objectAssignmentInitializer), TypeFactsIsUndefined)) {
				sourceType = tc.getTypeWithFacts(sourceType, TypeFactsNEUndefined)
			}
			tc.checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode)
		}
		target = (exprOrAssignment /* as ShorthandPropertyAssignment */).name
	} else {
		target = exprOrAssignment
	}

	if target.kind == SyntaxKindBinaryExpression && (target /* as BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken {
		tc.checkBinaryExpression(target /* as BinaryExpression */, checkMode)
		target = (target /* as BinaryExpression */).left
		// A default value is specified, so remove undefined from the final type.
		if tc.strictNullChecks {
			sourceType = tc.getTypeWithFacts(sourceType, TypeFactsNEUndefined)
		}
	}
	if target.kind == SyntaxKindObjectLiteralExpression {
		return tc.checkObjectLiteralAssignment(target /* as ObjectLiteralExpression */, sourceType, rightIsThis)
	}
	if target.kind == SyntaxKindArrayLiteralExpression {
		return tc.checkArrayLiteralAssignment(target /* as ArrayLiteralExpression */, sourceType, checkMode)
	}
	return tc.checkReferenceAssignment(target, sourceType, checkMode)
}

func (tc *TypeChecker) checkReferenceAssignment(target Expression, sourceType Type, checkMode CheckMode) Type {
	targetType := tc.checkExpression(target, checkMode)
	var error DiagnosticMessage
	if target.parent.kind == SyntaxKindSpreadAssignment {
		error = Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access
	} else {
		error = Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access
	}
	var optionalError DiagnosticMessage
	if target.parent.kind == SyntaxKindSpreadAssignment {
		optionalError = Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access
	} else {
		optionalError = Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access
	}
	if tc.checkReferenceExpression(target, error, optionalError) {
		tc.checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target)
	}
	if isPrivateIdentifierPropertyAccessExpression(target) {
		// NOTE: we do not limit this to LanguageFeatureTargets.PrivateNames as some other feature downleveling still requires this.
		tc.checkExternalEmitHelpers(target.parent, ExternalEmitHelpersClassPrivateFieldSet)
	}
	return sourceType
}

/**
 * This is a *shallow* check: An expression is side-effect-free if the
 * evaluation of the expression *itself* cannot produce side effects.
 * For example, x++ / 3 is side-effect free because the / operator
 * does not have side effects.
 * The intent is to "smell test" an expression for correctness in positions where
 * its value is discarded (e.g. the left side of the comma operator).
 */

func (tc *TypeChecker) isSideEffectFree(node Node) bool {
	node = skipParentheses(node)
	switch node.kind {
	case SyntaxKindIdentifier,
		SyntaxKindStringLiteral,
		SyntaxKindRegularExpressionLiteral,
		SyntaxKindTaggedTemplateExpression,
		SyntaxKindTemplateExpression,
		SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindNumericLiteral,
		SyntaxKindBigIntLiteral,
		SyntaxKindTrueKeyword,
		SyntaxKindFalseKeyword,
		SyntaxKindNullKeyword,
		SyntaxKindUndefinedKeyword,
		SyntaxKindFunctionExpression,
		SyntaxKindClassExpression,
		SyntaxKindArrowFunction,
		SyntaxKindArrayLiteralExpression,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindTypeOfExpression,
		SyntaxKindNonNullExpression,
		SyntaxKindJsxSelfClosingElement,
		SyntaxKindJsxElement:
		return true
	case SyntaxKindConditionalExpression:
		return tc.isSideEffectFree((node /* as ConditionalExpression */).whenTrue) && tc.isSideEffectFree((node /* as ConditionalExpression */).whenFalse)
	case SyntaxKindBinaryExpression:
		if isAssignmentOperator((node /* as BinaryExpression */).operatorToken.kind) {
			return false
		}
		return tc.isSideEffectFree((node /* as BinaryExpression */).left) && tc.isSideEffectFree((node /* as BinaryExpression */).right)
	case SyntaxKindPrefixUnaryExpression,
		SyntaxKindPostfixUnaryExpression:
		switch (node /* as PrefixUnaryExpression */).operator {
		case SyntaxKindExclamationToken,
			SyntaxKindPlusToken,
			SyntaxKindMinusToken,
			SyntaxKindTildeToken:
			return true
		}
		return false
	case SyntaxKindVoidExpression,
		SyntaxKindTypeAssertionExpression,
		SyntaxKindAsExpression:
		fallthrough
	default:
		return false
	}
}

func (tc *TypeChecker) isTypeEqualityComparableTo(source Type, target Type) bool {
	return (target.flags&TypeFlagsNullable) != 0 || tc.isTypeComparableTo(source, target)
}

func (tc *TypeChecker) createCheckBinaryExpression() /* TODO(TS-TO-GO) inferred type (node: BinaryExpression, checkMode: CheckMode | undefined) => Type */ any {
	type WorkArea struct {
		checkMode  *CheckMode
		skip       bool
		stackIndex number
		typeStack  []Type
	}

	trampoline := createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState)

	return func(node BinaryExpression, checkMode *CheckMode) Type {
		result := trampoline(node, checkMode)
		Debug.assertIsDefined(result)
		return result
	}

	onEnter := func(node BinaryExpression, state *WorkArea, checkMode *CheckMode) WorkArea {
		if state {
			state.stackIndex++
			state.skip = false
			setLeftType(state /*type*/, nil)
			setLastResult(state /*type*/, nil)
		} else {
			state = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"checkMode":  checkMode,
				"skip":       false,
				"stackIndex": 0,
				"typeStack":  []undefined{nil, nil},
			}
		}

		if isInJSFile(node) && getAssignedExpandoInitializer(node) {
			state.skip = true
			setLastResult(state, tc.checkExpression(node.right, checkMode))
			return state
		}

		tc.checkNullishCoalesceOperands(node)

		operator := node.operatorToken.kind
		if operator == SyntaxKindEqualsToken && (node.left.kind == SyntaxKindObjectLiteralExpression || node.left.kind == SyntaxKindArrayLiteralExpression) {
			state.skip = true
			setLastResult(state, tc.checkDestructuringAssignment(node.left, tc.checkExpression(node.right, checkMode), checkMode, node.right.kind == SyntaxKindThisKeyword))
			return state
		}

		return state
	}

	onLeft := func(left Expression, state WorkArea, _node BinaryExpression) *BinaryExpression {
		if !state.skip {
			return maybeCheckExpression(state, left)
		}
	}

	onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, node BinaryExpression) {
		if !state.skip {
			leftType := getLastResult(state)
			Debug.assertIsDefined(leftType)
			setLeftType(state, leftType)
			setLastResult(state /*type*/, nil)
			operator := operatorToken.kind
			if isLogicalOrCoalescingBinaryOperator(operator) {
				parent := node.parent
				for parent.kind == SyntaxKindParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent) {
					parent = parent.parent
				}
				if operator == SyntaxKindAmpersandAmpersandToken || isIfStatement(parent) {
					tc.checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType, __COND__(isIfStatement(parent), parent.thenStatement, nil))
				}
				if isBinaryLogicalOperator(operator) {
					tc.checkTruthinessOfType(leftType, node.left)
				}
			}
		}
	}

	onRight := func(right Expression, state WorkArea, _node BinaryExpression) *BinaryExpression {
		if !state.skip {
			return maybeCheckExpression(state, right)
		}
	}

	onExit := func(node BinaryExpression, state WorkArea) Type {
		var result Type
		if state.skip {
			result = getLastResult(state)
		} else {
			leftType := getLeftType(state)
			Debug.assertIsDefined(leftType)

			rightType := getLastResult(state)
			Debug.assertIsDefined(rightType)

			result = tc.checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node)
		}

		state.skip = false
		setLeftType(state /*type*/, nil)
		setLastResult(state /*type*/, nil)
		state.stackIndex--
		return result
	}

	foldState := func(state WorkArea, result Type, _side /* TODO(TS-TO-GO) TypeNode UnionType: "left" | "right" */ any) WorkArea {
		setLastResult(state, result)
		return state
	}

	maybeCheckExpression := func(state WorkArea, node Expression) *BinaryExpression {
		if isBinaryExpression(node) {
			return node
		}
		setLastResult(state, tc.checkExpression(node, state.checkMode))
	}

	getLeftType := func(state WorkArea) Type {
		return state.typeStack[state.stackIndex]
	}

	setLeftType := func(state WorkArea, type_ Type) {
		state.typeStack[state.stackIndex] = type_
	}

	getLastResult := func(state WorkArea) Type {
		return state.typeStack[state.stackIndex+1]
	}

	setLastResult := func(state WorkArea, type_ Type) {
		// To reduce overhead, reuse the next stack entry to store the
		// last result. This avoids the overhead of an additional property
		// on `WorkArea` and reuses empty stack entries as we walk back up
		// the stack.
		state.typeStack[state.stackIndex+1] = type_
	}

}

func (tc *TypeChecker) checkNullishCoalesceOperands(node BinaryExpression) {
	TODO_IDENTIFIER := node
	if operatorToken.kind == SyntaxKindQuestionQuestionToken {
		if isBinaryExpression(left) && (left.operatorToken.kind == SyntaxKindBarBarToken || left.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
			tc.grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind))
		}
		if isBinaryExpression(right) && (right.operatorToken.kind == SyntaxKindBarBarToken || right.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
			tc.grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind))
		}

		leftTarget := skipOuterExpressions(left, OuterExpressionKindsAll)
		nullishSemantics := tc.getSyntacticNullishnessSemantics(leftTarget)
		if nullishSemantics != PredicateSemanticsSometimes {
			if node.parent.kind == SyntaxKindBinaryExpression {
				tc.error(leftTarget, Diagnostics.This_binary_expression_is_never_nullish_Are_you_missing_parentheses)
			} else {
				if nullishSemantics == PredicateSemanticsAlways {
					tc.error(leftTarget, Diagnostics.This_expression_is_always_nullish)
				} else {
					tc.error(leftTarget, Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish)
				}
			}
		}
	}
}

func (tc *TypeChecker) getSyntacticNullishnessSemantics(node Node) PredicateSemantics {
	node = skipOuterExpressions(node)
	switch node.kind {
	case SyntaxKindAwaitExpression,
		SyntaxKindCallExpression,
		SyntaxKindElementAccessExpression,
		SyntaxKindNewExpression,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindYieldExpression,
		SyntaxKindThisKeyword:
		return PredicateSemanticsSometimes
	case SyntaxKindBinaryExpression:
		switch (node /* as BinaryExpression */).operatorToken.kind {
		case SyntaxKindEqualsToken,
			SyntaxKindQuestionQuestionToken,
			SyntaxKindQuestionQuestionEqualsToken,
			SyntaxKindBarBarToken,
			SyntaxKindBarBarEqualsToken,
			SyntaxKindAmpersandAmpersandToken,
			SyntaxKindAmpersandAmpersandEqualsToken:
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsNever
	case SyntaxKindConditionalExpression:
		return tc.getSyntacticNullishnessSemantics((node /* as ConditionalExpression */).whenTrue) | tc.getSyntacticNullishnessSemantics((node /* as ConditionalExpression */).whenFalse)
	case SyntaxKindNullKeyword:
		return PredicateSemanticsAlways
	case SyntaxKindIdentifier:
		if tc.getResolvedSymbol(node /* as Identifier */) == tc.undefinedSymbol {
			return PredicateSemanticsAlways
		}
		return PredicateSemanticsSometimes
	}
	return PredicateSemanticsNever
}

// Note that this and `checkBinaryExpression` above should behave mostly the same, except this elides some
// expression-wide checks and does not use a work stack to fold nested binary expressions into the same callstack frame
func (tc *TypeChecker) checkBinaryLikeExpression(left Expression, operatorToken BinaryOperatorToken, right Expression, checkMode CheckMode, errorNode Node) Type {
	operator := operatorToken.kind
	if operator == SyntaxKindEqualsToken && (left.kind == SyntaxKindObjectLiteralExpression || left.kind == SyntaxKindArrayLiteralExpression) {
		return tc.checkDestructuringAssignment(left, tc.checkExpression(right, checkMode), checkMode, right.kind == SyntaxKindThisKeyword)
	}
	var leftType Type
	if isBinaryLogicalOperator(operator) {
		leftType = tc.checkTruthinessExpression(left, checkMode)
	} else {
		leftType = tc.checkExpression(left, checkMode)
	}

	rightType := tc.checkExpression(right, checkMode)
	return tc.checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode)
}

func (tc *TypeChecker) checkBinaryLikeExpressionWorker(left Expression, operatorToken BinaryOperatorToken, right Expression, leftType Type, rightType Type, checkMode CheckMode, errorNode Node) Type {
	operator := operatorToken.kind
	switch operator {
	case SyntaxKindAsteriskToken,
		SyntaxKindAsteriskAsteriskToken,
		SyntaxKindAsteriskEqualsToken,
		SyntaxKindAsteriskAsteriskEqualsToken,
		SyntaxKindSlashToken,
		SyntaxKindSlashEqualsToken,
		SyntaxKindPercentToken,
		SyntaxKindPercentEqualsToken,
		SyntaxKindMinusToken,
		SyntaxKindMinusEqualsToken,
		SyntaxKindLessThanLessThanToken,
		SyntaxKindLessThanLessThanEqualsToken,
		SyntaxKindGreaterThanGreaterThanToken,
		SyntaxKindGreaterThanGreaterThanEqualsToken,
		SyntaxKindGreaterThanGreaterThanGreaterThanToken,
		SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken,
		SyntaxKindBarToken,
		SyntaxKindBarEqualsToken,
		SyntaxKindCaretToken,
		SyntaxKindCaretEqualsToken,
		SyntaxKindAmpersandToken,
		SyntaxKindAmpersandEqualsToken:
		if leftType == tc.silentNeverType || rightType == tc.silentNeverType {
			return tc.silentNeverType
		}

		leftType = tc.checkNonNullType(leftType, left)
		rightType = tc.checkNonNullType(rightType, right)

		var suggestedOperator *PunctuationSyntaxKind
		if (leftType.flags & TypeFlagsBooleanLike) && (rightType.flags & TypeFlagsBooleanLike) && ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind) */ TODO) != nil {
			tc.error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator))
			return tc.numberType
		} else {
			// otherwise just check each operand separately and report errors as normal
			leftOk := tc.checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type /*isAwaitValid*/, true)
			rightOk := tc.checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type /*isAwaitValid*/, true)
			var resultType Type
			// If both are any or unknown, allow operation; assume it will resolve to number
			if (tc.isTypeAssignableToKind(leftType, TypeFlagsAnyOrUnknown) && tc.isTypeAssignableToKind(rightType, TypeFlagsAnyOrUnknown)) || !(tc.maybeTypeOfKind(leftType, TypeFlagsBigIntLike) || tc.maybeTypeOfKind(rightType, TypeFlagsBigIntLike)) {
				resultType = tc.numberType
			} else if bothAreBigIntLike(leftType, rightType) {
				switch operator {
				case SyntaxKindGreaterThanGreaterThanGreaterThanToken,
					SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
					reportOperatorError()
				case SyntaxKindAsteriskAsteriskToken,
					SyntaxKindAsteriskAsteriskEqualsToken:
					if tc.languageVersion < ScriptTargetES2016 {
						tc.error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later)
					}
				}
				resultType = tc.bigintType
			} else {
				reportOperatorError(bothAreBigIntLike)
				resultType = tc.errorType
			}
			if leftOk && rightOk {
				checkAssignmentOperator(resultType)
				switch operator {
				case SyntaxKindLessThanLessThanToken,
					SyntaxKindLessThanLessThanEqualsToken,
					SyntaxKindGreaterThanGreaterThanToken,
					SyntaxKindGreaterThanGreaterThanEqualsToken,
					SyntaxKindGreaterThanGreaterThanGreaterThanToken,
					SyntaxKindGreaterThanGreaterThanGreaterThanEqualsToken:
					rhsEval := tc.evaluate(right)
					if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof rhsEval.value */ TODO == "number" && Math.abs(rhsEval.value) >= 32 {
						tc.errorOrSuggestion(isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), errorNode || operatorToken, Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2, getTextOfNode(left), tokenToString(operator), rhsEval.value%32)
					}
				default:
				}
			}
			return resultType
		}
		fallthrough
	case SyntaxKindPlusToken,
		SyntaxKindPlusEqualsToken:
		if leftType == tc.silentNeverType || rightType == tc.silentNeverType {
			return tc.silentNeverType
		}

		if !tc.isTypeAssignableToKind(leftType, TypeFlagsStringLike) && !tc.isTypeAssignableToKind(rightType, TypeFlagsStringLike) {
			leftType = tc.checkNonNullType(leftType, left)
			rightType = tc.checkNonNullType(rightType, right)
		}

		var resultType Type
		if tc.isTypeAssignableToKind(leftType, TypeFlagsNumberLike /*strict*/, true) && tc.isTypeAssignableToKind(rightType, TypeFlagsNumberLike /*strict*/, true) {
			// Operands of an enum type are treated as having the primitive type Number.
			// If both operands are of the Number primitive type, the result is of the Number primitive type.
			resultType = tc.numberType
		} else if tc.isTypeAssignableToKind(leftType, TypeFlagsBigIntLike /*strict*/, true) && tc.isTypeAssignableToKind(rightType, TypeFlagsBigIntLike /*strict*/, true) {
			// If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.
			resultType = tc.bigintType
		} else if tc.isTypeAssignableToKind(leftType, TypeFlagsStringLike /*strict*/, true) || tc.isTypeAssignableToKind(rightType, TypeFlagsStringLike /*strict*/, true) {
			// If one or both operands are of the String primitive type, the result is of the String primitive type.
			resultType = tc.stringType
		} else if tc.isTypeAny(leftType) || tc.isTypeAny(rightType) {
			// Otherwise, the result is of type Any.
			// NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.
			if tc.isErrorType(leftType) || tc.isErrorType(rightType) {
				resultType = tc.errorType
			} else {
				resultType = tc.anyType
			}
		}
		if resultType && !checkForDisallowedESSymbolOperand(operator) {
			return resultType
		}

		if !resultType {
			// Types that have a reasonably good chance of being a valid operand type.
			// If both types have an awaited type of one of these, we'll assume the user
			// might be missing an await without doing an exhaustive check that inserting
			// await(s) will actually be a completely valid binary expression.
			closeEnoughKind := TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsAnyOrUnknown
			reportOperatorError(func(left Type, right Type) bool {
				return tc.isTypeAssignableToKind(left, closeEnoughKind) && tc.isTypeAssignableToKind(right, closeEnoughKind)
			})
			return tc.anyType
		}

		if operator == SyntaxKindPlusEqualsToken {
			checkAssignmentOperator(resultType)
		}
		return resultType
	case SyntaxKindLessThanToken,
		SyntaxKindGreaterThanToken,
		SyntaxKindLessThanEqualsToken,
		SyntaxKindGreaterThanEqualsToken:
		if checkForDisallowedESSymbolOperand(operator) {
			leftType = tc.getBaseTypeOfLiteralTypeForComparison(tc.checkNonNullType(leftType, left))
			rightType = tc.getBaseTypeOfLiteralTypeForComparison(tc.checkNonNullType(rightType, right))
			reportOperatorErrorUnless(func(left Type, right Type) bool {
				if tc.isTypeAny(left) || tc.isTypeAny(right) {
					return true
				}
				leftAssignableToNumber := tc.isTypeAssignableTo(left, tc.numberOrBigIntType)
				rightAssignableToNumber := tc.isTypeAssignableTo(right, tc.numberOrBigIntType)
				return leftAssignableToNumber && rightAssignableToNumber || !leftAssignableToNumber && !rightAssignableToNumber && tc.areTypesComparable(left, right)
			})
		}
		return tc.booleanType
	case SyntaxKindEqualsEqualsToken,
		SyntaxKindExclamationEqualsToken,
		SyntaxKindEqualsEqualsEqualsToken,
		SyntaxKindExclamationEqualsEqualsToken:
		if !(checkMode && checkMode&CheckModeTypeOnly) {
			if (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) && (!isInJSFile(left) || (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken)) {
				eqType := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
				tc.error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, __COND__(eqType, "false", "true"))
			}
			checkNaNEquality(errorNode, operator, left, right)
			reportOperatorErrorUnless(func(left Type, right Type) bool {
				return tc.isTypeEqualityComparableTo(left, right) || tc.isTypeEqualityComparableTo(right, left)
			})
		}
		return tc.booleanType
	case SyntaxKindInstanceOfKeyword:
		return tc.checkInstanceOfExpression(left, right, leftType, rightType, checkMode)
	case SyntaxKindInKeyword:
		return tc.checkInExpression(left, right, leftType, rightType)
	case SyntaxKindAmpersandAmpersandToken,
		SyntaxKindAmpersandAmpersandEqualsToken:
		var resultType Type
		if tc.hasTypeFacts(leftType, TypeFactsTruthy) {
			resultType = tc.getUnionType([]Type{tc.extractDefinitelyFalsyTypes(__COND__(tc.strictNullChecks, leftType, tc.getBaseTypeOfLiteralType(rightType))), rightType})
		} else {
			resultType = leftType
		}
		if operator == SyntaxKindAmpersandAmpersandEqualsToken {
			checkAssignmentOperator(rightType)
		}
		return resultType
		fallthrough
	case SyntaxKindBarBarToken,
		SyntaxKindBarBarEqualsToken:
		var resultType Type
		if tc.hasTypeFacts(leftType, TypeFactsFalsy) {
			resultType = tc.getUnionType([]Type{tc.getNonNullableType(tc.removeDefinitelyFalsyTypes(leftType)), rightType}, UnionReductionSubtype)
		} else {
			resultType = leftType
		}
		if operator == SyntaxKindBarBarEqualsToken {
			checkAssignmentOperator(rightType)
		}
		return resultType
		fallthrough
	case SyntaxKindQuestionQuestionToken,
		SyntaxKindQuestionQuestionEqualsToken:
		var resultType Type
		if tc.hasTypeFacts(leftType, TypeFactsEQUndefinedOrNull) {
			resultType = tc.getUnionType([]Type{tc.getNonNullableType(leftType), rightType}, UnionReductionSubtype)
		} else {
			resultType = leftType
		}
		if operator == SyntaxKindQuestionQuestionEqualsToken {
			checkAssignmentOperator(rightType)
		}
		return resultType
		fallthrough
	case SyntaxKindEqualsToken:
		var declKind AssignmentDeclarationKind
		if isBinaryExpression(left.parent) {
			declKind = getAssignmentDeclarationKind(left.parent)
		} else {
			declKind = AssignmentDeclarationKindNone
		}
		checkAssignmentDeclaration(declKind, rightType)
		if isAssignmentDeclaration(declKind) {
			if !(rightType.flags & TypeFlagsObject) || declKind != AssignmentDeclarationKindModuleExports && declKind != AssignmentDeclarationKindPrototype && !tc.isEmptyObjectType(rightType) && !tc.isFunctionObjectType(rightType /* as ObjectType */) && !(getObjectFlags(rightType)&ObjectFlagsClass) {
				// don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete
				checkAssignmentOperator(rightType)
			}
			return leftType
		} else {
			checkAssignmentOperator(rightType)
			return rightType
		}
		fallthrough
	case SyntaxKindCommaToken:
		if !tc.compilerOptions.allowUnreachableCode && tc.isSideEffectFree(left) && !isIndirectCall(left.parent /* as BinaryExpression */) {
			sf := getSourceFileOfNode(left)
			sourceText := sf.text
			start := skipTrivia(sourceText, left.pos)
			isInDiag2657 := sf.parseDiagnostics.some(func(diag DiagnosticWithLocation) bool {
				if diag.code != Diagnostics.JSX_expressions_must_have_one_parent_element.code {
					return false
				}
				return textSpanContainsPosition(diag, start)
			})
			if !isInDiag2657 {
				tc.error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects)
			}
		}
		return rightType
	default:
		return Debug.fail()
	}

	bothAreBigIntLike := func(left Type, right Type) bool {
		return tc.isTypeAssignableToKind(left, TypeFlagsBigIntLike) && tc.isTypeAssignableToKind(right, TypeFlagsBigIntLike)
	}

	checkAssignmentDeclaration := func(kind AssignmentDeclarationKind, rightType Type) {
		if kind == AssignmentDeclarationKindModuleExports {
			for _, prop := range tc.getPropertiesOfObjectType(rightType) {
				propType := tc.getTypeOfSymbol(prop)
				if propType.symbol && propType.symbol.flags&SymbolFlagsClass {
					name := prop.escapedName
					symbol := tc.resolveName(prop.valueDeclaration, name, SymbolFlagsType /*nameNotFoundMessage*/, nil /*isUse*/, false)
					if symbol. /* ? */ declarations && symbol.declarations.some(isJSDocTypedefTag) {
						tc.addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop)
						tc.addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol)
					}
				}
			}
		}
	}

	// Return true for "indirect calls", (i.e. `(0, x.f)(...)` or `(0, eval)(...)`), which prevents passing `this`.
	isIndirectCall := func(node BinaryExpression) bool {
		return node.parent.kind == SyntaxKindParenthesizedExpression && isNumericLiteral(node.left) && node.left.text == "0" && (isCallExpression(node.parent.parent) && node.parent.parent.expression == node.parent || node.parent.parent.kind == SyntaxKindTaggedTemplateExpression) && (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText == "eval")
	}

	// Return true if there was no error, false if there was an error.
	checkForDisallowedESSymbolOperand := func(operator PunctuationSyntaxKind) bool {
		var offendingSymbolOperand Expression
		switch {
		case tc.maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlagsESSymbolLike):
			offendingSymbolOperand = left
		case tc.maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlagsESSymbolLike):
			offendingSymbolOperand = right
		default:
			offendingSymbolOperand = nil
		}

		if offendingSymbolOperand {
			tc.error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator))
			return false
		}

		return true
	}

	getSuggestedBooleanOperator := func(operator SyntaxKind) *PunctuationSyntaxKind {
		switch operator {
		case SyntaxKindBarToken,
			SyntaxKindBarEqualsToken:
			return SyntaxKindBarBarToken
		case SyntaxKindCaretToken,
			SyntaxKindCaretEqualsToken:
			return SyntaxKindExclamationEqualsEqualsToken
		case SyntaxKindAmpersandToken,
			SyntaxKindAmpersandEqualsToken:
			return SyntaxKindAmpersandAmpersandToken
		default:
			return nil
		}
	}

	checkAssignmentOperator := func(valueType Type) {
		if isAssignmentOperator(operator) {
			tc.addLazyDiagnostic(checkAssignmentOperatorWorker)
		}

		checkAssignmentOperatorWorker := func() {
			assigneeType := leftType

			// getters can be a subtype of setters, so to check for assignability we use the setter's type instead
			if isCompoundAssignment(operatorToken.kind) && left.kind == SyntaxKindPropertyAccessExpression {
				assigneeType = tc.checkPropertyAccessExpression(left /* as PropertyAccessExpression */ /*checkMode*/, nil /*writeOnly*/, true)
			}

			// TypeScript 1.0 spec (April 2014): 4.17
			// An assignment of the form
			//    VarExpr = ValueExpr
			// requires VarExpr to be classified as a reference
			// A compound assignment furthermore requires VarExpr to be classified as a reference (section 4.1)
			// and the type of the non-compound operation to be assignable to the type of VarExpr.

			if tc.checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access) {
				var headMessage *DiagnosticMessage
				if tc.exactOptionalPropertyTypes && isPropertyAccessExpression(left) && tc.maybeTypeOfKind(valueType, TypeFlagsUndefined) {
					target := tc.getTypeOfPropertyOfType(tc.getTypeOfExpression(left.expression), left.name.escapedText)
					if tc.isExactOptionalPropertyMismatch(valueType, target) {
						headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target
					}
				}
				// to avoid cascading errors check assignability only if 'isReference' check succeeded and no errors were reported
				tc.checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage)
			}
		}

	}

	isAssignmentDeclaration := func(kind AssignmentDeclarationKind) bool {
		switch kind {
		case AssignmentDeclarationKindModuleExports:
			return true
		case AssignmentDeclarationKindExportsProperty,
			AssignmentDeclarationKindProperty,
			AssignmentDeclarationKindPrototype,
			AssignmentDeclarationKindPrototypeProperty,
			AssignmentDeclarationKindThisProperty:
			symbol := tc.getSymbolOfNode(left)
			init := getAssignedExpandoInitializer(right)
			return !!init && isObjectLiteralExpression(init) && !!symbol. /* ? */ exports. /* ? */ size
		default:
			return false
		}
	}

	/**
	 * Returns true if an error is reported
	 */

	reportOperatorErrorUnless := func(typesAreCompatible func(left Type, right Type) bool) bool {
		if !typesAreCompatible(leftType, rightType) {
			reportOperatorError(typesAreCompatible)
			return true
		}
		return false
	}

	reportOperatorError := func(isRelated func(left Type, right Type) bool) {
		wouldWorkWithAwait := false
		errNode := errorNode || operatorToken
		if isRelated {
			awaitedLeftType := tc.getAwaitedTypeNoAlias(leftType)
			awaitedRightType := tc.getAwaitedTypeNoAlias(rightType)
			wouldWorkWithAwait = !(awaitedLeftType == leftType && awaitedRightType == rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType)
		}

		effectiveLeft := leftType
		effectiveRight := rightType
		if !wouldWorkWithAwait && isRelated {
			[]any{effectiveLeft, effectiveRight} = tc.getBaseTypesIfUnrelated(leftType, rightType, isRelated)
		}
		TODO_IDENTIFIER := tc.getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight)
		if !tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr) {
			tc.errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, tokenToString(operatorToken.kind), leftStr, rightStr)
		}
	}

	tryGiveBetterPrimaryError := func(errNode Node, maybeMissingAwait bool, leftStr string, rightStr string) *Diagnostic {
		switch operatorToken.kind {
		case SyntaxKindEqualsEqualsEqualsToken,
			SyntaxKindEqualsEqualsToken,
			SyntaxKindExclamationEqualsEqualsToken,
			SyntaxKindExclamationEqualsToken:
			return tc.errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap, leftStr, rightStr)
		default:
			return nil
		}
	}

	checkNaNEquality := func(errorNode Node, operator SyntaxKind, left Expression, right Expression) {
		isLeftNaN := isGlobalNaN(skipParentheses(left))
		isRightNaN := isGlobalNaN(skipParentheses(right))
		if isLeftNaN || isRightNaN {
			err := tc.error(errorNode, Diagnostics.This_condition_will_always_return_0, tokenToString(__COND__(operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindEqualsEqualsToken, SyntaxKindFalseKeyword, SyntaxKindTrueKeyword)))
			if isLeftNaN && isRightNaN {
				return
			}
			var operatorString string
			if operator == SyntaxKindExclamationEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken {
				operatorString = tokenToString(SyntaxKindExclamationToken)
			} else {
				operatorString = ""
			}
			var location Expression
			if isLeftNaN {
				location = right
			} else {
				location = left
			}
			expression := skipParentheses(location)
			addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0, __TEMPLATE__(operatorString, "Number.isNaN(", __COND__(isEntityNameExpression(expression), entityNameToString(expression), "..."), ")")))
		}
	}

	isGlobalNaN := func(expr Expression) bool {
		if isIdentifier(expr) && expr.escapedText == "NaN" {
			globalNaNSymbol := tc.getGlobalNaNSymbol()
			return !!globalNaNSymbol && globalNaNSymbol == tc.getResolvedSymbol(expr)
		}
		return false
	}

}

func (tc *TypeChecker) getBaseTypesIfUnrelated(leftType Type, rightType Type, isRelated func(left Type, right Type) bool) /* TODO(TS-TO-GO) TypeNode TupleType: [Type, Type] */ any {
	effectiveLeft := leftType
	effectiveRight := rightType
	leftBase := tc.getBaseTypeOfLiteralType(leftType)
	rightBase := tc.getBaseTypeOfLiteralType(rightType)
	if !isRelated(leftBase, rightBase) {
		effectiveLeft = leftBase
		effectiveRight = rightBase
	}
	return []any{effectiveLeft, effectiveRight}
}

func (tc *TypeChecker) checkYieldExpression(node YieldExpression) Type {
	tc.addLazyDiagnostic(checkYieldExpressionGrammar)

	func_ := getContainingFunction(node)
	if !func_ {
		return tc.anyType
	}
	functionFlags := getFunctionFlags(func_)

	if !(functionFlags & FunctionFlagsGenerator) {
		// If the user's code is syntactically correct, the func should always have a star. After all, we are in a yield context.
		return tc.anyType
	}

	isAsync := (functionFlags & FunctionFlagsAsync) != 0
	if node.asteriskToken {
		// Async generator functions prior to ES2018 require the __await, __asyncDelegator,
		// and __asyncValues helpers
		if isAsync && tc.languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncDelegatorIncludes)
		}

		// Generator functions prior to ES2015 require the __values helper
		if !isAsync && tc.languageVersion < LanguageFeatureMinimumTargetGenerators && tc.compilerOptions.downlevelIteration {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersValues)
		}
	}

	// There is no point in doing an assignability check if the function
	// has no explicit return type because the return type is directly computed
	// from the yield expressions.
	returnType := tc.getReturnTypeFromAnnotation(func_)
	if returnType && returnType.flags&TypeFlagsUnion {
		returnType = tc.filterType(returnType, func(t Type) bool {
			return tc.checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags /*errorNode*/, nil)
		})
	}
	iterationTypes := returnType && tc.getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync)
	signatureYieldType := iterationTypes && iterationTypes.yieldType || tc.anyType
	signatureNextType := iterationTypes && iterationTypes.nextType || tc.anyType
	var yieldExpressionType Type
	if node.expression {
		yieldExpressionType = tc.checkExpression(node.expression)
	} else {
		yieldExpressionType = tc.undefinedWideningType
	}
	yieldedType := tc.getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync)
	if returnType && yieldedType {
		tc.checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression)
	}

	if node.asteriskToken {
		var use /* TODO(TS-TO-GO) inferred type IterationUse.YieldStar | IterationUse.AsyncYieldStar */ any
		if isAsync {
			use = IterationUseAsyncYieldStar
		} else {
			use = IterationUseYieldStar
		}
		return tc.getIterationTypeOfIterable(use, IterationTypeKindReturn, yieldExpressionType, node.expression) || tc.anyType
	} else if returnType {
		return tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, isAsync) || tc.anyType
	}
	type_ := tc.getContextualIterationType(IterationTypeKindNext, func_)
	if !type_ {
		type_ = tc.anyType
		tc.addLazyDiagnostic(func() {
			if tc.noImplicitAny && !expressionResultIsUnused(node) {
				contextualType := tc.getContextualType(node /*contextFlags*/, nil)
				if !contextualType || tc.isTypeAny(contextualType) {
					tc.error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation)
				}
			}
		})
	}
	return type_

	checkYieldExpressionGrammar := func() {
		if !(node.flags & NodeFlagsYieldContext) {
			tc.grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body)
		}

		if tc.isInParameterInitializerBeforeContainingFunction(node) {
			tc.error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer)
		}
	}

}

func (tc *TypeChecker) checkConditionalExpression(node ConditionalExpression, checkMode CheckMode) Type {
	type_ := tc.checkTruthinessExpression(node.condition, checkMode)
	tc.checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type_, node.whenTrue)
	type1 := tc.checkExpression(node.whenTrue, checkMode)
	type2 := tc.checkExpression(node.whenFalse, checkMode)
	return tc.getUnionType([]Type{type1, type2}, UnionReductionSubtype)
}

func (tc *TypeChecker) isTemplateLiteralContext(node Node) bool {
	parent := node.parent
	return isParenthesizedExpression(parent) && tc.isTemplateLiteralContext(parent) || isElementAccessExpression(parent) && parent.argumentExpression == node
}

func (tc *TypeChecker) checkTemplateExpression(node TemplateExpression) Type {
	texts := []string{node.head.text}
	types := []never{}
	for _, span := range node.templateSpans {
		type_ := tc.checkExpression(span.expression)
		if tc.maybeTypeOfKindConsideringBaseConstraint(type_, TypeFlagsESSymbolLike) {
			tc.error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String)
		}
		texts.push(span.literal.text)
		types.push(__COND__(tc.isTypeAssignableTo(type_, tc.templateConstraintType), type_, tc.stringType))
	}
	evaluated := node.parent.kind != SyntaxKindTaggedTemplateExpression && tc.evaluate(node).value
	if evaluated {
		return tc.getFreshTypeOfLiteralType(tc.getStringLiteralType(evaluated))
	}
	if tc.isConstContext(node) || tc.isTemplateLiteralContext(node) || tc.someType(tc.getContextualType(node /*contextFlags*/, nil) || tc.unknownType, tc.isTemplateLiteralContextualType) {
		return tc.getTemplateLiteralType(texts, types)
	}
	return tc.stringType
}

func (tc *TypeChecker) isTemplateLiteralContextualType(type_ Type) bool {
	return !!(type_.flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral) || type_.flags&TypeFlagsInstantiableNonPrimitive && tc.maybeTypeOfKind(tc.getBaseConstraintOfType(type_) || tc.unknownType, TypeFlagsStringLike))
}

func (tc *TypeChecker) getContextNode(node Expression) Expression {
	if isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent) {
		return node.parent.parent
		// Needs to be the root JsxElement, so it encompasses the attributes _and_ the children (which are essentially part of the attributes)
	}
	return node
}

func (tc *TypeChecker) checkExpressionWithContextualType(node Expression, contextualType Type, inferenceContext *InferenceContext, checkMode CheckMode) Type {
	contextNode := tc.getContextNode(node)
	tc.pushContextualType(contextNode, contextualType /*isCache*/, false)
	tc.pushInferenceContext(contextNode, inferenceContext)
	type_ := tc.checkExpression(node, checkMode|CheckModeContextual|(__COND__(inferenceContext, CheckModeInferential, 0)))
	// In CheckMode.Inferential we collect intra-expression inference sites to process before fixing any type
	// parameters. This information is no longer needed after the call to checkExpression.
	if inferenceContext && inferenceContext.intraExpressionInferenceSites {
		inferenceContext.intraExpressionInferenceSites = nil
	}
	// We strip literal freshness when an appropriate contextual type is present such that contextually typed
	// literals always preserve their literal types (otherwise they might widen during type inference). An alternative
	// here would be to not mark contextually typed literals as fresh in the first place.
	var result Type
	if tc.maybeTypeOfKind(type_, TypeFlagsLiteral) && tc.isLiteralOfContextualType(type_, tc.instantiateContextualType(contextualType, node /*contextFlags*/, nil)) {
		result = tc.getRegularTypeOfLiteralType(type_)
	} else {
		result = type_
	}
	tc.popInferenceContext()
	tc.popContextualType()
	return result
}

func (tc *TypeChecker) checkExpressionCached(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, checkMode CheckMode) Type {
	if checkMode {
		return tc.checkExpression(node, checkMode)
	}
	links := tc.getNodeLinks(node)
	if !links.resolvedType {
		// When computing a type that we're going to cache, we need to ignore any ongoing control flow
		// analysis because variables may have transient types in indeterminable states. Moving flowLoopStart
		// to the top of the stack ensures all transient types are computed from a known point.
		saveFlowLoopStart := tc.flowLoopStart
		saveFlowTypeCache := tc.flowTypeCache
		tc.flowLoopStart = tc.flowLoopCount
		tc.flowTypeCache = nil
		links.resolvedType = tc.checkExpression(node, checkMode)
		tc.flowTypeCache = saveFlowTypeCache
		tc.flowLoopStart = saveFlowLoopStart
	}
	return links.resolvedType
}

func (tc *TypeChecker) isTypeAssertion(node Expression) bool {
	node = skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
	return node.kind == SyntaxKindTypeAssertionExpression || node.kind == SyntaxKindAsExpression || isJSDocTypeAssertion(node)
}

func (tc *TypeChecker) checkDeclarationInitializer(declaration HasExpressionInitializer, checkMode CheckMode, contextualType Type) Type {
	initializer := getEffectiveInitializer(declaration)
	if isInJSFile(declaration) {
		typeNode := tryGetJSDocSatisfiesTypeNode(declaration)
		if typeNode {
			return tc.checkSatisfiesExpressionWorker(initializer, typeNode, checkMode)
		}
	}
	type_ := tc.getQuickTypeOfExpression(initializer) || (__COND__(contextualType, tc.checkExpressionWithContextualType(initializer, contextualType /*inferenceContext*/, nil, checkMode || CheckModeNormal), tc.checkExpressionCached(initializer, checkMode)))
	if isParameter(__COND__(isBindingElement(declaration), walkUpBindingElementsAndPatterns(declaration), declaration)) {
		if declaration.name.kind == SyntaxKindObjectBindingPattern && tc.isObjectLiteralType(type_) {
			return tc.padObjectLiteralType(type_ /* as ObjectType */, declaration.name)
		}
		if declaration.name.kind == SyntaxKindArrayBindingPattern && tc.isTupleType(type_) {
			return tc.padTupleType(type_, declaration.name)
		}
	}
	return type_
}

func (tc *TypeChecker) padObjectLiteralType(type_ ObjectType, pattern ObjectBindingPattern) Type {
	var missingElements *[]BindingElement
	for _, e := range pattern.elements {
		if e.initializer {
			name := tc.getPropertyNameFromBindingElement(e)
			if name && !tc.getPropertyOfType(type_, name) {
				missingElements = append(missingElements, e)
			}
		}
	}
	if !missingElements {
		return type_
	}
	members := createSymbolTable()
	for _, prop := range tc.getPropertiesOfObjectType(type_) {
		members.set(prop.escapedName, prop)
	}
	for _, e := range missingElements {
		symbol := tc.createSymbol(SymbolFlagsProperty|SymbolFlagsOptional, tc.getPropertyNameFromBindingElement(e))
		symbol.links.type_ = tc.getTypeFromBindingElement(e /*includePatternInType*/, false /*reportErrors*/, false)
		members.set(symbol.escapedName, symbol)
	}
	result := tc.createAnonymousType(type_.symbol, members, emptyArray, emptyArray, tc.getIndexInfosOfType(type_))
	result.objectFlags = type_.objectFlags
	return result
}

func (tc *TypeChecker) getPropertyNameFromBindingElement(e BindingElement) *__String {
	exprType := tc.getLiteralTypeFromPropertyName(e.propertyName || e.name /* as Identifier */)
	if isTypeUsableAsPropertyName(exprType) {
		return getPropertyNameFromType(exprType)
	} else {
		return nil
	}
}

func (tc *TypeChecker) padTupleType(type_ TupleTypeReference, pattern ArrayBindingPattern) Type {
	if type_.target.combinedFlags&ElementFlagsVariable || tc.getTypeReferenceArity(type_) >= pattern.elements.length {
		return type_
	}
	patternElements := pattern.elements
	elementTypes := tc.getElementTypes(type_).slice()
	elementFlags := type_.target.elementFlags.slice()
	for i := tc.getTypeReferenceArity(type_); i < patternElements.length; i++ {
		e := patternElements[i]
		if i < patternElements.length-1 || !(e.kind == SyntaxKindBindingElement && e.dotDotDotToken) {
			elementTypes.push(__COND__(!isOmittedExpression(e) && tc.hasDefaultValue(e), tc.getTypeFromBindingElement(e /*includePatternInType*/, false /*reportErrors*/, false), tc.anyType))
			elementFlags.push(ElementFlagsOptional)
			if !isOmittedExpression(e) && !tc.hasDefaultValue(e) {
				tc.reportImplicitAny(e, tc.anyType)
			}
		}
	}
	return tc.createTupleType(elementTypes, elementFlags, type_.target.readonly)
}

func (tc *TypeChecker) widenTypeInferredFromInitializer(declaration HasExpressionInitializer, type_ Type) Type {
	var widened Type
	if tc.getCombinedNodeFlagsCached(declaration)&NodeFlagsConstant || isDeclarationReadonly(declaration) {
		widened = type_
	} else {
		widened = tc.getWidenedLiteralType(type_)
	}
	if isInJSFile(declaration) {
		if tc.isEmptyLiteralType(widened) {
			tc.reportImplicitAny(declaration, tc.anyType)
			return tc.anyType
		} else if tc.isEmptyArrayLiteralType(widened) {
			tc.reportImplicitAny(declaration, tc.anyArrayType)
			return tc.anyArrayType
		}
	}
	return widened
}

func (tc *TypeChecker) isLiteralOfContextualType(candidateType Type, contextualType Type) bool {
	if contextualType {
		if contextualType.flags & TypeFlagsUnionOrIntersection {
			types := (contextualType /* as UnionType */).types
			return some(types, func(t Type) bool {
				return tc.isLiteralOfContextualType(candidateType, t)
			})
		}
		if contextualType.flags & TypeFlagsInstantiableNonPrimitive {
			// If the contextual type is a type variable constrained to a primitive type, consider
			// this a literal context for literals of that primitive type. For example, given a
			// type parameter 'T extends string', infer string literal types for T.
			constraint := tc.getBaseConstraintOfType(contextualType) || tc.unknownType
			return tc.maybeTypeOfKind(constraint, TypeFlagsString) && tc.maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || tc.maybeTypeOfKind(constraint, TypeFlagsNumber) && tc.maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || tc.maybeTypeOfKind(constraint, TypeFlagsBigInt) && tc.maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || tc.maybeTypeOfKind(constraint, TypeFlagsESSymbol) && tc.maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol) || tc.isLiteralOfContextualType(candidateType, constraint)
		}
		// If the contextual type is a literal of a particular primitive type, we consider this a
		// literal context for all literals of that primitive type.
		return !!(contextualType.flags&(TypeFlagsStringLiteral|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && tc.maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || contextualType.flags&TypeFlagsNumberLiteral && tc.maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || contextualType.flags&TypeFlagsBigIntLiteral && tc.maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || contextualType.flags&TypeFlagsBooleanLiteral && tc.maybeTypeOfKind(candidateType, TypeFlagsBooleanLiteral) || contextualType.flags&TypeFlagsUniqueESSymbol && tc.maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol))
	}
	return false
}

func (tc *TypeChecker) isConstContext(node Expression) bool {
	parent := node.parent
	return isAssertionExpression(parent) && isConstTypeReference(parent.type_) || isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || tc.isValidConstAssertionArgument(node) && tc.isConstTypeVariable(tc.getContextualType(node, ContextFlagsNone)) || (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && tc.isConstContext(parent) || (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && tc.isConstContext(parent.parent)
}

func (tc *TypeChecker) checkExpressionForMutableLocation(node Expression, checkMode *CheckMode, forceTuple bool) Type {
	type_ := tc.checkExpression(node, checkMode, forceTuple)
	switch {
	case tc.isConstContext(node) || isCommonJsExportedExpression(node):
		return tc.getRegularTypeOfLiteralType(type_)
	case tc.isTypeAssertion(node):
		return type_
	default:
		return tc.getWidenedLiteralLikeTypeForContextualType(type_, tc.instantiateContextualType(tc.getContextualType(node /*contextFlags*/, nil), node /*contextFlags*/, nil))
	}
}

func (tc *TypeChecker) checkPropertyAssignment(node PropertyAssignment, checkMode CheckMode) Type {
	// Do not use hasDynamicName here, because that returns false for well known symbols.
	// We want to perform checkComputedPropertyName for all computed properties, including
	// well known symbols.
	if node.name.kind == SyntaxKindComputedPropertyName {
		tc.checkComputedPropertyName(node.name)
	}

	return tc.checkExpressionForMutableLocation(node.initializer, checkMode)
}

func (tc *TypeChecker) checkObjectLiteralMethod(node MethodDeclaration, checkMode CheckMode) Type {
	// Grammar checking
	tc.checkGrammarMethod(node)

	// Do not use hasDynamicName here, because that returns false for well known symbols.
	// We want to perform checkComputedPropertyName for all computed properties, including
	// well known symbols.
	if node.name.kind == SyntaxKindComputedPropertyName {
		tc.checkComputedPropertyName(node.name)
	}

	uninstantiatedType := tc.checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
	return tc.instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
}

func (tc *TypeChecker) instantiateTypeWithSingleGenericCallSignature(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | MethodDeclaration | QualifiedName */ any, type_ Type, checkMode CheckMode) Type {
	if checkMode && checkMode&(CheckModeInferential|CheckModeSkipGenericFunctions) {
		callSignature := tc.getSingleSignature(type_, SignatureKindCall /*allowMembers*/, true)
		constructSignature := tc.getSingleSignature(type_, SignatureKindConstruct /*allowMembers*/, true)
		signature := callSignature || constructSignature
		if signature && signature.typeParameters {
			contextualType := tc.getApparentTypeOfContextualType(node /* as Expression */, ContextFlagsNoConstraints)
			if contextualType {
				contextualSignature := tc.getSingleSignature(tc.getNonNullableType(contextualType), __COND__(callSignature, SignatureKindCall, SignatureKindConstruct) /*allowMembers*/, false)
				if contextualSignature && !contextualSignature.typeParameters {
					if checkMode & CheckModeSkipGenericFunctions {
						tc.skippedGenericFunction(node, checkMode)
						return tc.anyFunctionType
					}
					context := tc.getInferenceContext(node)
					// We have an expression that is an argument of a generic function for which we are performing
					// type argument inference. The expression is of a function type with a single generic call
					// signature and a contextual function type with a single non-generic call signature. Now check
					// if the outer function returns a function type with a single non-generic call signature and
					// if some of the outer function type parameters have no inferences so far. If so, we can
					// potentially add inferred type parameters to the outer function return type.
					returnType := context.signature && tc.getReturnTypeOfSignature(context.signature)
					returnSignature := returnType && tc.getSingleCallOrConstructSignature(returnType)
					if returnSignature && !returnSignature.typeParameters && !every(context.inferences, tc.hasInferenceCandidates) {
						// Instantiate the signature with its own type parameters as type arguments, possibly
						// renaming the type parameters to ensure they have unique names.
						uniqueTypeParameters := tc.getUniqueTypeParameters(context, signature.typeParameters)
						instantiatedSignature := tc.getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters)
						// Infer from the parameters of the instantiated signature to the parameters of the
						// contextual signature starting with an empty set of inference candidates.
						inferences := map_(context.inferences, func(info InferenceInfo) InferenceInfo {
							return tc.createInferenceInfo(info.typeParameter)
						})
						tc.applyToParameterTypes(instantiatedSignature, contextualSignature, func(source Type, target Type) {
							tc.inferTypes(inferences, source, target /*priority*/, 0 /*contravariant*/, true)
						})
						if some(inferences, tc.hasInferenceCandidates) {
							// We have inference candidates, indicating that one or more type parameters are referenced
							// in the parameter types of the contextual signature. Now also infer from the return type.
							tc.applyToReturnTypes(instantiatedSignature, contextualSignature, func(source Type, target Type) {
								tc.inferTypes(inferences, source, target)
							})
							// If the type parameters for which we produced candidates do not have any inferences yet,
							// we adopt the new inference candidates and add the type parameters of the expression type
							// to the set of inferred type parameters for the outer function return type.
							if !tc.hasOverlappingInferences(context.inferences, inferences) {
								tc.mergeInferences(context.inferences, inferences)
								context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters)
								return tc.getOrCreateTypeFromSignature(instantiatedSignature)
							}
						}
					}
					// TODO: The signature may reference any outer inference contexts, but we map pop off and then apply new inference contexts, and thus get different inferred types.
					// That this is cached on the *first* such attempt is not currently an issue, since expression types *also* get cached on the first pass. If we ever properly speculate, though,
					// the cached "isolatedSignatureType" signature field absolutely needs to be included in the list of speculative caches.
					return tc.getOrCreateTypeFromSignature(tc.instantiateSignatureInContextOf(signature, contextualSignature, context), flatMap(tc.inferenceContexts, func(c *InferenceContext) *[]TypeParameter {
						return c && map_(c.inferences, func(i InferenceInfo) TypeParameter {
							return i.typeParameter
						})
					}).slice())
				}
			}
		}
	}
	return type_
}

func (tc *TypeChecker) skippedGenericFunction(node Node, checkMode CheckMode) {
	if checkMode & CheckModeInferential {
		// We have skipped a generic function during inferential typing. Obtain the inference context and
		// indicate this has occurred such that we know a second pass of inference is be needed.
		context := tc.getInferenceContext(node)
		context.flags |= InferenceFlagsSkippedGenericFunction
	}
}

func (tc *TypeChecker) hasInferenceCandidates(info InferenceInfo) bool {
	return !!(info.candidates || info.contraCandidates)
}

func (tc *TypeChecker) hasInferenceCandidatesOrDefault(info InferenceInfo) bool {
	return !!(info.candidates || info.contraCandidates || tc.hasTypeParameterDefault(info.typeParameter))
}

func (tc *TypeChecker) hasOverlappingInferences(a []InferenceInfo, b []InferenceInfo) bool {
	for i := 0; i < a.length; i++ {
		if tc.hasInferenceCandidates(a[i]) && tc.hasInferenceCandidates(b[i]) {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) mergeInferences(target []InferenceInfo, source []InferenceInfo) {
	for i := 0; i < target.length; i++ {
		if !tc.hasInferenceCandidates(target[i]) && tc.hasInferenceCandidates(source[i]) {
			target[i] = source[i]
		}
	}
}

func (tc *TypeChecker) getUniqueTypeParameters(context InferenceContext, typeParameters []TypeParameter) []TypeParameter {
	var result []TypeParameter = []never{}
	var oldTypeParameters *[]TypeParameter
	var newTypeParameters *[]TypeParameter
	for _, tp := range typeParameters {
		name := tp.symbol.escapedName
		if tc.hasTypeParameterByName(context.inferredTypeParameters, name) || tc.hasTypeParameterByName(result, name) {
			newName := tc.getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name)
			symbol := tc.createSymbol(SymbolFlagsTypeParameter, newName)
			newTypeParameter := tc.createTypeParameter(symbol)
			newTypeParameter.target = tp
			oldTypeParameters = append(oldTypeParameters, tp)
			newTypeParameters = append(newTypeParameters, newTypeParameter)
			result.push(newTypeParameter)
		} else {
			result.push(tp)
		}
	}
	if newTypeParameters {
		mapper := tc.createTypeMapper(oldTypeParameters, newTypeParameters)
		for _, tp := range newTypeParameters {
			tp.mapper = mapper
		}
	}
	return result
}

func (tc *TypeChecker) hasTypeParameterByName(typeParameters *[]TypeParameter, name __String) bool {
	return some(typeParameters, func(tp TypeParameter) bool {
		return tp.symbol.escapedName == name
	})
}

func (tc *TypeChecker) getUniqueTypeParameterName(typeParameters []TypeParameter, baseName __String) __String {
	len := (baseName /* as string */).length
	for len > 1 && (baseName /* as string */).charCodeAt(len-1) >= CharacterCodes_0 && (baseName /* as string */).charCodeAt(len-1) <= CharacterCodes_9 {
		len--
	}
	s := (baseName /* as string */).slice(0, len)
	for index := 1; true; index++ {
		augmentedName := s + index /* as __String */
		if !tc.hasTypeParameterByName(typeParameters, augmentedName) {
			return augmentedName
		}
	}
}

func (tc *TypeChecker) getReturnTypeOfSingleNonGenericCallSignature(funcType Type) Type {
	signature := tc.getSingleCallSignature(funcType)
	if signature && !signature.typeParameters {
		return tc.getReturnTypeOfSignature(signature)
	}
}

func (tc *TypeChecker) getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr CallChain) Type {
	funcType := tc.checkExpression(expr.expression)
	nonOptionalType := tc.getOptionalExpressionType(funcType, expr.expression)
	returnType := tc.getReturnTypeOfSingleNonGenericCallSignature(funcType)
	return returnType && tc.propagateOptionalTypeMarker(returnType, expr, nonOptionalType != funcType)
}

/**
 * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
 * with computing the type and may not fully check all contained sub-expressions for errors.
 */

func (tc *TypeChecker) getTypeOfExpression(node Expression) Type {
	// Don't bother caching types that require no flow analysis and are quick to compute.
	quickType := tc.getQuickTypeOfExpression(node)
	if quickType {
		return quickType
	}
	// If a type has been cached for the node, return it.
	if node.flags&NodeFlagsTypeCached && tc.flowTypeCache {
		cachedType := tc.flowTypeCache[getNodeId(node)]
		if cachedType {
			return cachedType
		}
	}
	startInvocationCount := tc.flowInvocationCount
	type_ := tc.checkExpression(node, CheckModeTypeOnly)
	// If control flow analysis was required to determine the type, it is worth caching.
	if tc.flowInvocationCount != startInvocationCount {
		cache := tc.flowTypeCache || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: flowTypeCache = [] */ TODO)
		cache[getNodeId(node)] = type_
		setNodeFlags(node, node.flags|NodeFlagsTypeCached)
	}
	return type_
}

func (tc *TypeChecker) getQuickTypeOfExpression(node Expression) Type {
	expr := skipParentheses(node /*excludeJSDocTypeAssertions*/, true)
	if isJSDocTypeAssertion(expr) {
		type_ := getJSDocTypeAssertionType(expr)
		if !isConstTypeReference(type_) {
			return tc.getTypeFromTypeNode(type_)
		}
	}
	expr = skipParentheses(node)
	if isAwaitExpression(expr) {
		type_ := tc.getQuickTypeOfExpression(expr.expression)
		if type_ {
			return tc.getAwaitedType(type_)
		} else {
			return nil
		}
	}
	// Optimize for the common case of a call to a function with a single non-generic call
	// signature where we can just fetch the return type without checking the arguments.
	if isCallExpression(expr) && expr.expression.kind != SyntaxKindSuperKeyword && !isRequireCall(expr /*requireStringLiteralLikeArgument*/, true) && !tc.isSymbolOrSymbolForCall(expr) {
		if isCallChain(expr) {
			return tc.getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr)
		} else {
			return tc.getReturnTypeOfSingleNonGenericCallSignature(tc.checkNonNullExpression(expr.expression))
		}
	} else if isAssertionExpression(expr) && !isConstTypeReference(expr.type_) {
		return tc.getTypeFromTypeNode((expr /* as TypeAssertion */).type_)
	} else if isLiteralExpression(node) || isBooleanLiteral(node) {
		return tc.checkExpression(node)
	}
	return nil
}

/**
 * Returns the type of an expression. Unlike checkExpression, this function is simply concerned
 * with computing the type and may not fully check all contained sub-expressions for errors.
 * It is intended for uses where you know there is no contextual type,
 * and requesting the contextual type might cause a circularity or other bad behaviour.
 * It sets the contextual type of the node to any before calling getTypeOfExpression.
 */

func (tc *TypeChecker) getContextFreeTypeOfExpression(node Expression) Type {
	links := tc.getNodeLinks(node)
	if links.contextFreeType {
		return links.contextFreeType
	}
	tc.pushContextualType(node, tc.anyType /*isCache*/, false)
	type_ := /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive) */ TODO
	tc.popContextualType()
	return type_
}

func (tc *TypeChecker) checkExpression(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, checkMode CheckMode, forceTuple bool) Type {
	tracing. /* ? */ push(tracing.Phase.Check, "checkExpression", map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind": node.kind,
		"pos":  node.pos,
		"end":  node.end,
		"path": (node /* as TracingNode */).tracingPath,
	})
	saveCurrentNode := tc.currentNode
	tc.currentNode = node
	tc.instantiationCount = 0
	uninstantiatedType := tc.checkExpressionWorker(node, checkMode, forceTuple)
	type_ := tc.instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
	if tc.isConstEnumObjectType(type_) {
		tc.checkConstEnumAccess(node, type_)
	}
	tc.currentNode = saveCurrentNode
	tracing. /* ? */ pop()
	return type_
}

func (tc *TypeChecker) checkConstEnumAccess(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, type_ Type) {
	// enum object type for const enums are only permitted in:
	// - 'left' in property access
	// - 'object' in indexed access
	// - target in rhs of import statement
	ok := (node.parent.kind == SyntaxKindPropertyAccessExpression && (node.parent /* as PropertyAccessExpression */).expression == node) || (node.parent.kind == SyntaxKindElementAccessExpression && (node.parent /* as ElementAccessExpression */).expression == node) || ((node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindQualifiedName) && tc.isInRightSideOfImportOrExportAssignment(node /* as Identifier */) || (node.parent.kind == SyntaxKindTypeQuery && (node.parent /* as TypeQueryNode */).exprName == node)) || (node.parent.kind == SyntaxKindExportSpecifier)
	// We allow reexporting const enums

	if !ok {
		tc.error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query)
	}

	// --verbatimModuleSyntax only gets checked here when the enum usage does not
	// resolve to an import, because imports of ambient const enums get checked
	// separately in `checkAliasSymbol`.
	if tc.compilerOptions.isolatedModules || tc.compilerOptions.verbatimModuleSyntax && ok && !tc.resolveName(node, getFirstIdentifier(node /* as EntityNameOrEntityNameExpression */), SymbolFlagsAlias, nil, false, true) {
		Debug.assert(!!(type_.symbol.flags & SymbolFlagsConstEnum))
		constEnumDeclaration := type_.symbol.valueDeclaration /* as EnumDeclaration */
		redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
		if constEnumDeclaration.flags&NodeFlagsAmbient && !isValidTypeOnlyAliasUseSite(node) && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
			tc.error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, tc.isolatedModulesLikeFlagName)
		}
	}
}

func (tc *TypeChecker) checkParenthesizedExpression(node ParenthesizedExpression, checkMode CheckMode) Type {
	if hasJSDocNodes(node) {
		if isJSDocSatisfiesExpression(node) {
			return tc.checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode)
		}
		if isJSDocTypeAssertion(node) {
			return tc.checkAssertionWorker(node, checkMode)
		}
	}
	return tc.checkExpression(node.expression, checkMode)
}

func (tc *TypeChecker) checkExpressionWorker(node /* TODO(TS-TO-GO) TypeNode UnionType: Expression | QualifiedName */ any, checkMode *CheckMode, forceTuple bool) Type {
	kind := node.kind
	if tc.cancellationToken {
		// Only bother checking on a few construct kinds.  We don't want to be excessively
		// hitting the cancellation token on every node we check.
		switch kind {
		case SyntaxKindClassExpression,
			SyntaxKindFunctionExpression,
			SyntaxKindArrowFunction:
			tc.cancellationToken.throwIfCancellationRequested()
		}
	}
	switch kind {
	case SyntaxKindIdentifier:
		return tc.checkIdentifier(node /* as Identifier */, checkMode)
	case SyntaxKindPrivateIdentifier:
		return tc.checkPrivateIdentifierExpression(node /* as PrivateIdentifier */)
	case SyntaxKindThisKeyword:
		return tc.checkThisExpression(node)
	case SyntaxKindSuperKeyword:
		return tc.checkSuperExpression(node)
	case SyntaxKindNullKeyword:
		return tc.nullWideningType
	case SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindStringLiteral:
		if tc.hasSkipDirectInferenceFlag(node) {
			return tc.blockedStringType
		} else {
			return tc.getFreshTypeOfLiteralType(tc.getStringLiteralType((node /* as StringLiteralLike */).text))
		}
	case SyntaxKindNumericLiteral:
		tc.checkGrammarNumericLiteral(node /* as NumericLiteral */)
		return tc.getFreshTypeOfLiteralType(tc.getNumberLiteralType(+(node /* as NumericLiteral */).text))
	case SyntaxKindBigIntLiteral:
		tc.checkGrammarBigIntLiteral(node /* as BigIntLiteral */)
		return tc.getFreshTypeOfLiteralType(tc.getBigIntLiteralType(map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"negative":    false,
			"base10Value": parsePseudoBigInt((node /* as BigIntLiteral */).text),
		}))
	case SyntaxKindTrueKeyword:
		return tc.trueType
	case SyntaxKindFalseKeyword:
		return tc.falseType
	case SyntaxKindTemplateExpression:
		return tc.checkTemplateExpression(node /* as TemplateExpression */)
	case SyntaxKindRegularExpressionLiteral:
		return tc.checkRegularExpressionLiteral(node /* as RegularExpressionLiteral */)
	case SyntaxKindArrayLiteralExpression:
		return tc.checkArrayLiteral(node /* as ArrayLiteralExpression */, checkMode, forceTuple)
	case SyntaxKindObjectLiteralExpression:
		return tc.checkObjectLiteral(node /* as ObjectLiteralExpression */, checkMode)
	case SyntaxKindPropertyAccessExpression:
		return tc.checkPropertyAccessExpression(node /* as PropertyAccessExpression */, checkMode)
	case SyntaxKindQualifiedName:
		return tc.checkQualifiedName(node /* as QualifiedName */, checkMode)
	case SyntaxKindElementAccessExpression:
		return tc.checkIndexedAccess(node /* as ElementAccessExpression */, checkMode)
	case SyntaxKindCallExpression:
		if (node /* as CallExpression */).expression.kind == SyntaxKindImportKeyword {
			return tc.checkImportCallExpression(node /* as ImportCall */)
		}
		fallthrough
	case SyntaxKindNewExpression:
		return tc.checkCallExpression(node /* as CallExpression */, checkMode)
	case SyntaxKindTaggedTemplateExpression:
		return tc.checkTaggedTemplateExpression(node /* as TaggedTemplateExpression */)
	case SyntaxKindParenthesizedExpression:
		return tc.checkParenthesizedExpression(node /* as ParenthesizedExpression */, checkMode)
	case SyntaxKindClassExpression:
		return tc.checkClassExpression(node /* as ClassExpression */)
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return tc.checkFunctionExpressionOrObjectLiteralMethod(node /* as FunctionExpression | ArrowFunction */, checkMode)
	case SyntaxKindTypeOfExpression:
		return tc.checkTypeOfExpression(node /* as TypeOfExpression */)
	case SyntaxKindTypeAssertionExpression,
		SyntaxKindAsExpression:
		return tc.checkAssertion(node /* as AssertionExpression */, checkMode)
	case SyntaxKindNonNullExpression:
		return tc.checkNonNullAssertion(node /* as NonNullExpression */)
	case SyntaxKindExpressionWithTypeArguments:
		return tc.checkExpressionWithTypeArguments(node /* as ExpressionWithTypeArguments */)
	case SyntaxKindSatisfiesExpression:
		return tc.checkSatisfiesExpression(node /* as SatisfiesExpression */)
	case SyntaxKindMetaProperty:
		return tc.checkMetaProperty(node /* as MetaProperty */)
	case SyntaxKindDeleteExpression:
		return tc.checkDeleteExpression(node /* as DeleteExpression */)
	case SyntaxKindVoidExpression:
		return tc.checkVoidExpression(node /* as VoidExpression */)
	case SyntaxKindAwaitExpression:
		return tc.checkAwaitExpression(node /* as AwaitExpression */)
	case SyntaxKindPrefixUnaryExpression:
		return tc.checkPrefixUnaryExpression(node /* as PrefixUnaryExpression */)
	case SyntaxKindPostfixUnaryExpression:
		return tc.checkPostfixUnaryExpression(node /* as PostfixUnaryExpression */)
	case SyntaxKindBinaryExpression:
		return tc.checkBinaryExpression(node /* as BinaryExpression */, checkMode)
	case SyntaxKindConditionalExpression:
		return tc.checkConditionalExpression(node /* as ConditionalExpression */, checkMode)
	case SyntaxKindSpreadElement:
		return tc.checkSpreadExpression(node /* as SpreadElement */, checkMode)
	case SyntaxKindOmittedExpression:
		return tc.undefinedWideningType
	case SyntaxKindYieldExpression:
		return tc.checkYieldExpression(node /* as YieldExpression */)
	case SyntaxKindSyntheticExpression:
		return tc.checkSyntheticExpression(node /* as SyntheticExpression */)
	case SyntaxKindJsxExpression:
		return tc.checkJsxExpression(node /* as JsxExpression */, checkMode)
	case SyntaxKindJsxElement:
		return tc.checkJsxElement(node /* as JsxElement */, checkMode)
	case SyntaxKindJsxSelfClosingElement:
		return tc.checkJsxSelfClosingElement(node /* as JsxSelfClosingElement */, checkMode)
	case SyntaxKindJsxFragment:
		return tc.checkJsxFragment(node /* as JsxFragment */)
	case SyntaxKindJsxAttributes:
		return tc.checkJsxAttributes(node /* as JsxAttributes */, checkMode)
	case SyntaxKindJsxOpeningElement:
		Debug.fail("Shouldn't ever directly check a JsxOpeningElement")
	}
	return tc.errorType
}

// DECLARATION AND STATEMENT TYPE CHECKING

func (tc *TypeChecker) checkTypeParameter(node TypeParameterDeclaration) {
	// Grammar Checking
	tc.checkGrammarModifiers(node)
	if node.expression {
		tc.grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected)
	}

	tc.checkSourceElement(node.constraint)
	tc.checkSourceElement(node.default_)
	typeParameter := tc.getDeclaredTypeOfTypeParameter(tc.getSymbolOfDeclaration(node))
	// Resolve base constraint to reveal circularity errors
	tc.getBaseConstraintOfType(typeParameter)
	if !tc.hasNonCircularTypeParameterDefault(typeParameter) {
		tc.error(node.default_, Diagnostics.Type_parameter_0_has_a_circular_default, tc.typeToString(typeParameter))
	}
	constraintType := tc.getConstraintOfTypeParameter(typeParameter)
	defaultType := tc.getDefaultFromTypeParameter(typeParameter)
	if constraintType && defaultType {
		tc.checkTypeAssignableTo(defaultType, tc.getTypeWithThisArgument(tc.instantiateType(constraintType, tc.makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default_, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
	}
	tc.checkNodeDeferred(node)
	tc.addLazyDiagnostic(func() {
		return tc.checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0)
	})
}

func (tc *TypeChecker) checkTypeParameterDeferred(node TypeParameterDeclaration) {
	if isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent) {
		typeParameter := tc.getDeclaredTypeOfTypeParameter(tc.getSymbolOfDeclaration(node))
		modifiers := tc.getTypeParameterModifiers(typeParameter) & (ModifierFlagsIn | ModifierFlagsOut)
		if modifiers {
			symbol := tc.getSymbolOfDeclaration(node.parent)
			if isTypeAliasDeclaration(node.parent) && !(getObjectFlags(tc.getDeclaredTypeOfSymbol(symbol)) & (ObjectFlagsAnonymous | ObjectFlagsMapped)) {
				tc.error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types)
			} else if modifiers == ModifierFlagsIn || modifiers == ModifierFlagsOut {
				tracing. /* ? */ push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred", map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"parent": tc.getTypeId(tc.getDeclaredTypeOfSymbol(symbol)),
					"id":     tc.getTypeId(typeParameter),
				})
				source := tc.createMarkerType(symbol, typeParameter, __COND__(modifiers == ModifierFlagsOut, tc.markerSubTypeForCheck, tc.markerSuperTypeForCheck))
				target := tc.createMarkerType(symbol, typeParameter, __COND__(modifiers == ModifierFlagsOut, tc.markerSuperTypeForCheck, tc.markerSubTypeForCheck))
				saveVarianceTypeParameter := typeParameter
				tc.varianceTypeParameter = typeParameter
				tc.checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation)
				tc.varianceTypeParameter = saveVarianceTypeParameter
				tracing. /* ? */ pop()
			}
		}
	}
}

func (tc *TypeChecker) checkParameter(node ParameterDeclaration) {
	// Grammar checking
	// It is a SyntaxError if the Identifier "eval" or the Identifier "arguments" occurs as the
	// Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in strict code
	// or if its FunctionBody is strict code(11.1.5).
	tc.checkGrammarModifiers(node)

	tc.checkVariableLikeDeclaration(node)
	func_ := getContainingFunction(node)
	if hasSyntacticModifier(node, ModifierFlagsParameterPropertyModifier) {
		if !(func_.kind == SyntaxKindConstructor && nodeIsPresent(func_.body)) {
			tc.error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation)
		}
		if func_.kind == SyntaxKindConstructor && isIdentifier(node.name) && node.name.escapedText == "constructor" {
			tc.error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name)
		}
	}
	if !node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && (func_ /* as FunctionLikeDeclaration */).body {
		tc.error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature)
	}
	if node.name && isIdentifier(node.name) && (node.name.escapedText == "this" || node.name.escapedText == "new") {
		if func_.parameters.indexOf(node) != 0 {
			tc.error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText /* as string */)
		}
		if func_.kind == SyntaxKindConstructor || func_.kind == SyntaxKindConstructSignature || func_.kind == SyntaxKindConstructorType {
			tc.error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter)
		}
		if func_.kind == SyntaxKindArrowFunction {
			tc.error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
		}
		if func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor {
			tc.error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters)
		}
	}

	// Only check rest parameter type if it's not a binding pattern. Since binding patterns are
	// not allowed in a rest parameter, we already have an error from checkGrammarParameterList.
	if node.dotDotDotToken && !isBindingPattern(node.name) && !tc.isTypeAssignableTo(tc.getReducedType(tc.getTypeOfSymbol(node.symbol)), tc.anyReadonlyArrayType) {
		tc.error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type)
	}
}

func (tc *TypeChecker) checkTypePredicate(node TypePredicateNode) {
	parent := tc.getTypePredicateParent(node)
	if !parent {
		// The parent must not be valid.
		tc.error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods)
		return
	}

	signature := tc.getSignatureFromDeclaration(parent)
	typePredicate := tc.getTypePredicateOfSignature(signature)
	if !typePredicate {
		return
	}

	tc.checkSourceElement(node.type_)

	TODO_IDENTIFIER := node
	if typePredicate.kind != TypePredicateKindThis && typePredicate.kind != TypePredicateKindAssertsThis {
		if typePredicate.parameterIndex >= 0 {
			if signatureHasRestParameter(signature) && typePredicate.parameterIndex == signature.parameters.length-1 {
				tc.error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter)
			} else {
				if typePredicate.type_ {
					leadingError := func() DiagnosticMessageChain {
						return chainDiagnosticMessages(nil, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type)
					}
					tc.checkTypeAssignableTo(typePredicate.type_, tc.getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type_ /*headMessage*/, nil, leadingError)
				}
			}
		} else if parameterName {
			hasReportedError := false
			for _, TODO_IDENTIFIER := range parent.parameters {
				if isBindingPattern(name) && tc.checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName) {
					hasReportedError = true
					break
				}
			}
			if !hasReportedError {
				tc.error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName)
			}
		}
	}
}

func (tc *TypeChecker) getTypePredicateParent(node Node) *SignatureDeclaration {
	switch node.parent.kind {
	case SyntaxKindArrowFunction,
		SyntaxKindCallSignature,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindFunctionType,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature:
		parent := node.parent /* as SignatureDeclaration */
		if node == parent.type_ {
			return parent
		}
	}
}

func (tc *TypeChecker) checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern BindingPattern, predicateVariableNode Node, predicateVariableName string) *true {
	for _, element := range pattern.elements {
		if isOmittedExpression(element) {
			continue
		}

		name := element.name
		if name.kind == SyntaxKindIdentifier && name.escapedText == predicateVariableName {
			tc.error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName)
			return true
		} else if name.kind == SyntaxKindArrayBindingPattern || name.kind == SyntaxKindObjectBindingPattern {
			if tc.checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName) {
				return true
			}
		}
	}
}

func (tc *TypeChecker) checkSignatureDeclaration(node SignatureDeclaration) {
	// Grammar checking
	if node.kind == SyntaxKindIndexSignature {
		tc.checkGrammarIndexSignature(node)
	} else if node.kind == SyntaxKindFunctionType || node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindConstructorType || node.kind == SyntaxKindCallSignature || node.kind == SyntaxKindConstructor || node.kind == SyntaxKindConstructSignature {
		tc.checkGrammarFunctionLikeDeclaration(node /* as FunctionLikeDeclaration */)
	}

	functionFlags := getFunctionFlags(node /* as FunctionLikeDeclaration */)
	if !(functionFlags & FunctionFlagsInvalid) {
		// Async generators prior to ES2018 require the __await and __asyncGenerator helpers
		if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsyncGenerator && tc.languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncGeneratorIncludes)
		}

		// Async functions prior to ES2017 require the __awaiter helper
		if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsync && tc.languageVersion < LanguageFeatureMinimumTargetAsyncFunctions {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersAwaiter)
		}

		// Generator functions, Async functions, and Async Generator functions prior to
		// ES2015 require the __generator helper
		if (functionFlags&FunctionFlagsAsyncGenerator) != FunctionFlagsNormal && tc.languageVersion < LanguageFeatureMinimumTargetGenerators {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersGenerator)
		}
	}

	tc.checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
	tc.checkUnmatchedJSDocParameters(node)

	forEach(node.parameters, tc.checkParameter)

	// TODO(rbuckton): Should we start checking JSDoc types?
	if node.type_ {
		tc.checkSourceElement(node.type_)
	}

	tc.addLazyDiagnostic(checkSignatureDeclarationDiagnostics)

	checkSignatureDeclarationDiagnostics := func() {
		tc.checkCollisionWithArgumentsInGeneratedCode(node)

		returnTypeNode := getEffectiveReturnTypeNode(node)
		returnTypeErrorLocation := returnTypeNode

		if isInJSFile(node) {
			typeTag := getJSDocTypeTag(node)
			if typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type_) {
				signature := tc.getSingleCallSignature(tc.getTypeFromTypeNode(typeTag.typeExpression))
				if signature && signature.declaration {
					returnTypeNode = getEffectiveReturnTypeNode(signature.declaration)
					returnTypeErrorLocation = typeTag.typeExpression.type_
				}
			}
		}

		if tc.noImplicitAny && !returnTypeNode {
			switch node.kind {
			case SyntaxKindConstructSignature:
				tc.error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
			case SyntaxKindCallSignature:
				tc.error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type)
			}
		}

		if returnTypeNode && returnTypeErrorLocation {
			functionFlags := getFunctionFlags(node /* as FunctionDeclaration */)
			if (functionFlags & (FunctionFlagsInvalid | FunctionFlagsGenerator)) == FunctionFlagsGenerator {
				returnType := tc.getTypeFromTypeNode(returnTypeNode)
				if returnType == tc.voidType {
					tc.error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation)
				} else {
					tc.checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation)
				}
			} else if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
				tc.checkAsyncFunctionReturnType(node /* as FunctionLikeDeclaration */, returnTypeNode, returnTypeErrorLocation)
			}
		}
		if node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindJSDocFunctionType {
			tc.registerForUnusedIdentifiersCheck(node)
		}
	}

}

func (tc *TypeChecker) checkGeneratorInstantiationAssignabilityToReturnType(returnType Type, functionFlags FunctionFlags, errorNode TypeNode) bool {
	// Naively, one could check that Generator<any, any, any> is assignable to the return type annotation.
	// However, that would not catch the error in the following case.
	//
	//    interface BadGenerator extends Iterable<number>, Iterator<string> { }
	//    function* g(): BadGenerator { } // Iterable and Iterator have different types!
	//
	generatorYieldType := tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, returnType, (functionFlags&FunctionFlagsAsync) != 0) || tc.anyType
	generatorReturnType := tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, (functionFlags&FunctionFlagsAsync) != 0) || generatorYieldType
	generatorNextType := tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, (functionFlags&FunctionFlagsAsync) != 0) || tc.unknownType
	generatorInstantiation := tc.createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & FunctionFlagsAsync))

	return tc.checkTypeAssignableTo(generatorInstantiation, returnType, errorNode)
}

func (tc *TypeChecker) checkClassForDuplicateDeclarations(node ClassLikeDeclaration) {
	instanceNames := NewMap[__String, DeclarationMeaning]()
	staticNames := NewMap[__String, DeclarationMeaning]()
	// instance and static private identifiers share the same scope
	privateIdentifiers := NewMap[__String, DeclarationMeaning]()
	for _, member := range node.members {
		if member.kind == SyntaxKindConstructor {
			for _, param := range (member /* as ConstructorDeclaration */).parameters {
				if isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name) {
					addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaningGetOrSetAccessor)
				}
			}
		} else {
			isStaticMember := isStatic(member)
			name := member.name
			if !name {
				continue
			}
			isPrivate := isPrivateIdentifier(name)
			var privateStaticFlags /* TODO(TS-TO-GO) inferred type 0 | DeclarationMeaning.PrivateStatic */ any
			if isPrivate && isStaticMember {
				privateStaticFlags = DeclarationMeaningPrivateStatic
			} else {
				privateStaticFlags = 0
			}
			var names Map[__String, DeclarationMeaning]
			switch {
			case isPrivate:
				names = privateIdentifiers
			case isStaticMember:
				names = staticNames
			default:
				names = instanceNames
			}

			memberName := name && tc.getEffectivePropertyNameForPropertyNameNode(name)
			if memberName {
				switch member.kind {
				case SyntaxKindGetAccessor:
					addName(names, name, memberName, DeclarationMeaningGetAccessor|privateStaticFlags)
				case SyntaxKindSetAccessor:
					addName(names, name, memberName, DeclarationMeaningSetAccessor|privateStaticFlags)
				case SyntaxKindPropertyDeclaration:
					addName(names, name, memberName, DeclarationMeaningGetOrSetAccessor|privateStaticFlags)
				case SyntaxKindMethodDeclaration:
					addName(names, name, memberName, DeclarationMeaningMethod|privateStaticFlags)
				}
			}
		}
	}

	addName := func(names Map[__String, DeclarationMeaning], location Node, name __String, meaning DeclarationMeaning) {
		prev := names.get(name)
		if prev {
			// For private identifiers, do not allow mixing of static and instance members with the same name
			if (prev & DeclarationMeaningPrivateStatic) != (meaning & DeclarationMeaningPrivateStatic) {
				tc.error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location))
			} else {
				prevIsMethod := !!(prev & DeclarationMeaningMethod)
				isMethod := !!(meaning & DeclarationMeaningMethod)
				if prevIsMethod || isMethod {
					if prevIsMethod != isMethod {
						tc.error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
					}
					// If this is a method/method duplication is might be an overload, so this will be handled when overloads are considered
				} else if prev & meaning & ~DeclarationMeaningPrivateStatic {
					tc.error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
				} else {
					names.set(name, prev|meaning)
				}
			}
		} else {
			names.set(name, meaning)
		}
	}

}

/**
 * Static members being set on a constructor function may conflict with built-in properties
 * of Function. Esp. in ECMAScript 5 there are non-configurable and non-writable
 * built-in properties. This check issues a transpile error when a class has a static
 * member with the same name as a non-writable built-in property.
 *
 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.3
 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.5
 * @see http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-function-constructor
 * @see http://www.ecma-international.org/ecma-262/6.0/#sec-function-instances
 */

func (tc *TypeChecker) checkClassForStaticPropertyNameConflicts(node ClassLikeDeclaration) {
	for _, member := range node.members {
		memberNameNode := member.name
		isStaticMember := isStatic(member)
		if isStaticMember && memberNameNode {
			memberName := tc.getEffectivePropertyNameForPropertyNameNode(memberNameNode)
			switch memberName {
			case "name",
				"length",
				"caller",
				"arguments":
				if tc.useDefineForClassFields {
					break
				}
				fallthrough
			case "prototype":
				message := Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1
				className := tc.getNameOfSymbolAsWritten(tc.getSymbolOfDeclaration(node))
				tc.error(memberNameNode, message, memberName, className)
			}
		}
	}
}

func (tc *TypeChecker) checkObjectTypeForDuplicateDeclarations(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeLiteralNode | InterfaceDeclaration */ any) {
	names := NewMap[string, bool]()
	for _, member := range node.members {
		if member.kind == SyntaxKindPropertySignature {
			var memberName string
			name := member.name
			switch name.kind {
			case SyntaxKindStringLiteral,
				SyntaxKindNumericLiteral:
				memberName = name.text
			case SyntaxKindIdentifier:
				memberName = idText(name)
			default:
				continue
			}

			if names.get(memberName) {
				tc.error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName)
				tc.error(member.name, Diagnostics.Duplicate_identifier_0, memberName)
			} else {
				names.set(memberName, true)
			}
		}
	}
}

func (tc *TypeChecker) checkTypeForDuplicateIndexSignatures(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode */ any) {
	if node.kind == SyntaxKindInterfaceDeclaration {
		nodeSymbol := tc.getSymbolOfDeclaration(node)
		// in case of merging interface declaration it is possible that we'll enter this check procedure several times for every declaration
		// to prevent this run check only for the first declaration of a given kind
		if nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] != node {
			return
		}
	}

	// TypeScript 1.0 spec (April 2014)
	// 3.7.4: An object type can contain at most one string index signature and one numeric index signature.
	// 8.5: A class declaration can have at most one string index member declaration and one numeric index member declaration
	indexSymbol := tc.getIndexSymbol(tc.getSymbolOfDeclaration(node))
	if indexSymbol. /* ? */ declarations {
		indexSignatureMap := NewMap[TypeId /* TODO(TS-TO-GO) TypeNode TypeLiteral: { type: Type; declarations: IndexSignatureDeclaration[]; } */, any]()
		for _, declaration := range indexSymbol.declarations /* as IndexSignatureDeclaration[] */ {
			if declaration.parameters.length == 1 && declaration.parameters[0].type_ {
				tc.forEachType(tc.getTypeFromTypeNode(declaration.parameters[0].type_), func(type_ Type) {
					entry := indexSignatureMap.get(tc.getTypeId(type_))
					if entry {
						entry.declarations.push(declaration)
					} else {
						indexSignatureMap.set(tc.getTypeId(type_), map[any]any{ /* TODO(TS-TO-GO): was object literal */
							"type_":        type_,
							"declarations": []IndexSignatureDeclaration{declaration},
						})
					}
				})
			}
		}
		indexSignatureMap.forEach(func(entry /* TODO(TS-TO-GO) inferred type { type: Type; declarations: IndexSignatureDeclaration[]; } */ any) {
			if entry.declarations.length > 1 {
				for _, declaration := range entry.declarations {
					tc.error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, tc.typeToString(entry.type_))
				}
			}
		})
	}
}

func (tc *TypeChecker) checkPropertyDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | PropertySignature */ any) {
	// Grammar checking
	if !tc.checkGrammarModifiers(node) && !tc.checkGrammarProperty(node) {
		tc.checkGrammarComputedPropertyName(node.name)
	}
	tc.checkVariableLikeDeclaration(node)

	tc.setNodeLinksForPrivateIdentifierScope(node)

	// property signatures already report "initializer not allowed in ambient context" elsewhere
	if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindPropertyDeclaration && node.initializer {
		tc.error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name))
	}
}

func (tc *TypeChecker) checkPropertySignature(node PropertySignature) {
	if isPrivateIdentifier(node.name) {
		tc.error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
	}
	return tc.checkPropertyDeclaration(node)
}

func (tc *TypeChecker) checkMethodDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: MethodDeclaration | MethodSignature */ any) {
	// Grammar checking
	if !tc.checkGrammarMethod(node) {
		tc.checkGrammarComputedPropertyName(node.name)
	}

	if isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) == "constructor" {
		tc.error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator)
	}

	// Grammar checking for modifiers is done inside the function checkGrammarFunctionLikeDeclaration
	tc.checkFunctionOrMethodDeclaration(node)

	// method signatures already report "implementation not allowed in ambient context" elsewhere
	if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindMethodDeclaration && node.body {
		tc.error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name))
	}

	// Private named methods are only allowed in class declarations
	if isPrivateIdentifier(node.name) && !getContainingClass(node) {
		tc.error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
	}

	tc.setNodeLinksForPrivateIdentifierScope(node)
}

func (tc *TypeChecker) setNodeLinksForPrivateIdentifierScope(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */ any) {
	if isPrivateIdentifier(node.name) {
		if tc.languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || tc.languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !tc.useDefineForClassFields {
			for lexicalScope := getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope) {
				tc.getNodeLinks(lexicalScope).flags |= NodeCheckFlagsContainsClassWithPrivateIdentifiers
			}

			// If this is a private element in a class expression inside the body of a loop,
			// then we must use a block-scoped binding to store the additional variables required
			// to transform private elements.
			if isClassExpression(node.parent) {
				enclosingIterationStatement := tc.getEnclosingIterationStatement(node.parent)
				if enclosingIterationStatement {
					tc.getNodeLinks(node.name).flags |= NodeCheckFlagsBlockScopedBindingInLoop
					tc.getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
				}
			}
		}
	}
}

func (tc *TypeChecker) checkClassStaticBlockDeclaration(node ClassStaticBlockDeclaration) {
	tc.checkGrammarModifiers(node)

	forEachChild(node, tc.checkSourceElement)
}

func (tc *TypeChecker) checkConstructorDeclaration(node ConstructorDeclaration) {
	// Grammar check on signature of constructor and modifier of the constructor is done in checkSignatureDeclaration function.
	tc.checkSignatureDeclaration(node)
	// Grammar check for checking only related to constructorDeclaration
	if !tc.checkGrammarConstructorTypeParameters(node) {
		tc.checkGrammarConstructorTypeAnnotation(node)
	}

	tc.checkSourceElement(node.body)

	symbol := tc.getSymbolOfDeclaration(node)
	firstDeclaration := getDeclarationOfKind(symbol, node.kind)

	// Only type check the symbol once
	if node == firstDeclaration {
		tc.checkFunctionOrConstructorSymbol(symbol)
	}

	// exit early in the case of signature - super checks are not relevant to them
	if nodeIsMissing(node.body) {
		return
	}

	tc.addLazyDiagnostic(checkConstructorDeclarationDiagnostics)

	return

	isInstancePropertyWithInitializerOrPrivateIdentifierProperty := func(n Node) bool {
		if isPrivateIdentifierClassElementDeclaration(n) {
			return true
		}
		return n.kind == SyntaxKindPropertyDeclaration && !isStatic(n) && !!(n /* as PropertyDeclaration */).initializer
	}

	checkConstructorDeclarationDiagnostics := func() {
		// TS 1.0 spec (April 2014): 8.3.2
		// Constructors of classes with no extends clause may not contain super calls, whereas
		// constructors of derived classes must contain at least one super call somewhere in their function body.
		containingClassDecl := node.parent
		if getClassExtendsHeritageElement(containingClassDecl) {
			tc.captureLexicalThis(node.parent, containingClassDecl)
			classExtendsNull := tc.classDeclarationExtendsNull(containingClassDecl)
			superCall := tc.findFirstSuperCall(node.body)
			if superCall {
				if classExtendsNull {
					tc.error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null)
				}

				// A super call must be root-level in a constructor if both of the following are true:
				// - The containing class is a derived class.
				// - The constructor declares parameter properties
				//   or the containing class declares instance member variables with initializers.

				superCallShouldBeRootLevel := !tc.emitStandardClassFields && (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) || some(node.parameters, func(p ParameterDeclaration) bool {
					return hasSyntacticModifier(p, ModifierFlagsParameterPropertyModifier)
				}))

				if superCallShouldBeRootLevel {
					// Until we have better flow analysis, it is an error to place the super call within any kind of block or conditional
					// See GH #8277
					if !tc.superCallIsRootLevelInConstructor(superCall, node.body) {
						tc.error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers)
					} else {
						var superCallStatement *ExpressionStatement

						for _, statement := range node.body.statements {
							if isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression)) {
								superCallStatement = statement
								break
							}
							if tc.nodeImmediatelyReferencesSuperOrThis(statement) {
								break
							}
						}

						// Until we have better flow analysis, it is an error to place the super call within any kind of block or conditional
						// See GH #8277
						if superCallStatement == nil {
							tc.error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers)
						}
					}
				}
			} else if !classExtendsNull {
				tc.error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call)
			}
		}
	}

}

func (tc *TypeChecker) superCallIsRootLevelInConstructor(superCall Node, body Block) bool {
	superCallParent := walkUpParenthesizedExpressions(superCall.parent)
	return isExpressionStatement(superCallParent) && superCallParent.parent == body
}

func (tc *TypeChecker) nodeImmediatelyReferencesSuperOrThis(node Node) bool {
	if node.kind == SyntaxKindSuperKeyword || node.kind == SyntaxKindThisKeyword {
		return true
	}

	if isThisContainerOrFunctionBlock(node) {
		return false
	}

	return !!forEachChild(node, tc.nodeImmediatelyReferencesSuperOrThis)
}

func (tc *TypeChecker) checkAccessorDeclaration(node AccessorDeclaration) {
	if isIdentifier(node.name) && idText(node.name) == "constructor" && isClassLike(node.parent) {
		tc.error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor)
	}
	tc.addLazyDiagnostic(checkAccessorDeclarationDiagnostics)
	tc.checkSourceElement(node.body)
	tc.setNodeLinksForPrivateIdentifierScope(node)

	checkAccessorDeclarationDiagnostics := func() {
		// Grammar checking accessors
		if !tc.checkGrammarFunctionLikeDeclaration(node) && !tc.checkGrammarAccessor(node) {
			tc.checkGrammarComputedPropertyName(node.name)
		}

		tc.checkDecorators(node)
		tc.checkSignatureDeclaration(node)
		if node.kind == SyntaxKindGetAccessor {
			if !(node.flags & NodeFlagsAmbient) && nodeIsPresent(node.body) && (node.flags & NodeFlagsHasImplicitReturn) {
				if !(node.flags & NodeFlagsHasExplicitReturn) {
					tc.error(node.name, Diagnostics.A_get_accessor_must_return_a_value)
				}
			}
		}
		// Do not use hasDynamicName here, because that returns false for well known symbols.
		// We want to perform checkComputedPropertyName for all computed properties, including
		// well known symbols.
		if node.name.kind == SyntaxKindComputedPropertyName {
			tc.checkComputedPropertyName(node.name)
		}

		if tc.hasBindableName(node) {
			// TypeScript 1.0 spec (April 2014): 8.4.3
			// Accessors for the same member name must specify the same accessibility.
			symbol := tc.getSymbolOfDeclaration(node)
			getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
			setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
			if getter && setter && !(tc.getNodeCheckFlags(getter) & NodeCheckFlagsTypeChecked) {
				tc.getNodeLinks(getter).flags |= NodeCheckFlagsTypeChecked
				getterFlags := getEffectiveModifierFlags(getter)
				setterFlags := getEffectiveModifierFlags(setter)
				if (getterFlags & ModifierFlagsAbstract) != (setterFlags & ModifierFlagsAbstract) {
					tc.error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
					tc.error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
				}
				if ((getterFlags & ModifierFlagsProtected) && !(setterFlags & (ModifierFlagsProtected | ModifierFlagsPrivate))) || ((getterFlags & ModifierFlagsPrivate) && !(setterFlags & ModifierFlagsPrivate)) {
					tc.error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
					tc.error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
				}
			}
		}
		returnType := tc.getTypeOfAccessors(tc.getSymbolOfDeclaration(node))
		if node.kind == SyntaxKindGetAccessor {
			tc.checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
		}
	}

}

func (tc *TypeChecker) checkMissingDeclaration(node Node) {
	tc.checkDecorators(node)
}

func (tc *TypeChecker) getEffectiveTypeArgumentAtIndex(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments */ any, typeParameters []TypeParameter, index number) Type {
	if node.typeArguments && index < node.typeArguments.length {
		return tc.getTypeFromTypeNode(node.typeArguments[index])
	}
	return tc.getEffectiveTypeArguments(node, typeParameters)[index]
}

func (tc *TypeChecker) getEffectiveTypeArguments(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) []Type {
	return tc.fillMissingTypeArguments(map_(node.typeArguments, tc.getTypeFromTypeNode), typeParameters, tc.getMinTypeArgumentCount(typeParameters), isInJSFile(node))
}

func (tc *TypeChecker) checkTypeArgumentConstraints(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) bool {
	var typeArguments *[]Type
	var mapper *TypeMapper
	result := true
	for i := 0; i < typeParameters.length; i++ {
		constraint := tc.getConstraintOfTypeParameter(typeParameters[i])
		if constraint {
			if !typeArguments {
				typeArguments = tc.getEffectiveTypeArguments(node, typeParameters)
				mapper = tc.createTypeMapper(typeParameters, typeArguments)
			}
			result = result && tc.checkTypeAssignableTo(typeArguments[i], tc.instantiateType(constraint, mapper), node.typeArguments[i], Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
		}
	}
	return result
}

func (tc *TypeChecker) getTypeParametersForTypeAndSymbol(type_ Type, symbol Symbol) *[]TypeParameter {
	if !tc.isErrorType(type_) {
		return symbol.flags&SymbolFlagsTypeAlias && tc.getSymbolLinks(symbol).typeParameters || (__COND__(getObjectFlags(type_)&ObjectFlagsReference, (type_ /* as TypeReference */).target.localTypeParameters, nil))
	}
	return nil
}

func (tc *TypeChecker) getTypeParametersForTypeReferenceOrImport(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) *[]TypeParameter {
	type_ := tc.getTypeFromTypeNode(node)
	if !tc.isErrorType(type_) {
		symbol := tc.getNodeLinks(node).resolvedSymbol
		if symbol {
			return tc.getTypeParametersForTypeAndSymbol(type_, symbol)
		}
	}
	return nil
}

func (tc *TypeChecker) checkTypeReferenceNode(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments */ any) {
	tc.checkGrammarTypeArguments(node, node.typeArguments)
	if node.kind == SyntaxKindTypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end != node.typeArguments.pos {
		// If there was a token between the type name and the type arguments, check if it was a DotToken
		sourceFile := getSourceFileOfNode(node)
		if scanTokenAtPosition(sourceFile, node.typeName.end) == SyntaxKindDotToken {
			tc.grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
		}
	}
	forEach(node.typeArguments, tc.checkSourceElement)
	tc.checkTypeReferenceOrImport(node)
}

func (tc *TypeChecker) checkTypeReferenceOrImport(node /* TODO(TS-TO-GO) TypeNode UnionType: TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) {
	type_ := tc.getTypeFromTypeNode(node)
	if !tc.isErrorType(type_) {
		if node.typeArguments {
			tc.addLazyDiagnostic(func() {
				typeParameters := tc.getTypeParametersForTypeReferenceOrImport(node)
				if typeParameters {
					tc.checkTypeArgumentConstraints(node, typeParameters)
				}
			})
		}
		symbol := tc.getNodeLinks(node).resolvedSymbol
		if symbol {
			if some(symbol.declarations, func(d Declaration) bool {
				return isTypeDeclaration(d) && !!(d.flags & NodeFlagsDeprecated)
			}) {
				tc.addDeprecatedSuggestion(tc.getDeprecatedSuggestionNode(node), symbol.declarations, symbol.escapedName /* as string */)
			}
		}
	}
}

func (tc *TypeChecker) getTypeArgumentConstraint(node TypeNode) Type {
	typeReferenceNode := tryCast(node.parent, isTypeReferenceType)
	if !typeReferenceNode {
		return nil
	}
	typeParameters := tc.getTypeParametersForTypeReferenceOrImport(typeReferenceNode)
	if !typeParameters {
		return nil
	}
	constraint := tc.getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments.indexOf(node)])
	return constraint && tc.instantiateType(constraint, tc.createTypeMapper(typeParameters, tc.getEffectiveTypeArguments(typeReferenceNode, typeParameters)))
}

func (tc *TypeChecker) checkTypeQuery(node TypeQueryNode) {
	tc.getTypeFromTypeQueryNode(node)
}

func (tc *TypeChecker) checkTypeLiteral(node TypeLiteralNode) {
	forEach(node.members, tc.checkSourceElement)
	tc.addLazyDiagnostic(checkTypeLiteralDiagnostics)

	checkTypeLiteralDiagnostics := func() {
		type_ := tc.getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
		tc.checkIndexConstraints(type_, type_.symbol)
		tc.checkTypeForDuplicateIndexSignatures(node)
		tc.checkObjectTypeForDuplicateDeclarations(node)
	}

}

func (tc *TypeChecker) checkArrayType(node ArrayTypeNode) {
	tc.checkSourceElement(node.elementType)
}

func (tc *TypeChecker) checkTupleType(node TupleTypeNode) {
	seenOptionalElement := false
	seenRestElement := false
	for _, e := range node.elements {
		flags := tc.getTupleElementFlags(e)
		if flags & ElementFlagsVariadic {
			type_ := tc.getTypeFromTypeNode((e /* as RestTypeNode | NamedTupleMember */).type_)
			if !tc.isArrayLikeType(type_) {
				tc.error(e, Diagnostics.A_rest_element_type_must_be_an_array_type)
				break
			}
			if tc.isArrayType(type_) || tc.isTupleType(type_) && type_.target.combinedFlags&ElementFlagsRest {
				flags |= ElementFlagsRest
			}
		}
		if flags & ElementFlagsRest {
			if seenRestElement {
				tc.grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element)
				break
			}
			seenRestElement = true
		} else if flags & ElementFlagsOptional {
			if seenRestElement {
				tc.grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element)
				break
			}
			seenOptionalElement = true
		} else if flags&ElementFlagsRequired && seenOptionalElement {
			tc.grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element)
			break
		}
	}
	forEach(node.elements, tc.checkSourceElement)
	tc.getTypeFromTypeNode(node)
}

func (tc *TypeChecker) checkUnionOrIntersectionType(node UnionOrIntersectionTypeNode) {
	forEach(node.types, tc.checkSourceElement)
	tc.getTypeFromTypeNode(node)
}

func (tc *TypeChecker) checkIndexedAccessIndexType(type_ Type, accessNode /* TODO(TS-TO-GO) TypeNode UnionType: IndexedAccessTypeNode | ElementAccessExpression */ any) Type {
	if !(type_.flags & TypeFlagsIndexedAccess) {
		return type_
	}
	// Check if the index type is assignable to 'keyof T' for the object type.
	objectType := (type_ /* as IndexedAccessType */).objectType
	indexType := (type_ /* as IndexedAccessType */).indexType
	// skip index type deferral on remapping mapped types
	var objectIndexType Type
	if tc.isGenericMappedType(objectType) && tc.getMappedTypeNameTypeKind(objectType) == MappedTypeNameTypeKindRemapping {
		objectIndexType = tc.getIndexTypeForMappedType(objectType, IndexFlagsNone)
	} else {
		objectIndexType = tc.getIndexType(objectType, IndexFlagsNone)
	}
	hasNumberIndexInfo := !!tc.getIndexInfoOfType(objectType, tc.numberType)
	if tc.everyType(indexType, func(t Type) bool {
		return tc.isTypeAssignableTo(t, objectIndexType) || hasNumberIndexInfo && tc.isApplicableIndexType(t, tc.numberType)
	}) {
		if accessNode.kind == SyntaxKindElementAccessExpression && isAssignmentTarget(accessNode) && getObjectFlags(objectType)&ObjectFlagsMapped && tc.getMappedTypeModifiers(objectType /* as MappedType */)&MappedTypeModifiersIncludeReadonly {
			tc.error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, tc.typeToString(objectType))
		}
		return type_
	}
	if tc.isGenericObjectType(objectType) {
		propertyName := tc.getPropertyNameFromIndex(indexType, accessNode)
		if propertyName {
			propertySymbol := tc.forEachType(tc.getApparentType(objectType), func(t Type) Symbol {
				return tc.getPropertyOfType(t, propertyName)
			})
			if propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol)&ModifierFlagsNonPublicAccessibilityModifier {
				tc.error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName))
				return tc.errorType
			}
		}
	}
	tc.error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, tc.typeToString(indexType), tc.typeToString(objectType))
	return tc.errorType
}

func (tc *TypeChecker) checkIndexedAccessType(node IndexedAccessTypeNode) {
	tc.checkSourceElement(node.objectType)
	tc.checkSourceElement(node.indexType)
	tc.checkIndexedAccessIndexType(tc.getTypeFromIndexedAccessTypeNode(node), node)
}

func (tc *TypeChecker) checkMappedType(node MappedTypeNode) {
	tc.checkGrammarMappedType(node)
	tc.checkSourceElement(node.typeParameter)
	tc.checkSourceElement(node.nameType)
	tc.checkSourceElement(node.type_)

	if !node.type_ {
		tc.reportImplicitAny(node, tc.anyType)
	}

	type_ := tc.getTypeFromMappedTypeNode(node) /* as MappedType */
	nameType := tc.getNameTypeFromMappedType(type_)
	if nameType {
		tc.checkTypeAssignableTo(nameType, tc.stringNumberSymbolType, node.nameType)
	} else {
		constraintType := tc.getConstraintTypeFromMappedType(type_)
		tc.checkTypeAssignableTo(constraintType, tc.stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter))
	}
}

func (tc *TypeChecker) checkGrammarMappedType(node MappedTypeNode) *bool {
	if node.members. /* ? */ length {
		return tc.grammarErrorOnNode(node.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
	}
}

func (tc *TypeChecker) checkThisType(node ThisTypeNode) {
	tc.getTypeFromThisTypeNode(node)
}

func (tc *TypeChecker) checkTypeOperator(node TypeOperatorNode) {
	tc.checkGrammarTypeOperatorNode(node)
	tc.checkSourceElement(node.type_)
}

func (tc *TypeChecker) checkConditionalType(node ConditionalTypeNode) {
	forEachChild(node, tc.checkSourceElement)
}

func (tc *TypeChecker) checkInferType(node InferTypeNode) {
	if !findAncestor(node, func(n Node) bool {
		return n.parent && n.parent.kind == SyntaxKindConditionalType && (n.parent /* as ConditionalTypeNode */).extendsType == n
	}) {
		tc.grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type)
	}
	tc.checkSourceElement(node.typeParameter)
	symbol := tc.getSymbolOfDeclaration(node.typeParameter)
	if symbol.declarations && symbol.declarations.length > 1 {
		links := tc.getSymbolLinks(symbol)
		if !links.typeParametersChecked {
			links.typeParametersChecked = true
			typeParameter := tc.getDeclaredTypeOfTypeParameter(symbol)
			var declarations []TypeParameterDeclaration = getDeclarationsOfKind(symbol, SyntaxKindTypeParameter)
			if !tc.areTypeParametersIdentical(declarations, []TypeParameter{typeParameter}, func(decl TypeParameterDeclaration) []TypeParameterDeclaration {
				return []TypeParameterDeclaration{decl}
			}) {
				// Report an error on every conflicting declaration.
				name := tc.symbolToString(symbol)
				for _, declaration := range declarations {
					tc.error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name)
				}
			}
		}
	}
	tc.registerForUnusedIdentifiersCheck(node)
}

func (tc *TypeChecker) checkTemplateLiteralType(node TemplateLiteralTypeNode) {
	for _, span := range node.templateSpans {
		tc.checkSourceElement(span.type_)
		type_ := tc.getTypeFromTypeNode(span.type_)
		tc.checkTypeAssignableTo(type_, tc.templateConstraintType, span.type_)
	}
	tc.getTypeFromTypeNode(node)
}

func (tc *TypeChecker) checkImportType(node ImportTypeNode) {
	tc.checkSourceElement(node.argument)

	if node.attributes {
		getResolutionModeOverride(node.attributes, tc.grammarErrorOnNode)
	}
	tc.checkTypeReferenceOrImport(node)
}

func (tc *TypeChecker) checkNamedTupleMember(node NamedTupleMember) {
	if node.dotDotDotToken && node.questionToken {
		tc.grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest)
	}
	if node.type_.kind == SyntaxKindOptionalType {
		tc.grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type)
	}
	if node.type_.kind == SyntaxKindRestType {
		tc.grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type)
	}
	tc.checkSourceElement(node.type_)
	tc.getTypeFromTypeNode(node)
}

func (tc *TypeChecker) isPrivateWithinAmbient(node Node) bool {
	return (hasEffectiveModifier(node, ModifierFlagsPrivate) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & NodeFlagsAmbient)
}

func (tc *TypeChecker) getEffectiveDeclarationFlags(n Declaration, flagsToCheck ModifierFlags) ModifierFlags {
	flags := tc.getCombinedModifierFlagsCached(n)

	// children of classes (even ambient classes) should not be marked as ambient or export
	// because those flags have no useful semantics there.
	if n.parent.kind != SyntaxKindInterfaceDeclaration && n.parent.kind != SyntaxKindClassDeclaration && n.parent.kind != SyntaxKindClassExpression && n.flags&NodeFlagsAmbient {
		container := getEnclosingContainer(n)
		if (container && container.flags&NodeFlagsExportContext) && !(flags & ModifierFlagsAmbient) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)) {
			// It is nested in an ambient export context, which means it is automatically exported
			flags |= ModifierFlagsExport
		}
		flags |= ModifierFlagsAmbient
	}

	return flags & flagsToCheck
}

func (tc *TypeChecker) checkFunctionOrConstructorSymbol(symbol Symbol) {
	tc.addLazyDiagnostic(func() {
		return tc.checkFunctionOrConstructorSymbolWorker(symbol)
	})
}

func (tc *TypeChecker) checkFunctionOrConstructorSymbolWorker(symbol Symbol) {
	getCanonicalOverload := func(overloads []Declaration, implementation *FunctionLikeDeclaration) Declaration {
		// Consider the canonical set of flags to be the flags of the bodyDeclaration or the first declaration
		// Error on all deviations from this canonical set of flags
		// The caveat is that if some overloads are defined in lib.d.ts, we don't want to
		// report the errors on those. To achieve this, we will say that the implementation is
		// the canonical signature only if it is in the same container as the first overload
		implementationSharesContainerWithFirstOverload := implementation != nil && implementation.parent == overloads[0].parent
		if implementationSharesContainerWithFirstOverload {
			return implementation
		} else {
			return overloads[0]
		}
	}

	checkFlagAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, flagsToCheck ModifierFlags, someOverloadFlags ModifierFlags, allOverloadFlags ModifierFlags) {
		// Error if some overloads have a flag that is not shared by all overloads. To find the
		// deviations, we XOR someOverloadFlags with allOverloadFlags
		someButNotAllOverloadFlags := someOverloadFlags ^ allOverloadFlags
		if someButNotAllOverloadFlags != 0 {
			canonicalFlags := tc.getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck)
			group(overloads, func(o Declaration) string {
				return getSourceFileOfNode(o).fileName
			}).forEach(func(overloadsInFile []Declaration) {
				canonicalFlagsForFile := tc.getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck)
				for _, o := range overloadsInFile {
					deviation := tc.getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags
					deviationInFile := tc.getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile
					if deviationInFile & ModifierFlagsExport {
						// Overloads in different files need not all have export modifiers. This is ok:
						//   // lib.d.ts
						//   declare function foo(s: number): string;
						//   declare function foo(s: string): number;
						//   export { foo };
						//
						//   // app.ts
						//   declare module "lib" {
						//     export function foo(s: boolean): boolean;
						//   }
						tc.error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported)
					} else if deviationInFile & ModifierFlagsAmbient {
						// Though rare, a module augmentation (necessarily ambient) is allowed to add overloads
						// to a non-ambient function in an implementation file.
						tc.error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient)
					} else if deviation & (ModifierFlagsPrivate | ModifierFlagsProtected) {
						tc.error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected)
					} else if deviation & ModifierFlagsAbstract {
						tc.error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract)
					}
				}
			})
		}
	}

	checkQuestionTokenAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, someHaveQuestionToken bool, allHaveQuestionToken bool) {
		if someHaveQuestionToken != allHaveQuestionToken {
			canonicalHasQuestionToken := hasQuestionToken(getCanonicalOverload(overloads, implementation))
			forEach(overloads, func(o Declaration) {
				deviation := hasQuestionToken(o) != canonicalHasQuestionToken
				if deviation {
					tc.error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required)
				}
			})
		}
	}

	var flagsToCheck ModifierFlags = ModifierFlagsExport | ModifierFlagsAmbient | ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAbstract
	var someNodeFlags ModifierFlags = ModifierFlagsNone
	allNodeFlags := flagsToCheck
	someHaveQuestionToken := false
	allHaveQuestionToken := true
	hasOverloads := false
	var bodyDeclaration *FunctionLikeDeclaration
	var lastSeenNonAmbientDeclaration *FunctionLikeDeclaration
	var previousDeclaration *SignatureDeclaration

	declarations := symbol.declarations
	isConstructor := (symbol.flags & SymbolFlagsConstructor) != 0

	reportImplementationExpectedError := func(node SignatureDeclaration) {
		if node.name && nodeIsMissing(node.name) {
			return
		}

		seen := false
		subsequentNode := forEachChild(node.parent, func(c Node) Node {
			if seen {
				return c
			} else {
				seen = c == node
			}
		})
		// We may be here because of some extra nodes between overloads that could not be parsed into a valid node.
		// In this case the subsequent node is not really consecutive (.pos !== node.end), and we must ignore it here.
		if subsequentNode && subsequentNode.pos == node.end {
			if subsequentNode.kind == node.kind {
				var errorNode Node = (subsequentNode /* as FunctionLikeDeclaration */).name || subsequentNode
				subsequentName := (subsequentNode /* as FunctionLikeDeclaration */).name
				if node.name && subsequentName && (isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText == subsequentName.escapedText || isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && tc.isTypeIdenticalTo(tc.checkComputedPropertyName(node.name), tc.checkComputedPropertyName(subsequentName)) || isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) == getEscapedTextOfIdentifierOrLiteral(subsequentName)) {
					reportError := (node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature) && isStatic(node) != isStatic(subsequentNode)
					// we can get here in two cases
					// 1. mixed static and instance class members
					// 2. something with the same name was defined before the set of overloads that prevents them from merging
					// here we'll report error only for the first case since for second we should already report error in binder
					if reportError {
						var diagnostic DiagnosticMessage
						if isStatic(node) {
							diagnostic = Diagnostics.Function_overload_must_be_static
						} else {
							diagnostic = Diagnostics.Function_overload_must_not_be_static
						}
						tc.error(errorNode, diagnostic)
					}
					return
				}
				if nodeIsPresent((subsequentNode /* as FunctionLikeDeclaration */).body) {
					tc.error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name))
					return
				}
			}
		}
		var errorNode Node = node.name || node
		if isConstructor {
			tc.error(errorNode, Diagnostics.Constructor_implementation_is_missing)
		} else {
			// Report different errors regarding non-consecutive blocks of declarations depending on whether
			// the node in question is abstract.
			if hasSyntacticModifier(node, ModifierFlagsAbstract) {
				tc.error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive)
			} else {
				tc.error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration)
			}
		}
	}

	duplicateFunctionDeclaration := false
	multipleConstructorImplementation := false
	hasNonAmbientClass := false
	functionDeclarations := []never{} /* as Declaration[] */
	if declarations {
		for _, current := range declarations {
			node := current /* as SignatureDeclaration | ClassDeclaration | ClassExpression */
			inAmbientContext := node.flags & NodeFlagsAmbient
			inAmbientContextOrInterface := node.parent && (node.parent.kind == SyntaxKindInterfaceDeclaration || node.parent.kind == SyntaxKindTypeLiteral) || inAmbientContext
			if inAmbientContextOrInterface {
				// check if declarations are consecutive only if they are non-ambient
				// 1. ambient declarations can be interleaved
				// i.e. this is legal
				//     declare function foo();
				//     declare function bar();
				//     declare function foo();
				// 2. mixing ambient and non-ambient declarations is a separate error that will be reported - do not want to report an extra one
				previousDeclaration = nil
			}

			if (node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression) && !inAmbientContext {
				hasNonAmbientClass = true
			}

			if node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindConstructor {
				functionDeclarations.push(node)
				currentNodeFlags := tc.getEffectiveDeclarationFlags(node, flagsToCheck)
				someNodeFlags |= currentNodeFlags
				allNodeFlags &= currentNodeFlags
				someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node)
				allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node)
				bodyIsPresent := nodeIsPresent((node /* as FunctionLikeDeclaration */).body)

				if bodyIsPresent && bodyDeclaration {
					if isConstructor {
						multipleConstructorImplementation = true
					} else {
						duplicateFunctionDeclaration = true
					}
				} else if previousDeclaration. /* ? */ parent == node.parent && previousDeclaration.end != node.pos {
					reportImplementationExpectedError(previousDeclaration)
				}

				if bodyIsPresent {
					if !bodyDeclaration {
						bodyDeclaration = node /* as FunctionLikeDeclaration */
					}
				} else {
					hasOverloads = true
				}

				previousDeclaration = node

				if !inAmbientContextOrInterface {
					lastSeenNonAmbientDeclaration = node /* as FunctionLikeDeclaration */
				}
			}
			if isInJSFile(current) && isFunctionLike(current) && current.jsDoc {
				hasOverloads = length(getJSDocOverloadTags(current)) > 0
			}
		}
	}

	if multipleConstructorImplementation {
		forEach(functionDeclarations, func(declaration Declaration) {
			tc.error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed)
		})
	}

	if duplicateFunctionDeclaration {
		forEach(functionDeclarations, func(declaration Declaration) {
			tc.error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation)
		})
	}

	if hasNonAmbientClass && !isConstructor && symbol.flags&SymbolFlagsFunction && declarations {
		relatedDiagnostics := filter(declarations, func(d Declaration) bool {
			return d.kind == SyntaxKindClassDeclaration
		}).map_(func(d Declaration) DiagnosticWithLocation {
			return createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class)
		})

		forEach(declarations, func(declaration Declaration) {
			var diagnostic *DiagnosticMessage
			switch {
			case declaration.kind == SyntaxKindClassDeclaration:
				diagnostic = Diagnostics.Class_declaration_cannot_implement_overload_list_for_0
			case declaration.kind == SyntaxKindFunctionDeclaration:
				diagnostic = Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient
			default:
				diagnostic = nil
			}
			if diagnostic {
				addRelatedInfo(tc.error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)), relatedDiagnostics...)
			}
		})
	}

	// Abstract methods can't have an implementation -- in particular, they don't need one.
	if lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlagsAbstract) && !lastSeenNonAmbientDeclaration.questionToken {
		reportImplementationExpectedError(lastSeenNonAmbientDeclaration)
	}

	if hasOverloads {
		if declarations {
			checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags)
			checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken)
		}

		if bodyDeclaration {
			signatures := tc.getSignaturesOfSymbol(symbol)
			bodySignature := tc.getSignatureFromDeclaration(bodyDeclaration)
			for _, signature := range signatures {
				if !tc.isImplementationCompatibleWithOverload(bodySignature, signature) {
					var errorNode * /* TODO(TS-TO-GO) inferred type SignatureDeclaration | Identifier */ any
					if signature.declaration && isJSDocSignature(signature.declaration) {
						errorNode = (signature.declaration.parent /* as JSDocOverloadTag | JSDocCallbackTag */).tagName
					} else {
						errorNode = signature.declaration
					}
					addRelatedInfo(tc.error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here))
					break
				}
			}
		}
	}
}

func (tc *TypeChecker) checkExportsOnMergedDeclarations(node Declaration) {
	tc.addLazyDiagnostic(func() {
		return tc.checkExportsOnMergedDeclarationsWorker(node)
	})
}

func (tc *TypeChecker) checkExportsOnMergedDeclarationsWorker(node Declaration) {
	// if localSymbol is defined on node then node itself is exported - check is required
	symbol := node.localSymbol
	if !symbol {
		// local symbol is undefined => this declaration is non-exported.
		// however symbol might contain other declarations that are exported
		symbol = tc.getSymbolOfDeclaration(node)
		if !symbol.exportSymbol {
			// this is a pure local symbol (all declarations are non-exported) - no need to check anything
			return
		}
	}

	// run the check only for the first declaration in the list
	if getDeclarationOfKind(symbol, node.kind) != node {
		return
	}

	exportedDeclarationSpaces := DeclarationSpacesNone
	nonExportedDeclarationSpaces := DeclarationSpacesNone
	defaultExportedDeclarationSpaces := DeclarationSpacesNone
	for _, d := range symbol.declarations {
		declarationSpaces := getDeclarationSpaces(d)
		effectiveDeclarationFlags := tc.getEffectiveDeclarationFlags(d, ModifierFlagsExport|ModifierFlagsDefault)

		if effectiveDeclarationFlags & ModifierFlagsExport {
			if effectiveDeclarationFlags & ModifierFlagsDefault {
				defaultExportedDeclarationSpaces |= declarationSpaces
			} else {
				exportedDeclarationSpaces |= declarationSpaces
			}
		} else {
			nonExportedDeclarationSpaces |= declarationSpaces
		}
	}

	// Spaces for anything not declared a 'default export'.
	nonDefaultExportedDeclarationSpaces := exportedDeclarationSpaces | nonExportedDeclarationSpaces

	commonDeclarationSpacesForExportsAndLocals := exportedDeclarationSpaces & nonExportedDeclarationSpaces
	commonDeclarationSpacesForDefaultAndNonDefault := defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces

	if commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault {
		// declaration spaces for exported and non-exported declarations intersect
		for _, d := range symbol.declarations {
			declarationSpaces := getDeclarationSpaces(d)

			name := getNameOfDeclaration(d)
			// Only error on the declarations that contributed to the intersecting spaces.
			if declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault {
				tc.error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name))
			} else if declarationSpaces & commonDeclarationSpacesForExportsAndLocals {
				tc.error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name))
			}
		}
	}

	getDeclarationSpaces := func(decl Declaration) DeclarationSpaces {
		d := decl /* as Node */
		switch d.kind {
		case SyntaxKindInterfaceDeclaration,
			SyntaxKindTypeAliasDeclaration,
			SyntaxKindJSDocTypedefTag,
			SyntaxKindJSDocCallbackTag,
			SyntaxKindJSDocEnumTag:
			return DeclarationSpacesExportType
		case SyntaxKindModuleDeclaration:
			if isAmbientModule(d /* as ModuleDeclaration */) || getModuleInstanceState(d /* as ModuleDeclaration */) != ModuleInstanceStateNonInstantiated {
				return DeclarationSpacesExportNamespace | DeclarationSpacesExportValue
			} else {
				return DeclarationSpacesExportNamespace
			}
		case SyntaxKindClassDeclaration,
			SyntaxKindEnumDeclaration,
			SyntaxKindEnumMember:
			return DeclarationSpacesExportType | DeclarationSpacesExportValue
		case SyntaxKindSourceFile:
			return DeclarationSpacesExportType | DeclarationSpacesExportValue | DeclarationSpacesExportNamespace
		case SyntaxKindExportAssignment,
			SyntaxKindBinaryExpression:
			node := d /* as ExportAssignment | BinaryExpression */
			var expression Expression
			if isExportAssignment(node) {
				expression = node.expression
			} else {
				expression = node.right
			}
			if !isEntityNameExpression(expression) {
				return DeclarationSpacesExportValue
			}
			d = expression
			fallthrough
		case SyntaxKindImportEqualsDeclaration,
			SyntaxKindNamespaceImport,
			SyntaxKindImportClause:
			result := DeclarationSpacesNone
			target := tc.resolveAlias(tc.getSymbolOfDeclaration(d /* as ImportEqualsDeclaration | NamespaceImport | ImportClause | ExportAssignment | BinaryExpression */))
			forEach(target.declarations, func(d Declaration) {
				result |= getDeclarationSpaces(d)
			})
			return result
		case SyntaxKindVariableDeclaration,
			SyntaxKindBindingElement,
			SyntaxKindFunctionDeclaration,
			SyntaxKindImportSpecifier,
			SyntaxKindIdentifier:
			return DeclarationSpacesExportValue
		case SyntaxKindMethodSignature,
			SyntaxKindPropertySignature:
			return DeclarationSpacesExportType
		default:
			return Debug.failBadSyntaxKind(d)
		}
	}

}

func (tc *TypeChecker) getAwaitedTypeOfPromise(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
	promisedType := tc.getPromisedTypeOfPromise(type_, errorNode)
	return promisedType && tc.getAwaitedType(promisedType, errorNode, diagnosticMessage, args...)
}

/**
 * Gets the "promised type" of a promise.
 * @param type The type of the promise.
 * @remarks The "promised type" of a type is the type of the "value" parameter of the "onfulfilled" callback.
 */

func (tc *TypeChecker) getPromisedTypeOfPromise(type_ Type, errorNode Node, thisTypeForErrorOut /* TODO(TS-TO-GO) TypeNode TypeLiteral: { value?: Type; } */ any) Type {
	//
	//  { // type
	//      then( // thenFunction
	//          onfulfilled: ( // onfulfilledParameterType
	//              value: T // valueParameterType
	//          ) => any
	//      ): any;
	//  }
	//

	if tc.isTypeAny(type_) {
		return nil
	}

	typeAsPromise := type_ /* as PromiseOrAwaitableType */
	if typeAsPromise.promisedTypeOfPromise {
		return typeAsPromise.promisedTypeOfPromise
	}

	if tc.isReferenceToType(type_, tc.getGlobalPromiseType(false)) {
		typeAsPromise.promisedTypeOfPromise = tc.getTypeArguments(type_ /* as GenericType */)[0]
		return typeAsPromise.promisedTypeOfPromise
	}

	// primitives with a `{ then() }` won't be unwrapped/adopted.
	if tc.allTypesAssignableToKind(tc.getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
		return nil
	}

	thenFunction := tc.getTypeOfPropertyOfType(type_, "then" /* as __String */)
	// TODO: GH#18217
	if tc.isTypeAny(thenFunction) {
		return nil
	}

	var thenSignatures []Signature
	if thenFunction {
		thenSignatures = tc.getSignaturesOfType(thenFunction, SignatureKindCall)
	} else {
		thenSignatures = emptyArray
	}
	if thenSignatures.length == 0 {
		if errorNode {
			tc.error(errorNode, Diagnostics.A_promise_must_have_a_then_method)
		}
		return nil
	}

	var thisTypeForError Type
	var candidates *[]Signature
	for _, thenSignature := range thenSignatures {
		thisType := tc.getThisTypeOfSignature(thenSignature)
		if thisType && thisType != tc.voidType && !tc.isTypeRelatedTo(type_, thisType, tc.subtypeRelation) {
			thisTypeForError = thisType
		} else {
			candidates = append(candidates, thenSignature)
		}
	}

	if !candidates {
		Debug.assertIsDefined(thisTypeForError)
		if thisTypeForErrorOut {
			thisTypeForErrorOut.value = thisTypeForError
		}
		if errorNode {
			tc.error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, tc.typeToString(type_), tc.typeToString(thisTypeForError))
		}
		return nil
	}

	onfulfilledParameterType := tc.getTypeWithFacts(tc.getUnionType(map_(candidates, tc.getTypeOfFirstParameterOfSignature)), TypeFactsNEUndefinedOrNull)
	if tc.isTypeAny(onfulfilledParameterType) {
		return nil
	}

	onfulfilledParameterSignatures := tc.getSignaturesOfType(onfulfilledParameterType, SignatureKindCall)
	if onfulfilledParameterSignatures.length == 0 {
		if errorNode {
			tc.error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback)
		}
		return nil
	}

	typeAsPromise.promisedTypeOfPromise = tc.getUnionType(map_(onfulfilledParameterSignatures, tc.getTypeOfFirstParameterOfSignature), UnionReductionSubtype)
	return typeAsPromise.promisedTypeOfPromise
}

/**
 * Gets the "awaited type" of a type.
 * @param type The type to await.
 * @param withAlias When `true`, wraps the "awaited type" in `Awaited<T>` if needed.
 * @remarks The "awaited type" of an expression is its "promised type" if the expression is a
 * Promise-like type; otherwise, it is the type of the expression. This is used to reflect
 * The runtime behavior of the `await` keyword.
 */

func (tc *TypeChecker) checkAwaitedType(type_ Type, withAlias bool, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
	var awaitedType Type
	if withAlias {
		awaitedType = tc.getAwaitedType(type_, errorNode, diagnosticMessage, args...)
	} else {
		awaitedType = tc.getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage, args...)
	}
	return awaitedType || tc.errorType
}

/**
 * Determines whether a type is an object with a callable `then` member.
 */

func (tc *TypeChecker) isThenableType(type_ Type) bool {
	if tc.allTypesAssignableToKind(tc.getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
		// primitive types cannot be considered "thenable" since they are not objects.
		return false
	}

	thenFunction := tc.getTypeOfPropertyOfType(type_, "then" /* as __String */)
	return !!thenFunction && tc.getSignaturesOfType(tc.getTypeWithFacts(thenFunction, TypeFactsNEUndefinedOrNull), SignatureKindCall).length > 0
}

func (tc *TypeChecker) isAwaitedTypeInstantiation(type_ Type) /* TODO(TS-TO-GO) TypeNode TypePredicate: type is AwaitedTypeInstantiation */ any {
	if type_.flags & TypeFlagsConditional {
		awaitedSymbol := tc.getGlobalAwaitedSymbol(false)
		return !!awaitedSymbol && type_.aliasSymbol == awaitedSymbol && type_.aliasTypeArguments. /* ? */ length == 1
	}
	return false
}

/**
 * For a generic `Awaited<T>`, gets `T`.
 */

func (tc *TypeChecker) unwrapAwaitedType(type_ Type) Type {
	switch {
	case type_.flags & TypeFlagsUnion:
		return tc.mapType(type_, tc.unwrapAwaitedType)
	case tc.isAwaitedTypeInstantiation(type_):
		return type_.aliasTypeArguments[0]
	default:
		return type_
	}
}

func (tc *TypeChecker) isAwaitedTypeNeeded(type_ Type) bool {
	// If this is already an `Awaited<T>`, we shouldn't wrap it. This helps to avoid `Awaited<Awaited<T>>` in higher-order.
	if tc.isTypeAny(type_) || tc.isAwaitedTypeInstantiation(type_) {
		return false
	}

	// We only need `Awaited<T>` if `T` contains possibly non-primitive types.
	if tc.isGenericObjectType(type_) {
		baseConstraint := tc.getBaseConstraintOfType(type_)
		// We only need `Awaited<T>` if `T` is a type variable that has no base constraint, or the base constraint of `T` is `any`, `unknown`, `{}`, `object`,
		// or is promise-like.
		if __COND__(baseConstraint, baseConstraint.flags&TypeFlagsAnyOrUnknown || tc.isEmptyObjectType(baseConstraint) || tc.someType(baseConstraint, tc.isThenableType), tc.maybeTypeOfKind(type_, TypeFlagsTypeVariable)) {
			return true
		}
	}

	return false
}

func (tc *TypeChecker) tryCreateAwaitedType(type_ Type) Type {
	// Nothing to do if `Awaited<T>` doesn't exist
	awaitedSymbol := tc.getGlobalAwaitedSymbol(true)
	if awaitedSymbol {
		// Unwrap unions that may contain `Awaited<T>`, otherwise its possible to manufacture an `Awaited<Awaited<T> | U>` where
		// an `Awaited<T | U>` would suffice.
		return tc.getTypeAliasInstantiation(awaitedSymbol, []Type{tc.unwrapAwaitedType(type_)})
	}

	return nil
}

func (tc *TypeChecker) createAwaitedTypeIfNeeded(type_ Type) Type {
	// We wrap type `T` in `Awaited<T>` based on the following conditions:
	// - `T` is not already an `Awaited<U>`, and
	// - `T` is generic, and
	// - One of the following applies:
	//   - `T` has no base constraint, or
	//   - The base constraint of `T` is `any`, `unknown`, `object`, or `{}`, or
	//   - The base constraint of `T` is an object type with a callable `then` method.

	if tc.isAwaitedTypeNeeded(type_) {
		return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: tryCreateAwaitedType(type) ?? type */ TODO
	}

	Debug.assert(tc.isAwaitedTypeInstantiation(type_) || tc.getPromisedTypeOfPromise(type_) == nil, "type provided should not be a non-generic 'promise'-like.")
	return type_
}

/**
 * Gets the "awaited type" of a type.
 *
 * The "awaited type" of an expression is its "promised type" if the expression is a
 * Promise-like type; otherwise, it is the type of the expression. If the "promised
 * type" is itself a Promise-like, the "promised type" is recursively unwrapped until a
 * non-promise type is found.
 *
 * This is used to reflect the runtime behavior of the `await` keyword.
 */

func (tc *TypeChecker) getAwaitedType(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
	awaitedType := tc.getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage, args...)
	return awaitedType && tc.createAwaitedTypeIfNeeded(awaitedType)
}

/**
 * Gets the "awaited type" of a type without introducing an `Awaited<T>` wrapper.
 *
 * @see {@link getAwaitedType}
 */

func (tc *TypeChecker) getAwaitedTypeNoAlias(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
	if tc.isTypeAny(type_) {
		return type_
	}

	// If this is already an `Awaited<T>`, just return it. This avoids `Awaited<Awaited<T>>` in higher-order
	if tc.isAwaitedTypeInstantiation(type_) {
		return type_
	}

	// If we've already cached an awaited type, return a possible `Awaited<T>` for it.
	typeAsAwaitable := type_ /* as PromiseOrAwaitableType */
	if typeAsAwaitable.awaitedTypeOfType {
		return typeAsAwaitable.awaitedTypeOfType
	}

	// For a union, get a union of the awaited types of each constituent.
	if type_.flags & TypeFlagsUnion {
		if tc.awaitedTypeStack.lastIndexOf(type_.id) >= 0 {
			if errorNode {
				tc.error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
			}
			return nil
		}

		var mapper * /* TODO(TS-TO-GO) inferred type (type: Type, errorNode?: Node, diagnosticMessage?: DiagnosticMessage, ...args: DiagnosticArguments) => Type */ any
		if errorNode {
			mapper = func(constituentType Type) Type {
				return tc.getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, args...)
			}
		} else {
			mapper = tc.getAwaitedTypeNoAlias
		}

		tc.awaitedTypeStack.push(type_.id)
		mapped := tc.mapType(type_, mapper)
		tc.awaitedTypeStack.pop()

		typeAsAwaitable.awaitedTypeOfType = mapped
		return typeAsAwaitable.awaitedTypeOfType
	}

	// If `type` is generic and should be wrapped in `Awaited<T>`, return it.
	if tc.isAwaitedTypeNeeded(type_) {
		typeAsAwaitable.awaitedTypeOfType = type_
		return typeAsAwaitable.awaitedTypeOfType
	}

	var thisTypeForErrorOut /* TODO(TS-TO-GO) TypeNode TypeLiteral: { value: Type | undefined; } */ any = map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"value": nil,
	}
	promisedType := tc.getPromisedTypeOfPromise(type_ /*errorNode*/, nil, thisTypeForErrorOut)
	if promisedType {
		if type_.id == promisedType.id || tc.awaitedTypeStack.lastIndexOf(promisedType.id) >= 0 {
			// Verify that we don't have a bad actor in the form of a promise whose
			// promised type is the same as the promise type, or a mutually recursive
			// promise. If so, we return undefined as we cannot guess the shape. If this
			// were the actual case in the JavaScript, this Promise would never resolve.
			//
			// An example of a bad actor with a singly-recursive promise type might
			// be:
			//
			//  interface BadPromise {
			//      then(
			//          onfulfilled: (value: BadPromise) => any,
			//          onrejected: (error: any) => any): BadPromise;
			//  }
			//
			// The above interface will pass the PromiseLike check, and return a
			// promised type of `BadPromise`. Since this is a self reference, we
			// don't want to keep recursing ad infinitum.
			//
			// An example of a bad actor in the form of a mutually-recursive
			// promise type might be:
			//
			//  interface BadPromiseA {
			//      then(
			//          onfulfilled: (value: BadPromiseB) => any,
			//          onrejected: (error: any) => any): BadPromiseB;
			//  }
			//
			//  interface BadPromiseB {
			//      then(
			//          onfulfilled: (value: BadPromiseA) => any,
			//          onrejected: (error: any) => any): BadPromiseA;
			//  }
			//
			if errorNode {
				tc.error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
			}
			return nil
		}

		// Keep track of the type we're about to unwrap to avoid bad recursive promise types.
		// See the comments above for more information.
		tc.awaitedTypeStack.push(type_.id)
		awaitedType := tc.getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage, args...)
		tc.awaitedTypeStack.pop()

		if !awaitedType {
			return nil
		}

		typeAsAwaitable.awaitedTypeOfType = awaitedType
		return typeAsAwaitable.awaitedTypeOfType
	}

	// The type was not a promise, so it could not be unwrapped any further.
	// As long as the type does not have a callable "then" property, it is
	// safe to return the type; otherwise, an error is reported and we return
	// undefined.
	//
	// An example of a non-promise "thenable" might be:
	//
	//  await { then(): void {} }
	//
	// The "thenable" does not match the minimal definition for a promise. When
	// a Promise/A+-compatible or ES6 promise tries to adopt this value, the promise
	// will never settle. We treat this as an error to help flag an early indicator
	// of a runtime problem. If the user wants to return this value from an async
	// function, they would need to wrap it in some other value. If they want it to
	// be treated as a promise, they can cast to <any>.
	if tc.isThenableType(type_) {
		if errorNode {
			Debug.assertIsDefined(diagnosticMessage)
			var chain *DiagnosticMessageChain
			if thisTypeForErrorOut.value {
				chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, tc.typeToString(type_), tc.typeToString(thisTypeForErrorOut.value))
			}
			chain = chainDiagnosticMessages(chain, diagnosticMessage, args...)
			tc.diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain))
		}
		return nil
	}

	typeAsAwaitable.awaitedTypeOfType = type_
	return typeAsAwaitable.awaitedTypeOfType
}

/**
 * Checks the return type of an async function to ensure it is a compatible
 * Promise implementation.
 *
 * This checks that an async function has a valid Promise-compatible return type.
 * An async function has a valid Promise-compatible return type if the resolved value
 * of the return type has a construct signature that takes in an `initializer` function
 * that in turn supplies a `resolve` function as one of its arguments and results in an
 * object with a callable `then` signature.
 *
 * @param node The signature to check
 */

func (tc *TypeChecker) checkAsyncFunctionReturnType(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode) {
	// As part of our emit for an async function, we will need to emit the entity name of
	// the return type annotation as an expression. To meet the necessary runtime semantics
	// for __awaiter, we must also check that the type of the declaration (e.g. the static
	// side or "constructor" of the promise type) is compatible `PromiseConstructorLike`.
	//
	// An example might be (from lib.es6.d.ts):
	//
	//  interface Promise<T> { ... }
	//  interface PromiseConstructor {
	//      new <T>(...): Promise<T>;
	//  }
	//  declare var Promise: PromiseConstructor;
	//
	// When an async function declares a return type annotation of `Promise<T>`, we
	// need to get the type of the `Promise` variable declaration above, which would
	// be `PromiseConstructor`.
	//
	// The same case applies to a class:
	//
	//  declare class Promise<T> {
	//      constructor(...);
	//      then<U>(...): Promise<U>;
	//  }
	//
	returnType := tc.getTypeFromTypeNode(returnTypeNode)
	if tc.languageVersion >= ScriptTargetES2015 {
		if tc.isErrorType(returnType) {
			return
		}
		globalPromiseType := tc.getGlobalPromiseType(true)
		if globalPromiseType != tc.emptyGenericType && !tc.isReferenceToType(returnType, globalPromiseType) {
			// The promise type was not a valid type reference to the global promise type, so we
			// report an error and return the unknown type.
			reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, tc.typeToString(tc.getAwaitedTypeNoAlias(returnType) || tc.voidType))
			return
		}
	} else {
		// Always mark the type node as referenced if it points to a value
		tc.markLinkedReferences(node, ReferenceHintAsyncFunction)
		if tc.isErrorType(returnType) {
			return
		}

		promiseConstructorName := getEntityNameFromTypeNode(returnTypeNode)
		if promiseConstructorName == nil {
			reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, tc.typeToString(returnType))
			return
		}

		promiseConstructorSymbol := tc.resolveEntityName(promiseConstructorName, SymbolFlagsValue /*ignoreErrors*/, true)
		var promiseConstructorType Type
		if promiseConstructorSymbol {
			promiseConstructorType = tc.getTypeOfSymbol(promiseConstructorSymbol)
		} else {
			promiseConstructorType = tc.errorType
		}
		if tc.isErrorType(promiseConstructorType) {
			if promiseConstructorName.kind == SyntaxKindIdentifier && promiseConstructorName.escapedText == "Promise" && tc.getTargetType(returnType) == tc.getGlobalPromiseType(false) {
				tc.error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option)
			} else {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
			}
			return
		}

		globalPromiseConstructorLikeType := tc.getGlobalPromiseConstructorLikeType(true)
		if globalPromiseConstructorLikeType == tc.emptyObjectType {
			// If we couldn't resolve the global PromiseConstructorLike type we cannot verify
			// compatibility with __awaiter.
			reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
			return
		}

		headMessage := Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value
		errorInfo := func() *DiagnosticMessageChain {
			if returnTypeNode == returnTypeErrorLocation {
				return nil
			} else {
				return chainDiagnosticMessages(nil, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type)
			}
		}
		if !tc.checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo) {
			return
		}

		// Verify there is no local declaration that could collide with the promise constructor.
		rootName := promiseConstructorName && getFirstIdentifier(promiseConstructorName)
		collidingSymbol := tc.getSymbol(node.locals, rootName.escapedText, SymbolFlagsValue)
		if collidingSymbol {
			tc.error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName))
			return
		}
	}

	tc.checkAwaitedType(returnType /*withAlias*/, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)

	reportErrorForInvalidReturnType := func(message DiagnosticMessage, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode, typeName string) {
		if returnTypeNode == returnTypeErrorLocation {
			tc.error(returnTypeErrorLocation, message, typeName)
		} else {
			diag := tc.error(returnTypeErrorLocation, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type)
			addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName))
		}
	}

}

func (tc *TypeChecker) checkGrammarDecorator(decorator Decorator) bool {
	sourceFile := getSourceFileOfNode(decorator)
	if !tc.hasParseDiagnostics(sourceFile) {
		var node Expression = decorator.expression

		// DecoratorParenthesizedExpression :
		//   `(` Expression `)`

		if isParenthesizedExpression(node) {
			return false
		}

		canHaveCallExpression := true
		var errorNode Node
		for true {
			// Allow TS syntax such as non-null assertions and instantiation expressions
			if isExpressionWithTypeArguments(node) || isNonNullExpression(node) {
				node = node.expression
				continue
			}

			// DecoratorCallExpression :
			//   DecoratorMemberExpression Arguments

			if isCallExpression(node) {
				if !canHaveCallExpression {
					errorNode = node
				}
				if node.questionDotToken {
					// Even if we already have an error node, error at the `?.` token since it appears earlier.
					errorNode = node.questionDotToken
				}
				node = node.expression
				canHaveCallExpression = false
				continue
			}

			// DecoratorMemberExpression :
			//   IdentifierReference
			//   DecoratorMemberExpression `.` IdentifierName
			//   DecoratorMemberExpression `.` PrivateIdentifier

			if isPropertyAccessExpression(node) {
				if node.questionDotToken {
					// Even if we already have an error node, error at the `?.` token since it appears earlier.
					errorNode = node.questionDotToken
				}
				node = node.expression
				canHaveCallExpression = false
				continue
			}

			if !isIdentifier(node) {
				// Even if we already have an error node, error at this node since it appears earlier.
				errorNode = node
			}

			break
		}

		if errorNode {
			addRelatedInfo(tc.error(decorator.expression, Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator), createDiagnosticForNode(errorNode, Diagnostics.Invalid_syntax_in_decorator))
			return true
		}
	}

	return false
}

/** Check a decorator */

func (tc *TypeChecker) checkDecorator(node Decorator) {
	tc.checkGrammarDecorator(node)

	signature := tc.getResolvedSignature(node)
	tc.checkDeprecatedSignature(signature, node)
	returnType := tc.getReturnTypeOfSignature(signature)
	if returnType.flags & TypeFlagsAny {
		return
	}

	// if we fail to get a signature and return type here, we will have already reported a grammar error in `checkDecorators`.
	decoratorSignature := tc.getDecoratorCallSignature(node)
	if !decoratorSignature. /* ? */ resolvedReturnType {
		return
	}

	var headMessage DiagnosticMessage
	expectedReturnType := decoratorSignature.resolvedReturnType
	switch node.parent.kind {
	case SyntaxKindClassDeclaration,
		SyntaxKindClassExpression:
		headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
	case SyntaxKindPropertyDeclaration:
		if !tc.legacyDecorators {
			headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
			break
		}
		fallthrough
	case SyntaxKindParameter:
		headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any
	case SyntaxKindMethodDeclaration,
		SyntaxKindGetAccessor,
		SyntaxKindSetAccessor:
		headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1
	default:
		return Debug.failBadSyntaxKind(node.parent)
	}

	tc.checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage)
}

/**
 * Creates a synthetic `Signature` corresponding to a call signature.
 */

func (tc *TypeChecker) createCallSignature(typeParameters *[]TypeParameter, thisParameter Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number /*  = parameters.length */, flags SignatureFlags /*  = SignatureFlags.None */) Signature {
	decl := factory.createFunctionTypeNode(nil, emptyArray, factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
	return tc.createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
}

/**
 * Creates a synthetic `FunctionType`
 */

func (tc *TypeChecker) createFunctionType(typeParameters *[]TypeParameter, thisParameter Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number, flags SignatureFlags) ObjectType {
	signature := tc.createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
	return tc.getOrCreateTypeFromSignature(signature)
}

func (tc *TypeChecker) createGetterFunctionType(type_ Type) ObjectType {
	return tc.createFunctionType(nil /*thisParameter*/, nil, emptyArray, type_)
}

func (tc *TypeChecker) createSetterFunctionType(type_ Type) ObjectType {
	valueParam := tc.createParameter("value" /* as __String */, type_)
	return tc.createFunctionType(nil /*thisParameter*/, nil, []TransientSymbol{valueParam}, tc.voidType)
}

func (tc *TypeChecker) getEntityNameForDecoratorMetadata(node *TypeNode) *EntityName {
	if node {
		switch node.kind {
		case SyntaxKindIntersectionType,
			SyntaxKindUnionType:
			return tc.getEntityNameForDecoratorMetadataFromTypeList((node /* as UnionOrIntersectionTypeNode */).types)
		case SyntaxKindConditionalType:
			return tc.getEntityNameForDecoratorMetadataFromTypeList([]TypeNode{(node /* as ConditionalTypeNode */).trueType, (node /* as ConditionalTypeNode */).falseType})
		case SyntaxKindParenthesizedType,
			SyntaxKindNamedTupleMember:
			return tc.getEntityNameForDecoratorMetadata((node /* as ParenthesizedTypeNode */).type_)
		case SyntaxKindTypeReference:
			return (node /* as TypeReferenceNode */).typeName
		}
	}
}

func (tc *TypeChecker) getEntityNameForDecoratorMetadataFromTypeList(types []TypeNode) *EntityName {
	var commonEntityName *EntityName
	for _, typeNode := range types {
		for typeNode.kind == SyntaxKindParenthesizedType || typeNode.kind == SyntaxKindNamedTupleMember {
			typeNode = (typeNode /* as ParenthesizedTypeNode | NamedTupleMember */).type_
			// Skip parens if need be
		}
		if typeNode.kind == SyntaxKindNeverKeyword {
			continue
			// Always elide `never` from the union/intersection if possible
		}
		if !tc.strictNullChecks && (typeNode.kind == SyntaxKindLiteralType && (typeNode /* as LiteralTypeNode */).literal.kind == SyntaxKindNullKeyword || typeNode.kind == SyntaxKindUndefinedKeyword) {
			continue
			// Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks
		}
		individualEntityName := tc.getEntityNameForDecoratorMetadata(typeNode)
		if !individualEntityName {
			// Individual is something like string number
			// So it would be serialized to either that type or object
			// Safe to return here
			return nil
		}

		if commonEntityName {
			// Note this is in sync with the transformation that happens for type node.
			// Keep this in sync with serializeUnionOrIntersectionType
			// Verify if they refer to same entity and is identifier
			// return undefined if they dont match because we would emit object
			if !isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || commonEntityName.escapedText != individualEntityName.escapedText {
				return nil
			}
		} else {
			commonEntityName = individualEntityName
		}
	}
	return commonEntityName
}

func (tc *TypeChecker) getParameterTypeNodeForDecoratorCheck(node ParameterDeclaration) *TypeNode {
	typeNode := getEffectiveTypeAnnotationNode(node)
	if isRestParameter(node) {
		return getRestParameterElementType(typeNode)
	} else {
		return typeNode
	}
}

/** Check the decorators of a node */

func (tc *TypeChecker) checkDecorators(node Node) {
	// skip this check for nodes that cannot have decorators. These should have already had an error reported by
	// checkGrammarModifiers.
	if !canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(tc.legacyDecorators, node, node.parent, node.parent.parent) {
		return
	}

	firstDecorator := find(node.modifiers, isDecorator)
	if !firstDecorator {
		return
	}

	if tc.legacyDecorators {
		tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersDecorate)
		if node.kind == SyntaxKindParameter {
			tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersParam)
		}
	} else if tc.languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators {
		tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersESDecorateAndRunInitializers)
		if isClassDeclaration(node) {
			if !node.name {
				tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
			} else {
				member := tc.getFirstTransformableStaticClassElement(node)
				if member {
					tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				}
			}
		} else if !isClassExpression(node) {
			if isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node)) {
				tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
			}
			if isComputedPropertyName(node.name) {
				tc.checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersPropKey)
			}
		}
	}

	tc.markLinkedReferences(node, ReferenceHintDecorator)

	for _, modifier := range node.modifiers {
		if isDecorator(modifier) {
			tc.checkDecorator(modifier)
		}
	}
}

func (tc *TypeChecker) checkFunctionDeclaration(node FunctionDeclaration) {
	tc.addLazyDiagnostic(checkFunctionDeclarationDiagnostics)

	checkFunctionDeclarationDiagnostics := func() {
		tc.checkFunctionOrMethodDeclaration(node)
		tc.checkGrammarForGenerator(node)
		tc.checkCollisionsForDeclarationName(node, node.name)
	}

}

func (tc *TypeChecker) checkJSDocTypeAliasTag(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocTypedefTag | JSDocCallbackTag */ any) {
	if !node.typeExpression {
		// If the node had `@property` tags, `typeExpression` would have been set to the first property tag.
		tc.error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags)
	}

	if node.name {
		tc.checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
	}
	tc.checkSourceElement(node.typeExpression)
	tc.checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
}

func (tc *TypeChecker) checkJSDocTemplateTag(node JSDocTemplateTag) {
	tc.checkSourceElement(node.constraint)
	for _, tp := range node.typeParameters {
		tc.checkSourceElement(tp)
	}
}

func (tc *TypeChecker) checkJSDocTypeTag(node JSDocTypeTag) {
	tc.checkSourceElement(node.typeExpression)
}

func (tc *TypeChecker) checkJSDocSatisfiesTag(node JSDocSatisfiesTag) {
	tc.checkSourceElement(node.typeExpression)
	host := getEffectiveJSDocHost(node)
	if host {
		tags := getAllJSDocTags(host, isJSDocSatisfiesTag)
		if length(tags) > 1 {
			for i := 1; i < length(tags); i++ {
				tagName := tags[i].tagName
				tc.error(tagName, Diagnostics._0_tag_already_specified, idText(tagName))
			}
		}
	}
}

func (tc *TypeChecker) checkJSDocLinkLikeTag(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any) {
	if node.name {
		tc.resolveJSDocMemberName(node.name /*ignoreErrors*/, true)
	}
}

func (tc *TypeChecker) checkJSDocParameterTag(node JSDocParameterTag) {
	tc.checkSourceElement(node.typeExpression)
}

func (tc *TypeChecker) checkJSDocPropertyTag(node JSDocPropertyTag) {
	tc.checkSourceElement(node.typeExpression)
}

func (tc *TypeChecker) checkJSDocFunctionType(node JSDocFunctionType) {
	tc.addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny)
	tc.checkSignatureDeclaration(node)

	checkJSDocFunctionTypeImplicitAny := func() {
		if !node.type_ && !isJSDocConstructSignature(node) {
			tc.reportImplicitAny(node, tc.anyType)
		}
	}

}

func (tc *TypeChecker) checkJSDocThisTag(node JSDocThisTag) {
	host := getEffectiveJSDocHost(node)
	if host && isArrowFunction(host) {
		tc.error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
	}
}

func (tc *TypeChecker) checkJSDocImportTag(node JSDocImportTag) {
	tc.checkImportAttributes(node)
}

func (tc *TypeChecker) checkJSDocImplementsTag(node JSDocImplementsTag) {
	classLike := getEffectiveJSDocHost(node)
	if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
		tc.error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
	}
}

func (tc *TypeChecker) checkJSDocAugmentsTag(node JSDocAugmentsTag) {
	classLike := getEffectiveJSDocHost(node)
	if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
		tc.error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
		return
	}

	augmentsTags := getJSDocTags(classLike).filter(isJSDocAugmentsTag)
	Debug.assert(augmentsTags.length > 0)
	if augmentsTags.length > 1 {
		tc.error(augmentsTags[1], Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag)
	}

	name := tc.getIdentifierFromEntityNameExpression(node.class.expression)
	extend := getClassExtendsHeritageElement(classLike)
	if extend {
		className := tc.getIdentifierFromEntityNameExpression(extend.expression)
		if className && name.escapedText != className.escapedText {
			tc.error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className))
		}
	}
}

func (tc *TypeChecker) checkJSDocAccessibilityModifiers(node /* TODO(TS-TO-GO) TypeNode UnionType: JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */ any) {
	host := getJSDocHost(node)
	if host && isPrivateIdentifierClassElementDeclaration(host) {
		tc.error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
	}
}

/* OVERLOAD: function getIdentifierFromEntityNameExpression(node: Identifier | PropertyAccessExpression): Identifier | PrivateIdentifier; */
/* OVERLOAD: function getIdentifierFromEntityNameExpression(node: Expression): Identifier | PrivateIdentifier | undefined; */
func (tc *TypeChecker) getIdentifierFromEntityNameExpression(node Expression) /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | undefined */ any {
	switch node.kind {
	case SyntaxKindIdentifier:
		return node /* as Identifier */
	case SyntaxKindPropertyAccessExpression:
		return (node /* as PropertyAccessExpression */).name
	default:
		return nil
	}
}

func (tc *TypeChecker) checkFunctionOrMethodDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionDeclaration | MethodDeclaration | MethodSignature */ any) {
	tc.checkDecorators(node)
	tc.checkSignatureDeclaration(node)
	functionFlags := getFunctionFlags(node)

	// Do not use hasDynamicName here, because that returns false for well known symbols.
	// We want to perform checkComputedPropertyName for all computed properties, including
	// well known symbols.
	if node.name && node.name.kind == SyntaxKindComputedPropertyName {
		// This check will account for methods in class/interface declarations,
		// as well as accessors in classes/object literals
		tc.checkComputedPropertyName(node.name)
	}

	if tc.hasBindableName(node) {
		// first we want to check the local symbol that contain this declaration
		// - if node.localSymbol !== undefined - this is current declaration is exported and localSymbol points to the local symbol
		// - if node.localSymbol === undefined - this node is non-exported so we can just pick the result of getSymbolOfNode
		symbol := tc.getSymbolOfDeclaration(node)
		localSymbol := node.localSymbol || symbol

		// Since the javascript won't do semantic analysis like typescript,
		// if the javascript file comes before the typescript file and both contain same name functions,
		// checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
		firstDeclaration := localSymbol.declarations. /* ? */ find(func(declaration Declaration) bool {
			return declaration.kind == node.kind && !(declaration.flags & NodeFlagsJavaScriptFile)
		})

		// Only type check the symbol once
		if node == firstDeclaration {
			tc.checkFunctionOrConstructorSymbol(localSymbol)
		}

		if symbol.parent {
			// run check on export symbol to check that modifiers agree across all exported declarations
			tc.checkFunctionOrConstructorSymbol(symbol)
		}
	}

	var body *Block
	if node.kind == SyntaxKindMethodSignature {
		body = nil
	} else {
		body = node.body
	}
	tc.checkSourceElement(body)
	tc.checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, tc.getReturnTypeFromAnnotation(node))

	tc.addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics)

	// A js function declaration can have a @type tag instead of a return type node, but that type must have a call signature
	if isInJSFile(node) {
		typeTag := getJSDocTypeTag(node)
		if typeTag && typeTag.typeExpression && !tc.getContextualCallSignature(tc.getTypeFromTypeNode(typeTag.typeExpression), node) {
			tc.error(typeTag.typeExpression.type_, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature)
		}
	}

	checkFunctionOrMethodDeclarationDiagnostics := func() {
		if !getEffectiveReturnTypeNode(node) {
			// Report an implicit any error if there is no body, no explicit return type, and node is not a private method
			// in an ambient context
			if nodeIsMissing(body) && !tc.isPrivateWithinAmbient(node) {
				tc.reportImplicitAny(node, tc.anyType)
			}

			if functionFlags&FunctionFlagsGenerator && nodeIsPresent(body) {
				// A generator with a body and no type annotation can still cause errors. It can error if the
				// yielded values have no common supertype, or it can give an implicit any error if it has no
				// yielded values. The only way to trigger these errors is to try checking its return type.
				tc.getReturnTypeOfSignature(tc.getSignatureFromDeclaration(node))
			}
		}
	}

}

func (tc *TypeChecker) registerForUnusedIdentifiersCheck(node PotentiallyUnusedIdentifier) {
	tc.addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics)

	registerForUnusedIdentifiersCheckDiagnostics := func() {
		// May be in a call such as getTypeOfNode that happened to call this. But potentiallyUnusedIdentifiers is only defined in the scope of `checkSourceFile`.
		sourceFile := getSourceFileOfNode(node)
		potentiallyUnusedIdentifiers := tc.allPotentiallyUnusedIdentifiers.get(sourceFile.path)
		if !potentiallyUnusedIdentifiers {
			potentiallyUnusedIdentifiers = []never{}
			tc.allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers)
		}
		// TODO: GH#22580
		// Debug.assert(addToSeen(seenPotentiallyUnusedIdentifiers, getNodeId(node)), "Adding potentially-unused identifier twice");
		potentiallyUnusedIdentifiers.push(node)
	}

}

func (tc *TypeChecker) checkUnusedIdentifiers(potentiallyUnusedIdentifiers []PotentiallyUnusedIdentifier, addDiagnostic AddUnusedDiagnostic) {
	for _, node := range potentiallyUnusedIdentifiers {
		switch node.kind {
		case SyntaxKindClassDeclaration,
			SyntaxKindClassExpression:
			tc.checkUnusedClassMembers(node, addDiagnostic)
			tc.checkUnusedTypeParameters(node, addDiagnostic)
		case SyntaxKindSourceFile,
			SyntaxKindModuleDeclaration,
			SyntaxKindBlock,
			SyntaxKindCaseBlock,
			SyntaxKindForStatement,
			SyntaxKindForInStatement,
			SyntaxKindForOfStatement:
			tc.checkUnusedLocalsAndParameters(node, addDiagnostic)
		case SyntaxKindConstructor,
			SyntaxKindFunctionExpression,
			SyntaxKindFunctionDeclaration,
			SyntaxKindArrowFunction,
			SyntaxKindMethodDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			if node.body {
				tc.checkUnusedLocalsAndParameters(node, addDiagnostic)
			}
			tc.checkUnusedTypeParameters(node, addDiagnostic)
		case SyntaxKindMethodSignature,
			SyntaxKindCallSignature,
			SyntaxKindConstructSignature,
			SyntaxKindFunctionType,
			SyntaxKindConstructorType,
			SyntaxKindTypeAliasDeclaration,
			SyntaxKindInterfaceDeclaration:
			tc.checkUnusedTypeParameters(node, addDiagnostic)
		case SyntaxKindInferType:
			tc.checkUnusedInferTypeParameter(node, addDiagnostic)
		default:
			Debug.assertNever(node, "Node should not have been registered for unused identifiers check")
		}
	}
}

func (tc *TypeChecker) errorUnusedLocal(declaration Declaration, name string, addDiagnostic AddUnusedDiagnostic) {
	node := getNameOfDeclaration(declaration) || declaration
	var message DiagnosticMessage
	if isTypeDeclaration(declaration) {
		message = Diagnostics._0_is_declared_but_never_used
	} else {
		message = Diagnostics._0_is_declared_but_its_value_is_never_read
	}
	addDiagnostic(declaration, UnusedKindLocal, createDiagnosticForNode(node, message, name))
}

func (tc *TypeChecker) isIdentifierThatStartsWithUnderscore(node Node) bool {
	return isIdentifier(node) && idText(node).charCodeAt(0) == CharacterCodes_
}

func (tc *TypeChecker) checkUnusedClassMembers(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassDeclaration | ClassExpression */ any, addDiagnostic AddUnusedDiagnostic) {
	for _, member := range node.members {
		switch member.kind {
		case SyntaxKindMethodDeclaration,
			SyntaxKindPropertyDeclaration,
			SyntaxKindGetAccessor,
			SyntaxKindSetAccessor:
			if member.kind == SyntaxKindSetAccessor && member.symbol.flags&SymbolFlagsGetAccessor {
				// Already would have reported an error on the getter.
				break
			}
			symbol := tc.getSymbolOfDeclaration(member)
			if !symbol.isReferenced && (hasEffectiveModifier(member, ModifierFlagsPrivate) || isNamedDeclaration(member) && isPrivateIdentifier(member.name)) && !(member.flags & NodeFlagsAmbient) {
				addDiagnostic(member, UnusedKindLocal, createDiagnosticForNode(member.name, Diagnostics._0_is_declared_but_its_value_is_never_read, tc.symbolToString(symbol)))
			}
		case SyntaxKindConstructor:
			for _, parameter := range (member /* as ConstructorDeclaration */).parameters {
				if !parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlagsPrivate) {
					addDiagnostic(parameter, UnusedKindLocal, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)))
				}
			}
		case SyntaxKindIndexSignature,
			SyntaxKindSemicolonClassElement,
			SyntaxKindClassStaticBlockDeclaration:
		default:
			Debug.fail("Unexpected class member")
		}
	}
}

func (tc *TypeChecker) checkUnusedInferTypeParameter(node InferTypeNode, addDiagnostic AddUnusedDiagnostic) {
	TODO_IDENTIFIER := node
	if tc.isTypeParameterUnused(typeParameter) {
		addDiagnostic(node, UnusedKindParameter, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)))
	}
}

func (tc *TypeChecker) checkUnusedTypeParameters(node /* TODO(TS-TO-GO) TypeNode UnionType: ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration */ any, addDiagnostic AddUnusedDiagnostic) {
	// Only report errors on the last declaration for the type parameter container;
	// this ensures that all uses have been accounted for.
	declarations := tc.getSymbolOfDeclaration(node).declarations
	if !declarations || last(declarations) != node {
		return
	}

	typeParameters := getEffectiveTypeParameterDeclarations(node)
	seenParentsWithEveryUnused := NewSet[DeclarationWithTypeParameterChildren]()

	for _, typeParameter := range typeParameters {
		if !tc.isTypeParameterUnused(typeParameter) {
			continue
		}

		name := idText(typeParameter.name)
		TODO_IDENTIFIER := typeParameter
		if parent.kind != SyntaxKindInferType && parent.typeParameters.every(tc.isTypeParameterUnused) {
			if tryAddToSet(seenParentsWithEveryUnused, parent) {
				sourceFile := getSourceFileOfNode(parent)
				var range_ TextRange
				if isJSDocTemplateTag(parent) {
					range_ = rangeOfNode(parent)
				} else {
					range_ = rangeOfTypeParameters(sourceFile, parent.typeParameters)
				}
				only := parent.typeParameters.length == 1
				// TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
				var messageAndArg DiagnosticAndArguments
				if only {
					messageAndArg = []any{Diagnostics._0_is_declared_but_its_value_is_never_read, name}
				} else {
					messageAndArg = []any{Diagnostics.All_type_parameters_are_unused}
				}
				addDiagnostic(typeParameter, UnusedKindParameter, createFileDiagnostic(sourceFile, range_.pos, range_.end-range_.pos, messageAndArg...))
			}
		} else {
			// TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
			addDiagnostic(typeParameter, UnusedKindParameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name))
		}
	}
}

func (tc *TypeChecker) isTypeParameterUnused(typeParameter TypeParameterDeclaration) bool {
	return !(tc.getMergedSymbol(typeParameter.symbol).isReferenced & SymbolFlagsTypeParameter) && !tc.isIdentifierThatStartsWithUnderscore(typeParameter.name)
}

func (tc *TypeChecker) addToGroup(map_ Map[string /* TODO(TS-TO-GO) TypeNode TupleType: [K, V[]] */, any], key K, value V, getKey func(key K) /* TODO(TS-TO-GO) TypeNode UnionType: number | string */ any) {
	keyString := String(getKey(key))
	group := map_.get(keyString)
	if group {
		group[1].push(value)
	} else {
		map_.set(keyString, []any{key, []V{value}})
	}
}

func (tc *TypeChecker) tryGetRootParameterDeclaration(node Node) *ParameterDeclaration {
	return tryCast(getRootDeclaration(node), isParameter)
}

func (tc *TypeChecker) isValidUnusedLocalDeclaration(declaration Declaration) bool {
	if isBindingElement(declaration) {
		if isObjectBindingPattern(declaration.parent) {
			/**
			 * ignore starts with underscore names _
			 * const { a: _a } = { a: 1 }
			 */
			return !!(declaration.propertyName && tc.isIdentifierThatStartsWithUnderscore(declaration.name))
		}
		return tc.isIdentifierThatStartsWithUnderscore(declaration.name)
	}
	return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || tc.isImportedDeclaration(declaration)) && tc.isIdentifierThatStartsWithUnderscore(declaration.name)
}

func (tc *TypeChecker) checkUnusedLocalsAndParameters(nodeWithLocals HasLocals, addDiagnostic AddUnusedDiagnostic) {
	// Ideally we could use the ImportClause directly as a key, but must wait until we have full ES6 maps. So must store key along with value.
	unusedImports := NewMap[string /* TODO(TS-TO-GO) TypeNode TupleType: [ImportClause, ImportedDeclaration[]] */, any]()
	unusedDestructures := NewMap[string /* TODO(TS-TO-GO) TypeNode TupleType: [BindingPattern, BindingElement[]] */, any]()
	unusedVariables := NewMap[string /* TODO(TS-TO-GO) TypeNode TupleType: [VariableDeclarationList, VariableDeclaration[]] */, any]()
	nodeWithLocals.locals.forEach(func(local Symbol) {
		// If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.
		// If it's a type parameter merged with a parameter, check if the parameter-side is used.
		if __COND__(local.flags&SymbolFlagsTypeParameter, !(local.flags&SymbolFlagsVariable && !(local.isReferenced & SymbolFlagsVariable)), local.isReferenced || local.exportSymbol) {
			return
		}

		if local.declarations {
			for _, declaration := range local.declarations {
				if tc.isValidUnusedLocalDeclaration(declaration) {
					continue
				}

				if tc.isImportedDeclaration(declaration) {
					tc.addToGroup(unusedImports, tc.importClauseFromImported(declaration), declaration, getNodeId)
				} else if isBindingElement(declaration) && isObjectBindingPattern(declaration.parent) {
					// In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.
					lastElement := last(declaration.parent.elements)
					if declaration == lastElement || !last(declaration.parent.elements).dotDotDotToken {
						tc.addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
					}
				} else if isVariableDeclaration(declaration) {
					blockScopeKind := tc.getCombinedNodeFlagsCached(declaration) & NodeFlagsBlockScoped
					name := getNameOfDeclaration(declaration)
					if blockScopeKind != NodeFlagsUsing && blockScopeKind != NodeFlagsAwaitUsing || !name || !tc.isIdentifierThatStartsWithUnderscore(name) {
						tc.addToGroup(unusedVariables, declaration.parent, declaration, getNodeId)
					}
				} else {
					parameter := local.valueDeclaration && tc.tryGetRootParameterDeclaration(local.valueDeclaration)
					name := local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration)
					if parameter && name {
						if !isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !tc.isIdentifierThatStartsWithUnderscore(name) {
							if isBindingElement(declaration) && isArrayBindingPattern(declaration.parent) {
								tc.addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
							} else {
								addDiagnostic(parameter, UnusedKindParameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)))
							}
						}
					} else {
						tc.errorUnusedLocal(declaration, symbolName(local), addDiagnostic)
					}
				}
			}
		}
	})
	unusedImports.forEach(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [ImportClause, (ImportClause | NamespaceImport | ImportSpecifier)[]] */ any) {
		importDecl := importClause.parent
		nDeclarations := (__COND__(importClause.name, 1, 0)) + (__COND__(importClause.namedBindings, (__COND__(importClause.namedBindings.kind == SyntaxKindNamespaceImport, 1, importClause.namedBindings.elements.length)), 0))
		if nDeclarations == unuseds.length {
			addDiagnostic(importDecl, UnusedKindLocal, __COND__(unuseds.length == 1, createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name)), createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused)))
		} else {
			for _, unused := range unuseds {
				tc.errorUnusedLocal(unused, idText(unused.name), addDiagnostic)
			}
		}
	})
	unusedDestructures.forEach(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [BindingPattern, BindingElement[]] */ any) {
		var kind UnusedKind
		if tc.tryGetRootParameterDeclaration(bindingPattern.parent) {
			kind = UnusedKindParameter
		} else {
			kind = UnusedKindLocal
		}
		if bindingPattern.elements.length == bindingElements.length {
			if bindingElements.length == 1 && bindingPattern.parent.kind == SyntaxKindVariableDeclaration && bindingPattern.parent.parent.kind == SyntaxKindVariableDeclarationList {
				tc.addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId)
			} else {
				addDiagnostic(bindingPattern, kind, __COND__(bindingElements.length == 1, createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, tc.bindingNameText(first(bindingElements).name)), createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused)))
			}
		} else {
			for _, e := range bindingElements {
				addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, tc.bindingNameText(e.name)))
			}
		}
	})
	unusedVariables.forEach(func(TODO_IDENTIFIER /* TODO(TS-TO-GO) inferred type [VariableDeclarationList, VariableDeclaration[]] */ any) {
		if declarationList.declarations.length == declarations.length {
			addDiagnostic(declarationList, UnusedKindLocal, __COND__(declarations.length == 1, createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, tc.bindingNameText(first(declarations).name)), createDiagnosticForNode(__COND__(declarationList.parent.kind == SyntaxKindVariableStatement, declarationList.parent, declarationList), Diagnostics.All_variables_are_unused)))
		} else {
			for _, decl := range declarations {
				addDiagnostic(decl, UnusedKindLocal, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, tc.bindingNameText(decl.name)))
			}
		}
	})
}

func (tc *TypeChecker) checkPotentialUncheckedRenamedBindingElementsInTypes() {
	for _, node := range tc.potentialUnusedRenamedBindingElementsInTypes {
		if !tc.getSymbolOfDeclaration(node). /* ? */ isReferenced {
			wrappingDeclaration := walkUpBindingElementsAndPatterns(node)
			Debug.assert(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here")
			diagnostic := createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName))
			if !wrappingDeclaration.type_ {
				// entire parameter does not have type annotation, suggest adding an annotation
				addRelatedInfo(diagnostic, createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 0, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)))
			}
			tc.diagnostics.add(diagnostic)
		}
	}
}

func (tc *TypeChecker) bindingNameText(name BindingName) string {
	switch name.kind {
	case SyntaxKindIdentifier:
		return idText(name)
	case SyntaxKindArrayBindingPattern,
		SyntaxKindObjectBindingPattern:
		return tc.bindingNameText(cast(first(name.elements), isBindingElement).name)
	default:
		return Debug.assertNever(name)
	}
}

func (tc *TypeChecker) isImportedDeclaration(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is ImportedDeclaration */ any {
	return node.kind == SyntaxKindImportClause || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindNamespaceImport
}

func (tc *TypeChecker) importClauseFromImported(decl ImportedDeclaration) ImportClause {
	switch {
	case decl.kind == SyntaxKindImportClause:
		return decl
	case decl.kind == SyntaxKindNamespaceImport:
		return decl.parent
	default:
		return decl.parent.parent
	}
}

func (tc *TypeChecker) checkBlock(node Block) {
	// Grammar checking for SyntaxKind.Block
	if node.kind == SyntaxKindBlock {
		tc.checkGrammarStatementInAmbientContext(node)
	}
	if isFunctionOrModuleBlock(node) {
		saveFlowAnalysisDisabled := tc.flowAnalysisDisabled
		forEach(node.statements, tc.checkSourceElement)
		tc.flowAnalysisDisabled = saveFlowAnalysisDisabled
	} else {
		forEach(node.statements, tc.checkSourceElement)
	}
	if node.locals {
		tc.registerForUnusedIdentifiersCheck(node)
	}
}

func (tc *TypeChecker) checkCollisionWithArgumentsInGeneratedCode(node SignatureDeclaration) {
	// no rest parameters \ declaration context \ overload - no codegen impact
	if tc.languageVersion >= ScriptTargetES2015 || !hasRestParameter(node) || node.flags&NodeFlagsAmbient || nodeIsMissing((node /* as FunctionLikeDeclaration */).body) {
		return
	}

	forEach(node.parameters, func(p ParameterDeclaration) {
		if p.name && !isBindingPattern(p.name) && p.name.escapedText == tc.argumentsSymbol.escapedName {
			tc.errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters)
		}
	})
}

/**
 * Checks whether an {@link Identifier}, in the context of another {@link Node}, would collide with a runtime value
 * of {@link name} in an outer scope. This is used to check for collisions for downlevel transformations that
 * require names like `Object`, `Promise`, `Reflect`, `require`, `exports`, etc.
 */

func (tc *TypeChecker) needCollisionCheckForIdentifier(node Node, identifier *Identifier, name string) bool {
	if identifier. /* ? */ escapedText != name {
		return false
	}

	if node.kind == SyntaxKindPropertyDeclaration || node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor || node.kind == SyntaxKindPropertyAssignment {
		// it is ok to have member named '_super', '_this', `Promise`, etc. - member access is always qualified
		return false
	}

	if node.flags & NodeFlagsAmbient {
		// ambient context - no codegen impact
		return false
	}

	if isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node) {
		// type-only imports do not require collision checks against runtime values.
		if isTypeOnlyImportOrExportDeclaration(node) {
			return false
		}
	}

	root := getRootDeclaration(node)
	if isParameter(root) && nodeIsMissing((root.parent /* as FunctionLikeDeclaration */).body) {
		// just an overload - no codegen impact
		return false
	}

	return true
}

// this function will run after checking the source file so 'CaptureThis' is correct for all nodes
func (tc *TypeChecker) checkIfThisIsCapturedInEnclosingScope(node Node) {
	findAncestor(node, func(current Node) bool {
		if tc.getNodeCheckFlags(current) & NodeCheckFlagsCaptureThis {
			isDeclaration := node.kind != SyntaxKindIdentifier
			if isDeclaration {
				tc.error(getNameOfDeclaration(node /* as Declaration */), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference)
			} else {
				tc.error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference)
			}
			return true
		}
		return false
	})
}

func (tc *TypeChecker) checkIfNewTargetIsCapturedInEnclosingScope(node Node) {
	findAncestor(node, func(current Node) bool {
		if tc.getNodeCheckFlags(current) & NodeCheckFlagsCaptureNewTarget {
			isDeclaration := node.kind != SyntaxKindIdentifier
			if isDeclaration {
				tc.error(getNameOfDeclaration(node /* as Declaration */), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference)
			} else {
				tc.error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference)
			}
			return true
		}
		return false
	})
}

func (tc *TypeChecker) checkCollisionWithRequireExportsInGeneratedCode(node Node, name *Identifier) {
	// No need to check for require or exports for ES6 modules and later
	if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) >= ModuleKindES2015 {
		return
	}

	if !name || !tc.needCollisionCheckForIdentifier(node, name, "require") && !tc.needCollisionCheckForIdentifier(node, name, "exports") {
		return
	}

	// Uninstantiated modules shouldnt do this check
	if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
		return
	}

	// In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
	parent := tc.getDeclarationContainer(node)
	if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent /* as SourceFile */) {
		// If the declaration happens to be in external module, report error that require and exports are reserved keywords
		tc.errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name))
	}
}

func (tc *TypeChecker) checkCollisionWithGlobalPromiseInGeneratedCode(node Node, name *Identifier) {
	if !name || tc.languageVersion >= ScriptTargetES2017 || !tc.needCollisionCheckForIdentifier(node, name, "Promise") {
		return
	}

	// Uninstantiated modules shouldnt do this check
	if isModuleDeclaration(node) && getModuleInstanceState(node) != ModuleInstanceStateInstantiated {
		return
	}

	// In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
	parent := tc.getDeclarationContainer(node)
	if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent /* as SourceFile */) && parent.flags&NodeFlagsHasAsyncFunctions {
		// If the declaration happens to be in external module, report error that Promise is a reserved identifier.
		tc.errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name))
	}
}

func (tc *TypeChecker) recordPotentialCollisionWithWeakMapSetInGeneratedCode(node Node, name Identifier) {
	if tc.languageVersion <= ScriptTargetES2021 && (tc.needCollisionCheckForIdentifier(node, name, "WeakMap") || tc.needCollisionCheckForIdentifier(node, name, "WeakSet")) {
		tc.potentialWeakMapSetCollisions.push(node)
	}
}

func (tc *TypeChecker) checkWeakMapSetCollision(node Node) {
	enclosingBlockScope := getEnclosingBlockScopeContainer(node)
	if tc.getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlagsContainsClassWithPrivateIdentifiers {
		Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof node.name.escapedText */ TODO == "string", "The target of a WeakMap/WeakSet collision check should be an identifier")
		tc.errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText)
	}
}

func (tc *TypeChecker) recordPotentialCollisionWithReflectInGeneratedCode(node Node, name *Identifier) {
	if name && tc.languageVersion >= ScriptTargetES2015 && tc.languageVersion <= ScriptTargetES2021 && tc.needCollisionCheckForIdentifier(node, name, "Reflect") {
		tc.potentialReflectCollisions.push(node)
	}
}

func (tc *TypeChecker) checkReflectCollision(node Node) {
	hasCollision := false
	if isClassExpression(node) {
		// ClassExpression names don't contribute to their containers, but do matter for any of their block-scoped members.
		for _, member := range node.members {
			if tc.getNodeCheckFlags(member) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
				break
			}
		}
	} else if isFunctionExpression(node) {
		// FunctionExpression names don't contribute to their containers, but do matter for their contents
		if tc.getNodeCheckFlags(node) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
			hasCollision = true
		}
	} else {
		container := getEnclosingBlockScopeContainer(node)
		if container && tc.getNodeCheckFlags(container)&NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
			hasCollision = true
		}
	}
	if hasCollision {
		Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier")
		tc.errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect")
	}
}

func (tc *TypeChecker) checkCollisionsForDeclarationName(node Node, name *Identifier) {
	if !name {
		return
	}
	tc.checkCollisionWithRequireExportsInGeneratedCode(node, name)
	tc.checkCollisionWithGlobalPromiseInGeneratedCode(node, name)
	tc.recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name)
	tc.recordPotentialCollisionWithReflectInGeneratedCode(node, name)
	if isClassLike(node) {
		tc.checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0)
		if !(node.flags & NodeFlagsAmbient) {
			tc.checkClassNameCollisionWithObject(name)
		}
	} else if isEnumDeclaration(node) {
		tc.checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0)
	}
}

func (tc *TypeChecker) checkVarDeclaredNamesNotShadowed(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | BindingElement */ any) undefined {
	// - ScriptBody : StatementList
	// It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
	// also occurs in the VarDeclaredNames of StatementList.

	// - Block : { StatementList }
	// It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
	// also occurs in the VarDeclaredNames of StatementList.

	// Variable declarations are hoisted to the top of their function scope. They can shadow
	// block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
	// by the binder as the declaration scope is different.
	// A non-initialized declaration is a no-op as the block declaration will resolve before the var
	// declaration. the problem is if the declaration has an initializer. this will act as a write to the
	// block declared value. this is fine for let, but not const.
	// Only consider declarations with initializers, uninitialized const declarations will not
	// step on a let/const variable.
	// Do not consider const and const declarations, as duplicate block-scoped declarations
	// are handled by the binder.
	// We are only looking for const declarations that step on let\const declarations from a
	// different scope. e.g.:
	//      {
	//          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
	//          const x = 0; // symbol for this declaration will be 'symbol'
	//      }

	// skip block-scoped variables and parameters
	if (tc.getCombinedNodeFlagsCached(node)&NodeFlagsBlockScoped) != 0 || isPartOfParameterDeclaration(node) {
		return
	}

	// NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
	// so we'll always treat binding elements as initialized

	symbol := tc.getSymbolOfDeclaration(node)
	if symbol.flags & SymbolFlagsFunctionScopedVariable {
		if !isIdentifier(node.name) {
			return Debug.fail()
		}
		localDeclarationSymbol := tc.resolveName(node, node.name.escapedText, SymbolFlagsVariable /*nameNotFoundMessage*/, nil /*isUse*/, false)
		if localDeclarationSymbol && localDeclarationSymbol != symbol && localDeclarationSymbol.flags&SymbolFlagsBlockScopedVariable {
			if tc.getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlagsBlockScoped {
				varDeclList := getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKindVariableDeclarationList)
				var container Node
				if varDeclList.parent.kind == SyntaxKindVariableStatement && varDeclList.parent.parent {
					container = varDeclList.parent.parent
				} else {
					container = nil
				}

				// names of block-scoped and function scoped variables can collide only
				// if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
				namesShareScope := container && (container.kind == SyntaxKindBlock && isFunctionLike(container.parent) || container.kind == SyntaxKindModuleBlock || container.kind == SyntaxKindModuleDeclaration || container.kind == SyntaxKindSourceFile)

				// here we know that function scoped variable is "shadowed" by block scoped one
				// a var declatation can't hoist past a lexical declaration and it results in a SyntaxError at runtime
				if !namesShareScope {
					name := tc.symbolToString(localDeclarationSymbol)
					tc.error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name)
				}
			}
		}
	}
}

func (tc *TypeChecker) convertAutoToAny(type_ Type) Type {
	switch {
	case type_ == tc.autoType:
		return tc.anyType
	case type_ == tc.autoArrayType:
		return tc.anyArrayType
	default:
		return type_
	}
}

// Check variable, parameter, or property declaration
func (tc *TypeChecker) checkVariableLikeDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement */ any) {
	tc.checkDecorators(node)
	if !isBindingElement(node) {
		tc.checkSourceElement(node.type_)
	}

	// JSDoc `function(string, string): string` syntax results in parameters with no name
	if !node.name {
		return
	}

	// For a computed property, just check the initializer and exit
	// Do not use hasDynamicName here, because that returns false for well known symbols.
	// We want to perform checkComputedPropertyName for all computed properties, including
	// well known symbols.
	if node.name.kind == SyntaxKindComputedPropertyName {
		tc.checkComputedPropertyName(node.name)
		if hasOnlyExpressionInitializer(node) && node.initializer {
			tc.checkExpressionCached(node.initializer)
		}
	}

	if isBindingElement(node) {
		if node.propertyName && isIdentifier(node.name) && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) /* as FunctionLikeDeclaration */).body) {
			// type F = ({a: string}) => void;
			//               ^^^^^^
			// variable renaming in function type notation is confusing,
			// so we forbid it even if noUnusedLocals is not enabled
			tc.potentialUnusedRenamedBindingElementsInTypes.push(node)
			return
		}

		if isObjectBindingPattern(node.parent) && node.dotDotDotToken && tc.languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersRest)
		}
		// check computed properties inside property names of binding elements
		if node.propertyName && node.propertyName.kind == SyntaxKindComputedPropertyName {
			tc.checkComputedPropertyName(node.propertyName)
		}

		// check private/protected variable access
		parent := node.parent.parent
		var parentCheckMode /* TODO(TS-TO-GO) inferred type CheckMode.Normal | CheckMode.RestBindingElement */ any
		if node.dotDotDotToken {
			parentCheckMode = CheckModeRestBindingElement
		} else {
			parentCheckMode = CheckModeNormal
		}
		parentType := tc.getTypeForBindingElementParent(parent, parentCheckMode)
		name := node.propertyName || node.name
		if parentType && !isBindingPattern(name) {
			exprType := tc.getLiteralTypeFromPropertyName(name)
			if isTypeUsableAsPropertyName(exprType) {
				nameText := getPropertyNameFromType(exprType)
				property := tc.getPropertyOfType(parentType, nameText)
				if property {
					tc.markPropertyAsReferenced(property /*nodeForCheckWriteOnly*/, nil /*isSelfTypeAccess*/, false)
					// A destructuring is never a write-only reference.
					tc.checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind == SyntaxKindSuperKeyword /*writing*/, false, parentType, property)
				}
			}
		}
	}

	// For a binding pattern, check contained binding elements
	if isBindingPattern(node.name) {
		if node.name.kind == SyntaxKindArrayBindingPattern && tc.languageVersion < LanguageFeatureMinimumTargetBindingPatterns && tc.compilerOptions.downlevelIteration {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
		}

		forEach(node.name.elements, tc.checkSourceElement)
	}
	// For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
	if node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) /* as FunctionLikeDeclaration */).body) {
		tc.error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation)
		return
	}
	// For a binding pattern, validate the initializer and exit
	if isBindingPattern(node.name) {
		if tc.isInAmbientOrTypeNode(node) {
			return
		}
		needCheckInitializer := hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind != SyntaxKindForInStatement
		needCheckWidenedType := !some(node.name.elements, not(isOmittedExpression))
		if needCheckInitializer || needCheckWidenedType {
			// Don't validate for-in initializer as it is already an error
			widenedType := tc.getWidenedTypeForVariableLikeDeclaration(node)
			if needCheckInitializer {
				initializerType := tc.checkExpressionCached(node.initializer)
				if tc.strictNullChecks && needCheckWidenedType {
					tc.checkNonNullNonVoidType(initializerType, node)
				} else {
					tc.checkTypeAssignableToAndOptionallyElaborate(initializerType, tc.getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer)
				}
			}
			// check the binding pattern with empty elements
			if needCheckWidenedType {
				if isArrayBindingPattern(node.name) {
					tc.checkIteratedTypeOrElementType(IterationUseDestructuring, widenedType, tc.undefinedType, node)
				} else if tc.strictNullChecks {
					tc.checkNonNullNonVoidType(widenedType, node)
				}
			}
		}
		return
	}
	// For a commonjs `const x = require`, validate the alias and exit
	symbol := tc.getSymbolOfDeclaration(node)
	if symbol.flags&SymbolFlagsAlias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node)) {
		tc.checkAliasSymbol(node)
		return
	}

	if node.name.kind == SyntaxKindBigIntLiteral {
		tc.error(node.name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name)
	}

	type_ := tc.convertAutoToAny(tc.getTypeOfSymbol(symbol))
	if node == symbol.valueDeclaration {
		// Node is the primary declaration of the symbol, just validate the initializer
		// Don't validate for-in initializer as it is already an error
		initializer := hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node)
		if initializer {
			isJSObjectLiteralInitializer := isInJSFile(node) && isObjectLiteralExpression(initializer) && (initializer.properties.length == 0 || isPrototypeAccess(node.name)) && !!symbol.exports. /* ? */ size
			if !isJSObjectLiteralInitializer && node.parent.parent.kind != SyntaxKindForInStatement {
				initializerType := tc.checkExpressionCached(initializer)
				tc.checkTypeAssignableToAndOptionallyElaborate(initializerType, type_, node, initializer /*headMessage*/, nil)
				blockScopeKind := tc.getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
				if blockScopeKind == NodeFlagsAwaitUsing {
					globalAsyncDisposableType := tc.getGlobalAsyncDisposableType(true)
					globalDisposableType := tc.getGlobalDisposableType(true)
					if globalAsyncDisposableType != tc.emptyObjectType && globalDisposableType != tc.emptyObjectType {
						optionalDisposableType := tc.getUnionType([] /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any{globalAsyncDisposableType, globalDisposableType, tc.nullType, tc.undefinedType})
						tc.checkTypeAssignableTo(tc.widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined)
					}
				} else if blockScopeKind == NodeFlagsUsing {
					globalDisposableType := tc.getGlobalDisposableType(true)
					if globalDisposableType != tc.emptyObjectType {
						optionalDisposableType := tc.getUnionType([] /* TODO(TS-TO-GO) inferred type IntrinsicType | ObjectType */ any{globalDisposableType, tc.nullType, tc.undefinedType})
						tc.checkTypeAssignableTo(tc.widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined)
					}
				}
			}
		}
		if symbol.declarations && symbol.declarations.length > 1 {
			if some(symbol.declarations, func(d Declaration) bool {
				return d != node && isVariableLike(d) && !tc.areDeclarationFlagsIdentical(d, node)
			}) {
				tc.error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
			}
		}
	} else {
		// Node is a secondary declaration, check that type is identical to primary declaration and check that
		// initializer is consistent with type associated with the node
		declarationType := tc.convertAutoToAny(tc.getWidenedTypeForVariableLikeDeclaration(node))

		if !tc.isErrorType(type_) && !tc.isErrorType(declarationType) && !tc.isTypeIdenticalTo(type_, declarationType) && !(symbol.flags & SymbolFlagsAssignment) {
			tc.errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type_, node, declarationType)
		}
		if hasOnlyExpressionInitializer(node) && node.initializer {
			tc.checkTypeAssignableToAndOptionallyElaborate(tc.checkExpressionCached(node.initializer), declarationType, node, node.initializer /*headMessage*/, nil)
		}
		if symbol.valueDeclaration && !tc.areDeclarationFlagsIdentical(node, symbol.valueDeclaration) {
			tc.error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
		}
	}
	if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature {
		// We know we don't have a binding pattern or computed name here
		tc.checkExportsOnMergedDeclarations(node)
		if node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindBindingElement {
			tc.checkVarDeclaredNamesNotShadowed(node)
		}
		tc.checkCollisionsForDeclarationName(node, node.name)
	}
}

func (tc *TypeChecker) errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration Declaration, firstType Type, nextDeclaration Declaration, nextType Type) {
	nextDeclarationName := getNameOfDeclaration(nextDeclaration)
	var message DiagnosticMessage
	if nextDeclaration.kind == SyntaxKindPropertyDeclaration || nextDeclaration.kind == SyntaxKindPropertySignature {
		message = Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2
	} else {
		message = Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2
	}
	declName := declarationNameToString(nextDeclarationName)
	err := tc.error(nextDeclarationName, message, declName, tc.typeToString(firstType), tc.typeToString(nextType))
	if firstDeclaration {
		addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName))
	}
}

func (tc *TypeChecker) areDeclarationFlagsIdentical(left Declaration, right Declaration) bool {
	if (left.kind == SyntaxKindParameter && right.kind == SyntaxKindVariableDeclaration) || (left.kind == SyntaxKindVariableDeclaration && right.kind == SyntaxKindParameter) {
		// Differences in optionality between parameters and variables are allowed.
		return true
	}

	if hasQuestionToken(left) != hasQuestionToken(right) {
		return false
	}

	interestingFlags := ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAsync | ModifierFlagsAbstract | ModifierFlagsReadonly | ModifierFlagsStatic

	return getSelectedEffectiveModifierFlags(left, interestingFlags) == getSelectedEffectiveModifierFlags(right, interestingFlags)
}

func (tc *TypeChecker) checkVariableDeclaration(node VariableDeclaration) {
	tracing. /* ? */ push(tracing.Phase.Check, "checkVariableDeclaration", map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind": node.kind,
		"pos":  node.pos,
		"end":  node.end,
		"path": (node /* as TracingNode */).tracingPath,
	})
	tc.checkGrammarVariableDeclaration(node)
	tc.checkVariableLikeDeclaration(node)
	tracing. /* ? */ pop()
}

func (tc *TypeChecker) checkBindingElement(node BindingElement) {
	tc.checkGrammarBindingElement(node)
	return tc.checkVariableLikeDeclaration(node)
}

func (tc *TypeChecker) checkVariableDeclarationList(node VariableDeclarationList) {
	blockScopeKind := getCombinedNodeFlags(node) & NodeFlagsBlockScoped
	if (blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing) && tc.languageVersion < LanguageFeatureMinimumTargetUsingAndAwaitUsing {
		tc.checkExternalEmitHelpers(node, ExternalEmitHelpersAddDisposableResourceAndDisposeResources)
	}

	forEach(node.declarations, tc.checkSourceElement)
}

func (tc *TypeChecker) checkVariableStatement(node VariableStatement) {
	// Grammar checking
	if !tc.checkGrammarModifiers(node) && !tc.checkGrammarVariableDeclarationList(node.declarationList) {
		tc.checkGrammarForDisallowedBlockScopedVariableStatement(node)
	}
	tc.checkVariableDeclarationList(node.declarationList)
}

func (tc *TypeChecker) checkExpressionStatement(node ExpressionStatement) {
	// Grammar checking
	tc.checkGrammarStatementInAmbientContext(node)

	tc.checkExpression(node.expression)
}

func (tc *TypeChecker) checkIfStatement(node IfStatement) {
	// Grammar checking
	tc.checkGrammarStatementInAmbientContext(node)
	type_ := tc.checkTruthinessExpression(node.expression)
	tc.checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type_, node.thenStatement)
	tc.checkSourceElement(node.thenStatement)

	if node.thenStatement.kind == SyntaxKindEmptyStatement {
		tc.error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement)
	}

	tc.checkSourceElement(node.elseStatement)
}

func (tc *TypeChecker) checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(condExpr Expression, condType Type, body /* TODO(TS-TO-GO) TypeNode UnionType: Statement | Expression */ any) {
	if !tc.strictNullChecks {
		return
	}
	bothHelper(condExpr, body)

	bothHelper := func(condExpr Expression, body /* TODO(TS-TO-GO) TypeNode UnionType: Expression | Statement | undefined */ any) {
		condExpr = skipParentheses(condExpr)

		helper(condExpr, body)

		for isBinaryExpression(condExpr) && (condExpr.operatorToken.kind == SyntaxKindBarBarToken || condExpr.operatorToken.kind == SyntaxKindQuestionQuestionToken) {
			condExpr = skipParentheses(condExpr.left)
			helper(condExpr, body)
		}
	}

	helper := func(condExpr Expression, body /* TODO(TS-TO-GO) TypeNode UnionType: Expression | Statement | undefined */ any) {
		var location Expression
		if isLogicalOrCoalescingBinaryExpression(condExpr) {
			location = skipParentheses(condExpr.right)
		} else {
			location = condExpr
		}
		if isModuleExportsAccessExpression(location) {
			return
		}
		if isLogicalOrCoalescingBinaryExpression(location) {
			bothHelper(location, body)
			return
		}
		var type_ Type
		if location == condExpr {
			type_ = condType
		} else {
			type_ = tc.checkExpression(location)
		}
		if type_.flags&TypeFlagsEnumLiteral && isPropertyAccessExpression(location) && ( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol */ TODO).flags&SymbolFlagsEnum {
			// EnumLiteral type at condition with known value is always truthy or always falsy, likely an error
			tc.error(location, Diagnostics.This_condition_will_always_return_0, __COND__(!!(type_ /* as LiteralType */).value, "true", "false"))
			return
		}
		isPropertyExpressionCast := isPropertyAccessExpression(location) && tc.isTypeAssertion(location.expression)
		if !tc.hasTypeFacts(type_, TypeFactsTruthy) || isPropertyExpressionCast {
			return
		}

		// While it technically should be invalid for any known-truthy value
		// to be tested, we de-scope to functions and Promises unreferenced in
		// the block as a heuristic to identify the most common bugs. There
		// are too many false positives for values sourced from type
		// definitions without strictNullChecks otherwise.
		callSignatures := tc.getSignaturesOfType(type_, SignatureKindCall)
		isPromise := !!tc.getAwaitedTypeOfPromise(type_)
		if callSignatures.length == 0 && !isPromise {
			return
		}

		var testedNode *MemberName
		switch {
		case isIdentifier(location):
			testedNode = location
		case isPropertyAccessExpression(location):
			testedNode = location.name
		default:
			testedNode = nil
		}
		testedSymbol := testedNode && tc.getSymbolAtLocation(testedNode)
		if !testedSymbol && !isPromise {
			return
		}

		isUsed := testedSymbol && isBinaryExpression(condExpr.parent) && tc.isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol) || testedSymbol && body && tc.isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol)
		if !isUsed {
			if isPromise {
				tc.errorAndMaybeSuggestAwait(location, true, Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, tc.getTypeNameForErrorDisplay(type_))
			} else {
				tc.error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead)
			}
		}
	}

}

func (tc *TypeChecker) isSymbolUsedInConditionBody(expr Expression, body /* TODO(TS-TO-GO) TypeNode UnionType: Statement | Expression */ any, testedNode Node, testedSymbol Symbol) bool {
	return !!forEachChild(body, func /* check */ (childNode Node) *bool {
		if isIdentifier(childNode) {
			childSymbol := tc.getSymbolAtLocation(childNode)
			if childSymbol && childSymbol == testedSymbol {
				// If the test was a simple identifier, the above check is sufficient
				if isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent) {
					return true
				}
				// Otherwise we need to ensure the symbol is called on the same target
				testedExpression := testedNode.parent
				childExpression := childNode.parent
				for testedExpression && childExpression {
					if isIdentifier(testedExpression) && isIdentifier(childExpression) || testedExpression.kind == SyntaxKindThisKeyword && childExpression.kind == SyntaxKindThisKeyword {
						return tc.getSymbolAtLocation(testedExpression) == tc.getSymbolAtLocation(childExpression)
					} else if isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression) {
						if tc.getSymbolAtLocation(testedExpression.name) != tc.getSymbolAtLocation(childExpression.name) {
							return false
						}
						childExpression = childExpression.expression
						testedExpression = testedExpression.expression
					} else if isCallExpression(testedExpression) && isCallExpression(childExpression) {
						childExpression = childExpression.expression
						testedExpression = testedExpression.expression
					} else {
						return false
					}
				}
			}
		}
		return forEachChild(childNode, check)
	})
}

func (tc *TypeChecker) isSymbolUsedInBinaryExpressionChain(node Node, testedSymbol Symbol) bool {
	for isBinaryExpression(node) && node.operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
		isUsed := forEachChild(node.right, func /* visit */ (child Node) *bool {
			if isIdentifier(child) {
				symbol := tc.getSymbolAtLocation(child)
				if symbol && symbol == testedSymbol {
					return true
				}
			}
			return forEachChild(child, visit)
		})
		if isUsed {
			return true
		}
		node = node.parent
	}
	return false
}

func (tc *TypeChecker) checkDoStatement(node DoStatement) {
	// Grammar checking
	tc.checkGrammarStatementInAmbientContext(node)

	tc.checkSourceElement(node.statement)
	tc.checkTruthinessExpression(node.expression)
}

func (tc *TypeChecker) checkWhileStatement(node WhileStatement) {
	// Grammar checking
	tc.checkGrammarStatementInAmbientContext(node)

	tc.checkTruthinessExpression(node.expression)
	tc.checkSourceElement(node.statement)
}

func (tc *TypeChecker) checkTruthinessOfType(type_ Type, node Node) Type {
	if type_.flags & TypeFlagsVoid {
		tc.error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness)
	} else {
		semantics := tc.getSyntacticTruthySemantics(node)
		if semantics != PredicateSemanticsSometimes {
			tc.error(node, __COND__(semantics == PredicateSemanticsAlways, Diagnostics.This_kind_of_expression_is_always_truthy, Diagnostics.This_kind_of_expression_is_always_falsy))
		}
	}

	return type_
}

func (tc *TypeChecker) getSyntacticTruthySemantics(node Node) PredicateSemantics {
	node = skipOuterExpressions(node)
	switch node.kind {
	case SyntaxKindNumericLiteral:
		if (node /* as NumericLiteral */).text == "0" || (node /* as NumericLiteral */).text == "1" {
			return PredicateSemanticsSometimes
		}
		return PredicateSemanticsAlways
	case SyntaxKindArrayLiteralExpression,
		SyntaxKindArrowFunction,
		SyntaxKindBigIntLiteral,
		SyntaxKindClassExpression,
		SyntaxKindFunctionExpression,
		SyntaxKindJsxElement,
		SyntaxKindJsxSelfClosingElement,
		SyntaxKindObjectLiteralExpression,
		SyntaxKindRegularExpressionLiteral:
		return PredicateSemanticsAlways
	case SyntaxKindVoidExpression,
		SyntaxKindNullKeyword:
		return PredicateSemanticsNever
	case SyntaxKindNoSubstitutionTemplateLiteral,
		SyntaxKindStringLiteral:
		if !!(node /* as StringLiteral | NoSubstitutionTemplateLiteral */).text {
			return PredicateSemanticsAlways
		} else {
			return PredicateSemanticsNever
		}
	case SyntaxKindConditionalExpression:
		return tc.getSyntacticTruthySemantics((node /* as ConditionalExpression */).whenTrue) | tc.getSyntacticTruthySemantics((node /* as ConditionalExpression */).whenFalse)
	case SyntaxKindIdentifier:
		if tc.getResolvedSymbol(node /* as Identifier */) == tc.undefinedSymbol {
			return PredicateSemanticsNever
		}
		return PredicateSemanticsSometimes
	}
	return PredicateSemanticsSometimes
}

func (tc *TypeChecker) checkTruthinessExpression(node Expression, checkMode CheckMode) Type {
	return tc.checkTruthinessOfType(tc.checkExpression(node, checkMode), node)
}

func (tc *TypeChecker) checkForStatement(node ForStatement) {
	// Grammar checking
	if !tc.checkGrammarStatementInAmbientContext(node) {
		if node.initializer && node.initializer.kind == SyntaxKindVariableDeclarationList {
			tc.checkGrammarVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
		}
	}

	if node.initializer {
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			tc.checkVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
		} else {
			tc.checkExpression(node.initializer)
		}
	}

	if node.condition {
		tc.checkTruthinessExpression(node.condition)
	}
	if node.incrementor {
		tc.checkExpression(node.incrementor)
	}
	tc.checkSourceElement(node.statement)
	if node.locals {
		tc.registerForUnusedIdentifiersCheck(node)
	}
}

func (tc *TypeChecker) checkForOfStatement(node ForOfStatement) {
	tc.checkGrammarForInOrForOfStatement(node)

	container := getContainingFunctionOrClassStaticBlock(node)
	if node.awaitModifier {
		if container && isClassStaticBlockDeclaration(container) {
			tc.grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block)
		} else {
			functionFlags := getFunctionFlags(container)
			if (functionFlags&(FunctionFlagsInvalid|FunctionFlagsAsync)) == FunctionFlagsAsync && tc.languageVersion < LanguageFeatureMinimumTargetForAwaitOf {
				// for..await..of in an async function or async generator function prior to ESNext requires the __asyncValues helper
				tc.checkExternalEmitHelpers(node, ExternalEmitHelpersForAwaitOfIncludes)
			}
		}
	} else if tc.compilerOptions.downlevelIteration && tc.languageVersion < LanguageFeatureMinimumTargetForOf {
		// for..of prior to ES2015 requires the __values helper when downlevelIteration is enabled
		tc.checkExternalEmitHelpers(node, ExternalEmitHelpersForOfIncludes)
	}

	// Check the LHS and RHS
	// If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
	// via checkRightHandSideOfForOf.
	// If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
	// Then check that the RHS is assignable to it.
	if node.initializer.kind == SyntaxKindVariableDeclarationList {
		tc.checkVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
	} else {
		varExpr := node.initializer
		iteratedType := tc.checkRightHandSideOfForOf(node)

		// There may be a destructuring assignment on the left side
		if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
			// iteratedType may be undefined. In this case, we still want to check the structure of
			// varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
			// to short circuit the type relation checking as much as possible, so we pass the unknownType.
			tc.checkDestructuringAssignment(varExpr, iteratedType || tc.errorType)
		} else {
			leftType := tc.checkExpression(varExpr)
			tc.checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access)

			// iteratedType will be undefined if the rightType was missing properties/signatures
			// required to get its iteratedType (like [Symbol.iterator] or next). This may be
			// because we accessed properties from anyType, or it may have led to an error inside
			// getElementTypeOfIterable.
			if iteratedType {
				tc.checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression)
			}
		}
	}

	tc.checkSourceElement(node.statement)
	if node.locals {
		tc.registerForUnusedIdentifiersCheck(node)
	}
}

func (tc *TypeChecker) checkForInStatement(node ForInStatement) {
	// Grammar checking
	tc.checkGrammarForInOrForOfStatement(node)

	rightType := tc.getNonNullableTypeIfNeeded(tc.checkExpression(node.expression))
	// TypeScript 1.0 spec (April 2014): 5.4
	// In a 'for-in' statement of the form
	// for (let VarDecl in Expr) Statement
	//   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
	//   and Expr must be an expression of type Any, an object type, or a type parameter type.
	if node.initializer.kind == SyntaxKindVariableDeclarationList {
		variable := (node.initializer /* as VariableDeclarationList */).declarations[0]
		if variable && isBindingPattern(variable.name) {
			tc.error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
		}
		tc.checkVariableDeclarationList(node.initializer /* as VariableDeclarationList */)
	} else {
		// In a 'for-in' statement of the form
		// for (Var in Expr) Statement
		//   Var must be an expression classified as a reference of type Any or the String primitive type,
		//   and Expr must be an expression of type Any, an object type, or a type parameter type.
		varExpr := node.initializer
		leftType := tc.checkExpression(varExpr)
		if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
			tc.error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
		} else if !tc.isTypeAssignableTo(tc.getIndexTypeOrString(rightType), leftType) {
			tc.error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any)
		} else {
			// run check only former check succeeded to avoid cascading errors
			tc.checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access)
		}
	}

	// unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
	// in this case error about missing name is already reported - do not report extra one
	if rightType == tc.neverType || !tc.isTypeAssignableToKind(rightType, TypeFlagsNonPrimitive|TypeFlagsInstantiableNonPrimitive) {
		tc.error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, tc.typeToString(rightType))
	}

	tc.checkSourceElement(node.statement)
	if node.locals {
		tc.registerForUnusedIdentifiersCheck(node)
	}
}

func (tc *TypeChecker) checkRightHandSideOfForOf(statement ForOfStatement) Type {
	var use /* TODO(TS-TO-GO) inferred type IterationUse.ForOf | IterationUse.ForAwaitOf */ any
	if statement.awaitModifier {
		use = IterationUseForAwaitOf
	} else {
		use = IterationUseForOf
	}
	return tc.checkIteratedTypeOrElementType(use, tc.checkNonNullExpression(statement.expression), tc.undefinedType, statement.expression)
}

func (tc *TypeChecker) checkIteratedTypeOrElementType(use IterationUse, inputType Type, sentType Type, errorNode Node) Type {
	if tc.isTypeAny(inputType) {
		return inputType
	}
	return tc.getIteratedTypeOrElementType(use, inputType, sentType, errorNode /*checkAssignability*/, true) || tc.anyType
}

/**
 * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
 * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
 * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
 */

func (tc *TypeChecker) getIteratedTypeOrElementType(use IterationUse, inputType Type, sentType Type, errorNode Node, checkAssignability bool) Type {
	allowAsyncIterables := (use & IterationUseAllowsAsyncIterablesFlag) != 0
	if inputType == tc.neverType {
		if errorNode {
			tc.reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables)
		}
		return nil
	}

	uplevelIteration := tc.languageVersion >= ScriptTargetES2015
	downlevelIteration := !uplevelIteration && tc.compilerOptions.downlevelIteration
	possibleOutOfBounds := tc.compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUsePossiblyOutOfBounds)

	// Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
	// or higher, when inside of an async generator or for-await-if, or when
	// downlevelIteration is requested.
	if uplevelIteration || downlevelIteration || allowAsyncIterables {
		// We only report errors for an invalid iterable type in ES2015 or higher.
		iterationTypes := tc.getIterationTypesOfIterable(inputType, use, __COND__(uplevelIteration, errorNode, nil))
		if checkAssignability {
			if iterationTypes {
				var diagnostic *DiagnosticMessage
				switch {
				case use & IterationUseForOfFlag:
					diagnostic = Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0
				case use & IterationUseSpreadFlag:
					diagnostic = Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0
				case use & IterationUseDestructuringFlag:
					diagnostic = Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0
				case use & IterationUseYieldStarFlag:
					diagnostic = Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0
				default:
					diagnostic = nil
				}
				if diagnostic {
					tc.checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic)
				}
			}
		}
		if iterationTypes || uplevelIteration {
			if possibleOutOfBounds {
				return tc.includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType)
			} else {
				return (iterationTypes && iterationTypes.yieldType)
			}
		}
	}

	arrayType := inputType
	hasStringConstituent := false

	// If strings are permitted, remove any string-like constituents from the array type.
	// This allows us to find other non-string element types from an array unioned with
	// a string.
	if use & IterationUseAllowsStringInputFlag {
		if arrayType.flags & TypeFlagsUnion {
			// After we remove all types that are StringLike, we will know if there was a string constituent
			// based on whether the result of filter is a new array.
			arrayTypes := (inputType /* as UnionType */).types
			filteredTypes := filter(arrayTypes, func(t Type) bool {
				return !(t.flags & TypeFlagsStringLike)
			})
			if filteredTypes != arrayTypes {
				arrayType = tc.getUnionType(filteredTypes, UnionReductionSubtype)
			}
		} else if arrayType.flags & TypeFlagsStringLike {
			arrayType = tc.neverType
		}

		hasStringConstituent = arrayType != inputType
		if hasStringConstituent {
			// Now that we've removed all the StringLike types, if no constituents remain, then the entire
			// arrayOrStringType was a string.
			if arrayType.flags & TypeFlagsNever {
				if possibleOutOfBounds {
					return tc.includeUndefinedInIndexSignature(tc.stringType)
				} else {
					return tc.stringType
				}
			}
		}
	}

	if !tc.isArrayLikeType(arrayType) {
		if errorNode {
			// Which error we report depends on whether we allow strings or if there was a
			// string constituent. For example, if the input type is number | string, we
			// want to say that number is not an array type. But if the input was just
			// number and string input is allowed, we want to say that number is not an
			// array type or a string type.
			allowsStrings := !!(use & IterationUseAllowsStringInputFlag) && !hasStringConstituent
			TODO_IDENTIFIER := getIterationDiagnosticDetails(allowsStrings, downlevelIteration)
			tc.errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!tc.getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, tc.typeToString(arrayType))
		}
		switch {
		case hasStringConstituent:
			if possibleOutOfBounds {
				return tc.includeUndefinedInIndexSignature(tc.stringType)
			} else {
				return tc.stringType
			}
		default:
			return nil
		}
	}

	arrayElementType := tc.getIndexTypeOfType(arrayType, tc.numberType)
	if hasStringConstituent && arrayElementType {
		// This is just an optimization for the case where arrayOrStringType is string | string[]
		if arrayElementType.flags&TypeFlagsStringLike && !tc.compilerOptions.noUncheckedIndexedAccess {
			return tc.stringType
		}

		return tc.getUnionType(__COND__(possibleOutOfBounds, []Type{arrayElementType, tc.stringType, tc.undefinedType}, []Type{arrayElementType, tc.stringType}), UnionReductionSubtype)
	}

	if use & IterationUsePossiblyOutOfBounds {
		return tc.includeUndefinedInIndexSignature(arrayElementType)
	} else {
		return arrayElementType
	}

	getIterationDiagnosticDetails := func(allowsStrings bool, downlevelIteration *bool) /* TODO(TS-TO-GO) TypeNode TupleType: [error: DiagnosticMessage, maybeMissingAwait: boolean] */ any {
		if downlevelIteration {
			if allowsStrings {
				return []any{Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true}
			} else {
				return []any{Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true}
			}
		}

		yieldType := tc.getIterationTypeOfIterable(use, IterationTypeKindYield, inputType /*errorNode*/, nil)

		if yieldType {
			return []any{Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false}
		}

		if tc.isES2015OrLaterIterable(inputType.symbol. /* ? */ escapedName) {
			return []any{Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true}
		}

		if allowsStrings {
			return []any{Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true}
		} else {
			return []any{Diagnostics.Type_0_is_not_an_array_type, true}
		}
	}

}

func (tc *TypeChecker) isES2015OrLaterIterable(n __String) bool {
	switch n {
	case "Float32Array",
		"Float64Array",
		"Int16Array",
		"Int32Array",
		"Int8Array",
		"NodeList",
		"Uint16Array",
		"Uint32Array",
		"Uint8Array",
		"Uint8ClampedArray":
		return true
	}
	return false
}

/**
 * Gets the requested "iteration type" from an `Iterable`-like or `AsyncIterable`-like type.
 */

func (tc *TypeChecker) getIterationTypeOfIterable(use IterationUse, typeKind IterationTypeKind, inputType Type, errorNode Node) Type {
	if tc.isTypeAny(inputType) {
		return nil
	}

	iterationTypes := tc.getIterationTypesOfIterable(inputType, use, errorNode)
	return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)]
}

func (tc *TypeChecker) createIterationTypes(yieldType Type /*  = neverType */, returnType Type /*  = neverType */, nextType Type /*  = unknownType */) IterationTypes {
	// `yieldType` and `returnType` are defaulted to `neverType` they each will be combined
	// via `getUnionType` when merging iteration types. `nextType` is defined as `unknownType`
	// as it is combined via `getIntersectionType` when merging iteration types.

	// Use the cache only for intrinsic types to keep it small as they are likely to be
	// more frequently created (i.e. `Iterator<number, void, unknown>`). Iteration types
	// are also cached on the type they are requested for, so we shouldn't need to maintain
	// the cache for less-frequently used types.
	if yieldType.flags&TypeFlagsIntrinsic && returnType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) && nextType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) {
		id := tc.getTypeListId([]Type{yieldType, returnType, nextType})
		iterationTypes := tc.iterationTypesCache.get(id)
		if !iterationTypes {
			iterationTypes = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"yieldType":  yieldType,
				"returnType": returnType,
				"nextType":   nextType,
			}
			tc.iterationTypesCache.set(id, iterationTypes)
		}
		return iterationTypes
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"yieldType":  yieldType,
		"returnType": returnType,
		"nextType":   nextType,
	}
}

/**
 * Combines multiple `IterationTypes` records.
 *
 * If `array` is empty or all elements are missing or are references to `noIterationTypes`,
 * then `noIterationTypes` is returned. Otherwise, an `IterationTypes` record is returned
 * for the combined iteration types.
 */

func (tc *TypeChecker) combineIterationTypes(array []*IterationTypes) IterationTypes {
	var yieldTypes *[]Type
	var returnTypes *[]Type
	var nextTypes *[]Type
	for _, iterationTypes := range array {
		if iterationTypes == nil || iterationTypes == tc.noIterationTypes {
			continue
		}
		if iterationTypes == tc.anyIterationTypes {
			return tc.anyIterationTypes
		}
		yieldTypes = append(yieldTypes, iterationTypes.yieldType)
		returnTypes = append(returnTypes, iterationTypes.returnType)
		nextTypes = append(nextTypes, iterationTypes.nextType)
	}
	if yieldTypes || returnTypes || nextTypes {
		return tc.createIterationTypes(yieldTypes && tc.getUnionType(yieldTypes), returnTypes && tc.getUnionType(returnTypes), nextTypes && tc.getIntersectionType(nextTypes))
	}
	return tc.noIterationTypes
}

func (tc *TypeChecker) getCachedIterationTypes(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes]) *IterationTypes {
	return (type_ /* as IterableOrIteratorType */)[cacheKey]
}

func (tc *TypeChecker) setCachedIterationTypes(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes], cachedTypes IterationTypes) IterationTypes {
	(type_ /* as IterableOrIteratorType */)[cacheKey] = tc.cachedTypes
	return (type_ /* as IterableOrIteratorType */)[cacheKey]
}

/**
 * Gets the *yield*, *return*, and *next* types from an `Iterable`-like or `AsyncIterable`-like type.
 *
 * At every level that involves analyzing return types of signatures, we union the return types of all the signatures.
 *
 * Another thing to note is that at any step of this process, we could run into a dead end,
 * meaning either the property is missing, or we run into the anyType. If either of these things
 * happens, we return `undefined` to signal that we could not find the iteration type. If a property
 * is missing, and the previous step did not result in `any`, then we also give an error if the
 * caller requested it. Then the caller can decide what to do in the case where there is no iterated
 * type.
 *
 * For a **for-of** statement, `yield*` (in a normal generator), spread, array
 * destructuring, or normal generator we will only ever look for a `[Symbol.iterator]()`
 * method.
 *
 * For an async generator we will only ever look at the `[Symbol.asyncIterator]()` method.
 *
 * For a **for-await-of** statement or a `yield*` in an async generator we will look for
 * the `[Symbol.asyncIterator]()` method first, and then the `[Symbol.iterator]()` method.
 */

func (tc *TypeChecker) getIterationTypesOfIterable(type_ Type, use IterationUse, errorNode Node) *IterationTypes {
	if tc.isTypeAny(type_) {
		return tc.anyIterationTypes
	}

	if !(type_.flags & TypeFlagsUnion) {
		var errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any
		if errorNode {
			errorOutputContainer = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errors": nil,
			}
		} else {
			errorOutputContainer = nil
		}
		iterationTypes := tc.getIterationTypesOfIterableWorker(type_, use, errorNode, errorOutputContainer)
		if iterationTypes == tc.noIterationTypes {
			if errorNode {
				rootDiag := tc.reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
				if errorOutputContainer. /* ? */ errors {
					addRelatedInfo(rootDiag, errorOutputContainer.errors...)
				}
			}
			return nil
		} else if errorOutputContainer. /* ? */ errors. /* ? */ length {
			for _, diag := range errorOutputContainer.errors {
				tc.diagnostics.add(diag)
			}
		}
		return iterationTypes
	}

	var cacheKey /* TODO(TS-TO-GO) inferred type "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
	if use & IterationUseAllowsAsyncIterablesFlag {
		cacheKey = "iterationTypesOfAsyncIterable"
	} else {
		cacheKey = "iterationTypesOfIterable"
	}
	cachedTypes := tc.getCachedIterationTypes(type_, cacheKey)
	if cachedTypes {
		if cachedTypes == tc.noIterationTypes {
			return nil
		} else {
			return cachedTypes
		}
	}

	var allIterationTypes *[]IterationTypes
	for _, constituent := range (type_ /* as UnionType */).types {
		var errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any
		if errorNode {
			errorOutputContainer = map[any]any{ /* TODO(TS-TO-GO): was object literal */
				"errors": nil,
			}
		} else {
			errorOutputContainer = nil
		}
		iterationTypes := tc.getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer)
		if iterationTypes == tc.noIterationTypes {
			if errorNode {
				rootDiag := tc.reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
				if errorOutputContainer. /* ? */ errors {
					addRelatedInfo(rootDiag, errorOutputContainer.errors...)
				}
			}
			tc.setCachedIterationTypes(type_, cacheKey, tc.noIterationTypes)
			return nil
		} else if errorOutputContainer. /* ? */ errors. /* ? */ length {
			for _, diag := range errorOutputContainer.errors {
				tc.diagnostics.add(diag)
			}
		}

		allIterationTypes = append(allIterationTypes, iterationTypes)
	}

	var iterationTypes IterationTypes
	if allIterationTypes {
		iterationTypes = tc.combineIterationTypes(allIterationTypes)
	} else {
		iterationTypes = tc.noIterationTypes
	}
	tc.setCachedIterationTypes(type_, cacheKey, iterationTypes)
	if iterationTypes == tc.noIterationTypes {
		return nil
	} else {
		return iterationTypes
	}
}

func (tc *TypeChecker) getAsyncFromSyncIterationTypes(iterationTypes IterationTypes, errorNode Node) IterationTypes {
	if iterationTypes == tc.noIterationTypes {
		return tc.noIterationTypes
	}
	if iterationTypes == tc.anyIterationTypes {
		return tc.anyIterationTypes
	}
	TODO_IDENTIFIER := iterationTypes
	// if we're requesting diagnostics, report errors for a missing `Awaited<T>`.
	if errorNode {
		tc.getGlobalAwaitedSymbol(true)
	}
	return tc.createIterationTypes(tc.getAwaitedType(yieldType, errorNode) || tc.anyType, tc.getAwaitedType(returnType, errorNode) || tc.anyType, nextType)
}

/**
 * Gets the *yield*, *return*, and *next* types from a non-union type.
 *
 * If we are unable to find the *yield*, *return*, and *next* types, `noIterationTypes` is
 * returned to indicate to the caller that it should report an error. Otherwise, an
 * `IterationTypes` record is returned.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterable` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIterableWorker(type_ Type, use IterationUse, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any) IterationTypes {
	if tc.isTypeAny(type_) {
		return tc.anyIterationTypes
	}

	// If we are reporting errors and encounter a cached `noIterationTypes`, we should ignore the cached value and continue as if nothing was cached.
	// In addition, we should not cache any new results for this call.
	noCache := false

	if use & IterationUseAllowsAsyncIterablesFlag {
		iterationTypes := tc.getIterationTypesOfIterableCached(type_, tc.asyncIterationTypesResolver) || tc.getIterationTypesOfIterableFast(type_, tc.asyncIterationTypesResolver)
		if iterationTypes {
			if iterationTypes == tc.noIterationTypes && errorNode {
				// ignore the cached value
				noCache = true
			} else {
				if use & IterationUseForOfFlag {
					return tc.getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
				} else {
					return iterationTypes
				}
			}
		}
	}

	if use & IterationUseAllowsSyncIterablesFlag {
		iterationTypes := tc.getIterationTypesOfIterableCached(type_, tc.syncIterationTypesResolver) || tc.getIterationTypesOfIterableFast(type_, tc.syncIterationTypesResolver)
		if iterationTypes {
			if iterationTypes == tc.noIterationTypes && errorNode {
				// ignore the cached value
				noCache = true
			} else {
				if use & IterationUseAllowsAsyncIterablesFlag {
					// for a sync iterable in an async context, only use the cached types if they are valid.
					if iterationTypes != tc.noIterationTypes {
						iterationTypes = tc.getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
						if noCache {
							return iterationTypes
						} else {
							return tc.setCachedIterationTypes(type_, "iterationTypesOfAsyncIterable", iterationTypes)
						}
					}
				} else {
					return iterationTypes
				}
			}
		}
	}

	if use & IterationUseAllowsAsyncIterablesFlag {
		iterationTypes := tc.getIterationTypesOfIterableSlow(type_, tc.asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
		if iterationTypes != tc.noIterationTypes {
			return iterationTypes
		}
	}

	if use & IterationUseAllowsSyncIterablesFlag {
		iterationTypes := tc.getIterationTypesOfIterableSlow(type_, tc.syncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
		if iterationTypes != tc.noIterationTypes {
			if use & IterationUseAllowsAsyncIterablesFlag {
				iterationTypes = tc.getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
				if noCache {
					return iterationTypes
				} else {
					return tc.setCachedIterationTypes(type_, "iterationTypesOfAsyncIterable", iterationTypes)
				}
			} else {
				return iterationTypes
			}
		}
	}

	return tc.noIterationTypes
}

/**
 * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or
 * `AsyncIterable`-like type from the cache.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterable` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIterableCached(type_ Type, resolver IterationTypesResolver) *IterationTypes {
	return tc.getCachedIterationTypes(type_, resolver.iterableCacheKey)
}

/**
 * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
 * type from from common heuristics.
 *
 * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
 * returned. If we found iteration types, an `IterationTypes` record is returned.
 * Otherwise, we return `undefined` to indicate to the caller it should perform a more
 * exhaustive analysis.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterable` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIterableFast(type_ Type, resolver IterationTypesResolver) *IterationTypes {
	// As an optimization, if the type is an instantiation of the following global type, then
	// just grab its related type arguments:
	// - `Iterable<T, TReturn, TNext>` or `AsyncIterable<T, TReturn, TNext>`
	// - `IteratorObject<T, TReturn, TNext>` or `AsyncIteratorObject<T, TReturn, TNext>`
	// - `IterableIterator<T, TReturn, TNext>` or `AsyncIterableIterator<T, TReturn, TNext>`
	// - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
	if tc.isReferenceToType(type_, resolver.getGlobalIterableType(false)) || tc.isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || tc.isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || tc.isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
		TODO_IDENTIFIER := tc.getTypeArguments(type_ /* as GenericType */)
		return tc.setCachedIterationTypes(type_, resolver.iterableCacheKey, tc.createIterationTypes(resolver.resolveIterationType(yieldType /*errorNode*/, nil) || yieldType, resolver.resolveIterationType(returnType /*errorNode*/, nil) || returnType, nextType))
	}

	// As an optimization, if the type is an instantiation of one of the following global types, then
	// just grab the related type argument:
	// - `ArrayIterator<T>`
	// - `MapIterator<T>`
	// - `SetIterator<T>`
	// - `StringIterator<T>`
	// - `ReadableStreamAsyncIterator<T>`
	if tc.isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
		TODO_IDENTIFIER := tc.getTypeArguments(type_ /* as GenericType */)
		returnType := tc.getBuiltinIteratorReturnType()
		nextType := tc.unknownType
		return tc.setCachedIterationTypes(type_, resolver.iterableCacheKey, tc.createIterationTypes(resolver.resolveIterationType(yieldType /*errorNode*/, nil) || yieldType, resolver.resolveIterationType(returnType /*errorNode*/, nil) || returnType, nextType))
	}
}

func (tc *TypeChecker) getPropertyNameForKnownSymbolName(symbolName string) __String {
	ctorType := tc.getGlobalESSymbolConstructorSymbol(false)
	uniqueType := ctorType && tc.getTypeOfPropertyOfType(tc.getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName))
	if uniqueType && isTypeUsableAsPropertyName(uniqueType) {
		return getPropertyNameFromType(uniqueType)
	} else {
		return __TEMPLATE__("__@", symbolName) /* as __String */
	}
}

/**
 * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
 * type from its members.
 *
 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
 * record is returned. Otherwise, `noIterationTypes` is returned.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterable` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIterableSlow(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any, noCache bool) IterationTypes {
	method := tc.getPropertyOfType(type_, tc.getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName))
	var methodType Type
	if method && !(method.flags & SymbolFlagsOptional) {
		methodType = tc.getTypeOfSymbol(method)
	} else {
		methodType = nil
	}
	if tc.isTypeAny(methodType) {
		if noCache {
			return tc.anyIterationTypes
		} else {
			return tc.setCachedIterationTypes(type_, resolver.iterableCacheKey, tc.anyIterationTypes)
		}
	}

	var signatures *[]Signature
	if methodType {
		signatures = tc.getSignaturesOfType(methodType, SignatureKindCall)
	} else {
		signatures = nil
	}
	if !some(signatures) {
		if noCache {
			return tc.noIterationTypes
		} else {
			return tc.setCachedIterationTypes(type_, resolver.iterableCacheKey, tc.noIterationTypes)
		}
	}

	iteratorType := tc.getIntersectionType(map_(signatures, tc.getReturnTypeOfSignature))
	iterationTypes := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes */ TODO
	if noCache {
		return iterationTypes
	} else {
		return tc.setCachedIterationTypes(type_, resolver.iterableCacheKey, iterationTypes)
	}
}

func (tc *TypeChecker) reportTypeNotIterableError(errorNode Node, type_ Type, allowAsyncIterables bool) Diagnostic {
	var message DiagnosticMessage
	if allowAsyncIterables {
		message = Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator
	} else {
		message = Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator
	}
	suggestAwait := !!tc.getAwaitedTypeOfPromise(type_) || (!allowAsyncIterables && isForOfStatement(errorNode.parent) && errorNode.parent.expression == errorNode && tc.getGlobalAsyncIterableType(false) != tc.emptyGenericType && tc.isTypeAssignableTo(type_, tc.createTypeFromGenericGlobalType(tc.getGlobalAsyncIterableType(false), []IntrinsicType{tc.anyType, tc.anyType, tc.anyType})))
	return tc.errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, tc.typeToString(type_))
}

/**
 * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
 *
 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
 * record is returned. Otherwise, `undefined` is returned.
 */

func (tc *TypeChecker) getIterationTypesOfIterator(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
	return tc.getIterationTypesOfIteratorWorker(type_, resolver, errorNode, errorOutputContainer /*noCache*/, false)
}

/**
 * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
 *
 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
 * record is returned. Otherwise, `undefined` is returned.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterator` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIteratorWorker(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any, noCache bool) *IterationTypes {
	if tc.isTypeAny(type_) {
		return tc.anyIterationTypes
	}

	iterationTypes := tc.getIterationTypesOfIteratorCached(type_, resolver) || tc.getIterationTypesOfIteratorFast(type_, resolver)

	if iterationTypes == tc.noIterationTypes && errorNode {
		iterationTypes = nil
		noCache = true
	}

	/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache) */
	TODO
	if iterationTypes == tc.noIterationTypes {
		return nil
	} else {
		return iterationTypes
	}
}

/**
 * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
 * cache.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterator` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIteratorCached(type_ Type, resolver IterationTypesResolver) *IterationTypes {
	return tc.getCachedIterationTypes(type_, resolver.iteratorCacheKey)
}

/**
 * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
 * cache or from common heuristics.
 *
 * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
 * returned. If we found iteration types, an `IterationTypes` record is returned.
 * Otherwise, we return `undefined` to indicate to the caller it should perform a more
 * exhaustive analysis.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterator` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIteratorFast(type_ Type, resolver IterationTypesResolver) *IterationTypes {
	// As an optimization, if the type is an instantiation of one of the following global types,
	// then just grab its related type arguments:
	// - `IterableIterator<T, TReturn, TNext>` or `AsyncIterableIterator<T, TReturn, TNext>`
	// - `IteratorObject<T, TReturn, TNext>` or `AsyncIteratorObject<T, TReturn, TNext>`
	// - `Iterator<T, TReturn, TNext>` or `AsyncIterator<T, TReturn, TNext>`
	// - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
	if tc.isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || tc.isReferenceToType(type_, resolver.getGlobalIteratorType(false)) || tc.isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || tc.isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
		TODO_IDENTIFIER := tc.getTypeArguments(type_ /* as GenericType */)
		return tc.setCachedIterationTypes(type_, resolver.iteratorCacheKey, tc.createIterationTypes(yieldType, returnType, nextType))
	}

	// As an optimization, if the type is an instantiation of one of the following global types, then
	// just grab the related type argument:
	// - `ArrayIterator<T>`
	// - `MapIterator<T>`
	// - `SetIterator<T>`
	// - `StringIterator<T>`
	// - `ReadableStreamAsyncIterator<T>`
	if tc.isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
		TODO_IDENTIFIER := tc.getTypeArguments(type_ /* as GenericType */)
		returnType := tc.getBuiltinIteratorReturnType()
		nextType := tc.unknownType
		return tc.setCachedIterationTypes(type_, resolver.iteratorCacheKey, tc.createIterationTypes(yieldType, returnType, nextType))
	}
}

func (tc *TypeChecker) isIteratorResult(type_ Type, kind /* TODO(TS-TO-GO) TypeNode UnionType: IterationTypeKind.Yield | IterationTypeKind.Return */ any) bool {
	// From https://tc39.github.io/ecma262/#sec-iteratorresult-interface:
	// > [done] is the result status of an iterator `next` method call. If the end of the iterator was reached `done` is `true`.
	// > If the end was not reached `done` is `false` and a value is available.
	// > If a `done` property (either own or inherited) does not exist, it is consider to have the value `false`.
	doneType := tc.getTypeOfPropertyOfType(type_, "done" /* as __String */) || tc.falseType
	return tc.isTypeAssignableTo(__COND__(kind == IterationTypeKindYield, tc.falseType, tc.trueType), doneType)
}

func (tc *TypeChecker) isYieldIteratorResult(type_ Type) bool {
	return tc.isIteratorResult(type_, IterationTypeKindYield)
}

func (tc *TypeChecker) isReturnIteratorResult(type_ Type) bool {
	return tc.isIteratorResult(type_, IterationTypeKindReturn)
}

/**
 * Gets the *yield* and *return* types of an `IteratorResult`-like type.
 *
 * If we are unable to determine a *yield* or a *return* type, `noIterationTypes` is
 * returned to indicate to the caller that it should handle the error. Otherwise, an
 * `IterationTypes` record is returned.
 */

func (tc *TypeChecker) getIterationTypesOfIteratorResult(type_ Type) IterationTypes {
	if tc.isTypeAny(type_) {
		return tc.anyIterationTypes
	}

	cachedTypes := tc.getCachedIterationTypes(type_, "iterationTypesOfIteratorResult")
	if cachedTypes {
		return cachedTypes
	}

	// As an optimization, if the type is an instantiation of one of the global `IteratorYieldResult<T>`
	// or `IteratorReturnResult<TReturn>` types, then just grab its type argument.
	if tc.isReferenceToType(type_, tc.getGlobalIteratorYieldResultType(false)) {
		yieldType := tc.getTypeArguments(type_ /* as GenericType */)[0]
		return tc.setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", tc.createIterationTypes(yieldType /*returnType*/, nil /*nextType*/, nil))
	}
	if tc.isReferenceToType(type_, tc.getGlobalIteratorReturnResultType(false)) {
		returnType := tc.getTypeArguments(type_ /* as GenericType */)[0]
		return tc.setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", tc.createIterationTypes(nil, returnType /*nextType*/, nil))
	}

	// Choose any constituents that can produce the requested iteration type.
	yieldIteratorResult := tc.filterType(type_, tc.isYieldIteratorResult)
	var yieldType Type
	if yieldIteratorResult != tc.neverType {
		yieldType = tc.getTypeOfPropertyOfType(yieldIteratorResult, "value" /* as __String */)
	} else {
		yieldType = nil
	}

	returnIteratorResult := tc.filterType(type_, tc.isReturnIteratorResult)
	var returnType Type
	if returnIteratorResult != tc.neverType {
		returnType = tc.getTypeOfPropertyOfType(returnIteratorResult, "value" /* as __String */)
	} else {
		returnType = nil
	}

	if !yieldType && !returnType {
		return tc.setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", tc.noIterationTypes)
	}

	// From https://tc39.github.io/ecma262/#sec-iteratorresult-interface
	// > ... If the iterator does not have a return value, `value` is `undefined`. In that case, the
	// > `value` property may be absent from the conforming object if it does not inherit an explicit
	// > `value` property.
	return tc.setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", tc.createIterationTypes(yieldType, returnType || tc.voidType /*nextType*/, nil))
}

/**
 * Gets the *yield*, *return*, and *next* types of a the `next()`, `return()`, or
 * `throw()` method of an `Iterator`-like or `AsyncIterator`-like type.
 *
 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
 * record is returned. Otherwise, we return `undefined`.
 */

func (tc *TypeChecker) getIterationTypesOfMethod(type_ Type, resolver IterationTypesResolver, methodName /* TODO(TS-TO-GO) TypeNode UnionType: "next" | "return" | "throw" */ any, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
	method := tc.getPropertyOfType(type_, methodName /* as __String */)

	// Ignore 'return' or 'throw' if they are missing.
	if !method && methodName != "next" {
		return nil
	}

	var methodType Type
	switch {
	case method && !(methodName == "next" && (method.flags & SymbolFlagsOptional)):
		if methodName == "next" {
			methodType = tc.getTypeOfSymbol(method)
		} else {
			methodType = tc.getTypeWithFacts(tc.getTypeOfSymbol(method), TypeFactsNEUndefinedOrNull)
		}
	default:
		methodType = nil
	}

	if tc.isTypeAny(methodType) {
		return tc.anyIterationTypes
	}

	// Both async and non-async iterators *must* have a `next` method.
	var methodSignatures []Signature
	if methodType {
		methodSignatures = tc.getSignaturesOfType(methodType, SignatureKindCall)
	} else {
		methodSignatures = emptyArray
	}
	if methodSignatures.length == 0 {
		if errorNode {
			var diagnostic DiagnosticMessage
			if methodName == "next" {
				diagnostic = resolver.mustHaveANextMethodDiagnostic
			} else {
				diagnostic = resolver.mustBeAMethodDiagnostic
			}
			if errorOutputContainer {
				/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: errorOutputContainer.errors ??= [] */ TODO
				errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName))
			} else {
				tc.error(errorNode, diagnostic, methodName)
			}
		}
		if methodName == "next" {
			return tc.noIterationTypes
		} else {
			return nil
		}
	}

	// If the method signature comes exclusively from the global iterator or generator type,
	// create iteration types from its type arguments like `getIterationTypesOfIteratorFast`
	// does (so as to remove `undefined` from the next and return types). We arrive here when
	// a contextual type for a generator was not a direct reference to one of those global types,
	// but looking up `methodType` referred to one of them (and nothing else). E.g., in
	// `interface SpecialIterator extends Iterator<number> {}`, `SpecialIterator` is not a
	// reference to `Iterator`, but its `next` member derives exclusively from `Iterator`.
	if methodType. /* ? */ symbol && methodSignatures.length == 1 {
		globalGeneratorType := resolver.getGlobalGeneratorType(false)
		globalIteratorType := resolver.getGlobalIteratorType(false)
		isGeneratorMethod := globalGeneratorType.symbol. /* ? */ members. /* ? */ get(methodName /* as __String */) == methodType.symbol
		isIteratorMethod := !isGeneratorMethod && globalIteratorType.symbol. /* ? */ members. /* ? */ get(methodName /* as __String */) == methodType.symbol
		if isGeneratorMethod || isIteratorMethod {
			var globalType GenericType
			if isGeneratorMethod {
				globalType = globalGeneratorType
			} else {
				globalType = globalIteratorType
			}
			TODO_IDENTIFIER := methodType /* as AnonymousType */
			return tc.createIterationTypes(tc.getMappedType(globalType.typeParameters[0], mapper), tc.getMappedType(globalType.typeParameters[1], mapper), __COND__(methodName == "next", tc.getMappedType(globalType.typeParameters[2], mapper), nil))
		}
	}

	// Extract the first parameter and return type of each signature.
	var methodParameterTypes *[]Type
	var methodReturnTypes *[]Type
	for _, signature := range methodSignatures {
		if methodName != "throw" && some(signature.parameters) {
			methodParameterTypes = append(methodParameterTypes, tc.getTypeAtPosition(signature, 0))
		}
		methodReturnTypes = append(methodReturnTypes, tc.getReturnTypeOfSignature(signature))
	}

	// Resolve the *next* or *return* type from the first parameter of a `next()` or
	// `return()` method, respectively.
	var returnTypes *[]Type
	var nextType Type
	if methodName != "throw" {
		var methodParameterType Type
		if methodParameterTypes {
			methodParameterType = tc.getUnionType(methodParameterTypes)
		} else {
			methodParameterType = tc.unknownType
		}
		if methodName == "next" {
			// The value of `next(value)` is *not* awaited by async generators
			nextType = methodParameterType
		} else if methodName == "return" {
			// The value of `return(value)` *is* awaited by async generators
			resolvedMethodParameterType := resolver.resolveIterationType(methodParameterType, errorNode) || tc.anyType
			returnTypes = append(returnTypes, resolvedMethodParameterType)
		}
	}

	// Resolve the *yield* and *return* types from the return type of the method (i.e. `IteratorResult`)
	var yieldType Type
	var methodReturnType Type
	if methodReturnTypes {
		methodReturnType = tc.getIntersectionType(methodReturnTypes)
	} else {
		methodReturnType = tc.neverType
	}
	resolvedMethodReturnType := resolver.resolveIterationType(methodReturnType, errorNode) || tc.anyType
	iterationTypes := tc.getIterationTypesOfIteratorResult(resolvedMethodReturnType)
	if iterationTypes == tc.noIterationTypes {
		if errorNode {
			if errorOutputContainer {
				/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: errorOutputContainer.errors ??= [] */ TODO
				errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName))
			} else {
				tc.error(errorNode, resolver.mustHaveAValueDiagnostic, methodName)
			}
		}
		yieldType = tc.anyType
		returnTypes = append(returnTypes, tc.anyType)
	} else {
		yieldType = iterationTypes.yieldType
		returnTypes = append(returnTypes, iterationTypes.returnType)
	}

	return tc.createIterationTypes(yieldType, tc.getUnionType(returnTypes), nextType)
}

/**
 * Gets the *yield*, *return*, and *next* types of an `Iterator`-like or `AsyncIterator`-like
 * type from its members.
 *
 * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
 * record is returned. Otherwise, `noIterationTypes` is returned.
 *
 * NOTE: You probably don't want to call this directly and should be calling
 * `getIterationTypesOfIterator` instead.
 */

func (tc *TypeChecker) getIterationTypesOfIteratorSlow(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer * /* TODO(TS-TO-GO) TypeNode TypeLiteral: { errors: Diagnostic[] | undefined; } */ any, noCache bool) IterationTypes {
	iterationTypes := tc.combineIterationTypes([]*IterationTypes{tc.getIterationTypesOfMethod(type_, resolver, "next", errorNode, errorOutputContainer), tc.getIterationTypesOfMethod(type_, resolver, "return", errorNode, errorOutputContainer), tc.getIterationTypesOfMethod(type_, resolver, "throw", errorNode, errorOutputContainer)})
	if noCache {
		return iterationTypes
	} else {
		return tc.setCachedIterationTypes(type_, resolver.iteratorCacheKey, iterationTypes)
	}
}

/**
 * Gets the requested "iteration type" from a type that is either `Iterable`-like, `Iterator`-like,
 * `IterableIterator`-like, or `Generator`-like (for a non-async generator); or `AsyncIterable`-like,
 * `AsyncIterator`-like, `AsyncIterableIterator`-like, or `AsyncGenerator`-like (for an async generator).
 */

func (tc *TypeChecker) getIterationTypeOfGeneratorFunctionReturnType(kind IterationTypeKind, returnType Type, isAsyncGenerator bool) Type {
	if tc.isTypeAny(returnType) {
		return nil
	}

	iterationTypes := tc.getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator)
	return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)]
}

func (tc *TypeChecker) getIterationTypesOfGeneratorFunctionReturnType(type_ Type, isAsyncGenerator bool) *IterationTypes {
	if tc.isTypeAny(type_) {
		return tc.anyIterationTypes
	}

	var use /* TODO(TS-TO-GO) inferred type IterationUse.AllowsSyncIterablesFlag | IterationUse.AllowsAsyncIterablesFlag */ any
	if isAsyncGenerator {
		use = IterationUseAsyncGeneratorReturnType
	} else {
		use = IterationUseGeneratorReturnType
	}
	var resolver IterationTypesResolver
	if isAsyncGenerator {
		resolver = tc.asyncIterationTypesResolver
	} else {
		resolver = tc.syncIterationTypesResolver
	}
	return tc.getIterationTypesOfIterable(type_, use /*errorNode*/, nil) || tc.getIterationTypesOfIterator(type_, resolver /*errorNode*/, nil /*errorOutputContainer*/, nil)
}

func (tc *TypeChecker) checkBreakOrContinueStatement(node BreakOrContinueStatement) {
	// Grammar checking
	if !tc.checkGrammarStatementInAmbientContext(node) {
		tc.checkGrammarBreakOrContinueStatement(node)
	}

	// TODO: Check that target label is valid
}

func (tc *TypeChecker) unwrapReturnType(returnType Type, functionFlags FunctionFlags) Type {
	isGenerator := !!(functionFlags & FunctionFlagsGenerator)
	isAsync := !!(functionFlags & FunctionFlagsAsync)
	if isGenerator {
		returnIterationType := tc.getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, isAsync)
		if !returnIterationType {
			return tc.errorType
		}
		if isAsync {
			return tc.getAwaitedTypeNoAlias(tc.unwrapAwaitedType(returnIterationType))
		} else {
			return returnIterationType
		}
	}
	if isAsync {
		return tc.getAwaitedTypeNoAlias(returnType) || tc.errorType
	} else {
		return returnType
	}
}

func (tc *TypeChecker) isUnwrappedReturnTypeUndefinedVoidOrAny(func_ SignatureDeclaration, returnType Type) bool {
	type_ := tc.unwrapReturnType(returnType, getFunctionFlags(func_))
	return !!(type_ && (tc.maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)))
}

func (tc *TypeChecker) checkReturnStatement(node ReturnStatement) {
	// Grammar checking
	if tc.checkGrammarStatementInAmbientContext(node) {
		return
	}

	container := getContainingFunctionOrClassStaticBlock(node)
	if container && isClassStaticBlockDeclaration(container) {
		tc.grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block)
		return
	}

	if !container {
		tc.grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body)
		return
	}

	signature := tc.getSignatureFromDeclaration(container)
	returnType := tc.getReturnTypeOfSignature(signature)
	functionFlags := getFunctionFlags(container)
	if tc.strictNullChecks || node.expression || returnType.flags&TypeFlagsNever {
		var exprType Type
		if node.expression {
			exprType = tc.checkExpressionCached(node.expression)
		} else {
			exprType = tc.undefinedType
		}
		if container.kind == SyntaxKindSetAccessor {
			if node.expression {
				tc.error(node, Diagnostics.Setters_cannot_return_a_value)
			}
		} else if container.kind == SyntaxKindConstructor {
			if node.expression && !tc.checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression) {
				tc.error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class)
			}
		} else if tc.getReturnTypeFromAnnotation(container) {
			unwrappedReturnType := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: unwrapReturnType(returnType, functionFlags) ?? returnType */ TODO
			var unwrappedExprType Type
			if functionFlags & FunctionFlagsAsync {
				unwrappedExprType = tc.checkAwaitedType(exprType /*withAlias*/, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
			} else {
				unwrappedExprType = exprType
			}
			if unwrappedReturnType {
				// If the function has a return type, but promisedType is
				// undefined, an error will be reported in checkAsyncFunctionReturnType
				// so we don't need to report one here.
				tc.checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression)
			}
		}
	} else if container.kind != SyntaxKindConstructor && tc.compilerOptions.noImplicitReturns && !tc.isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType) {
		// The function has a return type, but the return statement doesn't have an expression.
		tc.error(node, Diagnostics.Not_all_code_paths_return_a_value)
	}
}

func (tc *TypeChecker) checkWithStatement(node WithStatement) {
	// Grammar checking for withStatement
	if !tc.checkGrammarStatementInAmbientContext(node) {
		if node.flags & NodeFlagsAwaitContext {
			tc.grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block)
		}
	}

	tc.checkExpression(node.expression)

	sourceFile := getSourceFileOfNode(node)
	if !tc.hasParseDiagnostics(sourceFile) {
		start := getSpanOfTokenAtPosition(sourceFile, node.pos).start
		end := node.statement.pos
		tc.grammarErrorAtPos(sourceFile, start, end-start, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any)
	}
}

func (tc *TypeChecker) checkSwitchStatement(node SwitchStatement) {
	// Grammar checking
	tc.checkGrammarStatementInAmbientContext(node)

	var firstDefaultClause CaseOrDefaultClause
	hasDuplicateDefaultClause := false

	expressionType := tc.checkExpression(node.expression)

	forEach(node.caseBlock.clauses, func(clause /* TODO(TS-TO-GO) inferred type CaseClause | DefaultClause */ any) {
		// Grammar check for duplicate default clauses, skip if we already report duplicate default clause
		if clause.kind == SyntaxKindDefaultClause && !hasDuplicateDefaultClause {
			if firstDefaultClause == nil {
				firstDefaultClause = clause
			} else {
				tc.grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement)
				hasDuplicateDefaultClause = true
			}
		}

		if clause.kind == SyntaxKindCaseClause {
			tc.addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause))
		}
		forEach(clause.statements, tc.checkSourceElement)
		if tc.compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && tc.isReachableFlowNode(clause.fallthroughFlowNode) {
			tc.error(clause, Diagnostics.Fallthrough_case_in_switch)
		}

		createLazyCaseClauseDiagnostics := func(clause CaseClause) /* TODO(TS-TO-GO) inferred type () => void */ any {
			return func() {
				// TypeScript 1.0 spec (April 2014): 5.9
				// In a 'switch' statement, each 'case' expression must be of a type that is comparable
				// to or from the type of the 'switch' expression.
				caseType := tc.checkExpression(clause.expression)

				if !tc.isTypeEqualityComparableTo(expressionType, caseType) {
					// expressionType is not comparable to caseType, try the reversed check and report errors if it fails
					tc.checkTypeComparableTo(caseType, expressionType, clause.expression /*headMessage*/, nil)
				}
			}
		}

	})
	if node.caseBlock.locals {
		tc.registerForUnusedIdentifiersCheck(node.caseBlock)
	}
}

func (tc *TypeChecker) checkLabeledStatement(node LabeledStatement) {
	// Grammar checking
	if !tc.checkGrammarStatementInAmbientContext(node) {
		findAncestor(node.parent, func(current Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
			if isFunctionLike(current) {
				return "quit"
			}
			if current.kind == SyntaxKindLabeledStatement && (current /* as LabeledStatement */).label.escapedText == node.label.escapedText {
				tc.grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label))
				return true
			}
			return false
		})
	}

	// ensure that label is unique
	tc.checkSourceElement(node.statement)
}

func (tc *TypeChecker) checkThrowStatement(node ThrowStatement) {
	// Grammar checking
	if !tc.checkGrammarStatementInAmbientContext(node) {
		if isIdentifier(node.expression) && !node.expression.escapedText {
			tc.grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here)
		}
	}

	if node.expression {
		tc.checkExpression(node.expression)
	}
}

func (tc *TypeChecker) checkTryStatement(node TryStatement) {
	// Grammar checking
	tc.checkGrammarStatementInAmbientContext(node)

	tc.checkBlock(node.tryBlock)
	catchClause := node.catchClause
	if catchClause {
		// Grammar checking
		if catchClause.variableDeclaration {
			declaration := catchClause.variableDeclaration
			tc.checkVariableLikeDeclaration(declaration)
			typeNode := getEffectiveTypeAnnotationNode(declaration)
			if typeNode {
				type_ := tc.getTypeFromTypeNode(typeNode)
				if type_ && !(type_.flags & TypeFlagsAnyOrUnknown) {
					tc.grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified)
				}
			} else if declaration.initializer {
				tc.grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer)
			} else {
				blockLocals := catchClause.block.locals
				if blockLocals {
					forEachKey(catchClause.locals, func(caughtName __String) {
						blockLocal := blockLocals.get(caughtName)
						if blockLocal. /* ? */ valueDeclaration && (blockLocal.flags&SymbolFlagsBlockScopedVariable) != 0 {
							tc.grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName))
						}
					})
				}
			}
		}

		tc.checkBlock(catchClause.block)
	}

	if node.finallyBlock {
		tc.checkBlock(node.finallyBlock)
	}
}

func (tc *TypeChecker) checkIndexConstraints(type_ Type, symbol Symbol, isStaticIndex bool) {
	indexInfos := tc.getIndexInfosOfType(type_)
	if indexInfos.length == 0 {
		return
	}
	for _, prop := range tc.getPropertiesOfObjectType(type_) {
		if !(isStaticIndex && prop.flags&SymbolFlagsPrototype) {
			tc.checkIndexConstraintForProperty(type_, prop, tc.getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique /*includeNonPublic*/, true), tc.getNonMissingTypeOfSymbol(prop))
		}
	}
	typeDeclaration := symbol.valueDeclaration
	if typeDeclaration && isClassLike(typeDeclaration) {
		for _, member := range typeDeclaration.members {
			// Only process instance properties with computed names here. Static properties cannot be in conflict with indexers,
			// and properties with literal names were already checked.
			if !isStatic(member) && !tc.hasBindableName(member) {
				symbol := tc.getSymbolOfDeclaration(member)
				tc.checkIndexConstraintForProperty(type_, symbol, tc.getTypeOfExpression((member /* as DynamicNamedDeclaration */).name.expression), tc.getNonMissingTypeOfSymbol(symbol))
			}
		}
	}
	if indexInfos.length > 1 {
		for _, info := range indexInfos {
			tc.checkIndexConstraintForIndexSignature(type_, info)
		}
	}
}

func (tc *TypeChecker) checkIndexConstraintForProperty(type_ Type, prop Symbol, propNameType Type, propType Type) {
	declaration := prop.valueDeclaration
	name := getNameOfDeclaration(declaration)
	if name && isPrivateIdentifier(name) {
		return
	}
	indexInfos := tc.getApplicableIndexInfos(type_, propNameType)
	var interfaceDeclaration Declaration
	if getObjectFlags(type_) & ObjectFlagsInterface {
		interfaceDeclaration = getDeclarationOfKind(type_.symbol, SyntaxKindInterfaceDeclaration)
	} else {
		interfaceDeclaration = nil
	}
	var propDeclaration Declaration
	if declaration && declaration.kind == SyntaxKindBinaryExpression || name && name.kind == SyntaxKindComputedPropertyName {
		propDeclaration = declaration
	} else {
		propDeclaration = nil
	}
	var localPropDeclaration Declaration
	if tc.getParentOfSymbol(prop) == type_.symbol {
		localPropDeclaration = declaration
	} else {
		localPropDeclaration = nil
	}
	for _, info := range indexInfos {
		var localIndexDeclaration *IndexSignatureDeclaration
		if info.declaration && tc.getParentOfSymbol(tc.getSymbolOfDeclaration(info.declaration)) == type_.symbol {
			localIndexDeclaration = info.declaration
		} else {
			localIndexDeclaration = nil
		}
		// We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared
		// in the containing type, or (c) the containing type is an interface and no base interface contains both the property and
		// the index signature (i.e. property and index signature are declared in separate inherited interfaces).
		errorNode := localPropDeclaration || localIndexDeclaration || (__COND__(interfaceDeclaration && !some(tc.getBaseTypes(type_ /* as InterfaceType */), func(base BaseType) bool {
			return !!tc.getPropertyOfObjectType(base, prop.escapedName) && !!tc.getIndexTypeOfType(base, info.keyType)
		}), interfaceDeclaration, nil))
		if errorNode && !tc.isTypeAssignableTo(propType, info.type_) {
			diagnostic := tc.createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, tc.symbolToString(prop), tc.typeToString(propType), tc.typeToString(info.keyType), tc.typeToString(info.type_))
			if propDeclaration && errorNode != propDeclaration {
				addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, tc.symbolToString(prop)))
			}
			tc.diagnostics.add(diagnostic)
		}
	}
}

func (tc *TypeChecker) checkIndexConstraintForIndexSignature(type_ Type, checkInfo IndexInfo) {
	declaration := checkInfo.declaration
	indexInfos := tc.getApplicableIndexInfos(type_, checkInfo.keyType)
	var interfaceDeclaration Declaration
	if getObjectFlags(type_) & ObjectFlagsInterface {
		interfaceDeclaration = getDeclarationOfKind(type_.symbol, SyntaxKindInterfaceDeclaration)
	} else {
		interfaceDeclaration = nil
	}
	var localCheckDeclaration *IndexSignatureDeclaration
	if declaration && tc.getParentOfSymbol(tc.getSymbolOfDeclaration(declaration)) == type_.symbol {
		localCheckDeclaration = declaration
	} else {
		localCheckDeclaration = nil
	}
	for _, info := range indexInfos {
		if info == checkInfo {
			continue
		}
		var localIndexDeclaration *IndexSignatureDeclaration
		if info.declaration && tc.getParentOfSymbol(tc.getSymbolOfDeclaration(info.declaration)) == type_.symbol {
			localIndexDeclaration = info.declaration
		} else {
			localIndexDeclaration = nil
		}
		// We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index
		// signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains
		// both index signatures (i.e. the index signatures are declared in separate inherited interfaces).
		errorNode := localCheckDeclaration || localIndexDeclaration || (__COND__(interfaceDeclaration && !some(tc.getBaseTypes(type_ /* as InterfaceType */), func(base BaseType) bool {
			return !!tc.getIndexInfoOfType(base, checkInfo.keyType) && !!tc.getIndexTypeOfType(base, info.keyType)
		}), interfaceDeclaration, nil))
		if errorNode && !tc.isTypeAssignableTo(checkInfo.type_, info.type_) {
			tc.error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, tc.typeToString(checkInfo.keyType), tc.typeToString(checkInfo.type_), tc.typeToString(info.keyType), tc.typeToString(info.type_))
		}
	}
}

func (tc *TypeChecker) checkTypeNameIsReserved(name Identifier, message DiagnosticMessage) {
	// TS 1.0 spec (April 2014): 3.6.1
	// The predefined type keywords are reserved and cannot be used as names of user defined types.
	switch name.escapedText {
	case "any",
		"unknown",
		"never",
		"number",
		"bigint",
		"boolean",
		"string",
		"symbol",
		"void",
		"object",
		"undefined":
		tc.error(name, message, name.escapedText /* as string */)
	}
}

/**
 * The name cannot be used as 'Object' of user defined types with special target.
 */

func (tc *TypeChecker) checkClassNameCollisionWithObject(name Identifier) {
	if tc.languageVersion >= ScriptTargetES5 && name.escapedText == "Object" && host.getEmitModuleFormatOfFile(getSourceFileOfNode(name)) < ModuleKindES2015 {
		tc.error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ModuleKind[tc.moduleKind])
		// https://github.com/Microsoft/TypeScript/issues/17494
	}
}

func (tc *TypeChecker) checkUnmatchedJSDocParameters(node SignatureDeclaration) {
	jsdocParameters := filter(getJSDocTags(node), isJSDocParameterTag)
	if !length(jsdocParameters) {
		return
	}

	isJs := isInJSFile(node)
	parameters := NewSet[__String]()
	excludedParameters := NewSet[number]()
	forEach(node.parameters, func(TODO_IDENTIFIER ParameterDeclaration, index number) {
		if isIdentifier(name) {
			parameters.add(name.escapedText)
		}
		if isBindingPattern(name) {
			excludedParameters.add(index)
		}
	})

	containsArguments := tc.containsArgumentsReference(node)
	if containsArguments {
		lastJSDocParamIndex := jsdocParameters.length - 1
		lastJSDocParam := jsdocParameters[lastJSDocParamIndex]
		if isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression && lastJSDocParam.typeExpression.type_ && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !tc.isArrayType(tc.getTypeFromTypeNode(lastJSDocParam.typeExpression.type_)) {
			tc.error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name))
		}
	} else {
		forEach(jsdocParameters, func(TODO_IDENTIFIER JSDocParameterTag, index number) {
			if excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText) {
				return
			}
			if isQualifiedName(name) {
				if isJs {
					tc.error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left))
				}
			} else {
				if !isNameFirst {
					tc.errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name))
				}
			}
		})
	}
}

/**
 * Check each type parameter and check that type parameters have no duplicate type parameter declarations
 */

func (tc *TypeChecker) checkTypeParameters(typeParameterDeclarations *[]TypeParameterDeclaration) {
	seenDefault := false
	if typeParameterDeclarations {
		for i := 0; i < typeParameterDeclarations.length; i++ {
			node := typeParameterDeclarations[i]
			tc.checkTypeParameter(node)

			tc.addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i))
		}
	}

	createCheckTypeParameterDiagnostic := func(node TypeParameterDeclaration, i number) /* TODO(TS-TO-GO) inferred type () => void */ any {
		return func() {
			if node.default_ {
				seenDefault = true
				tc.checkTypeParametersNotReferenced(node.default_, typeParameterDeclarations, i)
			} else if seenDefault {
				tc.error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters)
			}
			for j := 0; j < i; j++ {
				if typeParameterDeclarations[j].symbol == node.symbol {
					tc.error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name))
				}
			}
		}
	}

}

/** Check that type parameter defaults only reference previously declared type parameters */

func (tc *TypeChecker) checkTypeParametersNotReferenced(root TypeNode, typeParameters []TypeParameterDeclaration, index number) {
	visit(root)
	visit := func(node Node) {
		if node.kind == SyntaxKindTypeReference {
			type_ := tc.getTypeFromTypeReference(node /* as TypeReferenceNode */)
			if type_.flags & TypeFlagsTypeParameter {
				for i := index; i < typeParameters.length; i++ {
					if type_.symbol == tc.getSymbolOfDeclaration(typeParameters[i]) {
						tc.error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters)
					}
				}
			}
		}
		forEachChild(node, visit)
	}

}

/** Check that type parameter lists are identical across multiple declarations */

func (tc *TypeChecker) checkTypeParameterListsIdentical(symbol Symbol) {
	if symbol.declarations && symbol.declarations.length == 1 {
		return
	}

	links := tc.getSymbolLinks(symbol)
	if !links.typeParametersChecked {
		links.typeParametersChecked = true
		declarations := tc.getClassOrInterfaceDeclarationsOfSymbol(symbol)
		if !declarations || declarations.length <= 1 {
			return
		}

		type_ := tc.getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */
		if !tc.areTypeParametersIdentical(declarations, type_.localTypeParameters, getEffectiveTypeParameterDeclarations) {
			// Report an error on every conflicting declaration.
			name := tc.symbolToString(symbol)
			for _, declaration := range declarations {
				tc.error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name)
			}
		}
	}
}

func (tc *TypeChecker) areTypeParametersIdentical(declarations []T, targetParameters []TypeParameter, getTypeParameterDeclarations func(node T) []TypeParameterDeclaration) bool {
	maxTypeArgumentCount := length(targetParameters)
	minTypeArgumentCount := tc.getMinTypeArgumentCount(targetParameters)

	for _, declaration := range declarations {
		// If this declaration has too few or too many type parameters, we report an error
		sourceParameters := getTypeParameterDeclarations(declaration)
		numTypeParameters := sourceParameters.length
		if numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount {
			return false
		}

		for i := 0; i < numTypeParameters; i++ {
			source := sourceParameters[i]
			target := targetParameters[i]

			// If the type parameter node does not have the same as the resolved type
			// parameter at this position, we report an error.
			if source.name.escapedText != target.symbol.escapedName {
				return false
			}

			// If the type parameter node does not have an identical constraint as the resolved
			// type parameter at this position, we report an error.
			constraint := getEffectiveConstraintOfTypeParameter(source)
			sourceConstraint := constraint && tc.getTypeFromTypeNode(constraint)
			targetConstraint := tc.getConstraintOfTypeParameter(target)
			// relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with
			// a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)
			if sourceConstraint && targetConstraint && !tc.isTypeIdenticalTo(sourceConstraint, targetConstraint) {
				return false
			}

			// If the type parameter node has a default and it is not identical to the default
			// for the type parameter at this position, we report an error.
			sourceDefault := source.default_ && tc.getTypeFromTypeNode(source.default_)
			targetDefault := tc.getDefaultFromTypeParameter(target)
			if sourceDefault && targetDefault && !tc.isTypeIdenticalTo(sourceDefault, targetDefault) {
				return false
			}
		}
	}

	return true
}

func (tc *TypeChecker) getFirstTransformableStaticClassElement(node ClassLikeDeclaration) * /* TODO(TS-TO-GO) inferred type ClassLikeDeclaration | ClassStaticBlockDeclaration | Decorator | PrivateIdentifierPropertyDeclaration | PrivateIdentifierMethodDeclaration | PrivateIdentifierGetAccessorDeclaration | PrivateIdentifierSetAccessorDeclaration | (PropertyDeclaration & { initializer: Expression; }) */ any {
	willTransformStaticElementsOfDecoratedClass := !tc.legacyDecorators && tc.languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators && classOrConstructorParameterIsDecorated(false, node)
	willTransformPrivateElementsOrClassStaticBlocks := tc.languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || tc.languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
	willTransformInitializers := !tc.emitStandardClassFields
	if willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks {
		for _, member := range node.members {
			if willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(false, member, node) {
				return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: firstOrUndefined(getDecorators(node)) ?? node */ TODO
			} else if willTransformPrivateElementsOrClassStaticBlocks {
				if isClassStaticBlockDeclaration(member) {
					return member
				} else if isStatic(member) {
					if isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member) {
						return member
					}
				}
			}
		}
	}
}

func (tc *TypeChecker) checkClassExpressionExternalHelpers(node ClassExpression) {
	if node.name {
		return
	}

	parent := walkUpOuterExpressions(node)
	if !isNamedEvaluationSource(parent) {
		return
	}

	willTransformESDecorators := !tc.legacyDecorators && tc.languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
	var location Node
	if willTransformESDecorators && classOrConstructorParameterIsDecorated(false, node) {
		location = /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: firstOrUndefined(getDecorators(node)) ?? node */ TODO
	} else {
		location = tc.getFirstTransformableStaticClassElement(node)
	}

	if location {
		tc.checkExternalEmitHelpers(location, ExternalEmitHelpersSetFunctionName)
		if (isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name) {
			tc.checkExternalEmitHelpers(location, ExternalEmitHelpersPropKey)
		}
	}
}

func (tc *TypeChecker) checkClassExpression(node ClassExpression) Type {
	tc.checkClassLikeDeclaration(node)
	tc.checkNodeDeferred(node)
	tc.checkClassExpressionExternalHelpers(node)
	return tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node))
}

func (tc *TypeChecker) checkClassExpressionDeferred(node ClassExpression) {
	forEach(node.members, tc.checkSourceElement)
	tc.registerForUnusedIdentifiersCheck(node)
}

func (tc *TypeChecker) checkClassDeclaration(node ClassDeclaration) {
	firstDecorator := find(node.modifiers, isDecorator)
	if tc.legacyDecorators && firstDecorator && some(node.members, func(p ClassElement) bool {
		return hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p)
	}) {
		tc.grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator)
	}
	if !node.name && !hasSyntacticModifier(node, ModifierFlagsDefault) {
		tc.grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name)
	}
	tc.checkClassLikeDeclaration(node)
	forEach(node.members, tc.checkSourceElement)

	tc.registerForUnusedIdentifiersCheck(node)
}

func (tc *TypeChecker) checkClassLikeDeclaration(node ClassLikeDeclaration) {
	tc.checkGrammarClassLikeDeclaration(node)
	tc.checkDecorators(node)
	tc.checkCollisionsForDeclarationName(node, node.name)
	tc.checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
	tc.checkExportsOnMergedDeclarations(node)
	symbol := tc.getSymbolOfDeclaration(node)
	type_ := tc.getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */
	typeWithThis := tc.getTypeWithThisArgument(type_)
	staticType := tc.getTypeOfSymbol(symbol) /* as ObjectType */
	tc.checkTypeParameterListsIdentical(symbol)
	tc.checkFunctionOrConstructorSymbol(symbol)
	tc.checkClassForDuplicateDeclarations(node)

	// Only check for reserved static identifiers on non-ambient context.
	nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
	if !nodeInAmbientContext {
		tc.checkClassForStaticPropertyNameConflicts(node)
	}

	baseTypeNode := getEffectiveBaseTypeNode(node)
	if baseTypeNode {
		forEach(baseTypeNode.typeArguments, tc.checkSourceElement)
		if tc.languageVersion < LanguageFeatureMinimumTargetClasses {
			tc.checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpersExtends)
		}
		// check both @extends and extends if both are specified.
		extendsNode := getClassExtendsHeritageElement(node)
		if extendsNode && extendsNode != baseTypeNode {
			tc.checkExpression(extendsNode.expression)
		}

		baseTypes := tc.getBaseTypes(type_)
		if baseTypes.length {
			tc.addLazyDiagnostic(func() {
				baseType := baseTypes[0]
				baseConstructorType := tc.getBaseConstructorTypeOfClass(type_)
				staticBaseType := tc.getApparentType(baseConstructorType)
				tc.checkBaseTypeAccessibility(staticBaseType, baseTypeNode)
				tc.checkSourceElement(baseTypeNode.expression)
				if some(baseTypeNode.typeArguments) {
					forEach(baseTypeNode.typeArguments, tc.checkSourceElement)
					for _, constructor := range tc.getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode) {
						if !tc.checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters) {
							break
						}
					}
				}
				baseWithThis := tc.getTypeWithThisArgument(baseType, type_.thisType)
				if !tc.checkTypeAssignableTo(typeWithThis, baseWithThis /*errorNode*/, nil) {
					tc.issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1)
				} else {
					// Report static side error only when instance type is assignable
					tc.checkTypeAssignableTo(staticType, tc.getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1)
				}
				if baseConstructorType.flags & TypeFlagsTypeVariable {
					if !tc.isMixinConstructorType(staticType) {
						tc.error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any)
					} else {
						constructSignatures := tc.getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
						if constructSignatures.some(func(signature Signature) number {
							return signature.flags & SignatureFlagsAbstract
						}) && !hasSyntacticModifier(node, ModifierFlagsAbstract) {
							tc.error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract)
						}
					}
				}

				if !(staticBaseType.symbol && staticBaseType.symbol.flags&SymbolFlagsClass) && !(baseConstructorType.flags & TypeFlagsTypeVariable) {
					// When the static base type is a "class-like" constructor function (but not actually a class), we verify
					// that all instantiated base constructor signatures return the same type.
					constructors := tc.getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)
					if forEach(constructors, func(sig Signature) bool {
						return !tc.isJSConstructor(sig.declaration) && !tc.isTypeIdenticalTo(tc.getReturnTypeOfSignature(sig), baseType)
					}) {
						tc.error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type)
					}
				}
				tc.checkKindsOfPropertyMemberOverrides(type_, baseType)
			})
		}
	}

	tc.checkMembersForOverrideModifier(node, type_, typeWithThis, staticType)

	implementedTypeNodes := getEffectiveImplementsTypeNodes(node)
	if implementedTypeNodes {
		for _, typeRefNode := range implementedTypeNodes {
			if !isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression) {
				tc.error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments)
			}
			tc.checkTypeReferenceNode(typeRefNode)
			tc.addLazyDiagnostic(createImplementsDiagnostics(typeRefNode))
		}
	}

	tc.addLazyDiagnostic(func() {
		tc.checkIndexConstraints(type_, symbol)
		tc.checkIndexConstraints(staticType, symbol /*isStaticIndex*/, true)
		tc.checkTypeForDuplicateIndexSignatures(node)
		tc.checkPropertyInitialization(node)
	})

	createImplementsDiagnostics := func(typeRefNode ExpressionWithTypeArguments) /* TODO(TS-TO-GO) inferred type () => void */ any {
		return func() {
			t := tc.getReducedType(tc.getTypeFromTypeNode(typeRefNode))
			if !tc.isErrorType(t) {
				if tc.isValidBaseType(t) {
					var genericDiag DiagnosticMessage
					if t.symbol && t.symbol.flags&SymbolFlagsClass {
						genericDiag = Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass
					} else {
						genericDiag = Diagnostics.Class_0_incorrectly_implements_interface_1
					}
					baseWithThis := tc.getTypeWithThisArgument(t, type_.thisType)
					if !tc.checkTypeAssignableTo(typeWithThis, baseWithThis /*errorNode*/, nil) {
						tc.issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag)
					}
				} else {
					tc.error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members)
				}
			}
		}
	}

}

func (tc *TypeChecker) checkMembersForOverrideModifier(node ClassLikeDeclaration, type_ InterfaceType, typeWithThis Type, staticType ObjectType) {
	baseTypeNode := getEffectiveBaseTypeNode(node)
	baseTypes := baseTypeNode && tc.getBaseTypes(type_)
	var baseWithThis Type
	if baseTypes. /* ? */ length {
		baseWithThis = tc.getTypeWithThisArgument(first(baseTypes), type_.thisType)
	} else {
		baseWithThis = nil
	}
	baseStaticType := tc.getBaseConstructorTypeOfClass(type_)

	for _, member := range node.members {
		if hasAmbientModifier(member) {
			continue
		}

		if isConstructorDeclaration(member) {
			forEach(member.parameters, func(param ParameterDeclaration) {
				if isParameterPropertyDeclaration(param, member) {
					tc.checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, param, true)
				}
			})
		}
		tc.checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, member, false)
	}
}

/**
 * @param member Existing member node to be checked.
 * Note: `member` cannot be a synthetic node.
 */

func (tc *TypeChecker) checkExistingMemberForOverrideModifier(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis Type, type_ InterfaceType, typeWithThis Type, member /* TODO(TS-TO-GO) TypeNode UnionType: ClassElement | ParameterPropertyDeclaration */ any, memberIsParameterProperty bool, reportErrors bool /*  = true */) MemberOverrideStatus {
	declaredProp := member.name && tc.getSymbolAtLocation(member.name) || tc.getSymbolAtLocation(member)
	if !declaredProp {
		return MemberOverrideStatusOk
	}

	return tc.checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, declaredProp, __COND__(reportErrors, member, nil))
}

/**
 * Checks a class member declaration for either a missing or an invalid `override` modifier.
 * Note: this function can be used for speculative checking,
 * i.e. checking a member that does not yet exist in the program.
 * An example of that would be to call this function in a completions scenario,
 * when offering a method declaration as completion.
 * @param errorNode The node where we should report an error, or undefined if we should not report errors.
 */

func (tc *TypeChecker) checkMemberForOverrideModifier(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis Type, type_ InterfaceType, typeWithThis Type, memberHasOverrideModifier bool, memberHasAbstractModifier bool, memberIsStatic bool, memberIsParameterProperty bool, member Symbol, errorNode Node) MemberOverrideStatus {
	isJs := isInJSFile(node)
	nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
	if baseWithThis && (memberHasOverrideModifier || tc.compilerOptions.noImplicitOverride) {
		var thisType Type
		if memberIsStatic {
			thisType = staticType
		} else {
			thisType = typeWithThis
		}
		var baseType Type
		if memberIsStatic {
			baseType = baseStaticType
		} else {
			baseType = baseWithThis
		}
		prop := tc.getPropertyOfType(thisType, member.escapedName)
		baseProp := tc.getPropertyOfType(baseType, member.escapedName)

		baseClassName := tc.typeToString(baseWithThis)
		if prop && !baseProp && memberHasOverrideModifier {
			if errorNode {
				suggestion := tc.getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType)
				// Again, using symbol name: note that's different from `symbol.escapedName`
				__COND__(suggestion, tc.error(errorNode, __COND__(isJs, Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1, Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1), baseClassName, tc.symbolToString(suggestion)), tc.error(errorNode, __COND__(isJs, Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0, Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0), baseClassName))
			}
			return MemberOverrideStatusHasInvalidOverride
		} else if prop && baseProp. /* ? */ declarations && tc.compilerOptions.noImplicitOverride && !nodeInAmbientContext {
			baseHasAbstract := some(baseProp.declarations, hasAbstractModifier)
			if memberHasOverrideModifier {
				return MemberOverrideStatusOk
			}

			if !baseHasAbstract {
				if errorNode {
					var diag DiagnosticMessage
					switch {
					case memberIsParameterProperty:
						if isJs {
							diag = Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
						} else {
							diag = Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0
						}
					case isJs:
						diag = Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0
					default:
						diag = Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0
					}
					tc.error(errorNode, diag, baseClassName)
				}
				return MemberOverrideStatusNeedsOverride
			} else if memberHasAbstractModifier && baseHasAbstract {
				if errorNode {
					tc.error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName)
				}
				return MemberOverrideStatusNeedsOverride
			}
		}
	} else if memberHasOverrideModifier {
		if errorNode {
			className := tc.typeToString(type_)
			tc.error(errorNode, __COND__(isJs, Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class, Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class), className)
		}
		return MemberOverrideStatusHasInvalidOverride
	}

	return MemberOverrideStatusOk
}

func (tc *TypeChecker) issueMemberSpecificError(node ClassLikeDeclaration, typeWithThis Type, baseWithThis Type, broadDiag DiagnosticMessage) {
	// iterate over all implemented properties and issue errors on each one which isn't compatible, rather than the class as a whole, if possible
	issuedMemberError := false
	for _, member := range node.members {
		if isStatic(member) {
			continue
		}
		declaredProp := member.name && tc.getSymbolAtLocation(member.name) || tc.getSymbolAtLocation(member)
		if declaredProp {
			prop := tc.getPropertyOfType(typeWithThis, declaredProp.escapedName)
			baseProp := tc.getPropertyOfType(baseWithThis, declaredProp.escapedName)
			if prop && baseProp {
				rootChain := func() DiagnosticMessageChain {
					return chainDiagnosticMessages(nil, Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2, tc.symbolToString(declaredProp), tc.typeToString(typeWithThis), tc.typeToString(baseWithThis))
				}
				if !tc.checkTypeAssignableTo(tc.getTypeOfSymbol(prop), tc.getTypeOfSymbol(baseProp), member.name || member /*headMessage*/, nil, rootChain) {
					issuedMemberError = true
				}
			}
		}
	}
	if !issuedMemberError {
		// check again with diagnostics to generate a less-specific error
		tc.checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag)
	}
}

func (tc *TypeChecker) checkBaseTypeAccessibility(type_ Type, node ExpressionWithTypeArguments) {
	signatures := tc.getSignaturesOfType(type_, SignatureKindConstruct)
	if signatures.length {
		declaration := signatures[0].declaration
		if declaration && hasEffectiveModifier(declaration, ModifierFlagsPrivate) {
			typeClassDeclaration := getClassLikeDeclarationOfSymbol(type_.symbol)
			if !tc.isNodeWithinClass(node, typeClassDeclaration) {
				tc.error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, tc.getFullyQualifiedName(type_.symbol))
			}
		}
	}
}

/**
 * Checks a member declaration node to see if has a missing or invalid `override` modifier.
 * @param node Class-like node where the member is declared.
 * @param member Member declaration node.
 * @param memberSymbol Member symbol.
 * Note: `member` can be a synthetic node without a parent.
 */

func (tc *TypeChecker) getMemberOverrideModifierStatus(node ClassLikeDeclaration, member ClassElement, memberSymbol Symbol) MemberOverrideStatus {
	if !member.name {
		return MemberOverrideStatusOk
	}

	classSymbol := tc.getSymbolOfDeclaration(node)
	type_ := tc.getDeclaredTypeOfSymbol(classSymbol) /* as InterfaceType */
	typeWithThis := tc.getTypeWithThisArgument(type_)
	staticType := tc.getTypeOfSymbol(classSymbol) /* as ObjectType */

	baseTypeNode := getEffectiveBaseTypeNode(node)
	baseTypes := baseTypeNode && tc.getBaseTypes(type_)
	var baseWithThis Type
	if baseTypes. /* ? */ length {
		baseWithThis = tc.getTypeWithThisArgument(first(baseTypes), type_.thisType)
	} else {
		baseWithThis = nil
	}
	baseStaticType := tc.getBaseConstructorTypeOfClass(type_)

	var memberHasOverrideModifier bool
	if member.parent {
		memberHasOverrideModifier = hasOverrideModifier(member)
	} else {
		memberHasOverrideModifier = hasSyntacticModifier(member, ModifierFlagsOverride)
	}

	return tc.checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member), false, memberSymbol)
}

func (tc *TypeChecker) getTargetSymbol(s Symbol) Symbol {
	// if symbol is instantiated its flags are not copied from the 'target'
	// so we'll need to get back original 'target' symbol to work with correct set of flags
	// NOTE: cast to TransientSymbol should be safe because only TransientSymbols have CheckFlags.Instantiated
	if getCheckFlags(s) & CheckFlagsInstantiated {
		return (s /* as TransientSymbol */).links.target
	} else {
		return s
	}
}

func (tc *TypeChecker) getClassOrInterfaceDeclarationsOfSymbol(symbol Symbol) *[] /* TODO(TS-TO-GO) inferred type (InterfaceDeclaration | ClassDeclaration) */ any {
	return filter(symbol.declarations, func(d Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: d is ClassDeclaration | InterfaceDeclaration */ any {
		return d.kind == SyntaxKindClassDeclaration || d.kind == SyntaxKindInterfaceDeclaration
	})
}

func (tc *TypeChecker) checkKindsOfPropertyMemberOverrides(type_ InterfaceType, baseType BaseType) {
	// TypeScript 1.0 spec (April 2014): 8.2.3
	// A derived class inherits all members from its base class it doesn't override.
	// Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
	// Both public and private property members are inherited, but only public property members can be overridden.
	// A property member in a derived class is said to override a property member in a base class
	// when the derived class property member has the same name and kind(instance or static)
	// as the base class property member.
	// The type of an overriding property member must be assignable(section 3.8.4)
	// to the type of the overridden property member, or otherwise a compile - time error occurs.
	// Base class instance member functions can be overridden by derived class instance member functions,
	// but not by other kinds of members.
	// Base class instance member variables and accessors can be overridden by
	// derived class instance member variables and accessors, but not by other kinds of members.

	// NOTE: assignability is checked in checkClassDeclaration
	baseProperties := tc.getPropertiesOfType(baseType)

	type MemberInfo struct {
		missedProperties []string
		baseTypeName     string
		typeName         string
	}
	notImplementedInfo := NewMap[ClassLikeDeclaration, MemberInfo]()

basePropertyCheck:
	for _, baseProperty := range baseProperties {
		base := tc.getTargetSymbol(baseProperty)

		if base.flags & SymbolFlagsPrototype {
			continue
		}
		baseSymbol := tc.getPropertyOfObjectType(type_, base.escapedName)
		if !baseSymbol {
			continue
		}
		derived := tc.getTargetSymbol(baseSymbol)
		baseDeclarationFlags := getDeclarationModifierFlagsFromSymbol(base)

		Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.")

		// In order to resolve whether the inherited method was overridden in the base class or not,
		// we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*
		// type declaration, derived and base resolve to the same symbol even in the case of generic classes.
		if derived == base {
			// derived class inherits base without override/redeclaration
			derivedClassDecl := getClassLikeDeclarationOfSymbol(type_.symbol)

			// It is an error to inherit an abstract member without implementing it or being declared abstract.
			// If there is no declaration for the derived class (as in the case of class expressions),
			// then the class cannot be declared abstract.
			if baseDeclarationFlags&ModifierFlagsAbstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlagsAbstract)) {
				// Searches other base types for a declaration that would satisfy the inherited abstract member.
				// (The class may have more than one base type via declaration merging with an interface with the
				// same name.)
				for _, otherBaseType := range tc.getBaseTypes(type_) {
					if otherBaseType == baseType {
						continue
					}
					baseSymbol := tc.getPropertyOfObjectType(otherBaseType, base.escapedName)
					derivedElsewhere := baseSymbol && tc.getTargetSymbol(baseSymbol)
					if derivedElsewhere && derivedElsewhere != base {
						continue basePropertyCheck
					}
				}
				baseTypeName := tc.typeToString(baseType)
				typeName := tc.typeToString(type_)
				basePropertyName := tc.symbolToString(baseProperty)
				missedProperties := append(notImplementedInfo.get(derivedClassDecl). /* ? */ missedProperties, basePropertyName)
				notImplementedInfo.set(derivedClassDecl, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"baseTypeName":     baseTypeName,
					"typeName":         typeName,
					"missedProperties": missedProperties,
				})
			}
		} else {
			// derived overrides base.
			derivedDeclarationFlags := getDeclarationModifierFlagsFromSymbol(derived)
			if baseDeclarationFlags&ModifierFlagsPrivate || derivedDeclarationFlags&ModifierFlagsPrivate {
				// either base or derived property is private - not override, skip it
				continue
			}

			var errorMessage DiagnosticMessage
			basePropertyFlags := base.flags & SymbolFlagsPropertyOrAccessor
			derivedPropertyFlags := derived.flags & SymbolFlagsPropertyOrAccessor
			if basePropertyFlags && derivedPropertyFlags {
				// property/accessor is overridden with property/accessor
				if (__COND__(getCheckFlags(base)&CheckFlagsSynthetic, base.declarations. /* ? */ some(func(d Declaration) bool {
					return tc.isPropertyAbstractOrInterface(d, baseDeclarationFlags)
				}), base.declarations. /* ? */ every(func(d Declaration) bool {
					return tc.isPropertyAbstractOrInterface(d, baseDeclarationFlags)
				}))) || getCheckFlags(base)&CheckFlagsMapped || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) {
					// when the base property is abstract or from an interface, base/derived flags don't need to match
					// for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all*
					// same when the derived property is from an assignment
					continue
				}

				overriddenInstanceProperty := basePropertyFlags != SymbolFlagsProperty && derivedPropertyFlags == SymbolFlagsProperty
				overriddenInstanceAccessor := basePropertyFlags == SymbolFlagsProperty && derivedPropertyFlags != SymbolFlagsProperty
				if overriddenInstanceProperty || overriddenInstanceAccessor {
					var errorMessage DiagnosticMessage
					if overriddenInstanceProperty {
						errorMessage = Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property
					} else {
						errorMessage = Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor
					}
					tc.error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, tc.symbolToString(base), tc.typeToString(baseType), tc.typeToString(type_))
				} else if tc.useDefineForClassFields {
					uninitialized := derived.declarations. /* ? */ find(func(d Declaration) bool {
						return d.kind == SyntaxKindPropertyDeclaration && !(d /* as PropertyDeclaration */).initializer
					})
					if uninitialized && !(derived.flags & SymbolFlagsTransient) && !(baseDeclarationFlags & ModifierFlagsAbstract) && !(derivedDeclarationFlags & ModifierFlagsAbstract) && !derived.declarations. /* ? */ some(func(d Declaration) bool {
						return !!(d.flags & NodeFlagsAmbient)
					}) {
						constructor := findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type_.symbol))
						propName := (uninitialized /* as PropertyDeclaration */).name
						if (uninitialized /* as PropertyDeclaration */).exclamationToken || !constructor || !isIdentifier(propName) || !tc.strictNullChecks || !tc.isPropertyInitializedInConstructor(propName, type_, constructor) {
							errorMessage := Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration
							tc.error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, tc.symbolToString(base), tc.typeToString(baseType))
						}
					}
				}

				// correct case
				continue
			} else if tc.isPrototypeProperty(base) {
				if tc.isPrototypeProperty(derived) || derived.flags&SymbolFlagsProperty {
					// method is overridden with method or property -- correct case
					continue
				} else {
					Debug.assert(!!(derived.flags & SymbolFlagsAccessor))
					errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor
				}
			} else if base.flags & SymbolFlagsAccessor {
				errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function
			} else {
				errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function
			}

			tc.error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, tc.typeToString(baseType), tc.symbolToString(base), tc.typeToString(type_))
		}
	}

	for _, TODO_IDENTIFIER := range notImplementedInfo {
		if length(memberInfo.missedProperties) == 1 {
			if isClassExpression(errorNode) {
				tc.error(errorNode, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, first(memberInfo.missedProperties), memberInfo.baseTypeName)
			} else {
				tc.error(errorNode, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, memberInfo.typeName, first(memberInfo.missedProperties), memberInfo.baseTypeName)
			}
		} else if length(memberInfo.missedProperties) > 5 {
			missedProperties := map_(memberInfo.missedProperties.slice(0, 4), func(prop string) string {
				return __TEMPLATE__("'", prop, "'")
			}).join(", ")
			remainingMissedProperties := length(memberInfo.missedProperties) - 4
			if isClassExpression(errorNode) {
				tc.error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
			} else {
				tc.error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more, memberInfo.typeName, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
			}
		} else {
			missedProperties := map_(memberInfo.missedProperties, func(prop string) string {
				return __TEMPLATE__("'", prop, "'")
			}).join(", ")
			if isClassExpression(errorNode) {
				tc.error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1, memberInfo.baseTypeName, missedProperties)
			} else {
				tc.error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2, memberInfo.typeName, memberInfo.baseTypeName, missedProperties)
			}
		}
	}
}

func (tc *TypeChecker) isPropertyAbstractOrInterface(declaration Declaration, baseDeclarationFlags ModifierFlags) bool {
	return baseDeclarationFlags&ModifierFlagsAbstract && (!isPropertyDeclaration(declaration) || !declaration.initializer) || isInterfaceDeclaration(declaration.parent)
}

func (tc *TypeChecker) getNonInheritedProperties(type_ InterfaceType, baseTypes []BaseType, properties []Symbol) []Symbol {
	if !length(baseTypes) {
		return properties
	}
	seen := NewMap[__String, Symbol]()
	forEach(properties, func(p Symbol) {
		seen.set(p.escapedName, p)
	})

	for _, base := range baseTypes {
		properties := tc.getPropertiesOfType(tc.getTypeWithThisArgument(base, type_.thisType))
		for _, prop := range properties {
			existing := seen.get(prop.escapedName)
			if existing && prop.parent == existing.parent {
				seen.delete(prop.escapedName)
			}
		}
	}

	return arrayFrom(seen.values())
}

func (tc *TypeChecker) checkInheritedPropertiesAreIdentical(type_ InterfaceType, typeNode Node) bool {
	baseTypes := tc.getBaseTypes(type_)
	if baseTypes.length < 2 {
		return true
	}

	type InheritanceInfoMap struct {
		prop           Symbol
		containingType Type
	}
	seen := NewMap[__String, InheritanceInfoMap]()
	forEach(tc.resolveDeclaredMembers(type_).declaredProperties, func(p Symbol) {
		seen.set(p.escapedName, map[any]any{ /* TODO(TS-TO-GO): was object literal */
			"prop":           p,
			"containingType": type_,
		})
	})
	ok := true

	for _, base := range baseTypes {
		properties := tc.getPropertiesOfType(tc.getTypeWithThisArgument(base, type_.thisType))
		for _, prop := range properties {
			existing := seen.get(prop.escapedName)
			if !existing {
				seen.set(prop.escapedName, map[any]any{ /* TODO(TS-TO-GO): was object literal */
					"prop":           prop,
					"containingType": base,
				})
			} else {
				isInheritedProperty := existing.containingType != type_
				if isInheritedProperty && !tc.isPropertyIdenticalTo(existing.prop, prop) {
					ok = false

					typeName1 := tc.typeToString(existing.containingType)
					typeName2 := tc.typeToString(base)

					errorInfo := chainDiagnosticMessages(nil, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, tc.symbolToString(prop), typeName1, typeName2)
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, tc.typeToString(type_), typeName1, typeName2)
					tc.diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo))
				}
			}
		}
	}

	return ok
}

func (tc *TypeChecker) checkPropertyInitialization(node ClassLikeDeclaration) {
	if !tc.strictNullChecks || !tc.strictPropertyInitialization || node.flags&NodeFlagsAmbient {
		return
	}
	constructor := findConstructorDeclaration(node)
	for _, member := range node.members {
		if getEffectiveModifierFlags(member) & ModifierFlagsAmbient {
			continue
		}
		if !isStatic(member) && tc.isPropertyWithoutInitializer(member) {
			propName := (member /* as PropertyDeclaration */).name
			if isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName) {
				type_ := tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(member))
				if !(type_.flags&TypeFlagsAnyOrUnknown || tc.containsUndefinedType(type_)) {
					if !constructor || !tc.isPropertyInitializedInConstructor(propName, type_, constructor) {
						tc.error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName))
					}
				}
			}
		}
	}
}

func (tc *TypeChecker) isPropertyWithoutInitializer(node Node) bool {
	return node.kind == SyntaxKindPropertyDeclaration && !hasAbstractModifier(node) && !(node /* as PropertyDeclaration */).exclamationToken && !(node /* as PropertyDeclaration */).initializer
}

func (tc *TypeChecker) isPropertyInitializedInStaticBlocks(propName /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier */ any, propType Type, staticBlocks []ClassStaticBlockDeclaration, startPos number, endPos number) bool {
	for _, staticBlock := range staticBlocks {
		// static block must be within the provided range as they are evaluated in document order (unlike constructors)
		if staticBlock.pos >= startPos && staticBlock.pos <= endPos {
			reference := factory.createPropertyAccessExpression(factory.createThis(), propName)
			setParent(reference.expression, reference)
			setParent(reference, staticBlock)
			reference.flowNode = staticBlock.returnFlowNode
			flowType := tc.getFlowTypeOfReference(reference, propType, tc.getOptionalType(propType))
			if !tc.containsUndefinedType(flowType) {
				return true
			}
		}
	}
	return false
}

func (tc *TypeChecker) isPropertyInitializedInConstructor(propName /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | PrivateIdentifier | ComputedPropertyName */ any, propType Type, constructor ConstructorDeclaration) bool {
	var reference /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | ElementAccessExpression */ any
	if isComputedPropertyName(propName) {
		reference = factory.createElementAccessExpression(factory.createThis(), propName.expression)
	} else {
		reference = factory.createPropertyAccessExpression(factory.createThis(), propName)
	}
	setParent(reference.expression, reference)
	setParent(reference, constructor)
	reference.flowNode = constructor.returnFlowNode
	flowType := tc.getFlowTypeOfReference(reference, propType, tc.getOptionalType(propType))
	return !tc.containsUndefinedType(flowType)
}

func (tc *TypeChecker) checkInterfaceDeclaration(node InterfaceDeclaration) {
	// Grammar checking
	if !tc.checkGrammarModifiers(node) {
		tc.checkGrammarInterfaceDeclaration(node)
	}

	tc.checkTypeParameters(node.typeParameters)
	tc.addLazyDiagnostic(func() {
		tc.checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0)

		tc.checkExportsOnMergedDeclarations(node)
		symbol := tc.getSymbolOfDeclaration(node)
		tc.checkTypeParameterListsIdentical(symbol)

		// Only check this symbol once
		firstInterfaceDecl := getDeclarationOfKind(symbol, SyntaxKindInterfaceDeclaration)
		if node == firstInterfaceDecl {
			type_ := tc.getDeclaredTypeOfSymbol(symbol) /* as InterfaceType */
			typeWithThis := tc.getTypeWithThisArgument(type_)
			// run subsequent checks only if first set succeeded
			if tc.checkInheritedPropertiesAreIdentical(type_, node.name) {
				for _, baseType := range tc.getBaseTypes(type_) {
					tc.checkTypeAssignableTo(typeWithThis, tc.getTypeWithThisArgument(baseType, type_.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1)
				}
				tc.checkIndexConstraints(type_, symbol)
			}
		}
		tc.checkObjectTypeForDuplicateDeclarations(node)
	})
	forEach(getInterfaceBaseTypeNodes(node), func(heritageElement ExpressionWithTypeArguments) {
		if !isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression) {
			tc.error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments)
		}
		tc.checkTypeReferenceNode(heritageElement)
	})

	forEach(node.members, tc.checkSourceElement)

	tc.addLazyDiagnostic(func() {
		tc.checkTypeForDuplicateIndexSignatures(node)
		tc.registerForUnusedIdentifiersCheck(node)
	})
}

func (tc *TypeChecker) checkTypeAliasDeclaration(node TypeAliasDeclaration) {
	// Grammar checking
	tc.checkGrammarModifiers(node)
	tc.checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
	tc.checkExportsOnMergedDeclarations(node)
	tc.checkTypeParameters(node.typeParameters)
	if node.type_.kind == SyntaxKindIntrinsicKeyword {
		typeParameterCount := length(node.typeParameters)
		var valid bool
		if typeParameterCount == 0 {
			valid = node.name.escapedText == "BuiltinIteratorReturn"
		} else {
			valid = typeParameterCount == 1 && intrinsicTypeKinds.has(node.name.escapedText /* as string */)
		}
		if !valid {
			tc.error(node.type_, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types)
		}
	} else {
		tc.checkSourceElement(node.type_)
		tc.registerForUnusedIdentifiersCheck(node)
	}
}

func (tc *TypeChecker) computeEnumMemberValues(node EnumDeclaration) {
	nodeLinks := tc.getNodeLinks(node)
	if !(nodeLinks.flags & NodeCheckFlagsEnumValuesComputed) {
		nodeLinks.flags |= NodeCheckFlagsEnumValuesComputed
		var autoValue *number = 0
		var previous *EnumMember
		for _, member := range node.members {
			result := tc.computeEnumMemberValue(member, autoValue, previous)
			tc.getNodeLinks(member).enumMemberValue = result
			if /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result.value */ TODO == "number" {
				autoValue = result.value + 1
			} else {
				autoValue = nil
			}
			previous = member
		}
	}
}

func (tc *TypeChecker) computeEnumMemberValue(member EnumMember, autoValue *number, previous *EnumMember) EvaluatorResult {
	if isComputedNonLiteralName(member.name) {
		tc.error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums)
	} else {
		text := getTextOfPropertyName(member.name)
		if isNumericLiteralName(text) && !isInfinityOrNaNString(text) {
			tc.error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name)
		}
	}
	if member.initializer {
		return tc.computeConstantEnumMemberValue(member)
	}
	// In ambient non-const numeric enum declarations, enum members without initializers are
	// considered computed members (as opposed to having auto-incremented values).
	if member.parent.flags&NodeFlagsAmbient && !isEnumConst(member.parent) {
		return evaluatorResult(nil)
	}
	// If the member declaration specifies no value, the member is considered a constant enum member.
	// If the member is the first member in the enum declaration, it is assigned the value zero.
	// Otherwise, it is assigned the value of the immediately preceding member plus one, and an error
	// occurs if the immediately preceding member is not a constant enum member.
	if autoValue == nil {
		tc.error(member.name, Diagnostics.Enum_member_must_have_initializer)
		return evaluatorResult(nil)
	}
	if getIsolatedModules(tc.compilerOptions) && previous. /* ? */ initializer {
		prevValue := tc.getEnumMemberValue(previous)
		if !( /* TODO(TS-TO-GO) Node TypeOfExpression: typeof prevValue.value */ TODO == "number" && !prevValue.resolvedOtherFiles) {
			tc.error(member.name, Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled)
		}
	}
	return evaluatorResult(autoValue)
}

func (tc *TypeChecker) computeConstantEnumMemberValue(member EnumMember) EvaluatorResult {
	isConstEnum := isEnumConst(member.parent)
	initializer := member.initializer
	result := tc.evaluate(initializer, member)
	if result.value != nil {
		if isConstEnum && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result.value */ TODO == "number" && !isFinite(result.value) {
			tc.error(initializer, __COND__(isNaN(result.value), Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN, Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value))
		} else if getIsolatedModules(tc.compilerOptions) && /* TODO(TS-TO-GO) Node TypeOfExpression: typeof result.value */ TODO == "string" && !result.isSyntacticallyString {
			tc.error(initializer, Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled, __TEMPLATE__(idText(member.parent.name), ".", getTextOfPropertyName(member.name)))
		}
	} else if isConstEnum {
		tc.error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions)
	} else if member.parent.flags & NodeFlagsAmbient {
		tc.error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression)
	} else {
		tc.checkTypeAssignableTo(tc.checkExpression(initializer), tc.numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values)
	}
	return result
}

func (tc *TypeChecker) evaluateEntityNameExpression(expr EntityNameExpression, location Declaration) /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
	symbol := tc.resolveEntityName(expr, SymbolFlagsValue /*ignoreErrors*/, true)
	if !symbol {
		return evaluatorResult(nil)
	}

	if expr.kind == SyntaxKindIdentifier {
		identifier := expr
		if isInfinityOrNaNString(identifier.escapedText) && (symbol == tc.getGlobalSymbol(identifier.escapedText, SymbolFlagsValue /*diagnostic*/, nil)) {
			// Technically we resolved a global lib file here, but the decision to treat this as numeric
			// is more predicated on the fact that the single-file resolution *didn't* resolve to a
			// different meaning of `Infinity` or `NaN`. Transpilers handle this no problem.
			return evaluatorResult(+(identifier.escapedText) /*isSyntacticallyString*/, false)
		}
	}

	if symbol.flags & SymbolFlagsEnumMember {
		if location {
			return tc.evaluateEnumMember(expr, symbol, location)
		} else {
			return tc.getEnumMemberValue(symbol.valueDeclaration /* as EnumMember */)
		}
	}
	if tc.isConstantVariable(symbol) {
		declaration := symbol.valueDeclaration
		if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && (!location || declaration != location && tc.isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
			result := tc.evaluate(declaration.initializer, declaration)
			if location && getSourceFileOfNode(location) != getSourceFileOfNode(declaration) {
				return evaluatorResult(result.value, false, true, true)
			}
			return evaluatorResult(result.value, result.isSyntacticallyString, result.resolvedOtherFiles /*hasExternalReferences*/, true)
		}
	}
	return evaluatorResult(nil)
}

func (tc *TypeChecker) evaluateElementAccessExpression(expr ElementAccessExpression, location Declaration) /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
	root := expr.expression
	if isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression) {
		rootSymbol := tc.resolveEntityName(root, SymbolFlagsValue /*ignoreErrors*/, true)
		if rootSymbol && rootSymbol.flags&SymbolFlagsEnum {
			name := escapeLeadingUnderscores(expr.argumentExpression.text)
			member := rootSymbol.exports.get(name)
			if member {
				Debug.assert(getSourceFileOfNode(member.valueDeclaration) == getSourceFileOfNode(rootSymbol.valueDeclaration))
				if location {
					return tc.evaluateEnumMember(expr, member, location)
				} else {
					return tc.getEnumMemberValue(member.valueDeclaration /* as EnumMember */)
				}
			}
		}
	}
	return evaluatorResult(nil)
}

func (tc *TypeChecker) evaluateEnumMember(expr Expression, symbol Symbol, location Declaration) /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
	declaration := symbol.valueDeclaration
	if !declaration || declaration == location {
		tc.error(expr, Diagnostics.Property_0_is_used_before_being_assigned, tc.symbolToString(symbol))
		return evaluatorResult(nil)
	}
	if !tc.isBlockScopedNameDeclaredBeforeUse(declaration, location) {
		tc.error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums)
		return evaluatorResult(0)
	}
	value := tc.getEnumMemberValue(declaration /* as EnumMember */)
	if location.parent != declaration.parent {
		return evaluatorResult(value.value, value.isSyntacticallyString, value.resolvedOtherFiles /*hasExternalReferences*/, true)
	}
	return value
}

func (tc *TypeChecker) checkEnumDeclaration(node EnumDeclaration) {
	tc.addLazyDiagnostic(func() {
		return tc.checkEnumDeclarationWorker(node)
	})
}

func (tc *TypeChecker) checkEnumDeclarationWorker(node EnumDeclaration) {
	// Grammar checking
	tc.checkGrammarModifiers(node)

	tc.checkCollisionsForDeclarationName(node, node.name)
	tc.checkExportsOnMergedDeclarations(node)
	node.members.forEach(tc.checkEnumMember)

	tc.computeEnumMemberValues(node)

	// Spec 2014 - Section 9.3:
	// It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
	// and when an enum type has multiple declarations, only one declaration is permitted to omit a value
	// for the first member.
	//
	// Only perform this check once per symbol
	enumSymbol := tc.getSymbolOfDeclaration(node)
	firstDeclaration := getDeclarationOfKind(enumSymbol, node.kind)
	if node == firstDeclaration {
		if enumSymbol.declarations && enumSymbol.declarations.length > 1 {
			enumIsConst := isEnumConst(node)
			// check that const is placed\omitted on all enum declarations
			forEach(enumSymbol.declarations, func(decl Declaration) {
				if isEnumDeclaration(decl) && isEnumConst(decl) != enumIsConst {
					tc.error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const)
				}
			})
		}

		seenEnumMissingInitialInitializer := false
		forEach(enumSymbol.declarations, func(declaration Declaration) *false {
			// return true if we hit a violation of the rule, false otherwise
			if declaration.kind != SyntaxKindEnumDeclaration {
				return false
			}

			enumDeclaration := declaration /* as EnumDeclaration */
			if !enumDeclaration.members.length {
				return false
			}

			firstEnumMember := enumDeclaration.members[0]
			if !firstEnumMember.initializer {
				if seenEnumMissingInitialInitializer {
					tc.error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element)
				} else {
					seenEnumMissingInitialInitializer = true
				}
			}
		})
	}
}

func (tc *TypeChecker) checkEnumMember(node EnumMember) {
	if isPrivateIdentifier(node.name) {
		tc.error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier)
	}
	if node.initializer {
		tc.checkExpression(node.initializer)
	}
}

func (tc *TypeChecker) getFirstNonAmbientClassOrFunctionDeclaration(symbol Symbol) Declaration {
	declarations := symbol.declarations
	if declarations {
		for _, declaration := range declarations {
			if (declaration.kind == SyntaxKindClassDeclaration || (declaration.kind == SyntaxKindFunctionDeclaration && nodeIsPresent((declaration /* as FunctionLikeDeclaration */).body))) && !(declaration.flags & NodeFlagsAmbient) {
				return declaration
			}
		}
	}
	return nil
}

func (tc *TypeChecker) inSameLexicalScope(node1 Node, node2 Node) bool {
	container1 := getEnclosingBlockScopeContainer(node1)
	container2 := getEnclosingBlockScopeContainer(node2)
	if isGlobalSourceFile(container1) {
		return isGlobalSourceFile(container2)
	} else if isGlobalSourceFile(container2) {
		return false
	} else {
		return container1 == container2
	}
}

func (tc *TypeChecker) checkModuleDeclaration(node ModuleDeclaration) {
	if node.body {
		tc.checkSourceElement(node.body)
		if !isGlobalScopeAugmentation(node) {
			tc.registerForUnusedIdentifiersCheck(node)
		}
	}

	tc.addLazyDiagnostic(checkModuleDeclarationDiagnostics)

	checkModuleDeclarationDiagnostics := func() {
		// Grammar checking
		isGlobalAugmentation := isGlobalScopeAugmentation(node)
		inAmbientContext := node.flags & NodeFlagsAmbient
		if isGlobalAugmentation && !inAmbientContext {
			tc.error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context)
		}

		var isAmbientExternalModule bool = isAmbientModule(node)
		var contextErrorMessage DiagnosticMessage
		if isAmbientExternalModule {
			contextErrorMessage = Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
		} else {
			contextErrorMessage = Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module
		}
		if tc.checkGrammarModuleElementContext(node, contextErrorMessage) {
			// If we hit a module declaration in an illegal context, just bail out to avoid cascading errors.
			return
		}

		if !tc.checkGrammarModifiers(node) {
			if !inAmbientContext && node.name.kind == SyntaxKindStringLiteral {
				tc.grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names)
			}
		}

		if isIdentifier(node.name) {
			tc.checkCollisionsForDeclarationName(node, node.name)
			if !(node.flags & (NodeFlagsNamespace | NodeFlagsGlobalAugmentation)) {
				sourceFile := getSourceFileOfNode(node)
				pos := getNonModifierTokenPosOfNode(node)
				span := getSpanOfTokenAtPosition(sourceFile, pos)
				tc.suggestionDiagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead))
			}
		}

		tc.checkExportsOnMergedDeclarations(node)
		symbol := tc.getSymbolOfDeclaration(node)

		// The following checks only apply on a non-ambient instantiated module declaration.
		if symbol.flags&SymbolFlagsValueModule && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(tc.compilerOptions)) {
			if getIsolatedModules(tc.compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator {
				// This could be loosened a little if needed. The only problem we are trying to avoid is unqualified
				// references to namespace members declared in other files. But use of namespaces is discouraged anyway,
				// so for now we will just not allow them in scripts, which is the only place they can merge cross-file.
				tc.error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, tc.isolatedModulesLikeFlagName)
			}
			if symbol.declarations. /* ? */ length > 1 {
				firstNonAmbientClassOrFunc := tc.getFirstNonAmbientClassOrFunctionDeclaration(symbol)
				if firstNonAmbientClassOrFunc {
					if getSourceFileOfNode(node) != getSourceFileOfNode(firstNonAmbientClassOrFunc) {
						tc.error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged)
					} else if node.pos < firstNonAmbientClassOrFunc.pos {
						tc.error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged)
					}
				}

				// if the module merges with a class declaration in the same lexical scope,
				// we need to track this to ensure the correct emit.
				mergedClass := getDeclarationOfKind(symbol, SyntaxKindClassDeclaration)
				if mergedClass && tc.inSameLexicalScope(node, mergedClass) {
					tc.getNodeLinks(node).flags |= NodeCheckFlagsLexicalModuleMergesWithClass
				}
			}
			if tc.compilerOptions.verbatimModuleSyntax && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(node.parent) == ModuleKindCommonJS {
				exportModifier := node.modifiers. /* ? */ find(func(m ModifierLike) bool {
					return m.kind == SyntaxKindExportKeyword
				})
				if exportModifier {
					tc.error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
				}
			}
		}

		if isAmbientExternalModule {
			if isExternalModuleAugmentation(node) {
				// body of the augmentation should be checked for consistency only if augmentation was applied to its target (either global scope or module)
				// otherwise we'll be swamped in cascading errors.
				// We can detect if augmentation was applied using following rules:
				// - augmentation for a global scope is always applied
				// - augmentation for some external module is applied if symbol for augmentation is merged (it was combined with target module).
				checkBody := isGlobalAugmentation || (tc.getSymbolOfDeclaration(node).flags & SymbolFlagsTransient)
				if checkBody && node.body {
					for _, statement := range node.body.statements {
						tc.checkModuleAugmentationElement(statement, isGlobalAugmentation)
					}
				}
			} else if isGlobalSourceFile(node.parent) {
				if isGlobalAugmentation {
					tc.error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
				} else if isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name)) {
					tc.error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name)
				}
			} else {
				if isGlobalAugmentation {
					tc.error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
				} else {
					// Node is not an augmentation and is not located on the script level.
					// This means that this is declaration of ambient module that is located in other module or namespace which is prohibited.
					tc.error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces)
				}
			}
		}
	}

}

func (tc *TypeChecker) checkModuleAugmentationElement(node Node, isGlobalAugmentation bool) {
	switch node.kind {
	case SyntaxKindVariableStatement:
		for _, decl := range (node /* as VariableStatement */).declarationList.declarations {
			tc.checkModuleAugmentationElement(decl, isGlobalAugmentation)
		}
	case SyntaxKindExportAssignment,
		SyntaxKindExportDeclaration:
		tc.grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations)
	case SyntaxKindImportEqualsDeclaration:
		if isInternalModuleImportEqualsDeclaration(node) {
			break
		}
		fallthrough
	case SyntaxKindImportDeclaration:
		tc.grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module)
	case SyntaxKindBindingElement,
		SyntaxKindVariableDeclaration:
		name := (node /* as VariableDeclaration | BindingElement */).name
		if isBindingPattern(name) {
			for _, el := range name.elements {
				// mark individual names in binding pattern
				tc.checkModuleAugmentationElement(el, isGlobalAugmentation)
			}
			break
		}
		fallthrough
	case SyntaxKindClassDeclaration,
		SyntaxKindEnumDeclaration,
		SyntaxKindFunctionDeclaration,
		SyntaxKindInterfaceDeclaration,
		SyntaxKindModuleDeclaration,
		SyntaxKindTypeAliasDeclaration:
		if isGlobalAugmentation {
			return
		}
	}
}

func (tc *TypeChecker) getFirstNonModuleExportsIdentifier(node EntityNameOrEntityNameExpression) Identifier {
	switch node.kind {
	case SyntaxKindIdentifier:
		return node
	case SyntaxKindQualifiedName:
		for ok := true; ok; ok = node.kind != SyntaxKindIdentifier { // do-while loop
			node = node.left
		}
		return node
	case SyntaxKindPropertyAccessExpression:
		for ok := true; ok; ok = node.kind != SyntaxKindIdentifier { // do-while loop
			if isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name) {
				return node.name
			}
			node = node.expression
		}
		return node
	}
}

func (tc *TypeChecker) checkExternalImportOrExportDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) bool {
	moduleName := getExternalModuleName(node)
	if !moduleName || nodeIsMissing(moduleName) {
		// Should be a parse error.
		return false
	}
	if !isStringLiteral(moduleName) {
		tc.error(moduleName, Diagnostics.String_literal_expected)
		return false
	}
	inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
	if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule {
		tc.error(moduleName, __COND__(node.kind == SyntaxKindExportDeclaration, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace, Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module))
		return false
	}
	if inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text) {
		// we have already reported errors on top level imports/exports in external module augmentations in checkModuleDeclaration
		// no need to do this again.
		if !tc.isTopLevelInExternalModuleAugmentation(node) {
			// TypeScript 1.0 spec (April 2013): 12.1.6
			// An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
			// other external modules only through top - level external module names.
			// Relative external module names are not permitted.
			tc.error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name)
			return false
		}
	}
	if !isImportEqualsDeclaration(node) && node.attributes {
		var diagnostic DiagnosticMessage
		if node.attributes.token == SyntaxKindWithKeyword {
			diagnostic = Diagnostics.Import_attribute_values_must_be_string_literal_expressions
		} else {
			diagnostic = Diagnostics.Import_assertion_values_must_be_string_literal_expressions
		}
		hasError := false
		for _, attr := range node.attributes.elements {
			if !isStringLiteral(attr.value) {
				hasError = true
				tc.error(attr.value, diagnostic)
			}
		}
		return !hasError
	}
	return true
}

func (tc *TypeChecker) checkModuleExportName(name *ModuleExportName, allowStringLiteral bool /*  = true */) {
	if name == nil || name.kind != SyntaxKindStringLiteral {
		return
	}
	if !allowStringLiteral {
		tc.grammarErrorOnNode(name, Diagnostics.Identifier_expected)
	} else if tc.moduleKind == ModuleKindES2015 || tc.moduleKind == ModuleKindES2020 {
		tc.grammarErrorOnNode(name, Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020)
	}
}

func (tc *TypeChecker) checkAliasSymbol(node AliasDeclarationNode) {
	symbol := tc.getSymbolOfDeclaration(node)
	target := tc.resolveAlias(symbol)

	if target != tc.unknownSymbol {
		// For external modules, `symbol` represents the local symbol for an alias.
		// This local symbol will merge any other local declarations (excluding other aliases)
		// and symbol.flags will contains combined representation for all merged declaration.
		// Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,
		// otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export*
		// in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names).
		symbol = tc.getMergedSymbol(symbol.exportSymbol || symbol)

		// A type-only import/export will already have a grammar error in a JS file, so no need to issue more errors within
		if isInJSFile(node) && !(target.flags & SymbolFlagsValue) && !isTypeOnlyImportOrExportDeclaration(node) {
			var errorNode /* TODO(TS-TO-GO) inferred type ObjectBindingPattern | ArrayBindingPattern | ImportClause | ModuleExportName */ any
			switch {
			case isImportOrExportSpecifier(node):
				errorNode = node.propertyName || node.name
			case isNamedDeclaration(node):
				errorNode = node.name
			default:
				errorNode = node
			}

			Debug.assert(node.kind != SyntaxKindNamespaceExport)
			if node.kind == SyntaxKindExportSpecifier {
				diag := tc.error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files)
				alreadyExportedSymbol := getSourceFileOfNode(node).symbol. /* ? */ exports. /* ? */ get(moduleExportNameTextEscaped(node.propertyName || node.name))
				if alreadyExportedSymbol == target {
					exportingDeclaration := alreadyExportedSymbol.declarations. /* ? */ find(isJSDocNode)
					if exportingDeclaration {
						addRelatedInfo(diag, createDiagnosticForNode(exportingDeclaration, Diagnostics._0_is_automatically_exported_here, unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName)))
					}
				}
			} else {
				Debug.assert(node.kind != SyntaxKindVariableDeclaration)
				importDeclaration := findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration))
				moduleSpecifier := /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "..." */ TODO
				importedIdentifier := unescapeLeadingUnderscores(__COND__(isIdentifier(errorNode), errorNode.escapedText, symbol.escapedName))
				tc.error(errorNode, Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation, importedIdentifier, __TEMPLATE__("import(\"", moduleSpecifier, "\").", importedIdentifier))
			}
			return
		}

		targetFlags := tc.getSymbolFlags(target)
		excludedMeanings := (__COND__(symbol.flags&(SymbolFlagsValue|SymbolFlagsExportValue), SymbolFlagsValue, 0)) | (__COND__(symbol.flags&SymbolFlagsType, SymbolFlagsType, 0)) | (__COND__(symbol.flags&SymbolFlagsNamespace, SymbolFlagsNamespace, 0))
		if targetFlags & excludedMeanings {
			var message DiagnosticMessage
			if node.kind == SyntaxKindExportSpecifier {
				message = Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0
			} else {
				message = Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0
			}
			tc.error(node, message, tc.symbolToString(symbol))
		} else if node.kind != SyntaxKindExportSpecifier {
			// Look at 'compilerOptions.isolatedModules' and not 'getIsolatedModules(...)' (which considers 'verbatimModuleSyntax')
			// here because 'verbatimModuleSyntax' will already have an error for importing a type without 'import type'.
			appearsValueyToTranspiler := tc.compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration)
			if appearsValueyToTranspiler && symbol.flags&(SymbolFlagsValue|SymbolFlagsExportValue) {
				tc.error(node, Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, tc.symbolToString(symbol), tc.isolatedModulesLikeFlagName)
			}
		}

		if getIsolatedModules(tc.compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) {
			typeOnlyAlias := tc.getTypeOnlyAliasDeclaration(symbol)
			isType := !(targetFlags & SymbolFlagsValue)
			if isType || typeOnlyAlias {
				switch node.kind {
				case SyntaxKindImportClause,
					SyntaxKindImportSpecifier,
					SyntaxKindImportEqualsDeclaration:
					if tc.compilerOptions.verbatimModuleSyntax {
						Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name")
						var message DiagnosticMessage
						switch {
						case tc.compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node):
							message = Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled
						case isType:
							message = Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled
						default:
							message = Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled
						}
						name := moduleExportNameTextUnescaped(__COND__(node.kind == SyntaxKindImportSpecifier, node.propertyName || node.name, node.name))
						tc.addTypeOnlyDeclarationRelatedInfo(tc.error(node, message, name), __COND__(isType, nil, typeOnlyAlias), name)
					}
					if isType && node.kind == SyntaxKindImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlagsExport) {
						tc.error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, tc.isolatedModulesLikeFlagName)
					}
					break
					fallthrough
				case SyntaxKindExportSpecifier:
					// Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.
					// The exception is that `import type { A } from './a'; export { A }` is allowed
					// because single-file analysis can determine that the export should be dropped.
					if tc.compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) != getSourceFileOfNode(node) {
						name := moduleExportNameTextUnescaped(node.propertyName || node.name)
						var diagnostic Diagnostic
						if isType {
							diagnostic = tc.error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, tc.isolatedModulesLikeFlagName)
						} else {
							diagnostic = tc.error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, tc.isolatedModulesLikeFlagName)
						}
						tc.addTypeOnlyDeclarationRelatedInfo(diagnostic, __COND__(isType, nil, typeOnlyAlias), name)
						break
					}
				}
			}

			if tc.compilerOptions.verbatimModuleSyntax && node.kind != SyntaxKindImportEqualsDeclaration && !isInJSFile(node) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
				tc.error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
			} else if tc.moduleKind == ModuleKindPreserve && node.kind != SyntaxKindImportEqualsDeclaration && node.kind != SyntaxKindVariableDeclaration && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
				// In `--module preserve`, ESM input syntax emits ESM output syntax, but there will be times
				// when we look at the `impliedNodeFormat` of this file and decide it's CommonJS (i.e., currently,
				// only if the file extension is .cjs/.cts). To avoid that inconsistency, we disallow ESM syntax
				// in files that are unambiguously CommonJS in this mode.
				tc.error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve)
			}

			if tc.compilerOptions.verbatimModuleSyntax && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) && targetFlags&SymbolFlagsConstEnum {
				constEnumDeclaration := target.valueDeclaration /* as EnumDeclaration */
				redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
				if constEnumDeclaration.flags&NodeFlagsAmbient && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
					tc.error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, tc.isolatedModulesLikeFlagName)
				}
			}
		}

		if isImportSpecifier(node) {
			targetSymbol := tc.resolveAliasWithDeprecationCheck(symbol, node)
			if tc.isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations {
				tc.addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName /* as string */)
			}
		}
	}
}

func (tc *TypeChecker) resolveAliasWithDeprecationCheck(symbol Symbol, location Node) Symbol {
	if !(symbol.flags & SymbolFlagsAlias) || tc.isDeprecatedSymbol(symbol) || !tc.getDeclarationOfAliasSymbol(symbol) {
		return symbol
	}

	targetSymbol := tc.resolveAlias(symbol)
	if targetSymbol == tc.unknownSymbol {
		return targetSymbol
	}

	for symbol.flags & SymbolFlagsAlias {
		target := tc.getImmediateAliasedSymbol(symbol)
		if target {
			if target == targetSymbol {
				break
			}
			if target.declarations && length(target.declarations) {
				if tc.isDeprecatedSymbol(target) {
					tc.addDeprecatedSuggestion(location, target.declarations, target.escapedName /* as string */)
					break
				} else {
					if symbol == targetSymbol {
						break
					}
					symbol = target
				}
			}
		} else {
			break
		}
	}
	return targetSymbol
}

func (tc *TypeChecker) checkImportBinding(node /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier */ any) {
	tc.checkCollisionsForDeclarationName(node, node.name)
	tc.checkAliasSymbol(node)
	if node.kind == SyntaxKindImportSpecifier {
		tc.checkModuleExportName(node.propertyName)
		if moduleExportNameIsDefault(node.propertyName || node.name) && getESModuleInterop(tc.compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
		}
	}
}

func (tc *TypeChecker) checkImportAttributes(declaration /* TODO(TS-TO-GO) TypeNode UnionType: ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) *bool {
	node := declaration.attributes
	if node {
		importAttributesType := tc.getGlobalImportAttributesType(true)
		if importAttributesType != tc.emptyObjectType {
			tc.checkTypeAssignableTo(tc.getTypeFromImportAttributes(node), tc.getNullableType(importAttributesType, TypeFlagsUndefined), node)
		}

		validForTypeAttributes := isExclusivelyTypeOnlyImportOrExport(declaration)
		override := getResolutionModeOverride(node, __COND__(validForTypeAttributes, tc.grammarErrorOnNode, nil))
		isImportAttributes := declaration.attributes.token == SyntaxKindWithKeyword
		if validForTypeAttributes && override {
			return
			// Other grammar checks do not apply to type-only imports with resolution mode assertions
		}

		mode := (tc.moduleKind == ModuleKindNodeNext) && declaration.moduleSpecifier && tc.getEmitSyntaxForModuleSpecifierExpression(declaration.moduleSpecifier)
		if mode != ModuleKindESNext && tc.moduleKind != ModuleKindESNext && tc.moduleKind != ModuleKindPreserve {
			var message DiagnosticMessage
			switch {
			case isImportAttributes:
				if tc.moduleKind == ModuleKindNodeNext {
					message = Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls
				} else {
					message = Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve
				}
			case tc.moduleKind == ModuleKindNodeNext:
				message = Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls
			default:
				message = Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve
			}
			return tc.grammarErrorOnNode(node, message)
		}

		isTypeOnly := isJSDocImportTag(declaration) || (__COND__(isImportDeclaration(declaration), declaration.importClause. /* ? */ isTypeOnly, declaration.isTypeOnly))
		if isTypeOnly {
			return tc.grammarErrorOnNode(node, __COND__(isImportAttributes, Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports, Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports))
		}

		if override {
			return tc.grammarErrorOnNode(node, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports)
		}
	}
}

func (tc *TypeChecker) checkImportAttribute(node ImportAttribute) Type {
	return tc.getRegularTypeOfLiteralType(tc.checkExpressionCached(node.value))
}

func (tc *TypeChecker) checkImportDeclaration(node ImportDeclaration) {
	if tc.checkGrammarModuleElementContext(node, __COND__(isInJSFile(node), Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module, Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
		// If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
		return
	}
	if !tc.checkGrammarModifiers(node) && node.modifiers {
		tc.grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers)
	}
	if tc.checkExternalImportOrExportDeclaration(node) {
		importClause := node.importClause
		if importClause && !tc.checkGrammarImportClause(importClause) {
			if importClause.name {
				tc.checkImportBinding(importClause)
			}
			if importClause.namedBindings {
				if importClause.namedBindings.kind == SyntaxKindNamespaceImport {
					tc.checkImportBinding(importClause.namedBindings)
					if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && getESModuleInterop(tc.compilerOptions) {
						// import * as ns from "foo";
						tc.checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
					}
				} else {
					moduleExisted := tc.resolveExternalModuleName(node, node.moduleSpecifier)
					if moduleExisted {
						forEach(importClause.namedBindings.elements, tc.checkImportBinding)
					}
				}
			}
		} else if tc.noUncheckedSideEffectImports && !importClause {
			tc.resolveExternalModuleName(node, node.moduleSpecifier)
		}
	}
	tc.checkImportAttributes(node)
}

func (tc *TypeChecker) checkImportEqualsDeclaration(node ImportEqualsDeclaration) {
	if tc.checkGrammarModuleElementContext(node, __COND__(isInJSFile(node), Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module, Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
		// If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
		return
	}

	tc.checkGrammarModifiers(node)
	if isInternalModuleImportEqualsDeclaration(node) || tc.checkExternalImportOrExportDeclaration(node) {
		tc.checkImportBinding(node)
		tc.markLinkedReferences(node, ReferenceHintExportImportEquals)
		if node.moduleReference.kind != SyntaxKindExternalModuleReference {
			target := tc.resolveAlias(tc.getSymbolOfDeclaration(node))
			if target != tc.unknownSymbol {
				targetFlags := tc.getSymbolFlags(target)
				if targetFlags & SymbolFlagsValue {
					// Target is a value symbol, check that it is not hidden by a local declaration with the same name
					moduleName := getFirstIdentifier(node.moduleReference)
					if !(tc.resolveEntityName(moduleName, SymbolFlagsValue|SymbolFlagsNamespace).flags & SymbolFlagsNamespace) {
						tc.error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName))
					}
				}
				if targetFlags & SymbolFlagsType {
					tc.checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0)
				}
			}
			if node.isTypeOnly {
				tc.grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type)
			}
		} else {
			if ModuleKindES2015 <= tc.moduleKind && tc.moduleKind <= ModuleKindESNext && !node.isTypeOnly && !(node.flags & NodeFlagsAmbient) {
				// Import equals declaration cannot be emitted as ESM
				tc.grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead)
			}
		}
	}
}

func (tc *TypeChecker) checkExportDeclaration(node ExportDeclaration) {
	if tc.checkGrammarModuleElementContext(node, __COND__(isInJSFile(node), Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module, Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
		// If we hit an export in an illegal context, just bail out to avoid cascading errors.
		return
	}

	if !tc.checkGrammarModifiers(node) && hasSyntacticModifiers(node) {
		tc.grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers)
	}

	tc.checkGrammarExportDeclaration(node)
	if !node.moduleSpecifier || tc.checkExternalImportOrExportDeclaration(node) {
		if node.exportClause && !isNamespaceExport(node.exportClause) {
			// export { x, y }
			// export { x, y } from "foo"
			forEach(node.exportClause.elements, tc.checkExportSpecifier)
			inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
			inAmbientNamespaceDeclaration := !inAmbientExternalModule && node.parent.kind == SyntaxKindModuleBlock && !node.moduleSpecifier && node.flags&NodeFlagsAmbient
			if node.parent.kind != SyntaxKindSourceFile && !inAmbientExternalModule && !inAmbientNamespaceDeclaration {
				tc.error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace)
			}
		} else {
			// export * from "foo"
			// export * as ns from "foo";
			moduleSymbol := tc.resolveExternalModuleName(node, node.moduleSpecifier)
			if moduleSymbol && tc.hasExportAssignmentSymbol(moduleSymbol) {
				tc.error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, tc.symbolToString(moduleSymbol))
			} else if node.exportClause {
				tc.checkAliasSymbol(node.exportClause)
				tc.checkModuleExportName(node.exportClause.name)
			}
			if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
				if node.exportClause {
					// export * as ns from "foo";
					// For ES2015 modules, we emit it as a pair of `import * as a_1 ...; export { a_1 as ns }` and don't need the helper.
					// We only use the helper here when in esModuleInterop
					if getESModuleInterop(tc.compilerOptions) {
						tc.checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
					}
				} else {
					// export * from "foo"
					tc.checkExternalEmitHelpers(node, ExternalEmitHelpersExportStar)
				}
			}
		}
	}
	tc.checkImportAttributes(node)
}

func (tc *TypeChecker) checkGrammarExportDeclaration(node ExportDeclaration) bool {
	if node.isTypeOnly && node.exportClause. /* ? */ kind == SyntaxKindNamedExports {
		return tc.checkGrammarNamedImportsOrExports(node.exportClause)
	}
	return false
}

func (tc *TypeChecker) checkGrammarModuleElementContext(node Statement, errorMessage DiagnosticMessage) bool {
	isInAppropriateContext := node.parent.kind == SyntaxKindSourceFile || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindModuleDeclaration
	if !isInAppropriateContext {
		tc.grammarErrorOnFirstToken(node, errorMessage)
	}
	return !isInAppropriateContext
}

func (tc *TypeChecker) checkExportSpecifier(node ExportSpecifier) {
	tc.checkAliasSymbol(node)
	hasModuleSpecifier := node.parent.parent.moduleSpecifier != nil
	tc.checkModuleExportName(node.propertyName, hasModuleSpecifier)
	tc.checkModuleExportName(node.name)
	if getEmitDeclarations(tc.compilerOptions) {
		tc.collectLinkedAliases(node.propertyName || node.name /*setVisibility*/, true)
	}
	if !hasModuleSpecifier {
		exportedName := node.propertyName || node.name
		if exportedName.kind == SyntaxKindStringLiteral {
			return
			// Skip for invalid syntax like this: export { "x" }
		}
		// find immediate value referenced by exported name (SymbolFlags.Alias is set so we don't chase down aliases)
		symbol := tc.resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, true)
		if symbol && (symbol == tc.undefinedSymbol || symbol == tc.globalThisSymbol || symbol.declarations && isGlobalSourceFile(tc.getDeclarationContainer(symbol.declarations[0]))) {
			tc.error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName))
		} else {
			tc.markLinkedReferences(node, ReferenceHintExportSpecifier)
		}
	} else {
		if getESModuleInterop(tc.compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && moduleExportNameIsDefault(node.propertyName || node.name) {
			tc.checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
		}
	}
}

func (tc *TypeChecker) checkExportAssignment(node ExportAssignment) {
	var illegalContextMessage DiagnosticMessage
	if node.isExportEquals {
		illegalContextMessage = Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration
	} else {
		illegalContextMessage = Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration
	}
	if tc.checkGrammarModuleElementContext(node, illegalContextMessage) {
		// If we hit an export assignment in an illegal context, just bail out to avoid cascading errors.
		return
	}

	var container /* TODO(TS-TO-GO) inferred type SourceFile | ModuleDeclaration */ any
	if node.parent.kind == SyntaxKindSourceFile {
		container = node.parent
	} else {
		container = node.parent.parent /* as ModuleDeclaration */
	}
	if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
		if node.isExportEquals {
			tc.error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace)
		} else {
			tc.error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
		}

		return
	}
	// Grammar checking
	if !tc.checkGrammarModifiers(node) && hasEffectiveModifiers(node) {
		tc.grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers)
	}

	typeAnnotationNode := getEffectiveTypeAnnotationNode(node)
	if typeAnnotationNode {
		tc.checkTypeAssignableTo(tc.checkExpressionCached(node.expression), tc.getTypeFromTypeNode(typeAnnotationNode), node.expression)
	}

	isIllegalExportDefaultInCJS := !node.isExportEquals && !(node.flags & NodeFlagsAmbient) && tc.compilerOptions.verbatimModuleSyntax && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS

	if node.expression.kind == SyntaxKindIdentifier {
		id := node.expression /* as Identifier */
		sym := tc.getExportSymbolOfValueSymbolIfExported(tc.resolveEntityName(id, SymbolFlagsAll /*ignoreErrors*/, true /*dontResolveAlias*/, true, node))
		if sym {
			tc.markLinkedReferences(node, ReferenceHintExportAssignment)
			typeOnlyDeclaration := tc.getTypeOnlyAliasDeclaration(sym, SymbolFlagsValue)
			// If not a value, we're interpreting the identifier as a type export, along the lines of (`export { Id as default }`)
			if tc.getSymbolFlags(sym) & SymbolFlagsValue {
				// However if it is a value, we need to check it's being used correctly
				tc.checkExpressionCached(id)
				if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && tc.compilerOptions.verbatimModuleSyntax && typeOnlyDeclaration {
					tc.error(id, __COND__(node.isExportEquals, Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration, Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration), idText(id))
				}
			} else if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && tc.compilerOptions.verbatimModuleSyntax {
				tc.error(id, __COND__(node.isExportEquals, Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type, Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type), idText(id))
			}

			if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && getIsolatedModules(tc.compilerOptions) && !(sym.flags & SymbolFlagsValue) {
				nonLocalMeanings := tc.getSymbolFlags(sym /*excludeTypeOnlyMeanings*/, false /*excludeLocalMeanings*/, true)
				if sym.flags&SymbolFlagsAlias && nonLocalMeanings&SymbolFlagsType && !(nonLocalMeanings & SymbolFlagsValue) && (!typeOnlyDeclaration || getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node)) {
					// import { SomeType } from "./someModule";
					// export default SomeType; OR
					// export = SomeType;
					tc.error(id, __COND__(node.isExportEquals, Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported, Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default), idText(id), tc.isolatedModulesLikeFlagName)
				} else if typeOnlyDeclaration && getSourceFileOfNode(typeOnlyDeclaration) != getSourceFileOfNode(node) {
					// import { SomeTypeOnlyValue } from "./someModule";
					// export default SomeTypeOnlyValue; OR
					// export = SomeTypeOnlyValue;
					tc.addTypeOnlyDeclarationRelatedInfo(tc.error(id, __COND__(node.isExportEquals, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default), idText(id), tc.isolatedModulesLikeFlagName), typeOnlyDeclaration, idText(id))
				}
			}
		} else {
			tc.checkExpressionCached(id)
			// doesn't resolve, check as expression to mark as error
		}

		if getEmitDeclarations(tc.compilerOptions) {
			tc.collectLinkedAliases(id /*setVisibility*/, true)
		}
	} else {
		tc.checkExpressionCached(node.expression)
	}

	if isIllegalExportDefaultInCJS {
		tc.error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
	}

	tc.checkExternalModuleExports(container)

	if (node.flags & NodeFlagsAmbient) && !isEntityNameExpression(node.expression) {
		tc.grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context)
	}

	if node.isExportEquals {
		// Forbid export= in esm implementation files, and esm mode declaration files
		if tc.moduleKind >= ModuleKindES2015 && tc.moduleKind != ModuleKindPreserve && ((node.flags&NodeFlagsAmbient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) == ModuleKindESNext) || (!(node.flags & NodeFlagsAmbient) && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) != ModuleKindCommonJS)) {
			// export assignment is not supported in es6 modules
			tc.grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead)
		} else if tc.moduleKind == ModuleKindSystem && !(node.flags & NodeFlagsAmbient) {
			// system modules does not support export assignment
			tc.grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system)
		}
	}
}

func (tc *TypeChecker) hasExportedMembers(moduleSymbol Symbol) *bool {
	return forEachEntry(moduleSymbol.exports, func(_ Symbol, id __String) bool {
		return id != "export="
	})
}

func (tc *TypeChecker) checkExternalModuleExports(node /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | ModuleDeclaration */ any) {
	moduleSymbol := tc.getSymbolOfDeclaration(node)
	links := tc.getSymbolLinks(moduleSymbol)
	if !links.exportsChecked {
		exportEqualsSymbol := moduleSymbol.exports.get("export=" /* as __String */)
		if exportEqualsSymbol && tc.hasExportedMembers(moduleSymbol) {
			declaration := tc.getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration
			if declaration && !tc.isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration) {
				tc.error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements)
			}
		}
		// Checks for export * conflicts
		exports := tc.getExportsOfModule(moduleSymbol)
		if exports {
			exports.forEach(func(TODO_IDENTIFIER Symbol, id __String) {
				if id == "__export" {
					return
				}
				// ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.
				// (TS Exceptions: namespaces, function overloads, enums, and interfaces)
				if flags & (SymbolFlagsNamespace | SymbolFlagsEnum) {
					return
				}
				exportedDeclarationsCount := countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)))
				if flags&SymbolFlagsTypeAlias && exportedDeclarationsCount <= 2 {
					// it is legal to merge type alias with other values
					// so count should be either 1 (just type alias) or 2 (type alias + merged value)
					return
				}
				if exportedDeclarationsCount > 1 {
					if !tc.isDuplicatedCommonJSExport(declarations) {
						for _, declaration := range declarations {
							if isNotOverload(declaration) {
								tc.diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)))
							}
						}
					}
				}
			})
		}
		links.exportsChecked = true
	}
}

func (tc *TypeChecker) isDuplicatedCommonJSExport(declarations *[]Declaration) *bool {
	return declarations && declarations.length > 1 && declarations.every(func(d Declaration) bool {
		return isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression))
	})
}

func (tc *TypeChecker) checkSourceElement(node Node) {
	if node {
		saveCurrentNode := tc.currentNode
		tc.currentNode = node
		tc.instantiationCount = 0
		tc.checkSourceElementWorker(node)
		tc.currentNode = saveCurrentNode
	}
}

func (tc *TypeChecker) checkSourceElementWorker(node Node) {
	if tc.getNodeCheckFlags(node) & NodeCheckFlagsPartiallyTypeChecked {
		return
	}

	if canHaveJSDoc(node) {
		forEach(node.jsDoc, func(TODO_IDENTIFIER JSDoc) {
			tc.checkJSDocCommentWorker(comment)
			forEach(tags, func(tag JSDocTag) {
				tc.checkJSDocCommentWorker(tag.comment)
				if isInJSFile(node) {
					tc.checkSourceElement(tag)
				}
			})
		})
	}

	kind := node.kind
	if tc.cancellationToken {
		// Only bother checking on a few construct kinds.  We don't want to be excessively
		// hitting the cancellation token on every node we check.
		switch kind {
		case SyntaxKindModuleDeclaration,
			SyntaxKindClassDeclaration,
			SyntaxKindInterfaceDeclaration,
			SyntaxKindFunctionDeclaration:
			tc.cancellationToken.throwIfCancellationRequested()
		}
	}
	if kind >= SyntaxKindFirstStatement && kind <= SyntaxKindLastStatement && canHaveFlowNode(node) && node.flowNode && !tc.isReachableFlowNode(node.flowNode) {
		tc.errorOrSuggestion(tc.compilerOptions.allowUnreachableCode == false, node, Diagnostics.Unreachable_code_detected)
	}

	// If editing this, keep `isSourceElement` in utilities up to date.
	switch kind {
	case SyntaxKindTypeParameter:
		return tc.checkTypeParameter(node /* as TypeParameterDeclaration */)
	case SyntaxKindParameter:
		return tc.checkParameter(node /* as ParameterDeclaration */)
	case SyntaxKindPropertyDeclaration:
		return tc.checkPropertyDeclaration(node /* as PropertyDeclaration */)
	case SyntaxKindPropertySignature:
		return tc.checkPropertySignature(node /* as PropertySignature */)
	case SyntaxKindConstructorType,
		SyntaxKindFunctionType,
		SyntaxKindCallSignature,
		SyntaxKindConstructSignature,
		SyntaxKindIndexSignature:
		return tc.checkSignatureDeclaration(node /* as SignatureDeclaration */)
	case SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature:
		return tc.checkMethodDeclaration(node /* as MethodDeclaration | MethodSignature */)
	case SyntaxKindClassStaticBlockDeclaration:
		return tc.checkClassStaticBlockDeclaration(node /* as ClassStaticBlockDeclaration */)
	case SyntaxKindConstructor:
		return tc.checkConstructorDeclaration(node /* as ConstructorDeclaration */)
	case SyntaxKindGetAccessor,
		SyntaxKindSetAccessor:
		return tc.checkAccessorDeclaration(node /* as AccessorDeclaration */)
	case SyntaxKindTypeReference:
		return tc.checkTypeReferenceNode(node /* as TypeReferenceNode */)
	case SyntaxKindTypePredicate:
		return tc.checkTypePredicate(node /* as TypePredicateNode */)
	case SyntaxKindTypeQuery:
		return tc.checkTypeQuery(node /* as TypeQueryNode */)
	case SyntaxKindTypeLiteral:
		return tc.checkTypeLiteral(node /* as TypeLiteralNode */)
	case SyntaxKindArrayType:
		return tc.checkArrayType(node /* as ArrayTypeNode */)
	case SyntaxKindTupleType:
		return tc.checkTupleType(node /* as TupleTypeNode */)
	case SyntaxKindUnionType,
		SyntaxKindIntersectionType:
		return tc.checkUnionOrIntersectionType(node /* as UnionOrIntersectionTypeNode */)
	case SyntaxKindParenthesizedType,
		SyntaxKindOptionalType,
		SyntaxKindRestType:
		return tc.checkSourceElement((node /* as ParenthesizedTypeNode | OptionalTypeNode | RestTypeNode */).type_)
	case SyntaxKindThisType:
		return tc.checkThisType(node /* as ThisTypeNode */)
	case SyntaxKindTypeOperator:
		return tc.checkTypeOperator(node /* as TypeOperatorNode */)
	case SyntaxKindConditionalType:
		return tc.checkConditionalType(node /* as ConditionalTypeNode */)
	case SyntaxKindInferType:
		return tc.checkInferType(node /* as InferTypeNode */)
	case SyntaxKindTemplateLiteralType:
		return tc.checkTemplateLiteralType(node /* as TemplateLiteralTypeNode */)
	case SyntaxKindImportType:
		return tc.checkImportType(node /* as ImportTypeNode */)
	case SyntaxKindNamedTupleMember:
		return tc.checkNamedTupleMember(node /* as NamedTupleMember */)
	case SyntaxKindJSDocAugmentsTag:
		return tc.checkJSDocAugmentsTag(node /* as JSDocAugmentsTag */)
	case SyntaxKindJSDocImplementsTag:
		return tc.checkJSDocImplementsTag(node /* as JSDocImplementsTag */)
	case SyntaxKindJSDocTypedefTag,
		SyntaxKindJSDocCallbackTag,
		SyntaxKindJSDocEnumTag:
		return tc.checkJSDocTypeAliasTag(node /* as JSDocTypedefTag */)
	case SyntaxKindJSDocTemplateTag:
		return tc.checkJSDocTemplateTag(node /* as JSDocTemplateTag */)
	case SyntaxKindJSDocTypeTag:
		return tc.checkJSDocTypeTag(node /* as JSDocTypeTag */)
	case SyntaxKindJSDocLink,
		SyntaxKindJSDocLinkCode,
		SyntaxKindJSDocLinkPlain:
		return tc.checkJSDocLinkLikeTag(node /* as JSDocLink | JSDocLinkCode | JSDocLinkPlain */)
	case SyntaxKindJSDocParameterTag:
		return tc.checkJSDocParameterTag(node /* as JSDocParameterTag */)
	case SyntaxKindJSDocPropertyTag:
		return tc.checkJSDocPropertyTag(node /* as JSDocPropertyTag */)
	case SyntaxKindJSDocFunctionType:
		tc.checkJSDocFunctionType(node /* as JSDocFunctionType */)
		fallthrough
	case SyntaxKindJSDocNonNullableType,
		SyntaxKindJSDocNullableType,
		SyntaxKindJSDocAllType,
		SyntaxKindJSDocUnknownType,
		SyntaxKindJSDocTypeLiteral:
		tc.checkJSDocTypeIsInJsFile(node)
		forEachChild(node, tc.checkSourceElement)
		return
	case SyntaxKindJSDocVariadicType:
		tc.checkJSDocVariadicType(node /* as JSDocVariadicType */)
		return
	case SyntaxKindJSDocTypeExpression:
		return tc.checkSourceElement((node /* as JSDocTypeExpression */).type_)
	case SyntaxKindJSDocPublicTag,
		SyntaxKindJSDocProtectedTag,
		SyntaxKindJSDocPrivateTag:
		return tc.checkJSDocAccessibilityModifiers(node /* as JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */)
	case SyntaxKindJSDocSatisfiesTag:
		return tc.checkJSDocSatisfiesTag(node /* as JSDocSatisfiesTag */)
	case SyntaxKindJSDocThisTag:
		return tc.checkJSDocThisTag(node /* as JSDocThisTag */)
	case SyntaxKindJSDocImportTag:
		return tc.checkJSDocImportTag(node /* as JSDocImportTag */)
	case SyntaxKindIndexedAccessType:
		return tc.checkIndexedAccessType(node /* as IndexedAccessTypeNode */)
	case SyntaxKindMappedType:
		return tc.checkMappedType(node /* as MappedTypeNode */)
	case SyntaxKindFunctionDeclaration:
		return tc.checkFunctionDeclaration(node /* as FunctionDeclaration */)
	case SyntaxKindBlock,
		SyntaxKindModuleBlock:
		return tc.checkBlock(node /* as Block */)
	case SyntaxKindVariableStatement:
		return tc.checkVariableStatement(node /* as VariableStatement */)
	case SyntaxKindExpressionStatement:
		return tc.checkExpressionStatement(node /* as ExpressionStatement */)
	case SyntaxKindIfStatement:
		return tc.checkIfStatement(node /* as IfStatement */)
	case SyntaxKindDoStatement:
		return tc.checkDoStatement(node /* as DoStatement */)
	case SyntaxKindWhileStatement:
		return tc.checkWhileStatement(node /* as WhileStatement */)
	case SyntaxKindForStatement:
		return tc.checkForStatement(node /* as ForStatement */)
	case SyntaxKindForInStatement:
		return tc.checkForInStatement(node /* as ForInStatement */)
	case SyntaxKindForOfStatement:
		return tc.checkForOfStatement(node /* as ForOfStatement */)
	case SyntaxKindContinueStatement,
		SyntaxKindBreakStatement:
		return tc.checkBreakOrContinueStatement(node /* as BreakOrContinueStatement */)
	case SyntaxKindReturnStatement:
		return tc.checkReturnStatement(node /* as ReturnStatement */)
	case SyntaxKindWithStatement:
		return tc.checkWithStatement(node /* as WithStatement */)
	case SyntaxKindSwitchStatement:
		return tc.checkSwitchStatement(node /* as SwitchStatement */)
	case SyntaxKindLabeledStatement:
		return tc.checkLabeledStatement(node /* as LabeledStatement */)
	case SyntaxKindThrowStatement:
		return tc.checkThrowStatement(node /* as ThrowStatement */)
	case SyntaxKindTryStatement:
		return tc.checkTryStatement(node /* as TryStatement */)
	case SyntaxKindVariableDeclaration:
		return tc.checkVariableDeclaration(node /* as VariableDeclaration */)
	case SyntaxKindBindingElement:
		return tc.checkBindingElement(node /* as BindingElement */)
	case SyntaxKindClassDeclaration:
		return tc.checkClassDeclaration(node /* as ClassDeclaration */)
	case SyntaxKindInterfaceDeclaration:
		return tc.checkInterfaceDeclaration(node /* as InterfaceDeclaration */)
	case SyntaxKindTypeAliasDeclaration:
		return tc.checkTypeAliasDeclaration(node /* as TypeAliasDeclaration */)
	case SyntaxKindEnumDeclaration:
		return tc.checkEnumDeclaration(node /* as EnumDeclaration */)
	case SyntaxKindModuleDeclaration:
		return tc.checkModuleDeclaration(node /* as ModuleDeclaration */)
	case SyntaxKindImportDeclaration:
		return tc.checkImportDeclaration(node /* as ImportDeclaration */)
	case SyntaxKindImportEqualsDeclaration:
		return tc.checkImportEqualsDeclaration(node /* as ImportEqualsDeclaration */)
	case SyntaxKindExportDeclaration:
		return tc.checkExportDeclaration(node /* as ExportDeclaration */)
	case SyntaxKindExportAssignment:
		return tc.checkExportAssignment(node /* as ExportAssignment */)
	case SyntaxKindEmptyStatement,
		SyntaxKindDebuggerStatement:
		tc.checkGrammarStatementInAmbientContext(node)
		return
	case SyntaxKindMissingDeclaration:
		return tc.checkMissingDeclaration(node)
	}
}

func (tc *TypeChecker) checkJSDocCommentWorker(node /* TODO(TS-TO-GO) TypeNode UnionType: string | readonly JSDocComment[] | undefined */ any) {
	if isArray(node) {
		forEach(node, func(tag JSDocComment) {
			if isJSDocLinkLike(tag) {
				tc.checkSourceElement(tag)
			}
		})
	}
}

func (tc *TypeChecker) checkJSDocTypeIsInJsFile(node Node) {
	if !isInJSFile(node) {
		if isJSDocNonNullableType(node) || isJSDocNullableType(node) {
			token := tokenToString(__COND__(isJSDocNonNullableType(node), SyntaxKindExclamationToken, SyntaxKindQuestionToken))
			var diagnostic DiagnosticMessage
			if node.postfix {
				diagnostic = Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1
			} else {
				diagnostic = Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1
			}
			typeNode := node.type_
			type_ := tc.getTypeFromTypeNode(typeNode)
			tc.grammarErrorOnNode(node, diagnostic, token, tc.typeToString(__COND__(isJSDocNullableType(node) && !(type_ == tc.neverType || type_ == tc.voidType), tc.getUnionType(append([]Type{type_, tc.undefinedType}, __COND__(node.postfix, nil, tc.nullType))), type_)))
		} else {
			tc.grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
		}
	}
}

func (tc *TypeChecker) checkJSDocVariadicType(node JSDocVariadicType) {
	tc.checkJSDocTypeIsInJsFile(node)
	tc.checkSourceElement(node.type_)

	// Only legal location is in the *last* parameter tag or last parameter of a JSDoc function.
	TODO_IDENTIFIER := node
	if isParameter(parent) && isJSDocFunctionType(parent.parent) {
		if last(parent.parent.parameters) != parent {
			tc.error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
		}
		return
	}

	if !isJSDocTypeExpression(parent) {
		tc.error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
	}

	paramTag := node.parent.parent
	if !isJSDocParameterTag(paramTag) {
		tc.error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
		return
	}

	param := getParameterSymbolFromJSDoc(paramTag)
	if !param {
		// We will error in `checkJSDocParameterTag`.
		return
	}

	host := getHostSignatureFromJSDoc(paramTag)
	if !host || last(host.parameters).symbol != param {
		tc.error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
	}
}

func (tc *TypeChecker) getTypeFromJSDocVariadicType(node JSDocVariadicType) Type {
	type_ := tc.getTypeFromTypeNode(node.type_)
	TODO_IDENTIFIER := node
	paramTag := node.parent.parent
	if isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag) {
		// Else we will add a diagnostic, see `checkJSDocVariadicType`.
		host := getHostSignatureFromJSDoc(paramTag)
		isCallbackTag := isJSDocCallbackTag(paramTag.parent.parent)
		if host || isCallbackTag {
			/*
			   Only return an array type if the corresponding parameter is marked as a rest parameter, or if there are no parameters.
			   So in the following situation we will not create an array type:
			       /** @param {...number} a * /
			       function f(a) {}
			   Because `a` will just be of type `number | undefined`. A synthetic `...args` will also be added, which *will* get an array type.
			*/
			var lastParamDeclaration * /* TODO(TS-TO-GO) inferred type ParameterDeclaration | JSDocParameterTag */ any
			if isCallbackTag {
				lastParamDeclaration = lastOrUndefined((paramTag.parent.parent /* as unknown */ /* as JSDocCallbackTag */).typeExpression.parameters)
			} else {
				lastParamDeclaration = lastOrUndefined(host.parameters)
			}
			symbol := getParameterSymbolFromJSDoc(paramTag)
			if !lastParamDeclaration || symbol && lastParamDeclaration.symbol == symbol && isRestParameter(lastParamDeclaration) {
				return tc.createArrayType(type_)
			}
		}
	}
	if isParameter(parent) && isJSDocFunctionType(parent.parent) {
		return tc.createArrayType(type_)
	}
	return tc.addOptionality(type_)
}

// Function and class expression bodies are checked after all statements in the enclosing body. This is
// to ensure constructs like the following are permitted:
//
//	const foo = function () {
//	   const s = foo();
//	   return "hello";
//	}
//
// Here, performing a full type check of the body of the function expression whilst in the process of
// determining the type of foo would cause foo to be given type any because of the recursive reference.
// Delaying the type check of the body ensures foo has been assigned a type.
func (tc *TypeChecker) checkNodeDeferred(node Node) {
	enclosingFile := getSourceFileOfNode(node)
	links := tc.getNodeLinks(enclosingFile)
	if !(links.flags & NodeCheckFlagsTypeChecked) {
		links.deferredNodes = links.deferredNodes || NewSet()
		links.deferredNodes.add(node)
	} else {
		Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.")
	}
}

func (tc *TypeChecker) checkDeferredNodes(context SourceFile) {
	links := tc.getNodeLinks(context)
	if links.deferredNodes {
		links.deferredNodes.forEach(tc.checkDeferredNode)
	}
	links.deferredNodes = nil
}

func (tc *TypeChecker) checkDeferredNode(node Node) {
	tracing. /* ? */ push(tracing.Phase.Check, "checkDeferredNode", map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"kind": node.kind,
		"pos":  node.pos,
		"end":  node.end,
		"path": (node /* as TracingNode */).tracingPath,
	})
	saveCurrentNode := tc.currentNode
	tc.currentNode = node
	tc.instantiationCount = 0
	switch node.kind {
	case SyntaxKindCallExpression,
		SyntaxKindNewExpression,
		SyntaxKindTaggedTemplateExpression,
		SyntaxKindDecorator,
		SyntaxKindJsxOpeningElement:
		tc.resolveUntypedCall(node /* as CallLikeExpression */)
	case SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature:
		tc.checkFunctionExpressionOrObjectLiteralMethodDeferred(node /* as FunctionExpression */)
	case SyntaxKindGetAccessor,
		SyntaxKindSetAccessor:
		tc.checkAccessorDeclaration(node /* as AccessorDeclaration */)
	case SyntaxKindClassExpression:
		tc.checkClassExpressionDeferred(node /* as ClassExpression */)
	case SyntaxKindTypeParameter:
		tc.checkTypeParameterDeferred(node /* as TypeParameterDeclaration */)
	case SyntaxKindJsxSelfClosingElement:
		tc.checkJsxSelfClosingElementDeferred(node /* as JsxSelfClosingElement */)
	case SyntaxKindJsxElement:
		tc.checkJsxElementDeferred(node /* as JsxElement */)
	case SyntaxKindTypeAssertionExpression,
		SyntaxKindAsExpression,
		SyntaxKindParenthesizedExpression:
		tc.checkAssertionDeferred(node /* as AssertionExpression | JSDocTypeAssertion */)
	case SyntaxKindVoidExpression:
		tc.checkExpression((node /* as VoidExpression */).expression)
	case SyntaxKindBinaryExpression:
		if isInstanceOfExpression(node) {
			tc.resolveUntypedCall(node)
		}
	}
	tc.currentNode = saveCurrentNode
	tracing. /* ? */ pop()
}

func (tc *TypeChecker) checkSourceFile(node SourceFile, nodesToCheck *[]Node) {
	tracing. /* ? */ push(tracing.Phase.Check, __COND__(nodesToCheck, "checkSourceFileNodes", "checkSourceFile"), map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"path": node.path,
	}, /*separateBeginAndEnd*/ true)
	var beforeMark /* TODO(TS-TO-GO) inferred type "beforeCheckNodes" | "beforeCheck" */ any
	if nodesToCheck {
		beforeMark = "beforeCheckNodes"
	} else {
		beforeMark = "beforeCheck"
	}
	var afterMark /* TODO(TS-TO-GO) inferred type "afterCheckNodes" | "afterCheck" */ any
	if nodesToCheck {
		afterMark = "afterCheckNodes"
	} else {
		afterMark = "afterCheck"
	}
	performance.mark(beforeMark)
	__COND__(nodesToCheck, tc.checkSourceFileNodesWorker(node, nodesToCheck), tc.checkSourceFileWorker(node))
	performance.mark(afterMark)
	performance.measure("Check", beforeMark, afterMark)
	tracing. /* ? */ pop()
}

func (tc *TypeChecker) unusedIsError(kind UnusedKind, isAmbient bool) bool {
	if isAmbient {
		return false
	}
	switch kind {
	case UnusedKindLocal:
		return !!tc.compilerOptions.noUnusedLocals
	case UnusedKindParameter:
		return !!tc.compilerOptions.noUnusedParameters
	default:
		return Debug.assertNever(kind)
	}
}

func (tc *TypeChecker) getPotentiallyUnusedIdentifiers(sourceFile SourceFile) []PotentiallyUnusedIdentifier {
	return tc.allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray
}

// Fully type check a source file and collect the relevant diagnostics.
func (tc *TypeChecker) checkSourceFileWorker(node SourceFile) {
	links := tc.getNodeLinks(node)
	if !(links.flags & NodeCheckFlagsTypeChecked) {
		if skipTypeChecking(node, tc.compilerOptions, host) {
			return
		}

		// Grammar checking
		tc.checkGrammarSourceFile(node)

		clear(tc.potentialThisCollisions)
		clear(tc.potentialNewTargetCollisions)
		clear(tc.potentialWeakMapSetCollisions)
		clear(tc.potentialReflectCollisions)
		clear(tc.potentialUnusedRenamedBindingElementsInTypes)

		if links.flags & NodeCheckFlagsPartiallyTypeChecked {
			tc.potentialThisCollisions = links.potentialThisCollisions
			tc.potentialNewTargetCollisions = links.potentialNewTargetCollisions
			tc.potentialWeakMapSetCollisions = links.potentialWeakMapSetCollisions
			tc.potentialReflectCollisions = links.potentialReflectCollisions
			tc.potentialUnusedRenamedBindingElementsInTypes = links.potentialUnusedRenamedBindingElementsInTypes
		}

		forEach(node.statements, tc.checkSourceElement)
		tc.checkSourceElement(node.endOfFileToken)

		tc.checkDeferredNodes(node)

		if isExternalOrCommonJsModule(node) {
			tc.registerForUnusedIdentifiersCheck(node)
		}

		tc.addLazyDiagnostic(func() {
			// This relies on the results of other lazy diagnostics, so must be computed after them
			if !node.isDeclarationFile && (tc.compilerOptions.noUnusedLocals || tc.compilerOptions.noUnusedParameters) {
				tc.checkUnusedIdentifiers(tc.getPotentiallyUnusedIdentifiers(node), func(containingNode Node, kind UnusedKind, diag DiagnosticWithLocation) {
					if !containsParseError(containingNode) && tc.unusedIsError(kind, !!(containingNode.flags&NodeFlagsAmbient)) {
						tc.diagnostics.add(diag)
					}
				})
			}
			if !node.isDeclarationFile {
				tc.checkPotentialUncheckedRenamedBindingElementsInTypes()
			}
		})

		if isExternalOrCommonJsModule(node) {
			tc.checkExternalModuleExports(node)
		}

		if tc.potentialThisCollisions.length {
			forEach(tc.potentialThisCollisions, tc.checkIfThisIsCapturedInEnclosingScope)
			clear(tc.potentialThisCollisions)
		}

		if tc.potentialNewTargetCollisions.length {
			forEach(tc.potentialNewTargetCollisions, tc.checkIfNewTargetIsCapturedInEnclosingScope)
			clear(tc.potentialNewTargetCollisions)
		}

		if tc.potentialWeakMapSetCollisions.length {
			forEach(tc.potentialWeakMapSetCollisions, tc.checkWeakMapSetCollision)
			clear(tc.potentialWeakMapSetCollisions)
		}

		if tc.potentialReflectCollisions.length {
			forEach(tc.potentialReflectCollisions, tc.checkReflectCollision)
			clear(tc.potentialReflectCollisions)
		}

		links.flags |= NodeCheckFlagsTypeChecked
	}
}

func (tc *TypeChecker) checkSourceFileNodesWorker(file SourceFile, nodes []Node) {
	links := tc.getNodeLinks(file)
	if !(links.flags & NodeCheckFlagsTypeChecked) {
		if skipTypeChecking(file, tc.compilerOptions, host) {
			return
		}

		// Grammar checking
		tc.checkGrammarSourceFile(file)

		clear(tc.potentialThisCollisions)
		clear(tc.potentialNewTargetCollisions)
		clear(tc.potentialWeakMapSetCollisions)
		clear(tc.potentialReflectCollisions)
		clear(tc.potentialUnusedRenamedBindingElementsInTypes)

		forEach(nodes, tc.checkSourceElement)

		tc.checkDeferredNodes(file)

		(links.potentialThisCollisions || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.potentialThisCollisions = [] */ TODO)).push(tc.potentialThisCollisions...)
		(links.potentialNewTargetCollisions || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.potentialNewTargetCollisions = [] */ TODO)).push(tc.potentialNewTargetCollisions...)
		(links.potentialWeakMapSetCollisions || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.potentialWeakMapSetCollisions = [] */ TODO)).push(tc.potentialWeakMapSetCollisions...)
		(links.potentialReflectCollisions || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.potentialReflectCollisions = [] */ TODO)).push(tc.potentialReflectCollisions...)
		(links.potentialUnusedRenamedBindingElementsInTypes || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: links.potentialUnusedRenamedBindingElementsInTypes = [] */ TODO)).push(tc.potentialUnusedRenamedBindingElementsInTypes...)

		links.flags |= NodeCheckFlagsPartiallyTypeChecked
		for _, node := range nodes {
			nodeLinks := tc.getNodeLinks(node)
			nodeLinks.flags |= NodeCheckFlagsPartiallyTypeChecked
		}
	}
}

func (tc *TypeChecker) getDiagnostics(sourceFile SourceFile, ct CancellationToken, nodesToCheck []Node) []Diagnostic {
	{ // try
		// Record the cancellation token so it can be checked later on during checkSourceElement.
		// Do this in a finally block so we can ensure that it gets reset back to nothing after
		// this call is done.
		tc.cancellationToken = ct
		return tc.getDiagnosticsWorker(sourceFile, nodesToCheck)
	}
	{ // finally
		tc.cancellationToken = nil
	}
}

func (tc *TypeChecker) ensurePendingDiagnosticWorkComplete() {
	// Invoke any existing lazy diagnostics to add them, clear the backlog of diagnostics
	for _, cb := range tc.deferredDiagnosticsCallbacks {
		cb()
	}
	tc.deferredDiagnosticsCallbacks = []never{}
}

func (tc *TypeChecker) checkSourceFileWithEagerDiagnostics(sourceFile SourceFile, nodesToCheck []Node) {
	tc.ensurePendingDiagnosticWorkComplete()
	// then setup diagnostics for immediate invocation (as we are about to collect them, and
	// this avoids the overhead of longer-lived callbacks we don't need to allocate)
	// This also serves to make the shift to possibly lazy diagnostics transparent to serial command-line scenarios
	// (as in those cases, all the diagnostics will still be computed as the appropriate place in the tree,
	// thus much more likely retaining the same union ordering as before we had lazy diagnostics)
	oldAddLazyDiagnostics := tc.addLazyDiagnostic
	tc.addLazyDiagnostic = func(cb /* TODO(TS-TO-GO) inferred type () => void */ any) {
		return cb()
	}
	tc.checkSourceFile(sourceFile, nodesToCheck)
	tc.addLazyDiagnostic = oldAddLazyDiagnostics
}

func (tc *TypeChecker) getDiagnosticsWorker(sourceFile SourceFile, nodesToCheck *[]Node) []Diagnostic {
	if sourceFile {
		tc.ensurePendingDiagnosticWorkComplete()
		// Some global diagnostics are deferred until they are needed and
		// may not be reported in the first call to getGlobalDiagnostics.
		// We should catch these changes and report them.
		previousGlobalDiagnostics := tc.diagnostics.getGlobalDiagnostics()
		previousGlobalDiagnosticsSize := previousGlobalDiagnostics.length

		tc.checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck)
		semanticDiagnostics := tc.diagnostics.getDiagnostics(sourceFile.fileName)
		if nodesToCheck {
			// No need to get global diagnostics.
			return semanticDiagnostics
		}
		currentGlobalDiagnostics := tc.diagnostics.getGlobalDiagnostics()
		if currentGlobalDiagnostics != previousGlobalDiagnostics {
			// If the arrays are not the same reference, new diagnostics were added.
			deferredGlobalDiagnostics := relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics)
			return concatenate(deferredGlobalDiagnostics, semanticDiagnostics)
		} else if previousGlobalDiagnosticsSize == 0 && currentGlobalDiagnostics.length > 0 {
			// If the arrays are the same reference, but the length has changed, a single
			// new diagnostic was added as DiagnosticCollection attempts to reuse the
			// same array.
			return concatenate(currentGlobalDiagnostics, semanticDiagnostics)
		}

		return semanticDiagnostics
	}

	// Global diagnostics are always added when a file is not provided to
	// getDiagnostics
	forEach(host.getSourceFiles(), func(file SourceFile) {
		return tc.checkSourceFileWithEagerDiagnostics(file)
	})
	return tc.diagnostics.getDiagnostics()
}

func (tc *TypeChecker) getGlobalDiagnostics() []Diagnostic {
	tc.ensurePendingDiagnosticWorkComplete()
	return tc.diagnostics.getGlobalDiagnostics()
}

// Language service support

func (tc *TypeChecker) getSymbolsInScope(location Node, meaning SymbolFlags) []Symbol {
	if location.flags & NodeFlagsInWithStatement {
		// We cannot answer semantic questions within a with block, do not proceed any further
		return []never{}
	}

	symbols := createSymbolTable()
	isStaticSymbol := false

	populateSymbols()

	symbols.delete(InternalSymbolNameThis)
	// Not a symbol, a keyword
	return tc.symbolsToArray(symbols)

	populateSymbols := func() {
		for location {
			if canHaveLocals(location) && location.locals && !isGlobalSourceFile(location) {
				copySymbols(location.locals, meaning)
			}

			switch location.kind {
			case SyntaxKindSourceFile:
				if !isExternalModule(location /* as SourceFile */) {
					break
				}
				fallthrough
			case SyntaxKindModuleDeclaration:
				copyLocallyVisibleExportSymbols(tc.getSymbolOfDeclaration(location /* as ModuleDeclaration | SourceFile */).exports, meaning&SymbolFlagsModuleMember)
			case SyntaxKindEnumDeclaration:
				copySymbols(tc.getSymbolOfDeclaration(location /* as EnumDeclaration */).exports, meaning&SymbolFlagsEnumMember)
			case SyntaxKindClassExpression:
				className := (location /* as ClassExpression */).name
				if className {
					copySymbol((location /* as ClassExpression */).symbol, meaning)
				}
				fallthrough
			case SyntaxKindClassDeclaration,
				SyntaxKindInterfaceDeclaration:
				if !isStaticSymbol {
					copySymbols(tc.getMembersOfSymbol(tc.getSymbolOfDeclaration(location /* as ClassDeclaration | InterfaceDeclaration */)), meaning&SymbolFlagsType)
				}
			case SyntaxKindFunctionExpression:
				funcName := (location /* as FunctionExpression */).name
				if funcName {
					copySymbol((location /* as FunctionExpression */).symbol, meaning)
				}
			}

			if introducesArgumentsExoticObject(location) {
				copySymbol(tc.argumentsSymbol, meaning)
			}

			isStaticSymbol = isStatic(location)
			location = location.parent
		}

		copySymbols(tc.globals, meaning)
	}

	/**
	 * Copy the given symbol into symbol tables if the symbol has the given meaning
	 * and it doesn't already existed in the symbol table
	 * @param key a key for storing in symbol table; if undefined, use symbol.name
	 * @param symbol the symbol to be added into symbol table
	 * @param meaning meaning of symbol to filter by before adding to symbol table
	 */

	copySymbol := func(symbol Symbol, meaning SymbolFlags) {
		if getCombinedLocalAndExportSymbolFlags(symbol) & meaning {
			id := symbol.escapedName
			// We will copy all symbol regardless of its reserved name because
			// symbolsToArray will check whether the key is a reserved name and
			// it will not copy symbol with reserved name to the array
			if !symbols.has(id) {
				symbols.set(id, symbol)
			}
		}
	}

	copySymbols := func(source SymbolTable, meaning SymbolFlags) {
		if meaning {
			source.forEach(func(symbol Symbol) {
				copySymbol(symbol, meaning)
			})
		}
	}

	copyLocallyVisibleExportSymbols := func(source SymbolTable, meaning SymbolFlags) {
		if meaning {
			source.forEach(func(symbol Symbol) {
				// Similar condition as in `resolveNameHelper`
				if !getDeclarationOfKind(symbol, SyntaxKindExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKindNamespaceExport) && symbol.escapedName != InternalSymbolNameDefault {
					copySymbol(symbol, meaning)
				}
			})
		}
	}

}

func (tc *TypeChecker) isTypeDeclarationName(name Node) bool {
	return name.kind == SyntaxKindIdentifier && isTypeDeclaration(name.parent) && getNameOfDeclaration(name.parent) == name
}

// True if the given identifier is part of a type reference
func (tc *TypeChecker) isTypeReferenceIdentifier(node EntityName) bool {
	for node.parent.kind == SyntaxKindQualifiedName {
		node = node.parent /* as QualifiedName */
	}

	return node.parent.kind == SyntaxKindTypeReference
}

func (tc *TypeChecker) isInNameOfExpressionWithTypeArguments(node Node) bool {
	for node.parent.kind == SyntaxKindPropertyAccessExpression {
		node = node.parent
	}

	return node.parent.kind == SyntaxKindExpressionWithTypeArguments
}

func (tc *TypeChecker) forEachEnclosingClass(node Node, callback func(node ClassLikeDeclaration) *T) *T {
	var result *T
	containingClass := getContainingClass(node)
	for containingClass {
		if /* TODO(TS-TO-GO) EqualsToken BinaryExpression: result = callback(containingClass) */ TODO {
			break
		}
		containingClass = getContainingClass(containingClass)
	}

	return result
}

func (tc *TypeChecker) isNodeUsedDuringClassInitialization(node Node) bool {
	return !!findAncestor(node, func(element Node) /* TODO(TS-TO-GO) inferred type boolean | "quit" */ any {
		if isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element) {
			return true
		} else if isClassLike(element) || isFunctionLikeDeclaration(element) {
			return "quit"
		}

		return false
	})
}

func (tc *TypeChecker) isNodeWithinClass(node Node, classDeclaration ClassLikeDeclaration) bool {
	return !!tc.forEachEnclosingClass(node, func(n ClassLikeDeclaration) bool {
		return n == classDeclaration
	})
}

func (tc *TypeChecker) getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide EntityName) /* TODO(TS-TO-GO) TypeNode UnionType: ImportEqualsDeclaration | ExportAssignment | undefined */ any {
	for nodeOnRightSide.parent.kind == SyntaxKindQualifiedName {
		nodeOnRightSide = nodeOnRightSide.parent /* as QualifiedName */
	}

	if nodeOnRightSide.parent.kind == SyntaxKindImportEqualsDeclaration {
		if (nodeOnRightSide.parent /* as ImportEqualsDeclaration */).moduleReference == nodeOnRightSide {
			return nodeOnRightSide.parent /* as ImportEqualsDeclaration */
		} else {
			return nil
		}
	}

	if nodeOnRightSide.parent.kind == SyntaxKindExportAssignment {
		if (nodeOnRightSide.parent /* as ExportAssignment */).expression == nodeOnRightSide /* as Node */ {
			return nodeOnRightSide.parent /* as ExportAssignment */
		} else {
			return nil
		}
	}

	return nil
}

func (tc *TypeChecker) isInRightSideOfImportOrExportAssignment(node EntityName) bool {
	return tc.getLeftSideOfImportEqualsOrExportAssignment(node) != nil
}

func (tc *TypeChecker) getSpecialPropertyAssignmentSymbolFromEntityName(entityName /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | PropertyAccessExpression */ any) Symbol {
	specialPropertyAssignmentKind := getAssignmentDeclarationKind(entityName.parent.parent /* as BinaryExpression */)
	switch specialPropertyAssignmentKind {
	case AssignmentDeclarationKindExportsProperty,
		AssignmentDeclarationKindPrototypeProperty:
		return tc.getSymbolOfNode(entityName.parent)
	case AssignmentDeclarationKindProperty:
		if isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) == entityName {
			return nil
		}
		fallthrough
	case AssignmentDeclarationKindThisProperty,
		AssignmentDeclarationKindModuleExports:
		return tc.getSymbolOfDeclaration(entityName.parent.parent /* as BinaryExpression */)
	}
}

func (tc *TypeChecker) isImportTypeQualifierPart(node EntityName) *ImportTypeNode {
	parent := node.parent
	for isQualifiedName(parent) {
		node = parent
		parent = parent.parent
	}
	if parent && parent.kind == SyntaxKindImportType && (parent /* as ImportTypeNode */).qualifier == node {
		return parent /* as ImportTypeNode */
	}
	return nil
}

func (tc *TypeChecker) isThisPropertyAndThisTyped(node PropertyAccessExpression) *bool {
	if node.expression.kind == SyntaxKindThisKeyword {
		container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		if isFunctionLike(container) {
			containingLiteral := tc.getContainingObjectLiteral(container)
			if containingLiteral {
				contextualType := tc.getApparentTypeOfContextualType(containingLiteral /*contextFlags*/, nil)
				type_ := tc.getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
				return type_ && !tc.isTypeAny(type_)
			}
		}
	}
}

func (tc *TypeChecker) getSymbolOfNameOrPropertyAccessExpression(name /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName */ any) Symbol {
	if isDeclarationName(name) {
		return tc.getSymbolOfNode(name.parent)
	}

	if isInJSFile(name) && name.parent.kind == SyntaxKindPropertyAccessExpression && name.parent == (name.parent.parent /* as BinaryExpression */).left {
		// Check if this is a special property assignment
		if !isPrivateIdentifier(name) && !isJSDocMemberName(name) && !tc.isThisPropertyAndThisTyped(name.parent /* as PropertyAccessExpression */) {
			specialPropertyAssignmentSymbol := tc.getSpecialPropertyAssignmentSymbolFromEntityName(name)
			if specialPropertyAssignmentSymbol {
				return specialPropertyAssignmentSymbol
			}
		}
	}

	if name.parent.kind == SyntaxKindExportAssignment && isEntityNameExpression(name) {
		// Even an entity name expression that doesn't resolve as an entityname may still typecheck as a property access expression
		success := tc.resolveEntityName(name /*all meanings*/, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias /*ignoreErrors*/, true)
		if success && success != tc.unknownSymbol {
			return success
		}
	} else if isEntityName(name) && tc.isInRightSideOfImportOrExportAssignment(name) {
		// Since we already checked for ExportAssignment, this really could only be an Import
		importEqualsDeclaration := getAncestor(name, SyntaxKindImportEqualsDeclaration)
		Debug.assert(importEqualsDeclaration != nil)
		return tc.getSymbolOfPartOfRightHandSideOfImportEquals(name /*dontResolveAlias*/, true)
	}

	if isEntityName(name) {
		possibleImportNode := tc.isImportTypeQualifierPart(name)
		if possibleImportNode {
			tc.getTypeFromTypeNode(possibleImportNode)
			sym := tc.getNodeLinks(name).resolvedSymbol
			if sym == tc.unknownSymbol {
				return nil
			} else {
				return sym
			}
		}
	}

	for isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name) {
		name = name.parent /* as QualifiedName | PropertyAccessEntityNameExpression | JSDocMemberName */
	}

	if tc.isInNameOfExpressionWithTypeArguments(name) {
		meaning := SymbolFlagsNone
		if name.parent.kind == SyntaxKindExpressionWithTypeArguments {
			// An 'ExpressionWithTypeArguments' may appear in type space (interface Foo extends Bar<T>),
			// value space (return foo<T>), or both(class Foo extends Bar<T>); ensure the meaning matches.
			if isPartOfTypeNode(name) {
				meaning = SymbolFlagsType
			} else {
				meaning = SymbolFlagsValue
			}

			// In a class 'extends' clause we are also looking for a value.
			if isExpressionWithTypeArgumentsInClassExtendsClause(name.parent) {
				meaning |= SymbolFlagsValue
			}
		} else {
			meaning = SymbolFlagsNamespace
		}

		meaning |= SymbolFlagsAlias
		var entityNameSymbol Symbol
		if isEntityNameExpression(name) {
			entityNameSymbol = tc.resolveEntityName(name, meaning /*ignoreErrors*/, true)
		} else {
			entityNameSymbol = nil
		}
		if entityNameSymbol {
			return entityNameSymbol
		}
	}

	if name.parent.kind == SyntaxKindJSDocParameterTag {
		return getParameterSymbolFromJSDoc(name.parent /* as JSDocParameterTag */)
	}

	if name.parent.kind == SyntaxKindTypeParameter && name.parent.parent.kind == SyntaxKindJSDocTemplateTag {
		Debug.assert(!isInJSFile(name))
		// Otherwise `isDeclarationName` would have been true.
		typeParameter := getTypeParameterFromJsDoc(name.parent /* as TypeParameterDeclaration & { parent: JSDocTemplateTag; } */)
		return typeParameter && typeParameter.symbol
	}

	if isExpressionNode(name) {
		if nodeIsMissing(name) {
			// Missing entity name.
			return nil
		}

		isJSDoc := findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName))
		var meaning number
		if isJSDoc {
			meaning = SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsValue
		} else {
			meaning = SymbolFlagsValue
		}
		if name.kind == SyntaxKindIdentifier {
			if isJSXTagName(name) && tc.isJsxIntrinsicTagName(name) {
				symbol := tc.getIntrinsicTagSymbol(name.parent /* as JsxOpeningLikeElement */)
				if symbol == tc.unknownSymbol {
					return nil
				} else {
					return symbol
				}
			}
			result := tc.resolveEntityName(name, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true, getHostSignatureFromJSDoc(name))
			if !result && isJSDoc {
				container := findAncestor(name, or(isClassLike, isInterfaceDeclaration))
				if container {
					return tc.resolveJSDocMemberName(name /*ignoreErrors*/, true, tc.getSymbolOfDeclaration(container))
				}
			}
			if result && isJSDoc {
				container := getJSDocHost(name)
				if container && isEnumMember(container) && container == result.valueDeclaration {
					return tc.resolveEntityName(name, meaning /*ignoreErrors*/, true /*dontResolveAlias*/, true, getSourceFileOfNode(container)) || result
				}
			}
			return result
		} else if isPrivateIdentifier(name) {
			return tc.getSymbolForPrivateIdentifierExpression(name)
		} else if name.kind == SyntaxKindPropertyAccessExpression || name.kind == SyntaxKindQualifiedName {
			links := tc.getNodeLinks(name)
			if links.resolvedSymbol {
				return links.resolvedSymbol
			}

			if name.kind == SyntaxKindPropertyAccessExpression {
				tc.checkPropertyAccessExpression(name, CheckModeNormal)
				if !links.resolvedSymbol {
					links.resolvedSymbol = tc.getApplicableIndexSymbol(tc.checkExpressionCached(name.expression), tc.getLiteralTypeFromPropertyName(name.name))
				}
			} else {
				tc.checkQualifiedName(name, CheckModeNormal)
			}
			if !links.resolvedSymbol && isJSDoc && isQualifiedName(name) {
				return tc.resolveJSDocMemberName(name)
			}
			return links.resolvedSymbol
		} else if isJSDocMemberName(name) {
			return tc.resolveJSDocMemberName(name)
		}
	} else if tc.isTypeReferenceIdentifier(name /* as EntityName */) {
		var meaning /* TODO(TS-TO-GO) inferred type SymbolFlags.Type | SymbolFlags.Namespace */ any
		if name.parent.kind == SyntaxKindTypeReference {
			meaning = SymbolFlagsType
		} else {
			meaning = SymbolFlagsNamespace
		}
		symbol := tc.resolveEntityName(name /* as EntityName */, meaning /*ignoreErrors*/, false /*dontResolveAlias*/, true)
		if symbol && symbol != tc.unknownSymbol {
			return symbol
		} else {
			return tc.getUnresolvedSymbolForEntityName(name /* as EntityName */)
		}
	}
	if name.parent.kind == SyntaxKindTypePredicate {
		return tc.resolveEntityName(name /* as Identifier */ /*meaning*/, SymbolFlagsFunctionScopedVariable)
	}

	return nil
}

func (tc *TypeChecker) getApplicableIndexSymbol(type_ Type, keyType Type) Symbol {
	infos := tc.getApplicableIndexInfos(type_, keyType)
	if infos.length && (type_ /* as ObjectType */).members {
		symbol := tc.getIndexSymbolFromSymbolTable(tc.resolveStructuredTypeMembers(type_ /* as ObjectType */).members)
		if infos == tc.getIndexInfosOfType(type_) {
			return symbol
		} else if symbol {
			symbolLinks := tc.getSymbolLinks(symbol)
			declarationList := mapDefined(infos, func(i IndexInfo) *IndexSignatureDeclaration {
				return i.declaration
			})
			nodeListId := map_(declarationList, getNodeId).join(",")
			if !symbolLinks.filteredIndexSymbolCache {
				symbolLinks.filteredIndexSymbolCache = NewMap()
			}
			if symbolLinks.filteredIndexSymbolCache.has(nodeListId) {
				return symbolLinks.filteredIndexSymbolCache.get(nodeListId)
			} else {
				copy := tc.createSymbol(SymbolFlagsSignature, InternalSymbolNameIndex)
				copy.declarations = mapDefined(infos, func(i IndexInfo) *IndexSignatureDeclaration {
					return i.declaration
				})
				switch {
				case type_.aliasSymbol:
					copy.parent = type_.aliasSymbol
				case type_.symbol:
					copy.parent = type_.symbol
				default:
					copy.parent = tc.getSymbolAtLocation(copy.declarations[0].parent)
				}
				symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy)
				return copy
			}
		}
	}
}

/**
 * Recursively resolve entity names and jsdoc instance references:
 * 1. K#m as K.prototype.m for a class (or other value) K
 * 2. K.m as K.prototype.m
 * 3. I.m as I.m for a type I, or any other I.m that fails to resolve in (1) or (2)
 *
 * For unqualified names, a container K may be provided as a second argument.
 */

func (tc *TypeChecker) resolveJSDocMemberName(name /* TODO(TS-TO-GO) TypeNode UnionType: EntityName | JSDocMemberName */ any, ignoreErrors bool, container Symbol) Symbol {
	if isEntityName(name) {
		// resolve static values first
		meaning := SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsValue
		symbol := tc.resolveEntityName(name, meaning, ignoreErrors /*dontResolveAlias*/, true, getHostSignatureFromJSDoc(name))
		if !symbol && isIdentifier(name) && container {
			symbol = tc.getMergedSymbol(tc.getSymbol(tc.getExportsOfSymbol(container), name.escapedText, meaning))
		}
		if symbol {
			return symbol
		}
	}
	var left Symbol
	if isIdentifier(name) {
		left = container
	} else {
		left = tc.resolveJSDocMemberName(name.left, ignoreErrors, container)
	}
	var right __String
	if isIdentifier(name) {
		right = name.escapedText
	} else {
		right = name.right.escapedText
	}
	if left {
		proto := left.flags&SymbolFlagsValue && tc.getPropertyOfType(tc.getTypeOfSymbol(left), "prototype" /* as __String */)
		var t Type
		if proto {
			t = tc.getTypeOfSymbol(proto)
		} else {
			t = tc.getDeclaredTypeOfSymbol(left)
		}
		return tc.getPropertyOfType(t, right)
	}
}

func (tc *TypeChecker) getSymbolAtLocation(node Node, ignoreErrors bool) Symbol {
	if isSourceFile(node) {
		if isExternalModule(node) {
			return tc.getMergedSymbol(node.symbol)
		} else {
			return nil
		}
	}
	TODO_IDENTIFIER := node
	grandParent := parent.parent

	if node.flags & NodeFlagsInWithStatement {
		// We cannot answer semantic questions within a with block, do not proceed any further
		return nil
	}

	if isDeclarationNameOrImportPropertyName(node) {
		// This is a declaration, call getSymbolOfNode
		parentSymbol := tc.getSymbolOfDeclaration(parent /* as Declaration */)
		if isImportOrExportSpecifier(node.parent) && node.parent.propertyName == node {
			return tc.getImmediateAliasedSymbol(parentSymbol)
		} else {
			return parentSymbol
		}
	} else if isLiteralComputedPropertyDeclarationName(node) {
		return tc.getSymbolOfDeclaration(parent.parent /* as Declaration */)
	}

	if node.kind == SyntaxKindIdentifier {
		if tc.isInRightSideOfImportOrExportAssignment(node /* as Identifier */) {
			return tc.getSymbolOfNameOrPropertyAccessExpression(node /* as Identifier */)
		} else if parent.kind == SyntaxKindBindingElement && grandParent.kind == SyntaxKindObjectBindingPattern && node == (parent /* as BindingElement */).propertyName {
			typeOfPattern := tc.getTypeOfNode(grandParent)
			propertyDeclaration := tc.getPropertyOfType(typeOfPattern, (node /* as Identifier */).escapedText)

			if propertyDeclaration {
				return propertyDeclaration
			}
		} else if isMetaProperty(parent) && parent.name == node {
			if parent.keywordToken == SyntaxKindNewKeyword && idText(node /* as Identifier */) == "target" {
				// `target` in `new.target`
				return tc.checkNewTargetMetaProperty(parent).symbol
			}
			// The `meta` in `import.meta` could be given `getTypeOfNode(parent).symbol` (the `ImportMeta` interface symbol), but
			// we have a fake expression type made for other reasons already, whose transient `meta`
			// member should more exactly be the kind of (declarationless) symbol we want.
			// (See #44364 and #45031 for relevant implementation PRs)
			if parent.keywordToken == SyntaxKindImportKeyword && idText(node /* as Identifier */) == "meta" {
				return tc.getGlobalImportMetaExpressionType().members.get("meta" /* as __String */)
			}
			// no other meta properties are valid syntax, thus no others should have symbols
			return nil
		}
	}

	switch node.kind {
	case SyntaxKindIdentifier,
		SyntaxKindPrivateIdentifier,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindQualifiedName:
		if !isThisInTypeQuery(node) {
			return tc.getSymbolOfNameOrPropertyAccessExpression(node /* as EntityName | PrivateIdentifier | PropertyAccessExpression */)
		}
		fallthrough
	case SyntaxKindThisKeyword:
		container := getThisContainer(node /*includeArrowFunctions*/, false /*includeClassComputedPropertyName*/, false)
		if isFunctionLike(container) {
			sig := tc.getSignatureFromDeclaration(container)
			if sig.thisParameter {
				return sig.thisParameter
			}
		}
		if isInExpressionContext(node) {
			return tc.checkExpression(node /* as Expression */).symbol
		}
		fallthrough
	case SyntaxKindThisType:
		return tc.getTypeFromThisTypeNode(node /* as ThisExpression | ThisTypeNode */).symbol
	case SyntaxKindSuperKeyword:
		return tc.checkExpression(node /* as Expression */).symbol
	case SyntaxKindConstructorKeyword:
		constructorDeclaration := node.parent
		if constructorDeclaration && constructorDeclaration.kind == SyntaxKindConstructor {
			return (constructorDeclaration.parent /* as ClassDeclaration */).symbol
		}
		return nil
	case SyntaxKindStringLiteral,
		SyntaxKindNoSubstitutionTemplateLiteral:
		if (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) == node) || ((node.parent.kind == SyntaxKindImportDeclaration || node.parent.kind == SyntaxKindExportDeclaration) && (node.parent /* as ImportDeclaration */).moduleSpecifier == node) || (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier == node) || ((isInJSFile(node) && isRequireCall(node.parent /*requireStringLiteralLikeArgument*/, false)) || isImportCall(node.parent)) || (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument == node.parent) {
			return tc.resolveExternalModuleName(node, node /* as LiteralExpression */, ignoreErrors)
		}
		if isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] == node {
			return tc.getSymbolOfDeclaration(parent)
		}
		fallthrough
	case SyntaxKindNumericLiteral:
		var objectType Type
		switch {
		case isElementAccessExpression(parent):
			if parent.argumentExpression == node {
				objectType = tc.getTypeOfExpression(parent.expression)
			} else {
				objectType = nil
			}
		case isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent):
			objectType = tc.getTypeFromTypeNode(grandParent.objectType)
		default:
			objectType = nil
		}
		return objectType && tc.getPropertyOfType(objectType, escapeLeadingUnderscores((node /* as StringLiteral | NumericLiteral */).text))
	case SyntaxKindDefaultKeyword,
		SyntaxKindFunctionKeyword,
		SyntaxKindEqualsGreaterThanToken,
		SyntaxKindClassKeyword:
		return tc.getSymbolOfNode(node.parent)
	case SyntaxKindImportType:
		if isLiteralImportTypeNode(node) {
			return tc.getSymbolAtLocation(node.argument.literal, ignoreErrors)
		} else {
			return nil
		}
	case SyntaxKindExportKeyword:
		if isExportAssignment(node.parent) {
			return Debug.checkDefined(node.parent.symbol)
		} else {
			return nil
		}
	case SyntaxKindImportKeyword,
		SyntaxKindNewKeyword:
		if isMetaProperty(node.parent) {
			return tc.checkMetaPropertyKeyword(node.parent).symbol
		} else {
			return nil
		}
	case SyntaxKindInstanceOfKeyword:
		if isBinaryExpression(node.parent) {
			type_ := tc.getTypeOfExpression(node.parent.right)
			hasInstanceMethodType := tc.getSymbolHasInstanceMethodOfObjectType(type_)
			return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: hasInstanceMethodType?.symbol ?? type.symbol */ TODO
		}
		return nil
	case SyntaxKindMetaProperty:
		return tc.checkExpression(node /* as Expression */).symbol
	case SyntaxKindJsxNamespacedName:
		if isJSXTagName(node) && tc.isJsxIntrinsicTagName(node) {
			symbol := tc.getIntrinsicTagSymbol(node.parent /* as JsxOpeningLikeElement */)
			if symbol == tc.unknownSymbol {
				return nil
			} else {
				return symbol
			}
		}
		fallthrough
	default:
		return nil
	}
}

func (tc *TypeChecker) getIndexInfosAtLocation(node Node) *[]IndexInfo {
	if isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name == node {
		keyType := tc.getLiteralTypeFromPropertyName(node)
		objectType := tc.getTypeOfExpression(node.parent.expression)
		var objectTypes []Type
		if objectType.flags & TypeFlagsUnion {
			objectTypes = (objectType /* as UnionType */).types
		} else {
			objectTypes = []Type{objectType}
		}
		return flatMap(objectTypes, func(t Type) []IndexInfo {
			return filter(tc.getIndexInfosOfType(t), func(info IndexInfo) bool {
				return tc.isApplicableIndexType(keyType, info.keyType)
			})
		})
	}
	return nil
}

func (tc *TypeChecker) getShorthandAssignmentValueSymbol(location Node) Symbol {
	if location && location.kind == SyntaxKindShorthandPropertyAssignment {
		return tc.resolveEntityName((location /* as ShorthandPropertyAssignment */).name, SymbolFlagsValue|SymbolFlagsAlias)
	}
	return nil
}

/** Returns the target of an export specifier without following aliases */

func (tc *TypeChecker) getExportSpecifierLocalTargetSymbol(node /* TODO(TS-TO-GO) TypeNode UnionType: ExportSpecifier | Identifier */ any) Symbol {
	if isExportSpecifier(node) {
		name := node.propertyName || node.name
		switch {
		case node.parent.parent.moduleSpecifier:
			return tc.getExternalModuleMember(node.parent.parent, node)
		case name.kind == SyntaxKindStringLiteral:
			return nil
		default:
			return tc.resolveEntityName(name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
	} else {
		return tc.resolveEntityName(node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
	}
}

func (tc *TypeChecker) getTypeOfNode(node Node) Type {
	if isSourceFile(node) && !isExternalModule(node) {
		return tc.errorType
	}

	if node.flags & NodeFlagsInWithStatement {
		// We cannot answer semantic questions within a with block, do not proceed any further
		return tc.errorType
	}

	classDecl := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
	classType := classDecl && tc.getDeclaredTypeOfClassOrInterface(tc.getSymbolOfDeclaration(classDecl.class))
	if isPartOfTypeNode(node) {
		typeFromTypeNode := tc.getTypeFromTypeNode(node /* as TypeNode */)
		if classType {
			return tc.getTypeWithThisArgument(typeFromTypeNode, classType.thisType)
		} else {
			return typeFromTypeNode
		}
	}

	if isExpressionNode(node) {
		return tc.getRegularTypeOfExpression(node /* as Expression */)
	}

	if classType && !classDecl.isImplements {
		// A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
		// extends clause of a class. We handle that case here.
		baseType := firstOrUndefined(tc.getBaseTypes(classType))
		if baseType {
			return tc.getTypeWithThisArgument(baseType, classType.thisType)
		} else {
			return tc.errorType
		}
	}

	if isTypeDeclaration(node) {
		// In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
		symbol := tc.getSymbolOfDeclaration(node)
		return tc.getDeclaredTypeOfSymbol(symbol)
	}

	if tc.isTypeDeclarationName(node) {
		symbol := tc.getSymbolAtLocation(node)
		if symbol {
			return tc.getDeclaredTypeOfSymbol(symbol)
		} else {
			return tc.errorType
		}
	}

	if isBindingElement(node) {
		return tc.getTypeForVariableLikeDeclaration(node /*includeOptionality*/, true, CheckModeNormal) || tc.errorType
	}

	if isDeclaration(node) {
		// In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
		symbol := tc.getSymbolOfDeclaration(node)
		if symbol {
			return tc.getTypeOfSymbol(symbol)
		} else {
			return tc.errorType
		}
	}

	if isDeclarationNameOrImportPropertyName(node) {
		symbol := tc.getSymbolAtLocation(node)
		if symbol {
			return tc.getTypeOfSymbol(symbol)
		}
		return tc.errorType
	}

	if isBindingPattern(node) {
		return tc.getTypeForVariableLikeDeclaration(node.parent /*includeOptionality*/, true, CheckModeNormal) || tc.errorType
	}

	if tc.isInRightSideOfImportOrExportAssignment(node /* as Identifier */) {
		symbol := tc.getSymbolAtLocation(node)
		if symbol {
			declaredType := tc.getDeclaredTypeOfSymbol(symbol)
			if !tc.isErrorType(declaredType) {
				return declaredType
			} else {
				return tc.getTypeOfSymbol(symbol)
			}
		}
	}

	if isMetaProperty(node.parent) && node.parent.keywordToken == node.kind {
		return tc.checkMetaPropertyKeyword(node.parent)
	}

	if isImportAttributes(node) {
		return tc.getGlobalImportAttributesType(false)
	}

	return tc.errorType
}

// Gets the type of object literal or array literal of destructuring assignment.
// { a } from
//
//	for ( { a } of elems) {
//	}
//
// [ a ] from
//
//	[a] = [ some array ...]
func (tc *TypeChecker) getTypeOfAssignmentPattern(expr AssignmentPattern) Type {
	Debug.assert(expr.kind == SyntaxKindObjectLiteralExpression || expr.kind == SyntaxKindArrayLiteralExpression)
	// If this is from "for of"
	//     for ( { a } of elems) {
	//     }
	if expr.parent.kind == SyntaxKindForOfStatement {
		iteratedType := tc.checkRightHandSideOfForOf(expr.parent /* as ForOfStatement */)
		return tc.checkDestructuringAssignment(expr, iteratedType || tc.errorType)
	}
	// If this is from "for" initializer
	//     for ({a } = elems[0];.....) { }
	if expr.parent.kind == SyntaxKindBinaryExpression {
		iteratedType := tc.getTypeOfExpression((expr.parent /* as BinaryExpression */).right)
		return tc.checkDestructuringAssignment(expr, iteratedType || tc.errorType)
	}
	// If this is from nested object binding pattern
	//     for ({ skills: { primary, secondary } } = multiRobot, i = 0; i < 1; i++) {
	if expr.parent.kind == SyntaxKindPropertyAssignment {
		node := cast(expr.parent.parent, isObjectLiteralExpression)
		typeOfParentObjectLiteral := tc.getTypeOfAssignmentPattern(node) || tc.errorType
		propertyIndex := indexOfNode(node.properties, expr.parent)
		return tc.checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex)
	}
	// Array literal assignment - array destructuring pattern
	node := cast(expr.parent, isArrayLiteralExpression)
	//    [{ property1: p1, property2 }] = elems;
	typeOfArrayLiteral := tc.getTypeOfAssignmentPattern(node) || tc.errorType
	elementType := tc.checkIteratedTypeOrElementType(IterationUseDestructuring, typeOfArrayLiteral, tc.undefinedType, expr.parent) || tc.errorType
	return tc.checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType)
}

// Gets the property symbol corresponding to the property in destructuring assignment
// 'property1' from
//
//	for ( { property1: a } of elems) {
//	}
//
// 'property1' at location 'a' from:
//
//	[a] = [ property1, property2 ]
func (tc *TypeChecker) getPropertySymbolOfDestructuringAssignment(location Identifier) Symbol {
	// Get the type of the object or array literal and then look for property of given name in the type
	typeOfObjectLiteral := tc.getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern))
	return typeOfObjectLiteral && tc.getPropertyOfType(typeOfObjectLiteral, location.escapedText)
}

func (tc *TypeChecker) getRegularTypeOfExpression(expr Expression) Type {
	if isRightSideOfQualifiedNameOrPropertyAccess(expr) {
		expr = expr.parent /* as Expression */
	}
	return tc.getRegularTypeOfLiteralType(tc.getTypeOfExpression(expr))
}

/**
 * Gets either the static or instance type of a class element, based on
 * whether the element is declared as "static".
 */

func (tc *TypeChecker) getParentTypeOfClassElement(node ClassElement) Type {
	classSymbol := tc.getSymbolOfNode(node.parent)
	if isStatic(node) {
		return tc.getTypeOfSymbol(classSymbol)
	} else {
		return tc.getDeclaredTypeOfSymbol(classSymbol)
	}
}

func (tc *TypeChecker) getClassElementPropertyKeyType(element ClassElement) Type {
	name := element.name
	switch name.kind {
	case SyntaxKindIdentifier:
		return tc.getStringLiteralType(idText(name))
	case SyntaxKindNumericLiteral,
		SyntaxKindStringLiteral:
		return tc.getStringLiteralType(name.text)
	case SyntaxKindComputedPropertyName:
		nameType := tc.checkComputedPropertyName(name)
		if tc.isTypeAssignableToKind(nameType, TypeFlagsESSymbolLike) {
			return nameType
		} else {
			return tc.stringType
		}
	default:
		return Debug.fail("Unsupported property name.")
	}
}

// Return the list of properties of the given type, augmented with properties from Function
// if the type has call or construct signatures
func (tc *TypeChecker) getAugmentedPropertiesOfType(type_ Type) []Symbol {
	type_ = tc.getApparentType(type_)
	propsByName := createSymbolTable(tc.getPropertiesOfType(type_))
	var functionType *ObjectType
	switch {
	case tc.getSignaturesOfType(type_, SignatureKindCall).length:
		functionType = tc.globalCallableFunctionType
	case tc.getSignaturesOfType(type_, SignatureKindConstruct).length:
		functionType = tc.globalNewableFunctionType
	default:
		functionType = nil
	}
	if functionType {
		forEach(tc.getPropertiesOfType(functionType), func(p Symbol) {
			if !propsByName.has(p.escapedName) {
				propsByName.set(p.escapedName, p)
			}
		})
	}
	return tc.getNamedMembers(propsByName)
}

func (tc *TypeChecker) typeHasCallOrConstructSignatures(type_ Type) bool {
	return tc.getSignaturesOfType(type_, SignatureKindCall).length != 0 || tc.getSignaturesOfType(type_, SignatureKindConstruct).length != 0
}

func (tc *TypeChecker) getRootSymbols(symbol Symbol) []Symbol {
	roots := tc.getImmediateRootSymbols(symbol)
	if roots {
		return flatMap(roots, tc.getRootSymbols)
	} else {
		return []Symbol{symbol}
	}
}

func (tc *TypeChecker) getImmediateRootSymbols(symbol Symbol) *[]Symbol {
	if getCheckFlags(symbol) & CheckFlagsSynthetic {
		return mapDefined(tc.getSymbolLinks(symbol).containingType.types, func(type_ Type) Symbol {
			return tc.getPropertyOfType(type_, symbol.escapedName)
		})
	} else if symbol.flags & SymbolFlagsTransient {
		TODO_IDENTIFIER := symbol /* as TransientSymbol */
		switch {
		case leftSpread:
			return []Symbol{leftSpread, rightSpread}
		case syntheticOrigin:
			return []Symbol{syntheticOrigin}
		default:
			return singleElementArray(tc.tryGetTarget(symbol))
		}
	}
	return nil
}

func (tc *TypeChecker) tryGetTarget(symbol Symbol) Symbol {
	var target Symbol
	var next Symbol = symbol
	for /* TODO(TS-TO-GO) EqualsToken BinaryExpression: next = getSymbolLinks(next).target */ TODO {
		target = next
	}
	return target
}

// Emitter support

func (tc *TypeChecker) isArgumentsLocalBinding(nodeIn Identifier) bool {
	// Note: does not handle isShorthandPropertyAssignment (and probably a few more)
	if isGeneratedIdentifier(nodeIn) {
		return false
	}
	node := getParseTreeNode(nodeIn, isIdentifier)
	if !node {
		return false
	}
	parent := node.parent
	if !parent {
		return false
	}
	isPropertyName := (isPropertyAccessExpression(parent) || isPropertyAssignment(parent)) && parent.name == node
	return !isPropertyName && tc.getReferencedValueSymbol(node) == tc.argumentsSymbol
}

func (tc *TypeChecker) isNameOfModuleOrEnumDeclaration(node Identifier) bool {
	return isModuleOrEnumDeclaration(node.parent) && node == node.parent.name
}

// When resolved as an expression identifier, if the given node references an exported entity, return the declaration
// node of the exported entity's container. Otherwise, return undefined.
func (tc *TypeChecker) getReferencedExportContainer(nodeIn Identifier, prefixLocals bool) /* TODO(TS-TO-GO) TypeNode UnionType: SourceFile | ModuleDeclaration | EnumDeclaration | undefined */ any {
	node := getParseTreeNode(nodeIn, isIdentifier)
	if node {
		// When resolving the export container for the name of a module or enum
		// declaration, we need to start resolution at the declaration's container.
		// Otherwise, we could incorrectly resolve the export container as the
		// declaration if it contains an exported member with the same name.
		symbol := tc.getReferencedValueSymbol(node /*startInDeclarationContainer*/, tc.isNameOfModuleOrEnumDeclaration(node))
		if symbol {
			if symbol.flags & SymbolFlagsExportValue {
				// If we reference an exported entity within the same module declaration, then whether
				// we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
				// kinds that we do NOT prefix.
				exportSymbol := tc.getMergedSymbol(symbol.exportSymbol)
				if !prefixLocals && exportSymbol.flags&SymbolFlagsExportHasLocal && !(exportSymbol.flags & SymbolFlagsVariable) {
					return nil
				}
				symbol = exportSymbol
			}
			parentSymbol := tc.getParentOfSymbol(symbol)
			if parentSymbol {
				if parentSymbol.flags&SymbolFlagsValueModule && parentSymbol.valueDeclaration. /* ? */ kind == SyntaxKindSourceFile {
					symbolFile := parentSymbol.valueDeclaration /* as SourceFile */
					referenceFile := getSourceFileOfNode(node)
					// If `node` accesses an export and that export isn't in the same file, then symbol is a namespace export, so return undefined.
					symbolIsUmdExport := symbolFile != referenceFile
					if symbolIsUmdExport {
						return nil
					} else {
						return symbolFile
					}
				}
				return findAncestor(node.parent, func(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is ModuleDeclaration | EnumDeclaration */ any {
					return isModuleOrEnumDeclaration(n) && tc.getSymbolOfDeclaration(n) == parentSymbol
				})
			}
		}
	}
}

// When resolved as an expression identifier, if the given node references an import, return the declaration of
// that import. Otherwise, return undefined.
func (tc *TypeChecker) getReferencedImportDeclaration(nodeIn Identifier) Declaration {
	specifier := getIdentifierGeneratedImportReference(nodeIn)
	if specifier {
		return specifier
	}
	node := getParseTreeNode(nodeIn, isIdentifier)
	if node {
		symbol := tc.getReferencedValueOrAliasSymbol(node)

		// We should only get the declaration of an alias if there isn't a local value
		// declaration for the symbol
		if tc.isNonLocalAlias(symbol /*excludes*/, SymbolFlagsValue) && !tc.getTypeOnlyAliasDeclaration(symbol, SymbolFlagsValue) {
			return tc.getDeclarationOfAliasSymbol(symbol)
		}
	}

	return nil
}

func (tc *TypeChecker) isSymbolOfDestructuredElementOfCatchBinding(symbol Symbol) *bool {
	return symbol.valueDeclaration && isBindingElement(symbol.valueDeclaration) && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind == SyntaxKindCatchClause
}

func (tc *TypeChecker) isSymbolOfDeclarationWithCollidingName(symbol Symbol) bool {
	if symbol.flags&SymbolFlagsBlockScoped && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration) {
		links := tc.getSymbolLinks(symbol)
		if links.isDeclarationWithCollidingName == nil {
			container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
			if isStatementWithLocals(container) || tc.isSymbolOfDestructuredElementOfCatchBinding(symbol) {
				if tc.resolveName(container.parent, symbol.escapedName, SymbolFlagsValue /*nameNotFoundMessage*/, nil /*isUse*/, false) {
					// redeclaration - always should be renamed
					links.isDeclarationWithCollidingName = true
				} else if tc.hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsCapturedBlockScopedBinding) {
					// binding is captured in the function
					// should be renamed if:
					// - binding is not top level - top level bindings never collide with anything
					// AND
					//   - binding is not declared in loop, should be renamed to avoid name reuse across siblings
					//     let a, b
					//     { let x = 1; a = () => x; }
					//     { let x = 100; b = () => x; }
					//     console.log(a()); // should print '1'
					//     console.log(b()); // should print '100'
					//     OR
					//   - binding is declared inside loop but not in inside initializer of iteration statement or directly inside loop body
					//     * variables from initializer are passed to rewritten loop body as parameters so they are not captured directly
					//     * variables that are declared immediately in loop body will become top level variable after loop is rewritten and thus
					//       they will not collide with anything
					isDeclaredInLoop := tc.hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsBlockScopedBindingInLoop)
					inLoopInitializer := isIterationStatement(container /*lookInLabeledStatements*/, false)
					inLoopBodyBlock := container.kind == SyntaxKindBlock && isIterationStatement(container.parent /*lookInLabeledStatements*/, false)

					links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock))
				} else {
					links.isDeclarationWithCollidingName = false
				}
			}
		}
		return links.isDeclarationWithCollidingName
	}
	return false
}

// When resolved as an expression identifier, if the given node references a nested block scoped entity with
// a name that either hides an existing name or might hide it when compiled downlevel,
// return the declaration of that entity. Otherwise, return undefined.
func (tc *TypeChecker) getReferencedDeclarationWithCollidingName(nodeIn Identifier) Declaration {
	if !isGeneratedIdentifier(nodeIn) {
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := tc.getReferencedValueSymbol(node)
			if symbol && tc.isSymbolOfDeclarationWithCollidingName(symbol) {
				return symbol.valueDeclaration
			}
		}
	}

	return nil
}

// Return true if the given node is a declaration of a nested block scoped entity with a name that either hides an
// existing name or might hide a name when compiled downlevel
func (tc *TypeChecker) isDeclarationWithCollidingName(nodeIn Declaration) bool {
	node := getParseTreeNode(nodeIn, isDeclaration)
	if node {
		symbol := tc.getSymbolOfDeclaration(node)
		if symbol {
			return tc.isSymbolOfDeclarationWithCollidingName(symbol)
		}
	}

	return false
}

func (tc *TypeChecker) isValueAliasDeclaration(node Node) bool {
	Debug.assert(tc.canCollectSymbolAliasAccessabilityData)
	switch node.kind {
	case SyntaxKindImportEqualsDeclaration:
		return tc.isAliasResolvedToValue(tc.getSymbolOfDeclaration(node /* as ImportEqualsDeclaration */))
	case SyntaxKindImportClause,
		SyntaxKindNamespaceImport,
		SyntaxKindImportSpecifier,
		SyntaxKindExportSpecifier:
		symbol := tc.getSymbolOfDeclaration(node /* as ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier */)
		return !!symbol && tc.isAliasResolvedToValue(symbol /*excludeTypeOnlyValues*/, true)
	case SyntaxKindExportDeclaration:
		exportClause := (node /* as ExportDeclaration */).exportClause
		return !!exportClause && (isNamespaceExport(exportClause) || some(exportClause.elements, tc.isValueAliasDeclaration))
	case SyntaxKindExportAssignment:
		if (node /* as ExportAssignment */).expression && (node /* as ExportAssignment */).expression.kind == SyntaxKindIdentifier {
			return tc.isAliasResolvedToValue(tc.getSymbolOfDeclaration(node /* as ExportAssignment */) /*excludeTypeOnlyValues*/, true)
		} else {
			return true
		}
	}
	return false
}

func (tc *TypeChecker) isTopLevelValueImportEqualsWithEntityName(nodeIn ImportEqualsDeclaration) bool {
	node := getParseTreeNode(nodeIn, isImportEqualsDeclaration)
	if node == nil || node.parent.kind != SyntaxKindSourceFile || !isInternalModuleImportEqualsDeclaration(node) {
		// parent is not source file or it is not reference to internal module
		return false
	}

	isValue := tc.isAliasResolvedToValue(tc.getSymbolOfDeclaration(node))
	return isValue && node.moduleReference && !nodeIsMissing(node.moduleReference)
}

func (tc *TypeChecker) isAliasResolvedToValue(symbol Symbol, excludeTypeOnlyValues bool) bool {
	if !symbol {
		return false
	}
	container := getSourceFileOfNode(symbol.valueDeclaration)
	fileSymbol := container && tc.getSymbolOfDeclaration(container)
	// Ensures cjs export assignment is setup, since this symbol may point at, and merge with, the file itself.
	// If we don't, the merge may not have yet occured, and the flags check below will be missing flags that
	// are added as a result of the merge.
	tc.resolveExternalModuleSymbol(fileSymbol)
	target := tc.getExportSymbolOfValueSymbolIfExported(tc.resolveAlias(symbol))
	if target == tc.unknownSymbol {
		return !excludeTypeOnlyValues || !tc.getTypeOnlyAliasDeclaration(symbol)
	}
	// const enums and modules that contain only const enums are not considered values from the emit perspective
	// unless 'preserveConstEnums' option is set to true
	return !!(tc.getSymbolFlags(symbol, excludeTypeOnlyValues /*excludeLocalMeanings*/, true) & SymbolFlagsValue) && (shouldPreserveConstEnums(tc.compilerOptions) || !tc.isConstEnumOrConstEnumOnlyModule(target))
}

func (tc *TypeChecker) isConstEnumOrConstEnumOnlyModule(s Symbol) bool {
	return tc.isConstEnumSymbol(s) || !!s.constEnumOnlyModule
}

func (tc *TypeChecker) isReferencedAliasDeclaration(node Node, checkChildren bool) bool {
	Debug.assert(tc.canCollectSymbolAliasAccessabilityData)
	if tc.isAliasSymbolDeclaration(node) {
		symbol := tc.getSymbolOfDeclaration(node /* as Declaration */)
		links := symbol && tc.getSymbolLinks(symbol)
		if links. /* ? */ referenced {
			return true
		}
		target := tc.getSymbolLinks(symbol).aliasTarget
		if target && getEffectiveModifierFlags(node)&ModifierFlagsExport && tc.getSymbolFlags(target)&SymbolFlagsValue && (shouldPreserveConstEnums(tc.compilerOptions) || !tc.isConstEnumOrConstEnumOnlyModule(target)) {
			// An `export import ... =` of a value symbol is always considered referenced
			return true
		}
	}

	if checkChildren {
		return !!forEachChild(node, func(node Node) bool {
			return tc.isReferencedAliasDeclaration(node, checkChildren)
		})
	}
	return false
}

func (tc *TypeChecker) isImplementationOfOverload(node SignatureDeclaration) bool {
	if nodeIsPresent((node /* as FunctionLikeDeclaration */).body) {
		if isGetAccessor(node) || isSetAccessor(node) {
			return false
			// Get or set accessors can never be overload implementations, but can have up to 2 signatures
		}
		// Get or set accessors can never be overload implementations, but can have up to 2 signatures
		symbol := tc.getSymbolOfDeclaration(node)
		signaturesOfSymbol := tc.getSignaturesOfSymbol(symbol)
		// If this function body corresponds to function with multiple signature, it is implementation of overload
		// e.g.: function foo(a: string): string;
		//       function foo(a: number): number;
		//       function foo(a: any) { // This is implementation of the overloads
		//           return a;
		//       }
		return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length == 1 && signaturesOfSymbol[0].declaration != node)
	}
	return false
}

func (tc *TypeChecker) declaredParameterTypeContainsUndefined(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any) bool {
	typeNode := tc.getNonlocalEffectiveTypeAnnotationNode(parameter)
	if !typeNode {
		return false
	}
	type_ := tc.getTypeFromTypeNode(typeNode)
	return tc.containsUndefinedType(type_)
}

func (tc *TypeChecker) requiresAddingImplicitUndefined(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
	return (tc.isRequiredInitializedParameter(parameter, enclosingDeclaration) || tc.isOptionalUninitializedParameterProperty(parameter)) && !tc.declaredParameterTypeContainsUndefined(parameter)
}

func (tc *TypeChecker) isRequiredInitializedParameter(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
	if !tc.strictNullChecks || tc.isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || !parameter.initializer {
		return false
	}
	if hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier) {
		return !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration)
	}
	return true
}

func (tc *TypeChecker) isOptionalUninitializedParameterProperty(parameter /* TODO(TS-TO-GO) TypeNode UnionType: ParameterDeclaration | JSDocParameterTag */ any) bool {
	return tc.strictNullChecks && tc.isOptionalParameter(parameter) && (isJSDocParameterTag(parameter) || !parameter.initializer) && hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier)
}

func (tc *TypeChecker) isExpandoFunctionDeclaration(node Declaration) bool {
	declaration := getParseTreeNode(node, func(n Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: n is FunctionDeclaration | VariableDeclaration */ any {
		return isFunctionDeclaration(n) || isVariableDeclaration(n)
	})
	if !declaration {
		return false
	}
	var symbol Symbol
	if isVariableDeclaration(declaration) {
		if declaration.type_ || (!isInJSFile(declaration) && !tc.isVarConstLike(declaration)) {
			return false
		}
		initializer := getDeclaredExpandoInitializer(declaration)
		if !initializer || !canHaveSymbol(initializer) {
			return false
		}
		symbol = tc.getSymbolOfDeclaration(initializer)
	} else {
		symbol = tc.getSymbolOfDeclaration(declaration)
	}
	if !symbol || !(symbol.flags&SymbolFlagsFunction | SymbolFlagsVariable) {
		return false
	}
	return !!forEachEntry(tc.getExportsOfSymbol(symbol), func(p Symbol) /* TODO(TS-TO-GO) inferred type boolean | 0 */ any {
		return p.flags&SymbolFlagsValue && isExpandoPropertyDeclaration(p.valueDeclaration)
	})
}

func (tc *TypeChecker) getPropertiesOfContainerFunction(node Declaration) []Symbol {
	declaration := getParseTreeNode(node, isFunctionDeclaration)
	if !declaration {
		return emptyArray
	}
	symbol := tc.getSymbolOfDeclaration(declaration)
	return symbol && tc.getPropertiesOfType(tc.getTypeOfSymbol(symbol)) || emptyArray
}

func (tc *TypeChecker) getNodeCheckFlags(node Node) NodeCheckFlags {
	nodeId := node.id || 0
	if nodeId < 0 || nodeId >= tc.nodeLinks.length {
		return 0
	}
	return tc.nodeLinks[nodeId]. /* ? */ flags || 0
}

func (tc *TypeChecker) hasNodeCheckFlag(node Node, flag LazyNodeCheckFlags) bool {
	tc.calculateNodeCheckFlagWorker(node, flag)
	return !!(tc.getNodeCheckFlags(node) & flag)
}

func (tc *TypeChecker) calculateNodeCheckFlagWorker(node Node, flag LazyNodeCheckFlags) {
	if !tc.compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), tc.compilerOptions) {
		// Unless noCheck is passed, assume calculation of node check flags has been done eagerly.
		// This saves needing to mark up where in the eager traversal certain results are "done",
		// just to reconcile the eager and lazy results. This wouldn't be hard if an eager typecheck
		// was actually an in-order traversal, but it isn't - some nodes are deferred, and so don't
		// have these node check flags calculated until that deferral is completed. As an example,
		// in concept, we could consider a class that we've called `checkSourceElement` on as having had
		// these flags calculated, but since the method bodies are deferred, we actually can't set the
		// flags as having been calculated until that deferral is completed.
		// The downside to this either/or approach to eager or lazy calculation is that we can't combine
		// a partial eager traversal and lazy calculation for the missing bits, and there's a bit of
		// overlap in functionality. This isn't a huge loss for any usecases today, but would be nice
		// alongside language service partial file checking and editor-triggered emit.
		return
	}
	links := tc.getNodeLinks(node)
	if links.calculatedFlags & flag {
		return
	}
	// This is only the set of `NodeCheckFlags` our emitter actually looks for, not all of them
	switch flag {
	case NodeCheckFlagsSuperInstance,
		NodeCheckFlagsSuperStatic:
		return checkSingleSuperExpression(node)
	case NodeCheckFlagsMethodWithSuperPropertyAccessInAsync,
		NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync,
		NodeCheckFlagsContainsSuperPropertyInStaticInitializer:
		return checkChildSuperExpressions(node)
	case NodeCheckFlagsCaptureArguments,
		NodeCheckFlagsContainsCapturedBlockScopeBinding,
		NodeCheckFlagsNeedsLoopOutParameter,
		NodeCheckFlagsContainsConstructorReference:
		return checkChildIdentifiers(node)
	case NodeCheckFlagsConstructorReference:
		return checkSingleIdentifier(node)
	case NodeCheckFlagsLoopWithCapturedBlockScopedBinding,
		NodeCheckFlagsBlockScopedBindingInLoop,
		NodeCheckFlagsCapturedBlockScopedBinding:
		return checkContainingBlockScopeBindingUses(node)
	default:
		return Debug.assertNever(flag, __TEMPLATE__("Unhandled node check flag calculation: ", Debug.formatNodeCheckFlags(flag)))
	}

	forEachNodeRecursively := func(root Node, cb func(node Node, parent Node) /* TODO(TS-TO-GO) TypeNode UnionType: T | "skip" | undefined */ any) *T {
		rootResult := cb(root, root.parent)
		if rootResult == "skip" {
			return nil
		}
		if rootResult {
			return rootResult
		}
		return forEachChildRecursively(root, cb)
	}

	checkSuperExpressions := func(node Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
		links := tc.getNodeLinks(node)
		if links.calculatedFlags & flag {
			return "skip"
		}
		links.calculatedFlags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync | NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync | NodeCheckFlagsContainsSuperPropertyInStaticInitializer
		checkSingleSuperExpression(node)
		return nil
	}

	checkChildSuperExpressions := func(node Node) {
		forEachNodeRecursively(node, checkSuperExpressions)
	}

	checkSingleSuperExpression := func(node Node) {
		nodeLinks := tc.getNodeLinks(node)
		// This is called on sub-nodes of the original input, make sure we set `calculatedFlags` on the correct node
		nodeLinks.calculatedFlags |= NodeCheckFlagsSuperInstance | NodeCheckFlagsSuperStatic
		// Yes, we set this on non-applicable nodes, so we can entirely skip the traversal on future calls
		if node.kind == SyntaxKindSuperKeyword {
			tc.checkSuperExpression(node)
		}
	}

	checkIdentifiers := func(node Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
		links := tc.getNodeLinks(node)
		if links.calculatedFlags & flag {
			return "skip"
		}
		links.calculatedFlags |= NodeCheckFlagsCaptureArguments | NodeCheckFlagsContainsCapturedBlockScopeBinding | NodeCheckFlagsNeedsLoopOutParameter | NodeCheckFlagsContainsConstructorReference
		checkSingleIdentifier(node)
		return nil
	}

	checkChildIdentifiers := func(node Node) {
		forEachNodeRecursively(node, checkIdentifiers)
	}

	isExpressionNodeOrShorthandPropertyAssignmentName := func(node Identifier) bool {
		// TODO(jakebailey): Just use isExpressionNode once that considers these identifiers to be expressions.
		return isExpressionNode(node) || isShorthandPropertyAssignment(node.parent) && ( /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: node.parent.objectAssignmentInitializer ?? node.parent.name */ TODO) == node
	}

	checkSingleIdentifier := func(node Node) {
		nodeLinks := tc.getNodeLinks(node)
		nodeLinks.calculatedFlags |= NodeCheckFlagsConstructorReference
		if isIdentifier(node) {
			nodeLinks.calculatedFlags |= NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
			// Can't set on all arbitrary nodes (these nodes have this flag set by `checkSingleBlockScopeBinding` only)
			if isExpressionNodeOrShorthandPropertyAssignmentName(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name == node) {
				s := tc.getResolvedSymbol(node)
				if s && s != tc.unknownSymbol {
					tc.checkIdentifierCalculateNodeCheckFlags(node, s)
				}
			}
		}
	}

	checkBlockScopeBindings := func(node Node) * /* TODO(TS-TO-GO) inferred type "skip" */ any {
		links := tc.getNodeLinks(node)
		if links.calculatedFlags & flag {
			return "skip"
		}
		links.calculatedFlags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding | NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
		checkSingleBlockScopeBinding(node)
		return nil
	}

	checkContainingBlockScopeBindingUses := func(node Node) {
		scope := getEnclosingBlockScopeContainer(__COND__(isDeclarationName(node), node.parent, node))
		forEachNodeRecursively(scope, checkBlockScopeBindings)
	}

	checkSingleBlockScopeBinding := func(node Node) {
		checkSingleIdentifier(node)
		if isComputedPropertyName(node) {
			tc.checkComputedPropertyName(node)
		}
		if isPrivateIdentifier(node) && isClassElement(node.parent) {
			tc.setNodeLinksForPrivateIdentifierScope(node.parent /* as PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */)
		}
	}

}

func (tc *TypeChecker) getEnumMemberValue(node EnumMember) EvaluatorResult {
	tc.computeEnumMemberValues(node.parent)
	return /* TODO(TS-TO-GO) QuestionQuestionToken BinaryExpression: getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value* / undefined) */ TODO
}

func (tc *TypeChecker) canHaveConstantValue(node Node) /* TODO(TS-TO-GO) TypeNode TypePredicate: node is EnumMember | AccessExpression */ any {
	switch node.kind {
	case SyntaxKindEnumMember,
		SyntaxKindPropertyAccessExpression,
		SyntaxKindElementAccessExpression:
		return true
	}
	return false
}

func (tc *TypeChecker) getConstantValue(node /* TODO(TS-TO-GO) TypeNode UnionType: EnumMember | AccessExpression */ any) /* TODO(TS-TO-GO) TypeNode UnionType: string | number | undefined */ any {
	if node.kind == SyntaxKindEnumMember {
		return tc.getEnumMemberValue(node).value
	}

	if !tc.getNodeLinks(node).resolvedSymbol {
		tc.checkExpressionCached(node)
		// ensure cached resolved symbol is set
	}
	symbol := tc.getNodeLinks(node).resolvedSymbol || (__COND__(isEntityNameExpression(node), tc.resolveEntityName(node, SymbolFlagsValue /*ignoreErrors*/, true), nil))
	if symbol && (symbol.flags & SymbolFlagsEnumMember) {
		// inline property\index accesses only for const enums
		member := symbol.valueDeclaration /* as EnumMember */
		if isEnumConst(member.parent) {
			return tc.getEnumMemberValue(member).value
		}
	}

	return nil
}

func (tc *TypeChecker) isFunctionType(type_ Type) bool {
	return !!(type_.flags & TypeFlagsObject) && tc.getSignaturesOfType(type_, SignatureKindCall).length > 0
}

func (tc *TypeChecker) getTypeReferenceSerializationKind(typeNameIn EntityName, location Node) TypeReferenceSerializationKind {
	// ensure both `typeName` and `location` are parse tree nodes.
	typeName := getParseTreeNode(typeNameIn, isEntityName)
	if !typeName {
		return TypeReferenceSerializationKindUnknown
	}

	if location {
		location = getParseTreeNode(location)
		if !location {
			return TypeReferenceSerializationKindUnknown
		}
	}

	// Resolve the symbol as a value to ensure the type can be reached at runtime during emit.
	isTypeOnly := false
	if isQualifiedName(typeName) {
		rootValueSymbol := tc.resolveEntityName(getFirstIdentifier(typeName), SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, true, location)
		isTypeOnly = !!rootValueSymbol. /* ? */ declarations. /* ? */ every(isTypeOnlyImportOrExportDeclaration)
	}
	valueSymbol := tc.resolveEntityName(typeName, SymbolFlagsValue /*ignoreErrors*/, true /*dontResolveAlias*/, true, location)
	var resolvedValueSymbol Symbol
	if valueSymbol && valueSymbol.flags&SymbolFlagsAlias {
		resolvedValueSymbol = tc.resolveAlias(valueSymbol)
	} else {
		resolvedValueSymbol = valueSymbol
	}
	isTypeOnly = isTypeOnly || !!(valueSymbol && tc.getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlagsValue))

	// Resolve the symbol as a type so that we can provide a more useful hint for the type serializer.
	typeSymbol := tc.resolveEntityName(typeName, SymbolFlagsType /*ignoreErrors*/, true /*dontResolveAlias*/, true, location)
	var resolvedTypeSymbol Symbol
	if typeSymbol && typeSymbol.flags&SymbolFlagsAlias {
		resolvedTypeSymbol = tc.resolveAlias(typeSymbol)
	} else {
		resolvedTypeSymbol = typeSymbol
	}

	// In case the value symbol can't be resolved (e.g. because of missing declarations), use type symbol for reachability check.
	if !valueSymbol {
		isTypeOnly = isTypeOnly || !!(typeSymbol && tc.getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlagsType))
	}

	if resolvedValueSymbol && resolvedValueSymbol == resolvedTypeSymbol {
		globalPromiseSymbol := tc.getGlobalPromiseConstructorSymbol(false)
		if globalPromiseSymbol && resolvedValueSymbol == globalPromiseSymbol {
			return TypeReferenceSerializationKindPromise
		}

		constructorType := tc.getTypeOfSymbol(resolvedValueSymbol)
		if constructorType && tc.isConstructorType(constructorType) {
			if isTypeOnly {
				return TypeReferenceSerializationKindTypeWithCallSignature
			} else {
				return TypeReferenceSerializationKindTypeWithConstructSignatureAndValue
			}
		}
	}

	// We might not be able to resolve type symbol so use unknown type in that case (eg error case)
	if !resolvedTypeSymbol {
		if isTypeOnly {
			return TypeReferenceSerializationKindObjectType
		} else {
			return TypeReferenceSerializationKindUnknown
		}
	}
	type_ := tc.getDeclaredTypeOfSymbol(resolvedTypeSymbol)
	if tc.isErrorType(type_) {
		if isTypeOnly {
			return TypeReferenceSerializationKindObjectType
		} else {
			return TypeReferenceSerializationKindUnknown
		}
	} else if type_.flags & TypeFlagsAnyOrUnknown {
		return TypeReferenceSerializationKindObjectType
	} else if tc.isTypeAssignableToKind(type_, TypeFlagsVoid|TypeFlagsNullable|TypeFlagsNever) {
		return TypeReferenceSerializationKindVoidNullableOrNeverType
	} else if tc.isTypeAssignableToKind(type_, TypeFlagsBooleanLike) {
		return TypeReferenceSerializationKindBooleanType
	} else if tc.isTypeAssignableToKind(type_, TypeFlagsNumberLike) {
		return TypeReferenceSerializationKindNumberLikeType
	} else if tc.isTypeAssignableToKind(type_, TypeFlagsBigIntLike) {
		return TypeReferenceSerializationKindBigIntLikeType
	} else if tc.isTypeAssignableToKind(type_, TypeFlagsStringLike) {
		return TypeReferenceSerializationKindStringLikeType
	} else if tc.isTupleType(type_) {
		return TypeReferenceSerializationKindArrayLikeType
	} else if tc.isTypeAssignableToKind(type_, TypeFlagsESSymbolLike) {
		return TypeReferenceSerializationKindESSymbolType
	} else if tc.isFunctionType(type_) {
		return TypeReferenceSerializationKindTypeWithCallSignature
	} else if tc.isArrayType(type_) {
		return TypeReferenceSerializationKindArrayLikeType
	} else {
		return TypeReferenceSerializationKindObjectType
	}
}

func (tc *TypeChecker) createTypeOfDeclaration(declarationIn /* TODO(TS-TO-GO) TypeNode UnionType: AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
	declaration := getParseTreeNode(declarationIn, isVariableLikeOrAccessor)
	if !declaration {
		return factory.createToken(SyntaxKindAnyKeyword) /* as KeywordTypeNode */
	}
	// Get type of the symbol if this is the valid symbol otherwise get type at location
	symbol := tc.getSymbolOfDeclaration(declaration)
	var type_ Type
	if symbol && !(symbol.flags & (SymbolFlagsTypeLiteral | SymbolFlagsSignature)) {
		type_ = tc.getWidenedLiteralType(tc.getTypeOfSymbol(symbol))
	} else {
		type_ = tc.errorType
	}

	return tc.nodeBuilder.serializeTypeForDeclaration(declaration, type_, symbol, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
}

func (tc *TypeChecker) isDeclarationWithPossibleInnerTypeNodeReuse(declaration Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: declaration is DeclarationWithPotentialInnerNodeReuse */ any {
	return isFunctionLike(declaration) || isExportAssignment(declaration) || isVariableLike(declaration)
}

func (tc *TypeChecker) getAllAccessorDeclarationsForDeclaration(accessor AccessorDeclaration) AllAccessorDeclarations {
	accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)
	// TODO: GH#18217
	var otherKind /* TODO(TS-TO-GO) inferred type SyntaxKind.GetAccessor | SyntaxKind.SetAccessor */ any
	if accessor.kind == SyntaxKindSetAccessor {
		otherKind = SyntaxKindGetAccessor
	} else {
		otherKind = SyntaxKindSetAccessor
	}
	otherAccessor := getDeclarationOfKind(tc.getSymbolOfDeclaration(accessor), otherKind)
	var firstAccessor AccessorDeclaration
	if otherAccessor && (otherAccessor.pos < accessor.pos) {
		firstAccessor = otherAccessor
	} else {
		firstAccessor = accessor
	}
	var secondAccessor *AccessorDeclaration
	if otherAccessor && (otherAccessor.pos < accessor.pos) {
		secondAccessor = accessor
	} else {
		secondAccessor = otherAccessor
	}
	var setAccessor SetAccessorDeclaration
	if accessor.kind == SyntaxKindSetAccessor {
		setAccessor = accessor
	} else {
		setAccessor = otherAccessor /* as SetAccessorDeclaration */
	}
	var getAccessor GetAccessorDeclaration
	if accessor.kind == SyntaxKindGetAccessor {
		getAccessor = accessor
	} else {
		getAccessor = otherAccessor /* as GetAccessorDeclaration */
	}
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"firstAccessor":  firstAccessor,
		"secondAccessor": secondAccessor,
		"setAccessor":    setAccessor,
		"getAccessor":    getAccessor,
	}
}

func (tc *TypeChecker) getPossibleTypeNodeReuseExpression(declaration DeclarationWithPotentialInnerNodeReuse) Expression {
	switch {
	case isFunctionLike(declaration) && !isSetAccessor(declaration):
		return tc.getSingleReturnExpression(declaration)
	case isExportAssignment(declaration):
		return declaration.expression
	case !!(declaration /* as HasInitializer */).initializer:
		return (declaration /* as HasInitializer & typeof declaration */).initializer
	case isParameter(declaration) && isSetAccessor(declaration.parent):
		return tc.getSingleReturnExpression(tc.getAllAccessorDeclarationsForDeclaration(declaration.parent).getAccessor)
	default:
		return nil
	}
}

func (tc *TypeChecker) getSingleReturnExpression(declaration *SignatureDeclaration) Expression {
	var candidateExpr Expression
	if declaration && !nodeIsMissing((declaration /* as FunctionLikeDeclaration */).body) {
		if getFunctionFlags(declaration) & FunctionFlagsAsyncGenerator {
			return nil
		}
		body := (declaration /* as FunctionLikeDeclaration */).body
		if body && isBlock(body) {
			forEachReturnStatement(body, func(s ReturnStatement) *true {
				if !candidateExpr {
					candidateExpr = s.expression
				} else {
					candidateExpr = nil
					return true
				}
			})
		} else {
			candidateExpr = body
		}
	}
	return candidateExpr
}

func (tc *TypeChecker) createReturnTypeOfSignatureDeclaration(signatureDeclarationIn SignatureDeclaration, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
	signatureDeclaration := getParseTreeNode(signatureDeclarationIn, isFunctionLike)
	if !signatureDeclaration {
		return factory.createToken(SyntaxKindAnyKeyword) /* as KeywordTypeNode */
	}
	return tc.nodeBuilder.serializeReturnTypeForSignature(tc.getSignatureFromDeclaration(signatureDeclaration), enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
}

func (tc *TypeChecker) createTypeOfExpression(exprIn Expression, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *TypeNode {
	expr := getParseTreeNode(exprIn, isExpression)
	if !expr {
		return factory.createToken(SyntaxKindAnyKeyword) /* as KeywordTypeNode */
	}
	type_ := tc.getWidenedType(tc.getRegularTypeOfExpression(expr))
	return tc.nodeBuilder.expressionOrTypeToTypeNode(expr, type_ /*addUndefined*/, nil, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
}

func (tc *TypeChecker) hasGlobalName(name string) bool {
	return tc.globals.has(escapeLeadingUnderscores(name))
}

func (tc *TypeChecker) getReferencedValueSymbol(reference Identifier, startInDeclarationContainer bool) Symbol {
	resolvedSymbol := tc.getNodeLinks(reference).resolvedSymbol
	if resolvedSymbol {
		return resolvedSymbol
	}

	var location Node = reference
	if startInDeclarationContainer {
		// When resolving the name of a declaration as a value, we need to start resolution
		// at a point outside of the declaration.
		parent := reference.parent
		if isDeclaration(parent) && reference == parent.name {
			location = tc.getDeclarationContainer(parent)
		}
	}

	return tc.resolveName(location, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias /*nameNotFoundMessage*/, nil /*isUse*/, true)
}

/**
 * Get either a value-meaning symbol or an alias symbol.
 * Unlike `getReferencedValueSymbol`, if the cached resolved symbol is the unknown symbol,
 * we call `resolveName` to find a symbol.
 * This is because when caching the resolved symbol, we only consider value symbols, but here
 * we want to also get an alias symbol if one exists.
 */

func (tc *TypeChecker) getReferencedValueOrAliasSymbol(reference Identifier) Symbol {
	resolvedSymbol := tc.getNodeLinks(reference).resolvedSymbol
	if resolvedSymbol && resolvedSymbol != tc.unknownSymbol {
		return resolvedSymbol
	}

	return tc.resolveName(reference, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true, nil)
}

func (tc *TypeChecker) getReferencedValueDeclaration(referenceIn Identifier) Declaration {
	if !isGeneratedIdentifier(referenceIn) {
		reference := getParseTreeNode(referenceIn, isIdentifier)
		if reference {
			symbol := tc.getReferencedValueSymbol(reference)
			if symbol {
				return tc.getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration
			}
		}
	}

	return nil
}

func (tc *TypeChecker) getReferencedValueDeclarations(referenceIn Identifier) *[]Declaration {
	if !isGeneratedIdentifier(referenceIn) {
		reference := getParseTreeNode(referenceIn, isIdentifier)
		if reference {
			symbol := tc.getReferencedValueSymbol(reference)
			if symbol {
				return filter(tc.getExportSymbolOfValueSymbolIfExported(symbol).declarations, func(declaration Declaration) bool {
					switch declaration.kind {
					case SyntaxKindVariableDeclaration,
						SyntaxKindParameter,
						SyntaxKindBindingElement,
						SyntaxKindPropertyDeclaration,
						SyntaxKindPropertyAssignment,
						SyntaxKindShorthandPropertyAssignment,
						SyntaxKindEnumMember,
						SyntaxKindObjectLiteralExpression,
						SyntaxKindFunctionDeclaration,
						SyntaxKindFunctionExpression,
						SyntaxKindArrowFunction,
						SyntaxKindClassDeclaration,
						SyntaxKindClassExpression,
						SyntaxKindEnumDeclaration,
						SyntaxKindMethodDeclaration,
						SyntaxKindGetAccessor,
						SyntaxKindSetAccessor,
						SyntaxKindModuleDeclaration:
						return true
					}
					return false
				})
			}
		}
	}

	return nil
}

func (tc *TypeChecker) isLiteralConstDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any) bool {
	if isDeclarationReadonly(node) || isVariableDeclaration(node) && tc.isVarConstLike(node) {
		return tc.isFreshLiteralType(tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node)))
	}
	return false
}

func (tc *TypeChecker) literalTypeToNode(type_ FreshableType, enclosing Node, tracker SymbolTracker) Expression {
	var enumResult * /* TODO(TS-TO-GO) inferred type false | Expression */ any
	switch {
	case type_.flags & TypeFlagsEnumLike:
		enumResult = tc.nodeBuilder.symbolToExpression(type_.symbol, SymbolFlagsValue, enclosing /*flags*/, nil /*internalFlags*/, nil, tracker)
	case type_ == tc.trueType:
		enumResult = factory.createTrue()
	default:
		enumResult = type_ == tc.falseType && factory.createFalse()
	}
	if enumResult {
		return enumResult
	}
	literalValue := (type_ /* as LiteralType */).value
	switch {
	case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof literalValue */ TODO == "object":
		return factory.createBigIntLiteral(literalValue)
	case /* TODO(TS-TO-GO) Node TypeOfExpression: typeof literalValue */ TODO == "string":
		return factory.createStringLiteral(literalValue)
	case literalValue < 0:
		return factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-literalValue))
	default:
		return factory.createNumericLiteral(literalValue)
	}
}

func (tc *TypeChecker) createLiteralConstValue(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any, tracker SymbolTracker) Expression {
	type_ := tc.getTypeOfSymbol(tc.getSymbolOfDeclaration(node))
	return tc.literalTypeToNode(type_ /* as FreshableType */, node, tracker)
}

func (tc *TypeChecker) getJsxFactoryEntity(location Node) *EntityName {
	if location {
		return ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity) */ TODO)
	} else {
		return tc._jsxFactoryEntity
	}
}

func (tc *TypeChecker) getJsxFragmentFactoryEntity(location Node) *EntityName {
	if location {
		file := getSourceFileOfNode(location)
		if file {
			if file.localJsxFragmentFactory {
				return file.localJsxFragmentFactory
			}
			jsxFragPragmas := file.pragmas.get("jsxfrag")
			var jsxFragPragma /* TODO(TS-TO-GO) inferred type { arguments: { factory: string; }; range: CommentRange; } */ any
			if isArray(jsxFragPragmas) {
				jsxFragPragma = jsxFragPragmas[0]
			} else {
				jsxFragPragma = jsxFragPragmas
			}
			if jsxFragPragma {
				file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, tc.languageVersion)
				return file.localJsxFragmentFactory
			}
		}
	}

	if tc.compilerOptions.jsxFragmentFactory {
		return parseIsolatedEntityName(tc.compilerOptions.jsxFragmentFactory, tc.languageVersion)
	}
}

func (tc *TypeChecker) getNonlocalEffectiveTypeAnnotationNode(node Node) *TypeNode {
	direct := getEffectiveTypeAnnotationNode(node)
	if direct {
		return direct
	}
	if node.kind == SyntaxKindParameter && node.parent.kind == SyntaxKindSetAccessor {
		other := tc.getAllAccessorDeclarationsForDeclaration(node.parent /* as SetAccessorDeclaration */).getAccessor
		if other {
			return getEffectiveReturnTypeNode(other)
		}
	}
	return nil
}

func (tc *TypeChecker) getNonlocalEffectiveReturnTypeAnnotationNode(node /* TODO(TS-TO-GO) TypeNode UnionType: SignatureDeclaration | JSDocSignature */ any) *TypeNode {
	direct := getEffectiveReturnTypeNode(node)
	if direct {
		return direct
	}
	if node.kind == SyntaxKindGetAccessor {
		other := tc.getAllAccessorDeclarationsForDeclaration(node).setAccessor
		if other {
			param := getSetAccessorValueParameter(other)
			if param {
				return getEffectiveTypeAnnotationNode(param)
			}
		}
	}
	return nil
}

func (tc *TypeChecker) createResolver() EmitResolver {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getReferencedExportContainer":              getReferencedExportContainer,
		"getReferencedImportDeclaration":            getReferencedImportDeclaration,
		"getReferencedDeclarationWithCollidingName": getReferencedDeclarationWithCollidingName,
		"isDeclarationWithCollidingName":            isDeclarationWithCollidingName,
		"isValueAliasDeclaration": func(nodeIn Node) bool {
			node := getParseTreeNode(nodeIn)
			// Synthesized nodes are always treated like values.
			if node && tc.canCollectSymbolAliasAccessabilityData {
				return tc.isValueAliasDeclaration(node)
			} else {
				return true
			}
		},
		"hasGlobalName": hasGlobalName,
		"isReferencedAliasDeclaration": func(nodeIn Node, checkChildren *bool) bool {
			node := getParseTreeNode(nodeIn)
			// Synthesized nodes are always treated as referenced.
			if node && tc.canCollectSymbolAliasAccessabilityData {
				return tc.isReferencedAliasDeclaration(node, checkChildren)
			} else {
				return true
			}
		},
		"hasNodeCheckFlag": func(nodeIn Node, flag LazyNodeCheckFlags) bool {
			node := getParseTreeNode(nodeIn)
			if !node {
				return false
			}
			return tc.hasNodeCheckFlag(node, flag)
		},
		"isTopLevelValueImportEqualsWithEntityName": isTopLevelValueImportEqualsWithEntityName,
		"isDeclarationVisible":                      isDeclarationVisible,
		"isImplementationOfOverload":                isImplementationOfOverload,
		"requiresAddingImplicitUndefined":           requiresAddingImplicitUndefined,
		"isExpandoFunctionDeclaration":              isExpandoFunctionDeclaration,
		"getPropertiesOfContainerFunction":          getPropertiesOfContainerFunction,
		"createTypeOfDeclaration":                   createTypeOfDeclaration,
		"createReturnTypeOfSignatureDeclaration":    createReturnTypeOfSignatureDeclaration,
		"createTypeOfExpression":                    createTypeOfExpression,
		"createLiteralConstValue":                   createLiteralConstValue,
		"isSymbolAccessible":                        isSymbolAccessible,
		"isEntityNameVisible":                       isEntityNameVisible,
		"getConstantValue": func(nodeIn /* TODO(TS-TO-GO) inferred type PropertyAccessExpression | ElementAccessExpression | EnumMember */ any) * /* TODO(TS-TO-GO) inferred type string | number */ any {
			node := getParseTreeNode(nodeIn, tc.canHaveConstantValue)
			if node {
				return tc.getConstantValue(node)
			} else {
				return nil
			}
		},
		"getEnumMemberValue": func(nodeIn EnumMember) * /* TODO(TS-TO-GO) inferred type EvaluatorResult<string | number | undefined> */ any {
			node := getParseTreeNode(nodeIn, isEnumMember)
			if node {
				return tc.getEnumMemberValue(node)
			} else {
				return nil
			}
		},
		"collectLinkedAliases": collectLinkedAliases,
		"markLinkedReferences": func(nodeIn Node) {
			node := getParseTreeNode(nodeIn)
			return node && tc.markLinkedReferences(node, ReferenceHintUnspecified)
		},
		"getReferencedValueDeclaration":     getReferencedValueDeclaration,
		"getReferencedValueDeclarations":    getReferencedValueDeclarations,
		"getTypeReferenceSerializationKind": getTypeReferenceSerializationKind,
		"isOptionalParameter":               isOptionalParameter,
		"isArgumentsLocalBinding":           isArgumentsLocalBinding,
		"getExternalModuleFileFromDeclaration": func(nodeIn /* TODO(TS-TO-GO) inferred type ExportDeclaration | ImportDeclaration | ImportEqualsDeclaration | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
			node := getParseTreeNode(nodeIn, hasPossibleExternalModuleReference)
			return node && tc.getExternalModuleFileFromDeclaration(node)
		},
		"isLiteralConstDeclaration": isLiteralConstDeclaration,
		"isLateBound": func(nodeIn Declaration) /* TODO(TS-TO-GO) TypeNode TypePredicate: nodeIn is LateBoundDeclaration */ any {
			node := getParseTreeNode(nodeIn, isDeclaration)
			symbol := node && tc.getSymbolOfDeclaration(node)
			return !!(symbol && getCheckFlags(symbol)&CheckFlagsLate)
		},
		"getJsxFactoryEntity":         getJsxFactoryEntity,
		"getJsxFragmentFactoryEntity": getJsxFragmentFactoryEntity,
		"isBindingCapturedByNode": func(node Node, decl /* TODO(TS-TO-GO) inferred type VariableDeclaration | BindingElement */ any) bool {
			parseNode := getParseTreeNode(node)
			parseDecl := getParseTreeNode(decl)
			return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && tc.isBindingCapturedByNode(parseNode, parseDecl)
		},
		"getDeclarationStatementsForSourceFile": func(node SourceFile, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) *[]Statement {
			n := getParseTreeNode(node) /* as SourceFile */
			Debug.assert(n && n.kind == SyntaxKindSourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile")
			sym := tc.getSymbolOfDeclaration(node)
			if !sym {
				if !node.locals {
					return []never{}
				} else {
					return tc.nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker)
				}
			}
			tc.resolveExternalModuleSymbol(sym)
			// ensures cjs export assignment is setup
			if !sym.exports {
				return []never{}
			} else {
				return tc.nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker)
			}
		},
		"isImportRequiredByAugmentation":            isImportRequiredByAugmentation,
		"isDefinitelyReferenceToGlobalSymbolObject": isDefinitelyReferenceToGlobalSymbolObject,
	}

	isImportRequiredByAugmentation := func(node ImportDeclaration) bool {
		file := getSourceFileOfNode(node)
		if !file.symbol {
			return false
		}
		importTarget := tc.getExternalModuleFileFromDeclaration(node)
		if !importTarget {
			return false
		}
		if importTarget == file {
			return false
		}
		exports := tc.getExportsOfModule(file.symbol)
		for _, s := range arrayFrom(exports.values()) {
			if s.mergeId {
				merged := tc.getMergedSymbol(s)
				if merged.declarations {
					for _, d := range merged.declarations {
						declFile := getSourceFileOfNode(d)
						if declFile == importTarget {
							return true
						}
					}
				}
			}
		}
		return false
	}

}

func (tc *TypeChecker) getExternalModuleFileFromDeclaration(declaration /* TODO(TS-TO-GO) TypeNode UnionType: AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
	var specifier Expression
	if declaration.kind == SyntaxKindModuleDeclaration {
		specifier = tryCast(declaration.name, isStringLiteral)
	} else {
		specifier = getExternalModuleName(declaration)
	}
	moduleSymbol := tc.resolveExternalModuleNameWorker(specifier, specifier /*moduleNotFoundError*/, nil)
	// TODO: GH#18217
	if !moduleSymbol {
		return nil
	}
	return getDeclarationOfKind(moduleSymbol, SyntaxKindSourceFile)
}

func (tc *TypeChecker) initializeTypeChecker() {
	// Bind all source files and propagate errors
	for _, file := range host.getSourceFiles() {
		bindSourceFile(file, tc.compilerOptions)
	}

	tc.amalgamatedDuplicates = NewMap()

	// Initialize global symbol table
	var augmentations *[][] /* TODO(TS-TO-GO) TypeNode UnionType: StringLiteral | Identifier */ any
	for _, file := range host.getSourceFiles() {
		if file.redirectInfo {
			continue
		}
		if !isExternalOrCommonJsModule(file) {
			// It is an error for a non-external-module (i.e. script) to declare its own `globalThis`.
			fileGlobalThisSymbol := file.locals.get("globalThis" /* as __String */)
			if fileGlobalThisSymbol. /* ? */ declarations {
				for _, declaration := range fileGlobalThisSymbol.declarations {
					tc.diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"))
				}
			}
			tc.mergeSymbolTable(tc.globals, file.locals)
		}
		if file.jsGlobalAugmentations {
			tc.mergeSymbolTable(tc.globals, file.jsGlobalAugmentations)
		}
		if file.patternAmbientModules && file.patternAmbientModules.length {
			tc.patternAmbientModules = concatenate(tc.patternAmbientModules, file.patternAmbientModules)
		}
		if file.moduleAugmentations.length {
			(augmentations || ( /* TODO(TS-TO-GO) EqualsToken BinaryExpression: augmentations = [] */ TODO)).push(file.moduleAugmentations)
		}
		if file.symbol && file.symbol.globalExports {
			// Merge in UMD exports with first-in-wins semantics (see #9771)
			source := file.symbol.globalExports
			source.forEach(func(sourceSymbol Symbol, id __String) {
				if !tc.globals.has(id) {
					tc.globals.set(id, sourceSymbol)
				}
			})
		}
	}

	// We do global augmentations separately from module augmentations (and before creating global types) because they
	//  1. Affect global types. We won't have the correct global types until global augmentations are merged. Also,
	//  2. Module augmentation instantiation requires creating the type of a module, which, in turn, can require
	//       checking for an export or property on the module (if export=) which, in turn, can fall back to the
	//       apparent type of the module - either globalObjectType or globalFunctionType - which wouldn't exist if we
	//       did module augmentations prior to finalizing the global types.
	if augmentations {
		// merge _global_ module augmentations.
		// this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
		for _, list := range augmentations {
			for _, augmentation := range list {
				if !isGlobalScopeAugmentation(augmentation.parent /* as ModuleDeclaration */) {
					continue
				}
				tc.mergeModuleAugmentation(augmentation)
			}
		}
	}

	tc.addUndefinedToGlobalsOrErrorOnRedeclaration()

	tc.getSymbolLinks(tc.undefinedSymbol).type_ = tc.undefinedWideningType
	tc.getSymbolLinks(tc.argumentsSymbol).type_ = tc.getGlobalType("IArguments" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
	tc.getSymbolLinks(tc.unknownSymbol).type_ = tc.errorType
	tc.getSymbolLinks(tc.globalThisSymbol).type_ = tc.createObjectType(ObjectFlagsAnonymous, tc.globalThisSymbol)

	// Initialize special types
	tc.globalArrayType = tc.getGlobalType("Array" /* as __String */ /*arity*/, 1 /*reportErrors*/, true)
	tc.globalObjectType = tc.getGlobalType("Object" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
	tc.globalFunctionType = tc.getGlobalType("Function" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
	tc.globalCallableFunctionType = tc.strictBindCallApply && tc.getGlobalType("CallableFunction" /* as __String */ /*arity*/, 0 /*reportErrors*/, true) || tc.globalFunctionType
	tc.globalNewableFunctionType = tc.strictBindCallApply && tc.getGlobalType("NewableFunction" /* as __String */ /*arity*/, 0 /*reportErrors*/, true) || tc.globalFunctionType
	tc.globalStringType = tc.getGlobalType("String" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
	tc.globalNumberType = tc.getGlobalType("Number" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
	tc.globalBooleanType = tc.getGlobalType("Boolean" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
	tc.globalRegExpType = tc.getGlobalType("RegExp" /* as __String */ /*arity*/, 0 /*reportErrors*/, true)
	tc.anyArrayType = tc.createArrayType(tc.anyType)

	tc.autoArrayType = tc.createArrayType(tc.autoType)
	if tc.autoArrayType == tc.emptyObjectType {
		// autoArrayType is used as a marker, so even if global Array type is not defined, it needs to be a unique type
		tc.autoArrayType = tc.createAnonymousType(nil, tc.emptySymbols, emptyArray, emptyArray, emptyArray)
	}

	tc.globalReadonlyArrayType = tc.getGlobalTypeOrUndefined("ReadonlyArray" /* as __String */ /*arity*/, 1) /* as GenericType */ || tc.globalArrayType
	if tc.globalReadonlyArrayType {
		tc.anyReadonlyArrayType = tc.createTypeFromGenericGlobalType(tc.globalReadonlyArrayType, []IntrinsicType{tc.anyType})
	} else {
		tc.anyReadonlyArrayType = tc.anyArrayType
	}
	tc.globalThisType = tc.getGlobalTypeOrUndefined("ThisType" /* as __String */ /*arity*/, 1) /* as GenericType */

	if augmentations {
		// merge _nonglobal_ module augmentations.
		// this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
		for _, list := range augmentations {
			for _, augmentation := range list {
				if isGlobalScopeAugmentation(augmentation.parent /* as ModuleDeclaration */) {
					continue
				}
				tc.mergeModuleAugmentation(augmentation)
			}
		}
	}

	tc.amalgamatedDuplicates.forEach(func(TODO_IDENTIFIER DuplicateInfoForFiles) {
		// If not many things conflict, issue individual errors
		if conflictingSymbols.size < 8 {
			conflictingSymbols.forEach(func(TODO_IDENTIFIER DuplicateInfoForSymbol, symbolName string) {
				var message DiagnosticMessage
				if isBlockScoped {
					message = Diagnostics.Cannot_redeclare_block_scoped_variable_0
				} else {
					message = Diagnostics.Duplicate_identifier_0
				}
				for _, node := range firstFileLocations {
					tc.addDuplicateDeclarationError(node, message, symbolName, secondFileLocations)
				}
				for _, node := range secondFileLocations {
					tc.addDuplicateDeclarationError(node, message, symbolName, firstFileLocations)
				}
			})
		} else {
			// Otherwise issue top-level error since the files appear very identical in terms of what they contain
			list := arrayFrom(conflictingSymbols.keys()).join(", ")
			tc.diagnostics.add(addRelatedInfo(createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file)))
			tc.diagnostics.add(addRelatedInfo(createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file)))
		}
	})
	tc.amalgamatedDuplicates = nil
}

func (tc *TypeChecker) checkExternalEmitHelpers(location Node, helpers ExternalEmitHelpers) {
	if tc.compilerOptions.importHelpers {
		sourceFile := getSourceFileOfNode(location)
		if isEffectiveExternalModule(sourceFile, tc.compilerOptions) && !(location.flags & NodeFlagsAmbient) {
			helpersModule := tc.resolveHelpersModule(sourceFile, location)
			if helpersModule != tc.unknownSymbol {
				links := tc.getSymbolLinks(helpersModule)
				/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers */ TODO
				if (links.requestedExternalEmitHelpers & helpers) != helpers {
					uncheckedHelpers := helpers & ~links.requestedExternalEmitHelpers
					for helper := ExternalEmitHelpersFirstEmitHelper; helper <= ExternalEmitHelpersLastEmitHelper; helper <<= 1 {
						if uncheckedHelpers & helper {
							for _, name := range tc.getHelperNames(helper) {
								symbol := tc.resolveSymbol(tc.getSymbol(tc.getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlagsValue))
								if !symbol {
									tc.error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name)
								} else if helper & ExternalEmitHelpersClassPrivateFieldGet {
									if !some(tc.getSignaturesOfSymbol(symbol), func(signature Signature) bool {
										return tc.getParameterCount(signature) > 3
									}) {
										tc.error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4)
									}
								} else if helper & ExternalEmitHelpersClassPrivateFieldSet {
									if !some(tc.getSignaturesOfSymbol(symbol), func(signature Signature) bool {
										return tc.getParameterCount(signature) > 4
									}) {
										tc.error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5)
									}
								} else if helper & ExternalEmitHelpersSpreadArray {
									if !some(tc.getSignaturesOfSymbol(symbol), func(signature Signature) bool {
										return tc.getParameterCount(signature) > 2
									}) {
										tc.error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3)
									}
								}
							}
						}
					}
				}
				links.requestedExternalEmitHelpers |= helpers
			}
		}
	}
}

func (tc *TypeChecker) getHelperNames(helper ExternalEmitHelpers) []string {
	switch helper {
	case ExternalEmitHelpersExtends:
		return []string{"__extends"}
	case ExternalEmitHelpersAssign:
		return []string{"__assign"}
	case ExternalEmitHelpersRest:
		return []string{"__rest"}
	case ExternalEmitHelpersDecorate:
		if tc.legacyDecorators {
			return []string{"__decorate"}
		} else {
			return []string{"__esDecorate", "__runInitializers"}
		}
	case ExternalEmitHelpersMetadata:
		return []string{"__metadata"}
	case ExternalEmitHelpersParam:
		return []string{"__param"}
	case ExternalEmitHelpersAwaiter:
		return []string{"__awaiter"}
	case ExternalEmitHelpersGenerator:
		return []string{"__generator"}
	case ExternalEmitHelpersValues:
		return []string{"__values"}
	case ExternalEmitHelpersRead:
		return []string{"__read"}
	case ExternalEmitHelpersSpreadArray:
		return []string{"__spreadArray"}
	case ExternalEmitHelpersAwait:
		return []string{"__await"}
	case ExternalEmitHelpersAsyncGenerator:
		return []string{"__asyncGenerator"}
	case ExternalEmitHelpersAsyncDelegator:
		return []string{"__asyncDelegator"}
	case ExternalEmitHelpersAsyncValues:
		return []string{"__asyncValues"}
	case ExternalEmitHelpersExportStar:
		return []string{"__exportStar"}
	case ExternalEmitHelpersImportStar:
		return []string{"__importStar"}
	case ExternalEmitHelpersImportDefault:
		return []string{"__importDefault"}
	case ExternalEmitHelpersMakeTemplateObject:
		return []string{"__makeTemplateObject"}
	case ExternalEmitHelpersClassPrivateFieldGet:
		return []string{"__classPrivateFieldGet"}
	case ExternalEmitHelpersClassPrivateFieldSet:
		return []string{"__classPrivateFieldSet"}
	case ExternalEmitHelpersClassPrivateFieldIn:
		return []string{"__classPrivateFieldIn"}
	case ExternalEmitHelpersSetFunctionName:
		return []string{"__setFunctionName"}
	case ExternalEmitHelpersPropKey:
		return []string{"__propKey"}
	case ExternalEmitHelpersAddDisposableResourceAndDisposeResources:
		return []string{"__addDisposableResource", "__disposeResources"}
	default:
		return Debug.fail("Unrecognized helper")
	}
}

func (tc *TypeChecker) resolveHelpersModule(file SourceFile, errorNode Node) Symbol {
	links := tc.getNodeLinks(file)
	if !links.externalHelpersModule {
		links.externalHelpersModule = tc.resolveExternalModule(tc.getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || tc.unknownSymbol
	}
	return links.externalHelpersModule
}

// GRAMMAR CHECKING

func (tc *TypeChecker) checkGrammarModifiers(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) bool {
	quickResult := tc.reportObviousDecoratorErrors(node) || tc.reportObviousModifierErrors(node)
	if quickResult != nil {
		return quickResult
	}

	if isParameter(node) && parameterIsThisKeyword(node) {
		return tc.grammarErrorOnFirstToken(node, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters)
	}

	var blockScopeKind number
	if isVariableStatement(node) {
		blockScopeKind = node.declarationList.flags & NodeFlagsBlockScoped
	} else {
		blockScopeKind = NodeFlagsNone
	}
	var lastStatic Node
	var lastDeclare Node
	var lastAsync Node
	var lastOverride Node
	var firstDecorator *Decorator
	flags := ModifierFlagsNone
	sawExportBeforeDecorators := false
	// We parse decorators and modifiers in four contiguous chunks:
	// [...leadingDecorators, ...leadingModifiers, ...trailingDecorators, ...trailingModifiers]. It is an error to
	// have both leading and trailing decorators.
	hasLeadingDecorators := false
	for _, modifier := range (node /* as HasModifiers */).modifiers {
		if isDecorator(modifier) {
			if !nodeCanBeDecorated(tc.legacyDecorators, node, node.parent, node.parent.parent) {
				if node.kind == SyntaxKindMethodDeclaration && !nodeIsPresent(node.body) {
					return tc.grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload)
				} else {
					return tc.grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here)
				}
			} else if tc.legacyDecorators && (node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor) {
				accessors := tc.getAllAccessorDeclarationsForDeclaration(node /* as AccessorDeclaration */)
				if hasDecorators(accessors.firstAccessor) && node == accessors.secondAccessor {
					return tc.grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name)
				}
			}

			// if we've seen any modifiers aside from `export`, `default`, or another decorator, then this is an invalid position
			if flags & ~(ModifierFlagsExportDefault | ModifierFlagsDecorator) {
				return tc.grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here)
			}

			// if we've already seen leading decorators and leading modifiers, then trailing decorators are an invalid position
			if hasLeadingDecorators && flags&ModifierFlagsModifier {
				Debug.assertIsDefined(firstDecorator)
				sourceFile := getSourceFileOfNode(modifier)
				if !tc.hasParseDiagnostics(sourceFile) {
					addRelatedInfo(tc.error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export), createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here))
					return true
				}
				return false
			}

			flags |= ModifierFlagsDecorator

			// if we have not yet seen a modifier, then these are leading decorators
			if !(flags & ModifierFlagsModifier) {
				hasLeadingDecorators = true
			} else if flags & ModifierFlagsExport {
				sawExportBeforeDecorators = true
			}

			/* TODO(TS-TO-GO) QuestionQuestionEqualsToken BinaryExpression: firstDecorator ??= modifier */
			TODO
		} else {
			if modifier.kind != SyntaxKindReadonlyKeyword {
				if node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodSignature {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind))
				}
				if node.kind == SyntaxKindIndexSignature && (modifier.kind != SyntaxKindStaticKeyword || !isClassLike(node.parent)) {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind))
				}
			}
			if modifier.kind != SyntaxKindInKeyword && modifier.kind != SyntaxKindOutKeyword && modifier.kind != SyntaxKindConstKeyword {
				if node.kind == SyntaxKindTypeParameter {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind))
				}
			}
			switch modifier.kind {
			case SyntaxKindConstKeyword:
				if node.kind != SyntaxKindEnumDeclaration && node.kind != SyntaxKindTypeParameter {
					return tc.grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKindConstKeyword))
				}
				parent := (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent
				if node.kind == SyntaxKindTypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) || isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent)) {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind))
				}
				break
				fallthrough
			case SyntaxKindOverrideKeyword:
				if flags & ModifierFlagsOverride {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override")
				} else if flags & ModifierFlagsAmbient {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare")
				} else if flags & ModifierFlagsReadonly {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly")
				} else if flags & ModifierFlagsAccessor {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor")
				} else if flags & ModifierFlagsAsync {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async")
				}
				flags |= ModifierFlagsOverride
				lastOverride = modifier
			case SyntaxKindPublicKeyword,
				SyntaxKindProtectedKeyword,
				SyntaxKindPrivateKeyword:
				text := tc.visibilityToString(modifierToFlag(modifier.kind))

				if flags & ModifierFlagsAccessibilityModifier {
					return tc.grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen)
				} else if flags & ModifierFlagsOverride {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override")
				} else if flags & ModifierFlagsStatic {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static")
				} else if flags & ModifierFlagsAccessor {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor")
				} else if flags & ModifierFlagsReadonly {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly")
				} else if flags & ModifierFlagsAsync {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async")
				} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text)
				} else if flags & ModifierFlagsAbstract {
					if modifier.kind == SyntaxKindPrivateKeyword {
						return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract")
					} else {
						return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract")
					}
				} else if isPrivateIdentifierClassElementDeclaration(node) {
					return tc.grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
				}
				flags |= modifierToFlag(modifier.kind)
			case SyntaxKindStaticKeyword:
				if flags & ModifierFlagsStatic {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static")
				} else if flags & ModifierFlagsReadonly {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly")
				} else if flags & ModifierFlagsAsync {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async")
				} else if flags & ModifierFlagsAccessor {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor")
				} else if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static")
				} else if node.kind == SyntaxKindParameter {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static")
				} else if flags & ModifierFlagsAbstract {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
				} else if flags & ModifierFlagsOverride {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override")
				}
				flags |= ModifierFlagsStatic
				lastStatic = modifier
			case SyntaxKindAccessorKeyword:
				if flags & ModifierFlagsAccessor {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor")
				} else if flags & ModifierFlagsReadonly {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly")
				} else if flags & ModifierFlagsAmbient {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare")
				} else if node.kind != SyntaxKindPropertyDeclaration {
					return tc.grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration)
				}

				flags |= ModifierFlagsAccessor
			case SyntaxKindReadonlyKeyword:
				if flags & ModifierFlagsReadonly {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly")
				} else if node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindPropertySignature && node.kind != SyntaxKindIndexSignature && node.kind != SyntaxKindParameter {
					// If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
					return tc.grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature)
				} else if flags & ModifierFlagsAccessor {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor")
				}
				flags |= ModifierFlagsReadonly
			case SyntaxKindExportKeyword:
				if tc.compilerOptions.verbatimModuleSyntax && !(node.flags & NodeFlagsAmbient) && node.kind != SyntaxKindTypeAliasDeclaration && node.kind != SyntaxKindInterfaceDeclaration && node.kind != SyntaxKindModuleDeclaration && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					return tc.grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
				}
				if flags & ModifierFlagsExport {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export")
				} else if flags & ModifierFlagsAmbient {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare")
				} else if flags & ModifierFlagsAbstract {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract")
				} else if flags & ModifierFlagsAsync {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async")
				} else if isClassLike(node.parent) {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export")
				} else if node.kind == SyntaxKindParameter {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export")
				} else if blockScopeKind == NodeFlagsUsing {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export")
				} else if blockScopeKind == NodeFlagsAwaitUsing {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export")
				}
				flags |= ModifierFlagsExport
			case SyntaxKindDefaultKeyword:
				var container Node
				if node.parent.kind == SyntaxKindSourceFile {
					container = node.parent
				} else {
					container = node.parent.parent
				}
				if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
					return tc.grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
				} else if blockScopeKind == NodeFlagsUsing {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default")
				} else if blockScopeKind == NodeFlagsAwaitUsing {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default")
				} else if !(flags & ModifierFlagsExport) {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default")
				} else if sawExportBeforeDecorators {
					return tc.grammarErrorOnNode(firstDecorator, Diagnostics.Decorators_are_not_valid_here)
				}

				flags |= ModifierFlagsDefault
			case SyntaxKindDeclareKeyword:
				if flags & ModifierFlagsAmbient {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare")
				} else if flags & ModifierFlagsAsync {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
				} else if flags & ModifierFlagsOverride {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override")
				} else if isClassLike(node.parent) && !isPropertyDeclaration(node) {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare")
				} else if node.kind == SyntaxKindParameter {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare")
				} else if blockScopeKind == NodeFlagsUsing {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare")
				} else if blockScopeKind == NodeFlagsAwaitUsing {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare")
				} else if (node.parent.flags & NodeFlagsAmbient) && node.parent.kind == SyntaxKindModuleBlock {
					return tc.grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context)
				} else if isPrivateIdentifierClassElementDeclaration(node) {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare")
				} else if flags & ModifierFlagsAccessor {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor")
				}
				flags |= ModifierFlagsAmbient
				lastDeclare = modifier
			case SyntaxKindAbstractKeyword:
				if flags & ModifierFlagsAbstract {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract")
				}
				if node.kind != SyntaxKindClassDeclaration && node.kind != SyntaxKindConstructorType {
					if node.kind != SyntaxKindMethodDeclaration && node.kind != SyntaxKindPropertyDeclaration && node.kind != SyntaxKindGetAccessor && node.kind != SyntaxKindSetAccessor {
						return tc.grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration)
					}
					if !(node.parent.kind == SyntaxKindClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlagsAbstract)) {
						var message DiagnosticMessage
						if node.kind == SyntaxKindPropertyDeclaration {
							message = Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class
						} else {
							message = Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class
						}
						return tc.grammarErrorOnNode(modifier, message)
					}
					if flags & ModifierFlagsStatic {
						return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract")
					}
					if flags & ModifierFlagsPrivate {
						return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract")
					}
					if flags&ModifierFlagsAsync && lastAsync {
						return tc.grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
					}
					if flags & ModifierFlagsOverride {
						return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override")
					}
					if flags & ModifierFlagsAccessor {
						return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor")
					}
				}
				if isNamedDeclaration(node) && node.name.kind == SyntaxKindPrivateIdentifier {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract")
				}

				flags |= ModifierFlagsAbstract
			case SyntaxKindAsyncKeyword:
				if flags & ModifierFlagsAsync {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async")
				} else if flags&ModifierFlagsAmbient || node.parent.flags&NodeFlagsAmbient {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async")
				} else if node.kind == SyntaxKindParameter {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async")
				}
				if flags & ModifierFlagsAbstract {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract")
				}
				flags |= ModifierFlagsAsync
				lastAsync = modifier
			case SyntaxKindInKeyword,
				SyntaxKindOutKeyword:
				var inOutFlag /* TODO(TS-TO-GO) inferred type ModifierFlags.In | ModifierFlags.Out */ any
				if modifier.kind == SyntaxKindInKeyword {
					inOutFlag = ModifierFlagsIn
				} else {
					inOutFlag = ModifierFlagsOut
				}
				var inOutText /* TODO(TS-TO-GO) inferred type "in" | "out" */ any
				if modifier.kind == SyntaxKindInKeyword {
					inOutText = "in"
				} else {
					inOutText = "out"
				}
				parent := isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent). /* ? */ tags, isJSDocTypedefTag)) || node.parent
				if node.kind != SyntaxKindTypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent)) {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText)
				}
				if flags & inOutFlag {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText)
				}
				if inOutFlag&ModifierFlagsIn && flags&ModifierFlagsOut {
					return tc.grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out")
				}
				flags |= inOutFlag
				break
			}
		}
	}

	if node.kind == SyntaxKindConstructor {
		if flags & ModifierFlagsStatic {
			return tc.grammarErrorOnNode(lastStatic, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static")
		}
		if flags & ModifierFlagsOverride {
			return tc.grammarErrorOnNode(lastOverride, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override")
			// TODO: GH#18217
		}
		if flags & ModifierFlagsAsync {
			return tc.grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async")
		}
		return false
	} else if (node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration) && flags&ModifierFlagsAmbient {
		return tc.grammarErrorOnNode(lastDeclare, Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare")
	} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && isBindingPattern(node.name) {
		return tc.grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern)
	} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && node.dotDotDotToken {
		return tc.grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter)
	}
	if flags & ModifierFlagsAsync {
		return tc.checkGrammarAsyncModifier(node, lastAsync)
	}
	return false
}

/**
 * true | false: Early return this value from checkGrammarModifiers.
 * undefined: Need to do full checking on the modifiers.
 */

func (tc *TypeChecker) reportObviousModifierErrors(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasIllegalModifiers */ any) *bool {
	if !node.modifiers {
		return false
	}

	modifier := tc.findFirstIllegalModifier(node)
	return modifier && tc.grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here)
}

func (tc *TypeChecker) findFirstModifierExcept(node HasModifiers, allowedModifier SyntaxKind) *Modifier {
	modifier := find(node.modifiers, isModifier)
	if modifier && modifier.kind != allowedModifier {
		return modifier
	} else {
		return nil
	}
}

func (tc *TypeChecker) findFirstIllegalModifier(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasIllegalModifiers */ any) *Modifier {
	switch node.kind {
	case SyntaxKindGetAccessor,
		SyntaxKindSetAccessor,
		SyntaxKindConstructor,
		SyntaxKindPropertyDeclaration,
		SyntaxKindPropertySignature,
		SyntaxKindMethodDeclaration,
		SyntaxKindMethodSignature,
		SyntaxKindIndexSignature,
		SyntaxKindModuleDeclaration,
		SyntaxKindImportDeclaration,
		SyntaxKindImportEqualsDeclaration,
		SyntaxKindExportDeclaration,
		SyntaxKindExportAssignment,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction,
		SyntaxKindParameter,
		SyntaxKindTypeParameter:
		return nil
	case SyntaxKindClassStaticBlockDeclaration,
		SyntaxKindPropertyAssignment,
		SyntaxKindShorthandPropertyAssignment,
		SyntaxKindNamespaceExportDeclaration,
		SyntaxKindMissingDeclaration:
		return find(node.modifiers, isModifier)
	default:
		if node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
			return nil
		}
		switch node.kind {
		case SyntaxKindFunctionDeclaration:
			return tc.findFirstModifierExcept(node, SyntaxKindAsyncKeyword)
		case SyntaxKindClassDeclaration,
			SyntaxKindConstructorType:
			return tc.findFirstModifierExcept(node, SyntaxKindAbstractKeyword)
		case SyntaxKindClassExpression,
			SyntaxKindInterfaceDeclaration,
			SyntaxKindTypeAliasDeclaration:
			return find(node.modifiers, isModifier)
		case SyntaxKindVariableStatement:
			if node.declarationList.flags & NodeFlagsUsing {
				return tc.findFirstModifierExcept(node, SyntaxKindAwaitKeyword)
			} else {
				return find(node.modifiers, isModifier)
			}
		case SyntaxKindEnumDeclaration:
			return tc.findFirstModifierExcept(node, SyntaxKindConstKeyword)
		default:
			Debug.assertNever(node)
		}
	}
}

func (tc *TypeChecker) reportObviousDecoratorErrors(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *bool {
	decorator := tc.findFirstIllegalDecorator(node)
	return decorator && tc.grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here)
}

func (tc *TypeChecker) findFirstIllegalDecorator(node /* TODO(TS-TO-GO) TypeNode UnionType: HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *Decorator {
	if canHaveIllegalDecorators(node) {
		return find(node.modifiers, isDecorator)
	} else {
		return nil
	}
}

func (tc *TypeChecker) checkGrammarAsyncModifier(node Node, asyncModifier Node) bool {
	switch node.kind {
	case SyntaxKindMethodDeclaration,
		SyntaxKindFunctionDeclaration,
		SyntaxKindFunctionExpression,
		SyntaxKindArrowFunction:
		return false
	}

	return tc.grammarErrorOnNode(asyncModifier, Diagnostics._0_modifier_cannot_be_used_here, "async")
}

func (tc *TypeChecker) checkGrammarForDisallowedTrailingComma(list *NodeArray[Node], diag DiagnosticMessage /*  = Diagnostics.Trailing_comma_not_allowed */) bool {
	if list && list.hasTrailingComma {
		return tc.grammarErrorAtPos(list[0], list.end-len(","), len(","), diag)
	}
	return false
}

func (tc *TypeChecker) checkGrammarTypeParameterList(typeParameters *NodeArray[TypeParameterDeclaration], file SourceFile) bool {
	if typeParameters && typeParameters.length == 0 {
		start := typeParameters.pos - len("<")
		end := skipTrivia(file.text, typeParameters.end) + len(">")
		return tc.grammarErrorAtPos(file, start, end-start, Diagnostics.Type_parameter_list_cannot_be_empty)
	}
	return false
}

func (tc *TypeChecker) checkGrammarParameterList(parameters NodeArray[ParameterDeclaration]) *bool {
	seenOptionalParameter := false
	parameterCount := parameters.length

	for i := 0; i < parameterCount; i++ {
		parameter := parameters[i]
		if parameter.dotDotDotToken {
			if i != (parameterCount - 1) {
				return tc.grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
			}
			if !(parameter.flags & NodeFlagsAmbient) {
				tc.checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
			}

			if parameter.questionToken {
				return tc.grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional)
			}

			if parameter.initializer {
				return tc.grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer)
			}
		} else if tc.hasEffectiveQuestionToken(parameter) {
			seenOptionalParameter = true
			if parameter.questionToken && parameter.initializer {
				return tc.grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer)
			}
		} else if seenOptionalParameter && !parameter.initializer {
			return tc.grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter)
		}
	}
}

func (tc *TypeChecker) getNonSimpleParameters(parameters []ParameterDeclaration) []ParameterDeclaration {
	return filter(parameters, func(parameter ParameterDeclaration) bool {
		return !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter)
	})
}

func (tc *TypeChecker) checkGrammarForUseStrictSimpleParameterList(node FunctionLikeDeclaration) bool {
	if tc.languageVersion >= ScriptTargetES2016 {
		useStrictDirective := node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements)
		if useStrictDirective {
			nonSimpleParameters := tc.getNonSimpleParameters(node.parameters)
			if length(nonSimpleParameters) {
				forEach(nonSimpleParameters, func(parameter ParameterDeclaration) {
					addRelatedInfo(tc.error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here))
				})

				diagnostics := nonSimpleParameters.map_(func(parameter ParameterDeclaration, index number) DiagnosticWithLocation {
					return (__COND__(index == 0, createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here), createDiagnosticForNode(parameter, Diagnostics.and_here)))
				}) /* as [DiagnosticWithLocation, ...DiagnosticWithLocation[]] */
				addRelatedInfo(tc.error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list), diagnostics...)
				return true
			}
		}
	}
	return false
}

func (tc *TypeChecker) checkGrammarFunctionLikeDeclaration(node /* TODO(TS-TO-GO) TypeNode UnionType: FunctionLikeDeclaration | MethodSignature */ any) bool {
	// Prevent cascading error by short-circuit
	file := getSourceFileOfNode(node)
	return tc.checkGrammarModifiers(node) || tc.checkGrammarTypeParameterList(node.typeParameters, file) || tc.checkGrammarParameterList(node.parameters) || tc.checkGrammarArrowFunction(node, file) || (isFunctionLikeDeclaration(node) && tc.checkGrammarForUseStrictSimpleParameterList(node))
}

func (tc *TypeChecker) checkGrammarClassLikeDeclaration(node ClassLikeDeclaration) bool {
	file := getSourceFileOfNode(node)
	return tc.checkGrammarClassDeclarationHeritageClauses(node) || tc.checkGrammarTypeParameterList(node.typeParameters, file)
}

func (tc *TypeChecker) checkGrammarArrowFunction(node Node, file SourceFile) bool {
	if !isArrowFunction(node) {
		return false
	}

	if node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint) {
		if file && fileExtensionIsOneOf(file.fileName, []Extension{ExtensionMts, ExtensionCts}) {
			tc.grammarErrorOnNode(node.typeParameters[0], Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint)
		}
	}

	TODO_IDENTIFIER := node
	startLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line
	endLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line
	return startLine != endLine && tc.grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow)
}

func (tc *TypeChecker) checkGrammarIndexSignatureParameters(node SignatureDeclaration) bool {
	parameter := node.parameters[0]
	if node.parameters.length != 1 {
		if parameter {
			return tc.grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
		} else {
			return tc.grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
		}
	}
	tc.checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma)
	if parameter.dotDotDotToken {
		return tc.grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter)
	}
	if hasEffectiveModifiers(parameter) {
		return tc.grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier)
	}
	if parameter.questionToken {
		return tc.grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark)
	}
	if parameter.initializer {
		return tc.grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer)
	}
	if !parameter.type_ {
		return tc.grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation)
	}
	type_ := tc.getTypeFromTypeNode(parameter.type_)
	if tc.someType(type_, func(t Type) bool {
		return !!(t.flags & TypeFlagsStringOrNumberLiteralOrUnique)
	}) || tc.isGenericType(type_) {
		return tc.grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead)
	}
	if !tc.everyType(type_, tc.isValidIndexKeyType) {
		return tc.grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type)
	}
	if !node.type_ {
		return tc.grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation)
	}
	return false
}

func (tc *TypeChecker) checkGrammarIndexSignature(node IndexSignatureDeclaration) bool {
	// Prevent cascading error by short-circuit
	return tc.checkGrammarModifiers(node) || tc.checkGrammarIndexSignatureParameters(node)
}

func (tc *TypeChecker) checkGrammarForAtLeastOneTypeArgument(node Node, typeArguments *NodeArray[TypeNode]) bool {
	if typeArguments && typeArguments.length == 0 {
		sourceFile := getSourceFileOfNode(node)
		start := typeArguments.pos - len("<")
		end := skipTrivia(sourceFile.text, typeArguments.end) + len(">")
		return tc.grammarErrorAtPos(sourceFile, start, end-start, Diagnostics.Type_argument_list_cannot_be_empty)
	}
	return false
}

func (tc *TypeChecker) checkGrammarTypeArguments(node Node, typeArguments *NodeArray[TypeNode]) bool {
	return tc.checkGrammarForDisallowedTrailingComma(typeArguments) || tc.checkGrammarForAtLeastOneTypeArgument(node, typeArguments)
}

func (tc *TypeChecker) checkGrammarTaggedTemplateChain(node TaggedTemplateExpression) bool {
	if node.questionDotToken || node.flags&NodeFlagsOptionalChain {
		return tc.grammarErrorOnNode(node.template, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain)
	}
	return false
}

func (tc *TypeChecker) checkGrammarHeritageClause(node HeritageClause) bool {
	types := node.types
	if tc.checkGrammarForDisallowedTrailingComma(types) {
		return true
	}
	if types && types.length == 0 {
		listType := tokenToString(node.token)
		return tc.grammarErrorAtPos(node, types.pos, 0, Diagnostics._0_list_cannot_be_empty, listType)
	}
	return some(types, tc.checkGrammarExpressionWithTypeArguments)
}

func (tc *TypeChecker) checkGrammarExpressionWithTypeArguments(node /* TODO(TS-TO-GO) TypeNode UnionType: ExpressionWithTypeArguments | TypeQueryNode */ any) bool {
	if isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments {
		return tc.grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
	}
	return tc.checkGrammarTypeArguments(node, node.typeArguments)
}

func (tc *TypeChecker) checkGrammarClassDeclarationHeritageClauses(node ClassLikeDeclaration) *bool {
	seenExtendsClause := false
	seenImplementsClause := false

	if !tc.checkGrammarModifiers(node) && node.heritageClauses {
		for _, heritageClause := range node.heritageClauses {
			if heritageClause.token == SyntaxKindExtendsKeyword {
				if seenExtendsClause {
					return tc.grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
				}

				if seenImplementsClause {
					return tc.grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause)
				}

				if heritageClause.types.length > 1 {
					return tc.grammarErrorOnFirstToken(heritageClause.types[1], Diagnostics.Classes_can_only_extend_a_single_class)
				}

				seenExtendsClause = true
			} else {
				Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
				if seenImplementsClause {
					return tc.grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen)
				}

				seenImplementsClause = true
			}

			// Grammar checking heritageClause inside class declaration
			tc.checkGrammarHeritageClause(heritageClause)
		}
	}
}

func (tc *TypeChecker) checkGrammarInterfaceDeclaration(node InterfaceDeclaration) bool {
	seenExtendsClause := false

	if node.heritageClauses {
		for _, heritageClause := range node.heritageClauses {
			if heritageClause.token == SyntaxKindExtendsKeyword {
				if seenExtendsClause {
					return tc.grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
				}

				seenExtendsClause = true
			} else {
				Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
				return tc.grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause)
			}

			// Grammar checking heritageClause inside class declaration
			tc.checkGrammarHeritageClause(heritageClause)
		}
	}
	return false
}

func (tc *TypeChecker) checkGrammarComputedPropertyName(node Node) bool {
	// If node is not a computedPropertyName, just skip the grammar checking
	if node.kind != SyntaxKindComputedPropertyName {
		return false
	}

	computedPropertyName := node /* as ComputedPropertyName */
	if computedPropertyName.expression.kind == SyntaxKindBinaryExpression && (computedPropertyName.expression /* as BinaryExpression */).operatorToken.kind == SyntaxKindCommaToken {
		return tc.grammarErrorOnNode(computedPropertyName.expression, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name)
	}
	return false
}

func (tc *TypeChecker) checkGrammarForGenerator(node FunctionLikeDeclaration) *bool {
	if node.asteriskToken {
		Debug.assert(node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression || node.kind == SyntaxKindMethodDeclaration)
		if node.flags & NodeFlagsAmbient {
			return tc.grammarErrorOnNode(node.asteriskToken, Diagnostics.Generators_are_not_allowed_in_an_ambient_context)
		}
		if !node.body {
			return tc.grammarErrorOnNode(node.asteriskToken, Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator)
		}
	}
}

func (tc *TypeChecker) checkGrammarForInvalidQuestionMark(questionToken *QuestionToken, message DiagnosticMessage) bool {
	return !!questionToken && tc.grammarErrorOnNode(questionToken, message)
}

func (tc *TypeChecker) checkGrammarForInvalidExclamationToken(exclamationToken *ExclamationToken, message DiagnosticMessage) bool {
	return !!exclamationToken && tc.grammarErrorOnNode(exclamationToken, message)
}

func (tc *TypeChecker) checkGrammarObjectLiteralExpression(node ObjectLiteralExpression, inDestructuring bool) *bool {
	seen := NewMap[__String, DeclarationMeaning]()

	for _, prop := range node.properties {
		if prop.kind == SyntaxKindSpreadAssignment {
			if inDestructuring {
				// a rest property cannot be destructured any further
				expression := skipParentheses(prop.expression)
				if isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression) {
					return tc.grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern)
				}
			}
			continue
		}
		name := prop.name
		if name.kind == SyntaxKindComputedPropertyName {
			// If the name is not a ComputedPropertyName, the grammar checking will skip it
			tc.checkGrammarComputedPropertyName(name)
		}

		if prop.kind == SyntaxKindShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer {
			// having objectAssignmentInitializer is only valid in ObjectAssignmentPattern
			// outside of destructuring it is a syntax error
			tc.grammarErrorOnNode(prop.equalsToken, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern)
		}

		if name.kind == SyntaxKindPrivateIdentifier {
			tc.grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}

		// Modifiers are never allowed on properties except for 'async' on a method declaration
		if canHaveModifiers(prop) && prop.modifiers {
			for _, mod := range prop.modifiers {
				if isModifier(mod) && (mod.kind != SyntaxKindAsyncKeyword || prop.kind != SyntaxKindMethodDeclaration) {
					tc.grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
				}
			}
		} else if canHaveIllegalModifiers(prop) && prop.modifiers {
			for _, mod := range prop.modifiers {
				if isModifier(mod) {
					tc.grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
				}
			}
		}

		// ECMA-262 11.1.5 Object Initializer
		// If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
		// a.This production is contained in strict code and IsDataDescriptor(previous) is true and
		// IsDataDescriptor(propId.descriptor) is true.
		//    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
		//    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
		//    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
		// and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
		var currentKind DeclarationMeaning
		switch prop.kind {
		case SyntaxKindShorthandPropertyAssignment,
			SyntaxKindPropertyAssignment:
			tc.checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)
			tc.checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional)
			if name.kind == SyntaxKindNumericLiteral {
				tc.checkGrammarNumericLiteral(name)
			}
			if name.kind == SyntaxKindBigIntLiteral {
				tc.addErrorOrSuggestion(true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name))
			}
			currentKind = DeclarationMeaningPropertyAssignment
		case SyntaxKindMethodDeclaration:
			currentKind = DeclarationMeaningMethod
		case SyntaxKindGetAccessor:
			currentKind = DeclarationMeaningGetAccessor
		case SyntaxKindSetAccessor:
			currentKind = DeclarationMeaningSetAccessor
		default:
			Debug.assertNever(prop, "Unexpected syntax kind:"+(prop /* as Node */).kind)
		}

		if !inDestructuring {
			effectiveName := tc.getEffectivePropertyNameForPropertyNameNode(name)
			if effectiveName == nil {
				continue
			}

			existingKind := seen.get(effectiveName)
			if !existingKind {
				seen.set(effectiveName, currentKind)
			} else {
				if (currentKind & DeclarationMeaningMethod) && (existingKind & DeclarationMeaningMethod) {
					tc.grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name))
				} else if (currentKind & DeclarationMeaningPropertyAssignment) && (existingKind & DeclarationMeaningPropertyAssignment) {
					tc.grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name))
				} else if (currentKind & DeclarationMeaningGetOrSetAccessor) && (existingKind & DeclarationMeaningGetOrSetAccessor) {
					if existingKind != DeclarationMeaningGetOrSetAccessor && currentKind != existingKind {
						seen.set(effectiveName, currentKind|existingKind)
					} else {
						return tc.grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name)
					}
				} else {
					return tc.grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name)
				}
			}
		}
	}
}

func (tc *TypeChecker) checkGrammarJsxElement(node JsxOpeningLikeElement) *bool {
	tc.checkGrammarJsxName(node.tagName)
	tc.checkGrammarTypeArguments(node, node.typeArguments)
	seen := NewMap[__String, bool]()

	for _, attr := range node.attributes.properties {
		if attr.kind == SyntaxKindJsxSpreadAttribute {
			continue
		}

		TODO_IDENTIFIER := attr
		escapedText := getEscapedTextOfJsxAttributeName(name)
		if !seen.get(escapedText) {
			seen.set(escapedText, true)
		} else {
			return tc.grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name)
		}

		if initializer && initializer.kind == SyntaxKindJsxExpression && !initializer.expression {
			return tc.grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression)
		}
	}
}

func (tc *TypeChecker) checkGrammarJsxName(node JsxTagNameExpression) *bool {
	if isPropertyAccessExpression(node) && isJsxNamespacedName(node.expression) {
		return tc.grammarErrorOnNode(node.expression, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names)
	}
	if isJsxNamespacedName(node) && getJSXTransformEnabled(tc.compilerOptions) && !isIntrinsicJsxName(node.namespace.escapedText) {
		return tc.grammarErrorOnNode(node, Diagnostics.React_components_cannot_include_JSX_namespace_names)
	}
}

func (tc *TypeChecker) checkGrammarJsxExpression(node JsxExpression) *bool {
	if node.expression && isCommaSequence(node.expression) {
		return tc.grammarErrorOnNode(node.expression, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array)
	}
}

func (tc *TypeChecker) checkGrammarForInOrForOfStatement(forInOrOfStatement ForInOrOfStatement) bool {
	if tc.checkGrammarStatementInAmbientContext(forInOrOfStatement) {
		return true
	}

	if forInOrOfStatement.kind == SyntaxKindForOfStatement && forInOrOfStatement.awaitModifier {
		if !(forInOrOfStatement.flags & NodeFlagsAwaitContext) {
			sourceFile := getSourceFileOfNode(forInOrOfStatement)
			if isInTopLevelContext(forInOrOfStatement) {
				if !tc.hasParseDiagnostics(sourceFile) {
					if !isEffectiveExternalModule(sourceFile, tc.compilerOptions) {
						tc.diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module))
					}
					switch tc.moduleKind {
					case ModuleKindNode16,
						ModuleKindNodeNext:
						if sourceFile.impliedNodeFormat == ModuleKindCommonJS {
							tc.diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level))
							break
						}
						fallthrough
					case ModuleKindES2022,
						ModuleKindESNext,
						ModuleKindPreserve,
						ModuleKindSystem:
						if tc.languageVersion >= ScriptTargetES2017 {
							break
						}
						fallthrough
					default:
						tc.diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher))
					}
				}
			} else {
				// use of 'for-await-of' in non-async function
				if !tc.hasParseDiagnostics(sourceFile) {
					diagnostic := createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules)
					func_ := getContainingFunction(forInOrOfStatement)
					if func_ && func_.kind != SyntaxKindConstructor {
						Debug.assert((getFunctionFlags(func_)&FunctionFlagsAsync) == 0, "Enclosing function should never be an async function.")
						relatedInfo := createDiagnosticForNode(func_, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
						addRelatedInfo(diagnostic, relatedInfo)
					}
					tc.diagnostics.add(diagnostic)
					return true
				}
			}
		}
	}

	if isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlagsAwaitContext) && isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText == "async" {
		tc.grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async)
		return false
	}

	if forInOrOfStatement.initializer.kind == SyntaxKindVariableDeclarationList {
		variableList := forInOrOfStatement.initializer /* as VariableDeclarationList */
		if !tc.checkGrammarVariableDeclarationList(variableList) {
			declarations := variableList.declarations

			// declarations.length can be zero if there is an error in variable declaration in for-of or for-in
			// See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
			// For example:
			//      var let = 10;
			//      for (let of [1,2,3]) {} // this is invalid ES6 syntax
			//      for (let in [1,2,3]) {} // this is invalid ES6 syntax
			// We will then want to skip on grammar checking on variableList declaration
			if !declarations.length {
				return false
			}

			if declarations.length > 1 {
				var diagnostic DiagnosticMessage
				if forInOrOfStatement.kind == SyntaxKindForInStatement {
					diagnostic = Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
				} else {
					diagnostic = Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement
				}
				return tc.grammarErrorOnFirstToken(variableList.declarations[1], diagnostic)
			}
			firstDeclaration := declarations[0]

			if firstDeclaration.initializer {
				var diagnostic DiagnosticMessage
				if forInOrOfStatement.kind == SyntaxKindForInStatement {
					diagnostic = Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
				} else {
					diagnostic = Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer
				}
				return tc.grammarErrorOnNode(firstDeclaration.name, diagnostic)
			}
			if firstDeclaration.type_ {
				var diagnostic DiagnosticMessage
				if forInOrOfStatement.kind == SyntaxKindForInStatement {
					diagnostic = Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
				} else {
					diagnostic = Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation
				}
				return tc.grammarErrorOnNode(firstDeclaration, diagnostic)
			}
		}
	}

	return false
}

func (tc *TypeChecker) checkGrammarAccessor(accessor AccessorDeclaration) bool {
	if !(accessor.flags & NodeFlagsAmbient) && (accessor.parent.kind != SyntaxKindTypeLiteral) && (accessor.parent.kind != SyntaxKindInterfaceDeclaration) {
		if tc.languageVersion < ScriptTargetES2015 && isPrivateIdentifier(accessor.name) {
			return tc.grammarErrorOnNode(accessor.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
		}
		if accessor.body == nil && !hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
			return tc.grammarErrorAtPos(accessor, accessor.end-1, len(";"), Diagnostics._0_expected, "{")
		}
	}
	if accessor.body {
		if hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
			return tc.grammarErrorOnNode(accessor, Diagnostics.An_abstract_accessor_cannot_have_an_implementation)
		}
		if accessor.parent.kind == SyntaxKindTypeLiteral || accessor.parent.kind == SyntaxKindInterfaceDeclaration {
			return tc.grammarErrorOnNode(accessor.body, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
		}
	}
	if accessor.typeParameters {
		return tc.grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters)
	}
	if !tc.doesAccessorHaveCorrectParameterCount(accessor) {
		return tc.grammarErrorOnNode(accessor.name, __COND__(accessor.kind == SyntaxKindGetAccessor, Diagnostics.A_get_accessor_cannot_have_parameters, Diagnostics.A_set_accessor_must_have_exactly_one_parameter))
	}
	if accessor.kind == SyntaxKindSetAccessor {
		if accessor.type_ {
			return tc.grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation)
		}
		parameter := Debug.checkDefined(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.")
		if parameter.dotDotDotToken {
			return tc.grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_set_accessor_cannot_have_rest_parameter)
		}
		if parameter.questionToken {
			return tc.grammarErrorOnNode(parameter.questionToken, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter)
		}
		if parameter.initializer {
			return tc.grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer)
		}
	}
	return false
}

/** Does the accessor have the right number of parameters?
 * A get accessor has no parameters or a single `this` parameter.
 * A set accessor has one parameter or a `this` parameter and one more parameter.
 */

func (tc *TypeChecker) doesAccessorHaveCorrectParameterCount(accessor AccessorDeclaration) /* TODO(TS-TO-GO) inferred type boolean | ParameterDeclaration */ any {
	return tc.getAccessorThisParameter(accessor) || accessor.parameters.length == (__COND__(accessor.kind == SyntaxKindGetAccessor, 0, 1))
}

func (tc *TypeChecker) getAccessorThisParameter(accessor AccessorDeclaration) *ParameterDeclaration {
	if accessor.parameters.length == (__COND__(accessor.kind == SyntaxKindGetAccessor, 1, 2)) {
		return getThisParameter(accessor)
	}
}

func (tc *TypeChecker) checkGrammarTypeOperatorNode(node TypeOperatorNode) *bool {
	if node.operator == SyntaxKindUniqueKeyword {
		if node.type_.kind != SyntaxKindSymbolKeyword {
			return tc.grammarErrorOnNode(node.type_, Diagnostics._0_expected, tokenToString(SyntaxKindSymbolKeyword))
		}
		parent := walkUpParenthesizedTypes(node.parent)
		if isInJSFile(parent) && isJSDocTypeExpression(parent) {
			host := getJSDocHost(parent)
			if host {
				parent = getSingleVariableOfVariableStatement(host) || host
			}
		}
		switch parent.kind {
		case SyntaxKindVariableDeclaration:
			decl := parent /* as VariableDeclaration */
			if decl.name.kind != SyntaxKindIdentifier {
				return tc.grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name)
			}
			if !isVariableDeclarationInVariableStatement(decl) {
				return tc.grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement)
			}
			if !(decl.parent.flags & NodeFlagsConst) {
				return tc.grammarErrorOnNode((parent /* as VariableDeclaration */).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const)
			}
		case SyntaxKindPropertyDeclaration:
			if !isStatic(parent) || !hasEffectiveReadonlyModifier(parent) {
				return tc.grammarErrorOnNode((parent /* as PropertyDeclaration */).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly)
			}
		case SyntaxKindPropertySignature:
			if !hasSyntacticModifier(parent, ModifierFlagsReadonly) {
				return tc.grammarErrorOnNode((parent /* as PropertySignature */).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly)
			}
		default:
			return tc.grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here)
		}
	} else if node.operator == SyntaxKindReadonlyKeyword {
		if node.type_.kind != SyntaxKindArrayType && node.type_.kind != SyntaxKindTupleType {
			return tc.grammarErrorOnFirstToken(node, Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, tokenToString(SyntaxKindSymbolKeyword))
		}
	}
}

func (tc *TypeChecker) checkGrammarForInvalidDynamicName(node DeclarationName, message DiagnosticMessage) *bool {
	if tc.isNonBindableDynamicName(node) {
		return tc.grammarErrorOnNode(node, message)
	}
}

func (tc *TypeChecker) checkGrammarMethod(node /* TODO(TS-TO-GO) TypeNode UnionType: MethodDeclaration | MethodSignature */ any) *bool {
	if tc.checkGrammarFunctionLikeDeclaration(node) {
		return true
	}

	if node.kind == SyntaxKindMethodDeclaration {
		if node.parent.kind == SyntaxKindObjectLiteralExpression {
			// We only disallow modifier on a method declaration if it is a property of object-literal-expression
			if node.modifiers && !(node.modifiers.length == 1 && first(node.modifiers).kind == SyntaxKindAsyncKeyword) {
				return tc.grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here)
			} else if tc.checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional) {
				return true
			} else if tc.checkGrammarForInvalidExclamationToken(node.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context) {
				return true
			} else if node.body == nil {
				return tc.grammarErrorAtPos(node, node.end-1, len(";"), Diagnostics._0_expected, "{")
			}
		}
		if tc.checkGrammarForGenerator(node) {
			return true
		}
	}

	if isClassLike(node.parent) {
		if tc.languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
			return tc.grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
		}
		// Technically, computed properties in ambient contexts is disallowed
		// for property declarations and accessors too, not just methods.
		// However, property declarations disallow computed names in general,
		// and accessors are not allowed in ambient contexts in general,
		// so this error only really matters for methods.
		if node.flags & NodeFlagsAmbient {
			return tc.checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		} else if node.kind == SyntaxKindMethodDeclaration && !node.body {
			return tc.checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		}
	} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
		return tc.checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
	} else if node.parent.kind == SyntaxKindTypeLiteral {
		return tc.checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
	}
}

func (tc *TypeChecker) checkGrammarBreakOrContinueStatement(node BreakOrContinueStatement) bool {
	var current Node = node
	for current {
		if isFunctionLikeOrClassStaticBlockDeclaration(current) {
			return tc.grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary)
		}

		switch current.kind {
		case SyntaxKindLabeledStatement:
			if node.label && (current /* as LabeledStatement */).label.escapedText == node.label.escapedText {
				// found matching label - verify that label usage is correct
				// continue can only target labels that are on iteration statements
				isMisplacedContinueLabel := node.kind == SyntaxKindContinueStatement && !isIterationStatement((current /* as LabeledStatement */).statement /*lookInLabeledStatements*/, true)

				if isMisplacedContinueLabel {
					return tc.grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement)
				}

				return false
			}
		case SyntaxKindSwitchStatement:
			if node.kind == SyntaxKindBreakStatement && !node.label {
				// unlabeled break within switch statement - ok
				return false
			}
		default:
			if isIterationStatement(current /*lookInLabeledStatements*/, false) && !node.label {
				// unlabeled break or continue within iteration statement - ok
				return false
			}
		}

		current = current.parent
	}

	if node.label {
		var message DiagnosticMessage
		if node.kind == SyntaxKindBreakStatement {
			message = Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
		} else {
			message = Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement
		}

		return tc.grammarErrorOnNode(node, message)
	} else {
		var message DiagnosticMessage
		if node.kind == SyntaxKindBreakStatement {
			message = Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
		} else {
			message = Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement
		}
		return tc.grammarErrorOnNode(node, message)
	}
}

func (tc *TypeChecker) checkGrammarBindingElement(node BindingElement) *bool {
	if node.dotDotDotToken {
		elements := node.parent.elements
		if node != last(elements) {
			return tc.grammarErrorOnNode(node, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
		}
		tc.checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)

		if node.propertyName {
			return tc.grammarErrorOnNode(node.name, Diagnostics.A_rest_element_cannot_have_a_property_name)
		}
	}

	if node.dotDotDotToken && node.initializer {
		// Error on equals token which immediately precedes the initializer
		return tc.grammarErrorAtPos(node, node.initializer.pos-1, 1, Diagnostics.A_rest_element_cannot_have_an_initializer)
	}
}

func (tc *TypeChecker) isStringOrNumberLiteralExpression(expr Expression) bool {
	return isStringOrNumericLiteralLike(expr) || expr.kind == SyntaxKindPrefixUnaryExpression && (expr /* as PrefixUnaryExpression */).operator == SyntaxKindMinusToken && (expr /* as PrefixUnaryExpression */).operand.kind == SyntaxKindNumericLiteral
}

func (tc *TypeChecker) isBigIntLiteralExpression(expr Expression) bool {
	return expr.kind == SyntaxKindBigIntLiteral || expr.kind == SyntaxKindPrefixUnaryExpression && (expr /* as PrefixUnaryExpression */).operator == SyntaxKindMinusToken && (expr /* as PrefixUnaryExpression */).operand.kind == SyntaxKindBigIntLiteral
}

func (tc *TypeChecker) isSimpleLiteralEnumReference(expr Expression) *bool {
	if (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && tc.isStringOrNumberLiteralExpression(expr.argumentExpression))) && isEntityNameExpression(expr.expression) {
		return !!(tc.checkExpressionCached(expr).flags & TypeFlagsEnumLike)
	}
}

func (tc *TypeChecker) checkAmbientInitializer(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | PropertyDeclaration | PropertySignature */ any) *bool {
	initializer := node.initializer
	if initializer {
		isInvalidInitializer := !(tc.isStringOrNumberLiteralExpression(initializer) || tc.isSimpleLiteralEnumReference(initializer) || initializer.kind == SyntaxKindTrueKeyword || initializer.kind == SyntaxKindFalseKeyword || tc.isBigIntLiteralExpression(initializer))
		isConstOrReadonly := isDeclarationReadonly(node) || isVariableDeclaration(node) && (tc.isVarConstLike(node))
		if isConstOrReadonly && !node.type_ {
			if isInvalidInitializer {
				return tc.grammarErrorOnNode(initializer, Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference)
			}
		} else {
			return tc.grammarErrorOnNode(initializer, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts)
		}
	}
}

func (tc *TypeChecker) checkGrammarVariableDeclaration(node VariableDeclaration) bool {
	nodeFlags := tc.getCombinedNodeFlagsCached(node)
	blockScopeKind := nodeFlags & NodeFlagsBlockScoped
	if isBindingPattern(node.name) {
		switch blockScopeKind {
		case NodeFlagsAwaitUsing:
			return tc.grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using")
		case NodeFlagsUsing:
			return tc.grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using")
		}
	}

	if node.parent.parent.kind != SyntaxKindForInStatement && node.parent.parent.kind != SyntaxKindForOfStatement {
		if nodeFlags & NodeFlagsAmbient {
			tc.checkAmbientInitializer(node)
		} else if !node.initializer {
			if isBindingPattern(node.name) && !isBindingPattern(node.parent) {
				return tc.grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer)
			}
			switch blockScopeKind {
			case NodeFlagsAwaitUsing:
				return tc.grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using")
			case NodeFlagsUsing:
				return tc.grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using")
			case NodeFlagsConst:
				return tc.grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const")
			}
		}
	}

	if node.exclamationToken && (node.parent.parent.kind != SyntaxKindVariableStatement || !node.type_ || node.initializer || nodeFlags&NodeFlagsAmbient) {
		var message DiagnosticMessage
		switch {
		case node.initializer:
			message = Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
		case !node.type_:
			message = Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
		default:
			message = Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context
		}
		return tc.grammarErrorOnNode(node.exclamationToken, message)
	}

	if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && !(node.parent.parent.flags & NodeFlagsAmbient) && hasSyntacticModifier(node.parent.parent, ModifierFlagsExport) {
		tc.checkESModuleMarker(node.name)
	}

	// 1. LexicalDeclaration : LetOrConst BindingList ;
	// It is a Syntax Error if the BoundNames of BindingList contains "let".
	// 2. ForDeclaration: ForDeclaration : LetOrConst ForBinding
	// It is a Syntax Error if the BoundNames of ForDeclaration contains "let".

	// It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
	// and its Identifier is eval or arguments
	return !!blockScopeKind && tc.checkGrammarNameInLetOrConstDeclarations(node.name)
}

func (tc *TypeChecker) checkESModuleMarker(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | BindingPattern */ any) bool {
	if name.kind == SyntaxKindIdentifier {
		if idText(name) == "__esModule" {
			return tc.grammarErrorOnNodeSkippedOn("noEmit", name, Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules)
		}
	} else {
		elements := name.elements
		for _, element := range elements {
			if !isOmittedExpression(element) {
				return tc.checkESModuleMarker(element.name)
			}
		}
	}
	return false
}

func (tc *TypeChecker) checkGrammarNameInLetOrConstDeclarations(name /* TODO(TS-TO-GO) TypeNode UnionType: Identifier | BindingPattern */ any) bool {
	if name.kind == SyntaxKindIdentifier {
		if name.escapedText == "let" {
			return tc.grammarErrorOnNode(name, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations)
		}
	} else {
		elements := name.elements
		for _, element := range elements {
			if !isOmittedExpression(element) {
				tc.checkGrammarNameInLetOrConstDeclarations(element.name)
			}
		}
	}
	return false
}

func (tc *TypeChecker) checkGrammarVariableDeclarationList(declarationList VariableDeclarationList) bool {
	declarations := declarationList.declarations
	if tc.checkGrammarForDisallowedTrailingComma(declarationList.declarations) {
		return true
	}

	if !declarationList.declarations.length {
		return tc.grammarErrorAtPos(declarationList, declarations.pos, declarations.end-declarations.pos, Diagnostics.Variable_declaration_list_cannot_be_empty)
	}

	blockScopeFlags := declarationList.flags & NodeFlagsBlockScoped
	if (blockScopeFlags == NodeFlagsUsing || blockScopeFlags == NodeFlagsAwaitUsing) && isForInStatement(declarationList.parent) {
		return tc.grammarErrorOnNode(declarationList, __COND__(blockScopeFlags == NodeFlagsUsing, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration))
	}

	if blockScopeFlags == NodeFlagsAwaitUsing {
		return tc.checkAwaitGrammar(declarationList)
	}

	return false
}

func (tc *TypeChecker) allowLetAndConstDeclarations(parent Node) bool {
	switch parent.kind {
	case SyntaxKindIfStatement,
		SyntaxKindDoStatement,
		SyntaxKindWhileStatement,
		SyntaxKindWithStatement,
		SyntaxKindForStatement,
		SyntaxKindForInStatement,
		SyntaxKindForOfStatement:
		return false
	case SyntaxKindLabeledStatement:
		return tc.allowLetAndConstDeclarations(parent.parent)
	}

	return true
}

func (tc *TypeChecker) checkGrammarForDisallowedBlockScopedVariableStatement(node VariableStatement) *bool {
	if !tc.allowLetAndConstDeclarations(node.parent) {
		blockScopeKind := tc.getCombinedNodeFlagsCached(node.declarationList) & NodeFlagsBlockScoped
		if blockScopeKind {
			var keyword /* TODO(TS-TO-GO) inferred type "const" | "await using" | "using" | "let" */ any
			switch {
			case blockScopeKind == NodeFlagsLet:
				keyword = "let"
			case blockScopeKind == NodeFlagsConst:
				keyword = "const"
			case blockScopeKind == NodeFlagsUsing:
				keyword = "using"
			case blockScopeKind == NodeFlagsAwaitUsing:
				keyword = "await using"
			default:
				keyword = Debug.fail("Unknown BlockScope flag")
			}
			return tc.grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, keyword)
		}
	}
}

func (tc *TypeChecker) checkGrammarMetaProperty(node MetaProperty) *bool {
	escapedText := node.name.escapedText
	switch node.keywordToken {
	case SyntaxKindNewKeyword:
		if escapedText != "target" {
			return tc.grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target")
		}
	case SyntaxKindImportKeyword:
		if escapedText != "meta" {
			return tc.grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta")
		}
	}
}

func (tc *TypeChecker) hasParseDiagnostics(sourceFile SourceFile) bool {
	return sourceFile.parseDiagnostics.length > 0
}

func (tc *TypeChecker) grammarErrorOnFirstToken(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
	sourceFile := getSourceFileOfNode(node)
	if !tc.hasParseDiagnostics(sourceFile) {
		span := getSpanOfTokenAtPosition(sourceFile, node.pos)
		tc.diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message, args...))
		return true
	}
	return false
}

func (tc *TypeChecker) grammarErrorAtPos(nodeForSourceFile Node, start number, length number, message DiagnosticMessage, args DiagnosticArguments) bool {
	sourceFile := getSourceFileOfNode(nodeForSourceFile)
	if !tc.hasParseDiagnostics(sourceFile) {
		tc.diagnostics.add(createFileDiagnostic(sourceFile, start, length, message, args...))
		return true
	}
	return false
}

func (tc *TypeChecker) grammarErrorOnNodeSkippedOn(key CompilerOptions, node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
	sourceFile := getSourceFileOfNode(node)
	if !tc.hasParseDiagnostics(sourceFile) {
		tc.errorSkippedOn(key, node, message, args...)
		return true
	}
	return false
}

func (tc *TypeChecker) grammarErrorOnNode(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
	sourceFile := getSourceFileOfNode(node)
	if !tc.hasParseDiagnostics(sourceFile) {
		tc.diagnostics.add(createDiagnosticForNode(node, message, args...))
		return true
	}
	return false
}

func (tc *TypeChecker) checkGrammarConstructorTypeParameters(node ConstructorDeclaration) *bool {
	var jsdocTypeParameters *[]TypeParameterDeclaration
	if isInJSFile(node) {
		jsdocTypeParameters = getJSDocTypeParameterDeclarations(node)
	} else {
		jsdocTypeParameters = nil
	}
	range_ := node.typeParameters || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters)
	if range_ {
		var pos number
		if range_.pos == range_.end {
			pos = range_.pos
		} else {
			pos = skipTrivia(getSourceFileOfNode(node).text, range_.pos)
		}
		return tc.grammarErrorAtPos(node, pos, range_.end-pos, Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration)
	}
}

func (tc *TypeChecker) checkGrammarConstructorTypeAnnotation(node ConstructorDeclaration) *bool {
	type_ := node.type_ || getEffectiveReturnTypeNode(node)
	if type_ {
		return tc.grammarErrorOnNode(type_, Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration)
	}
}

func (tc *TypeChecker) checkGrammarProperty(node /* TODO(TS-TO-GO) TypeNode UnionType: PropertyDeclaration | PropertySignature */ any) *bool {
	if isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind == SyntaxKindInKeyword {
		return tc.grammarErrorOnNode(node.parent.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
	}
	if isClassLike(node.parent) {
		if isStringLiteral(node.name) && node.name.text == "constructor" {
			return tc.grammarErrorOnNode(node.name, Diagnostics.Classes_may_not_have_a_field_named_constructor)
		}
		if tc.checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type) {
			return true
		}
		if tc.languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
			return tc.grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
		}
		if tc.languageVersion < ScriptTargetES2015 && isAutoAccessorPropertyDeclaration(node) {
			return tc.grammarErrorOnNode(node.name, Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher)
		}
		if isAutoAccessorPropertyDeclaration(node) && tc.checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional) {
			return true
		}
	} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
		if tc.checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
			return true
		}

		// Interfaces cannot contain property declarations
		Debug.assertNode(node, isPropertySignature)
		if node.initializer {
			return tc.grammarErrorOnNode(node.initializer, Diagnostics.An_interface_property_cannot_have_an_initializer)
		}
	} else if isTypeLiteralNode(node.parent) {
		if tc.checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
			return true
		}
		// Type literals cannot contain property declarations
		Debug.assertNode(node, isPropertySignature)
		if node.initializer {
			return tc.grammarErrorOnNode(node.initializer, Diagnostics.A_type_literal_property_cannot_have_an_initializer)
		}
	}

	if node.flags & NodeFlagsAmbient {
		tc.checkAmbientInitializer(node)
	}

	if isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(node.parent) || !node.type_ || node.initializer || node.flags&NodeFlagsAmbient || isStatic(node) || hasAbstractModifier(node)) {
		var message DiagnosticMessage
		switch {
		case node.initializer:
			message = Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
		case !node.type_:
			message = Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
		default:
			message = Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context
		}
		return tc.grammarErrorOnNode(node.exclamationToken, message)
	}
}

func (tc *TypeChecker) checkGrammarTopLevelElementForRequiredDeclareModifier(node Node) bool {
	// A declare modifier is required for any top level .d.ts declaration except export=, export default, export as namespace
	// interfaces and imports categories:
	//
	//  DeclarationElement:
	//     ExportAssignment
	//     export_opt   InterfaceDeclaration
	//     export_opt   TypeAliasDeclaration
	//     export_opt   ImportDeclaration
	//     export_opt   ExternalImportDeclaration
	//     export_opt   AmbientDeclaration
	//
	// TODO: The spec needs to be amended to reflect this grammar.
	if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindTypeAliasDeclaration || node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindExportDeclaration || node.kind == SyntaxKindExportAssignment || node.kind == SyntaxKindNamespaceExportDeclaration || hasSyntacticModifier(node, ModifierFlagsAmbient|ModifierFlagsExport|ModifierFlagsDefault) {
		return false
	}

	return tc.grammarErrorOnFirstToken(node, Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier)
}

func (tc *TypeChecker) checkGrammarTopLevelElementsForRequiredDeclareModifier(file SourceFile) bool {
	for _, decl := range file.statements {
		if isDeclaration(decl) || decl.kind == SyntaxKindVariableStatement {
			if tc.checkGrammarTopLevelElementForRequiredDeclareModifier(decl) {
				return true
			}
		}
	}
	return false
}

func (tc *TypeChecker) checkGrammarSourceFile(node SourceFile) bool {
	return !!(node.flags & NodeFlagsAmbient) && tc.checkGrammarTopLevelElementsForRequiredDeclareModifier(node)
}

func (tc *TypeChecker) checkGrammarStatementInAmbientContext(node Node) bool {
	if node.flags & NodeFlagsAmbient {
		// Find containing block which is either Block, ModuleBlock, SourceFile
		links := tc.getNodeLinks(node)
		if !links.hasReportedStatementInAmbientContext && (isFunctionLike(node.parent) || isAccessor(node.parent)) {
			tc.getNodeLinks(node).hasReportedStatementInAmbientContext = tc.grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
			return tc.getNodeLinks(node).hasReportedStatementInAmbientContext
		}

		// We are either parented by another statement, or some sort of block.
		// If we're in a block, we only want to really report an error once
		// to prevent noisiness.  So use a bit on the block to indicate if
		// this has already been reported, and don't report if it has.
		//
		if node.parent.kind == SyntaxKindBlock || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
			links := tc.getNodeLinks(node.parent)
			// Check if the containing block ever report this error
			if !links.hasReportedStatementInAmbientContext {
				links.hasReportedStatementInAmbientContext = tc.grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts)
				return links.hasReportedStatementInAmbientContext
			}
		} else {
			// We must be parented by a statement.  If so, there's no need
			// to report the error as our parent will have already done it.
			// Debug.assert(isStatement(node.parent));
		}
	}
	return false
}

func (tc *TypeChecker) checkGrammarNumericLiteral(node NumericLiteral) {
	// Realism (size) checking
	// We should test against `getTextOfNode(node)` rather than `node.text`, because `node.text` for large numeric literals can contain "."
	// e.g. `node.text` for numeric literal `1100000000000000000000` is `1.1e21`.
	isFractional := getTextOfNode(node).includes(".")
	isScientific := node.numericLiteralFlags & TokenFlagsScientific

	// Scientific notation (e.g. 2e54 and 1e00000000010) can't be converted to bigint
	// Fractional numbers (e.g. 9000000000000000.001) are inherently imprecise anyway
	if isFractional || isScientific {
		return
	}

	// Here `node` is guaranteed to be a numeric literal representing an integer.
	// We need to judge whether the integer `node` represents is <= 2 ** 53 - 1, which can be accomplished by comparing to `value` defined below because:
	// 1) when `node` represents an integer <= 2 ** 53 - 1, `node.text` is its exact string representation and thus `value` precisely represents the integer.
	// 2) otherwise, although `node.text` may be imprecise string representation, its mathematical value and consequently `value` cannot be less than 2 ** 53,
	//    thus the result of the predicate won't be affected.
	value := +node.text
	if value <= 2**53-1 {
		return
	}

	tc.addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers))
}

func (tc *TypeChecker) checkGrammarBigIntLiteral(node BigIntLiteral) bool {
	literalType := isLiteralTypeNode(node.parent) || isPrefixUnaryExpression(node.parent) && isLiteralTypeNode(node.parent.parent)
	if !literalType {
		if tc.languageVersion < ScriptTargetES2020 {
			if tc.grammarErrorOnNode(node, Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020) {
				return true
			}
		}
	}
	return false
}

func (tc *TypeChecker) grammarErrorAfterFirstToken(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
	sourceFile := getSourceFileOfNode(node)
	if !tc.hasParseDiagnostics(sourceFile) {
		span := getSpanOfTokenAtPosition(sourceFile, node.pos)
		tc.diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span) /*length*/, 0, message, args...))
		return true
	}
	return false
}

func (tc *TypeChecker) getAmbientModules() []Symbol {
	if !tc.ambientModulesCache {
		tc.ambientModulesCache = []never{}
		tc.globals.forEach(func(global Symbol, sym __String) {
			// No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.
			if ambientModuleSymbolRegex.test(sym /* as string */) {
				tc.ambientModulesCache.push(global)
			}
		})
	}
	return tc.ambientModulesCache
}

func (tc *TypeChecker) checkGrammarImportClause(node ImportClause) bool {
	if node.isTypeOnly && node.name && node.namedBindings {
		return tc.grammarErrorOnNode(node, Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both)
	}
	if node.isTypeOnly && node.namedBindings. /* ? */ kind == SyntaxKindNamedImports {
		return tc.checkGrammarNamedImportsOrExports(node.namedBindings)
	}
	return false
}

func (tc *TypeChecker) checkGrammarNamedImportsOrExports(namedBindings NamedImportsOrExports) bool {
	return !!forEach(namedBindings.elements, func(specifier /* TODO(TS-TO-GO) inferred type ExportSpecifier | ImportSpecifier */ any) *bool {
		if specifier.isTypeOnly {
			return tc.grammarErrorOnFirstToken(specifier, __COND__(specifier.kind == SyntaxKindImportSpecifier, Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement, Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement))
		}
	})
}

func (tc *TypeChecker) checkGrammarImportCallExpression(node ImportCall) bool {
	if tc.compilerOptions.verbatimModuleSyntax && tc.moduleKind == ModuleKindCommonJS {
		return tc.grammarErrorOnNode(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
	}

	if tc.moduleKind == ModuleKindES2015 {
		return tc.grammarErrorOnNode(node, Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext)
	}

	if node.typeArguments {
		return tc.grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
	}

	nodeArguments := node.arguments
	if tc.moduleKind != ModuleKindESNext && tc.moduleKind != ModuleKindNodeNext && tc.moduleKind != ModuleKindNode16 && tc.moduleKind != ModuleKindPreserve {
		// We are allowed trailing comma after proposal-import-assertions.
		tc.checkGrammarForDisallowedTrailingComma(nodeArguments)

		if nodeArguments.length > 1 {
			importAttributesArgument := nodeArguments[1]
			return tc.grammarErrorOnNode(importAttributesArgument, Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve)
		}
	}

	if nodeArguments.length == 0 || nodeArguments.length > 2 {
		return tc.grammarErrorOnNode(node, Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments)
	}

	// see: parseArgumentOrArrayLiteralElement...we use this function which parse arguments of callExpression to parse specifier for dynamic import.
	// parseArgumentOrArrayLiteralElement allows spread element to be in an argument list which is not allowed as specifier in dynamic import.
	spreadElement := find(nodeArguments, isSpreadElement)
	if spreadElement {
		return tc.grammarErrorOnNode(spreadElement, Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element)
	}
	return false
}

func (tc *TypeChecker) findMatchingTypeReferenceOrTypeAliasReference(source Type, unionTarget UnionOrIntersectionType) Type {
	sourceObjectFlags := getObjectFlags(source)
	if sourceObjectFlags&(ObjectFlagsReference|ObjectFlagsAnonymous) && unionTarget.flags&TypeFlagsUnion {
		return find(unionTarget.types, func(target Type) bool {
			if target.flags & TypeFlagsObject {
				overlapObjFlags := sourceObjectFlags & getObjectFlags(target)
				if overlapObjFlags & ObjectFlagsReference {
					return (source /* as TypeReference */).target == (target /* as TypeReference */).target
				}
				if overlapObjFlags & ObjectFlagsAnonymous {
					return !!(source /* as AnonymousType */).aliasSymbol && (source /* as AnonymousType */).aliasSymbol == (target /* as AnonymousType */).aliasSymbol
				}
			}
			return false
		})
	}
}

func (tc *TypeChecker) findBestTypeForObjectLiteral(source Type, unionTarget UnionOrIntersectionType) Type {
	if getObjectFlags(source)&ObjectFlagsObjectLiteral && tc.someType(unionTarget, tc.isArrayLikeType) {
		return find(unionTarget.types, func(t Type) bool {
			return !tc.isArrayLikeType(t)
		})
	}
}

func (tc *TypeChecker) findBestTypeForInvokable(source Type, unionTarget UnionOrIntersectionType) Type {
	signatureKind := SignatureKindCall
	hasSignatures := tc.getSignaturesOfType(source, signatureKind).length > 0 || ( /* TODO(TS-TO-GO) CommaToken BinaryExpression: signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0 */ TODO)
	if hasSignatures {
		return find(unionTarget.types, func(t Type) bool {
			return tc.getSignaturesOfType(t, signatureKind).length > 0
		})
	}
}

func (tc *TypeChecker) findMostOverlappyType(source Type, unionTarget UnionOrIntersectionType) Type {
	var bestMatch Type
	if !(source.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
		matchingCount := 0
		for _, target := range unionTarget.types {
			if !(target.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
				overlap := tc.getIntersectionType([]Type{tc.getIndexType(source), tc.getIndexType(target)})
				if overlap.flags & TypeFlagsIndex {
					// perfect overlap of keys
					return target
				} else if tc.isUnitType(overlap) || overlap.flags&TypeFlagsUnion {
					// We only want to account for literal types otherwise.
					// If we have a union of index types, it seems likely that we
					// needed to elaborate between two generic mapped types anyway.
					var len number
					if overlap.flags & TypeFlagsUnion {
						len = countWhere((overlap /* as UnionType */).types, tc.isUnitType)
					} else {
						len = 1
					}
					if len >= matchingCount {
						bestMatch = target
						matchingCount = len
					}
				}
			}
		}
	}
	return bestMatch
}

func (tc *TypeChecker) filterPrimitivesIfContainsNonPrimitive(type_ UnionType) Type {
	if tc.maybeTypeOfKind(type_, TypeFlagsNonPrimitive) {
		result := tc.filterType(type_, func(t Type) bool {
			return !(t.flags & TypeFlagsPrimitive)
		})
		if !(result.flags & TypeFlagsNever) {
			return result
		}
	}
	return type_
}

// Keep this up-to-date with the same logic within `getApparentTypeOfContextualType`, since they should behave similarly
func (tc *TypeChecker) findMatchingDiscriminantType(source Type, target Type, isRelatedTo func(source Type, target Type) Ternary) Type {
	if target.flags&TypeFlagsUnion && source.flags&(TypeFlagsIntersection|TypeFlagsObject) {
		match := tc.getMatchingUnionConstituentForType(target /* as UnionType */, source)
		if match {
			return match
		}
		sourceProperties := tc.getPropertiesOfType(source)
		if sourceProperties {
			sourcePropertiesFiltered := tc.findDiscriminantProperties(sourceProperties, target)
			if sourcePropertiesFiltered {
				discriminated := tc.discriminateTypeByDiscriminableItems(target /* as UnionType */, map_(sourcePropertiesFiltered, func(p Symbol) /* TODO(TS-TO-GO) inferred type [() => Type, __String] */ any {
					return ([]any{func() Type {
						return tc.getTypeOfSymbol(p)
					}, p.escapedName} /* as [() => Type, __String] */)
				}), isRelatedTo)
				if discriminated != target {
					return discriminated
				}
			}
		}
	}
	return nil
}

func (tc *TypeChecker) getEffectivePropertyNameForPropertyNameNode(node PropertyName) *__String {
	name := getPropertyNameForPropertyNameNode(node)
	switch {
	case name:
		return name
	case isComputedPropertyName(node):
		return tc.tryGetNameFromType(tc.getTypeOfExpression(node.expression))
	default:
		return nil
	}
}

func (tc *TypeChecker) getCombinedModifierFlagsCached(node Declaration) ModifierFlags {
	// we hold onto the last node and result to speed up repeated lookups against the same node.
	if tc.lastGetCombinedModifierFlagsNode == node {
		return tc.lastGetCombinedModifierFlagsResult
	}

	tc.lastGetCombinedModifierFlagsNode = node
	tc.lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node)
	return tc.lastGetCombinedModifierFlagsResult
}

func (tc *TypeChecker) getCombinedNodeFlagsCached(node Node) NodeFlags {
	// we hold onto the last node and result to speed up repeated lookups against the same node.
	if tc.lastGetCombinedNodeFlagsNode == node {
		return tc.lastGetCombinedNodeFlagsResult
	}
	tc.lastGetCombinedNodeFlagsNode = node
	tc.lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node)
	return tc.lastGetCombinedNodeFlagsResult
}

func (tc *TypeChecker) isVarConstLike(node /* TODO(TS-TO-GO) TypeNode UnionType: VariableDeclaration | VariableDeclarationList */ any) bool {
	blockScopeKind := tc.getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
	return blockScopeKind == NodeFlagsConst || blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing
}

func (tc *TypeChecker) getJSXRuntimeImportSpecifier(file *SourceFile, specifierText string) *StringLiteralLike {
	// Synthesized JSX import is either first or after tslib
	var jsxImportIndex /* TODO(TS-TO-GO) inferred type 0 | 1 */ any
	if tc.compilerOptions.importHelpers {
		jsxImportIndex = 1
	} else {
		jsxImportIndex = 0
	}
	specifier := file. /* ? */ imports[jsxImportIndex]
	if specifier {
		Debug.assert(nodeIsSynthesized(specifier) && specifier.text == specifierText, __TEMPLATE__("Expected sourceFile.imports[", jsxImportIndex, "] to be the synthesized JSX runtime import"))
	}
	return specifier
}

func (tc *TypeChecker) getImportHelpersImportSpecifier(file SourceFile) StringLiteralLike {
	Debug.assert(tc.compilerOptions.importHelpers, "Expected importHelpers to be enabled")
	specifier := file.imports[0]
	Debug.assert(specifier && nodeIsSynthesized(specifier) && specifier.text == "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`)
	return specifier
}

func isNotAccessor(declaration Declaration) bool {
	// Accessors check for their own matching duplicates, and in contexts where they are valid, there are already duplicate identifier checks
	return !isAccessor(declaration)
}

func isNotOverload(declaration Declaration) bool {
	return (declaration.kind != SyntaxKindFunctionDeclaration && declaration.kind != SyntaxKindMethodDeclaration) || !!(declaration /* as FunctionDeclaration */).body
}

/** Like 'isDeclarationName', but returns true for LHS of `import { x as y }` or `export { x as y }`. */

func isDeclarationNameOrImportPropertyName(name Node) bool {
	switch name.parent.kind {
	case SyntaxKindImportSpecifier,
		SyntaxKindExportSpecifier:
		return isIdentifier(name) || name.kind == SyntaxKindStringLiteral
	default:
		return isDeclarationName(name)
	}
}

var JsxNames = struct {
	JSX                                    __String
	IntrinsicElements                      __String
	ElementClass                           __String
	ElementAttributesPropertyNameContainer __String
	ElementChildrenAttributeNameContainer  __String
	Element                                __String
	ElementType                            __String
	IntrinsicAttributes                    __String
	IntrinsicClassAttributes               __String
	LibraryManagedAttributes               __String
}{
	JSX:                                    __String("JSX"),
	IntrinsicElements:                      __String("IntrinsicElements"),
	ElementClass:                           __String("ElementClass"),
	ElementAttributesPropertyNameContainer: __String("ElementAttributesProperty"),
	ElementChildrenAttributeNameContainer:  __String("ElementChildrenAttribute"),
	Element:                                __String("Element"),
	ElementType:                            __String("ElementType"),
	IntrinsicAttributes:                    __String("IntrinsicAttributes"),
	IntrinsicClassAttributes:               __String("IntrinsicClassAttributes"),
	LibraryManagedAttributes:               __String("LibraryManagedAttributes"),
}

func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) /* TODO(TS-TO-GO) inferred type "yieldType" | "returnType" | "nextType" */ any {
	switch typeKind {
	case IterationTypeKindYield:
		return "yieldType"
	case IterationTypeKindReturn:
		return "returnType"
	case IterationTypeKindNext:
		return "nextType"
	}
}

/** @internal */

func signatureHasRestParameter(s Signature) bool {
	return !!(s.flags & SignatureFlagsHasRestParameter)
}

func signatureHasLiteralTypes(s Signature) bool {
	return !!(s.flags & SignatureFlagsHasLiteralTypes)
}

func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
	return map[any]any{ /* TODO(TS-TO-GO): was object literal */
		"getCommonSourceDirectory": __COND__(!!(host /* as Program */).getCommonSourceDirectory, func() string {
			return (host /* as Program */).getCommonSourceDirectory()
		}, func() string {
			return ""
		}),
		"getCurrentDirectory": func() string {
			return host.getCurrentDirectory()
		},
		"getSymlinkCache": maybeBind(host, host.getSymlinkCache),
		"getPackageJsonInfoCache": func() *PackageJsonInfoCache {
			return host.getPackageJsonInfoCache()
		},
		"useCaseSensitiveFileNames": maybeBind(host, host.useCaseSensitiveFileNames),
		"redirectTargetsMap":        host.redirectTargetsMap,
		"getProjectReferenceRedirect": func(fileName string) *string {
			return host.getProjectReferenceRedirect(fileName)
		},
		"isSourceOfProjectReferenceRedirect": func(fileName string) bool {
			return host.isSourceOfProjectReferenceRedirect(fileName)
		},
		"fileExists": func(fileName string) bool {
			return host.fileExists(fileName)
		},
		"getFileIncludeReasons": func() /* TODO(TS-TO-GO) inferred type MultiMap<Path, FileIncludeReason> */ any {
			return host.getFileIncludeReasons()
		},
		"readFile": __COND__(host.readFile, (func(fileName string) *string {
			return host.readFile(fileName)
		}), nil),
		"getDefaultResolutionModeForFile": func(file SourceFile) ResolutionMode {
			return host.getDefaultResolutionModeForFile(file)
		},
		"getModeForResolutionAtIndex": func(file SourceFile, index number) ResolutionMode {
			return host.getModeForResolutionAtIndex(file, index)
		},
		"getGlobalTypingsCacheLocation": maybeBind(host, host.getGlobalTypingsCacheLocation),
	}
}

type NodeBuilderContext struct {
	enclosingDeclaration                  Node
	enclosingFile                         *SourceFile
	flags                                 NodeBuilderFlags
	internalFlags                         InternalNodeBuilderFlags
	tracker                               SymbolTrackerImpl
	encounteredError                      bool
	reportedDiagnostic                    bool
	trackedSymbols                        *[]TrackedSymbol
	visitedTypes                          *Set[number]
	symbolDepth                           *Map[string, number]
	inferTypeParameters                   *[]TypeParameter
	approximateLength                     number
	truncating                            bool
	mustCreateTypeParameterSymbolList     bool
	typeParameterSymbolList               *Set[number]
	mustCreateTypeParametersNamesLookups  bool
	typeParameterNames                    *Map[TypeId, Identifier]
	typeParameterNamesByText              *Set[string]
	typeParameterNamesByTextNextNameCount *Map[string, number]
	usedSymbolNames                       *Set[string]
	remappedSymbolNames                   *Map[SymbolId, string]
	remappedSymbolReferences              *Map[SymbolId, Symbol]
	reverseMappedStack                    *[]ReverseMappedSymbol
	bundled                               bool
	mapper                                *TypeMapper
}

/* TODO(TS-TO-GO) Node ClassDeclaration: class SymbolTrackerImpl implements SymbolTracker { moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined; context: NodeBuilderContext; readonly inner: SymbolTracker | undefined = undefined; readonly canTrackSymbol: boolean; disableTrackSymbol = false; constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) { while (tracker instanceof SymbolTrackerImpl) { tracker = tracker.inner; } this.inner = tracker; this.moduleResolverHost = moduleResolverHost; this.context = context; this.canTrackSymbol = !!this.inner?.trackSymbol; } trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean { if (this.inner?.trackSymbol && !this.disableTrackSymbol) { if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) { this.onDiagnosticReported(); return true; } // Skip recording type parameters as they dont contribute to late painted statements if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]); } return false; } reportInaccessibleThisError(): void { if (this.inner?.reportInaccessibleThisError) { this.onDiagnosticReported(); this.inner.reportInaccessibleThisError(); } } reportPrivateInBaseOfClassExpression(propertyName: string): void { if (this.inner?.reportPrivateInBaseOfClassExpression) { this.onDiagnosticReported(); this.inner.reportPrivateInBaseOfClassExpression(propertyName); } } reportInaccessibleUniqueSymbolError(): void { if (this.inner?.reportInaccessibleUniqueSymbolError) { this.onDiagnosticReported(); this.inner.reportInaccessibleUniqueSymbolError(); } } reportCyclicStructureError(): void { if (this.inner?.reportCyclicStructureError) { this.onDiagnosticReported(); this.inner.reportCyclicStructureError(); } } reportLikelyUnsafeImportRequiredError(specifier: string): void { if (this.inner?.reportLikelyUnsafeImportRequiredError) { this.onDiagnosticReported(); this.inner.reportLikelyUnsafeImportRequiredError(specifier); } } reportTruncationError(): void { if (this.inner?.reportTruncationError) { this.onDiagnosticReported(); this.inner.reportTruncationError(); } } reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void { if (this.inner?.reportNonlocalAugmentation) { this.onDiagnosticReported(); this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol); } } reportNonSerializableProperty(propertyName: string): void { if (this.inner?.reportNonSerializableProperty) { this.onDiagnosticReported(); this.inner.reportNonSerializableProperty(propertyName); } } private onDiagnosticReported() { this.context.reportedDiagnostic = true; } reportInferenceFallback(node: Node): void { if (this.inner?.reportInferenceFallback) { this.inner.reportInferenceFallback(node); } } } */
