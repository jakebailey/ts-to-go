package output

var ambientModuleSymbolRegex = regexp.MustParse(`^".+"$`)
var anon = "(anonymous)" /* as */ /* TODO(IntersectionType): __String & string */
type ReferenceHint int32

const (
	ReferenceHintUnspecified ReferenceHint = iota
	ReferenceHintIdentifier
	ReferenceHintProperty
	ReferenceHintExportAssignment
	ReferenceHintJsx
	ReferenceHintAsyncFunction
	ReferenceHintExportImportEquals
	ReferenceHintExportSpecifier
	ReferenceHintDecorator
)

var nextSymbolId = 1
var nextNodeId = 1
var nextMergeId = 1
var nextFlowId = 1

type IterationUse int32

const (
	IterationUseAllowsSyncIterablesFlag  IterationUse = 1 << 0
	IterationUseAllowsAsyncIterablesFlag IterationUse = 1 << 1
	IterationUseAllowsStringInputFlag    IterationUse = 1 << 2
	IterationUseForOfFlag                IterationUse = 1 << 3
	IterationUseYieldStarFlag            IterationUse = 1 << 4
	IterationUseSpreadFlag               IterationUse = 1 << 5
	IterationUseDestructuringFlag        IterationUse = 1 << 6
	IterationUsePossiblyOutOfBounds      IterationUse = 1 << 7
	IterationUseElement                  IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseSpread                   IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseSpreadFlag
	IterationUseDestructuring            IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseDestructuringFlag
	IterationUseForOf                    IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseForAwaitOf               IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseAllowsStringInputFlag | IterationUseIterationUseForOfFlag
	IterationUseYieldStar                IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseAsyncYieldStar           IterationUse = IterationUseAllowsSyncIterablesFlag | IterationUseAllowsAsyncIterablesFlag | IterationUseIterationUseYieldStarFlag
	IterationUseGeneratorReturnType      IterationUse = IterationUseAllowsSyncIterablesFlag
	IterationUseAsyncGeneratorReturnType IterationUse = IterationUseAllowsAsyncIterablesFlag
)

type IterationTypeKind int32

const (
	IterationTypeKindYield IterationTypeKind = iota
	IterationTypeKindReturn
	IterationTypeKindNext
)

type IterationTypesResolver struct {
	iterableCacheKey/* TODO(UnionType): "iterationTypesOfAsyncIterable" | "iterationTypesOfIterable" */ any
	iteratorCacheKey/* TODO(UnionType): "iterationTypesOfAsyncIterator" | "iterationTypesOfIterator" */ any
	iteratorSymbolName/* TODO(UnionType): "asyncIterator" | "iterator" */ any
	getGlobalIteratorType         func(reportErrors bool) GenericType
	getGlobalIterableType         func(reportErrors bool) GenericType
	getGlobalIterableIteratorType func(reportErrors bool) GenericType
	getGlobalIteratorObjectType   func(reportErrors bool) GenericType
	getGlobalGeneratorType        func(reportErrors bool) GenericType
	getGlobalBuiltinIteratorTypes func() []GenericType
	resolveIterationType          func(type_ Type, errorNode Node) *Type
	mustHaveANextMethodDiagnostic DiagnosticMessage
	mustBeAMethodDiagnostic       DiagnosticMessage
	mustHaveAValueDiagnostic      DiagnosticMessage
}
type WideningKind int32

const (
	WideningKindNormal WideningKind = iota
	WideningKindFunctionReturn
	WideningKindGeneratorNext
	WideningKindGeneratorYield
)

type TypeFacts int32

const (
	TypeFactsNone                      TypeFacts = 0
	TypeFactsTypeofEQString            TypeFacts = 1 << 0
	TypeFactsTypeofEQNumber            TypeFacts = 1 << 1
	TypeFactsTypeofEQBigInt            TypeFacts = 1 << 2
	TypeFactsTypeofEQBoolean           TypeFacts = 1 << 3
	TypeFactsTypeofEQSymbol            TypeFacts = 1 << 4
	TypeFactsTypeofEQObject            TypeFacts = 1 << 5
	TypeFactsTypeofEQFunction          TypeFacts = 1 << 6
	TypeFactsTypeofEQHostObject        TypeFacts = 1 << 7
	TypeFactsTypeofNEString            TypeFacts = 1 << 8
	TypeFactsTypeofNENumber            TypeFacts = 1 << 9
	TypeFactsTypeofNEBigInt            TypeFacts = 1 << 10
	TypeFactsTypeofNEBoolean           TypeFacts = 1 << 11
	TypeFactsTypeofNESymbol            TypeFacts = 1 << 12
	TypeFactsTypeofNEObject            TypeFacts = 1 << 13
	TypeFactsTypeofNEFunction          TypeFacts = 1 << 14
	TypeFactsTypeofNEHostObject        TypeFacts = 1 << 15
	TypeFactsEQUndefined               TypeFacts = 1 << 16
	TypeFactsEQNull                    TypeFacts = 1 << 17
	TypeFactsEQUndefinedOrNull         TypeFacts = 1 << 18
	TypeFactsNEUndefined               TypeFacts = 1 << 19
	TypeFactsNENull                    TypeFacts = 1 << 20
	TypeFactsNEUndefinedOrNull         TypeFacts = 1 << 21
	TypeFactsTruthy                    TypeFacts = 1 << 22
	TypeFactsFalsy                     TypeFacts = 1 << 23
	TypeFactsIsUndefined               TypeFacts = 1 << 24
	TypeFactsIsNull                    TypeFacts = 1 << 25
	TypeFactsIsUndefinedOrNull         TypeFacts = TypeFactsIsUndefined | TypeFactsIsNull
	TypeFactsAll                       TypeFacts = (1 << 27) - 1
	TypeFactsBaseStringStrictFacts     TypeFacts = TypeFactsTypeofEQString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseStringFacts           TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsStringStrictFacts         TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsStringFacts               TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsEmptyStringStrictFacts    TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsFalsy
	TypeFactsEmptyStringFacts          TypeFacts = TypeFactsBaseTypeFactsStringFacts
	TypeFactsNonEmptyStringStrictFacts TypeFacts = TypeFactsBaseTypeFactsStringStrictFacts | TypeFactsTruthy
	TypeFactsNonEmptyStringFacts       TypeFacts = TypeFactsBaseTypeFactsStringFacts | TypeFactsTruthy
	TypeFactsBaseNumberStrictFacts     TypeFacts = TypeFactsTypeofEQNumber | TypeFactsTypeofNEString | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsNumberStrictFacts         TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsNumberFacts               TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsZeroNumberStrictFacts     TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsFalsy
	TypeFactsZeroNumberFacts           TypeFacts = TypeFactsBaseTypeFactsNumberFacts
	TypeFactsNonZeroNumberStrictFacts  TypeFacts = TypeFactsBaseTypeFactsNumberStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroNumberFacts        TypeFacts = TypeFactsBaseTypeFactsNumberFacts | TypeFactsTruthy
	TypeFactsBaseBigIntStrictFacts     TypeFacts = TypeFactsTypeofEQBigInt | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBigIntStrictFacts         TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBigIntFacts               TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsZeroBigIntStrictFacts     TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsFalsy
	TypeFactsZeroBigIntFacts           TypeFacts = TypeFactsBaseTypeFactsBigIntFacts
	TypeFactsNonZeroBigIntStrictFacts  TypeFacts = TypeFactsBaseTypeFactsBigIntStrictFacts | TypeFactsTruthy
	TypeFactsNonZeroBigIntFacts        TypeFacts = TypeFactsBaseTypeFactsBigIntFacts | TypeFactsTruthy
	TypeFactsBaseBooleanStrictFacts    TypeFacts = TypeFactsTypeofEQBoolean | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull
	TypeFactsBaseBooleanFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsBooleanStrictFacts        TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy | TypeFactsFalsy
	TypeFactsBooleanFacts              TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsFalseStrictFacts          TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsFalsy
	TypeFactsFalseFacts                TypeFacts = TypeFactsBaseTypeFactsBooleanFacts
	TypeFactsTrueStrictFacts           TypeFacts = TypeFactsBaseTypeFactsBooleanStrictFacts | TypeFactsTruthy
	TypeFactsTrueFacts                 TypeFacts = TypeFactsBaseTypeFactsBooleanFacts | TypeFactsTruthy
	TypeFactsSymbolStrictFacts         TypeFacts = TypeFactsTypeofEQSymbol | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsSymbolFacts               TypeFacts = TypeFactsSymbolStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsObjectStrictFacts         TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsObjectFacts               TypeFacts = TypeFactsObjectStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsFunctionStrictFacts       TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofEQHostObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsNEUndefined | TypeFactsNENull | TypeFactsTypeFactsNEUndefinedOrNull | TypeFactsTruthy
	TypeFactsFunctionFacts             TypeFacts = TypeFactsFunctionStrictFacts | TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsFalsy
	TypeFactsVoidFacts                 TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy
	TypeFactsUndefinedFacts            TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQUndefined | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNENull | TypeFactsFalsy | TypeFactsIsUndefined
	TypeFactsNullFacts                 TypeFacts = TypeFactsTypeofEQObject | TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEFunction | TypeFactsTypeofNEHostObject | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsNEUndefined | TypeFactsFalsy | TypeFactsIsNull
	TypeFactsEmptyObjectStrictFacts    TypeFacts = TypeFactsAll & ~(TypeFactsEQUndefined | TypeFactsEQNull | TypeFactsTypeFactsEQUndefinedOrNull | TypeFactsTypeFactsIsUndefinedOrNull)
	TypeFactsEmptyObjectFacts          TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsUnknownFacts              TypeFacts = TypeFactsAll & ~TypeFactsTypeFactsIsUndefinedOrNull
	TypeFactsAllTypeofNE               TypeFacts = TypeFactsTypeofNEString | TypeFactsTypeofNENumber | TypeFactsTypeofNEBigInt | TypeFactsTypeofNEBoolean | TypeFactsTypeofNESymbol | TypeFactsTypeofNEObject | TypeFactsTypeofNEFunction | TypeFactsNEUndefined
	TypeFactsOrFactsMask               TypeFacts = TypeFactsTypeofEQFunction | TypeFactsTypeofNEObject
	TypeFactsAndFactsMask              TypeFacts = TypeFactsAll & ~TypeFactsOrFactsMask
)

var typeofNEFacts ReadonlyMap[string, TypeFacts] = /* TODO(NewExpression): new Map(Object.entries({     string: TypeFacts.TypeofNEString,     number: TypeFacts.TypeofNENumber,     bigint: TypeFacts.TypeofNEBigInt,     boolean: TypeFacts.TypeofNEBoolean,     symbol: TypeFacts.TypeofNESymbol,     undefined: TypeFacts.NEUndefined,     object: TypeFacts.TypeofNEObject,     function: TypeFacts.TypeofNEFunction, })) */ TODO

type TypeSystemEntity /* TODO(UnionType): Node | Symbol | Type | Signature */ any
type TypeSystemPropertyName int32

const (
	TypeSystemPropertyNameType TypeSystemPropertyName = iota
	TypeSystemPropertyNameResolvedBaseConstructorType
	TypeSystemPropertyNameDeclaredType
	TypeSystemPropertyNameResolvedReturnType
	TypeSystemPropertyNameImmediateBaseConstraint
	TypeSystemPropertyNameResolvedTypeArguments
	TypeSystemPropertyNameResolvedBaseTypes
	TypeSystemPropertyNameWriteType
	TypeSystemPropertyNameParameterInitializerContainsUndefined
)

type CheckMode int32

const (
	CheckModeNormal               CheckMode = 0
	CheckModeContextual           CheckMode = 1 << 0
	CheckModeInferential          CheckMode = 1 << 1
	CheckModeSkipContextSensitive CheckMode = 1 << 2
	CheckModeSkipGenericFunctions CheckMode = 1 << 3
	CheckModeIsForSignatureHelp   CheckMode = 1 << 4
	CheckModeRestBindingElement   CheckMode = 1 << 5
	CheckModeTypeOnly             CheckMode = 1 << 6
)

type SignatureCheckMode int32

const (
	SignatureCheckModeNone               SignatureCheckMode = 0
	SignatureCheckModeBivariantCallback  SignatureCheckMode = 1 << 0
	SignatureCheckModeStrictCallback     SignatureCheckMode = 1 << 1
	SignatureCheckModeIgnoreReturnTypes  SignatureCheckMode = 1 << 2
	SignatureCheckModeStrictArity        SignatureCheckMode = 1 << 3
	SignatureCheckModeStrictTopSignature SignatureCheckMode = 1 << 4
	SignatureCheckModeCallback           SignatureCheckMode = SignatureCheckModeBivariantSignatureCheckModeCallback | SignatureCheckModeStrictSignatureCheckModeCallback
)

type IntersectionState int32

const (
	IntersectionStateNone   IntersectionState = 0
	IntersectionStateSource IntersectionState = 1 << 0
	IntersectionStateTarget IntersectionState = 1 << 1
)

type RecursionFlags int32

const (
	RecursionFlagsNone   RecursionFlags = 0
	RecursionFlagsSource RecursionFlags = 1 << 0
	RecursionFlagsTarget RecursionFlags = 1 << 1
	RecursionFlagsBoth   RecursionFlags = RecursionFlagsSource | RecursionFlagsTarget
)

type MappedTypeModifiers int32

const (
	MappedTypeModifiersIncludeReadonly MappedTypeModifiers = 1 << 0
	MappedTypeModifiersExcludeReadonly MappedTypeModifiers = 1 << 1
	MappedTypeModifiersIncludeOptional MappedTypeModifiers = 1 << 2
	MappedTypeModifiersExcludeOptional MappedTypeModifiers = 1 << 3
)

type MappedTypeNameTypeKind int32

const (
	MappedTypeNameTypeKindNone MappedTypeNameTypeKind = iota
	MappedTypeNameTypeKindFiltering
	MappedTypeNameTypeKindRemapping
)

type ExpandingFlags int32

const (
	ExpandingFlagsNone   ExpandingFlags = 0
	ExpandingFlagsSource ExpandingFlags = 1
	ExpandingFlagsTarget ExpandingFlags = 1 << 1
	ExpandingFlagsBoth   ExpandingFlags = ExpandingFlagsSource | ExpandingFlagsTarget
)

type MembersOrExportsResolutionKind string

const (
	MembersOrExportsResolutionKindresolvedExports MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedExports"
	MembersOrExportsResolutionKindresolvedMembers MembersOrExportsResolutionKind = "MembersOrExportsResolutionKindresolvedMembers"
)

type UnusedKind int32

const (
	UnusedKindLocal UnusedKind = iota
	UnusedKindParameter
)

type AddUnusedDiagnostic func(containingNode Node, type_ UnusedKind, diagnostic DiagnosticWithLocation)

var isNotOverloadAndNotAccessor = and(isNotOverload, isNotAccessor)

type DeclarationMeaning int32

const (
	DeclarationMeaningGetAccessor                DeclarationMeaning = 1
	DeclarationMeaningSetAccessor                DeclarationMeaning = 2
	DeclarationMeaningPropertyAssignment         DeclarationMeaning = 4
	DeclarationMeaningMethod                     DeclarationMeaning = 8
	DeclarationMeaningPrivateStatic              DeclarationMeaning = 16
	DeclarationMeaningGetOrSetAccessor           DeclarationMeaning = DeclarationMeaningGetAccessor | DeclarationMeaningSetAccessor
	DeclarationMeaningPropertyAssignmentOrMethod DeclarationMeaning = DeclarationMeaningPropertyAssignment | DeclarationMeaningMethod
)

type DeclarationSpaces int32

const (
	DeclarationSpacesNone            DeclarationSpaces = 0
	DeclarationSpacesExportValue     DeclarationSpaces = 1 << 0
	DeclarationSpacesExportType      DeclarationSpaces = 1 << 1
	DeclarationSpacesExportNamespace DeclarationSpaces = 1 << 2
)

type MinArgumentCountFlags int32

const (
	MinArgumentCountFlagsNone                    MinArgumentCountFlags = 0
	MinArgumentCountFlagsStrongArityForUntypedJS MinArgumentCountFlags = 1 << 0
	MinArgumentCountFlagsVoidIsNonOptional       MinArgumentCountFlags = 1 << 1
)

type IntrinsicTypeKind int32

const (
	IntrinsicTypeKindUppercase IntrinsicTypeKind = iota
	IntrinsicTypeKindLowercase
	IntrinsicTypeKindCapitalize
	IntrinsicTypeKindUncapitalize
	IntrinsicTypeKindNoInfer
)

var intrinsicTypeKinds ReadonlyMap[string, IntrinsicTypeKind] = /* TODO(NewExpression): new Map(Object.entries({     Uppercase: IntrinsicTypeKind.Uppercase,     Lowercase: IntrinsicTypeKind.Lowercase,     Capitalize: IntrinsicTypeKind.Capitalize,     Uncapitalize: IntrinsicTypeKind.Uncapitalize,     NoInfer: IntrinsicTypeKind.NoInfer, })) */ TODO
var SymbolLinks = /* TODO(ClassExpression): class implements SymbolLinks {     declare _symbolLinksBrand: any; } */ TODO

func NodeLinks(this NodeLinks) {
	this.flags = NodeCheckFlagsNone
}
func getNodeId(node Node) number {
	if !node.id {
		node.id = nextNodeId
		nextNodeId++
	}
	return node.id
}
func getSymbolId(symbol Symbol) SymbolId {
	if !symbol.id {
		symbol.id = nextSymbolId
		nextSymbolId++
	}
	return symbol.id
}
func isInstantiatedModule(node ModuleDeclaration, preserveConstEnums bool) /* TODO(undefined): boolean */ TODO {
	moduleState := getModuleInstanceState(node)
	return moduleState == ModuleInstanceStateInstantiated || (preserveConstEnums && moduleState == ModuleInstanceStateConstEnumOnly)
}
func createTypeChecker(host TypeCheckerHost) TypeChecker {
	var deferredDiagnosticsCallbacks []func() = /* TODO(ArrayLiteralExpression): [] */ TODO
	addLazyDiagnostic := func(arg func()) {
		deferredDiagnosticsCallbacks.push(arg)
	}
	var cancellationToken *CancellationToken
	var scanner *Scanner
	Symbol := objectAllocator.getSymbolConstructor()
	Type := objectAllocator.getTypeConstructor()
	Signature := objectAllocator.getSignatureConstructor()
	typeCount := 0
	symbolCount := 0
	totalInstantiationCount := 0
	instantiationCount := 0
	instantiationDepth := 0
	inlineLevel := 0
	var currentNode Node
	var varianceTypeParameter *TypeParameter
	isInferencePartiallyBlocked := false
	emptySymbols := createSymbolTable()
	arrayVariances := /* TODO(ArrayLiteralExpression): [VarianceFlags.Covariant] */ TODO
	compilerOptions := host.getCompilerOptions()
	languageVersion := getEmitScriptTarget(compilerOptions)
	moduleKind := getEmitModuleKind(compilerOptions)
	legacyDecorators := !!compilerOptions.experimentalDecorators
	useDefineForClassFields := getUseDefineForClassFields(compilerOptions)
	emitStandardClassFields := getEmitStandardClassFields(compilerOptions)
	allowSyntheticDefaultImports := getAllowSyntheticDefaultImports(compilerOptions)
	strictNullChecks := getStrictOptionValue(compilerOptions, "strictNullChecks")
	strictFunctionTypes := getStrictOptionValue(compilerOptions, "strictFunctionTypes")
	strictBindCallApply := getStrictOptionValue(compilerOptions, "strictBindCallApply")
	strictPropertyInitialization := getStrictOptionValue(compilerOptions, "strictPropertyInitialization")
	strictBuiltinIteratorReturn := getStrictOptionValue(compilerOptions, "strictBuiltinIteratorReturn")
	noImplicitAny := getStrictOptionValue(compilerOptions, "noImplicitAny")
	noImplicitThis := getStrictOptionValue(compilerOptions, "noImplicitThis")
	useUnknownInCatchVariables := getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables")
	exactOptionalPropertyTypes := compilerOptions.exactOptionalPropertyTypes
	noUncheckedSideEffectImports := !!compilerOptions.noUncheckedSideEffectImports
	checkBinaryExpression := createCheckBinaryExpression()
	emitResolver := createResolver()
	nodeBuilder := createNodeBuilder()
	syntacticNodeBuilder := createSyntacticTypeNodeBuilder(compilerOptions /* TODO(ObjectLiteralExpression): {         isEntityNameVisible,         isExpandoFunctionDeclaration,         getAllAccessorDeclarations: getAllAccessorDeclarationsForDeclaration,         requiresAddingImplicitUndefined,         isUndefinedIdentifierExpression(node: Identifier) {             Debug.assert(isExpressionNode(node));             return getSymbolAtLocation(node) === undefinedSymbol;         },         isDefinitelyReferenceToGlobalSymbolObject,     } */, TODO)
	evaluate := createEvaluator( /* TODO(ObjectLiteralExpression): {         evaluateElementAccessExpression,         evaluateEntityNameExpression,     } */ TODO)
	globals := createSymbolTable()
	undefinedSymbol := createSymbol(SymbolFlagsProperty, "undefined" /* as */ /* TODO(TypeReference): __String */)
	undefinedSymbol.declarations = /* TODO(ArrayLiteralExpression): [] */ TODO
	globalThisSymbol := createSymbol(SymbolFlagsModule, "globalThis" /* as */ /* TODO(TypeReference): __String */, CheckFlagsReadonly)
	globalThisSymbol.exports = globals
	globalThisSymbol.declarations = /* TODO(ArrayLiteralExpression): [] */ TODO
	globals.set(globalThisSymbol.escapedName, globalThisSymbol)
	argumentsSymbol := createSymbol(SymbolFlagsProperty, "arguments" /* as */ /* TODO(TypeReference): __String */)
	requireSymbol := createSymbol(SymbolFlagsProperty, "require" /* as */ /* TODO(TypeReference): __String */)
	isolatedModulesLikeFlagName := /* TODO(ConditionalExpression): compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules" */ TODO
	canCollectSymbolAliasAccessabilityData := !compilerOptions.verbatimModuleSyntax
	var apparentArgumentCount /* TODO(NumberKeyword): number */ any
	var lastGetCombinedNodeFlagsNode Node
	lastGetCombinedNodeFlagsResult := NodeFlagsNone
	var lastGetCombinedModifierFlagsNode Declaration
	lastGetCombinedModifierFlagsResult := ModifierFlagsNone
	resolveName := createNameResolver( /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSymbol,         onPropertyWithInvalidInitializer: checkAndReportErrorForInvalidInitializer,         onFailedToResolveSymbol,         onSuccessfullyResolvedSymbol,     } */ TODO)
	resolveNameForSymbolSuggestion := createNameResolver( /* TODO(ObjectLiteralExpression): {         compilerOptions,         requireSymbol,         argumentsSymbol,         globals,         getSymbolOfDeclaration,         error,         getRequiresScopeChangeCache,         setRequiresScopeChangeCache,         lookup: getSuggestionForSymbolNameLookup,     } */ TODO)
	var checker TypeChecker = /* TODO(ObjectLiteralExpression): {         getNodeCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.nodeCount, 0),         getIdentifierCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.identifierCount, 0),         getSymbolCount: () => reduceLeft(host.getSourceFiles(), (n, s) => n + s.symbolCount, symbolCount),         getTypeCount: () => typeCount,         getInstantiationCount: () => totalInstantiationCount,         getRelationCacheSizes: () => ({             assignable: assignableRelation.size,             identity: identityRelation.size,             subtype: subtypeRelation.size,             strictSubtype: strictSubtypeRelation.size,         }),         isUndefinedSymbol: symbol => symbol === undefinedSymbol,         isArgumentsSymbol: symbol => symbol === argumentsSymbol,         isUnknownSymbol: symbol => symbol === unknownSymbol,         getMergedSymbol,         symbolIsValue,         getDiagnostics,         getGlobalDiagnostics,         getRecursionIdentity,         getUnmatchedProperties,         getTypeOfSymbolAtLocation: (symbol, locationIn) => {             const location = getParseTreeNode(locationIn);             return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;         },         getTypeOfSymbol,         getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {             const parameter = getParseTreeNode(parameterIn, isParameter);             if (parameter === undefined) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");             Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent));             return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));         },         getDeclaredTypeOfSymbol,         getPropertiesOfType,         getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),         getPrivateIdentifierPropertyOfType: (leftType: Type, name: string, location: Node) => {             const node = getParseTreeNode(location);             if (!node) {                 return undefined;             }             const propName = escapeLeadingUnderscores(name);             const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);             return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : undefined;         },         getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),         getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexInfosOfType,         getIndexInfosOfIndexSymbol,         getSignaturesOfType,         getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === IndexKind.String ? stringType : numberType),         getIndexType: type => getIndexType(type),         getBaseTypes,         getBaseTypeOfLiteralType,         getWidenedType,         getWidenedLiteralType,         getTypeFromTypeNode: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node ? getTypeFromTypeNode(node) : errorType;         },         getParameterType: getTypeAtPosition,         getParameterIdentifierInfoAtPosition,         getPromisedTypeOfPromise,         getAwaitedType: type => getAwaitedType(type),         getReturnTypeOfSignature,         isNullableType,         getNullableType,         getNonNullableType,         getNonOptionalType: removeOptionalTypeMarker,         getTypeArguments,         typeToTypeNode: nodeBuilder.typeToTypeNode,         typePredicateToTypePredicateNode: nodeBuilder.typePredicateToTypePredicateNode,         indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,         signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,         symbolToEntityName: nodeBuilder.symbolToEntityName,         symbolToExpression: nodeBuilder.symbolToExpression,         symbolToNode: nodeBuilder.symbolToNode,         symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,         symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,         typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,         getSymbolsInScope: (locationIn, meaning) => {             const location = getParseTreeNode(locationIn);             return location ? getSymbolsInScope(location, meaning) : [];         },         getSymbolAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             // set ignoreErrors: true because any lookups invoked by the API shouldn't cause any new errors             return node ? getSymbolAtLocation(node, /*ignoreErrors* / true) : undefined;         },         getIndexInfosAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getIndexInfosAtLocation(node) : undefined;         },         getShorthandAssignmentValueSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getShorthandAssignmentValueSymbol(node) : undefined;         },         getExportSpecifierLocalTargetSymbol: nodeIn => {             const node = getParseTreeNode(nodeIn, isExportSpecifier);             return node ? getExportSpecifierLocalTargetSymbol(node) : undefined;         },         getExportSymbolOfSymbol(symbol) {             return getMergedSymbol(symbol.exportSymbol || symbol);         },         getTypeAtLocation: nodeIn => {             const node = getParseTreeNode(nodeIn);             return node ? getTypeOfNode(node) : errorType;         },         getTypeOfAssignmentPattern: nodeIn => {             const node = getParseTreeNode(nodeIn, isAssignmentPattern);             return node && getTypeOfAssignmentPattern(node) || errorType;         },         getPropertySymbolOfDestructuringAssignment: locationIn => {             const location = getParseTreeNode(locationIn, isIdentifier);             return location ? getPropertySymbolOfDestructuringAssignment(location) : undefined;         },         signatureToString: (signature, enclosingDeclaration, flags, kind) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);         },         typeToString: (type, enclosingDeclaration, flags) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);         },         symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags);         },         typePredicateToString: (predicate, enclosingDeclaration, flags) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);         },         writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {             return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);         },         writeType: (type, enclosingDeclaration, flags, writer) => {             return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);         },         writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {             return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);         },         writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {             return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);         },         getAugmentedPropertiesOfType,         getRootSymbols,         getSymbolOfExpando,         getContextualType: (nodeIn: Expression, contextFlags?: ContextFlags) => {             const node = getParseTreeNode(nodeIn, isExpression);             if (!node) {                 return undefined;             }             if (contextFlags! & ContextFlags.Completions) {                 return runWithInferenceBlockedFromSourceNode(node, () => getContextualType(node, contextFlags));             }             return getContextualType(node, contextFlags);         },         getContextualTypeForObjectLiteralElement: nodeIn => {             const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);             return node ? getContextualTypeForObjectLiteralElement(node, /*contextFlags* / undefined) : undefined;         },         getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {             const node = getParseTreeNode(nodeIn, isCallLikeExpression);             return node && getContextualTypeForArgumentAtIndex(node, argIndex);         },         getContextualTypeForJsxAttribute: nodeIn => {             const node = getParseTreeNode(nodeIn, isJsxAttributeLike);             return node && getContextualTypeForJsxAttribute(node, /*contextFlags* / undefined);         },         isContextSensitive,         getTypeOfPropertyOfContextualType,         getFullyQualifiedName,         getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.Normal),         getCandidateSignaturesForStringLiteralCompletions,         getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, CheckMode.IsForSignatureHelp)),         getExpandedParameters,         hasEffectiveRestParameter,         containsArgumentsReference,         getConstantValue: nodeIn => {             const node = getParseTreeNode(nodeIn, canHaveConstantValue);             return node ? getConstantValue(node) : undefined;         },         isValidPropertyAccess: (nodeIn, propertyName) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);             return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));         },         isValidPropertyAccessForCompletions: (nodeIn, type, property) => {             const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);             return !!node && isValidPropertyAccessForCompletions(node, type, property);         },         getSignatureFromDeclaration: declarationIn => {             const declaration = getParseTreeNode(declarationIn, isFunctionLike);             return declaration ? getSignatureFromDeclaration(declaration) : undefined;         },         isImplementationOfOverload: nodeIn => {             const node = getParseTreeNode(nodeIn, isFunctionLike);             return node ? isImplementationOfOverload(node) : undefined;         },         getImmediateAliasedSymbol,         getAliasedSymbol: resolveAlias,         getEmitResolver,         requiresAddingImplicitUndefined,         getExportsOfModule: getExportsOfModuleAsArray,         getExportsAndPropertiesOfModule,         forEachExportAndPropertyOfModule,         getSymbolWalker: createGetSymbolWalker(             getRestTypeOfSignature,             getTypePredicateOfSignature,             getReturnTypeOfSignature,             getBaseTypes,             resolveStructuredTypeMembers,             getTypeOfSymbol,             getResolvedSymbol,             getConstraintOfTypeParameter,             getFirstIdentifier,             getTypeArguments,         ),         getAmbientModules,         getJsxIntrinsicTagNamesAt,         isOptionalParameter: nodeIn => {             const node = getParseTreeNode(nodeIn, isParameter);             return node ? isOptionalParameter(node) : false;         },         tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),         tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),         tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, /*withAugmentations* / true),         getApparentType,         getUnionType,         isTypeAssignableTo,         createAnonymousType,         createSignature,         createSymbol,         createIndexInfo,         getAnyType: () => anyType,         getStringType: () => stringType,         getStringLiteralType,         getNumberType: () => numberType,         getNumberLiteralType,         getBigIntType: () => bigintType,         getBigIntLiteralType,         createPromiseType,         createArrayType,         getElementTypeOfArrayType,         getBooleanType: () => booleanType,         getFalseType: (fresh?) => fresh ? falseType : regularFalseType,         getTrueType: (fresh?) => fresh ? trueType : regularTrueType,         getVoidType: () => voidType,         getUndefinedType: () => undefinedType,         getNullType: () => nullType,         getESSymbolType: () => esSymbolType,         getNeverType: () => neverType,         getOptionalType: () => optionalType,         getPromiseType: () => getGlobalPromiseType(/*reportErrors* / false),         getPromiseLikeType: () => getGlobalPromiseLikeType(/*reportErrors* / false),         getAnyAsyncIterableType: () => {             const type = getGlobalAsyncIterableType(/*reportErrors* / false);             if (type === emptyGenericType) return undefined;             return createTypeReference(type, [anyType, anyType, anyType]);         },         isSymbolAccessible,         isArrayType,         isTupleType,         isArrayLikeType,         isEmptyAnonymousObjectType,         isTypeInvalidDueToUnionDiscriminant,         getExactOptionalProperties,         getAllPossiblePropertiesOfTypes,         getSuggestedSymbolForNonexistentProperty,         getSuggestedSymbolForNonexistentJSXAttribute,         getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),         getSuggestedSymbolForNonexistentModule,         getSuggestedSymbolForNonexistentClassMember,         getBaseConstraintOfType,         getDefaultFromTypeParameter: type => type && type.flags & TypeFlags.TypeParameter ? getDefaultFromTypeParameter(type as TypeParameter) : undefined,         resolveName(name, location, meaning, excludeGlobals) {             return resolveName(location, escapeLeadingUnderscores(name), meaning, /*nameNotFoundMessage* / undefined, /*isUse* / false, excludeGlobals);         },         getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),         getJsxFragmentFactory: n => {             const jsxFragmentFactory = getJsxFragmentFactoryEntity(n);             return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);         },         getAccessibleSymbolChain,         getTypePredicateOfSignature,         resolveExternalModuleName: moduleSpecifierIn => {             const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);             return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, /*ignoreErrors* / true);         },         resolveExternalModuleSymbol,         tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {             const node = getParseTreeNode(nodeIn);             return node && tryGetThisTypeAt(node, includeGlobalThis, container);         },         getTypeArgumentConstraint: nodeIn => {             const node = getParseTreeNode(nodeIn, isTypeNode);             return node && getTypeArgumentConstraint(node);         },         getSuggestionDiagnostics: (fileIn, ct) => {             const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");             if (skipTypeChecking(file, compilerOptions, host)) {                 return emptyArray;             }              let diagnostics: DiagnosticWithLocation[] | undefined;             try {                 // Record the cancellation token so it can be checked later on during checkSourceElement.                 // Do this in a finally block so we can ensure that it gets reset back to nothing after                 // this call is done.                 cancellationToken = ct;                  // Ensure file is type checked, with _eager_ diagnostic production, so identifiers are registered as potentially unused                 checkSourceFileWithEagerDiagnostics(file);                 Debug.assert(!!(getNodeLinks(file).flags & NodeCheckFlags.TypeChecked));                  diagnostics = addRange(diagnostics, suggestionDiagnostics.getDiagnostics(file.fileName));                 checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag) => {                     if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & NodeFlags.Ambient))) {                         (diagnostics || (diagnostics = [])).push({ ...diag, category: DiagnosticCategory.Suggestion });                     }                 });                  return diagnostics || emptyArray;             }             finally {                 cancellationToken = undefined;             }         },          runWithCancellationToken: (token, callback) => {             try {                 cancellationToken = token;                 return callback(checker);             }             finally {                 cancellationToken = undefined;             }         },          getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,         isDeclarationVisible,         isPropertyAccessible,         getTypeOnlyAliasDeclaration,         getMemberOverrideModifierStatus,         isTypeParameterPossiblyReferenced,         typeHasCallOrConstructSignatures,         getSymbolFlags,     } */ TODO
	getCandidateSignaturesForStringLiteralCompletions := func(call CallLikeExpression, editingArgument Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
		candidatesSet := /* TODO(NewExpression): new Set<Signature>() */ TODO
		var candidates []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		runWithInferenceBlockedFromSourceNode(editingArgument, func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
			/* TODO(Identifier): getResolvedSignatureWorker */
			/* TODO(Identifier): call */
			/* TODO(Identifier): candidates */
			/* TODO(Identifier): undefined */
			/* TODO(PropertyAccessExpression): CheckMode.Normal */
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		candidates.length = 0
		runWithoutResolvedSignatureCaching(editingArgument, func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
			/* TODO(Identifier): getResolvedSignatureWorker */
			/* TODO(Identifier): call */
			/* TODO(Identifier): candidates */
			/* TODO(Identifier): undefined */
			/* TODO(PropertyAccessExpression): CheckMode.Normal */
		})
		for _, candidate := range candidates {
			candidatesSet.add(candidate)
		}
		return arrayFrom(candidatesSet)
	}
	runWithoutResolvedSignatureCaching := func(node Node, fn func() T) T {
		node = findAncestor(node, isCallLikeOrFunctionLikeExpression)
		if node {
			cachedResolvedSignatures := /* TODO(ArrayLiteralExpression): [] */ TODO
			cachedTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(WhileStatement): while (node) {                 const nodeLinks = getNodeLinks(node);                 cachedResolvedSignatures.push([nodeLinks, nodeLinks.resolvedSignature] as const);                 nodeLinks.resolvedSignature = undefined;                 if (isFunctionExpressionOrArrowFunction(node)) {                     const symbolLinks = getSymbolLinks(getSymbolOfDeclaration(node));                     const type = symbolLinks.type;                     cachedTypes.push([symbolLinks, type] as const);                     symbolLinks.type = undefined;                 }                 node = findAncestor(node.parent, isCallLikeOrFunctionLikeExpression);             } */
			result := fn()
			for _, TODO_IDENTIFIER := range cachedResolvedSignatures {
				nodeLinks.resolvedSignature = resolvedSignature
			}
			for _, TODO_IDENTIFIER := range cachedTypes {
				symbolLinks.type_ = type_
			}
			return result
		}
		return fn()
	}
	runWithInferenceBlockedFromSourceNode := func(node Node, fn func() T) T {
		containingCall := findAncestor(node, isCallLikeExpression)
		if containingCall {
			toMarkSkip := /* TODO(NonNullExpression): node! */ TODO
			/* TODO(DoStatement): do {                 getNodeLinks(toMarkSkip).skipDirectInference = true;                 toMarkSkip = toMarkSkip.parent;             }             while (toMarkSkip && toMarkSkip !== containingCall); */
		}
		isInferencePartiallyBlocked = true
		result := runWithoutResolvedSignatureCaching(node, fn)
		isInferencePartiallyBlocked = false
		if containingCall {
			toMarkSkip := /* TODO(NonNullExpression): node! */ TODO
			/* TODO(DoStatement): do {                 getNodeLinks(toMarkSkip).skipDirectInference = undefined;                 toMarkSkip = toMarkSkip.parent;             }             while (toMarkSkip && toMarkSkip !== containingCall); */
		}
		return result
	}
	getResolvedSignatureWorker := func(nodeIn CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, argumentCount /* TODO(NumberKeyword): number */ any, checkMode CheckMode) *Signature {
		node := getParseTreeNode(nodeIn, isCallLikeExpression)
		apparentArgumentCount = argumentCount
		res := /* TODO(ConditionalExpression): !node ? undefined : getResolvedSignature(node, candidatesOutArray, checkMode) */ TODO
		apparentArgumentCount = nil
		return res
	}
	tupleTypes := /* TODO(NewExpression): new Map<string, GenericType>() */ TODO
	unionTypes := /* TODO(NewExpression): new Map<string, UnionType>() */ TODO
	unionOfUnionTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	intersectionTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	stringLiteralTypes := /* TODO(NewExpression): new Map<string, StringLiteralType>() */ TODO
	numberLiteralTypes := /* TODO(NewExpression): new Map<number, NumberLiteralType>() */ TODO
	bigIntLiteralTypes := /* TODO(NewExpression): new Map<string, BigIntLiteralType>() */ TODO
	enumLiteralTypes := /* TODO(NewExpression): new Map<string, LiteralType>() */ TODO
	indexedAccessTypes := /* TODO(NewExpression): new Map<string, IndexedAccessType>() */ TODO
	templateLiteralTypes := /* TODO(NewExpression): new Map<string, TemplateLiteralType>() */ TODO
	stringMappingTypes := /* TODO(NewExpression): new Map<string, StringMappingType>() */ TODO
	substitutionTypes := /* TODO(NewExpression): new Map<string, SubstitutionType>() */ TODO
	subtypeReductionCache := /* TODO(NewExpression): new Map<string, Type[]>() */ TODO
	decoratorContextOverrideTypeCache := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	cachedTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	var evolvingArrayTypes []EvolvingArrayType = /* TODO(ArrayLiteralExpression): [] */ TODO
	var undefinedProperties SymbolTable = /* TODO(NewExpression): new Map() */ TODO
	markerTypes := /* TODO(NewExpression): new Set<number>() */ TODO
	unknownSymbol := createSymbol(SymbolFlagsProperty, "unknown" /* as */ /* TODO(TypeReference): __String */)
	resolvingSymbol := createSymbol(0, InternalSymbolNameResolving)
	unresolvedSymbols := /* TODO(NewExpression): new Map<string, TransientSymbol>() */ TODO
	errorTypes := /* TODO(NewExpression): new Map<string, Type>() */ TODO
	seenIntrinsicNames := /* TODO(NewExpression): new Set<string>() */ TODO
	anyType := createIntrinsicType(TypeFlagsAny, "any")
	autoType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsNonInferrableType, "auto")
	wildcardType := createIntrinsicType(TypeFlagsAny, "any", nil, "wildcard")
	blockedStringType := createIntrinsicType(TypeFlagsAny, "any", nil, "blocked string")
	errorType := createIntrinsicType(TypeFlagsAny, "error")
	unresolvedType := createIntrinsicType(TypeFlagsAny, "unresolved")
	nonInferrableAnyType := createIntrinsicType(TypeFlagsAny, "any", ObjectFlagsContainsWideningType, "non-inferrable")
	intrinsicMarkerType := createIntrinsicType(TypeFlagsAny, "intrinsic")
	unknownType := createIntrinsicType(TypeFlagsUnknown, "unknown")
	undefinedType := createIntrinsicType(TypeFlagsUndefined, "undefined")
	undefinedWideningType := /* TODO(ConditionalExpression): strictNullChecks ? undefinedType : createIntrinsicType(TypeFlags.Undefined, "undefined", ObjectFlags.ContainsWideningType, "widening") */ TODO
	missingType := createIntrinsicType(TypeFlagsUndefined, "undefined", nil, "missing")
	undefinedOrMissingType := /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? missingType : undefinedType */ TODO
	optionalType := createIntrinsicType(TypeFlagsUndefined, "undefined", nil, "optional")
	nullType := createIntrinsicType(TypeFlagsNull, "null")
	nullWideningType := /* TODO(ConditionalExpression): strictNullChecks ? nullType : createIntrinsicType(TypeFlags.Null, "null", ObjectFlags.ContainsWideningType, "widening") */ TODO
	stringType := createIntrinsicType(TypeFlagsString, "string")
	numberType := createIntrinsicType(TypeFlagsNumber, "number")
	bigintType := createIntrinsicType(TypeFlagsBigInt, "bigint")
	falseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false", nil, "fresh") /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	regularFalseType := createIntrinsicType(TypeFlagsBooleanLiteral, "false")        /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	trueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true", nil, "fresh")   /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	regularTrueType := createIntrinsicType(TypeFlagsBooleanLiteral, "true")          /* as */ /* TODO(TypeReference): FreshableIntrinsicType */
	trueType.regularType = regularTrueType
	trueType.freshType = trueType
	regularTrueType.regularType = regularTrueType
	regularTrueType.freshType = trueType
	falseType.regularType = regularFalseType
	falseType.freshType = falseType
	regularFalseType.regularType = regularFalseType
	regularFalseType.freshType = falseType
	booleanType := getUnionType( /* TODO(ArrayLiteralExpression): [regularFalseType, regularTrueType] */ TODO)
	esSymbolType := createIntrinsicType(TypeFlagsESSymbol, "symbol")
	voidType := createIntrinsicType(TypeFlagsVoid, "void")
	neverType := createIntrinsicType(TypeFlagsNever, "never")
	silentNeverType := createIntrinsicType(TypeFlagsNever, "never", ObjectFlagsNonInferrableType, "silent")
	implicitNeverType := createIntrinsicType(TypeFlagsNever, "never", nil, "implicit")
	unreachableNeverType := createIntrinsicType(TypeFlagsNever, "never", nil, "unreachable")
	nonPrimitiveType := createIntrinsicType(TypeFlagsNonPrimitive, "object")
	stringOrNumberType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType] */ TODO)
	stringNumberSymbolType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType, esSymbolType] */ TODO)
	numberOrBigIntType := getUnionType( /* TODO(ArrayLiteralExpression): [numberType, bigintType] */ TODO)
	templateConstraintType := getUnionType( /* TODO(ArrayLiteralExpression): [stringType, numberType, booleanType, bigintType, nullType, undefinedType] */ TODO) /* as */ /* TODO(TypeReference): UnionType */
	numericStringType := getTemplateLiteralType( /* TODO(ArrayLiteralExpression): ["", ""] */ TODO /* TODO(ArrayLiteralExpression): [numberType] */, TODO)
	var restrictiveMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		/* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */
		/* TODO(QuestionToken): ? */
		/* TODO(CallExpression): getRestrictiveTypeParameter(t as TypeParameter) */
		/* TODO(ColonToken): : */
		/* TODO(Identifier): t */
	}, func() /* TODO(undefined): string */ TODO {
	})
	var permissiveMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		/* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */
		/* TODO(QuestionToken): ? */
		/* TODO(Identifier): wildcardType */
		/* TODO(ColonToken): : */
		/* TODO(Identifier): t */
	}, func() /* TODO(undefined): string */ TODO {
	})
	uniqueLiteralType := createIntrinsicType(TypeFlagsNever, "never", nil, "unique literal")
	var uniqueLiteralMapper TypeMapper = makeFunctionTypeMapper(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		/* TODO(BinaryExpression): t.flags & TypeFlags.TypeParameter */
		/* TODO(QuestionToken): ? */
		/* TODO(Identifier): uniqueLiteralType */
		/* TODO(ColonToken): : */
		/* TODO(Identifier): t */
	}, func() /* TODO(undefined): string */ TODO {
	})
	var outofbandVarianceMarkerHandler /* TODO(ParenthesizedType): ((onlyUnreliable: boolean) => void) */ any
	reportUnreliableMapper := makeFunctionTypeMapper(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(true)
		}
		return t
	}, func() /* TODO(undefined): string */ TODO {
	})
	reportUnmeasurableMapper := makeFunctionTypeMapper(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if outofbandVarianceMarkerHandler && (t == markerSuperType || t == markerSubType || t == markerOtherType) {
			outofbandVarianceMarkerHandler(false)
		}
		return t
	}, func() /* TODO(undefined): string */ TODO {
	})
	emptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	emptyJsxObjectType.objectFlags |= ObjectFlagsJsxAttributes
	emptyTypeLiteralSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
	emptyTypeLiteralSymbol.members = createSymbolTable()
	emptyTypeLiteralType := createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownEmptyObjectType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	unknownUnionType := /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType */ TODO
	emptyGenericType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray) /* as */ /* TODO(TypeReference): ObjectType */ /* as */ /* TODO(TypeReference): GenericType */
	emptyGenericType.instantiations = /* TODO(NewExpression): new Map<string, TypeReference>() */ TODO
	anyFunctionType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	anyFunctionType.objectFlags |= ObjectFlagsNonInferrableType
	noConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	circularConstraintType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	resolvingDefaultType := createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
	markerSuperType := createTypeParameter()
	markerSubType := createTypeParameter()
	markerSubType.constraint = markerSuperType
	markerOtherType := createTypeParameter()
	markerSuperTypeForCheck := createTypeParameter()
	markerSubTypeForCheck := createTypeParameter()
	markerSubTypeForCheck.constraint = markerSuperTypeForCheck
	noTypePredicate := createTypePredicate(TypePredicateKindIdentifier, "<<unresolved>>", 0, anyType)
	anySignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0, SignatureFlagsNone)
	unknownSignature := createSignature(nil, nil, nil, emptyArray, errorType, nil, 0, SignatureFlagsNone)
	resolvingSignature := createSignature(nil, nil, nil, emptyArray, anyType, nil, 0, SignatureFlagsNone)
	silentNeverSignature := createSignature(nil, nil, nil, emptyArray, silentNeverType, nil, 0, SignatureFlagsNone)
	enumNumberIndexInfo := createIndexInfo(numberType, stringType, true)
	iterationTypesCache := /* TODO(NewExpression): new Map<string, IterationTypes>() */ TODO
	var noIterationTypes IterationTypes = /* TODO(ObjectLiteralExpression): {         get yieldType(): Type {             return Debug.fail("Not supported");         },         get returnType(): Type {             return Debug.fail("Not supported");         },         get nextType(): Type {             return Debug.fail("Not supported");         },     } */ TODO
	anyIterationTypes := createIterationTypes(anyType, anyType, anyType)
	var asyncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfAsyncIterable",         iteratorCacheKey: "iterationTypesOfAsyncIterator",         iteratorSymbolName: "asyncIterator",         getGlobalIteratorType: getGlobalAsyncIteratorType,         getGlobalIterableType: getGlobalAsyncIterableType,         getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,         getGlobalIteratorObjectType: getGlobalAsyncIteratorObjectType,         getGlobalGeneratorType: getGlobalAsyncGeneratorType,         getGlobalBuiltinIteratorTypes: getGlobalBuiltinAsyncIteratorTypes,         resolveIterationType: (type, errorNode) => getAwaitedType(type, errorNode, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member),         mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property,     } */ TODO
	var syncIterationTypesResolver IterationTypesResolver = /* TODO(ObjectLiteralExpression): {         iterableCacheKey: "iterationTypesOfIterable",         iteratorCacheKey: "iterationTypesOfIterator",         iteratorSymbolName: "iterator",         getGlobalIteratorType,         getGlobalIterableType,         getGlobalIterableIteratorType,         getGlobalIteratorObjectType,         getGlobalGeneratorType,         getGlobalBuiltinIteratorTypes,         resolveIterationType: (type, _errorNode) => type,         mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,         mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,         mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property,     } */ TODO
	type DuplicateInfoForSymbol struct {
		firstFileLocations  []Declaration
		secondFileLocations []Declaration
		isBlockScoped       bool
	}
	type DuplicateInfoForFiles struct {
		firstFile          SourceFile
		secondFile         SourceFile
		conflictingSymbols Map[string, DuplicateInfoForSymbol]
	}
	var amalgamatedDuplicates *Map[string, DuplicateInfoForFiles]
	reverseMappedCache := /* TODO(NewExpression): new Map<string, Type | undefined>() */ TODO
	reverseHomomorphicMappedCache := /* TODO(NewExpression): new Map<string, Type | undefined>() */ TODO
	var ambientModulesCache /* TODO(ArrayType): Symbol[] */ any
	var patternAmbientModules []PatternAmbientModule
	var patternAmbientModuleAugmentations *Map[string, Symbol]
	var globalObjectType ObjectType
	var globalFunctionType ObjectType
	var globalCallableFunctionType ObjectType
	var globalNewableFunctionType ObjectType
	var globalArrayType GenericType
	var globalReadonlyArrayType GenericType
	var globalStringType ObjectType
	var globalNumberType ObjectType
	var globalBooleanType ObjectType
	var globalRegExpType ObjectType
	var globalThisType GenericType
	var anyArrayType Type
	var autoArrayType Type
	var anyReadonlyArrayType Type
	var deferredGlobalNonNullableTypeAlias Symbol
	var deferredGlobalESSymbolConstructorSymbol *Symbol
	var deferredGlobalESSymbolConstructorTypeSymbol *Symbol
	var deferredGlobalESSymbolType *ObjectType
	var deferredGlobalTypedPropertyDescriptorType GenericType
	var deferredGlobalPromiseType *GenericType
	var deferredGlobalPromiseLikeType *GenericType
	var deferredGlobalPromiseConstructorSymbol *Symbol
	var deferredGlobalPromiseConstructorLikeType *ObjectType
	var deferredGlobalIterableType *GenericType
	var deferredGlobalIteratorType *GenericType
	var deferredGlobalIterableIteratorType *GenericType
	var deferredGlobalIteratorObjectType *GenericType
	var deferredGlobalGeneratorType *GenericType
	var deferredGlobalIteratorYieldResultType *GenericType
	var deferredGlobalIteratorReturnResultType *GenericType
	var deferredGlobalAsyncIterableType *GenericType
	var deferredGlobalAsyncIteratorType *GenericType
	var deferredGlobalAsyncIterableIteratorType *GenericType
	var deferredGlobalBuiltinIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
	var deferredGlobalBuiltinAsyncIteratorTypes /* TODO(TypeOperator): readonly GenericType[] */ any
	var deferredGlobalAsyncIteratorObjectType *GenericType
	var deferredGlobalAsyncGeneratorType *GenericType
	var deferredGlobalTemplateStringsArrayType *ObjectType
	var deferredGlobalImportMetaType ObjectType
	var deferredGlobalImportMetaExpressionType ObjectType
	var deferredGlobalImportCallOptionsType *ObjectType
	var deferredGlobalImportAttributesType *ObjectType
	var deferredGlobalDisposableType *ObjectType
	var deferredGlobalAsyncDisposableType *ObjectType
	var deferredGlobalExtractSymbol *Symbol
	var deferredGlobalOmitSymbol *Symbol
	var deferredGlobalAwaitedSymbol *Symbol
	var deferredGlobalBigIntType *ObjectType
	var deferredGlobalNaNSymbol *Symbol
	var deferredGlobalRecordSymbol *Symbol
	var deferredGlobalClassDecoratorContextType *GenericType
	var deferredGlobalClassMethodDecoratorContextType *GenericType
	var deferredGlobalClassGetterDecoratorContextType *GenericType
	var deferredGlobalClassSetterDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorContextType *GenericType
	var deferredGlobalClassAccessorDecoratorTargetType *GenericType
	var deferredGlobalClassAccessorDecoratorResultType *GenericType
	var deferredGlobalClassFieldDecoratorContextType *GenericType
	allPotentiallyUnusedIdentifiers := /* TODO(NewExpression): new Map<Path, PotentiallyUnusedIdentifier[]>() */ TODO
	flowLoopStart := 0
	flowLoopCount := 0
	sharedFlowCount := 0
	flowAnalysisDisabled := false
	flowInvocationCount := 0
	var lastFlowNode *FlowNode
	var lastFlowNodeReachable bool
	var flowTypeCache /* TODO(ArrayType): Type[] */ any
	var contextualTypeNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var contextualTypes []*Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var contextualIsCache []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
	contextualTypeCount := 0
	var contextualBindingPatterns []BindingPattern = /* TODO(ArrayLiteralExpression): [] */ TODO
	var inferenceContextNodes []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var inferenceContexts []*InferenceContext = /* TODO(ArrayLiteralExpression): [] */ TODO
	inferenceContextCount := 0
	emptyStringType := getStringLiteralType("")
	zeroType := getNumberLiteralType(0)
	zeroBigIntType := getBigIntLiteralType( /* TODO(ObjectLiteralExpression): { negative: false, base10Value: "0" } */ TODO)
	var resolutionTargets []TypeSystemEntity = /* TODO(ArrayLiteralExpression): [] */ TODO
	var resolutionResults []bool = /* TODO(ArrayLiteralExpression): [] */ TODO
	var resolutionPropertyNames []TypeSystemPropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
	resolutionStart := 0
	inVarianceComputation := false
	suggestionCount := 0
	maximumSuggestionCount := 10
	var mergedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
	var symbolLinks []SymbolLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
	var nodeLinks []NodeLinks = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopCaches []Map[string, Type] = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopKeys []string = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowLoopTypes [][]Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var sharedFlowNodes []FlowNode = /* TODO(ArrayLiteralExpression): [] */ TODO
	var sharedFlowTypes []FlowType = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowNodeReachable [] /* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
	var flowNodePostSuper [] /* TODO(BooleanKeyword): boolean */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialThisCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialNewTargetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialWeakMapSetCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialReflectCollisions []Node = /* TODO(ArrayLiteralExpression): [] */ TODO
	var potentialUnusedRenamedBindingElementsInTypes []BindingElement = /* TODO(ArrayLiteralExpression): [] */ TODO
	var awaitedTypeStack []number = /* TODO(ArrayLiteralExpression): [] */ TODO
	var reverseMappedSourceStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	var reverseMappedTargetStack []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
	reverseExpandingFlags := ExpandingFlagsNone
	diagnostics := createDiagnosticCollection()
	suggestionDiagnostics := createDiagnosticCollection()
	typeofType := createTypeofType()
	var _jsxNamespace __String
	var _jsxFactoryEntity *EntityName
	subtypeRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	strictSubtypeRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	assignableRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	comparableRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	identityRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	enumRelation := /* TODO(NewExpression): new Map<string, RelationComparisonResult>() */ TODO
	var suggestedExtensions [] /* TODO(TupleType): [string, string] */ TODO = /* TODO(ArrayLiteralExpression): [         [".mts", ".mjs"],         [".ts", ".js"],         [".cts", ".cjs"],         [".mjs", ".mjs"],         [".js", ".js"],         [".cjs", ".cjs"],         [".tsx", compilerOptions.jsx === JsxEmit.Preserve ? ".jsx" : ".js"],         [".jsx", ".jsx"],         [".json", ".json"],     ] */ TODO
	initializeTypeChecker()
	return checker
	isDefinitelyReferenceToGlobalSymbolObject := func(node Node) bool {
		if !isPropertyAccessExpression(node) {
			/* TODO(FalseKeyword): false */
		}
		if !isIdentifier(node.name) {
			/* TODO(FalseKeyword): false */
		}
		if !isPropertyAccessExpression(node.expression) && !isIdentifier(node.expression) {
			/* TODO(FalseKeyword): false */
		}
		if isIdentifier(node.expression) {
			return idText(node.expression) == "Symbol" && getResolvedSymbol(node.expression) == (getGlobalSymbol("Symbol" /* as */ /* TODO(TypeReference): __String */, SymbolFlagsValue|SymbolFlagsExportValue, nil) || unknownSymbol)
		}
		if !isIdentifier(node.expression.expression) {
			/* TODO(FalseKeyword): false */
		}
		return idText(node.expression.name) == "Symbol" && idText(node.expression.expression) == "globalThis" && getResolvedSymbol(node.expression.expression) == globalThisSymbol
	}
	getCachedType := func(key /* TODO(StringKeyword): string */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): key ? cachedTypes.get(key) : undefined */ TODO
	}
	setCachedType := func(key /* TODO(StringKeyword): string */ any, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if key {
			/* TODO(CallExpression): cachedTypes.set(key, type) */
		}
		return type_
	}
	getJsxNamespace := func(location Node) __String {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if isJsxOpeningFragment(location) {
					if file.localJsxFragmentNamespace {
						return file.localJsxFragmentNamespace
					}
					jsxFragmentPragma := file.pragmas.get("jsxfrag")
					if jsxFragmentPragma {
						chosenPragma := /* TODO(ConditionalExpression): isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma */ TODO
						file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
						visitNode(file.localJsxFragmentFactory, markAsSynthetic, isEntityName)
						if file.localJsxFragmentFactory {
							return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText */ TODO
						}
					}
					entity := getJsxFragmentFactoryEntity(location)
					if entity {
						file.localJsxFragmentFactory = entity
						return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText */ TODO
					}
				} else {
					localJsxNamespace := getLocalJsxNamespace(file)
					if localJsxNamespace {
						return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxNamespace = localJsxNamespace */ TODO
					}
				}
			}
		}
		if !_jsxNamespace {
			_jsxNamespace = "React" /* as */ /* TODO(TypeReference): __String */
			if compilerOptions.jsxFactory {
				_jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion)
				visitNode(_jsxFactoryEntity, markAsSynthetic)
				if _jsxFactoryEntity {
					_jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText
				}
			} else if compilerOptions.reactNamespace {
				_jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace)
			}
		}
		if !_jsxFactoryEntity {
			_jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement")
		}
		return _jsxNamespace
	}
	getLocalJsxNamespace := func(file SourceFile) *__String {
		if file.localJsxNamespace {
			return file.localJsxNamespace
		}
		jsxPragma := file.pragmas.get("jsx")
		if jsxPragma {
			chosenPragma := /* TODO(ConditionalExpression): isArray(jsxPragma) ? jsxPragma[0] : jsxPragma */ TODO
			file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion)
			visitNode(file.localJsxFactory, markAsSynthetic, isEntityName)
			if file.localJsxFactory {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText */ TODO
			}
		}
	}
	markAsSynthetic := func(node T) VisitResult[T] {
		setTextRangePosEnd(node, -1, -1)
		return visitEachChildWorker(node, markAsSynthetic, nil)
	}
	getEmitResolver := func(sourceFile SourceFile, cancellationToken CancellationToken, skipDiagnostics bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitResolver */ TODO {
		if !skipDiagnostics {
			/* TODO(CallExpression): getDiagnostics(sourceFile, cancellationToken) */
		}
		return emitResolver
	}
	lookupOrIssueError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
		existing := diagnostics.lookup(diagnostic)
		if existing {
			return existing
		} else {
			diagnostics.add(diagnostic)
			return diagnostic
		}
	}
	errorSkippedOn := func(key CompilerOptions, location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message /* TODO(SpreadElement): ...args */, TODO)
		diagnostic.skippedOn = key
		return diagnostic
	}
	createError := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		return /* TODO(ConditionalExpression): location             ? createDiagnosticForNode(location, message, ...args)             : createCompilerDiagnostic(message, ...args) */ TODO
	}
	error := func(location Node, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := createError(location, message /* TODO(SpreadElement): ...args */, TODO)
		diagnostics.add(diagnostic)
		return diagnostic
	}
	addErrorOrSuggestion := func(isError bool, diagnostic Diagnostic) {
		if isError {
			diagnostics.add(diagnostic)
		} else {
			suggestionDiagnostics.add( /* TODO(ObjectLiteralExpression): { ...diagnostic, category: DiagnosticCategory.Suggestion } */ TODO)
		}
	}
	errorOrSuggestion := func(isError bool, location Node, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) {
		if location.pos < 0 || location.end < 0 {
			if !isError {
				return
			}
			file := getSourceFileOfNode(location)
			addErrorOrSuggestion(isError /* TODO(ConditionalExpression): "message" in message ? createFileDiagnostic(file, 0, 0, message, ...args) : createDiagnosticForFileFromMessageChain(file, message) */, TODO)
			return
		}
		addErrorOrSuggestion(isError /* TODO(ConditionalExpression): "message" in message ? createDiagnosticForNode(location, message, ...args) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message) */, TODO)
	}
	errorAndMaybeSuggestAwait := func(location Node, maybeMissingAwait bool, message DiagnosticMessage, args DiagnosticArguments) Diagnostic {
		diagnostic := error(location, message /* TODO(SpreadElement): ...args */, TODO)
		if maybeMissingAwait {
			related := createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await)
			addRelatedInfo(diagnostic, related)
		}
		return diagnostic
	}
	addDeprecatedSuggestionWorker := func(declarations /* TODO(UnionType): Node | Node[] */ any, diagnostic DiagnosticWithLocation) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		deprecatedTag := /* TODO(ConditionalExpression): Array.isArray(declarations) ? forEach(declarations, getJSDocDeprecatedTag) : getJSDocDeprecatedTag(declarations) */ TODO
		if deprecatedTag {
			addRelatedInfo(diagnostic, createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here))
		}
		suggestionDiagnostics.add(diagnostic)
		return diagnostic
	}
	isDeprecatedSymbol := func(symbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
		parentSymbol := getParentOfSymbol(symbol)
		if parentSymbol && length(symbol.declarations) > 1 {
			return /* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Interface ? some(symbol.declarations, isDeprecatedDeclaration) : every(symbol.declarations, isDeprecatedDeclaration) */ TODO
		}
		return !!symbol.valueDeclaration && isDeprecatedDeclaration(symbol.valueDeclaration) || length(symbol.declarations) && every(symbol.declarations, isDeprecatedDeclaration)
	}
	isDeprecatedDeclaration := func(declaration Declaration) /* TODO(undefined): boolean */ TODO {
		return !!(getCombinedNodeFlagsCached(declaration) & NodeFlagsDeprecated)
	}
	addDeprecatedSuggestion := func(location Node, declarations []Node, deprecatedEntity string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		diagnostic := createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity)
		return addDeprecatedSuggestionWorker(declarations, diagnostic)
	}
	addDeprecatedSuggestionWithSignature := func(location Node, declaration Node, deprecatedEntity /* TODO(StringKeyword): string */ any, signatureString string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		diagnostic := /* TODO(ConditionalExpression): deprecatedEntity             ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity)             : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString) */ TODO
		return addDeprecatedSuggestionWorker(declaration, diagnostic)
	}
	createSymbol := func(flags SymbolFlags, name __String, checkFlags CheckFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbolCount++
		symbol := /* TODO(NewExpression): new Symbol(flags | SymbolFlags.Transient, name) */ TODO /* as */ /* TODO(TypeReference): TransientSymbol */
		symbol.links = /* TODO(NewExpression): new SymbolLinks() */ TODO                          /* as */ /* TODO(TypeReference): TransientSymbolLinks */
		symbol.links.checkFlags = checkFlags || CheckFlagsNone
		return symbol
	}
	createParameter := func(name __String, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name)
		symbol.links.type_ = type_
		return symbol
	}
	createProperty := func(name __String, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol(SymbolFlagsProperty, name)
		symbol.links.type_ = type_
		return symbol
	}
	getExcludedSymbolFlags := func(flags SymbolFlags) SymbolFlags {
		var result SymbolFlags = 0
		if flags & SymbolFlagsBlockScopedVariable {
			/* TODO(BinaryExpression): result |= SymbolFlags.BlockScopedVariableExcludes */
		}
		if flags & SymbolFlagsFunctionScopedVariable {
			/* TODO(BinaryExpression): result |= SymbolFlags.FunctionScopedVariableExcludes */
		}
		if flags & SymbolFlagsProperty {
			/* TODO(BinaryExpression): result |= SymbolFlags.PropertyExcludes */
		}
		if flags & SymbolFlagsEnumMember {
			/* TODO(BinaryExpression): result |= SymbolFlags.EnumMemberExcludes */
		}
		if flags & SymbolFlagsFunction {
			/* TODO(BinaryExpression): result |= SymbolFlags.FunctionExcludes */
		}
		if flags & SymbolFlagsClass {
			/* TODO(BinaryExpression): result |= SymbolFlags.ClassExcludes */
		}
		if flags & SymbolFlagsInterface {
			/* TODO(BinaryExpression): result |= SymbolFlags.InterfaceExcludes */
		}
		if flags & SymbolFlagsRegularEnum {
			/* TODO(BinaryExpression): result |= SymbolFlags.RegularEnumExcludes */
		}
		if flags & SymbolFlagsConstEnum {
			/* TODO(BinaryExpression): result |= SymbolFlags.ConstEnumExcludes */
		}
		if flags & SymbolFlagsValueModule {
			/* TODO(BinaryExpression): result |= SymbolFlags.ValueModuleExcludes */
		}
		if flags & SymbolFlagsMethod {
			/* TODO(BinaryExpression): result |= SymbolFlags.MethodExcludes */
		}
		if flags & SymbolFlagsGetAccessor {
			/* TODO(BinaryExpression): result |= SymbolFlags.GetAccessorExcludes */
		}
		if flags & SymbolFlagsSetAccessor {
			/* TODO(BinaryExpression): result |= SymbolFlags.SetAccessorExcludes */
		}
		if flags & SymbolFlagsTypeParameter {
			/* TODO(BinaryExpression): result |= SymbolFlags.TypeParameterExcludes */
		}
		if flags & SymbolFlagsTypeAlias {
			/* TODO(BinaryExpression): result |= SymbolFlags.TypeAliasExcludes */
		}
		if flags & SymbolFlagsAlias {
			/* TODO(BinaryExpression): result |= SymbolFlags.AliasExcludes */
		}
		return result
	}
	recordMergedSymbol := func(target Symbol, source Symbol) {
		if !source.mergeId {
			source.mergeId = nextMergeId
			nextMergeId++
		}
		/* TODO(ElementAccessExpression): mergedSymbols[source.mergeId] */ TODO = target
	}
	cloneSymbol := func(symbol Symbol) TransientSymbol {
		result := createSymbol(symbol.flags, symbol.escapedName)
		result.declarations = /* TODO(ConditionalExpression): symbol.declarations ? symbol.declarations.slice() : [] */ TODO
		result.parent = symbol.parent
		if symbol.valueDeclaration {
			/* TODO(BinaryExpression): result.valueDeclaration = symbol.valueDeclaration */
		}
		if symbol.constEnumOnlyModule {
			/* TODO(BinaryExpression): result.constEnumOnlyModule = true */
		}
		if symbol.members {
			/* TODO(BinaryExpression): result.members = new Map(symbol.members) */
		}
		if symbol.exports {
			/* TODO(BinaryExpression): result.exports = new Map(symbol.exports) */
		}
		recordMergedSymbol(result, symbol)
		return result
	}
	mergeSymbol := func(target Symbol, source Symbol, unidirectional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Symbol {
		if !(target.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|target.flags)&SymbolFlagsAssignment {
			if source == target {
				return target
			}
			if !(target.flags & SymbolFlagsTransient) {
				resolvedTarget := resolveSymbol(target)
				if resolvedTarget == unknownSymbol {
					return source
				}
				if !(resolvedTarget.flags & getExcludedSymbolFlags(source.flags)) || (source.flags|resolvedTarget.flags)&SymbolFlagsAssignment {
					target = cloneSymbol(resolvedTarget)
				} else {
					reportMergeSymbolError(target, source)
					return source
				}
			}
			if source.flags&SymbolFlagsValueModule && target.flags&SymbolFlagsValueModule && target.constEnumOnlyModule && !source.constEnumOnlyModule {
				target.constEnumOnlyModule = false
			}
			target.flags |= source.flags
			if source.valueDeclaration {
				setValueDeclaration(target, source.valueDeclaration)
			}
			addRange(target.declarations, source.declarations)
			if source.members {
				if !target.members {
					/* TODO(BinaryExpression): target.members = createSymbolTable() */
				}
				mergeSymbolTable(target.members, source.members, unidirectional)
			}
			if source.exports {
				if !target.exports {
					/* TODO(BinaryExpression): target.exports = createSymbolTable() */
				}
				mergeSymbolTable(target.exports, source.exports, unidirectional, target)
			}
			if !unidirectional {
				recordMergedSymbol(target, source)
			}
		} else if target.flags & SymbolFlagsNamespaceModule {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== globalThisSymbol */ TODO {
				error(source.declarations && getNameOfDeclaration( /* TODO(ElementAccessExpression): source.declarations[0] */ TODO), Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target))
			}
		} else {
			reportMergeSymbolError(target, source)
		}
		return target
		reportMergeSymbolError := func(target Symbol, source Symbol) {
			isEitherEnum := !!(target.flags&SymbolFlagsEnum || source.flags&SymbolFlagsEnum)
			isEitherBlockScoped := !!(target.flags&SymbolFlagsBlockScopedVariable || source.flags&SymbolFlagsBlockScopedVariable)
			message := /* TODO(ConditionalExpression): isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations                 : isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0                 : Diagnostics.Duplicate_identifier_0 */ TODO
			sourceSymbolFile := source.declarations && getSourceFileOfNode( /* TODO(ElementAccessExpression): source.declarations[0] */ TODO)
			targetSymbolFile := target.declarations && getSourceFileOfNode( /* TODO(ElementAccessExpression): target.declarations[0] */ TODO)
			isSourcePlainJs := isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs)
			isTargetPlainJs := isPlainJsFile(targetSymbolFile, compilerOptions.checkJs)
			symbolName := symbolToString(source)
			if sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSymbolFile !== targetSymbolFile */ TODO {
				firstFile := /* TODO(ConditionalExpression): comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === Comparison.LessThan ? sourceSymbolFile : targetSymbolFile */ TODO
				secondFile := /* TODO(ConditionalExpression): firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile */ TODO
				filesDuplicates := getOrUpdate(amalgamatedDuplicates /* TODO(TemplateExpression): `${firstFile.path}|${secondFile.path}` */, TODO, func() DuplicateInfoForFiles {
					/* TODO(ObjectLiteralExpression): { firstFile, secondFile, conflictingSymbols: new Map() } */
				})
				conflictingSymbolInfo := getOrUpdate(filesDuplicates.conflictingSymbols, symbolName, func() DuplicateInfoForSymbol {
					/* TODO(ObjectLiteralExpression): { isBlockScoped: isEitherBlockScoped, firstFileLocations: [], secondFileLocations: [] } */
				})
				if !isSourcePlainJs {
					/* TODO(CallExpression): addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source) */
				}
				if !isTargetPlainJs {
					/* TODO(CallExpression): addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target) */
				}
			} else {
				if !isSourcePlainJs {
					/* TODO(CallExpression): addDuplicateDeclarationErrorsForSymbols(source, message, symbolName, target) */
				}
				if !isTargetPlainJs {
					/* TODO(CallExpression): addDuplicateDeclarationErrorsForSymbols(target, message, symbolName, source) */
				}
			}
		}
		addDuplicateLocations := func(locs []Declaration, symbol Symbol) {
			if symbol.declarations {
				for _, decl := range symbol.declarations {
					pushIfUnique(locs, decl)
				}
			}
		}
	}
	addDuplicateDeclarationErrorsForSymbols := func(target Symbol, message DiagnosticMessage, symbolName string, source Symbol) {
		forEach(target.declarations, func(node /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
			addDuplicateDeclarationError(node, message, symbolName, source.declarations)
		})
	}
	addDuplicateDeclarationError := func(node Declaration, message DiagnosticMessage, symbolName string, relatedNodes /* TODO(TypeOperator): readonly Declaration[] */ any) {
		errorNode := ( /* TODO(ConditionalExpression): getExpandoInitializer(node, /*isPrototypeAssignment* / false) ? getNameOfExpando(node) : getNameOfDeclaration(node) */ TODO) || node
		err := lookupOrIssueError(errorNode, message, symbolName)
		for _, relatedNode := range relatedNodes || emptyArray {
			adjustedNode := ( /* TODO(ConditionalExpression): getExpandoInitializer(relatedNode, /*isPrototypeAssignment* / false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode) */ TODO) || relatedNode
			if adjustedNode == errorNode {
			}
			err.relatedInformation = err.relatedInformation || /* TODO(ArrayLiteralExpression): [] */ TODO
			leadingMessage := createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName)
			followOnMessage := createDiagnosticForNode(adjustedNode, Diagnostics.and_here)
			if length(err.relatedInformation) >= 5 || some(err.relatedInformation, func(r /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticRelatedInformation */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(BinaryExpression): compareDiagnostics(r, followOnMessage) === Comparison.EqualTo */
				/* TODO(BarBarToken): || */
				/* TODO(BinaryExpression): compareDiagnostics(r, leadingMessage) === Comparison.EqualTo */
			}) {
			}
			addRelatedInfo(err /* TODO(ConditionalExpression): !length(err.relatedInformation) ? leadingMessage : followOnMessage */, TODO)
		}
	}
	combineSymbolTables := func(first *SymbolTable, second *SymbolTable) *SymbolTable {
		if !first.size {
			/* TODO(Identifier): second */
		}
		if !second.size {
			/* TODO(Identifier): first */
		}
		combined := createSymbolTable()
		mergeSymbolTable(combined, first)
		mergeSymbolTable(combined, second)
		return combined
	}
	mergeSymbolTable := func(target SymbolTable, source SymbolTable, unidirectional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, mergedParent Symbol) {
		source.forEach(func(sourceSymbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			targetSymbol := target.get(id)
			merged := /* TODO(ConditionalExpression): targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol) */ TODO
			if mergedParent && targetSymbol {
				merged.parent = mergedParent
			}
			target.set(id, merged)
		})
	}
	mergeModuleAugmentation := func(moduleName /* TODO(UnionType): StringLiteral | Identifier */ any) {
		moduleAugmentation := moduleName.parent /* as */ /* TODO(TypeReference): ModuleDeclaration */
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleAugmentation.symbol.declarations?.[0] !== moduleAugmentation */ TODO {
			Debug.assert( /* TODO(NonNullExpression): moduleAugmentation.symbol.declarations! */ TODO.length > 1)
			return
		}
		if isGlobalScopeAugmentation(moduleAugmentation) {
			mergeSymbolTable(globals /* TODO(NonNullExpression): moduleAugmentation.symbol.exports! */, TODO)
		} else {
			moduleNotFoundError := /* TODO(ConditionalExpression): !(moduleName.parent.parent.flags & NodeFlags.Ambient)                 ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found                 : undefined */ TODO
			mainModule := resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, false, true)
			if !mainModule {
				return
			}
			mainModule = resolveExternalModuleSymbol(mainModule)
			if mainModule.flags & SymbolFlagsNamespace {
				if some(patternAmbientModules, func(module /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").PatternAmbientModule */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): mainModule */
					/* TODO(EqualsEqualsEqualsToken): === */
					/* TODO(PropertyAccessExpression): module.symbol */
				}) {
					merged := mergeSymbol(moduleAugmentation.symbol, mainModule, true)
					if !patternAmbientModuleAugmentations {
						patternAmbientModuleAugmentations = /* TODO(NewExpression): new Map() */ TODO
					}
					patternAmbientModuleAugmentations.set((moduleName /* as */ /* TODO(TypeReference): StringLiteral */).text, merged)
				} else {
					if mainModule.exports.get(InternalSymbolNameExportStar) && moduleAugmentation.symbol.exports.size {
						resolvedExports := getResolvedMembersOrExportsOfSymbol(mainModule, MembersOrExportsResolutionKindresolvedExports)
						for _, TODO_IDENTIFIER := range arrayFrom(moduleAugmentation.symbol.exports.entries()) {
							if resolvedExports.has(key) && !mainModule.exports.has(key) {
								mergeSymbol( /* TODO(NonNullExpression): resolvedExports.get(key)! */ TODO, value)
							}
						}
					}
					mergeSymbol(mainModule, moduleAugmentation.symbol)
				}
			} else {
				error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, (moduleName /* as */ /* TODO(TypeReference): StringLiteral */).text)
			}
		}
	}
	addUndefinedToGlobalsOrErrorOnRedeclaration := func() {
		name := undefinedSymbol.escapedName
		targetSymbol := globals.get(name)
		if targetSymbol {
			forEach(targetSymbol.declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				if !isTypeDeclaration(declaration) {
					diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, unescapeLeadingUnderscores(name)))
				}
			})
		} else {
			globals.set(name, undefinedSymbol)
		}
	}
	getSymbolLinks := func(symbol Symbol) SymbolLinks {
		if symbol.flags & SymbolFlagsTransient {
			/* TODO(PropertyAccessExpression): (symbol as TransientSymbol).links */
		}
		id := getSymbolId(symbol)
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): symbolLinks[id] ??= new SymbolLinks() */ TODO
	}
	getNodeLinks := func(node Node) NodeLinks {
		nodeId := getNodeId(node)
		return /* TODO(ElementAccessExpression): nodeLinks[nodeId] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): nodeLinks[nodeId] = new (NodeLinks as any)() */ TODO)
	}
	getSymbol := func(symbols SymbolTable, name __String, meaning SymbolFlags) *Symbol {
		if meaning {
			symbol := getMergedSymbol(symbols.get(name))
			if symbol {
				if symbol.flags & meaning {
					return symbol
				}
				if symbol.flags & SymbolFlagsAlias {
					targetFlags := getSymbolFlags(symbol)
					if targetFlags & meaning {
						return symbol
					}
				}
			}
		}
	}
	getSymbolsOfParameterPropertyDeclaration := func(parameter ParameterPropertyDeclaration, parameterName __String) /* TODO(TupleType): [Symbol, Symbol] */ TODO {
		constructorDeclaration := parameter.parent
		classDeclaration := parameter.parent.parent
		parameterSymbol := getSymbol( /* TODO(NonNullExpression): constructorDeclaration.locals! */ TODO, parameterName, SymbolFlagsValue)
		propertySymbol := getSymbol(getMembersOfSymbol(classDeclaration.symbol), parameterName, SymbolFlagsValue)
		if parameterSymbol && propertySymbol {
			return /* TODO(ArrayLiteralExpression): [parameterSymbol, propertySymbol] */ TODO
		}
		return Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration")
	}
	isBlockScopedNameDeclaredBeforeUse := func(declaration Declaration, usage Node) bool {
		declarationFile := getSourceFileOfNode(declaration)
		useFile := getSourceFileOfNode(usage)
		declContainer := getEnclosingBlockScopeContainer(declaration)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declarationFile !== useFile */ TODO {
			if (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator)) || (!compilerOptions.outFile) || isInTypeQuery(usage) || declaration.flags&NodeFlagsAmbient {
				return true
			}
			if isUsedInFunctionOrInstanceProperty(usage, declaration) {
				return true
			}
			sourceFiles := host.getSourceFiles()
			return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile)
		}
		if !!(usage.flags & NodeFlagsJSDoc) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage) {
			return true
		}
		if declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken) {
			if declaration.kind == SyntaxKindBindingElement {
				errorBindingElement := getAncestor(usage, SyntaxKindBindingElement) /* as */ /* TODO(TypeReference): BindingElement */
				if errorBindingElement {
					return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): findAncestor(errorBindingElement, isBindingElement) !== findAncestor(declaration, isBindingElement) */ TODO || declaration.pos < errorBindingElement.pos
				}
				return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, SyntaxKindVariableDeclaration) /* as */ /* TODO(TypeReference): Declaration */, usage)
			} else if declaration.kind == SyntaxKindVariableDeclaration {
				return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration /* as */ /* TODO(TypeReference): VariableDeclaration */, usage)
			} else if isClassLike(declaration) {
				container := findAncestor(usage, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
					/* TODO(BinaryExpression): n === declaration */
					/* TODO(QuestionToken): ? */
					/* TODO(StringLiteral): "quit" */
					/* TODO(ColonToken): : */
					/* TODO(ConditionalExpression): isComputedPropertyName(n) ? n.parent.parent === declaration :                         !legacyDecorators && isDecorator(n) && (n.parent === declaration ||                             isMethodDeclaration(n.parent) && n.parent.parent === declaration ||                             isGetOrSetAccessorDeclaration(n.parent) && n.parent.parent === declaration ||                             isPropertyDeclaration(n.parent) && n.parent.parent === declaration ||                             isParameter(n.parent) && n.parent.parent.parent === declaration) */
				})
				if !container {
					return true
				}
				if !legacyDecorators && isDecorator(container) {
					return !!findAncestor(usage, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
						/* TODO(BinaryExpression): n === container */
						/* TODO(QuestionToken): ? */
						/* TODO(StringLiteral): "quit" */
						/* TODO(ColonToken): : */
						/* TODO(BinaryExpression): isFunctionLike(n) && !getImmediatelyInvokedFunctionExpression(n) */
					})
				}
				return false
			} else if isPropertyDeclaration(declaration) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, false)
			} else if isParameterPropertyDeclaration(declaration, declaration.parent) {
				return !(emitStandardClassFields && getContainingClass(declaration) == getContainingClass(usage) && isUsedInFunctionOrInstanceProperty(usage, declaration))
			}
			return true
		}
		if usage.parent.kind == SyntaxKindExportSpecifier || (usage.parent.kind == SyntaxKindExportAssignment && (usage.parent /* as */ /* TODO(TypeReference): ExportAssignment */).isExportEquals) {
			return true
		}
		if usage.kind == SyntaxKindExportAssignment && (usage /* as */ /* TODO(TypeReference): ExportAssignment */).isExportEquals {
			return true
		}
		if isUsedInFunctionOrInstanceProperty(usage, declaration) {
			if emitStandardClassFields && getContainingClass(declaration) && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent)) {
				return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, true)
			} else {
				return true
			}
		}
		return false
		isImmediatelyUsedInInitializerOfBlockScopedVariable := func(declaration VariableDeclaration, usage Node) bool {
			/* TODO(SwitchStatement): switch (declaration.parent.parent.kind) {                 case SyntaxKind.VariableStatement:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForOfStatement:                     // variable statement/for/for-of statement case,                     // use site should not be inside variable declaration (initializer of declaration or binding element)                     if (isSameScopeDescendentOf(usage, declaration, declContainer)) {                         return true;                     }                     break;             } */
			grandparent := declaration.parent.parent
			return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage, grandparent.expression, declContainer)
		}
		isUsedInFunctionOrInstanceProperty := func(usage Node, declaration Node) bool {
			return !!findAncestor(usage, func(current /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
				if current == declContainer {
					return "quit"
				}
				if isFunctionLike(current) {
					return true
				}
				if isClassStaticBlockDeclaration(current) {
					return declaration.pos < usage.pos
				}
				propertyDeclaration := tryCast(current.parent, isPropertyDeclaration)
				if propertyDeclaration {
					initializerOfProperty := propertyDeclaration.initializer == current
					if initializerOfProperty {
						if isStatic(current.parent) {
							if declaration.kind == SyntaxKindMethodDeclaration {
								return true
							}
							if isPropertyDeclaration(declaration) && getContainingClass(usage) == getContainingClass(declaration) {
								propName := declaration.name
								if isIdentifier(propName) || isPrivateIdentifier(propName) {
									type_ := getTypeOfSymbol(getSymbolOfDeclaration(declaration))
									staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
									if isPropertyInitializedInStaticBlocks(propName, type_, staticBlocks, declaration.parent.pos, current.pos) {
										return true
									}
								}
							}
						} else {
							isDeclarationInstanceProperty := declaration.kind == SyntaxKindPropertyDeclaration && !isStatic(declaration)
							if !isDeclarationInstanceProperty || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getContainingClass(usage) !== getContainingClass(declaration) */ TODO {
								return true
							}
						}
					}
				}
				return false
			})
		}
		isPropertyImmediatelyReferencedWithinDeclaration := func(declaration /* TODO(UnionType): PropertyDeclaration | ParameterPropertyDeclaration */ any, usage Node, stopAtAnyPropertyDeclaration bool) /* TODO(undefined): boolean */ TODO {
			if usage.end > declaration.end {
				return false
			}
			ancestorChangingReferenceScope := findAncestor(usage, func(node Node) /* TODO(undefined): boolean | "quit" */ TODO {
				if node == declaration {
					return "quit"
				}
				/* TODO(SwitchStatement): switch (node.kind) {                     case SyntaxKind.ArrowFunction:                         return true;                     case SyntaxKind.PropertyDeclaration:                         // even when stopping at any property declaration, they need to come from the same class                         return stopAtAnyPropertyDeclaration &&                                 (isPropertyDeclaration(declaration) && node.parent === declaration.parent                                     || isParameterPropertyDeclaration(declaration, declaration.parent) && node.parent === declaration.parent.parent)                             ? "quit" : true;                     case SyntaxKind.Block:                         switch (node.parent.kind) {                             case SyntaxKind.GetAccessor:                             case SyntaxKind.MethodDeclaration:                             case SyntaxKind.SetAccessor:                                 return true;                             default:                                 return false;                         }                     default:                         return false;                 } */
			})
			return ancestorChangingReferenceScope == nil
		}
	}
	getRequiresScopeChangeCache := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		return getNodeLinks(node).declarationRequiresScopeChange
	}
	setRequiresScopeChangeCache := func(node FunctionLikeDeclaration, value bool) {
		getNodeLinks(node).declarationRequiresScopeChange = value
	}
	checkAndReportErrorForInvalidInitializer := func(errorLocation Node, name __String, propertyWithInvalidInitializer PropertyDeclaration, result *Symbol) /* TODO(undefined): boolean */ TODO {
		if !emitStandardClassFields {
			if errorLocation && !result && checkAndReportErrorForMissingPrefix(errorLocation, name, name) {
				return true
			}
			error(errorLocation /* TODO(ConditionalExpression): errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos)                     ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor                     : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor */, TODO, declarationNameToString(propertyWithInvalidInitializer.name), diagnosticName(name))
			return true
		}
		return false
	}
	onFailedToResolveSymbol := func(errorLocation Node, nameArg /* TODO(UnionType): __String | Identifier */ any, meaning SymbolFlags, nameNotFoundMessage DiagnosticMessage) {
		name := /* TODO(ConditionalExpression): isString(nameArg) ? nameArg : (nameArg as Identifier).escapedText */ TODO
		addLazyDiagnostic(func() {
			if !errorLocation || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorLocation.parent.kind !== SyntaxKind.JSDocLink */ TODO && !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) && !checkAndReportErrorForExtendingInterface(errorLocation) && !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) && !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) && !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
				var suggestion *Symbol
				var suggestedLib /* TODO(StringKeyword): string */ any
				if nameArg {
					suggestedLib = getSuggestedLibForNonExistentName(nameArg)
					if suggestedLib {
						error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib)
					}
				}
				if !suggestedLib && suggestionCount < maximumSuggestionCount {
					suggestion = getSuggestedSymbolForNonexistentSymbol(errorLocation, name, meaning)
					isGlobalScopeAugmentationDeclaration := suggestion.valueDeclaration && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration)
					if isGlobalScopeAugmentationDeclaration {
						suggestion = nil
					}
					if suggestion {
						suggestionName := symbolToString(suggestion)
						isUncheckedJS := isUncheckedJSSuggestion(errorLocation, suggestion, false)
						message := /* TODO(ConditionalExpression): meaning === SymbolFlags.Namespace ||                                 nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ?                             Diagnostics.Cannot_find_namespace_0_Did_you_mean_1                             : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1                             : Diagnostics.Cannot_find_name_0_Did_you_mean_1 */ TODO
						diagnostic := createError(errorLocation, message, diagnosticName(nameArg), suggestionName)
						diagnostic.canonicalHead = getCanonicalDiagnostic(nameNotFoundMessage, diagnosticName(nameArg))
						addErrorOrSuggestion(!isUncheckedJS, diagnostic)
						if suggestion.valueDeclaration {
							addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
						}
					}
				}
				if !suggestion && !suggestedLib && nameArg {
					error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg))
				}
				suggestionCount++
			}
		})
	}
	onSuccessfullyResolvedSymbol := func(errorLocation Node, result Symbol, meaning SymbolFlags, lastLocation Node, associatedDeclarationForContainingInitializerOrBindingName /* TODO(UnionType): ParameterDeclaration | BindingElement | undefined */ any, withinDeferredContext bool) {
		addLazyDiagnostic(func() {
			name := result.escapedName
			isInExternalModule := lastLocation && isSourceFile(lastLocation) && isExternalOrCommonJsModule(lastLocation)
			if errorLocation && (meaning&SymbolFlagsBlockScopedVariable || ((meaning&SymbolFlagsClass || meaning&SymbolFlagsEnum) && (meaning&SymbolFlagsValue) == SymbolFlagsValue)) {
				exportOrLocalSymbol := getExportSymbolOfValueSymbolIfExported(result)
				if exportOrLocalSymbol.flags&SymbolFlagsBlockScopedVariable || exportOrLocalSymbol.flags&SymbolFlagsClass || exportOrLocalSymbol.flags&SymbolFlagsEnum {
					checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation)
				}
			}
			if isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue && !( /* TODO(NonNullExpression): errorLocation! */ TODO.flags & NodeFlagsJSDoc) {
				merged := getMergedSymbol(result)
				if length(merged.declarations) && every(merged.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): isNamespaceExportDeclaration(d) */
					/* TODO(BarBarToken): || */
					/* TODO(BinaryExpression): isSourceFile(d) && !!d.symbol.globalExports */
				}) {
					errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess /* TODO(NonNullExpression): errorLocation! */, TODO, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name))
				}
			}
			if associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				candidate := getMergedSymbol(getLateBoundSymbol(result))
				root := getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName) /* as */ /* TODO(TypeReference): ParameterDeclaration */
				if candidate == getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName) {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name))
				} else if candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && getSymbol(root.parent.locals, candidate.escapedName, meaning) == candidate {
					error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation /* as */ /* TODO(TypeReference): Identifier */))
				}
			}
			if errorLocation && meaning&SymbolFlagsValue && result.flags&SymbolFlagsAlias && !(result.flags & SymbolFlagsValue) && !isValidTypeOnlyAliasUseSite(errorLocation) {
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(result, SymbolFlagsValue)
				if typeOnlyDeclaration {
					message := /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                         ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type                         : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type */ TODO
					unescapedName := unescapeLeadingUnderscores(name)
					addTypeOnlyDeclarationRelatedInfo(error(errorLocation, message, unescapedName), typeOnlyDeclaration, unescapedName)
				}
			}
			if compilerOptions.isolatedModules && result && isInExternalModule && (meaning&SymbolFlagsValue) == SymbolFlagsValue {
				isGlobal := getSymbol(globals, name, meaning) == result
				nonValueSymbol := isGlobal && isSourceFile(lastLocation) && lastLocation.locals && getSymbol(lastLocation.locals, name, ~SymbolFlagsValue)
				if nonValueSymbol {
					importDecl := nonValueSymbol.declarations.find(func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(BinaryExpression): d.kind === SyntaxKind.ImportSpecifier || d.kind === SyntaxKind.ImportClause || d.kind === SyntaxKind.NamespaceImport */
						/* TODO(BarBarToken): || */
						/* TODO(BinaryExpression): d.kind === SyntaxKind.ImportEqualsDeclaration */
					})
					if importDecl && !isTypeOnlyImportDeclaration(importDecl) {
						error(importDecl, Diagnostics.Import_0_conflicts_with_global_value_used_in_this_file_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, unescapeLeadingUnderscores(name))
					}
				}
			}
		})
	}
	addTypeOnlyDeclarationRelatedInfo := func(diagnostic Diagnostic, typeOnlyDeclaration *TypeOnlyCompatibleAliasDeclaration, unescapedName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
		if !typeOnlyDeclaration {
			/* TODO(Identifier): diagnostic */
		}
		return addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportSpecifier || typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration || typeOnlyDeclaration.kind === SyntaxKind.NamespaceExport                     ? Diagnostics._0_was_exported_here                     : Diagnostics._0_was_imported_here */, TODO, unescapedName))
	}
	diagnosticName := func(nameArg /* TODO(UnionType): __String | Identifier | PrivateIdentifier */ any) /* TODO(undefined): string */ TODO {
		return /* TODO(ConditionalExpression): isString(nameArg) ? unescapeLeadingUnderscores(nameArg as __String) : declarationNameToString(nameArg as Identifier) */ TODO
	}
	checkAndReportErrorForMissingPrefix := func(errorLocation Node, name __String, nameArg /* TODO(UnionType): __String | Identifier */ any) bool {
		if !isIdentifier(errorLocation) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorLocation.escapedText !== name */ TODO || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation) {
			return false
		}
		container := getThisContainer(errorLocation, false, false)
		var location Node = container
		/* TODO(WhileStatement): while (location) {             if (isClassLike(location.parent)) {                 const classSymbol = getSymbolOfDeclaration(location.parent);                 if (!classSymbol) {                     break;                 }                  // Check to see if a static member exists.                 const constructorType = getTypeOfSymbol(classSymbol);                 if (getPropertyOfType(constructorType, name)) {                     error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));                     return true;                 }                  // No static member is present.                 // Check if we're in an instance method and look for a relevant instance member.                 if (location === container && !isStatic(location)) {                     const instanceType = (getDeclaredTypeOfSymbol(classSymbol) as InterfaceType).thisType!; // TODO: GH#18217                     if (getPropertyOfType(instanceType, name)) {                         error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));                         return true;                     }                 }             }              location = location.parent;         } */
		return false
	}
	checkAndReportErrorForExtendingInterface := func(errorLocation Node) bool {
		expression := getEntityNameForExtendingInterface(errorLocation)
		if expression && resolveEntityName(expression, SymbolFlagsInterface, true) {
			error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression))
			return true
		}
		return false
	}
	getEntityNameForExtendingInterface := func(node Node) *EntityNameExpression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.PropertyAccessExpression:                 return node.parent ? getEntityNameForExtendingInterface(node.parent) : undefined;             case SyntaxKind.ExpressionWithTypeArguments:                 if (isEntityNameExpression((node as ExpressionWithTypeArguments).expression)) {                     return (node as ExpressionWithTypeArguments).expression as EntityNameExpression;                 }                 // falls through             default:                 return undefined;         } */
	}
	checkAndReportErrorForUsingTypeAsNamespace := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		namespaceMeaning := SymbolFlagsNamespace | ( /* TODO(ConditionalExpression): isInJSFile(errorLocation) ? SymbolFlags.Value : 0 */ TODO)
		if meaning == namespaceMeaning {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~namespaceMeaning, nil, false))
			parent := errorLocation.parent
			if symbol {
				if isQualifiedName(parent) {
					Debug.assert(parent.left == errorLocation, "Should only be resolving left side of qualified name as a namespace")
					propName := parent.right.escapedText
					propType := getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName)
					if propType {
						error(parent, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, unescapeLeadingUnderscores(name), unescapeLeadingUnderscores(propName))
						return true
					}
				}
				error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkAndReportErrorForUsingValueAsType := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsType & ~SymbolFlagsNamespace) {
			symbol := resolveSymbol(resolveName(errorLocation, name, ~SymbolFlagsType&SymbolFlagsValue, nil, false))
			if symbol && !(symbol.flags & SymbolFlagsNamespace) {
				error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	isPrimitiveTypeName := func(name __String) /* TODO(undefined): boolean */ TODO {
		return name == "any" || name == "string" || name == "number" || name == "boolean" || name == "never" || name == "unknown"
	}
	checkAndReportErrorForExportingPrimitiveType := func(errorLocation Node, name __String) bool {
		if isPrimitiveTypeName(name) && errorLocation.parent.kind == SyntaxKindExportSpecifier {
			error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name /* as */ /* TODO(StringKeyword): string */)
			return true
		}
		return false
	}
	checkAndReportErrorForUsingTypeAsValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & SymbolFlagsValue {
			if isPrimitiveTypeName(name) {
				grandparent := errorLocation.parent.parent
				if grandparent && grandparent.parent && isHeritageClause(grandparent) {
					heritageKind := grandparent.token
					containerKind := grandparent.parent.kind
					if containerKind == SyntaxKindInterfaceDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_It_can_only_extend_other_named_object_types, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindExtendsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_extend_a_primitive_type_like_0_Classes_can_only_extend_constructable_values, unescapeLeadingUnderscores(name))
					} else if containerKind == SyntaxKindClassDeclaration && heritageKind == SyntaxKindImplementsKeyword {
						error(errorLocation, Diagnostics.A_class_cannot_implement_a_primitive_type_like_0_It_can_only_implement_other_named_object_types, unescapeLeadingUnderscores(name))
					}
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name))
				}
				return true
			}
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsType&~SymbolFlagsValue, nil, false))
			allFlags := symbol && getSymbolFlags(symbol)
			if symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): allFlags !== undefined */ TODO && !(allFlags & SymbolFlagsValue) {
				rawName := unescapeLeadingUnderscores(name)
				if isES2015OrLaterConstructorName(name) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName)
				} else if maybeMappedType(errorLocation, symbol) {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName /* TODO(ConditionalExpression): rawName === "K" ? "P" : "K" */, TODO)
				} else {
					error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName)
				}
				return true
			}
		}
		return false
	}
	maybeMappedType := func(node Node, symbol Symbol) /* TODO(undefined): boolean */ TODO {
		container := findAncestor(node.parent, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(BinaryExpression): isComputedPropertyName(n) || isPropertySignature(n) */
			/* TODO(QuestionToken): ? */
			/* TODO(FalseKeyword): false */
			/* TODO(ColonToken): : */
			/* TODO(BinaryExpression): isTypeLiteralNode(n) || "quit" */
		}) /* as */ /* TODO(UnionType): TypeLiteralNode | undefined */
		if container && container.members.length == 1 {
			type_ := getDeclaredTypeOfSymbol(symbol)
			return !!(type_.flags & TypeFlagsUnion) && allTypesAssignableToKind(type_, TypeFlagsStringOrNumberLiteral, true)
		}
		return false
	}
	isES2015OrLaterConstructorName := func(n __String) /* TODO(undefined): boolean */ TODO {
		/* TODO(SwitchStatement): switch (n) {             case "Promise":             case "Symbol":             case "Map":             case "WeakMap":             case "Set":             case "WeakSet":                 return true;         } */
		return false
	}
	checkAndReportErrorForUsingNamespaceAsTypeOrValue := func(errorLocation Node, name __String, meaning SymbolFlags) bool {
		if meaning & (SymbolFlagsValue & ~SymbolFlagsType) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsNamespaceModule, nil, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_value, unescapeLeadingUnderscores(name))
				return true
			}
		} else if meaning & (SymbolFlagsType & ~SymbolFlagsValue) {
			symbol := resolveSymbol(resolveName(errorLocation, name, SymbolFlagsModule, nil, false))
			if symbol {
				error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name))
				return true
			}
		}
		return false
	}
	checkResolvedBlockScopedVariable := func(result Symbol, errorLocation Node) {
		Debug.assert(!!(result.flags&SymbolFlagsBlockScopedVariable || result.flags&SymbolFlagsClass || result.flags&SymbolFlagsEnum))
		if result.flags&(SymbolFlagsFunction|SymbolFlagsFunctionScopedVariable|SymbolFlagsAssignment) && result.flags&SymbolFlagsClass {
			return
		}
		declaration := result.declarations.find(func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): isBlockOrCatchScoped(d) || isClassLike(d) */
			/* TODO(BarBarToken): || */
			/* TODO(ParenthesizedExpression): (d.kind === SyntaxKind.EnumDeclaration) */
		})
		if declaration == nil {
			/* TODO(CallExpression): Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration") */
		}
		if !(declaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation) {
			var diagnosticMessage TODO
			declarationName := declarationNameToString(getNameOfDeclaration(declaration))
			if result.flags & SymbolFlagsBlockScopedVariable {
				diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsClass {
				diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName)
			} else if result.flags & SymbolFlagsRegularEnum {
				diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
			} else {
				Debug.assert(!!(result.flags & SymbolFlagsConstEnum))
				if getIsolatedModules(compilerOptions) {
					diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName)
				}
			}
			if diagnosticMessage {
				addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName))
			}
		}
	}
	isSameScopeDescendentOf := func(initial Node, parent Node, stopAt Node) bool {
		return !!parent && !!findAncestor(initial, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(BinaryExpression): n === parent */
			/* TODO(BarBarToken): || */
			/* TODO(ParenthesizedExpression): (n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || (getFunctionFlags(n) & FunctionFlags.AsyncGenerator)) ? "quit" : false) */
		})
	}
	getAnyImportSyntax := func(node Node) *AnyImportOrJsDocImport {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:                 return node as ImportEqualsDeclaration;             case SyntaxKind.ImportClause:                 return (node as ImportClause).parent;             case SyntaxKind.NamespaceImport:                 return (node as NamespaceImport).parent.parent;             case SyntaxKind.ImportSpecifier:                 return (node as ImportSpecifier).parent.parent.parent;             default:                 return undefined;         } */
	}
	getDeclarationOfAliasSymbol := func(symbol Symbol) Declaration {
		return symbol.declarations && findLast(symbol.declarations, isAliasSymbolDeclaration)
	}
	isAliasSymbolDeclaration := func(node Node) bool {
		return node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindNamespaceExportDeclaration || node.kind == SyntaxKindImportClause && !!(node /* as */ /* TODO(TypeReference): ImportClause */).name || node.kind == SyntaxKindNamespaceImport || node.kind == SyntaxKindNamespaceExport || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindExportSpecifier || node.kind == SyntaxKindExportAssignment && exportAssignmentIsAlias(node /* as */ /* TODO(TypeReference): ExportAssignment */) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) == AssignmentDeclarationKindModuleExports && exportAssignmentIsAlias(node) || isAccessExpression(node) && isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken && isAliasableOrJsExpression(node.parent.right) || node.kind == SyntaxKindShorthandPropertyAssignment || node.kind == SyntaxKindPropertyAssignment && isAliasableOrJsExpression((node /* as */ /* TODO(TypeReference): PropertyAssignment */).initializer) || node.kind == SyntaxKindVariableDeclaration && isVariableDeclarationInitializedToBareOrAccessedRequire(node) || node.kind == SyntaxKindBindingElement && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent)
	}
	isAliasableOrJsExpression := func(e Expression) /* TODO(undefined): boolean */ TODO {
		return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e)
	}
	getTargetOfImportEqualsDeclaration := func(node /* TODO(UnionType): ImportEqualsDeclaration | VariableDeclaration */ any, dontResolveAlias bool) *Symbol {
		commonJSPropertyAccess := getCommonJSPropertyAccess(node)
		if commonJSPropertyAccess {
			name := /* TODO(ElementAccessExpression): (getLeftmostAccessExpression(commonJSPropertyAccess.expression) as CallExpression).arguments[0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */
			return /* TODO(ConditionalExpression): isIdentifier(commonJSPropertyAccess.name)                 ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText))                 : undefined */ TODO
		}
		if isVariableDeclaration(node) || node.moduleReference.kind == SyntaxKindExternalModuleReference {
			immediate := resolveExternalModuleName(node, getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node))
			resolved := resolveExternalModuleSymbol(immediate)
			markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
			return resolved
		}
		resolved := getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias)
		checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved)
		return resolved
	}
	checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol := func(node ImportEqualsDeclaration, resolved *Symbol) {
		if markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false) && !node.isTypeOnly {
			typeOnlyDeclaration := /* TODO(NonNullExpression): getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node))! */ TODO
			isExport := typeOnlyDeclaration.kind == SyntaxKindExportSpecifier || typeOnlyDeclaration.kind == SyntaxKindExportDeclaration
			message := /* TODO(ConditionalExpression): isExport                 ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type                 : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type */ TODO
			relatedMessage := /* TODO(ConditionalExpression): isExport                 ? Diagnostics._0_was_exported_here                 : Diagnostics._0_was_imported_here */ TODO
			name := /* TODO(ConditionalExpression): typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration ? "*" : moduleExportNameTextUnescaped(typeOnlyDeclaration.name) */ TODO
			addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name))
		}
	}
	resolveExportByName := func(moduleSymbol Symbol, name __String, sourceNode *TypeOnlyCompatibleAliasDeclaration, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		exportValue := /* TODO(NonNullExpression): moduleSymbol.exports! */ TODO.get(InternalSymbolNameExportEquals)
		exportSymbol := /* TODO(ConditionalExpression): exportValue             ? getPropertyOfType(getTypeOfSymbol(exportValue), name, /*skipObjectFunctionPropertyAugment* / true)             : moduleSymbol.exports!.get(name) */ TODO
		resolved := resolveSymbol(exportSymbol, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, false)
		return resolved
	}
	isSyntacticDefault := func(node Node) /* TODO(undefined): boolean */ TODO {
		return ((isExportAssignment(node) && !node.isExportEquals) || hasSyntacticModifier(node, ModifierFlagsDefault) || isExportSpecifier(node) || isNamespaceExport(node))
	}
	getEmitSyntaxForModuleSpecifierExpression := func(usage Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolutionMode */ TODO {
		return /* TODO(ConditionalExpression): isStringLiteralLike(usage) ? host.getEmitSyntaxForUsageLocation(getSourceFileOfNode(usage), usage) : undefined */ TODO
	}
	isESMFormatImportImportingCommonjsFormatFile := func(usageMode ResolutionMode, targetMode ResolutionMode) /* TODO(undefined): boolean */ TODO {
		return usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS
	}
	isOnlyImportableAsDefault := func(usage Expression) /* TODO(undefined): boolean */ TODO {
		if ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
			usageMode := getEmitSyntaxForModuleSpecifierExpression(usage)
			return usageMode == ModuleKindESNext && endsWith((usage /* as */ /* TODO(TypeReference): StringLiteralLike */).text, ExtensionJson)
		}
		return false
	}
	canHaveSyntheticDefault := func(file *SourceFile, moduleSymbol Symbol, dontResolveAlias bool, usage Expression) /* TODO(undefined): boolean */ TODO {
		usageMode := file && getEmitSyntaxForModuleSpecifierExpression(usage)
		if file && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): usageMode !== undefined */ TODO {
			targetMode := host.getImpliedNodeFormatForEmit(file)
			if usageMode == ModuleKindESNext && targetMode == ModuleKindCommonJS && ModuleKindNode16 <= moduleKind && moduleKind <= ModuleKindNodeNext {
				return true
			}
			if usageMode == ModuleKindESNext && targetMode == ModuleKindESNext {
				return false
			}
		}
		if !allowSyntheticDefaultImports {
			return false
		}
		if !file || file.isDeclarationFile {
			defaultExportSymbol := resolveExportByName(moduleSymbol, InternalSymbolNameDefault, nil, true)
			if defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault) {
				return false
			}
			if resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias) {
				return false
			}
			return true
		}
		if !isSourceFileJS(file) {
			return hasExportAssignmentSymbol(moduleSymbol)
		}
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeof file.externalModuleIndicator !== "object" */ TODO && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), nil, dontResolveAlias)
	}
	getTargetOfImportClause := func(node ImportClause, dontResolveAlias bool) *Symbol {
		moduleSymbol := resolveExternalModuleName(node, node.parent.moduleSpecifier)
		if moduleSymbol {
			return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
		}
	}
	getTargetofModuleDefault := func(moduleSymbol Symbol, node /* TODO(UnionType): ImportClause | ImportOrExportSpecifier */ any, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var exportDefaultSymbol *Symbol
		if isShorthandAmbientModuleSymbol(moduleSymbol) {
			exportDefaultSymbol = moduleSymbol
		} else {
			exportDefaultSymbol = resolveExportByName(moduleSymbol, InternalSymbolNameDefault, node, dontResolveAlias)
		}
		file := moduleSymbol.declarations.find(isSourceFile)
		specifier := getModuleSpecifierForImportOrExport(node)
		if !specifier {
			return exportDefaultSymbol
		}
		hasDefaultOnly := isOnlyImportableAsDefault(specifier)
		hasSyntheticDefault := canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier)
		if !exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly {
			if hasExportAssignmentSymbol(moduleSymbol) && !allowSyntheticDefaultImports {
				compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015 ? "allowSyntheticDefaultImports" : "esModuleInterop" */ TODO
				exportEqualsSymbol := /* TODO(NonNullExpression): moduleSymbol.exports! */ TODO.get(InternalSymbolNameExportEquals)
				exportAssignment := /* TODO(NonNullExpression): exportEqualsSymbol! */ TODO.valueDeclaration
				err := error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName)
				if exportAssignment {
					addRelatedInfo(err, createDiagnosticForNode(exportAssignment, Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName))
				}
			} else if isImportClause(node) {
				reportNonDefaultExport(moduleSymbol, node)
			} else {
				errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name)
			}
		} else if hasSyntheticDefault || hasDefaultOnly {
			resolved := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, false)
			return resolved
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, nil, false)
		return exportDefaultSymbol
	}
	getModuleSpecifierForImportOrExport := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportOrExportSpecifier */ any) *Expression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportClause:                 return node.parent.moduleSpecifier;             case SyntaxKind.ImportEqualsDeclaration:                 return isExternalModuleReference(node.moduleReference) ? node.moduleReference.expression : undefined;             case SyntaxKind.NamespaceImport:                 return node.parent.parent.moduleSpecifier;             case SyntaxKind.ImportSpecifier:                 return node.parent.parent.parent.moduleSpecifier;             case SyntaxKind.ExportSpecifier:                 return node.parent.parent.moduleSpecifier;             default:                 return Debug.assertNever(node);         } */
	}
	reportNonDefaultExport := func(moduleSymbol Symbol, node ImportClause) {
		if moduleSymbol.exports.has(node.symbol.escapedName) {
			error(node.name, Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, symbolToString(moduleSymbol), symbolToString(node.symbol))
		} else {
			diagnostic := error(node.name, Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol))
			exportStar := moduleSymbol.exports.get(InternalSymbolNameExportStar)
			if exportStar {
				defaultExport := exportStar.declarations.find(func(decl /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !(                         isExportDeclaration(decl) && decl.moduleSpecifier &&                         resolveExternalModuleName(decl, decl.moduleSpecifier)?.exports?.has(InternalSymbolName.Default)                     ) */
				})
				if defaultExport {
					addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default))
				}
			}
		}
	}
	getTargetOfNamespaceImport := func(node NamespaceImport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := node.parent.parent.moduleSpecifier
		immediate := resolveExternalModuleName(node, moduleSpecifier)
		resolved := resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
		return resolved
	}
	getTargetOfNamespaceExport := func(node NamespaceExport, dontResolveAlias bool) *Symbol {
		moduleSpecifier := node.parent.moduleSpecifier
		immediate := moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier)
		resolved := moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false)
		markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false)
		return resolved
	}
	combineValueAndTypeSymbols := func(valueSymbol Symbol, typeSymbol Symbol) Symbol {
		if valueSymbol == unknownSymbol && typeSymbol == unknownSymbol {
			return unknownSymbol
		}
		if valueSymbol.flags & (SymbolFlagsType | SymbolFlagsNamespace) {
			return valueSymbol
		}
		result := createSymbol(valueSymbol.flags|typeSymbol.flags, valueSymbol.escapedName)
		Debug.assert(valueSymbol.declarations || typeSymbol.declarations)
		result.declarations = deduplicate(concatenate( /* TODO(NonNullExpression): valueSymbol.declarations! */ TODO, typeSymbol.declarations), equateValues)
		result.parent = valueSymbol.parent || typeSymbol.parent
		if valueSymbol.valueDeclaration {
			/* TODO(BinaryExpression): result.valueDeclaration = valueSymbol.valueDeclaration */
		}
		if typeSymbol.members {
			/* TODO(BinaryExpression): result.members = new Map(typeSymbol.members) */
		}
		if valueSymbol.exports {
			/* TODO(BinaryExpression): result.exports = new Map(valueSymbol.exports) */
		}
		return result
	}
	getExportOfModule := func(symbol Symbol, nameText __String, specifier Declaration, dontResolveAlias bool) *Symbol {
		if symbol.flags & SymbolFlagsModule {
			exportSymbol := getExportsOfSymbol(symbol).get(nameText)
			resolved := resolveSymbol(exportSymbol, dontResolveAlias)
			exportStarDeclaration := getSymbolLinks(symbol).typeOnlyExportStarMap.get(nameText)
			markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, false, exportStarDeclaration, nameText)
			return resolved
		}
	}
	getPropertyOfVariable := func(symbol Symbol, name __String) *Symbol {
		if symbol.flags & SymbolFlagsVariable {
			typeAnnotation := (symbol.valueDeclaration /* as */ /* TODO(TypeReference): VariableDeclaration */).type_
			if typeAnnotation {
				return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name))
			}
		}
	}
	getExternalModuleMember := func(node /* TODO(UnionType): ImportDeclaration | ExportDeclaration | VariableDeclaration | JSDocImportTag */ any, specifier /* TODO(UnionType): ImportOrExportSpecifier | BindingElement | PropertyAccessExpression */ any, dontResolveAlias /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		moduleSpecifier := getExternalModuleRequireArgument(node) || /* TODO(NonNullExpression): (node as ImportDeclaration | ExportDeclaration | JSDocImportTag).moduleSpecifier! */ TODO
		moduleSymbol := /* TODO(NonNullExpression): resolveExternalModuleName(node, moduleSpecifier)! */ TODO
		name := !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name
		if !isIdentifier(name) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name.kind !== SyntaxKind.StringLiteral */ TODO {
			return nil
		}
		nameText := moduleExportNameTextEscaped(name)
		suppressInteropError := nameText == InternalSymbolNameDefault && allowSyntheticDefaultImports
		targetSymbol := resolveESModuleSymbol(moduleSymbol, moduleSpecifier, false, suppressInteropError)
		if targetSymbol {
			if nameText || name.kind == SyntaxKindStringLiteral {
				if isShorthandAmbientModuleSymbol(moduleSymbol) {
					return moduleSymbol
				}
				var symbolFromVariable *Symbol
				if moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get(InternalSymbolNameExportEquals) {
					symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), nameText, true)
				} else {
					symbolFromVariable = getPropertyOfVariable(targetSymbol, nameText)
				}
				symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias)
				symbolFromModule := getExportOfModule(targetSymbol, nameText, specifier, dontResolveAlias)
				if symbolFromModule == nil && nameText == InternalSymbolNameDefault {
					file := moduleSymbol.declarations.find(isSourceFile)
					if isOnlyImportableAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier) {
						symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias)
					}
				}
				symbol := /* TODO(ConditionalExpression): symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ?                     combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) :                     symbolFromModule || symbolFromVariable */ TODO
				if !symbol {
					errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name)
				}
				return symbol
			}
		}
	}
	errorNoModuleMemberSymbol := func(moduleSymbol Symbol, targetSymbol Symbol, node Node, name ModuleExportName) {
		moduleName := getFullyQualifiedName(moduleSymbol, node)
		declarationName := declarationNameToString(name)
		suggestion := /* TODO(ConditionalExpression): isIdentifier(name) ? getSuggestedSymbolForNonexistentModule(name, targetSymbol) : undefined */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
			suggestionName := symbolToString(suggestion)
			diagnostic := error(name, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName)
			if suggestion.valueDeclaration {
				addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName))
			}
		} else {
			if moduleSymbol.exports.has(InternalSymbolNameDefault) {
				error(name, Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName)
			} else {
				reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName)
			}
		}
	}
	reportNonExportedMember := func(node Node, name ModuleExportName, declarationName string, moduleSymbol Symbol, moduleName string) {
		localSymbol := tryCast(moduleSymbol.valueDeclaration, canHaveLocals).locals.get(moduleExportNameTextEscaped(name))
		exports := moduleSymbol.exports
		if localSymbol {
			exportedEqualsSymbol := exports.get(InternalSymbolNameExportEquals)
			if exportedEqualsSymbol {
				/* TODO(ExpressionStatement): getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) :                     error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName); */
			} else {
				exportedSymbol := /* TODO(ConditionalExpression): exports ? find(symbolsToArray(exports), symbol => !!getSymbolIfSameReference(symbol, localSymbol)) : undefined */ TODO
				diagnostic := /* TODO(ConditionalExpression): exportedSymbol ? error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) :                     error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName) */ TODO
				if localSymbol.declarations {
					addRelatedInfo(diagnostic /* TODO(SpreadElement): ...map(localSymbol.declarations, (decl, index) => createDiagnosticForNode(decl, index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here, declarationName)) */, TODO)
				}
			}
		} else {
			error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName)
		}
	}
	reportInvalidImportEqualsExportMember := func(node Node, name ModuleExportName, declarationName string, moduleName string) {
		if moduleKind >= ModuleKindES2015 {
			message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import :                 Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
			error(name, message, declarationName)
		} else {
			if isInJSFile(node) {
				message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName)
			} else {
				message := /* TODO(ConditionalExpression): getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import :                     Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import */ TODO
				error(name, message, declarationName, declarationName, moduleName)
			}
		}
	}
	getTargetOfImportSpecifier := func(node /* TODO(UnionType): ImportSpecifier | BindingElement */ any, dontResolveAlias bool) *Symbol {
		if isImportSpecifier(node) && moduleExportNameIsDefault(node.propertyName || node.name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias)
			}
		}
		root := /* TODO(ConditionalExpression): isBindingElement(node) ? getRootDeclaration(node) as VariableDeclaration : node.parent.parent.parent */ TODO
		commonJSPropertyAccess := getCommonJSPropertyAccess(root)
		resolved := getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias)
		name := node.propertyName || node.name
		if commonJSPropertyAccess && resolved && isIdentifier(name) {
			return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias)
		}
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getCommonJSPropertyAccess := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAccessExpression | undefined */ TODO {
		if isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer) {
			return node.initializer
		}
	}
	getTargetOfNamespaceExportDeclaration := func(node NamespaceExportDeclaration, dontResolveAlias bool) *Symbol {
		if canHaveSymbol(node.parent) {
			resolved := resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias)
			markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
			return resolved
		}
	}
	getTargetOfExportSpecifier := func(node ExportSpecifier, meaning SymbolFlags, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		name := node.propertyName || node.name
		if moduleExportNameIsDefault(name) {
			specifier := getModuleSpecifierForImportOrExport(node)
			moduleSymbol := specifier && resolveExternalModuleName(node, specifier)
			if moduleSymbol {
				return getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias)
			}
		}
		resolved := /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?             getExternalModuleMember(node.parent.parent, node, dontResolveAlias) :             name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }             resolveEntityName(name, meaning, /*ignoreErrors* / false, dontResolveAlias) */ TODO
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getTargetOfExportAssignment := func(node /* TODO(UnionType): ExportAssignment | BinaryExpression */ any, dontResolveAlias bool) *Symbol {
		expression := /* TODO(ConditionalExpression): isExportAssignment(node) ? node.expression : node.right */ TODO
		resolved := getTargetOfAliasLikeExpression(expression, dontResolveAlias)
		markSymbolOfAliasDeclarationIfTypeOnly(node, nil, resolved, false)
		return resolved
	}
	getTargetOfAliasLikeExpression := func(expression Expression, dontResolveAlias bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isClassExpression(expression) {
			return checkExpressionCached(expression).symbol
		}
		if !isEntityName(expression) && !isEntityNameExpression(expression) {
			return nil
		}
		aliasLike := resolveEntityName(expression, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, true, dontResolveAlias)
		if aliasLike {
			return aliasLike
		}
		checkExpressionCached(expression)
		return getNodeLinks(expression).resolvedSymbol
	}
	getTargetOfAccessExpression := func(node AccessExpression, dontRecursivelyResolve bool) *Symbol {
		if !(isBinaryExpression(node.parent) && node.parent.left == node && node.parent.operatorToken.kind == SyntaxKindEqualsToken) {
			return nil
		}
		return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve)
	}
	getTargetOfAliasDeclaration := func(node Declaration, dontRecursivelyResolve /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:             case SyntaxKind.VariableDeclaration:                 return getTargetOfImportEqualsDeclaration(node as ImportEqualsDeclaration | VariableDeclaration, dontRecursivelyResolve);             case SyntaxKind.ImportClause:                 return getTargetOfImportClause(node as ImportClause, dontRecursivelyResolve);             case SyntaxKind.NamespaceImport:                 return getTargetOfNamespaceImport(node as NamespaceImport, dontRecursivelyResolve);             case SyntaxKind.NamespaceExport:                 return getTargetOfNamespaceExport(node as NamespaceExport, dontRecursivelyResolve);             case SyntaxKind.ImportSpecifier:             case SyntaxKind.BindingElement:                 return getTargetOfImportSpecifier(node as ImportSpecifier | BindingElement, dontRecursivelyResolve);             case SyntaxKind.ExportSpecifier:                 return getTargetOfExportSpecifier(node as ExportSpecifier, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, dontRecursivelyResolve);             case SyntaxKind.ExportAssignment:             case SyntaxKind.BinaryExpression:                 return getTargetOfExportAssignment(node as ExportAssignment | BinaryExpression, dontRecursivelyResolve);             case SyntaxKind.NamespaceExportDeclaration:                 return getTargetOfNamespaceExportDeclaration(node as NamespaceExportDeclaration, dontRecursivelyResolve);             case SyntaxKind.ShorthandPropertyAssignment:                 return resolveEntityName((node as ShorthandPropertyAssignment).name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace, /*ignoreErrors* / true, dontRecursivelyResolve);             case SyntaxKind.PropertyAssignment:                 return getTargetOfAliasLikeExpression((node as PropertyAssignment).initializer, dontRecursivelyResolve);             case SyntaxKind.ElementAccessExpression:             case SyntaxKind.PropertyAccessExpression:                 return getTargetOfAccessExpression(node as AccessExpression, dontRecursivelyResolve);             default:                 return Debug.fail();         } */
	}
	isNonLocalAlias := func(symbol *Symbol, excludes /* TODO(undefined): number */ TODO /* = */ /* TODO(BinaryExpression): SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace */) /* TODO(TypePredicate): symbol is Symbol */ TODO {
		if !symbol {
			/* TODO(FalseKeyword): false */
		}
		return (symbol.flags&(SymbolFlagsAlias|excludes)) == SymbolFlagsAlias || !!(symbol.flags&SymbolFlagsAlias && symbol.flags&SymbolFlagsAssignment)
	}
	// OVERLOAD: resolveSymbol := func(symbol Symbol, dontResolveAlias bool) Symbol
	// OVERLOAD: resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol
	resolveSymbol := func(symbol *Symbol, dontResolveAlias bool) *Symbol {
		return /* TODO(ConditionalExpression): !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol */ TODO
	}
	resolveAlias := func(symbol Symbol) Symbol {
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.Alias) !== 0 */ TODO, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.aliasTarget {
			links.aliasTarget = resolvingSymbol
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				/* TODO(CallExpression): Debug.fail() */
			}
			target := getTargetOfAliasDeclaration(node)
			if links.aliasTarget == resolvingSymbol {
				links.aliasTarget = target || unknownSymbol
			} else {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		} else if links.aliasTarget == resolvingSymbol {
			links.aliasTarget = unknownSymbol
		}
		return links.aliasTarget
	}
	tryResolveAlias := func(symbol Symbol) *Symbol {
		links := getSymbolLinks(symbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): links.aliasTarget !== resolvingSymbol */ TODO {
			return resolveAlias(symbol)
		}
		return nil
	}
	getSymbolFlags := func(symbol Symbol, excludeTypeOnlyMeanings bool, excludeLocalMeanings bool) SymbolFlags {
		typeOnlyDeclaration := excludeTypeOnlyMeanings && getTypeOnlyAliasDeclaration(symbol)
		typeOnlyDeclarationIsExportStar := typeOnlyDeclaration && isExportDeclaration(typeOnlyDeclaration)
		typeOnlyResolution := typeOnlyDeclaration && ( /* TODO(ConditionalExpression): typeOnlyDeclarationIsExportStar                 ? resolveExternalModuleName(typeOnlyDeclaration.moduleSpecifier, typeOnlyDeclaration.moduleSpecifier, /*ignoreErrors* / true)                 : resolveAlias(typeOnlyDeclaration.symbol) */ TODO)
		typeOnlyExportStarTargets := /* TODO(ConditionalExpression): typeOnlyDeclarationIsExportStar && typeOnlyResolution ? getExportsOfModule(typeOnlyResolution) : undefined */ TODO
		flags := /* TODO(ConditionalExpression): excludeLocalMeanings ? SymbolFlags.None : symbol.flags */ TODO
		var seenSymbols TODO
		/* TODO(WhileStatement): while (symbol.flags & SymbolFlags.Alias) {             const target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));             if (                 !typeOnlyDeclarationIsExportStar && target === typeOnlyResolution ||                 typeOnlyExportStarTargets?.get(target.escapedName) === target             ) {                 break;             }             if (target === unknownSymbol) {                 return SymbolFlags.All;             }              // Optimizations - try to avoid creating or adding to             // `seenSymbols` if possible             if (target === symbol || seenSymbols?.has(target)) {                 break;             }             if (target.flags & SymbolFlags.Alias) {                 if (seenSymbols) {                     seenSymbols.add(target);                 }                 else {                     seenSymbols = new Set([symbol, target]);                 }             }             flags |= target.flags;             symbol = target;         } */
		return flags
	}
	markSymbolOfAliasDeclarationIfTypeOnly := func(aliasDeclaration Declaration, immediateTarget *Symbol, finalTarget *Symbol, overwriteEmpty bool, exportStarDeclaration /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */ TODO, exportStarName __String) bool {
		if !aliasDeclaration || isPropertyAccessExpression(aliasDeclaration) {
			/* TODO(FalseKeyword): false */
		}
		sourceSymbol := getSymbolOfDeclaration(aliasDeclaration)
		if isTypeOnlyImportOrExportDeclaration(aliasDeclaration) {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = aliasDeclaration
			return true
		}
		if exportStarDeclaration {
			links := getSymbolLinks(sourceSymbol)
			links.typeOnlyDeclaration = exportStarDeclaration
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSymbol.escapedName !== exportStarName */ TODO {
				links.typeOnlyExportStarName = exportStarName
			}
			return true
		}
		links := getSymbolLinks(sourceSymbol)
		return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty)
	}
	markSymbolOfAliasDeclarationIfTypeOnlyWorker := func(aliasDeclarationLinks SymbolLinks, target *Symbol, overwriteEmpty bool) bool {
		if target && (aliasDeclarationLinks.typeOnlyDeclaration == nil || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration == false) {
			exportSymbol := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): target.exports?.get(InternalSymbolName.ExportEquals) ?? target */ TODO
			typeOnly := exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration)
			aliasDeclarationLinks.typeOnlyDeclaration = /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): typeOnly ?? getSymbolLinks(exportSymbol).typeOnlyDeclaration ?? false */ TODO
		}
		return !!aliasDeclarationLinks.typeOnlyDeclaration
	}
	getTypeOnlyAliasDeclaration := func(symbol Symbol, include SymbolFlags) *TypeOnlyAliasDeclaration {
		if !(symbol.flags & SymbolFlagsAlias) {
			return nil
		}
		links := getSymbolLinks(symbol)
		if links.typeOnlyDeclaration == nil {
			links.typeOnlyDeclaration = false
			resolved := resolveSymbol(symbol)
			markSymbolOfAliasDeclarationIfTypeOnly( /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO, getDeclarationOfAliasSymbol(symbol) && getImmediateAliasedSymbol(symbol), resolved, true)
		}
		if include == nil {
			return links.typeOnlyDeclaration || nil
		}
		if links.typeOnlyDeclaration {
			resolved := /* TODO(ConditionalExpression): links.typeOnlyDeclaration.kind === SyntaxKind.ExportDeclaration                 ? resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent!).get(links.typeOnlyExportStarName || symbol.escapedName))!                 : resolveAlias(links.typeOnlyDeclaration.symbol) */ TODO
			return /* TODO(ConditionalExpression): getSymbolFlags(resolved) & include ? links.typeOnlyDeclaration : undefined */ TODO
		}
		return nil
	}
	getSymbolOfPartOfRightHandSideOfImportEquals := func(entityName EntityName, dontResolveAlias bool) *Symbol {
		if entityName.kind == SyntaxKindIdentifier && isRightSideOfQualifiedNameOrPropertyAccess(entityName) {
			entityName = entityName.parent /* as */ /* TODO(TypeReference): QualifiedName */
		}
		if entityName.kind == SyntaxKindIdentifier || entityName.parent.kind == SyntaxKindQualifiedName {
			return resolveEntityName(entityName, SymbolFlagsNamespace, false, dontResolveAlias)
		} else {
			Debug.assert(entityName.parent.kind == SyntaxKindImportEqualsDeclaration)
			return resolveEntityName(entityName, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, false, dontResolveAlias)
		}
	}
	getFullyQualifiedName := func(symbol Symbol, containingLocation Node) string {
		return /* TODO(ConditionalExpression): symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, /*meaning* / undefined, SymbolFormatFlags.DoNotIncludeSymbolChain | SymbolFormatFlags.AllowAnyNodeKind) */ TODO
	}
	getContainingQualifiedNameNode := func(node QualifiedName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").QualifiedName */ TODO {
		/* TODO(WhileStatement): while (isQualifiedName(node.parent)) {             node = node.parent;         } */
		return node
	}
	tryGetQualifiedNameAsValue := func(node QualifiedName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var left /* TODO(UnionType): Identifier | QualifiedName */ any = getFirstIdentifier(node)
		symbol := resolveName(left, left, SymbolFlagsValue, nil, true)
		if !symbol {
			return nil
		}
		/* TODO(WhileStatement): while (isQualifiedName(left.parent)) {             const type = getTypeOfSymbol(symbol);             symbol = getPropertyOfType(type, left.parent.right.escapedText);             if (!symbol) {                 return undefined;             }             left = left.parent;         } */
		return symbol
	}
	resolveEntityName := func(name EntityNameOrEntityNameExpression, meaning SymbolFlags, ignoreErrors bool, dontResolveAlias bool, location Node) *Symbol {
		if nodeIsMissing(name) {
			return nil
		}
		namespaceMeaning := SymbolFlagsNamespace | ( /* TODO(ConditionalExpression): isInJSFile(name) ? meaning & SymbolFlags.Value : 0 */ TODO)
		var symbol *Symbol
		if name.kind == SyntaxKindIdentifier {
			message := /* TODO(ConditionalExpression): meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name)) */ TODO
			symbolFromJSPrototype := /* TODO(ConditionalExpression): isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : undefined */ TODO
			symbol = getMergedSymbol(resolveName(location || name, name, meaning /* TODO(ConditionalExpression): ignoreErrors || symbolFromJSPrototype ? undefined : message */, TODO, true, false))
			if !symbol {
				return getMergedSymbol(symbolFromJSPrototype)
			}
		} else if name.kind == SyntaxKindQualifiedName || name.kind == SyntaxKindPropertyAccessExpression {
			left := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.left : name.expression */ TODO
			right := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right : name.name */ TODO
			namespace := resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location)
			if !namespace || nodeIsMissing(right) {
				return nil
			} else if namespace == unknownSymbol {
				return namespace
			}
			if namespace.valueDeclaration && isInJSFile(namespace.valueDeclaration) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Bundler */ TODO && isVariableDeclaration(namespace.valueDeclaration) && namespace.valueDeclaration.initializer && isCommonJsRequire(namespace.valueDeclaration.initializer) {
				moduleName := /* TODO(ElementAccessExpression): (namespace.valueDeclaration.initializer as CallExpression).arguments[0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */
				moduleSym := resolveExternalModuleName(moduleName, moduleName)
				if moduleSym {
					resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
					if resolvedModuleSymbol {
						namespace = resolvedModuleSymbol
					}
				}
			}
			symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, meaning))
			if !symbol && (namespace.flags & SymbolFlagsAlias) {
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(resolveAlias(namespace)), right.escapedText, meaning))
			}
			if !symbol {
				if !ignoreErrors {
					namespaceName := getFullyQualifiedName(namespace)
					declarationName := declarationNameToString(right)
					suggestionForNonexistentModule := getSuggestedSymbolForNonexistentModule(right, namespace)
					if suggestionForNonexistentModule {
						error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule))
						return nil
					}
					containingQualifiedName := isQualifiedName(name) && getContainingQualifiedNameNode(name)
					canSuggestTypeof := globalObjectType && (meaning & SymbolFlagsType) && containingQualifiedName && !isTypeOfExpression(containingQualifiedName.parent) && tryGetQualifiedNameAsValue(containingQualifiedName)
					if canSuggestTypeof {
						error(containingQualifiedName, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, entityNameToString(containingQualifiedName))
						return nil
					}
					if meaning&SymbolFlagsNamespace && isQualifiedName(name.parent) {
						exportedTypeSymbol := getMergedSymbol(getSymbol(getExportsOfSymbol(namespace), right.escapedText, SymbolFlagsType))
						if exportedTypeSymbol {
							error(name.parent.right, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores(name.parent.right.escapedText))
							return nil
						}
					}
					error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName)
				}
				return nil
			}
		} else {
			Debug.assertNever(name, "Unknown entity name kind.")
		}
		if !nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags&SymbolFlagsAlias || name.parent.kind == SyntaxKindExportAssignment) {
			markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, nil, true)
		}
		return /* TODO(ConditionalExpression): (symbol.flags & meaning) || dontResolveAlias ? symbol : resolveAlias(symbol) */ TODO
	}
	resolveEntityNameFromAssignmentDeclaration := func(name Identifier, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isJSDocTypeReference(name.parent) {
			secondaryLocation := getAssignmentDeclarationLocation(name.parent)
			if secondaryLocation {
				return resolveName(secondaryLocation, name, meaning, nil, true)
			}
		}
	}
	getAssignmentDeclarationLocation := func(node TypeReferenceNode) Node {
		typeAlias := findAncestor(node, func(node /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(PrefixUnaryExpression): !(isJSDocNode(node) || node.flags & NodeFlags.JSDoc) */
			/* TODO(QuestionToken): ? */
			/* TODO(StringLiteral): "quit" */
			/* TODO(ColonToken): : */
			/* TODO(CallExpression): isJSDocTypeAlias(node) */
		})
		if typeAlias {
			return
		}
		host := getJSDocHost(node)
		if host && isExpressionStatement(host) && isPrototypePropertyAssignment(host.expression) {
			symbol := getSymbolOfDeclaration(host.expression.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && isFunctionExpression(host) && isPrototypePropertyAssignment(host.parent) && isExpressionStatement(host.parent.parent) {
			symbol := getSymbolOfDeclaration(host.parent.left)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		if host && (isObjectLiteralMethod(host) || isPropertyAssignment(host)) && isBinaryExpression(host.parent.parent) && getAssignmentDeclarationKind(host.parent.parent) == AssignmentDeclarationKindPrototype {
			symbol := getSymbolOfDeclaration(host.parent.parent.left /* as */ /* TODO(TypeReference): BindableStaticNameExpression */)
			if symbol {
				return getDeclarationOfJSPrototypeContainer(symbol)
			}
		}
		sig := getEffectiveJSDocHost(node)
		if sig && isFunctionLike(sig) {
			symbol := getSymbolOfDeclaration(sig)
			return symbol && symbol.valueDeclaration
		}
	}
	getDeclarationOfJSPrototypeContainer := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
		decl := /* TODO(NonNullExpression): symbol.parent! */ TODO.valueDeclaration
		if !decl {
			return nil
		}
		initializer := /* TODO(ConditionalExpression): isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(decl) :             hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(decl) :             undefined */ TODO
		return initializer || decl
	}
	getExpandoSymbol := func(symbol Symbol) *Symbol {
		decl := symbol.valueDeclaration
		if !decl || !isInJSFile(decl) || symbol.flags&SymbolFlagsTypeAlias || getExpandoInitializer(decl, false) {
			return nil
		}
		init := /* TODO(ConditionalExpression): isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(decl) : getAssignedExpandoInitializer(decl) */ TODO
		if init {
			initSymbol := getSymbolOfNode(init)
			if initSymbol {
				return mergeJSSymbols(initSymbol, symbol)
			}
		}
	}
	resolveExternalModuleName := func(location Node, moduleReferenceExpression Expression, ignoreErrors bool) *Symbol {
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		errorMessage := /* TODO(ConditionalExpression): isClassic ?             Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		return resolveExternalModuleNameWorker(location, moduleReferenceExpression /* TODO(ConditionalExpression): ignoreErrors ? undefined : errorMessage */, TODO, ignoreErrors)
	}
	resolveExternalModuleNameWorker := func(location Node, moduleReferenceExpression Expression, moduleNotFoundError *DiagnosticMessage, ignoreErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, isForAugmentation /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		return /* TODO(ConditionalExpression): isStringLiteralLike(moduleReferenceExpression)             ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, !ignoreErrors ? moduleReferenceExpression : undefined, isForAugmentation)             : undefined */ TODO
	}
	resolveExternalModule := func(location Node, moduleReference string, moduleNotFoundError *DiagnosticMessage, errorNode Node, isForAugmentation /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) *Symbol {
		if errorNode && startsWith(moduleReference, "@types/") {
			diag := Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1
			withoutAtTypePrefix := removePrefix(moduleReference, "@types/")
			error(errorNode, diag, withoutAtTypePrefix, moduleReference)
		}
		ambientModule := tryFindAmbientModule(moduleReference, true)
		if ambientModule {
			return ambientModule
		}
		currentSourceFile := getSourceFileOfNode(location)
		contextSpecifier := /* TODO(ConditionalExpression): isStringLiteralLike(location)             ? location             : (isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : undefined)?.name ||                 (isLiteralImportTypeNode(location) ? location : undefined)?.argument.literal ||                 (isInJSFile(location) && isJSDocImportTag(location) ? location.moduleSpecifier : undefined) ||                 (isVariableDeclaration(location) && location.initializer && isRequireCall(location.initializer, /*requireStringLiteralLikeArgument* / true) ? location.initializer.arguments[0] : undefined) ||                 findAncestor(location, isImportCall)?.arguments[0] ||                 findAncestor(location, isImportDeclaration)?.moduleSpecifier ||                 findAncestor(location, isExternalModuleImportEqualsDeclaration)?.moduleReference.expression ||                 findAncestor(location, isExportDeclaration)?.moduleSpecifier */ TODO
		mode := /* TODO(ConditionalExpression): contextSpecifier && isStringLiteralLike(contextSpecifier)             ? host.getModeForUsageLocation(currentSourceFile, contextSpecifier)             : host.getDefaultResolutionModeForFile(currentSourceFile) */ TODO
		moduleResolutionKind := getEmitModuleResolutionKind(compilerOptions)
		resolvedModule := host.getResolvedModule(currentSourceFile, moduleReference, mode).resolvedModule
		resolutionDiagnostic := errorNode && resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile)
		sourceFile := resolvedModule && (!resolutionDiagnostic || resolutionDiagnostic == Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set) && host.getSourceFile(resolvedModule.resolvedFileName)
		if sourceFile {
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			}
			if resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference) {
				importOrExport := findAncestor(location, isImportDeclaration).importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall) {
					error(errorNode, Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead, getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))))
				}
			} else if resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(compilerOptions, currentSourceFile.fileName) {
				importOrExport := findAncestor(location, isImportDeclaration).importClause || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration))
				if errorNode && !(importOrExport.isTypeOnly || findAncestor(location, isImportTypeNode)) {
					tsExtension := Debug.checkDefined(tryExtractTSExtension(moduleReference))
					error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension)
				}
			}
			if sourceFile.symbol {
				if errorNode && resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension) {
					errorOnImplicitAnyModule(false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference)
				}
				if errorNode && (moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext) {
					isSyncImport := (currentSourceFile.impliedNodeFormat == ModuleKindCommonJS && !findAncestor(location, isImportCall)) || !!findAncestor(location, isImportEqualsDeclaration)
					overrideHost := findAncestor(location, func(l /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(BinaryExpression): isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l) */
						/* TODO(BarBarToken): || */
						/* TODO(CallExpression): isJSDocImportTag(l) */
					})
					if isSyncImport && sourceFile.impliedNodeFormat == ModuleKindESNext && !hasResolutionModeOverride(overrideHost) {
						if findAncestor(location, isImportEqualsDeclaration) {
							error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference)
						} else {
							var diagnosticDetails TODO
							ext := tryGetExtensionFromPath(currentSourceFile.fileName)
							if ext == ExtensionTs || ext == ExtensionJs || ext == ExtensionTsx || ext == ExtensionJsx {
								diagnosticDetails = createModeMismatchDetails(currentSourceFile)
							}
							diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chainDiagnosticMessages(diagnosticDetails, Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead, moduleReference)))
						}
					}
				}
				return getMergedSymbol(sourceFile.symbol)
			}
			if errorNode && moduleNotFoundError && !isSideEffectImport(errorNode) {
				error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName)
			}
			return nil
		}
		if patternAmbientModules {
			pattern := findBestPatternMatch(patternAmbientModules, func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").PatternAmbientModule */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/core").Pattern */ TODO {
				/* TODO(Identifier): _ */
				/* TODO(Identifier): pattern */
			}, moduleReference)
			if pattern {
				augmentation := patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference)
				if augmentation {
					return getMergedSymbol(augmentation)
				}
				return getMergedSymbol(pattern.symbol)
			}
		}
		if !errorNode {
			return nil
		}
		if resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic == nil || resolutionDiagnostic == Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type {
			if isForAugmentation {
				diag := Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented
				error(errorNode, diag, moduleReference /* TODO(NonNullExpression): resolvedModule! */, TODO.resolvedFileName)
			} else {
				errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode /* TODO(NonNullExpression): resolvedModule! */, TODO, moduleReference)
			}
			return nil
		}
		if moduleNotFoundError {
			if resolvedModule {
				redirect := host.getProjectReferenceRedirect(resolvedModule.resolvedFileName)
				if redirect {
					error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName)
					return nil
				}
			}
			if resolutionDiagnostic {
				error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName)
			} else {
				isExtensionlessRelativePathImport := pathIsRelative(moduleReference) && !hasExtension(moduleReference)
				resolutionIsNode16OrNext := moduleResolutionKind == ModuleResolutionKindNode16 || moduleResolutionKind == ModuleResolutionKindNodeNext
				if !getResolveJsonModule(compilerOptions) && fileExtensionIs(moduleReference, ExtensionJson) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleResolutionKind !== ModuleResolutionKind.Classic */ TODO && hasJsonModuleEmitEnabled(compilerOptions) {
					error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference)
				} else if mode == ModuleKindESNext && resolutionIsNode16OrNext && isExtensionlessRelativePathImport {
					absoluteRef := getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path))
					suggestedExt := /* TODO(ElementAccessExpression): suggestedExtensions.find(([actualExt, _importExt]) => host.fileExists(absoluteRef + actualExt))?.[1] */ TODO
					if suggestedExt {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): moduleReference + suggestedExt */, TODO)
					} else {
						error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path)
					}
				} else {
					if host.getResolvedModule(currentSourceFile, moduleReference, mode).alternateResult {
						errorInfo := createModuleNotFoundChain(currentSourceFile, host, moduleReference, mode, moduleReference)
						errorOrSuggestion(true, errorNode, chainDiagnosticMessages(errorInfo, moduleNotFoundError, moduleReference))
					} else {
						error(errorNode, moduleNotFoundError, moduleReference)
					}
				}
			}
		}
		return nil
		getSuggestedImportSource := func(tsExtension string) /* TODO(undefined): string */ TODO {
			importSourceWithoutExtension := removeExtension(moduleReference, tsExtension)
			if emitModuleKindIsNonNodeESM(moduleKind) || mode == ModuleKindESNext {
				preferTs := isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions)
				ext := /* TODO(ConditionalExpression): tsExtension === Extension.Mts || tsExtension === Extension.Dmts ? preferTs ? ".mts" : ".mjs" :                     tsExtension === Extension.Cts || tsExtension === Extension.Dmts ? preferTs ? ".cts" : ".cjs" :                     preferTs ? ".ts" : ".js" */ TODO
				return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): importSourceWithoutExtension + ext */ TODO
			}
			return importSourceWithoutExtension
		}
	}
	errorOnImplicitAnyModule := func(isError bool, errorNode Node, sourceFile SourceFile, mode ResolutionMode, TODO_IDENTIFIER ResolvedModuleFull, moduleReference string) {
		if isSideEffectImport(errorNode) {
			return
		}
		var errorInfo *DiagnosticMessageChain
		if !isExternalModuleNameRelative(moduleReference) && packageId {
			errorInfo = createModuleNotFoundChain(sourceFile, host, moduleReference, mode, packageId.name)
		}
		errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo, Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName))
	}
	// OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol Symbol, dontResolveAlias bool) Symbol
	// OVERLOAD: resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol
	resolveExternalModuleSymbol := func(moduleSymbol *Symbol, dontResolveAlias bool) *Symbol {
		if moduleSymbol.exports {
			exportEquals := resolveSymbol(moduleSymbol.exports.get(InternalSymbolNameExportEquals), dontResolveAlias)
			exported := getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol))
			return getMergedSymbol(exported) || moduleSymbol
		}
		return nil
	}
	getCommonJsExportEquals := func(exported *Symbol, moduleSymbol Symbol) *Symbol {
		if !exported || exported == unknownSymbol || exported == moduleSymbol || /* TODO(NonNullExpression): moduleSymbol.exports! */ TODO.size == 1 || exported.flags&SymbolFlagsAlias {
			return exported
		}
		links := getSymbolLinks(exported)
		if links.cjsExportMerged {
			return links.cjsExportMerged
		}
		merged := /* TODO(ConditionalExpression): exported.flags & SymbolFlags.Transient ? exported : cloneSymbol(exported) */ TODO
		merged.flags = merged.flags | SymbolFlagsValueModule
		if merged.exports == nil {
			merged.exports = createSymbolTable()
		}
		/* TODO(NonNullExpression): moduleSymbol.exports! */ TODO.forEach(func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if name == InternalSymbolNameExportEquals {
			}
			/* TODO(NonNullExpression): merged.exports! */ TODO.set(name /* TODO(ConditionalExpression): merged.exports!.has(name) ? mergeSymbol(merged.exports!.get(name)!, s) : s */, TODO)
		})
		if merged == exported {
			getSymbolLinks(merged).resolvedExports = nil
			getSymbolLinks(merged).resolvedMembers = nil
		}
		getSymbolLinks(merged).cjsExportMerged = merged
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.cjsExportMerged = merged */ TODO
	}
	resolveESModuleSymbol := func(moduleSymbol *Symbol, referencingLocation Node, dontResolveAlias bool, suppressInteropError bool) *Symbol {
		symbol := resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias)
		if !dontResolveAlias && symbol {
			if !suppressInteropError && !(symbol.flags & (SymbolFlagsModule | SymbolFlagsVariable)) && !getDeclarationOfKind(symbol, SyntaxKindSourceFile) {
				compilerOptionName := /* TODO(ConditionalExpression): moduleKind >= ModuleKind.ES2015                     ? "allowSyntheticDefaultImports"                     : "esModuleInterop" */ TODO
				error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName)
				return symbol
			}
			referenceParent := referencingLocation.parent
			if (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent)) || isImportCall(referenceParent) {
				reference := /* TODO(ConditionalExpression): isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier */ TODO
				type_ := getTypeOfSymbol(symbol)
				defaultOnlyType := getTypeWithSyntheticDefaultOnly(type_, symbol /* TODO(NonNullExpression): moduleSymbol! */, TODO, reference)
				if defaultOnlyType {
					return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent)
				}
				targetFile := moduleSymbol.declarations.find(isSourceFile)
				isEsmCjsRef := targetFile && isESMFormatImportImportingCommonjsFormatFile(getEmitSyntaxForModuleSpecifierExpression(reference), host.getImpliedNodeFormatForEmit(targetFile))
				if getESModuleInterop(compilerOptions) || isEsmCjsRef {
					sigs := getSignaturesOfStructuredType(type_, SignatureKindCall)
					if !sigs || !sigs.length {
						sigs = getSignaturesOfStructuredType(type_, SignatureKindConstruct)
					}
					if (sigs && sigs.length) || getPropertyOfType(type_, InternalSymbolNameDefault, true) || isEsmCjsRef {
						moduleType := /* TODO(ConditionalExpression): type.flags & TypeFlags.StructuredType                             ? getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol!, reference)                             : createDefaultPropertyWrapperForModule(symbol, symbol.parent) */ TODO
						return cloneTypeAsModuleType(symbol, moduleType, referenceParent)
					}
				}
			}
		}
		return symbol
	}
	cloneTypeAsModuleType := func(symbol Symbol, moduleType Type, referenceParent /* TODO(UnionType): ImportDeclaration | ImportCall */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		result := createSymbol(symbol.flags, symbol.escapedName)
		result.declarations = /* TODO(ConditionalExpression): symbol.declarations ? symbol.declarations.slice() : [] */ TODO
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.originatingImport = referenceParent
		if symbol.valueDeclaration {
			/* TODO(BinaryExpression): result.valueDeclaration = symbol.valueDeclaration */
		}
		if symbol.constEnumOnlyModule {
			/* TODO(BinaryExpression): result.constEnumOnlyModule = true */
		}
		if symbol.members {
			/* TODO(BinaryExpression): result.members = new Map(symbol.members) */
		}
		if symbol.exports {
			/* TODO(BinaryExpression): result.exports = new Map(symbol.exports) */
		}
		resolvedModuleType := resolveStructuredTypeMembers(moduleType /* as */ /* TODO(TypeReference): StructuredType */)
		result.links.type_ = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos)
		return result
	}
	hasExportAssignmentSymbol := func(moduleSymbol Symbol) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleSymbol.exports!.get(InternalSymbolName.ExportEquals) !== undefined */ TODO
	}
	getExportsOfModuleAsArray := func(moduleSymbol Symbol) []Symbol {
		return symbolsToArray(getExportsOfModule(moduleSymbol))
	}
	getExportsAndPropertiesOfModule := func(moduleSymbol Symbol) []Symbol {
		exports := getExportsOfModuleAsArray(moduleSymbol)
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): exportEquals !== moduleSymbol */ TODO {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				addRange(exports, getPropertiesOfType(type_))
			}
		}
		return exports
	}
	forEachExportAndPropertyOfModule := func(moduleSymbol Symbol, cb func(symbol Symbol, key __String)) {
		exports := getExportsOfModule(moduleSymbol)
		exports.forEach(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, key /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if !isReservedMemberName(key) {
				cb(symbol, key)
			}
		})
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): exportEquals !== moduleSymbol */ TODO {
			type_ := getTypeOfSymbol(exportEquals)
			if shouldTreatPropertiesOfExternalModuleAsExports(type_) {
				forEachPropertyOfType(type_, func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, escapedName /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					cb(symbol, escapedName)
				})
			}
		}
	}
	tryGetMemberInModuleExports := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbolTable := getExportsOfModule(moduleSymbol)
		if symbolTable {
			return symbolTable.get(memberName)
		}
	}
	tryGetMemberInModuleExportsAndProperties := func(memberName __String, moduleSymbol Symbol) *Symbol {
		symbol := tryGetMemberInModuleExports(memberName, moduleSymbol)
		if symbol {
			return symbol
		}
		exportEquals := resolveExternalModuleSymbol(moduleSymbol)
		if exportEquals == moduleSymbol {
			return nil
		}
		type_ := getTypeOfSymbol(exportEquals)
		return /* TODO(ConditionalExpression): shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : undefined */ TODO
	}
	shouldTreatPropertiesOfExternalModuleAsExports := func(resolvedExternalModuleType Type) /* TODO(undefined): boolean */ TODO {
		return !(resolvedExternalModuleType.flags&TypeFlagsPrimitive || getObjectFlags(resolvedExternalModuleType)&ObjectFlagsClass || isArrayType(resolvedExternalModuleType) || isTupleType(resolvedExternalModuleType))
	}
	getExportsOfSymbol := func(symbol Symbol) SymbolTable {
		return /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedExports) :             symbol.flags & SymbolFlags.Module ? getExportsOfModule(symbol) :             symbol.exports || emptySymbols */ TODO
	}
	getExportsOfModule := func(moduleSymbol Symbol) SymbolTable {
		links := getSymbolLinks(moduleSymbol)
		if !links.resolvedExports {
			TODO_IDENTIFIER := getExportsOfModuleWorker(moduleSymbol)
			links.resolvedExports = exports
			links.typeOnlyExportStarMap = typeOnlyExportStarMap
		}
		return links.resolvedExports
	}
	type ExportCollisionTracker struct {
		specifierText        string
		exportsWithDuplicate []ExportDeclaration
	}
	type ExportCollisionTrackerTable Map[__String, ExportCollisionTracker]
	extendExportSymbols := func(target SymbolTable, source *SymbolTable, lookupTable ExportCollisionTrackerTable, exportNode ExportDeclaration) {
		if !source {
		}
		source.forEach(func(sourceSymbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if id == InternalSymbolNameDefault {
			}
			targetSymbol := target.get(id)
			if !targetSymbol {
				target.set(id, sourceSymbol)
				if lookupTable && exportNode {
					lookupTable.set(id /* TODO(ObjectLiteralExpression): {                         specifierText: getTextOfNode(exportNode.moduleSpecifier!),                     } */, TODO)
				}
			} else if lookupTable && exportNode && targetSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol) */ TODO {
				collisionTracker := /* TODO(NonNullExpression): lookupTable.get(id)! */ TODO
				if !collisionTracker.exportsWithDuplicate {
					collisionTracker.exportsWithDuplicate = /* TODO(ArrayLiteralExpression): [exportNode] */ TODO
				} else {
					collisionTracker.exportsWithDuplicate.push(exportNode)
				}
			}
		})
	}
	getExportsOfModuleWorker := func(moduleSymbol Symbol) /* TODO(undefined): { exports: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable; typeOnlyExportStarMap: Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> | undefined; } */ TODO {
		var visitedSymbols []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var typeOnlyExportStarMap *Map[__String /* TODO(IntersectionType): ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */, TODO]
		nonTypeOnlyNames := /* TODO(NewExpression): new Set<__String>() */ TODO
		moduleSymbol = resolveExternalModuleSymbol(moduleSymbol)
		exports := visit(moduleSymbol) || emptySymbols
		if typeOnlyExportStarMap {
			nonTypeOnlyNames.forEach(func(name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): typeOnlyExportStarMap!.delete */
				/* TODO(Identifier): name */
			})
		}
		return /* TODO(ObjectLiteralExpression): {             exports,             typeOnlyExportStarMap,         } */ TODO
		visit := func(symbol *Symbol, exportStar ExportDeclaration, isTypeOnly bool) *SymbolTable {
			if !isTypeOnly && symbol.exports {
				symbol.exports.forEach(func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO(undefined): Set<import("/home/jabaile/work/TypeScript/src/compiler/types").__String> */ TODO {
					/* TODO(PropertyAccessExpression): nonTypeOnlyNames.add */
					/* TODO(Identifier): name */
				})
			}
			if !(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol)) {
				return
			}
			symbols := /* TODO(NewExpression): new Map(symbol.exports) */ TODO
			exportStars := symbol.exports.get(InternalSymbolNameExportStar)
			if exportStars {
				nestedSymbols := createSymbolTable()
				var lookupTable ExportCollisionTrackerTable = /* TODO(NewExpression): new Map() */ TODO
				if exportStars.declarations {
					for _, node := range exportStars.declarations {
						resolvedModule := resolveExternalModuleName(node /* TODO(NonNullExpression): (node as ExportDeclaration).moduleSpecifier! */, TODO)
						exportedSymbols := visit(resolvedModule, node /* as */ /* TODO(TypeReference): ExportDeclaration */, isTypeOnly || (node /* as */ /* TODO(TypeReference): ExportDeclaration */).isTypeOnly)
						extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node /* as */ /* TODO(TypeReference): ExportDeclaration */)
					}
				}
				lookupTable.forEach(func(TODO_IDENTIFIER /* TODO(undefined): ExportCollisionTracker */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					if id == "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id) {
						return
					}
					for _, node := range exportsWithDuplicate {
						diagnostics.add(createDiagnosticForNode(node, Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity /* TODO(NonNullExpression): lookupTable.get(id)! */, TODO.specifierText, unescapeLeadingUnderscores(id)))
					}
				})
				extendExportSymbols(symbols, nestedSymbols)
			}
			if exportStar.isTypeOnly {
				/* TODO(ExpressionStatement): typeOnlyExportStarMap ??= new Map(); */
				symbols.forEach(func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, escapedName /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO(undefined): Map<import("/home/jabaile/work/TypeScript/src/compiler/types").__String, import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }> */ TODO {
					/* TODO(PropertyAccessExpression): typeOnlyExportStarMap!.set */
					/* TODO(Identifier): escapedName */
					/* TODO(AsExpression): exportStar as ExportDeclaration & { readonly isTypeOnly: true; readonly moduleSpecifier: Expression; } */
				})
			}
			return symbols
		}
	}
	// OVERLOAD: getMergedSymbol := func(symbol Symbol) Symbol
	// OVERLOAD: getMergedSymbol := func(symbol *Symbol) *Symbol
	getMergedSymbol := func(symbol *Symbol) *Symbol {
		var merged Symbol
		return /* TODO(ConditionalExpression): symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol */ TODO
	}
	getSymbolOfDeclaration := func(node Declaration) Symbol {
		return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol))
	}
	getSymbolOfNode := func(node Node) *Symbol {
		return /* TODO(ConditionalExpression): canHaveSymbol(node) ? getSymbolOfDeclaration(node) : undefined */ TODO
	}
	getParentOfSymbol := func(symbol Symbol) *Symbol {
		return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent))
	}
	getFunctionExpressionParentSymbolOrSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		return /* TODO(ConditionalExpression): symbol.valueDeclaration?.kind === SyntaxKind.ArrowFunction || symbol.valueDeclaration?.kind === SyntaxKind.FunctionExpression             ? getSymbolOfNode(symbol.valueDeclaration.parent) || symbol             : symbol */ TODO
	}
	getAlternativeContainingModules := func(symbol Symbol, enclosingDeclaration Node) []Symbol {
		containingFile := getSourceFileOfNode(enclosingDeclaration)
		id := getNodeId(containingFile)
		links := getSymbolLinks(symbol)
		var results /* TODO(ArrayType): Symbol[] */ any
		if links.extendedContainersByFile && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): results = links.extendedContainersByFile.get(id) */ TODO) {
			return results
		}
		if containingFile && containingFile.imports {
			for _, importRef := range containingFile.imports {
				if nodeIsSynthesized(importRef) {
				}
				resolvedModule := resolveExternalModuleName(enclosingDeclaration, importRef, true)
				if !resolvedModule {
				}
				ref := getAliasForSymbolInContainer(resolvedModule, symbol)
				if !ref {
				}
				results = append(results, resolvedModule)
			}
			if length(results) {
				(links.extendedContainersByFile || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.extendedContainersByFile = new Map() */ TODO)).set(id /* TODO(NonNullExpression): results! */, TODO)
				return /* TODO(NonNullExpression): results! */ TODO
			}
		}
		if links.extendedContainers {
			return links.extendedContainers
		}
		otherFiles := host.getSourceFiles()
		for _, file := range otherFiles {
			if !isExternalModule(file) {
			}
			sym := getSymbolOfDeclaration(file)
			ref := getAliasForSymbolInContainer(sym, symbol)
			if !ref {
			}
			results = append(results, sym)
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.extendedContainers = results || emptyArray */ TODO
	}
	getContainersOfSymbol := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO(ArrayType): Symbol[] */ any {
		container := getParentOfSymbol(symbol)
		if container && !(symbol.flags & SymbolFlagsTypeParameter) {
			return getWithAlternativeContainers(container)
		}
		candidates := mapDefined(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			if !isAmbientModule(d) && d.parent {
				if hasNonGlobalAugmentationExternalModuleSymbol(d.parent) {
					return getSymbolOfDeclaration(d.parent /* as */ /* TODO(TypeReference): Declaration */)
				}
				if isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) == symbol {
					return getSymbolOfDeclaration(d.parent.parent)
				}
			}
			if isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind == SyntaxKindEqualsToken && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression) {
				if isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression) {
					return getSymbolOfDeclaration(getSourceFileOfNode(d))
				}
				checkExpressionCached(d.parent.left.expression)
				return getNodeLinks(d.parent.left.expression).resolvedSymbol
			}
		})
		if !length(candidates) {
			return nil
		}
		containers := mapDefined(candidates, func(candidate /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			/* TODO(CallExpression): getAliasForSymbolInContainer(candidate, symbol) */
			/* TODO(QuestionToken): ? */
			/* TODO(Identifier): candidate */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): undefined */
		})
		var bestContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var alternativeContainers []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, container := range containers {
			TODO_IDENTIFIER := getWithAlternativeContainers(container)
			bestContainers = append(bestContainers, bestMatch)
			alternativeContainers = addRange(alternativeContainers, rest)
		}
		return concatenate(bestContainers, alternativeContainers)
		getWithAlternativeContainers := func(container Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			additionalContainers := mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer)
			reexportContainers := enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration)
			objectLiteralContainer := getVariableDeclarationOfObjectLiteral(container, meaning)
			if enclosingDeclaration && container.flags&getQualifiedLeftMeaning(meaning) && getAccessibleSymbolChain(container, enclosingDeclaration, SymbolFlagsNamespace, false) {
				return append(concatenate(concatenate( /* TODO(ArrayLiteralExpression): [container] */ TODO, additionalContainers), reexportContainers), objectLiteralContainer)
			}
			firstVariableMatch := /* TODO(ConditionalExpression): !(container.flags & getQualifiedLeftMeaning(meaning))                     && container.flags & SymbolFlags.Type                     && getDeclaredTypeOfSymbol(container).flags & TypeFlags.Object                     && meaning === SymbolFlags.Value                 ? forEachSymbolTableInScope(enclosingDeclaration, t => {                     return forEachEntry(t, s => {                         if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {                             return s;                         }                     });                 }) : undefined */ TODO
			res := /* TODO(ConditionalExpression): firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container] */ TODO
			res = append(res, objectLiteralContainer)
			res = addRange(res, reexportContainers)
			return res
		}
		fileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container)
		}
	}
	getVariableDeclarationOfObjectLiteral := func(symbol Symbol, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		var firstDecl /* TODO(UnionType): Node | false */ any = !!length(symbol.declarations) && first( /* TODO(NonNullExpression): symbol.declarations! */ TODO)
		if meaning&SymbolFlagsValue && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent) {
			if isObjectLiteralExpression(firstDecl) && firstDecl == firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl == firstDecl.parent.type_ {
				return getSymbolOfDeclaration(firstDecl.parent)
			}
		}
	}
	getFileSymbolIfFileSymbolExportEqualsContainer := func(d Declaration, container Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		fileSymbol := getExternalModuleContainer(d)
		exported := fileSymbol && fileSymbol.exports && fileSymbol.exports.get(InternalSymbolNameExportEquals)
		return /* TODO(ConditionalExpression): exported && getSymbolIfSameReference(exported, container) ? fileSymbol : undefined */ TODO
	}
	getAliasForSymbolInContainer := func(container Symbol, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if container == getParentOfSymbol(symbol) {
			return symbol
		}
		exportEquals := container.exports && container.exports.get(InternalSymbolNameExportEquals)
		if exportEquals && getSymbolIfSameReference(exportEquals, symbol) {
			return container
		}
		exports := getExportsOfSymbol(container)
		quick := exports.get(symbol.escapedName)
		if quick && getSymbolIfSameReference(quick, symbol) {
			return quick
		}
		return forEachEntry(exports, func(exported /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			if getSymbolIfSameReference(exported, symbol) {
				return exported
			}
		})
	}
	getSymbolIfSameReference := func(s1 Symbol, s2 Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) == getMergedSymbol(resolveSymbol(getMergedSymbol(s2))) {
			return s1
		}
	}
	// OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol Symbol) Symbol
	// OVERLOAD: getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol
	getExportSymbolOfValueSymbolIfExported := func(symbol *Symbol) *Symbol {
		return getMergedSymbol(symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.ExportValue) !== 0 */ TODO && symbol.exportSymbol || symbol)
	}
	symbolIsValue := func(symbol Symbol, includeTypeOnlyMembers bool) bool {
		return !!(symbol.flags&SymbolFlagsValue || symbol.flags&SymbolFlagsAlias && getSymbolFlags(symbol, !includeTypeOnlyMembers)&SymbolFlagsValue)
	}
	createType := func(flags TypeFlags) Type {
		result := /* TODO(NewExpression): new Type(checker, flags) */ TODO
		typeCount++
		result.id = typeCount
		tracing.recordType(result)
		return result
	}
	createTypeWithSymbol := func(flags TypeFlags, symbol Symbol) Type {
		result := createType(flags)
		result.symbol = symbol
		return result
	}
	createOriginType := func(flags TypeFlags) Type {
		return /* TODO(NewExpression): new Type(checker, flags) */ TODO
	}
	createIntrinsicType := func(kind TypeFlags, intrinsicName string, objectFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): ObjectFlags.None */, debugIntrinsicName string) IntrinsicType {
		checkIntrinsicName(intrinsicName, debugIntrinsicName)
		type_ := createType(kind) /* as */ /* TODO(TypeReference): IntrinsicType */
		type_.intrinsicName = intrinsicName
		type_.debugIntrinsicName = debugIntrinsicName
		type_.objectFlags = objectFlags | ObjectFlagsCouldContainTypeVariablesComputed | ObjectFlagsIsGenericTypeComputed | ObjectFlagsIsUnknownLikeUnionComputed | ObjectFlagsIsNeverIntersectionComputed
		return type_
	}
	checkIntrinsicName := func(name string, debug /* TODO(StringKeyword): string */ any) {
		key := /* TODO(TemplateExpression): `${name},${debug ?? ""}` */ TODO
		if seenIntrinsicNames.has(key) {
			Debug.fail( /* TODO(TemplateExpression): `Duplicate intrinsic type name ${name}${debug ? ` (${debug})` : ""}; you may need to pass a name to createIntrinsicType.` */ TODO)
		}
		seenIntrinsicNames.add(key)
	}
	createObjectType := func(objectFlags ObjectFlags, symbol Symbol) ObjectType {
		type_ := createTypeWithSymbol(TypeFlagsObject /* TODO(NonNullExpression): symbol! */, TODO) /* as */ /* TODO(TypeReference): ObjectType */
		type_.objectFlags = objectFlags
		type_.members = nil
		type_.properties = nil
		type_.callSignatures = nil
		type_.constructSignatures = nil
		type_.indexInfos = nil
		return type_
	}
	createTypeofType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getUnionType(arrayFrom(typeofNEFacts.keys(), getStringLiteralType))
	}
	createTypeParameter := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
		return createTypeWithSymbol(TypeFlagsTypeParameter /* TODO(NonNullExpression): symbol! */, TODO) /* as */ /* TODO(TypeReference): TypeParameter */
	}
	isReservedMemberName := func(name __String) /* TODO(undefined): boolean */ TODO {
		return (name /* as */ /* TODO(StringKeyword): string */).charCodeAt(0) == CharacterCodes_ && (name /* as */ /* TODO(StringKeyword): string */).charCodeAt(1) == CharacterCodes_ && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (name as string).charCodeAt(2) !== CharacterCodes._ */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (name as string).charCodeAt(2) !== CharacterCodes.at */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (name as string).charCodeAt(2) !== CharacterCodes.hash */ TODO
	}
	getNamedMembers := func(members SymbolTable) []Symbol {
		var result /* TODO(ArrayType): Symbol[] */ any
		members.forEach(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if isNamedMember(symbol, id) {
				(result || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = [] */ TODO)).push(symbol)
			}
		})
		return result || emptyArray
	}
	isNamedMember := func(member Symbol, escapedName __String) /* TODO(undefined): boolean */ TODO {
		return !isReservedMemberName(escapedName) && symbolIsValue(member)
	}
	getNamedOrIndexSignatureMembers := func(members SymbolTable) []Symbol {
		result := getNamedMembers(members)
		index := getIndexSymbolFromSymbolTable(members)
		return /* TODO(ConditionalExpression): index ? concatenate(result, [index]) : result */ TODO
	}
	setStructuredTypeMembers := func(type_ StructuredType, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		resolved := type_ /* as */ /* TODO(TypeReference): ResolvedType */
		resolved.members = members
		resolved.properties = emptyArray
		resolved.callSignatures = callSignatures
		resolved.constructSignatures = constructSignatures
		resolved.indexInfos = indexInfos
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): members !== emptySymbols */ TODO {
			/* TODO(BinaryExpression): resolved.properties = getNamedMembers(members) */
		}
		return resolved
	}
	createAnonymousType := func(symbol *Symbol, members SymbolTable, callSignatures []Signature, constructSignatures []Signature, indexInfos []IndexInfo) ResolvedType {
		return setStructuredTypeMembers(createObjectType(ObjectFlagsAnonymous, symbol), members, callSignatures, constructSignatures, indexInfos)
	}
	getResolvedTypeWithoutAbstractConstructSignatures := func(type_ ResolvedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if type_.constructSignatures.length == 0 {
			/* TODO(Identifier): type */
		}
		if type_.objectTypeWithoutAbstractConstructSignatures {
			/* TODO(PropertyAccessExpression): type.objectTypeWithoutAbstractConstructSignatures */
		}
		constructSignatures := filter(type_.constructSignatures, func(signature /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(ParenthesizedExpression): (signature.flags & SignatureFlags.Abstract) */
		})
		if type_.constructSignatures == constructSignatures {
			/* TODO(Identifier): type */
		}
		typeCopy := createAnonymousType(type_.symbol, type_.members, type_.callSignatures /* TODO(ConditionalExpression): some(constructSignatures) ? constructSignatures : emptyArray */, TODO, type_.indexInfos)
		type_.objectTypeWithoutAbstractConstructSignatures = typeCopy
		typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy
		return typeCopy
	}
	forEachSymbolTableInScope := func(enclosingDeclaration Node, callback func(symbolTable SymbolTable, ignoreQualification bool, isLocalNameLookup bool, scopeNode Node) T) T {
		var result T
		/* TODO(ForStatement): for (let location = enclosingDeclaration; location; location = location.parent) {             // Locals of a source file are not in scope (because they get merged into the global symbol table)             if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {                 if (result = callback(location.locals, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                     return result;                 }             }             switch (location.kind) {                 case SyntaxKind.SourceFile:                     if (!isExternalOrCommonJsModule(location as SourceFile)) {                         break;                     }                     // falls through                 case SyntaxKind.ModuleDeclaration:                     const sym = getSymbolOfDeclaration(location as ModuleDeclaration);                     // `sym` may not have exports if this module declaration is backed by the symbol for a `const` that's being rewritten                     // into a namespace - in such cases, it's best to just let the namespace appear empty (the const members couldn't have referred                     // to one another anyway)                     if (result = callback(sym?.exports || emptySymbols, /*ignoreQualification* / undefined, /*isLocalNameLookup* / true, location)) {                         return result;                     }                     break;                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                 case SyntaxKind.InterfaceDeclaration:                     // Type parameters are bound into `members` lists so they can merge across declarations                     // This is troublesome, since in all other respects, they behave like locals :cries:                     // TODO: the below is shared with similar code in `resolveName` - in fact, rephrasing all this symbol                     // lookup logic in terms of `resolveName` would be nice                     // The below is used to lookup type parameters within a class or interface, as they are added to the class/interface locals                     // These can never be latebound, so the symbol's raw members are sufficient. `getMembersOfNode` cannot be used, as it would                     // trigger resolving late-bound names, which we may already be in the process of doing while we're here!                     let table: Map<__String, Symbol> | undefined;                     // TODO: Should this filtered table be cached in some way?                     (getSymbolOfDeclaration(location as ClassLikeDeclaration | InterfaceDeclaration).members || emptySymbols).forEach((memberSymbol, key) => {                         if (memberSymbol.flags & (SymbolFlags.Type & ~SymbolFlags.Assignment)) {                             (table || (table = createSymbolTable())).set(key, memberSymbol);                         }                     });                     if (table && (result = callback(table, /*ignoreQualification* / undefined, /*isLocalNameLookup* / false, location))) {                         return result;                     }                     break;             }         } */
		return callback(globals, nil, true)
	}
	getQualifiedLeftMeaning := func(rightMeaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Value | import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags.Namespace */ TODO {
		return /* TODO(ConditionalExpression): rightMeaning === SymbolFlags.Value ? SymbolFlags.Value : SymbolFlags.Namespace */ TODO
	}
	getAccessibleSymbolChain := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, useOnlyExternalAliasing bool, visitedSymbolTablesMap /* TODO(undefined): Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable[]> */ TODO /* = */ /* TODO(NewExpression): new Map<SymbolId, SymbolTable[]>() */) /* TODO(ArrayType): Symbol[] */ any {
		if !(symbol && !isPropertyOrMethodDeclarationSymbol(symbol)) {
			return nil
		}
		links := getSymbolLinks(symbol)
		cache := ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): links.accessibleChainCache ||= new Map() */ TODO)
		firstRelevantLocation := forEachSymbolTableInScope(enclosingDeclaration, func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO, __ /* TODO(undefined): boolean | undefined */ TODO, ___ /* TODO(undefined): boolean | undefined */ TODO, node /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
		})
		key := /* TODO(TemplateExpression): `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation && getNodeId(firstRelevantLocation)}|${meaning}` */ TODO
		if cache.has(key) {
			return cache.get(key)
		}
		id := getSymbolId(symbol)
		visitedSymbolTables := visitedSymbolTablesMap.get(id)
		if !visitedSymbolTables {
			visitedSymbolTablesMap.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): visitedSymbolTables = [] */, TODO)
		}
		result := forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable)
		cache.set(key, result)
		return result
		getAccessibleSymbolChainFromSymbolTable := func(symbols SymbolTable, ignoreQualification bool, isLocalNameLookup bool) /* TODO(ArrayType): Symbol[] */ any {
			if !pushIfUnique( /* TODO(NonNullExpression): visitedSymbolTables! */ TODO, symbols) {
				return nil
			}
			result := trySymbolTable(symbols, ignoreQualification, isLocalNameLookup)
			/* TODO(NonNullExpression): visitedSymbolTables! */ TODO.pop()
			return result
		}
		canQualifySymbol := func(symbolFromSymbolTable Symbol, meaning SymbolFlags) /* TODO(undefined): boolean */ TODO {
			return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning) || !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning), useOnlyExternalAliasing, visitedSymbolTablesMap)
		}
		isAccessible := func(symbolFromSymbolTable Symbol, resolvedAliasSymbol Symbol, ignoreQualification bool) /* TODO(undefined): boolean */ TODO {
			return (symbol == (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) == getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) && !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) && (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning))
		}
		trySymbolTable := func(symbols SymbolTable, ignoreQualification /* TODO(BooleanKeyword): boolean */ any, isLocalNameLookup /* TODO(BooleanKeyword): boolean */ any) /* TODO(ArrayType): Symbol[] */ any {
			if isAccessible( /* TODO(NonNullExpression): symbols.get(symbol!.escapedName)! */ TODO, nil, ignoreQualification) {
				return /* TODO(ArrayLiteralExpression): [symbol!] */ TODO
			}
			result := forEachEntry(symbols, func(symbolFromSymbolTable /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
				if symbolFromSymbolTable.flags&SymbolFlagsAlias && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbolFromSymbolTable.escapedName !== InternalSymbolName.ExportEquals */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbolFromSymbolTable.escapedName !== InternalSymbolName.Default */ TODO && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration))) && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration)) && ( /* TODO(ConditionalExpression): isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true */ TODO) && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)) {
					resolvedImportedSymbol := resolveAlias(symbolFromSymbolTable)
					candidate := getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)
					if candidate {
						return candidate
					}
				}
				if symbolFromSymbolTable.escapedName == /* TODO(NonNullExpression): symbol! */ TODO.escapedName && symbolFromSymbolTable.exportSymbol {
					if isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), nil, ignoreQualification) {
						return /* TODO(ArrayLiteralExpression): [symbol!] */ TODO
					}
				}
			})
			return result || ( /* TODO(ConditionalExpression): symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : undefined */ TODO)
		}
		getCandidateListForSymbol := func(symbolFromSymbolTable Symbol, resolvedImportedSymbol Symbol, ignoreQualification /* TODO(BooleanKeyword): boolean */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
			if isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
				return /* TODO(ArrayLiteralExpression): [symbolFromSymbolTable] */ TODO
			}
			candidateTable := getExportsOfSymbol(resolvedImportedSymbol)
			accessibleSymbolsFromExports := candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, true)
			if accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning)) {
				return /* TODO(ArrayLiteralExpression): [symbolFromSymbolTable] */ TODO.concat(accessibleSymbolsFromExports)
			}
		}
	}
	needsQualification := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags) /* TODO(undefined): boolean */ TODO {
		qualify := false
		forEachSymbolTableInScope(enclosingDeclaration, func(symbolTable /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO) /* TODO(undefined): boolean */ TODO {
			symbolFromSymbolTable := getMergedSymbol(symbolTable.get(symbol.escapedName))
			if !symbolFromSymbolTable {
				return false
			}
			if symbolFromSymbolTable == symbol {
				return true
			}
			shouldResolveAlias := symbolFromSymbolTable.flags&SymbolFlagsAlias && !getDeclarationOfKind(symbolFromSymbolTable, SyntaxKindExportSpecifier)
			symbolFromSymbolTable = /* TODO(ConditionalExpression): shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable */ TODO
			flags := /* TODO(ConditionalExpression): shouldResolveAlias ? getSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags */ TODO
			if flags & meaning {
				qualify = true
				return true
			}
			return false
		})
		return qualify
	}
	isPropertyOrMethodDeclarationSymbol := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if symbol.declarations && symbol.declarations.length {
			for _, declaration := range symbol.declarations {
				/* TODO(SwitchStatement): switch (declaration.kind) {                     case SyntaxKind.PropertyDeclaration:                     case SyntaxKind.MethodDeclaration:                     case SyntaxKind.GetAccessor:                     case SyntaxKind.SetAccessor:                         continue;                     default:                         return false;                 } */
			}
			return true
		}
		return false
	}
	isTypeSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsType, false, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isValueSymbolAccessible := func(typeSymbol Symbol, enclosingDeclaration Node) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, SymbolFlagsValue, false, true)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isSymbolAccessibleByFlags := func(typeSymbol Symbol, enclosingDeclaration Node, flags SymbolFlags) bool {
		access := isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, false, false)
		return access.accessibility == SymbolAccessibilityAccessible
	}
	isAnySymbolAccessible := func(symbols /* TODO(ArrayType): Symbol[] */ any, enclosingDeclaration Node, initialSymbol Symbol, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) *SymbolAccessibilityResult {
		if !length(symbols) {
		}
		var hadAccessibleChain *Symbol
		earlyModuleBail := false
		for _, symbol := range /* TODO(NonNullExpression): symbols! */ TODO {
			accessibleSymbolChain := getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, false)
			if accessibleSymbolChain {
				hadAccessibleChain = symbol
				hasAccessibleDeclarations := hasVisibleDeclarations( /* TODO(ElementAccessExpression): accessibleSymbolChain[0] */ TODO, shouldComputeAliasesToMakeVisible)
				if hasAccessibleDeclarations {
					return hasAccessibleDeclarations
				}
			}
			if allowModules {
				if some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					if shouldComputeAliasesToMakeVisible {
						earlyModuleBail = true
						/* TODO(ContinueStatement): continue; */
					}
					return /* TODO(ObjectLiteralExpression): {                         accessibility: SymbolAccessibility.Accessible,                     } */ TODO
				}
			}
			containers := getContainersOfSymbol(symbol, enclosingDeclaration, meaning)
			parentResult := isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol /* TODO(ConditionalExpression): initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning */, TODO, shouldComputeAliasesToMakeVisible, allowModules)
			if parentResult {
				return parentResult
			}
		}
		if earlyModuleBail {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.Accessible,             } */ TODO
		}
		if hadAccessibleChain {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),                 errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, SymbolFlags.Namespace) : undefined,             } */ TODO
		}
	}
	isSymbolAccessible := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool) SymbolAccessibilityResult {
		return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, true)
	}
	isSymbolAccessibleWorker := func(symbol *Symbol, enclosingDeclaration Node, meaning SymbolFlags, shouldComputeAliasesToMakeVisible bool, allowModules bool) SymbolAccessibilityResult {
		if symbol && enclosingDeclaration {
			result := isAnySymbolAccessible( /* TODO(ArrayLiteralExpression): [symbol] */ TODO, enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules)
			if result {
				return result
			}
			symbolExternalModule := forEach(symbol.declarations, getExternalModuleContainer)
			if symbolExternalModule {
				enclosingExternalModule := getExternalModuleContainer(enclosingDeclaration)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbolExternalModule !== enclosingExternalModule */ TODO {
					return /* TODO(ObjectLiteralExpression): {                         accessibility: SymbolAccessibility.CannotBeNamed,                         errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),                         errorModuleName: symbolToString(symbolExternalModule),                         errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : undefined,                     } */ TODO
				}
			}
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotAccessible,                 errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),             } */ TODO
		}
		return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
	}
	getExternalModuleContainer := func(declaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		node := findAncestor(declaration, hasExternalModuleSymbol)
		return node && getSymbolOfDeclaration(node /* as */ /* TODO(UnionType): AmbientModuleDeclaration | SourceFile */)
	}
	hasExternalModuleSymbol := func(declaration Node) /* TODO(undefined): boolean */ TODO {
		return isAmbientModule(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration /* as */ /* TODO(TypeReference): SourceFile */))
	}
	hasNonGlobalAugmentationExternalModuleSymbol := func(declaration Node) /* TODO(undefined): boolean */ TODO {
		return isModuleWithStringLiteralName(declaration) || (declaration.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(declaration /* as */ /* TODO(TypeReference): SourceFile */))
	}
	hasVisibleDeclarations := func(symbol Symbol, shouldComputeAliasToMakeVisible bool) *SymbolVisibilityResult {
		var aliasesToMakeVisible /* TODO(ArrayType): LateVisibilityPaintedStatement[] */ any
		if !every(filter(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PropertyAccessExpression): d.kind */
			/* TODO(ExclamationEqualsEqualsToken): !== */
			/* TODO(PropertyAccessExpression): SyntaxKind.Identifier */
		}), getIsDeclarationVisible) {
			return nil
		}
		return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible, aliasesToMakeVisible } */ TODO
		getIsDeclarationVisible := func(declaration Declaration) /* TODO(undefined): boolean */ TODO {
			if !isDeclarationVisible(declaration) {
				anyImportSyntax := getAnyImportSyntax(declaration)
				if anyImportSyntax && !hasSyntacticModifier(anyImportSyntax, ModifierFlagsExport) && isDeclarationVisible(anyImportSyntax.parent) {
					return addVisibleAlias(declaration, anyImportSyntax)
				} else if isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) && !hasSyntacticModifier(declaration.parent.parent, ModifierFlagsExport) && isDeclarationVisible(declaration.parent.parent.parent) {
					return addVisibleAlias(declaration, declaration.parent.parent)
				} else if isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration, ModifierFlagsExport) && isDeclarationVisible(declaration.parent) {
					return addVisibleAlias(declaration, declaration)
				} else if isBindingElement(declaration) {
					if symbol.flags&SymbolFlagsAlias && isInJSFile(declaration) && declaration.parent.parent && isVariableDeclaration(declaration.parent.parent) && declaration.parent.parent.parent.parent && isVariableStatement(declaration.parent.parent.parent.parent) && !hasSyntacticModifier(declaration.parent.parent.parent.parent, ModifierFlagsExport) && declaration.parent.parent.parent.parent.parent && isDeclarationVisible(declaration.parent.parent.parent.parent.parent) {
						return addVisibleAlias(declaration, declaration.parent.parent.parent.parent)
					} else if symbol.flags & SymbolFlagsBlockScopedVariable {
						variableStatement := /* TODO(NonNullExpression): findAncestor(declaration, isVariableStatement)! */ TODO
						if hasSyntacticModifier(variableStatement, ModifierFlagsExport) {
							return true
						}
						if !isDeclarationVisible(variableStatement.parent) {
							return false
						}
						return addVisibleAlias(declaration, variableStatement)
					}
				}
				return false
			}
			return true
		}
		addVisibleAlias := func(declaration Declaration, aliasingStatement LateVisibilityPaintedStatement) /* TODO(undefined): boolean */ TODO {
			if shouldComputeAliasToMakeVisible {
				getNodeLinks(declaration).isVisible = true
				aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement)
			}
			return true
		}
	}
	getMeaningOfEntityNameReference := func(entityName EntityNameOrEntityNameExpression) SymbolFlags {
		var meaning SymbolFlags
		if entityName.parent.kind == SyntaxKindTypeQuery || entityName.parent.kind == SyntaxKindExpressionWithTypeArguments && !isPartOfTypeNode(entityName.parent) || entityName.parent.kind == SyntaxKindComputedPropertyName || entityName.parent.kind == SyntaxKindTypePredicate && (entityName.parent /* as */ /* TODO(TypeReference): TypePredicateNode */).parameterName == entityName {
			meaning = SymbolFlagsValue | SymbolFlagsExportValue
		} else if entityName.kind == SyntaxKindQualifiedName || entityName.kind == SyntaxKindPropertyAccessExpression || entityName.parent.kind == SyntaxKindImportEqualsDeclaration || (entityName.parent.kind == SyntaxKindQualifiedName && (entityName.parent /* as */ /* TODO(TypeReference): QualifiedName */).left == entityName) || (entityName.parent.kind == SyntaxKindPropertyAccessExpression && (entityName.parent /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression == entityName) || (entityName.parent.kind == SyntaxKindElementAccessExpression && (entityName.parent /* as */ /* TODO(TypeReference): ElementAccessExpression */).expression == entityName) {
			meaning = SymbolFlagsNamespace
		} else {
			meaning = SymbolFlagsType
		}
		return meaning
	}
	isEntityNameVisible := func(entityName EntityNameOrEntityNameExpression, enclosingDeclaration Node, shouldComputeAliasToMakeVisible /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) SymbolVisibilityResult {
		meaning := getMeaningOfEntityNameReference(entityName)
		firstIdentifier := getFirstIdentifier(entityName)
		symbol := resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, nil, false)
		if symbol && symbol.flags&SymbolFlagsTypeParameter && meaning&SymbolFlagsType {
			return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, false, false)), firstIdentifier, meaning, false).accessibility == SymbolAccessibilityAccessible {
			return /* TODO(ObjectLiteralExpression): { accessibility: SymbolAccessibility.Accessible } */ TODO
		}
		if !symbol {
			return /* TODO(ObjectLiteralExpression): {                 accessibility: SymbolAccessibility.NotResolved,                 errorSymbolName: getTextOfNode(firstIdentifier),                 errorNode: firstIdentifier,             } */ TODO
		}
		return hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) || /* TODO(ObjectLiteralExpression): {             accessibility: SymbolAccessibility.NotAccessible,             errorSymbolName: getTextOfNode(firstIdentifier),             errorNode: firstIdentifier,         } */ TODO
	}
	symbolToString := func(symbol Symbol, enclosingDeclaration Node, meaning SymbolFlags, flags SymbolFormatFlags /* = */ /* TODO(PropertyAccessExpression): SymbolFormatFlags.AllowAnyNodeKind */, writer EmitTextWriter) string {
		nodeFlags := NodeBuilderFlagsIgnoreErrors
		internalNodeFlags := InternalNodeBuilderFlagsNone
		if flags & SymbolFormatFlagsUseOnlyExternalAliasing {
			nodeFlags |= NodeBuilderFlagsUseOnlyExternalAliasing
		}
		if flags & SymbolFormatFlagsWriteTypeParametersOrArguments {
			nodeFlags |= NodeBuilderFlagsWriteTypeParametersInQualifiedName
		}
		if flags & SymbolFormatFlagsUseAliasDefinedOutsideCurrentScope {
			nodeFlags |= NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope
		}
		if flags & SymbolFormatFlagsDoNotIncludeSymbolChain {
			internalNodeFlags |= InternalNodeBuilderFlagsDoNotIncludeSymbolChain
		}
		if flags & SymbolFormatFlagsWriteComputedProps {
			internalNodeFlags |= InternalNodeBuilderFlagsWriteComputedProps
		}
		builder := /* TODO(ConditionalExpression): flags & SymbolFormatFlags.AllowAnyNodeKind ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName */ TODO
		return /* TODO(ConditionalExpression): writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(symbolToStringWorker) */ TODO
		symbolToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			entity := /* TODO(NonNullExpression): builder(symbol, meaning!, enclosingDeclaration, nodeFlags, internalNodeFlags)! */ TODO
			printer := /* TODO(ConditionalExpression): enclosingDeclaration?.kind === SyntaxKind.SourceFile                 ? createPrinterWithRemoveCommentsNeverAsciiEscape()                 : createPrinterWithRemoveComments() */ TODO
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, entity, sourceFile, writer)
			return writer
		}
	}
	signatureToString := func(signature Signature, enclosingDeclaration Node, flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.None */, kind SignatureKind, writer EmitTextWriter) string {
		return /* TODO(ConditionalExpression): writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker) */ TODO
		signatureToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			var sigOutput SyntaxKind
			if flags & TypeFormatFlagsWriteArrowStyleSignature {
				sigOutput = /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? SyntaxKind.ConstructorType : SyntaxKind.FunctionType */ TODO
			} else {
				sigOutput = /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? SyntaxKind.ConstructSignature : SyntaxKind.CallSignature */ TODO
			}
			sig := nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|NodeBuilderFlagsWriteTypeParametersInQualifiedName)
			printer := createPrinterWithRemoveCommentsOmitTrailingSemicolon()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified /* TODO(NonNullExpression): sig! */, TODO, sourceFile, getTrailingSemicolonDeferringWriter(writer))
			return writer
		}
	}
	typeToString := func(type_ Type, enclosingDeclaration Node, flags TypeFormatFlags /* = */ /* TODO(BinaryExpression): TypeFormatFlags.AllowUniqueESSymbolType | TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter /* = */ /* TODO(CallExpression): createTextWriter("") */) string {
		noTruncation := compilerOptions.noErrorTruncation || flags&TypeFormatFlagsNoTruncation
		typeNode := nodeBuilder.typeToTypeNode(type_, enclosingDeclaration, toNodeBuilderFlags(flags)|NodeBuilderFlagsIgnoreErrors|( /* TODO(ConditionalExpression): noTruncation ? NodeBuilderFlags.NoTruncation : NodeBuilderFlags.None */ TODO), nil)
		if typeNode == nil {
			/* TODO(CallExpression): Debug.fail("should always get typenode") */
		}
		printer := /* TODO(ConditionalExpression): type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults() */ TODO
		sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
		printer.writeNode(EmitHintUnspecified, typeNode, sourceFile, writer)
		result := writer.getText()
		maxLength := /* TODO(ConditionalExpression): noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2 */ TODO
		if maxLength && result && result.length >= maxLength {
			return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): result.substr(0, maxLength - "...".length) + "..." */ TODO
		}
		return result
	}
	getTypeNamesForErrorDisplay := func(left Type, right Type) /* TODO(TupleType): [string, string] */ TODO {
		leftStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left) */ TODO
		rightStr := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right) */ TODO
		if leftStr == rightStr {
			leftStr = getTypeNameForErrorDisplay(left)
			rightStr = getTypeNameForErrorDisplay(right)
		}
		return /* TODO(ArrayLiteralExpression): [leftStr, rightStr] */ TODO
	}
	getTypeNameForErrorDisplay := func(type_ Type) /* TODO(undefined): string */ TODO {
		return typeToString(type_, nil, TypeFormatFlagsUseFullyQualifiedType)
	}
	symbolValueDeclarationIsContextSensitive := func(symbol Symbol) bool {
		return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration)
	}
	toNodeBuilderFlags := func(flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFormatFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.None */) NodeBuilderFlags {
		return flags & TypeFormatFlagsNodeBuilderFlagsMask
	}
	isClassInstanceSide := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!type_.symbol && !!(type_.symbol.flags & SymbolFlagsClass) && (type_ == getDeclaredTypeOfClassOrInterface(type_.symbol) || (!!(type_.flags & TypeFlagsObject) && !!(getObjectFlags(type_) & ObjectFlagsIsClassInstanceClone)))
	}
	getTypeFromTypeNodeWithoutContext := func(node TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeFromTypeNode(node)
	}
	createNodeBuilder := func() /* TODO(undefined): { typeToTypeNode: (type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; typePredicateToTypePredicateNode: (typePredicate: import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicateNode | undefined; expressionOrTypeToTypeNode: (expr: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeValue | undefined, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, addUndefined?: boolean | undefined, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeTypeForDeclaration: (declaration: import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration, type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; serializeReturnTypeForSignature: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined; indexInfoToIndexSignatureDeclaration: (indexInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined; signatureToSignatureDeclaration: (signature: import("/home/jabaile/work/TypeScript/src/compiler/types").Signature, kind: import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.Constructor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.GetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.SetAccessor | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.CallSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.IndexSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ConstructorType | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.ArrowFunction | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.JSDocFunctionType, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | undefined; symbolToEntityName: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").EntityName | undefined; symbolToExpression: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; symbolToTypeParameterDeclarations: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined; symbolToParameterDeclaration: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined; typeParameterToDeclaration: (parameter: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration | undefined; symbolTableToDeclarationStatements: (symbolTable: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] | undefined; symbolToNode: (symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol, meaning: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolFlags, enclosingDeclaration?: import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined, flags?: import("/home/jabaile/work/TypeScript/src/compiler/types").NodeBuilderFlags | undefined, internalFlags?: import("/home/jabaile/work/TypeScript/src/compiler/types").InternalNodeBuilderFlags | undefined, tracker?: import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTracker | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined; } */ TODO {
		return /* TODO(ObjectLiteralExpression): {             typeToTypeNode: (type: Type, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeToTypeNodeHelper(type, context)),             typePredicateToTypePredicateNode: (typePredicate: TypePredicate, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typePredicateToTypePredicateNodeHelper(typePredicate, context)),             expressionOrTypeToTypeNode: (expr: Expression | JsxAttributeValue | undefined, type: Type, addUndefined?: boolean, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => expressionOrTypeToTypeNode(context, expr, type, addUndefined)),             serializeTypeForDeclaration: (declaration: Declaration, type: Type, symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeTypeForDeclaration(context, declaration, type, symbol)),             serializeReturnTypeForSignature: (signature: Signature, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => serializeReturnTypeForSignature(context, signature)),             indexInfoToIndexSignatureDeclaration: (indexInfo: IndexInfo, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, /*typeNode* / undefined)),             signatureToSignatureDeclaration: (signature: Signature, kind: SignatureDeclaration["kind"], enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => signatureToSignatureDeclarationHelper(signature, kind, context)),             symbolToEntityName: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToName(symbol, context, meaning, /*expectsIdentifier* / false)),             symbolToExpression: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToExpression(symbol, context, meaning)),             symbolToTypeParameterDeclarations: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParametersToTypeParameterDeclarations(symbol, context)),             symbolToParameterDeclaration: (symbol: Symbol, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToParameterDeclaration(symbol, context)),             typeParameterToDeclaration: (parameter: TypeParameter, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => typeParameterToDeclaration(parameter, context)),             symbolTableToDeclarationStatements: (symbolTable: SymbolTable, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolTableToDeclarationStatements(symbolTable, context)),             symbolToNode: (symbol: Symbol, meaning: SymbolFlags, enclosingDeclaration?: Node, flags?: NodeBuilderFlags, internalFlags?: InternalNodeBuilderFlags, tracker?: SymbolTracker) => withContext(enclosingDeclaration, flags, internalFlags, tracker, context => symbolToNode(symbol, context, meaning)),         } */ TODO
		// OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): false */ TODO) Type
		// OVERLOAD: getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes /* TODO(LiteralType): true */ TODO) *Type
		getTypeFromTypeNode := func(context NodeBuilderContext, node TypeNode, noMappedTypes bool) *Type {
			type_ := getTypeFromTypeNodeWithoutContext(node)
			if !context.mapper {
				/* TODO(Identifier): type */
			}
			mappedType := instantiateType(type_, context.mapper)
			return /* TODO(ConditionalExpression): noMappedTypes && mappedType !== type ? undefined : mappedType */ TODO
		}
		setTextRange := func(context NodeBuilderContext, range_ T, location Node) T {
			if !nodeIsSynthesized(range_) || !(range_.flags & NodeFlagsSynthesized) || !context.enclosingFile || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): context.enclosingFile !== getSourceFileOfNode(getOriginalNode(range)) */ TODO {
				range_ = factory.cloneNode(range_)
			}
			if range_ == location {
				/* TODO(Identifier): range */
			}
			if !location {
				return range_
			}
			original := range_.original
			/* TODO(WhileStatement): while (original && original !== location) {                 original = original.original;             } */
			if !original {
				setOriginalNode(range_, location)
			}
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(getOriginalNode(location)) {
				return setTextRangeWorker(range_, location)
			}
			return range_
		}
		expressionOrTypeToTypeNode := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			restoreFlags := saveRestoreFlags(context)
			if expr && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfExpression(expr, context, addUndefined)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			result := expressionOrTypeToTypeNodeHelper(context, expr, type_, addUndefined)
			restoreFlags()
			return result
		}
		expressionOrTypeToTypeNodeHelper := func(context NodeBuilderContext, expr /* TODO(UnionType): Expression | JsxAttributeValue | undefined */ any, type_ Type, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			if expr {
				typeNode := /* TODO(ConditionalExpression): isAssertionExpression(expr) ? expr.type                     : isJSDocTypeAssertion(expr) ? getJSDocTypeAssertionType(expr)                     : undefined */ TODO
				if typeNode && !isConstTypeReference(typeNode) {
					result := tryReuseExistingTypeNode(context, typeNode, type_, expr.parent, addUndefined)
					if result {
						return result
					}
				}
			}
			if addUndefined {
				type_ = getOptionalType(type_)
			}
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode, type_ Type, host Node, addUndefined bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			originalType := type_
			if addUndefined {
				type_ = getOptionalType(type_, !isParameter(host))
			}
			clone := tryReuseExistingNonParameterTypeNode(context, typeNode, type_, host)
			if clone {
				if addUndefined && containsNonMissingUndefinedType(type_) && !someType(getTypeFromTypeNode(context, typeNode), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.Undefined) */
				}) {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [clone, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
				return clone
			}
			if addUndefined && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): originalType !== type */ TODO {
				cloneMissingUndefined := tryReuseExistingNonParameterTypeNode(context, typeNode, originalType, host)
				if cloneMissingUndefined {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [cloneMissingUndefined, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
			}
			return nil
		}
		tryReuseExistingNonParameterTypeNode := func(context NodeBuilderContext, existing TypeNode, type_ Type, host /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO /* = */ /* TODO(PropertyAccessExpression): context.enclosingDeclaration */, annotationType /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /* = */ /* TODO(CallExpression): getTypeFromTypeNode(context, existing, /*noMappedTypes* / true) */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			if annotationType && typeNodeIsEquivalentToType(host, type_, annotationType) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) {
				result := tryReuseExistingTypeNodeHelper(context, existing)
				if result {
					return result
				}
			}
			return nil
		}
		symbolToNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
			if context.internalFlags & InternalNodeBuilderFlagsWriteComputedProps {
				if symbol.valueDeclaration {
					name := getNameOfDeclaration(symbol.valueDeclaration)
					if name && isComputedPropertyName(name) {
						/* TODO(Identifier): name */
					}
				}
				nameType := getSymbolLinks(symbol).nameType
				if nameType && nameType.flags&(TypeFlagsEnumLiteral|TypeFlagsUniqueESSymbol) {
					context.enclosingDeclaration = nameType.symbol.valueDeclaration
					return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning))
				}
			}
			return symbolToExpression(symbol, context, meaning)
		}
		withContext := func(enclosingDeclaration Node, flags *NodeBuilderFlags, internalFlags *InternalNodeBuilderFlags, tracker *SymbolTracker, cb func(context NodeBuilderContext) T) *T {
			moduleResolverHost := /* TODO(ConditionalExpression): tracker?.trackSymbol ? tracker.moduleResolverHost :                 (internalFlags || InternalNodeBuilderFlags.None) & InternalNodeBuilderFlags.DoNotIncludeSymbolChain ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) :                 undefined */ TODO
			var context NodeBuilderContext = /* TODO(ObjectLiteralExpression): {                 enclosingDeclaration,                 enclosingFile: enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration),                 flags: flags || NodeBuilderFlags.None,                 internalFlags: internalFlags || InternalNodeBuilderFlags.None,                 tracker: undefined!,                 encounteredError: false,                 reportedDiagnostic: false,                 visitedTypes: undefined,                 symbolDepth: undefined,                 inferTypeParameters: undefined,                 approximateLength: 0,                 trackedSymbols: undefined,                 bundled: !!compilerOptions.outFile && !!enclosingDeclaration && isExternalOrCommonJsModule(getSourceFileOfNode(enclosingDeclaration)),                 truncating: false,                 usedSymbolNames: undefined,                 remappedSymbolNames: undefined,                 remappedSymbolReferences: undefined,                 reverseMappedStack: undefined,                 mustCreateTypeParameterSymbolList: true,                 typeParameterSymbolList: undefined,                 mustCreateTypeParametersNamesLookups: true,                 typeParameterNames: undefined,                 typeParameterNamesByText: undefined,                 typeParameterNamesByTextNextNameCount: undefined,                 mapper: undefined,             } */ TODO
			context.tracker = /* TODO(NewExpression): new SymbolTrackerImpl(context, tracker, moduleResolverHost) */ TODO
			resultingNode := cb(context)
			if context.truncating && context.flags&NodeBuilderFlagsNoTruncation {
				context.tracker.reportTruncationError()
			}
			return /* TODO(ConditionalExpression): context.encounteredError ? undefined : resultingNode */ TODO
		}
		saveRestoreFlags := func(context NodeBuilderContext) /* TODO(undefined): () => void */ TODO {
			flags := context.flags
			internalFlags := context.internalFlags
			return restore
			restore := func() {
				context.flags = flags
				context.internalFlags = internalFlags
			}
		}
		checkTruncationLength := func(context NodeBuilderContext) bool {
			if context.truncating {
				/* TODO(PropertyAccessExpression): context.truncating */
			}
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): context.truncating = context.approximateLength > ((context.flags & NodeBuilderFlags.NoTruncation) ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength) */ TODO
		}
		typeToTypeNodeHelper := func(type_ Type, context NodeBuilderContext) TypeNode {
			restoreFlags := saveRestoreFlags(context)
			typeNode := typeToTypeNodeWorker(type_, context)
			restoreFlags()
			return typeNode
		}
		typeToTypeNodeWorker := func(type_ Type, context NodeBuilderContext) TypeNode {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			inTypeAlias := context.flags & NodeBuilderFlagsInTypeAlias
			context.flags &= ~NodeBuilderFlagsInTypeAlias
			if !type_ {
				if !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
					context.encounteredError = true
					return /* TODO(NonNullExpression): undefined! */ TODO
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			if !(context.flags & NodeBuilderFlagsNoTypeReduction) {
				type_ = getReducedType(type_)
			}
			if type_.flags & TypeFlagsAny {
				if type_.aliasSymbol {
					return factory.createTypeReferenceNode(symbolToEntityNameNode(type_.aliasSymbol), mapToTypeNodes(type_.aliasTypeArguments, context))
				}
				if type_ == unresolvedType {
					return addSyntheticLeadingComment(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), SyntaxKindMultiLineCommentTrivia, "unresolved")
				}
				context.approximateLength += 3
				return factory.createKeywordTypeNode( /* TODO(ConditionalExpression): type === intrinsicMarkerType ? SyntaxKind.IntrinsicKeyword : SyntaxKind.AnyKeyword */ TODO)
			}
			if type_.flags & TypeFlagsUnknown {
				return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
			}
			if type_.flags & TypeFlagsString {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindStringKeyword)
			}
			if type_.flags & TypeFlagsNumber {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindNumberKeyword)
			}
			if type_.flags & TypeFlagsBigInt {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindBigIntKeyword)
			}
			if type_.flags&TypeFlagsBoolean && !type_.aliasSymbol {
				context.approximateLength += 7
				return factory.createKeywordTypeNode(SyntaxKindBooleanKeyword)
			}
			if type_.flags & TypeFlagsEnumLike {
				if type_.symbol.flags & SymbolFlagsEnumMember {
					parentSymbol := /* TODO(NonNullExpression): getParentOfSymbol(type.symbol)! */ TODO
					parentName := symbolToTypeNode(parentSymbol, context, SymbolFlagsType)
					if getDeclaredTypeOfSymbol(parentSymbol) == type_ {
						return parentName
					}
					memberName := symbolName(type_.symbol)
					if isIdentifierText(memberName, ScriptTargetES5) {
						return appendReferenceToType(parentName /* as */ /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */, factory.createTypeReferenceNode(memberName, nil))
					}
					if isImportTypeNode(parentName) {
						(parentName /* as */ /* TODO(AnyKeyword): any */).isTypeOf = true
						return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else if isTypeReferenceNode(parentName) {
						return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)))
					} else {
						return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.")
					}
				}
				return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
			}
			if type_.flags & TypeFlagsStringLiteral {
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (type as StringLiteralType).value.length + 2 */ TODO
				return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral((type_ /* as */ /* TODO(TypeReference): StringLiteralType */).value, !!(context.flags&NodeBuilderFlagsUseSingleQuotesForStringLiteralType)), EmitFlagsNoAsciiEscaping))
			}
			if type_.flags & TypeFlagsNumberLiteral {
				value := (type_ /* as */ /* TODO(TypeReference): NumberLiteralType */).value
				context.approximateLength += ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + value */ TODO).length
				return factory.createLiteralTypeNode( /* TODO(ConditionalExpression): value < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-value)) : factory.createNumericLiteral(value) */ TODO)
			}
			if type_.flags & TypeFlagsBigIntLiteral {
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (pseudoBigIntToString((type as BigIntLiteralType).value).length) + 1 */ TODO
				return factory.createLiteralTypeNode(factory.createBigIntLiteral((type_ /* as */ /* TODO(TypeReference): BigIntLiteralType */).value))
			}
			if type_.flags & TypeFlagsBooleanLiteral {
				context.approximateLength += (type_ /* as */ /* TODO(TypeReference): IntrinsicType */).intrinsicName.length
				return factory.createLiteralTypeNode( /* TODO(ConditionalExpression): (type as IntrinsicType).intrinsicName === "true" ? factory.createTrue() : factory.createFalse() */ TODO)
			}
			if type_.flags & TypeFlagsUniqueESSymbol {
				if !(context.flags & NodeBuilderFlagsAllowUniqueESSymbolType) {
					if isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
						context.approximateLength += 6
						return symbolToTypeNode(type_.symbol, context, SymbolFlagsValue)
					}
					if context.tracker.reportInaccessibleUniqueSymbolError {
						context.tracker.reportInaccessibleUniqueSymbolError()
					}
				}
				context.approximateLength += 13
				return factory.createTypeOperatorNode(SyntaxKindUniqueKeyword, factory.createKeywordTypeNode(SyntaxKindSymbolKeyword))
			}
			if type_.flags & TypeFlagsVoid {
				context.approximateLength += 4
				return factory.createKeywordTypeNode(SyntaxKindVoidKeyword)
			}
			if type_.flags & TypeFlagsUndefined {
				context.approximateLength += 9
				return factory.createKeywordTypeNode(SyntaxKindUndefinedKeyword)
			}
			if type_.flags & TypeFlagsNull {
				context.approximateLength += 4
				return factory.createLiteralTypeNode(factory.createNull())
			}
			if type_.flags & TypeFlagsNever {
				context.approximateLength += 5
				return factory.createKeywordTypeNode(SyntaxKindNeverKeyword)
			}
			if type_.flags & TypeFlagsESSymbol {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindSymbolKeyword)
			}
			if type_.flags & TypeFlagsNonPrimitive {
				context.approximateLength += 6
				return factory.createKeywordTypeNode(SyntaxKindObjectKeyword)
			}
			if isThisTypeParameter(type_) {
				if context.flags & NodeBuilderFlagsInObjectTypeLiteral {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowThisInObjectLiteral) {
						context.encounteredError = true
					}
					context.tracker.reportInaccessibleThisError()
				}
				context.approximateLength += 4
				return factory.createThisTypeNode()
			}
			if !inTypeAlias && type_.aliasSymbol && (context.flags&NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope || isTypeSymbolAccessible(type_.aliasSymbol, context.enclosingDeclaration)) {
				typeArgumentNodes := mapToTypeNodes(type_.aliasTypeArguments, context)
				if isReservedMemberName(type_.aliasSymbol.escapedName) && !(type_.aliasSymbol.flags & SymbolFlagsClass) {
					/* TODO(CallExpression): factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes) */
				}
				if length(typeArgumentNodes) == 1 && type_.aliasSymbol == globalArrayType.symbol {
					return factory.createArrayTypeNode( /* TODO(ElementAccessExpression): typeArgumentNodes![0] */ TODO)
				}
				return symbolToTypeNode(type_.aliasSymbol, context, SymbolFlagsType, typeArgumentNodes)
			}
			objectFlags := getObjectFlags(type_)
			if objectFlags & ObjectFlagsReference {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				return /* TODO(ConditionalExpression): (type as TypeReference).node ? visitAndTransformType(type as TypeReference, typeReferenceToTypeNode) : typeReferenceToTypeNode(type as TypeReference) */ TODO
			}
			if type_.flags&TypeFlagsTypeParameter || objectFlags&ObjectFlagsClassOrInterface {
				if type_.flags&TypeFlagsTypeParameter && contains(context.inferTypeParameters, type_) {
					context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName(type.symbol).length + 6 */ TODO
					var constraintNode *TypeNode
					constraint := getConstraintOfTypeParameter(type_ /* as */ /* TODO(TypeReference): TypeParameter */)
					if constraint {
						inferredConstraint := getInferredTypeParameterConstraint(type_ /* as */ /* TODO(TypeReference): TypeParameter */, true)
						if !(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint)) {
							context.approximateLength += 9
							constraintNode = constraint && typeToTypeNodeHelper(constraint, context)
						}
					}
					return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type_ /* as */ /* TODO(TypeReference): TypeParameter */, context, constraintNode))
				}
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.flags&TypeFlagsTypeParameter {
					name := typeParameterToName(type_, context)
					context.approximateLength += idText(name).length
					return factory.createTypeReferenceNode(factory.createIdentifier(idText(name)), nil)
				}
				if type_.symbol {
					return symbolToTypeNode(type_.symbol, context, SymbolFlagsType)
				}
				name := /* TODO(ConditionalExpression): (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ?                     (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?" */ TODO
				return factory.createTypeReferenceNode(factory.createIdentifier(name), nil)
			}
			if type_.flags&TypeFlagsUnion && (type_ /* as */ /* TODO(TypeReference): UnionType */).origin {
				type_ = /* TODO(NonNullExpression): (type as UnionType).origin! */ TODO
			}
			if type_.flags & (TypeFlagsUnion | TypeFlagsIntersection) {
				types := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? formatUnionTypes((type as UnionType).types) : (type as IntersectionType).types */ TODO
				if length(types) == 1 {
					return typeToTypeNodeHelper( /* TODO(ElementAccessExpression): types[0] */ TODO, context)
				}
				typeNodes := mapToTypeNodes(types, context, true)
				if typeNodes && typeNodes.length > 0 {
					return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? factory.createUnionTypeNode(typeNodes) : factory.createIntersectionTypeNode(typeNodes) */ TODO
				} else {
					if !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowEmptyUnionOrIntersection) {
						context.encounteredError = true
					}
					return /* TODO(NonNullExpression): undefined! */ TODO
				}
			}
			if objectFlags & (ObjectFlagsAnonymous | ObjectFlagsMapped) {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				return createAnonymousTypeNode(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			}
			if type_.flags & TypeFlagsIndex {
				indexedType := (type_ /* as */ /* TODO(TypeReference): IndexType */).type_
				context.approximateLength += 6
				indexTypeNode := typeToTypeNodeHelper(indexedType, context)
				return factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, indexTypeNode)
			}
			if type_.flags & TypeFlagsTemplateLiteral {
				texts := (type_ /* as */ /* TODO(TypeReference): TemplateLiteralType */).texts
				types := (type_ /* as */ /* TODO(TypeReference): TemplateLiteralType */).types
				templateHead := factory.createTemplateHead( /* TODO(ElementAccessExpression): texts[0] */ TODO)
				templateSpans := factory.createNodeArray(map_(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralTypeSpan */ TODO {
					/* TODO(PropertyAccessExpression): factory.createTemplateLiteralTypeSpan */
					/* TODO(CallExpression): typeToTypeNodeHelper(t, context) */
					/* TODO(CallExpression): (i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail)(texts[i + 1]) */
				}))
				context.approximateLength += 2
				return factory.createTemplateLiteralType(templateHead, templateSpans)
			}
			if type_.flags & TypeFlagsStringMapping {
				typeNode := typeToTypeNodeHelper((type_ /* as */ /* TODO(TypeReference): StringMappingType */).type_, context)
				return symbolToTypeNode((type_ /* as */ /* TODO(TypeReference): StringMappingType */).symbol, context, SymbolFlagsType /* TODO(ArrayLiteralExpression): [typeNode] */, TODO)
			}
			if type_.flags & TypeFlagsIndexedAccess {
				objectTypeNode := typeToTypeNodeHelper((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType, context)
				indexTypeNode := typeToTypeNodeHelper((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType, context)
				context.approximateLength += 2
				return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode)
			}
			if type_.flags & TypeFlagsConditional {
				return visitAndTransformType(type_, func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ TODO {
					/* TODO(Identifier): conditionalTypeToTypeNode */
					/* TODO(AsExpression): type as ConditionalType */
				})
			}
			if type_.flags & TypeFlagsSubstitution {
				typeNode := typeToTypeNodeHelper((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType, context)
				noInferSymbol := isNoInferType(type_) && getGlobalTypeSymbol("NoInfer" /* as */ /* TODO(TypeReference): __String */, false)
				return /* TODO(ConditionalExpression): noInferSymbol ? symbolToTypeNode(noInferSymbol, context, SymbolFlags.Type, [typeNode]) : typeNode */ TODO
			}
			return Debug.fail("Should be unreachable.")
			conditionalTypeToTypeNode := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode */ TODO {
				checkTypeNode := typeToTypeNodeHelper(type_.checkType, context)
				context.approximateLength += 15
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && type_.root.isDistributive && !(type_.checkType.flags & TypeFlagsTypeParameter) {
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T" /* as */ /* TODO(TypeReference): __String */))
					name := typeParameterToName(newParam, context)
					newTypeVariable := factory.createTypeReferenceNode(name)
					context.approximateLength += 37
					newMapper := prependTypeMapping(type_.root.checkType, newParam, type_.mapper)
					saveInferTypeParameters := context.inferTypeParameters
					context.inferTypeParameters = type_.root.inferTypeParameters
					extendsTypeNode := typeToTypeNodeHelper(instantiateType(type_.root.extendsType, newMapper), context)
					context.inferTypeParameters = saveInferTypeParameters
					trueTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.trueType), newMapper))
					falseTypeNode := typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(context, type_.root.node.falseType), newMapper))
					return factory.createConditionalTypeNode(checkTypeNode, factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode(newTypeVariable.typeName) /* as */ /* TODO(TypeReference): Identifier */)), factory.createConditionalTypeNode(factory.createTypeReferenceNode(factory.cloneNode(name)), typeToTypeNodeHelper(type_.checkType, context), factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode, trueTypeNode, falseTypeNode), factory.createKeywordTypeNode(SyntaxKindNeverKeyword)), factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				saveInferTypeParameters := context.inferTypeParameters
				context.inferTypeParameters = type_.root.inferTypeParameters
				extendsTypeNode := typeToTypeNodeHelper(type_.extendsType, context)
				context.inferTypeParameters = saveInferTypeParameters
				trueTypeNode := typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type_))
				falseTypeNode := typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type_))
				return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode)
			}
			typeToTypeNodeOrCircularityElision := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				if type_.flags & TypeFlagsUnion {
					if context.visitedTypes.has(getTypeId(type_)) {
						if !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) {
							context.encounteredError = true
							context.tracker.reportCyclicStructureError()
						}
						return createElidedInformationPlaceholder(context)
					}
					return visitAndTransformType(type_, func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
						/* TODO(Identifier): typeToTypeNodeHelper */
						/* TODO(Identifier): type */
						/* TODO(Identifier): context */
					})
				}
				return typeToTypeNodeHelper(type_, context)
			}
			isMappedTypeHomomorphic := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
				return !!getHomomorphicTypeVariable(type_)
			}
			isHomomorphicMappedTypeWithNonHomomorphicInstantiation := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
				return !!type_.target && isMappedTypeHomomorphic(type_.target /* as */ /* TODO(TypeReference): MappedType */) && !isMappedTypeHomomorphic(type_)
			}
			createMappedTypeNodeFromType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConditionalTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").MappedTypeNode */ TODO {
				Debug.assert(!!(type_.flags & TypeFlagsObject))
				readonlyToken := /* TODO(ConditionalExpression): type.declaration.readonlyToken ? factory.createToken(type.declaration.readonlyToken.kind) as ReadonlyKeyword | PlusToken | MinusToken : undefined */ TODO
				questionToken := /* TODO(ConditionalExpression): type.declaration.questionToken ? factory.createToken(type.declaration.questionToken.kind) as QuestionToken | PlusToken | MinusToken : undefined */ TODO
				var appropriateConstraintTypeNode TypeNode
				var newTypeVariable *TypeReferenceNode
				needsModifierPreservingWrapper := !isMappedTypeWithKeyofConstraintDeclaration(type_) && !(getModifiersTypeFromMappedType(type_).flags & TypeFlagsUnknown) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && !(getConstraintTypeFromMappedType(type_).flags&TypeFlagsTypeParameter && /* TODO(NonNullExpression): getConstraintOfTypeParameter(getConstraintTypeFromMappedType(type))?.flags! */ TODO&TypeFlagsIndex)
				if isMappedTypeWithKeyofConstraintDeclaration(type_) {
					if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
						newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T" /* as */ /* TODO(TypeReference): __String */))
						name := typeParameterToName(newParam, context)
						newTypeVariable = factory.createTypeReferenceNode(name)
					}
					appropriateConstraintTypeNode = factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context))
				} else if needsModifierPreservingWrapper {
					newParam := createTypeParameter(createSymbol(SymbolFlagsTypeParameter, "T" /* as */ /* TODO(TypeReference): __String */))
					name := typeParameterToName(newParam, context)
					newTypeVariable = factory.createTypeReferenceNode(name)
					appropriateConstraintTypeNode = newTypeVariable
				} else {
					appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context)
				}
				typeParameterNode := typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type_), context, appropriateConstraintTypeNode)
				nameTypeNode := /* TODO(ConditionalExpression): type.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type)!, context) : undefined */ TODO
				templateTypeNode := typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type_), !!(getMappedTypeModifiers(type_)&MappedTypeModifiersIncludeOptional)), context)
				mappedTypeNode := factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, nil)
				context.approximateLength += 10
				result := setEmitFlags(mappedTypeNode, EmitFlagsSingleLine)
				if isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type_) && context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
					originalConstraint := instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(context, ( /* TODO(NonNullExpression): type.declaration.typeParameter.constraint! */ TODO /* as */ /* TODO(TypeReference): TypeOperatorNode */).type_) /* as */ /* TODO(TypeReference): TypeParameter */) || unknownType, type_.mapper)
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode( /* TODO(NonNullExpression): newTypeVariable! */ TODO.typeName) /* as */ /* TODO(TypeReference): Identifier */ /* TODO(ConditionalExpression): originalConstraint.flags & TypeFlags.Unknown ? undefined : typeToTypeNodeHelper(originalConstraint, context) */, TODO)), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				} else if needsModifierPreservingWrapper {
					return factory.createConditionalTypeNode(typeToTypeNodeHelper(getConstraintTypeFromMappedType(type_), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(nil, factory.cloneNode( /* TODO(NonNullExpression): newTypeVariable! */ TODO.typeName) /* as */ /* TODO(TypeReference): Identifier */, factory.createTypeOperatorNode(SyntaxKindKeyOfKeyword, typeToTypeNodeHelper(getModifiersTypeFromMappedType(type_), context)))), result, factory.createKeywordTypeNode(SyntaxKindNeverKeyword))
				}
				return result
			}
			createAnonymousTypeNode := func(type_ ObjectType) TypeNode {
				typeId := type_.id
				symbol := type_.symbol
				if symbol {
					isInstantiationExpressionType := !!(getObjectFlags(type_) & ObjectFlagsInstantiationExpressionType)
					if isInstantiationExpressionType {
						instantiationExpressionType := type_ /* as */ /* TODO(TypeReference): InstantiationExpressionType */
						existing := instantiationExpressionType.node
						if isTypeQueryNode(existing) {
							typeNode := tryReuseExistingNonParameterTypeNode(context, existing, type_)
							if typeNode {
								return typeNode
							}
						}
						if context.visitedTypes.has(typeId) {
							return createElidedInformationPlaceholder(context)
						}
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
					isInstanceType := /* TODO(ConditionalExpression): isClassInstanceSide(type) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
					if isJSConstructor(symbol.valueDeclaration) {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if symbol.flags&SymbolFlagsClass && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && (!isClassDeclaration(symbol.valueDeclaration) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO)) || symbol.flags&(SymbolFlagsEnum|SymbolFlagsValueModule) || shouldWriteTypeOfFunctionSymbol() {
						return symbolToTypeNode(symbol, context, isInstanceType)
					} else if context.visitedTypes.has(typeId) {
						typeAlias := getTypeAliasForTypeLiteral(type_)
						if typeAlias {
							return symbolToTypeNode(typeAlias, context, SymbolFlagsType)
						} else {
							return createElidedInformationPlaceholder(context)
						}
					} else {
						return visitAndTransformType(type_, createTypeNodeFromObjectType)
					}
				} else {
					return createTypeNodeFromObjectType(type_)
				}
				shouldWriteTypeOfFunctionSymbol := func() /* TODO(undefined): boolean | undefined */ TODO {
					isStaticMethodSymbol := !!(symbol.flags & SymbolFlagsMethod) && some(symbol.declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(Identifier): isStatic */
						/* TODO(Identifier): declaration */
					})
					isNonLocalFunctionSymbol := !!(symbol.flags & SymbolFlagsFunction) && (symbol.parent || forEach(symbol.declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(BinaryExpression): declaration.parent.kind === SyntaxKind.SourceFile */
						/* TODO(BarBarToken): || */
						/* TODO(BinaryExpression): declaration.parent.kind === SyntaxKind.ModuleBlock */
					}))
					if isStaticMethodSymbol || isNonLocalFunctionSymbol {
						return (!!(context.flags & NodeBuilderFlagsUseTypeOfFunction) || (context.visitedTypes.has(typeId))) && (!(context.flags & NodeBuilderFlagsUseStructuralFallback) || isValueSymbolAccessible(symbol, context.enclosingDeclaration))
					}
				}
			}
			visitAndTransformType := func(type_ T, transform func(type_ T) TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				typeId := type_.id
				isConstructorObject := getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&SymbolFlagsClass
				id := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference & T).node ? "N" + getNodeId((type as TypeReference & T).node!) :                     type.flags & TypeFlags.Conditional ? "N" + getNodeId((type as ConditionalType & T).root.node) :                     type.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type.symbol) :                     undefined */ TODO
				if !context.visitedTypes {
					context.visitedTypes = /* TODO(NewExpression): new Set() */ TODO
				}
				if id && !context.symbolDepth {
					context.symbolDepth = /* TODO(NewExpression): new Map() */ TODO
				}
				links := context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration)
				key := /* TODO(TemplateExpression): `${getTypeId(type)}|${context.flags}|${context.internalFlags}` */ TODO
				if links {
					/* TODO(ExpressionStatement): links.serializedTypes ||= new Map(); */
				}
				cachedResult := links.serializedTypes.get(key)
				if cachedResult {
					cachedResult.trackedSymbols.forEach(func(TODO_IDENTIFIER /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TrackedSymbol */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(PropertyAccessExpression): context.tracker.trackSymbol */
						/* TODO(Identifier): symbol */
						/* TODO(Identifier): enclosingDeclaration */
						/* TODO(Identifier): meaning */
					})
					if cachedResult.truncating {
						context.truncating = true
					}
					context.approximateLength += cachedResult.addedLength
					return deepCloneOrReuseNode(cachedResult.node)
				}
				var depth /* TODO(NumberKeyword): number */ any
				if id {
					depth = /* TODO(NonNullExpression): context.symbolDepth! */ TODO.get(id) || 0
					if depth > 10 {
						return createElidedInformationPlaceholder(context)
					}
					/* TODO(NonNullExpression): context.symbolDepth! */ TODO.set(id /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO)
				}
				context.visitedTypes.add(typeId)
				prevTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				startLength := context.approximateLength
				result := transform(type_)
				addedLength := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): context.approximateLength - startLength */ TODO
				if !context.reportedDiagnostic && !context.encounteredError {
					links.serializedTypes.set(key /* TODO(ObjectLiteralExpression): {                         node: result,                         truncating: context.truncating,                         addedLength,                         trackedSymbols: context.trackedSymbols,                     } */, TODO)
				}
				context.visitedTypes.delete(typeId)
				if id {
					/* TODO(NonNullExpression): context.symbolDepth! */ TODO.set(id /* TODO(NonNullExpression): depth! */, TODO)
				}
				context.trackedSymbols = prevTrackedSymbols
				return result
				deepCloneOrReuseNode := func(node T) T {
					if !nodeIsSynthesized(node) && getParseTreeNode(node) == node {
						return node
					}
					return setTextRange(context, factory.cloneNode(visitEachChildWorker(node, deepCloneOrReuseNode, nil, deepCloneOrReuseNodes, deepCloneOrReuseNode)), node)
				}
				deepCloneOrReuseNodes := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					if nodes && nodes.length == 0 {
						return setTextRangeWorker(factory.createNodeArray(nil, nodes.hasTrailingComma), nodes)
					}
					return visitNodes(nodes, visitor, test, start, count)
				}
			}
			createTypeNodeFromObjectType := func(type_ ObjectType) TypeNode {
				if isGenericMappedType(type_) || (type_ /* as */ /* TODO(TypeReference): MappedType */).containsError {
					return createMappedTypeNodeFromType(type_ /* as */ /* TODO(TypeReference): MappedType */)
				}
				resolved := resolveStructuredTypeMembers(type_)
				if !resolved.properties.length && !resolved.indexInfos.length {
					if !resolved.callSignatures.length && !resolved.constructSignatures.length {
						context.approximateLength += 2
						return setEmitFlags(factory.createTypeLiteralNode(nil), EmitFlagsSingleLine)
					}
					if resolved.callSignatures.length == 1 && !resolved.constructSignatures.length {
						signature := /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindFunctionType, context) /* as */ /* TODO(TypeReference): FunctionTypeNode */
						return signatureNode
					}
					if resolved.constructSignatures.length == 1 && !resolved.callSignatures.length {
						signature := /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
						signatureNode := signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructorType, context) /* as */ /* TODO(TypeReference): ConstructorTypeNode */
						return signatureNode
					}
				}
				abstractSignatures := filter(resolved.constructSignatures, func(signature /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !(signature.flags & SignatureFlags.Abstract) */
				})
				if some(abstractSignatures) {
					types := map_(abstractSignatures, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
						/* TODO(Identifier): getOrCreateTypeFromSignature */
						/* TODO(Identifier): s */
					})
					typeElementCount := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): resolved.callSignatures.length +                         (resolved.constructSignatures.length - abstractSignatures.length) +                         resolved.indexInfos.length +                         // exclude `prototype` when writing a class expression as a type literal, as per                         // the logic in `createTypeNodesFromResolvedType`.                         (context.flags & NodeBuilderFlags.WriteClassExpressionAsTypeLiteral ?                             countWhere(resolved.properties, p => !(p.flags & SymbolFlags.Prototype)) :                             length(resolved.properties)) */ TODO
					if typeElementCount {
						types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved))
					}
					return typeToTypeNodeHelper(getIntersectionType(types), context)
				}
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInObjectTypeLiteral
				members := createTypeNodesFromResolvedType(resolved)
				restoreFlags()
				typeLiteralNode := factory.createTypeLiteralNode(members)
				context.approximateLength += 2
				setEmitFlags(typeLiteralNode /* TODO(ConditionalExpression): (context.flags & NodeBuilderFlags.MultilineObjectLiterals) ? 0 : EmitFlags.SingleLine */, TODO)
				return typeLiteralNode
			}
			typeReferenceToTypeNode := func(type_ TypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
				var typeArguments []Type = getTypeArguments(type_)
				if type_.target == globalArrayType || type_.target == globalReadonlyArrayType {
					if context.flags & NodeBuilderFlagsWriteArrayAsGenericType {
						typeArgumentNode := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
						return factory.createTypeReferenceNode( /* TODO(ConditionalExpression): type.target === globalArrayType ? "Array" : "ReadonlyArray" */ TODO /* TODO(ArrayLiteralExpression): [typeArgumentNode] */, TODO)
					}
					elementType := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): typeArguments[0] */ TODO, context)
					arrayType := factory.createArrayTypeNode(elementType)
					return /* TODO(ConditionalExpression): type.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, arrayType) */ TODO
				} else if type_.target.objectFlags & ObjectFlagsTuple {
					typeArguments = sameMap(typeArguments, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						/* TODO(Identifier): removeMissingType */
						/* TODO(Identifier): t */
						/* TODO(PrefixUnaryExpression): !!((type.target as TupleType).elementFlags[i] & ElementFlags.Optional) */
					})
					if typeArguments.length > 0 {
						arity := getTypeReferenceArity(type_)
						tupleConstituentNodes := mapToTypeNodes(typeArguments.slice(0, arity), context)
						if tupleConstituentNodes {
							TODO_IDENTIFIER := type_.target /* as */ /* TODO(TypeReference): TupleType */
							/* TODO(ForStatement): for (let i = 0; i < tupleConstituentNodes.length; i++) {                                 const flags = (type.target as TupleType).elementFlags[i];                                 const labeledElementDeclaration = labeledElementDeclarations?.[i];                                  if (labeledElementDeclaration) {                                     tupleConstituentNodes[i] = factory.createNamedTupleMember(                                         flags & ElementFlags.Variable ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined,                                         factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(labeledElementDeclaration))),                                         flags & ElementFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                         flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) :                                             tupleConstituentNodes[i],                                     );                                 }                                 else {                                     tupleConstituentNodes[i] = flags & ElementFlags.Variable ? factory.createRestTypeNode(flags & ElementFlags.Rest ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) :                                         flags & ElementFlags.Optional ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) :                                         tupleConstituentNodes[i];                                 }                             } */
							tupleTypeNode := setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), EmitFlagsSingleLine)
							return /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
						}
					}
					if context.encounteredError || (context.flags & NodeBuilderFlagsAllowEmptyTuple) {
						tupleTypeNode := setEmitFlags(factory.createTupleTypeNode( /* TODO(ArrayLiteralExpression): [] */ TODO), EmitFlagsSingleLine)
						return /* TODO(ConditionalExpression): (type.target as TupleType).readonly ? factory.createTypeOperatorNode(SyntaxKind.ReadonlyKeyword, tupleTypeNode) : tupleTypeNode */ TODO
					}
					context.encounteredError = true
					return /* TODO(NonNullExpression): undefined! */ TODO
				} else if context.flags&NodeBuilderFlagsWriteClassExpressionAsTypeLiteral && type_.symbol.valueDeclaration && isClassLike(type_.symbol.valueDeclaration) && !isValueSymbolAccessible(type_.symbol, context.enclosingDeclaration) {
					return createAnonymousTypeNode(type_)
				} else {
					outerTypeParameters := type_.target.outerTypeParameters
					i := 0
					var resultType /* TODO(UnionType): TypeReferenceNode | ImportTypeNode | undefined */ any
					if outerTypeParameters {
						length := outerTypeParameters.length
						/* TODO(WhileStatement): while (i < length) {                             // Find group of type arguments for type parameters with the same declaring container.                             const start = i;                             const parent = getParentSymbolOfTypeParameter(outerTypeParameters[i])!;                             do {                                 i++;                             }                             while (i < length && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent);                             // When type parameters are their own type arguments for the whole group (i.e. we have                             // the default outer type arguments), we don't show the group.                             if (!rangeEquals(outerTypeParameters, typeArguments, start, i)) {                                 const typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);                                 const restoreFlags = saveRestoreFlags(context);                                 context.flags |= NodeBuilderFlags.ForbidIndexedAccessSymbolReferences;                                 const ref = symbolToTypeNode(parent, context, SymbolFlags.Type, typeArgumentSlice) as TypeReferenceNode | ImportTypeNode;                                 restoreFlags();                                 resultType = !resultType ? ref : appendReferenceToType(resultType, ref as TypeReferenceNode);                             }                         } */
					}
					var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any
					if typeArguments.length > 0 {
						typeParameterCount := 0
						if type_.target.typeParameters {
							typeParameterCount = Math.min(type_.target.typeParameters.length, typeArguments.length)
							if isReferenceToType(type_, getGlobalIterableType(false)) || isReferenceToType(type_, getGlobalIterableIteratorType(false)) || isReferenceToType(type_, getGlobalAsyncIterableType(false)) || isReferenceToType(type_, getGlobalAsyncIterableIteratorType(false)) {
								if !type_.node || !isTypeReferenceNode(type_.node) || !type_.node.typeArguments || type_.node.typeArguments.length < typeParameterCount {
									/* TODO(WhileStatement): while (typeParameterCount > 0) {                                         const typeArgument = typeArguments[typeParameterCount - 1];                                         const typeParameter = type.target.typeParameters[typeParameterCount - 1];                                         const defaultType = getDefaultFromTypeParameter(typeParameter);                                         if (!defaultType || !isTypeIdenticalTo(typeArgument, defaultType)) {                                             break;                                         }                                         typeParameterCount--;                                     } */
								}
							}
						}
						typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context)
					}
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsForbidIndexedAccessSymbolReferences
					finalRef := symbolToTypeNode(type_.symbol, context, SymbolFlagsType, typeArgumentNodes)
					restoreFlags()
					return /* TODO(ConditionalExpression): !resultType ? finalRef : appendReferenceToType(resultType, finalRef as TypeReferenceNode) */ TODO
				}
			}
			appendReferenceToType := func(root /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any, ref TypeReferenceNode) /* TODO(UnionType): TypeReferenceNode | ImportTypeNode */ any {
				if isImportTypeNode(root) {
					typeArguments := root.typeArguments
					qualifier := root.qualifier
					if qualifier {
						if isIdentifier(qualifier) {
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(qualifier) */ TODO {
								qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments)
							}
						} else {
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(qualifier.right) */ TODO {
								qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments))
							}
						}
					}
					typeArguments = ref.typeArguments
					ids := getAccessStack(ref)
					for _, id := range ids {
						qualifier = /* TODO(ConditionalExpression): qualifier ? factory.createQualifiedName(qualifier, id) : id */ TODO
					}
					return factory.updateImportTypeNode(root, root.argument, root.attributes, qualifier, typeArguments, root.isTypeOf)
				} else {
					typeArguments := root.typeArguments
					typeName := root.typeName
					if isIdentifier(typeName) {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(typeName) */ TODO {
							typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments)
						}
					} else {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeArguments !== getIdentifierTypeArguments(typeName.right) */ TODO {
							typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments))
						}
					}
					typeArguments = ref.typeArguments
					ids := getAccessStack(ref)
					for _, id := range ids {
						typeName = factory.createQualifiedName(typeName, id)
					}
					return factory.updateTypeReferenceNode(root, typeName, typeArguments)
				}
			}
			getAccessStack := func(ref TypeReferenceNode) []Identifier {
				state := ref.typeName
				ids := /* TODO(ArrayLiteralExpression): [] */ TODO
				/* TODO(WhileStatement): while (!isIdentifier(state)) {                     ids.unshift(state.right);                     state = state.left;                 } */
				ids.unshift(state)
				return ids
			}
			createTypeNodesFromResolvedType := func(resolvedType ResolvedType) /* TODO(ArrayType): TypeElement[] */ any {
				if checkTruncationLength(context) {
					return /* TODO(ArrayLiteralExpression): [factory.createPropertySignature(/*modifiers* / undefined, "...", /*questionToken* / undefined, /*type* / undefined)] */ TODO
				}
				var typeElements []TypeElement = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, signature := range resolvedType.callSignatures {
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindCallSignature, context) /* as */ /* TODO(TypeReference): CallSignatureDeclaration */)
				}
				for _, signature := range resolvedType.constructSignatures {
					if signature.flags & SignatureFlagsAbstract {
					}
					typeElements.push(signatureToSignatureDeclarationHelper(signature, SyntaxKindConstructSignature, context) /* as */ /* TODO(TypeReference): ConstructSignatureDeclaration */)
				}
				for _, info := range resolvedType.indexInfos {
					typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context /* TODO(ConditionalExpression): resolvedType.objectFlags & ObjectFlags.ReverseMapped ? createElidedInformationPlaceholder(context) : undefined */, TODO))
				}
				properties := resolvedType.properties
				if !properties {
					return typeElements
				}
				i := 0
				for _, propertySymbol := range properties {
					i++
					if context.flags & NodeBuilderFlagsWriteClassExpressionAsTypeLiteral {
						if propertySymbol.flags & SymbolFlagsPrototype {
							/* TODO(ContinueStatement): continue; */
						}
						if getDeclarationModifierFlagsFromSymbol(propertySymbol)&(ModifierFlagsPrivate|ModifierFlagsProtected) && context.tracker.reportPrivateInBaseOfClassExpression {
							context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName))
						}
					}
					if checkTruncationLength(context) && ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): i + 2 */ TODO < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): properties.length - 1 */ TODO) {
						typeElements.push(factory.createPropertySignature(nil /* TODO(TemplateExpression): `... ${properties.length - i} more ...` */, TODO, nil, nil))
						addPropertyToElementList( /* TODO(ElementAccessExpression): properties[properties.length - 1] */ TODO, context, typeElements)
						/* TODO(BreakStatement): break; */
					}
					addPropertyToElementList(propertySymbol, context, typeElements)
				}
				return /* TODO(ConditionalExpression): typeElements.length ? typeElements : undefined */ TODO
			}
		}
		createElidedInformationPlaceholder := func(context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeReferenceNode | import("/home/jabaile/work/TypeScript/src/compiler/types").KeywordTypeNode<import("/home/jabaile/work/TypeScript/src/compiler/types").SyntaxKind.AnyKeyword> */ TODO {
			context.approximateLength += 3
			if !(context.flags & NodeBuilderFlagsNoTruncation) {
				return factory.createTypeReferenceNode(factory.createIdentifier("..."), nil)
			}
			return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
		}
		shouldUsePlaceholderForProperty := func(propertySymbol Symbol, context NodeBuilderContext) /* TODO(undefined): boolean */ TODO {
			depth := 3
			return !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped) && (contains(context.reverseMappedStack, propertySymbol /* as */ /* TODO(TypeReference): ReverseMappedSymbol */) || ( /* TODO(ElementAccessExpression): context.reverseMappedStack?.[0] */ TODO && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & ObjectFlagsAnonymous)) || isDeeplyNestedReverseMappedTypeProperty())
			isDeeplyNestedReverseMappedTypeProperty := func() /* TODO(undefined): boolean */ TODO {
				if ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): context.reverseMappedStack?.length ?? 0 */ TODO) < depth {
					return false
				}
				/* TODO(ForStatement): for (let i = 0; i < depth; i++) {                     const prop = context.reverseMappedStack![context.reverseMappedStack!.length - 1 - i];                     if (prop.links.mappedType.symbol !== (propertySymbol as ReverseMappedSymbol).links.mappedType.symbol) {                         return false;                     }                 } */
				return true
			}
		}
		addPropertyToElementList := func(propertySymbol Symbol, context NodeBuilderContext, typeElements []TypeElement) {
			propertyIsReverseMapped := !!(getCheckFlags(propertySymbol) & CheckFlagsReverseMapped)
			propertyType := /* TODO(ConditionalExpression): shouldUsePlaceholderForProperty(propertySymbol, context) ?                 anyType : getNonMissingTypeOfSymbol(propertySymbol) */ TODO
			saveEnclosingDeclaration := context.enclosingDeclaration
			context.enclosingDeclaration = nil
			if context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.escapedName) {
				if propertySymbol.declarations {
					decl := first(propertySymbol.declarations)
					if hasLateBindableName(decl) {
						if isBinaryExpression(decl) {
							name := getNameOfDeclaration(decl)
							if name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression) {
								trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context)
							}
						} else {
							trackComputedName(decl.name.expression, saveEnclosingDeclaration, context)
						}
					}
				} else {
					context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol))
				}
			}
			context.enclosingDeclaration = propertySymbol.valueDeclaration || /* TODO(ElementAccessExpression): propertySymbol.declarations?.[0] */ TODO || saveEnclosingDeclaration
			propertyName := getPropertyNameNodeForSymbol(propertySymbol, context)
			context.enclosingDeclaration = saveEnclosingDeclaration
			context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName(propertySymbol).length + 1 */ TODO
			if propertySymbol.flags & SymbolFlagsAccessor {
				writeType := getWriteTypeOfSymbol(propertySymbol)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propertyType !== writeType */ TODO && !isErrorType(propertyType) && !isErrorType(writeType) {
					getterDeclaration := /* TODO(NonNullExpression): getDeclarationOfKind<GetAccessorDeclaration>(propertySymbol, SyntaxKind.GetAccessor)! */ TODO
					getterSignature := getSignatureFromDeclaration(getterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(getterSignature, SyntaxKindGetAccessor, context /* TODO(ObjectLiteralExpression): { name: propertyName } */, TODO) /* as */ /* TODO(TypeReference): GetAccessorDeclaration */, getterDeclaration))
					setterDeclaration := /* TODO(NonNullExpression): getDeclarationOfKind<SetAccessorDeclaration>(propertySymbol, SyntaxKind.SetAccessor)! */ TODO
					setterSignature := getSignatureFromDeclaration(setterDeclaration)
					typeElements.push(setCommentRange(context, signatureToSignatureDeclarationHelper(setterSignature, SyntaxKindSetAccessor, context /* TODO(ObjectLiteralExpression): { name: propertyName } */, TODO) /* as */ /* TODO(TypeReference): SetAccessorDeclaration */, setterDeclaration))
					return
				}
			}
			optionalToken := /* TODO(ConditionalExpression): propertySymbol.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			if propertySymbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol) {
				signatures := getSignaturesOfType(filterType(propertyType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Undefined) */
				}), SignatureKindCall)
				for _, signature := range signatures {
					methodDeclaration := signatureToSignatureDeclarationHelper(signature, SyntaxKindMethodSignature, context /* TODO(ObjectLiteralExpression): { name: propertyName, questionToken: optionalToken } */, TODO) /* as */ /* TODO(TypeReference): MethodSignature */
					typeElements.push(preserveCommentsOn(methodDeclaration))
				}
				if signatures.length || !optionalToken {
					return
				}
			}
			var propertyTypeNode TypeNode
			if shouldUsePlaceholderForProperty(propertySymbol, context) {
				propertyTypeNode = createElidedInformationPlaceholder(context)
			} else {
				if propertyIsReverseMapped {
					/* TODO(ExpressionStatement): context.reverseMappedStack ||= []; */
					context.reverseMappedStack.push(propertySymbol /* as */ /* TODO(TypeReference): ReverseMappedSymbol */)
				}
				propertyTypeNode = /* TODO(ConditionalExpression): propertyType ? serializeTypeForDeclaration(context, /*declaration* / undefined, propertyType, propertySymbol) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */ TODO
				if propertyIsReverseMapped {
					/* TODO(NonNullExpression): context.reverseMappedStack! */ TODO.pop()
				}
			}
			modifiers := /* TODO(ConditionalExpression): isReadonlySymbol(propertySymbol) ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO
			if modifiers {
				context.approximateLength += 9
			}
			propertySignature := factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode)
			typeElements.push(preserveCommentsOn(propertySignature))
			preserveCommentsOn := func(node T) /* TODO(undefined): T */ TODO {
				jsdocPropertyTag := propertySymbol.declarations.find(func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(TypePredicate): d is JSDocPropertyTag */ TODO {
					/* TODO(PropertyAccessExpression): d.kind */
					/* TODO(EqualsEqualsEqualsToken): === */
					/* TODO(PropertyAccessExpression): SyntaxKind.JSDocPropertyTag */
				})
				if jsdocPropertyTag {
					commentText := getTextOfJSDocComment(jsdocPropertyTag.comment)
					if commentText {
						setSyntheticLeadingComments(node /* TODO(ArrayLiteralExpression): [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }] */, TODO)
					}
				} else if propertySymbol.valueDeclaration {
					setCommentRange(context, node, propertySymbol.valueDeclaration)
				}
				return node
			}
		}
		setCommentRange := func(context NodeBuilderContext, node T, range_ Node) T {
			if context.enclosingFile && context.enclosingFile == getSourceFileOfNode(range_) {
				return setCommentRangeWorker(node, range_)
			}
			return node
		}
		mapToTypeNodes := func(types /* TODO(TypeOperator): readonly Type[] */ any, context NodeBuilderContext, isBareList bool) /* TODO(ArrayType): TypeNode[] */ any {
			if some(types) {
				if checkTruncationLength(context) {
					if !isBareList {
						return /* TODO(ArrayLiteralExpression): [factory.createTypeReferenceNode("...", /*typeArguments* / undefined)] */ TODO
					} else if types.length > 2 {
						return /* TODO(ArrayLiteralExpression): [                             typeToTypeNodeHelper(types[0], context),                             factory.createTypeReferenceNode(`... ${types.length - 2} more ...`, /*typeArguments* / undefined),                             typeToTypeNodeHelper(types[types.length - 1], context),                         ] */ TODO
					}
				}
				mayHaveNameCollisions := !(context.flags & NodeBuilderFlagsUseFullyQualifiedType)
				seenNames := /* TODO(ConditionalExpression): mayHaveNameCollisions ? createMultiMap<__String, [Type, number]>() : undefined */ TODO
				var result []TypeNode = /* TODO(ArrayLiteralExpression): [] */ TODO
				i := 0
				for _, type_ := range types {
					i++
					if checkTruncationLength(context) && ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): i + 2 */ TODO < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - 1 */ TODO) {
						result.push(factory.createTypeReferenceNode( /* TODO(TemplateExpression): `... ${types.length - i} more ...` */ TODO, nil))
						typeNode := typeToTypeNodeHelper( /* TODO(ElementAccessExpression): types[types.length - 1] */ TODO, context)
						if typeNode {
							result.push(typeNode)
						}
						/* TODO(BreakStatement): break; */
					}
					context.approximateLength += 2
					typeNode := typeToTypeNodeHelper(type_, context)
					if typeNode {
						result.push(typeNode)
						if seenNames && isIdentifierTypeReference(typeNode) {
							seenNames.add(typeNode.typeName.escapedText /* TODO(ArrayLiteralExpression): [type, result.length - 1] */, TODO)
						}
					}
				}
				if seenNames {
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsUseFullyQualifiedType
					seenNames.forEach(func(types /* TODO(undefined): [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number][] */ TODO) {
						if !arrayIsHomogeneous(types, func(TODO_IDENTIFIER /* TODO(undefined): [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number] */ TODO, TODO_IDENTIFIER /* TODO(undefined): [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, number] */ TODO) /* TODO(undefined): boolean */ TODO {
							/* TODO(Identifier): typesAreSameReference */
							/* TODO(Identifier): a */
							/* TODO(Identifier): b */
						}) {
							for _, TODO_IDENTIFIER := range types {
								/* TODO(ElementAccessExpression): result[resultIndex] */ TODO = typeToTypeNodeHelper(type_, context)
							}
						}
					})
					restoreFlags()
				}
				return result
			}
		}
		typesAreSameReference := func(a Type, b Type) bool {
			return a == b || !!a.symbol && a.symbol == b.symbol || !!a.aliasSymbol && a.aliasSymbol == b.aliasSymbol
		}
		indexInfoToIndexSignatureDeclarationHelper := func(indexInfo IndexInfo, context NodeBuilderContext, typeNode *TypeNode) IndexSignatureDeclaration {
			name := getNameFromIndexInfo(indexInfo) || "x"
			indexerTypeNode := typeToTypeNodeHelper(indexInfo.keyType, context)
			indexingParameter := factory.createParameterDeclaration(nil, nil, name, nil, indexerTypeNode, nil)
			if !typeNode {
				typeNode = typeToTypeNodeHelper(indexInfo.type_ || anyType, context)
			}
			if !indexInfo.type_ && !(context.flags & NodeBuilderFlagsAllowEmptyIndexInfoType) {
				context.encounteredError = true
			}
			context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): name.length + 4 */ TODO
			return factory.createIndexSignature( /* TODO(ConditionalExpression): indexInfo.isReadonly ? [factory.createToken(SyntaxKind.ReadonlyKeyword)] : undefined */ TODO /* TODO(ArrayLiteralExpression): [indexingParameter] */, TODO, typeNode)
		}
		type SignatureToSignatureDeclarationOptions struct {
			modifiers     []Modifier
			name          PropertyName
			questionToken QuestionToken
		}
		signatureToSignatureDeclarationHelper := func(signature Signature, kind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, context NodeBuilderContext, options SignatureToSignatureDeclarationOptions) SignatureDeclaration {
			var typeParameters /* TODO(ArrayType): TypeParameterDeclaration[] */ any
			var typeArguments /* TODO(ArrayType): TypeNode[] */ any
			expandedParams := /* TODO(ElementAccessExpression): getExpandedParameters(signature, /*skipUnionExpanding* / true)[0] */ TODO
			cleanup := enterNewScope(context, signature.declaration, expandedParams, signature.typeParameters, signature.parameters, signature.mapper)
			context.approximateLength += 3
			if context.flags&NodeBuilderFlagsWriteTypeArgumentsOfSignature && signature.target && signature.mapper && signature.target.typeParameters {
				typeArguments = signature.target.typeParameters.map_(func(parameter /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
					/* TODO(Identifier): typeToTypeNodeHelper */
					/* TODO(CallExpression): instantiateType(parameter, signature.mapper) */
					/* TODO(Identifier): context */
				})
			} else {
				typeParameters = signature.typeParameters && signature.typeParameters.map_(func(parameter /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					/* TODO(Identifier): typeParameterToDeclaration */
					/* TODO(Identifier): parameter */
					/* TODO(Identifier): context */
				})
			}
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsSuppressAnyReturnType
			parameters := ( /* TODO(ConditionalExpression): some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & CheckFlags.RestParameter)) ? signature.parameters : expandedParams */ TODO).map_(func(parameter /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
				/* TODO(Identifier): symbolToParameterDeclaration */
				/* TODO(Identifier): parameter */
				/* TODO(Identifier): context */
				/* TODO(BinaryExpression): kind === SyntaxKind.Constructor */
			})
			thisParameter := /* TODO(ConditionalExpression): context.flags & NodeBuilderFlags.OmitThisParameter ? undefined : tryGetThisParameterDeclaration(signature, context) */ TODO
			if thisParameter {
				parameters.unshift(thisParameter)
			}
			restoreFlags()
			returnTypeNode := serializeReturnTypeForSignature(context, signature)
			modifiers := options.modifiers
			if (kind == SyntaxKindConstructorType) && signature.flags&SignatureFlagsAbstract {
				flags := modifiersToFlags(modifiers)
				modifiers = factory.createModifiersFromModifierFlags(flags | ModifierFlagsAbstract)
			}
			node := /* TODO(ConditionalExpression): kind === SyntaxKind.CallSignature ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.ConstructSignature ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodSignature ? factory.createMethodSignature(modifiers, options?.name ?? factory.createIdentifier(""), options?.questionToken, typeParameters, parameters, returnTypeNode) :                 kind === SyntaxKind.MethodDeclaration ? factory.createMethodDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ?? factory.createIdentifier(""), /*questionToken* / undefined, typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.Constructor ? factory.createConstructorDeclaration(modifiers, parameters, /*body* / undefined) :                 kind === SyntaxKind.GetAccessor ? factory.createGetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.SetAccessor ? factory.createSetAccessorDeclaration(modifiers, options?.name ?? factory.createIdentifier(""), parameters, /*body* / undefined) :                 kind === SyntaxKind.IndexSignature ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) :                 kind === SyntaxKind.JSDocFunctionType ? factory.createJSDocFunctionType(parameters, returnTypeNode) :                 kind === SyntaxKind.FunctionType ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.ConstructorType ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode ?? factory.createTypeReferenceNode(factory.createIdentifier(""))) :                 kind === SyntaxKind.FunctionDeclaration ? factory.createFunctionDeclaration(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, /*body* / undefined) :                 kind === SyntaxKind.FunctionExpression ? factory.createFunctionExpression(modifiers, /*asteriskToken* / undefined, options?.name ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) :                 kind === SyntaxKind.ArrowFunction ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, /*equalsGreaterThanToken* / undefined, factory.createBlock([])) :                 Debug.assertNever(kind) */ TODO
			if typeArguments {
				node.typeArguments = factory.createNodeArray(typeArguments)
			}
			if signature.declaration.kind == SyntaxKindJSDocSignature && signature.declaration.parent.kind == SyntaxKindJSDocOverloadTag {
				comment := getTextOfNode(signature.declaration.parent.parent, true).slice(2, -2).split(regexp.MustParse(`\r\n|\n|\r`)).map_(func(line /* TODO(undefined): string */ TODO) /* TODO(undefined): string */ TODO {
					/* TODO(PropertyAccessExpression): line.replace */
					/* TODO(RegularExpressionLiteral): /^\s+/ */
					/* TODO(StringLiteral): " " */
				}).join("\n")
				addSyntheticLeadingComment(node, SyntaxKindMultiLineCommentTrivia, comment, true)
			}
			cleanup()
			return node
		}
		type IntroducesNewScopeNode /* TODO(UnionType): SignatureDeclaration | JSDocSignature | MappedTypeNode */ any
		isNewScopeNode := func(node Node) /* TODO(TypePredicate): node is IntroducesNewScopeNode */ TODO {
			return isFunctionLike(node) || isJSDocSignature(node) || isMappedTypeNode(node)
		}
		getTypeParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
			return /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).typeParameters :                 isConditionalTypeNode(node) ? getInferTypeParameters(node) :                 [getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))] */ TODO
		}
		getParametersInScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] | undefined */ TODO {
			return /* TODO(ConditionalExpression): isFunctionLike(node) || isJSDocSignature(node) ? getSignatureFromDeclaration(node).parameters : undefined */ TODO
		}
		enterNewScope := func(context NodeBuilderContext, declaration /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode | undefined */ any, expandedParams /* TODO(TypeOperator): readonly Symbol[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, originalParameters /* TODO(TypeOperator): readonly Symbol[] */ any, mapper TypeMapper) /* TODO(undefined): () => void */ TODO {
			cleanupContext := cloneNodeBuilderContext(context)
			var cleanupParams /* TODO(ParenthesizedType): (() => void) */ any
			var cleanupTypeParams /* TODO(ParenthesizedType): (() => void) */ any
			oldEnclosingDecl := context.enclosingDeclaration
			oldMapper := context.mapper
			if mapper {
				context.mapper = mapper
			}
			if context.enclosingDeclaration && declaration {
				cleanupParams = /* TODO(ConditionalExpression): !some(expandedParams) ? undefined : pushFakeScope(                     "params",                     add => {                         if (!expandedParams) return;                         for (let pIndex = 0; pIndex < expandedParams.length; pIndex++) {                             const param = expandedParams[pIndex];                             const originalParam = originalParameters?.[pIndex];                             if (originalParameters && originalParam !== param) {                                 // Can't reference parameters that come from an expansion                                 add(param.escapedName, unknownSymbol);                                 // Can't reference the original expanded parameter either                                 if (originalParam) {                                     add(originalParam.escapedName, unknownSymbol);                                 }                             }                             else if (                                 !forEach(param.declarations, d => {                                     if (isParameter(d) && isBindingPattern(d.name)) {                                         bindPattern(d.name);                                         return true;                                     }                                     return undefined;                                     function bindPattern(p: BindingPattern): void {                                         forEach(p.elements, e => {                                             switch (e.kind) {                                                 case SyntaxKind.OmittedExpression:                                                     return;                                                 case SyntaxKind.BindingElement:                                                     return bindElement(e);                                                 default:                                                     return Debug.assertNever(e);                                             }                                         });                                     }                                     function bindElement(e: BindingElement): void {                                         if (isBindingPattern(e.name)) {                                             return bindPattern(e.name);                                         }                                         const symbol = getSymbolOfDeclaration(e);                                         add(symbol.escapedName, symbol);                                     }                                 })                             ) {                                 add(param.escapedName, param);                             }                         }                     },                 ) */ TODO
				if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && some(typeParameters) {
					cleanupTypeParams = pushFakeScope("typeParams", func(add /* TODO(undefined): (name: import("/home/jabaile/work/TypeScript/src/compiler/types").__String, symbol: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol) => void */ TODO) {
						for _, typeParam := range /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): typeParameters ?? emptyArray */ TODO {
							typeParamName := typeParameterToName(typeParam, context).escapedText
							add(typeParamName, typeParam.symbol)
						}
					})
				}
				pushFakeScope := func(kind /* TODO(UnionType): "params" | "typeParams" */ any, addAll func(addSymbol func(name __String, symbol Symbol))) /* TODO(undefined): (() => void) | undefined */ TODO {
					Debug.assert(context.enclosingDeclaration)
					var existingFakeScope Node
					if getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration
					} else if context.enclosingDeclaration.parent && getNodeLinks(context.enclosingDeclaration.parent).fakeScopeForSignatureDeclaration == kind {
						existingFakeScope = context.enclosingDeclaration.parent
					}
					Debug.assertOptionalNode(existingFakeScope, isBlock)
					locals := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): existingFakeScope?.locals ?? createSymbolTable() */ TODO
					var newLocals /* TODO(ArrayType): __String[] */ any
					var oldLocals /* TODO(ArrayType): { name: __String; oldSymbol: Symbol; }[] */ any
					addAll(func(name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO, symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
						if existingFakeScope {
							oldSymbol := locals.get(name)
							if !oldSymbol {
								newLocals = append(newLocals, name)
							} else {
								oldLocals = append(oldLocals /* TODO(ObjectLiteralExpression): { name, oldSymbol } */, TODO)
							}
						}
						locals.set(name, symbol)
					})
					if !existingFakeScope {
						fakeScope := factory.createBlock(emptyArray)
						getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = kind
						fakeScope.locals = locals
						setParent(fakeScope, context.enclosingDeclaration)
						context.enclosingDeclaration = fakeScope
					} else {
						return /* TODO(FunctionExpression): function undo() {                             forEach(newLocals, s => locals.delete(s));                             forEach(oldLocals, s => locals.set(s.name, s.oldSymbol));                         } */ TODO
					}
				}
			}
			return func() {
				cleanupParams()
				cleanupTypeParams()
				cleanupContext()
				context.enclosingDeclaration = oldEnclosingDecl
				context.mapper = oldMapper
			}
		}
		tryGetThisParameterDeclaration := func(signature Signature, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
			if signature.thisParameter {
				return symbolToParameterDeclaration(signature.thisParameter, context)
			}
			if signature.declaration && isInJSFile(signature.declaration) {
				thisTag := getJSDocThisTag(signature.declaration)
				if thisTag && thisTag.typeExpression {
					return factory.createParameterDeclaration(nil, nil, "this", nil, typeToTypeNodeHelper(getTypeFromTypeNode(context, thisTag.typeExpression), context))
				}
			}
		}
		typeParameterToDeclarationWithConstraint := func(type_ TypeParameter, context NodeBuilderContext, constraintNode *TypeNode) TypeParameterDeclaration {
			restoreFlags := saveRestoreFlags(context)
			context.flags &= ~NodeBuilderFlagsWriteTypeParametersInQualifiedName
			modifiers := factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type_))
			name := typeParameterToName(type_, context)
			defaultParameter := getDefaultFromTypeParameter(type_)
			defaultParameterNode := defaultParameter && typeToTypeNodeHelper(defaultParameter, context)
			restoreFlags()
			return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode)
		}
		typeToTypeNodeHelperWithPossibleReusableTypeNode := func(type_ Type, typeNode *TypeNode, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			return typeNode && tryReuseExistingNonParameterTypeNode(context, typeNode, type_) || typeToTypeNodeHelper(type_, context)
		}
		typeParameterToDeclaration := func(type_ TypeParameter, context NodeBuilderContext, constraint /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO /* = */ /* TODO(CallExpression): getConstraintOfTypeParameter(type) */) TypeParameterDeclaration {
			constraintNode := constraint && typeToTypeNodeHelperWithPossibleReusableTypeNode(constraint, getConstraintDeclaration(type_), context)
			return typeParameterToDeclarationWithConstraint(type_, context, constraintNode)
		}
		typePredicateToTypePredicateNodeHelper := func(typePredicate TypePredicate, context NodeBuilderContext) TypePredicateNode {
			assertsModifier := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.AssertsThis || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 factory.createToken(SyntaxKind.AssertsKeyword) :                 undefined */ TODO
			parameterName := /* TODO(ConditionalExpression): typePredicate.kind === TypePredicateKind.Identifier || typePredicate.kind === TypePredicateKind.AssertsIdentifier ?                 setEmitFlags(factory.createIdentifier(typePredicate.parameterName), EmitFlags.NoAsciiEscaping) :                 factory.createThisTypeNode() */ TODO
			typeNode := typePredicate.type_ && typeToTypeNodeHelper(typePredicate.type_, context)
			return factory.createTypePredicateNode(assertsModifier, parameterName, typeNode)
		}
		getEffectiveParameterDeclaration := func(parameterSymbol Symbol) /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any {
			var parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any = getDeclarationOfKind(parameterSymbol, SyntaxKindParameter)
			if parameterDeclaration {
				return parameterDeclaration
			}
			if !isTransientSymbol(parameterSymbol) {
				return getDeclarationOfKind(parameterSymbol, SyntaxKindJSDocParameterTag)
			}
		}
		symbolToParameterDeclaration := func(parameterSymbol Symbol, context NodeBuilderContext, preserveModifierFlags bool) ParameterDeclaration {
			parameterDeclaration := getEffectiveParameterDeclaration(parameterSymbol)
			parameterType := getTypeOfSymbol(parameterSymbol)
			parameterTypeNode := serializeTypeForDeclaration(context, parameterDeclaration, parameterType, parameterSymbol)
			modifiers := /* TODO(ConditionalExpression): !(context.flags & NodeBuilderFlags.OmitParameterModifiers) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : undefined */ TODO
			isRest := parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsRestParameter
			dotDotDotToken := /* TODO(ConditionalExpression): isRest ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO
			name := parameterToParameterDeclarationName(parameterSymbol, parameterDeclaration, context)
			isOptional := parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol)&CheckFlagsOptionalParameter
			questionToken := /* TODO(ConditionalExpression): isOptional ? factory.createToken(SyntaxKind.QuestionToken) : undefined */ TODO
			parameterNode := factory.createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, nil)
			context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName(parameterSymbol).length + 3 */ TODO
			return parameterNode
		}
		parameterToParameterDeclarationName := func(parameterSymbol Symbol, parameterDeclaration /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | undefined */ any, context NodeBuilderContext) /* TODO(undefined): string | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingName */ TODO {
			return /* TODO(ConditionalExpression): parameterDeclaration ? parameterDeclaration.name ?                 parameterDeclaration.name.kind === SyntaxKind.Identifier ? setEmitFlags(factory.cloneNode(parameterDeclaration.name), EmitFlags.NoAsciiEscaping) :                     parameterDeclaration.name.kind === SyntaxKind.QualifiedName ? setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), EmitFlags.NoAsciiEscaping) :                     cloneBindingName(parameterDeclaration.name) :                 symbolName(parameterSymbol) :                 symbolName(parameterSymbol) */ TODO
			cloneBindingName := func(node BindingName) BindingName {
				return elideInitializerAndSetEmitFlags(node) /* as */ /* TODO(TypeReference): BindingName */
				elideInitializerAndSetEmitFlags := func(node Node) Node {
					if context.tracker.canTrackSymbol && isComputedPropertyName(node) && isLateBindableName(node) {
						trackComputedName(node.expression, context.enclosingDeclaration, context)
					}
					visited := visitEachChildWorker(node, elideInitializerAndSetEmitFlags, nil, nil, elideInitializerAndSetEmitFlags)
					if isBindingElement(visited) {
						visited = factory.updateBindingElement(visited, visited.dotDotDotToken, visited.propertyName, visited.name, nil)
					}
					if !nodeIsSynthesized(visited) {
						visited = factory.cloneNode(visited)
					}
					return setEmitFlags(visited, EmitFlagsSingleLine|EmitFlagsNoAsciiEscaping)
				}
			}
		}
		trackComputedName := func(accessExpression EntityNameOrEntityNameExpression, enclosingDeclaration Node, context NodeBuilderContext) {
			if !context.tracker.canTrackSymbol {
			}
			firstIdentifier := getFirstIdentifier(accessExpression)
			name := resolveName(firstIdentifier, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsExportValue, nil, true)
			if name {
				context.tracker.trackSymbol(name, enclosingDeclaration, SymbolFlagsValue)
			}
		}
		lookupSymbolChain := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning)
			return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol)
		}
		lookupSymbolChainWorker := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, yieldModuleSymbol bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			var chain []Symbol
			isTypeParameter := symbol.flags & SymbolFlagsTypeParameter
			if !isTypeParameter && (context.enclosingDeclaration || context.flags&NodeBuilderFlagsUseFullyQualifiedType) && !(context.internalFlags & InternalNodeBuilderFlagsDoNotIncludeSymbolChain) {
				chain = Debug.checkDefined(getSymbolChain(symbol, meaning, true))
				Debug.assert(chain && chain.length > 0)
			} else {
				chain = /* TODO(ArrayLiteralExpression): [symbol] */ TODO
			}
			return chain
			getSymbolChain := func(symbol Symbol, meaning SymbolFlags, endOfChain bool) /* TODO(ArrayType): Symbol[] */ any {
				accessibleSymbolChain := getAccessibleSymbolChain(symbol, context.enclosingDeclaration, meaning, !!(context.flags & NodeBuilderFlagsUseOnlyExternalAliasing))
				var parentSpecifiers [] /* TODO(StringKeyword): string */ any
				if !accessibleSymbolChain || needsQualification( /* TODO(ElementAccessExpression): accessibleSymbolChain[0] */ TODO, context.enclosingDeclaration /* TODO(ConditionalExpression): accessibleSymbolChain.length === 1 ? meaning : getQualifiedLeftMeaning(meaning) */, TODO) {
					parents := getContainersOfSymbol( /* TODO(ConditionalExpression): accessibleSymbolChain ? accessibleSymbolChain[0] : symbol */ TODO, context.enclosingDeclaration, meaning)
					if length(parents) {
						parentSpecifiers = /* TODO(NonNullExpression): parents! */ TODO.map_(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): string | undefined */ TODO {
							/* TODO(CallExpression): some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) */
							/* TODO(QuestionToken): ? */
							/* TODO(CallExpression): getSpecifierForModuleSymbol(symbol, context) */
							/* TODO(ColonToken): : */
							/* TODO(Identifier): undefined */
						})
						indices := /* TODO(NonNullExpression): parents! */ TODO.map_(func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): number */ TODO {
						})
						indices.sort(sortByBestName)
						sortedParents := indices.map_(func(i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
							/* TODO(NonNullExpression): parents! */
							/* TODO(Identifier): i */
						})
						for _, parent := range sortedParents {
							parentChain := getSymbolChain(parent, getQualifiedLeftMeaning(meaning), false)
							if parentChain {
								if parent.exports && parent.exports.get(InternalSymbolNameExportEquals) && getSymbolIfSameReference( /* TODO(NonNullExpression): parent.exports.get(InternalSymbolName.ExportEquals)! */ TODO, symbol) {
									accessibleSymbolChain = parentChain
									/* TODO(BreakStatement): break; */
								}
								accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || /* TODO(ArrayLiteralExpression): [getAliasForSymbolInContainer(parent, symbol) || symbol] */ TODO)
								/* TODO(BreakStatement): break; */
							}
						}
					}
				}
				if accessibleSymbolChain {
					return accessibleSymbolChain
				}
				if endOfChain || !(symbol.flags & (SymbolFlagsTypeLiteral | SymbolFlagsObjectLiteral)) {
					if !endOfChain && !yieldModuleSymbol && !!forEach(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
						return
					}
					return /* TODO(ArrayLiteralExpression): [symbol] */ TODO
				}
				sortByBestName := func(a number, b number) /* TODO(undefined): number */ TODO {
					specifierA := /* TODO(ElementAccessExpression): parentSpecifiers[a] */ TODO
					specifierB := /* TODO(ElementAccessExpression): parentSpecifiers[b] */ TODO
					if specifierA && specifierB {
						isBRelative := pathIsRelative(specifierB)
						if pathIsRelative(specifierA) == isBRelative {
							return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): moduleSpecifiers.countPathComponents(specifierA) - moduleSpecifiers.countPathComponents(specifierB) */ TODO
						}
						if isBRelative {
							return -1
						}
						return 1
					}
					return 0
				}
			}
		}
		typeParametersToTypeParameterDeclarations := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").NodeArray<import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration> | undefined */ TODO {
			var typeParameterNodes *NodeArray[TypeParameterDeclaration]
			targetSymbol := getTargetSymbol(symbol)
			if targetSymbol.flags & (SymbolFlagsClass | SymbolFlagsInterface | SymbolFlagsTypeAlias) {
				typeParameterNodes = factory.createNodeArray(map_(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), func(tp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					/* TODO(Identifier): typeParameterToDeclaration */
					/* TODO(Identifier): tp */
					/* TODO(Identifier): context */
				}))
			}
			return typeParameterNodes
		}
		lookupTypeParameterNodes := func(chain []Symbol, index number, context NodeBuilderContext) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode[] | readonly import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] | undefined */ TODO {
			Debug.assert(chain && 0 <= index && index < chain.length)
			symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
			symbolId := getSymbolId(symbol)
			if context.typeParameterSymbolList.has(symbolId) {
				return nil
			}
			if context.mustCreateTypeParameterSymbolList {
				context.mustCreateTypeParameterSymbolList = false
				context.typeParameterSymbolList = /* TODO(NewExpression): new Set(context.typeParameterSymbolList) */ TODO
			}
			/* TODO(NonNullExpression): context.typeParameterSymbolList! */ TODO.add(symbolId)
			var typeParameterNodes /* TODO(UnionType): readonly TypeNode[] | readonly TypeParameterDeclaration[] | undefined */ any
			if context.flags&NodeBuilderFlagsWriteTypeParametersInQualifiedName && index < ( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */ TODO) {
				parentSymbol := symbol
				nextSymbol := /* TODO(ElementAccessExpression): chain[index + 1] */ TODO
				if getCheckFlags(nextSymbol) & CheckFlagsInstantiated {
					params := getTypeParametersOfClassOrInterface( /* TODO(ConditionalExpression): parentSymbol.flags & SymbolFlags.Alias ? resolveAlias(parentSymbol) : parentSymbol */ TODO)
					typeParameterNodes = mapToTypeNodes(map_(params, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						/* TODO(Identifier): getMappedType */
						/* TODO(Identifier): t */
						/* TODO(NonNullExpression): (nextSymbol as TransientSymbol).links.mapper! */
					}), context)
				} else {
					typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context)
				}
			}
			return typeParameterNodes
		}
		getTopmostIndexedAccessType := func(top IndexedAccessTypeNode) IndexedAccessTypeNode {
			if isIndexedAccessTypeNode(top.objectType) {
				return getTopmostIndexedAccessType(top.objectType)
			}
			return top
		}
		getSpecifierForModuleSymbol := func(symbol Symbol, context NodeBuilderContext, overrideImportMode ResolutionMode) /* TODO(undefined): string */ TODO {
			file := getDeclarationOfKind(symbol, SyntaxKindSourceFile)
			if !file {
				equivalentFileSymbol := firstDefined(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
					/* TODO(Identifier): getFileSymbolIfFileSymbolExportEqualsContainer */
					/* TODO(Identifier): d */
					/* TODO(Identifier): symbol */
				})
				if equivalentFileSymbol {
					file = getDeclarationOfKind(equivalentFileSymbol, SyntaxKindSourceFile)
				}
			}
			if file && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): file.moduleName !== undefined */ TODO {
				return file.moduleName
			}
			if !file {
				if ambientModuleSymbolRegex.test(symbol.escapedName /* as */ /* TODO(StringKeyword): string */) {
					return (symbol.escapedName /* as */ /* TODO(StringKeyword): string */).substring(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */, TODO)
				}
			}
			if !context.enclosingFile || !context.tracker.moduleResolverHost {
				if ambientModuleSymbolRegex.test(symbol.escapedName /* as */ /* TODO(StringKeyword): string */) {
					return (symbol.escapedName /* as */ /* TODO(StringKeyword): string */).substring(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): (symbol.escapedName as string).length - 1 */, TODO)
				}
				return getSourceFileOfNode( /* TODO(NonNullExpression): getNonAugmentationDeclaration(symbol)! */ TODO).fileName
			}
			enclosingDeclaration := getOriginalNode(context.enclosingDeclaration)
			originalModuleSpecifier := /* TODO(ConditionalExpression): canHaveModuleSpecifier(enclosingDeclaration) ? tryGetModuleSpecifierFromDeclaration(enclosingDeclaration) : undefined */ TODO
			contextFile := context.enclosingFile
			resolutionMode := overrideImportMode || originalModuleSpecifier && host.getModeForUsageLocation(contextFile, originalModuleSpecifier) || contextFile && host.getDefaultResolutionModeForFile(contextFile)
			cacheKey := createModeAwareCacheKey(contextFile.path, resolutionMode)
			links := getSymbolLinks(symbol)
			specifier := links.specifierCache && links.specifierCache.get(cacheKey)
			if !specifier {
				isBundle := !!compilerOptions.outFile
				TODO_IDENTIFIER := context.tracker
				specifierCompilerOptions := /* TODO(ConditionalExpression): isBundle ? { ...compilerOptions, baseUrl: moduleResolverHost.getCommonSourceDirectory() } : compilerOptions */ TODO
				specifier = first(moduleSpecifiers.getModuleSpecifiers(symbol, checker, specifierCompilerOptions, contextFile, moduleResolverHost /* TODO(ObjectLiteralExpression): {                         importModuleSpecifierPreference: isBundle ? "non-relative" : "project-relative",                         importModuleSpecifierEnding: isBundle ? "minimal"                             : resolutionMode === ModuleKind.ESNext ? "js"                             : undefined,                     } */, TODO /* TODO(ObjectLiteralExpression): { overrideImportMode } */, TODO))
				/* TODO(ExpressionStatement): links.specifierCache ??= new Map(); */
				links.specifierCache.set(cacheKey, specifier)
			}
			return specifier
		}
		symbolToEntityNameNode := func(symbol Symbol) EntityName {
			identifier := factory.createIdentifier(unescapeLeadingUnderscores(symbol.escapedName))
			return /* TODO(ConditionalExpression): symbol.parent ? factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier */ TODO
		}
		symbolToTypeNode := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, overrideTypeArguments []TypeNode) TypeNode {
			chain := lookupSymbolChain(symbol, context, meaning, !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope))
			isTypeOf := meaning == SymbolFlagsValue
			if some( /* TODO(ElementAccessExpression): chain[0] */ TODO.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
				nonRootParts := /* TODO(ConditionalExpression): chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : undefined */ TODO
				typeParameterNodes := overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context)
				contextFile := getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration))
				targetFile := getSourceFileOfModule( /* TODO(ElementAccessExpression): chain[0] */ TODO)
				var specifier /* TODO(StringKeyword): string */ any
				var attributes *ImportAttributes
				if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
					if targetFile.impliedNodeFormat == ModuleKindESNext && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetFile.impliedNodeFormat !== contextFile?.impliedNodeFormat */ TODO {
						specifier = getSpecifierForModuleSymbol( /* TODO(ElementAccessExpression): chain[0] */ TODO, context, ModuleKindESNext)
						attributes = factory.createImportAttributes(factory.createNodeArray( /* TODO(ArrayLiteralExpression): [                                 factory.createImportAttribute(                                     factory.createStringLiteral("resolution-mode"),                                     factory.createStringLiteral("import"),                                 ),                             ] */ TODO))
					}
				}
				if !specifier {
					specifier = getSpecifierForModuleSymbol( /* TODO(ElementAccessExpression): chain[0] */ TODO, context)
				}
				if !(context.flags & NodeBuilderFlagsAllowNodeModulesRelativePaths) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getEmitModuleResolutionKind(compilerOptions) !== ModuleResolutionKind.Classic */ TODO && specifier.includes("/node_modules/") {
					oldSpecifier := specifier
					if getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNode16 || getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindNodeNext {
						swappedMode := /* TODO(ConditionalExpression): contextFile?.impliedNodeFormat === ModuleKind.ESNext ? ModuleKind.CommonJS : ModuleKind.ESNext */ TODO
						specifier = getSpecifierForModuleSymbol( /* TODO(ElementAccessExpression): chain[0] */ TODO, context, swappedMode)
						if specifier.includes("/node_modules/") {
							specifier = oldSpecifier
						} else {
							attributes = factory.createImportAttributes(factory.createNodeArray( /* TODO(ArrayLiteralExpression): [                                     factory.createImportAttribute(                                         factory.createStringLiteral("resolution-mode"),                                         factory.createStringLiteral(swappedMode === ModuleKind.ESNext ? "import" : "require"),                                     ),                                 ] */ TODO))
						}
					}
					if !attributes {
						context.encounteredError = true
						if context.tracker.reportLikelyUnsafeImportRequiredError {
							context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier)
						}
					}
				}
				lit := factory.createLiteralTypeNode(factory.createStringLiteral(specifier))
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): specifier.length + 10 */ TODO
				if !nonRootParts || isEntityName(nonRootParts) {
					if nonRootParts {
						lastId := /* TODO(ConditionalExpression): isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right */ TODO
						setIdentifierTypeArguments(lastId, nil)
					}
					return factory.createImportTypeNode(lit, attributes, nonRootParts /* as */ /* TODO(TypeReference): EntityName */, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */, isTypeOf)
				} else {
					splitNode := getTopmostIndexedAccessType(nonRootParts)
					qualifier := (splitNode.objectType /* as */ /* TODO(TypeReference): TypeReferenceNode */).typeName
					return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, attributes, qualifier, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */, isTypeOf), splitNode.indexType)
				}
			}
			entityName := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO, 0)
			if isIndexedAccessTypeNode(entityName) {
				return entityName
			}
			if isTypeOf {
				return factory.createTypeQueryNode(entityName)
			} else {
				lastId := /* TODO(ConditionalExpression): isIdentifier(entityName) ? entityName : entityName.right */ TODO
				lastTypeArgs := getIdentifierTypeArguments(lastId)
				setIdentifierTypeArguments(lastId, nil)
				return factory.createTypeReferenceNode(entityName, lastTypeArgs /* as */ /* TODO(TypeReference): NodeArray<TypeNode> */)
			}
			createAccessFromSymbolChain := func(chain []Symbol, index number, stopper number) /* TODO(UnionType): EntityName | IndexedAccessTypeNode */ any {
				typeParameterNodes := /* TODO(ConditionalExpression): index === (chain.length - 1) ? overrideTypeArguments : lookupTypeParameterNodes(chain, index, context) */ TODO
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				parent := /* TODO(ElementAccessExpression): chain[index - 1] */ TODO
				var symbolName /* TODO(StringKeyword): string */ any
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
					symbolName = getNameOfSymbolAsWritten(symbol, context)
					context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (symbolName ? symbolName.length : 0) + 1 */ TODO
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				} else {
					if parent && getExportsOfSymbol(parent) {
						exports := getExportsOfSymbol(parent)
						forEachEntry(exports, func(ex /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO(undefined): true | undefined */ TODO {
							if getSymbolIfSameReference(ex, symbol) && !isLateBoundName(name) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== InternalSymbolName.ExportEquals */ TODO {
								symbolName = unescapeLeadingUnderscores(name)
								return true
							}
						})
					}
				}
				if symbolName == nil {
					name := firstDefined(symbol.declarations, getNameOfDeclaration)
					if name && isComputedPropertyName(name) && isEntityName(name.expression) {
						LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
						if isEntityName(LHS) {
							return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression))
						}
						return LHS
					}
					symbolName = getNameOfSymbolAsWritten(symbol, context)
				}
				context.approximateLength += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): symbolName.length + 1 */ TODO
				if !(context.flags & NodeBuilderFlagsForbidIndexedAccessSymbolReferences) && parent && getMembersOfSymbol(parent) && getMembersOfSymbol(parent).get(symbol.escapedName) && getSymbolIfSameReference( /* TODO(NonNullExpression): getMembersOfSymbol(parent).get(symbol.escapedName)! */ TODO, symbol) {
					LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
					if isIndexedAccessTypeNode(LHS) {
						return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					} else {
						return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes /* as */ /* TODO(TypeOperator): readonly TypeNode[] */), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName)))
					}
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
				}
				identifier.symbol = symbol
				if index > stopper {
					LHS := createAccessFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO, stopper)
					if !isEntityName(LHS) {
						return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable")
					}
					return factory.createQualifiedName(LHS, identifier)
				}
				return identifier
			}
		}
		typeParameterShadowsOtherTypeParameterInScope := func(escapedName __String, context NodeBuilderContext, type_ TypeParameter) /* TODO(undefined): boolean */ TODO {
			result := resolveName(context.enclosingDeclaration, escapedName, SymbolFlagsType, nil, false)
			if result && result.flags&SymbolFlagsTypeParameter {
				return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== type.symbol */ TODO
			}
			return false
		}
		typeParameterToName := func(type_ TypeParameter, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier */ TODO {
			if context.flags&NodeBuilderFlagsGenerateNamesForShadowedTypeParams && context.typeParameterNames {
				cached := context.typeParameterNames.get(getTypeId(type_))
				if cached {
					return cached
				}
			}
			result := symbolToName(type_.symbol, context, SymbolFlagsType, true)
			if !(result.kind & SyntaxKindIdentifier) {
				return factory.createIdentifier("(Missing type parameter)")
			}
			decl := /* TODO(ElementAccessExpression): type.symbol?.declarations?.[0] */ TODO
			if decl && isTypeParameterDeclaration(decl) {
				result = setTextRange(context, result, decl.name)
			}
			if context.flags & NodeBuilderFlagsGenerateNamesForShadowedTypeParams {
				rawtext := result.escapedText /* as */ /* TODO(StringKeyword): string */
				i := context.typeParameterNamesByTextNextNameCount.get(rawtext) || 0
				text := rawtext
				/* TODO(WhileStatement): while (context.typeParameterNamesByText?.has(text) || typeParameterShadowsOtherTypeParameterInScope(text as __String, context, type)) {                     i++;                     text = `${rawtext}_${i}`;                 } */
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): text !== rawtext */ TODO {
					typeArguments := getIdentifierTypeArguments(result)
					result = factory.createIdentifier(text)
					setIdentifierTypeArguments(result, typeArguments)
				}
				if context.mustCreateTypeParametersNamesLookups {
					context.mustCreateTypeParametersNamesLookups = false
					context.typeParameterNames = /* TODO(NewExpression): new Map(context.typeParameterNames) */ TODO
					context.typeParameterNamesByTextNextNameCount = /* TODO(NewExpression): new Map(context.typeParameterNamesByTextNextNameCount) */ TODO
					context.typeParameterNamesByText = /* TODO(NewExpression): new Set(context.typeParameterNamesByText) */ TODO
				}
				/* TODO(NonNullExpression): context.typeParameterNamesByTextNextNameCount! */ TODO.set(rawtext, i)
				/* TODO(NonNullExpression): context.typeParameterNames! */ TODO.set(getTypeId(type_), result)
				/* TODO(NonNullExpression): context.typeParameterNamesByText! */ TODO.add(text)
			}
			return result
		}
		// OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): true */ TODO) Identifier
		// OVERLOAD: symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier /* TODO(LiteralType): false */ TODO) EntityName
		symbolToName := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags, expectsIdentifier bool) EntityName {
			chain := lookupSymbolChain(symbol, context, meaning)
			if expectsIdentifier && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): chain.length !== 1 */ TODO && !context.encounteredError && !(context.flags & NodeBuilderFlagsAllowQualifiedNameInPlaceOfIdentifier) {
				context.encounteredError = true
			}
			return createEntityNameFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO)
			createEntityNameFromSymbolChain := func(chain []Symbol, index number) EntityName {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
				if typeParameterNodes {
					/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
				}
				identifier.symbol = symbol
				return /* TODO(ConditionalExpression): index > 0 ? factory.createQualifiedName(createEntityNameFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
			}
		}
		symbolToExpression := func(symbol Symbol, context NodeBuilderContext, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
			chain := lookupSymbolChain(symbol, context, meaning)
			return createExpressionFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): chain.length - 1 */, TODO)
			createExpressionFromSymbolChain := func(chain []Symbol, index number) Expression {
				typeParameterNodes := lookupTypeParameterNodes(chain, index, context)
				symbol := /* TODO(ElementAccessExpression): chain[index] */ TODO
				if index == 0 {
					context.flags |= NodeBuilderFlagsInInitialEntityName
				}
				symbolName := getNameOfSymbolAsWritten(symbol, context)
				if index == 0 {
					context.flags ^= NodeBuilderFlagsInInitialEntityName
				}
				firstChar := symbolName.charCodeAt(0)
				if isSingleOrDoubleQuote(firstChar) && some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol) {
					return factory.createStringLiteral(getSpecifierForModuleSymbol(symbol, context))
				}
				if index == 0 || canUsePropertyAccess(symbolName, languageVersion) {
					identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
					if typeParameterNodes {
						/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
					}
					identifier.symbol = symbol
					return /* TODO(ConditionalExpression): index > 0 ? factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain, index - 1), identifier) : identifier */ TODO
				} else {
					if firstChar == CharacterCodesopenBracket {
						symbolName = symbolName.substring(1 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): symbolName.length - 1 */, TODO)
						firstChar = symbolName.charCodeAt(0)
					}
					var expression *Expression
					if isSingleOrDoubleQuote(firstChar) && !(symbol.flags & SymbolFlagsEnumMember) {
						expression = factory.createStringLiteral(stripQuotes(symbolName).replace( /* TODO(RegularExpressionLiteral): /\\./g */ TODO, func(s /* TODO(undefined): string */ TODO) /* TODO(undefined): string */ TODO {
							/* TODO(PropertyAccessExpression): s.substring */
							/* TODO(NumericLiteral): 1 */
						}), firstChar == CharacterCodessingleQuote)
					} else if ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + +symbolName */ TODO) == symbolName {
						expression = factory.createNumericLiteral(+symbolName)
					}
					if !expression {
						identifier := setEmitFlags(factory.createIdentifier(symbolName), EmitFlagsNoAsciiEscaping)
						if typeParameterNodes {
							/* TODO(CallExpression): setIdentifierTypeArguments(identifier, factory.createNodeArray<TypeNode | TypeParameterDeclaration>(typeParameterNodes)) */
						}
						identifier.symbol = symbol
						expression = identifier
					}
					return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain /* TODO(MinusToken): - */ /* TODO(BinaryExpression): index - 1 */, TODO), expression)
				}
			}
		}
		isStringNamed := func(d Declaration) /* TODO(undefined): boolean */ TODO {
			name := getNameOfDeclaration(d)
			if !name {
				return false
			}
			if isComputedPropertyName(name) {
				type_ := checkExpression(name.expression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			if isElementAccessExpression(name) {
				type_ := checkExpression(name.argumentExpression)
				return !!(type_.flags & TypeFlagsStringLike)
			}
			return isStringLiteral(name)
		}
		isSingleQuotedStringNamed := func(d Declaration) /* TODO(undefined): boolean */ TODO {
			name := getNameOfDeclaration(d)
			return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, false), "'")))
		}
		getPropertyNameNodeForSymbol := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName */ TODO {
			stringNamed := !!length(symbol.declarations) && every(symbol.declarations, isStringNamed)
			singleQuote := !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed)
			isMethod := !!(symbol.flags & SymbolFlagsMethod)
			fromNameType := getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed, isMethod)
			if fromNameType {
				return fromNameType
			}
			rawName := unescapeLeadingUnderscores(symbol.escapedName)
			return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
		}
		getPropertyNameNodeForSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext, singleQuote bool, stringNamed bool, isMethod bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | import("/home/jabaile/work/TypeScript/src/compiler/types").NumericLiteral | import("/home/jabaile/work/TypeScript/src/compiler/types").ComputedPropertyName | undefined */ TODO {
			nameType := getSymbolLinks(symbol).nameType
			if nameType {
				if nameType.flags & TypeFlagsStringOrNumberLiteral {
					name := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
					if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name)) {
						return factory.createStringLiteral(name, !!singleQuote)
					}
					if isNumericLiteralName(name) && startsWith(name, "-") {
						return factory.createComputedPropertyName(factory.createPrefixUnaryExpression(SyntaxKindMinusToken, factory.createNumericLiteral(-name)))
					}
					return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed, isMethod)
				}
				if nameType.flags & TypeFlagsUniqueESSymbol {
					return factory.createComputedPropertyName(symbolToExpression((nameType /* as */ /* TODO(TypeReference): UniqueESSymbolType */).symbol, context, SymbolFlagsValue))
				}
			}
		}
		cloneNodeBuilderContext := func(context NodeBuilderContext) /* TODO(undefined): () => void */ TODO {
			oldMustCreateTypeParameterSymbolList := context.mustCreateTypeParameterSymbolList
			oldMustCreateTypeParametersNamesLookups := context.mustCreateTypeParametersNamesLookups
			context.mustCreateTypeParameterSymbolList = true
			context.mustCreateTypeParametersNamesLookups = true
			oldTypeParameterNames := context.typeParameterNames
			oldTypeParameterNamesByText := context.typeParameterNamesByText
			oldTypeParameterNamesByTextNextNameCount := context.typeParameterNamesByTextNextNameCount
			oldTypeParameterSymbolList := context.typeParameterSymbolList
			return func() {
				context.typeParameterNames = oldTypeParameterNames
				context.typeParameterNamesByText = oldTypeParameterNamesByText
				context.typeParameterNamesByTextNextNameCount = oldTypeParameterNamesByTextNextNameCount
				context.typeParameterSymbolList = oldTypeParameterSymbolList
				context.mustCreateTypeParameterSymbolList = oldMustCreateTypeParameterSymbolList
				context.mustCreateTypeParametersNamesLookups = oldMustCreateTypeParametersNamesLookups
			}
		}
		getDeclarationWithTypeAnnotation := func(symbol Symbol, enclosingDeclaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
			return symbol.declarations && find(symbol.declarations, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !!getNonlocalEffectiveTypeAnnotationNode(s) */
				/* TODO(AmpersandAmpersandToken): && */
				/* TODO(ParenthesizedExpression): (!enclosingDeclaration || !!findAncestor(s, n => n === enclosingDeclaration)) */
			})
		}
		existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount := func(existing TypeNode, type_ Type) /* TODO(undefined): boolean */ TODO {
			if !(getObjectFlags(type_) & ObjectFlagsReference) {
				/* TODO(TrueKeyword): true */
			}
			if !isTypeReferenceNode(existing) {
				/* TODO(TrueKeyword): true */
			}
			/* TODO(ExpressionStatement): void getTypeFromTypeReference(existing); */
			symbol := getNodeLinks(existing).resolvedSymbol
			existingTarget := symbol && getDeclaredTypeOfSymbol(symbol)
			if !existingTarget || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): existingTarget !== (type as TypeReference).target */ TODO {
				/* TODO(TrueKeyword): true */
			}
			return length(existing.typeArguments) >= getMinTypeArgumentCount((type_ /* as */ /* TODO(TypeReference): TypeReference */).target.typeParameters)
		}
		getEnclosingDeclarationIgnoringFakeScope := func(enclosingDeclaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO {
			/* TODO(WhileStatement): while (getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration) {                 enclosingDeclaration = enclosingDeclaration.parent;             } */
			return enclosingDeclaration
		}
		serializeTypeForDeclaration := func(context NodeBuilderContext, declaration Declaration, type_ Type, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			addUndefinedForParameter := declaration && (isParameter(declaration) || isJSDocParameterTag(declaration)) && requiresAddingImplicitUndefined(declaration, context.enclosingDeclaration)
			enclosingDeclaration := context.enclosingDeclaration
			restoreFlags := saveRestoreFlags(context)
			if declaration && hasInferredType(declaration) && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
				syntacticNodeBuilder.serializeTypeOfDeclaration(declaration, context)
			}
			context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
			if enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) {
				declWithExistingAnnotation := /* TODO(ConditionalExpression): declaration && getNonlocalEffectiveTypeAnnotationNode(declaration)                     ? declaration                     : getDeclarationWithTypeAnnotation(symbol) */ TODO
				if declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation) {
					existing := /* TODO(NonNullExpression): getNonlocalEffectiveTypeAnnotationNode(declWithExistingAnnotation)! */ TODO
					addUndefined := addUndefinedForParameter || !!(symbol.flags&SymbolFlagsProperty && symbol.flags&SymbolFlagsOptional && isOptionalDeclaration(declWithExistingAnnotation) && (symbol /* as */ /* TODO(TypeReference): MappedSymbol */).links.mappedType && containsNonMissingUndefinedType(type_))
					result := !isTypePredicateNode(existing) && tryReuseExistingTypeNode(context, existing, type_, declWithExistingAnnotation, addUndefined)
					if result {
						restoreFlags()
						return result
					}
				}
			}
			if type_.flags&TypeFlagsUniqueESSymbol && type_.symbol == symbol && (!context.enclosingDeclaration || some(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(CallExpression): getSourceFileOfNode(d) */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(CallExpression): getSourceFileOfNode(context.enclosingDeclaration!) */
			})) {
				context.flags |= NodeBuilderFlagsAllowUniqueESSymbolType
			}
			decl := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): declaration ?? symbol.valueDeclaration ?? symbol.declarations?.[0] */ TODO
			expr := /* TODO(ConditionalExpression): decl && isDeclarationWithPossibleInnerTypeNodeReuse(decl) ? getPossibleTypeNodeReuseExpression(decl) : undefined */ TODO
			result := expressionOrTypeToTypeNode(context, expr, type_, addUndefinedForParameter)
			restoreFlags()
			return result
		}
		typeNodeIsEquivalentToType := func(annotatedDeclaration Node, type_ Type, typeFromTypeNode Type) /* TODO(undefined): boolean */ TODO {
			if typeFromTypeNode == type_ {
				return true
			}
			if annotatedDeclaration && (isParameter(annotatedDeclaration) || isPropertySignature(annotatedDeclaration) || isPropertyDeclaration(annotatedDeclaration)) && annotatedDeclaration.questionToken {
				return getTypeWithFacts(type_, TypeFactsNEUndefined) == typeFromTypeNode
			}
			return false
		}
		serializeReturnTypeForSignature := func(context NodeBuilderContext, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			suppressAny := context.flags & NodeBuilderFlagsSuppressAnyReturnType
			restoreFlags := saveRestoreFlags(context)
			if suppressAny {
				/* TODO(BinaryExpression): context.flags &= ~NodeBuilderFlags.SuppressAnyReturnType */
			}
			var returnTypeNode *TypeNode
			returnType := getReturnTypeOfSignature(signature)
			if returnType && !(suppressAny && isTypeAny(returnType)) {
				if signature.declaration && !(context.internalFlags & InternalNodeBuilderFlagsNoSyntacticPrinter) {
					syntacticNodeBuilder.serializeReturnTypeForSignature(signature.declaration, context)
				}
				context.internalFlags |= InternalNodeBuilderFlagsNoSyntacticPrinter
				returnTypeNode = serializeReturnTypeForSignatureWorker(context, signature)
			} else if !suppressAny {
				returnTypeNode = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
			}
			restoreFlags()
			return returnTypeNode
		}
		serializeReturnTypeForSignatureWorker := func(context NodeBuilderContext, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			typePredicate := getTypePredicateOfSignature(signature)
			type_ := getReturnTypeOfSignature(signature)
			if context.enclosingDeclaration && (!isErrorType(type_) || (context.internalFlags & InternalNodeBuilderFlagsAllowUnresolvedNames)) && signature.declaration && !nodeIsSynthesized(signature.declaration) {
				annotation := getNonlocalEffectiveReturnTypeAnnotationNode(signature.declaration)
				if annotation {
					result := tryReuseExistingTypeNode(context, annotation, type_, context.enclosingDeclaration)
					if result {
						return result
					}
				}
			}
			if typePredicate {
				return typePredicateToTypePredicateNodeHelper(typePredicate, context)
			}
			expr := signature.declaration && getPossibleTypeNodeReuseExpression(signature.declaration)
			return expressionOrTypeToTypeNode(context, expr, type_)
		}
		trackExistingEntityName := func(node T, context NodeBuilderContext) /* TODO(undefined): { introducesError: boolean; node: T; sym?: undefined; } | { introducesError: boolean; node: T; sym: import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined; } */ TODO {
			introducesError := false
			leftmost := getFirstIdentifier(node)
			if isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || (isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) {
				introducesError = true
				return /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
			}
			meaning := getMeaningOfEntityNameReference(node)
			var sym *Symbol
			if isThisIdentifier(leftmost) {
				sym = getSymbolOfDeclaration(getThisContainer(leftmost, false, false))
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isSymbolAccessible(sym, leftmost, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
					introducesError = true
					context.tracker.reportInaccessibleThisError()
				}
				return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			sym = resolveEntityName(leftmost, meaning, true, true)
			if context.enclosingDeclaration && !(sym && sym.flags&SymbolFlagsTypeParameter) {
				sym = getExportSymbolOfValueSymbolIfExported(sym)
				symAtLocation := resolveEntityName(leftmost, meaning, true, true, context.enclosingDeclaration)
				if symAtLocation == unknownSymbol || (symAtLocation == nil && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sym !== undefined */ TODO) || (symAtLocation && sym && !getSymbolIfSameReference(getExportSymbolOfValueSymbolIfExported(symAtLocation), sym)) {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symAtLocation !== unknownSymbol */ TODO {
						context.tracker.reportInferenceFallback(node)
					}
					introducesError = true
					return /* TODO(ObjectLiteralExpression): { introducesError, node, sym } */ TODO
				} else {
					sym = symAtLocation
				}
			}
			if sym {
				if sym.flags&SymbolFlagsFunctionScopedVariable && sym.valueDeclaration {
					if isPartOfParameterDeclaration(sym.valueDeclaration) || isJSDocParameterTag(sym.valueDeclaration) {
						return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
					}
				}
				if !(sym.flags & SymbolFlagsTypeParameter) && !isDeclarationName(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isSymbolAccessible(sym, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
					context.tracker.reportInferenceFallback(node)
					introducesError = true
				} else {
					context.tracker.trackSymbol(sym, context.enclosingDeclaration, meaning)
				}
				return /* TODO(ObjectLiteralExpression): { introducesError, node: attachSymbolToLeftmostIdentifier(node) as T } */ TODO
			}
			return /* TODO(ObjectLiteralExpression): { introducesError, node } */ TODO
			attachSymbolToLeftmostIdentifier := func(node Node) Node {
				if node == leftmost {
					type_ := getDeclaredTypeOfSymbol( /* TODO(NonNullExpression): sym! */ TODO)
					name := /* TODO(ConditionalExpression): sym!.flags & SymbolFlags.TypeParameter ? typeParameterToName(type, context) : factory.cloneNode(node as Identifier) */ TODO
					name.symbol = /* TODO(NonNullExpression): sym! */ TODO
					return setTextRange(context, setEmitFlags(name, EmitFlagsNoAsciiEscaping), node)
				}
				updated := visitEachChildWorker(node, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO {
					/* TODO(Identifier): attachSymbolToLeftmostIdentifier */
					/* TODO(Identifier): c */
				}, nil)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): updated !== node */ TODO {
					setTextRange(context, updated, node)
				}
				return updated
			}
		}
		serializeTypeName := func(context NodeBuilderContext, node EntityName, isTypeOf bool, typeArguments []TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			meaning := /* TODO(ConditionalExpression): isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
			symbol := resolveEntityName(node, meaning, true)
			if !symbol {
				/* TODO(Identifier): undefined */
			}
			resolvedSymbol := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isSymbolAccessible(symbol, context.enclosingDeclaration, meaning, /*shouldComputeAliasesToMakeVisible* / false).accessibility !== SymbolAccessibility.Accessible */ TODO {
				/* TODO(Identifier): undefined */
			}
			return symbolToTypeNode(resolvedSymbol, context, meaning, typeArguments)
		}
		canReuseTypeNode := func(context NodeBuilderContext, existing TypeNode) /* TODO(undefined): number | boolean */ TODO {
			if isInJSFile(existing) {
				if isLiteralImportTypeNode(existing) {
					/* TODO(ExpressionStatement): void getTypeFromImportTypeNode(existing); */
					nodeSymbol := getNodeLinks(existing).resolvedSymbol
					return (!nodeSymbol || !((!existing.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(existing.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))))
				}
			}
			if isThisTypeNode(existing) {
				if context.mapper == nil {
					/* TODO(TrueKeyword): true */
				}
				type_ := getTypeFromTypeNode(context, existing, true)
				return !!type_
			}
			if isTypeReferenceNode(existing) {
				if isConstTypeReference(existing) {
					/* TODO(FalseKeyword): false */
				}
				type_ := getTypeFromTypeReference(existing)
				symbol := getNodeLinks(existing).resolvedSymbol
				if !symbol {
					/* TODO(FalseKeyword): false */
				}
				if symbol.flags & SymbolFlagsTypeParameter {
					type_ := getDeclaredTypeOfSymbol(symbol)
					if context.mapper && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getMappedType(type, context.mapper) !== type */ TODO {
						return false
					}
				}
				if isInJSDoc(existing) {
					return existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type_) && !getIntendedTypeFromJSDocTypeReference(existing) && (symbol.flags & SymbolFlagsType)
				}
			}
			if isTypeOperatorNode(existing) && existing.operator == SyntaxKindUniqueKeyword && existing.type_.kind == SyntaxKindSymbolKeyword {
				effectiveEnclosingContext := context.enclosingDeclaration && getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration)
				return !!findAncestor(existing, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): n */
					/* TODO(EqualsEqualsEqualsToken): === */
					/* TODO(Identifier): effectiveEnclosingContext */
				})
			}
			return true
		}
		serializeExistingTypeNode := func(context NodeBuilderContext, typeNode TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
			type_ := getTypeFromTypeNode(context, typeNode)
			return typeToTypeNodeHelper(type_, context)
		}
		tryReuseExistingTypeNodeHelper := func(context NodeBuilderContext, existing TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			if cancellationToken && cancellationToken.throwIfCancellationRequested {
				cancellationToken.throwIfCancellationRequested()
			}
			hadError := false
			TODO_IDENTIFIER := createRecoveryBoundary()
			transformed := visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode)
			if !finalizeBoundary() {
				return nil
			}
			context.approximateLength += /* TODO(MinusToken): - */ /* TODO(BinaryExpression): existing.end - existing.pos */ TODO
			return transformed
			visitExistingNodeTreeSymbols := func(node Node) Node {
				if hadError {
					/* TODO(Identifier): node */
				}
				recover := startRecoveryScope()
				onExitNewScope := /* TODO(ConditionalExpression): isNewScopeNode(node) ? onEnterNewScope(node) : undefined */ TODO
				result := visitExistingNodeTreeSymbolsWorker(node)
				onExitNewScope()
				if hadError {
					if isTypeNode(node) && !isTypePredicateNode(node) {
						recover()
						return serializeExistingTypeNode(context, node)
					}
					return node
				}
				return /* TODO(ConditionalExpression): result ? setTextRange(context, result, node) : undefined */ TODO
			}
			createRecoveryBoundary := func() /* TODO(undefined): { startRecoveryScope: () => () => void; finalizeBoundary: () => boolean; } */ TODO {
				var trackedSymbols []TrackedSymbol
				var unreportedErrors []func()
				oldTracker := context.tracker
				oldTrackedSymbols := context.trackedSymbols
				context.trackedSymbols = nil
				oldEncounteredError := context.encounteredError
				context.tracker = /* TODO(NewExpression): new SymbolTrackerImpl(context, {                     ...oldTracker.inner,                     reportCyclicStructureError() {                         markError(() => oldTracker.reportCyclicStructureError());                     },                     reportInaccessibleThisError() {                         markError(() => oldTracker.reportInaccessibleThisError());                     },                     reportInaccessibleUniqueSymbolError() {                         markError(() => oldTracker.reportInaccessibleUniqueSymbolError());                     },                     reportLikelyUnsafeImportRequiredError(specifier) {                         markError(() => oldTracker.reportLikelyUnsafeImportRequiredError(specifier));                     },                     reportNonSerializableProperty(name) {                         markError(() => oldTracker.reportNonSerializableProperty(name));                     },                     trackSymbol(sym, decl, meaning) {                         (trackedSymbols ??= []).push([sym, decl, meaning]);                         return false;                     },                     moduleResolverHost: context.tracker.moduleResolverHost,                 }, context.tracker.moduleResolverHost) */ TODO
				return /* TODO(ObjectLiteralExpression): {                     startRecoveryScope,                     finalizeBoundary,                 } */ TODO
				markError := func(unreportedError func()) {
					hadError = true
					( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): unreportedErrors ??= [] */ TODO).push(unreportedError)
				}
				startRecoveryScope := func() /* TODO(undefined): () => void */ TODO {
					trackedSymbolsTop := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): trackedSymbols?.length ?? 0 */ TODO
					unreportedErrorsTop := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): unreportedErrors?.length ?? 0 */ TODO
					return func() {
						hadError = false
						if trackedSymbols {
							trackedSymbols.length = trackedSymbolsTop
						}
						if unreportedErrors {
							unreportedErrors.length = unreportedErrorsTop
						}
					}
				}
				finalizeBoundary := func() /* TODO(undefined): boolean */ TODO {
					context.tracker = oldTracker
					context.trackedSymbols = oldTrackedSymbols
					context.encounteredError = oldEncounteredError
					unreportedErrors.forEach(func(fn /* TODO(undefined): () => void */ TODO) {
						/* TODO(Identifier): fn */
					})
					if hadError {
						return false
					}
					trackedSymbols.forEach(func(TODO_IDENTIFIER /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TrackedSymbol */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(PropertyAccessExpression): context.tracker.trackSymbol */
						/* TODO(Identifier): symbol */
						/* TODO(Identifier): enclosingDeclaration */
						/* TODO(Identifier): meaning */
					})
					return true
				}
			}
			onEnterNewScope := func(node /* TODO(UnionType): IntroducesNewScopeNode | ConditionalTypeNode */ any) /* TODO(undefined): () => void */ TODO {
				return enterNewScope(context, node, getParametersInScope(node), getTypeParametersInScope(node))
			}
			tryVisitSimpleTypeNode := func(node TypeNode) *TypeNode {
				innerNode := skipTypeParentheses(node)
				/* TODO(SwitchStatement): switch (innerNode.kind) {                     case SyntaxKind.TypeReference:                         return tryVisitTypeReference(innerNode as TypeReferenceNode);                     case SyntaxKind.TypeQuery:                         return tryVisitTypeQuery(innerNode as TypeQueryNode);                     case SyntaxKind.IndexedAccessType:                         return tryVisitIndexedAccess(innerNode as IndexedAccessTypeNode);                     case SyntaxKind.TypeOperator:                         const typeOperatorNode = innerNode as TypeOperatorNode;                         if (typeOperatorNode.operator === SyntaxKind.KeyOfKeyword) {                             return tryVisitKeyOf(typeOperatorNode);                         }                 } */
				return visitNode(node, visitExistingNodeTreeSymbols, isTypeNode)
			}
			tryVisitIndexedAccess := func(node IndexedAccessTypeNode) *TypeNode {
				resultObjectType := tryVisitSimpleTypeNode(node.objectType)
				if resultObjectType == nil {
					return nil
				}
				return factory.updateIndexedAccessTypeNode(node, resultObjectType /* TODO(NonNullExpression): visitNode(node.indexType, visitExistingNodeTreeSymbols, isTypeNode)! */, TODO)
			}
			tryVisitKeyOf := func(node TypeOperatorNode) *TypeNode {
				Debug.assertEqual(node.operator, SyntaxKindKeyOfKeyword)
				type_ := tryVisitSimpleTypeNode(node.type_)
				if type_ == nil {
					return nil
				}
				return factory.updateTypeOperatorNode(node, type_)
			}
			tryVisitTypeQuery := func(node TypeQueryNode) *TypeNode {
				TODO_IDENTIFIER := trackExistingEntityName(node.exprName, context)
				if !introducesError {
					return factory.updateTypeQueryNode(node, exprName, visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode))
				}
				serializedName := serializeTypeName(context, node.exprName, true)
				if serializedName {
					return setTextRange(context, serializedName, node.exprName)
				}
			}
			tryVisitTypeReference := func(node TypeReferenceNode) *TypeNode {
				if canReuseTypeNode(context, node) {
					TODO_IDENTIFIER := trackExistingEntityName(node.typeName, context)
					typeArguments := visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode)
					if !introducesError {
						updated := factory.updateTypeReferenceNode(node, newName, typeArguments)
						return setTextRange(context, updated, node)
					} else {
						serializedName := serializeTypeName(context, node.typeName, false, typeArguments)
						if serializedName {
							return setTextRange(context, serializedName, node.typeName)
						}
					}
				}
			}
			visitExistingNodeTreeSymbolsWorker := func(node Node) Node {
				if isJSDocTypeExpression(node) {
					return visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode)
				}
				if isJSDocAllType(node) || node.kind == SyntaxKindJSDocNamepathType {
					return factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
				}
				if isJSDocUnknownType(node) {
					return factory.createKeywordTypeNode(SyntaxKindUnknownKeyword)
				}
				if isJSDocNullableType(node) {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createLiteralTypeNode(factory.createNull())] */ TODO)
				}
				if isJSDocOptionalType(node) {
					return factory.createUnionTypeNode( /* TODO(ArrayLiteralExpression): [visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)!, factory.createKeywordTypeNode(SyntaxKind.UndefinedKeyword)] */ TODO)
				}
				if isJSDocNonNullableType(node) {
					return visitNode(node.type_, visitExistingNodeTreeSymbols)
				}
				if isJSDocVariadicType(node) {
					return factory.createArrayTypeNode( /* TODO(NonNullExpression): visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO)
				}
				if isJSDocTypeLiteral(node) {
					return factory.createTypeLiteralNode(map_(node.jsDocPropertyTags, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocPropertyLikeTag */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").PropertySignature */ TODO {
						name := /* TODO(NonNullExpression): visitNode(isIdentifier(t.name) ? t.name : t.name.right, visitExistingNodeTreeSymbols, isIdentifier)! */ TODO
						typeViaParent := getTypeOfPropertyOfType(getTypeFromTypeNode(context, node), name.escapedText)
						overrideTypeNode := /* TODO(ConditionalExpression): typeViaParent && t.typeExpression && getTypeFromTypeNode(context, t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : undefined */ TODO
						return factory.createPropertySignature(nil, name /* TODO(ConditionalExpression): t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type) ? factory.createToken(SyntaxKind.QuestionToken) : undefined */, TODO, overrideTypeNode || (t.typeExpression && visitNode(t.typeExpression.type_, visitExistingNodeTreeSymbols, isTypeNode)) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}))
				}
				if isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText == "" {
					return setOriginalNode(factory.createKeywordTypeNode(SyntaxKindAnyKeyword), node)
				}
				if (isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node) {
					return factory.createTypeLiteralNode( /* TODO(ArrayLiteralExpression): [factory.createIndexSignature(                         /*modifiers* / undefined,                         [factory.createParameterDeclaration(                             /*modifiers* / undefined,                             /*dotDotDotToken* / undefined,                             "x",                             /*questionToken* / undefined,                             visitNode(node.typeArguments![0], visitExistingNodeTreeSymbols, isTypeNode),                         )],                         visitNode(node.typeArguments![1], visitExistingNodeTreeSymbols, isTypeNode),                     )] */ TODO)
				}
				if isJSDocFunctionType(node) {
					if isJSDocConstructSignature(node) {
						var newTypeNode *TypeNode
						return factory.createConstructorTypeNode(nil, visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined(node.parameters, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
							/* TODO(BinaryExpression): p.name && isIdentifier(p.name) && p.name.escapedText === "new" */
							/* TODO(QuestionToken): ? */
							/* TODO(ParenthesizedExpression): (newTypeNode = p.type, undefined) */
							/* TODO(ColonToken): : */
							/* TODO(CallExpression): factory.createParameterDeclaration(                                     /*modifiers* / undefined,                                     getEffectiveDotDotDotForParameter(p),                                     setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p),                                     factory.cloneNode(p.questionToken),                                     visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode),                                     /*initializer* / undefined,                                 ) */
						}), visitNode(newTypeNode || node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					} else {
						return factory.createFunctionTypeNode(visitNodes(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map_(node.parameters, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
							/* TODO(PropertyAccessExpression): factory.createParameterDeclaration */
							/* TODO(Identifier): undefined */
							/* TODO(CallExpression): getEffectiveDotDotDotForParameter(p) */
							/* TODO(CallExpression): setTextRange(context, factory.createIdentifier(getNameForJSDocFunctionParameter(p, i)), p) */
							/* TODO(CallExpression): factory.cloneNode(p.questionToken) */
							/* TODO(CallExpression): visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode) */
							/* TODO(Identifier): undefined */
						}), visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
					}
				}
				if isThisTypeNode(node) {
					if canReuseTypeNode(context, node) {
						return node
					}
					hadError = true
					return node
				}
				if isTypeParameterDeclaration(node) {
					return factory.updateTypeParameterDeclaration(node, visitNodes(node.modifiers, visitExistingNodeTreeSymbols, isModifier), setTextRange(context, typeParameterToName(getDeclaredTypeOfSymbol(getSymbolOfDeclaration(node)), context), node), visitNode(node.constraint, visitExistingNodeTreeSymbols, isTypeNode), visitNode(node.default_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isIndexedAccessTypeNode(node) {
					result := tryVisitIndexedAccess(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isTypeReferenceNode(node) {
					result := tryVisitTypeReference(node)
					if result {
						return result
					}
					hadError = true
					return node
				}
				if isLiteralImportTypeNode(node) {
					nodeSymbol := getNodeLinks(node).resolvedSymbol
					if isInJSDoc(node) && nodeSymbol && ((!node.isTypeOf && !(nodeSymbol.flags & SymbolFlagsType)) || !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol)))) {
						return setTextRange(context, typeToTypeNodeHelper(getTypeFromTypeNode(context, node), context), node)
					}
					return factory.updateImportTypeNode(node, factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), visitNode(node.attributes, visitExistingNodeTreeSymbols, isImportAttributes), visitNode(node.qualifier, visitExistingNodeTreeSymbols, isEntityName), visitNodes(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode), node.isTypeOf)
				}
				if isNamedDeclaration(node) && node.name.kind == SyntaxKindComputedPropertyName && !isLateBindableName(node.name) {
					if !hasDynamicName(node) {
						return visitEachChild(node, visitExistingNodeTreeSymbols)
					}
					if !(context.internalFlags&InternalNodeBuilderFlagsAllowUnresolvedNames && isEntityNameExpression(node.name.expression) && checkComputedPropertyName(node.name).flags&TypeFlagsAny) {
						return nil
					}
				}
				if (isFunctionLike(node) && !node.type_) || (isPropertyDeclaration(node) && !node.type_ && !node.initializer) || (isPropertySignature(node) && !node.type_ && !node.initializer) || (isParameter(node) && !node.type_ && !node.initializer) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					if visited == node {
						visited = setTextRange(context, factory.cloneNode(node), node)
					}
					(visited /* as */ /* TODO(TypeReference): Mutable<typeof visited> */).type_ = factory.createKeywordTypeNode(SyntaxKindAnyKeyword)
					if isParameter(node) {
						(visited /* as */ /* TODO(TypeReference): Mutable<ParameterDeclaration> */).modifiers = nil
					}
					return visited
				}
				if isTypeQueryNode(node) {
					result := tryVisitTypeQuery(node)
					if !result {
						hadError = true
						return node
					}
					return result
				}
				if isComputedPropertyName(node) && isEntityNameExpression(node.expression) {
					TODO_IDENTIFIER := trackExistingEntityName(node.expression, context)
					if !introducesError {
						return factory.updateComputedPropertyName(node, result)
					} else {
						type_ := getWidenedType(getRegularTypeOfExpression(node.expression))
						computedPropertyNameType := typeToTypeNodeHelper(type_, context)
						var literal TODO
						if isLiteralTypeNode(computedPropertyNameType) {
							literal = computedPropertyNameType.literal
						} else {
							evaluated := evaluateEntityNameExpression(node.expression)
							literalNode := /* TODO(ConditionalExpression): typeof evaluated.value === "string" ? factory.createStringLiteral(evaluated.value, /*isSingleQuote* / undefined) :                                 typeof evaluated.value === "number" ? factory.createNumericLiteral(evaluated.value, /*numericLiteralFlags* / 0) :                                 undefined */ TODO
							if !literalNode {
								if isImportTypeNode(computedPropertyNameType) {
									trackComputedName(node.expression, context.enclosingDeclaration, context)
								}
								return node
							}
							literal = literalNode
						}
						if literal.kind == SyntaxKindStringLiteral && isIdentifierText(literal.text, getEmitScriptTarget(compilerOptions)) {
							return factory.createIdentifier(literal.text)
						}
						if literal.kind == SyntaxKindNumericLiteral && !literal.text.startsWith("-") {
							return literal
						}
						return factory.updateComputedPropertyName(node, literal)
					}
				}
				if isTypePredicateNode(node) {
					var parameterName TODO
					if isIdentifier(node.parameterName) {
						TODO_IDENTIFIER := trackExistingEntityName(node.parameterName, context)
						hadError = hadError || introducesError
						parameterName = result
					} else {
						parameterName = factory.cloneNode(node.parameterName)
					}
					return factory.updateTypePredicateNode(node, factory.cloneNode(node.assertsModifier), parameterName, visitNode(node.type_, visitExistingNodeTreeSymbols, isTypeNode))
				}
				if isTupleTypeNode(node) || isTypeLiteralNode(node) || isMappedTypeNode(node) {
					visited := visitEachChild(node, visitExistingNodeTreeSymbols)
					clone := setTextRange(context /* TODO(ConditionalExpression): visited === node ? factory.cloneNode(node) : visited */, TODO, node)
					flags := getEmitFlags(clone)
					setEmitFlags(clone, flags|( /* TODO(ConditionalExpression): context.flags & NodeBuilderFlags.MultilineObjectLiterals && isTypeLiteralNode(node) ? 0 : EmitFlags.SingleLine */ TODO))
					return clone
				}
				if isStringLiteral(node) && !!(context.flags & NodeBuilderFlagsUseSingleQuotesForStringLiteralType) && !node.singleQuote {
					clone := factory.cloneNode(node)
					(clone /* as */ /* TODO(TypeReference): Mutable<typeof clone> */).singleQuote = true
					return clone
				}
				if isConditionalTypeNode(node) {
					checkType := /* TODO(NonNullExpression): visitNode(node.checkType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					disposeScope := onEnterNewScope(node)
					extendType := /* TODO(NonNullExpression): visitNode(node.extendsType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					trueType := /* TODO(NonNullExpression): visitNode(node.trueType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					disposeScope()
					falseType := /* TODO(NonNullExpression): visitNode(node.falseType, visitExistingNodeTreeSymbols, isTypeNode)! */ TODO
					return factory.updateConditionalTypeNode(node, checkType, extendType, trueType, falseType)
				}
				if isTypeOperatorNode(node) {
					if node.operator == SyntaxKindUniqueKeyword && node.type_.kind == SyntaxKindSymbolKeyword {
						if !canReuseTypeNode(context, node) {
							hadError = true
							return node
						}
					} else if node.operator == SyntaxKindKeyOfKeyword {
						result := tryVisitKeyOf(node)
						if !result {
							hadError = true
							return node
						}
						return result
					}
				}
				return visitEachChild(node, visitExistingNodeTreeSymbols)
				// OVERLOAD: visitEachChild := func(node T, visitor Visitor) T
				// OVERLOAD: visitEachChild := func(node *T, visitor Visitor) *T
				visitEachChild := func(node *T, visitor Visitor) *T {
					nonlocalNode := !context.enclosingFile || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): context.enclosingFile !== getSourceFileOfNode(node) */ TODO
					return visitEachChildWorker(node, visitor, nil /* TODO(ConditionalExpression): nonlocalNode ? visitNodesWithoutCopyingPositions : undefined */, TODO)
				}
				visitNodesWithoutCopyingPositions := func(nodes *NodeArray[Node], visitor Visitor, test func(node Node) bool, start number, count number) *NodeArray[Node] {
					result := visitNodes(nodes, visitor, test, start, count)
					if result {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result.pos !== -1 */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result.end !== -1 */ TODO {
							if result == nodes {
								result = factory.createNodeArray(nodes.slice(), nodes.hasTrailingComma)
							}
							setTextRangePosEnd(result, -1, -1)
						}
					}
					return result
				}
				getEffectiveDotDotDotForParameter := func(p ParameterDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DotDotDotToken | undefined */ TODO {
					return p.dotDotDotToken || ( /* TODO(ConditionalExpression): p.type && isJSDocVariadicType(p.type) ? factory.createToken(SyntaxKind.DotDotDotToken) : undefined */ TODO)
				}
				getNameForJSDocFunctionParameter := func(p ParameterDeclaration, index number) /* TODO(undefined): string */ TODO {
					return /* TODO(ConditionalExpression): p.name && isIdentifier(p.name) && p.name.escapedText === "this" ? "this"                         : getEffectiveDotDotDotForParameter(p) ? `args`                         : `arg${index}` */ TODO
				}
				rewriteModuleSpecifier := func(parent ImportTypeNode, lit StringLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteral */ TODO {
					if context.bundled || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): context.enclosingFile !== getSourceFileOfNode(lit) */ TODO {
						name := lit.text
						nodeSymbol := getNodeLinks(node).resolvedSymbol
						meaning := /* TODO(ConditionalExpression): parent.isTypeOf ? SymbolFlags.Value : SymbolFlags.Type */ TODO
						parentSymbol := nodeSymbol && isSymbolAccessible(nodeSymbol, context.enclosingDeclaration, meaning, false).accessibility == SymbolAccessibilityAccessible && /* TODO(ElementAccessExpression): lookupSymbolChain(nodeSymbol, context, meaning, /*yieldModuleSymbol* / true)[0] */ TODO
						if parentSymbol && isExternalModuleSymbol(parentSymbol) {
							name = getSpecifierForModuleSymbol(parentSymbol, context)
						} else {
							targetFile := getExternalModuleFileFromDeclaration(parent)
							if targetFile {
								name = getSpecifierForModuleSymbol(targetFile.symbol, context)
							}
						}
						if name.includes("/node_modules/") {
							context.encounteredError = true
							if context.tracker.reportLikelyUnsafeImportRequiredError {
								context.tracker.reportLikelyUnsafeImportRequiredError(name)
							}
						}
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== lit.text */ TODO {
							return setOriginalNode(factory.createStringLiteral(name), lit)
						}
					}
					return /* TODO(NonNullExpression): visitNode(lit, visitExistingNodeTreeSymbols, isStringLiteral)! */ TODO
				}
			}
		}
		symbolTableToDeclarationStatements := func(symbolTable SymbolTable, context NodeBuilderContext) []Statement {
			serializePropertySymbolForClass := makeSerializePropertySymbol(factory.createPropertyDeclaration, SyntaxKindMethodDeclaration, true)
			serializePropertySymbolForInterfaceWorker := makeSerializePropertySymbol(func(mods /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Modifier[] | undefined */ TODO, name /* TODO(undefined): string | import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyName */ TODO, question /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ TODO, type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").PropertySignature */ TODO {
				/* TODO(PropertyAccessExpression): factory.createPropertySignature */
				/* TODO(Identifier): mods */
				/* TODO(Identifier): name */
				/* TODO(Identifier): question */
				/* TODO(Identifier): type */
			}, SyntaxKindMethodSignature, false)
			enclosingDeclaration := /* TODO(NonNullExpression): context.enclosingDeclaration! */ TODO
			var results []Statement = /* TODO(ArrayLiteralExpression): [] */ TODO
			visitedSymbols := /* TODO(NewExpression): new Set<number>() */ TODO
			var deferredPrivatesStack []Map[SymbolId, Symbol] = /* TODO(ArrayLiteralExpression): [] */ TODO
			oldcontext := context
			context = /* TODO(ObjectLiteralExpression): {                 ...oldcontext,                 usedSymbolNames: new Set(oldcontext.usedSymbolNames),                 remappedSymbolNames: new Map(),                 remappedSymbolReferences: new Map(oldcontext.remappedSymbolReferences?.entries()),                 tracker: undefined!,             } */ TODO
			var tracker SymbolTracker = /* TODO(ObjectLiteralExpression): {                 ...oldcontext.tracker.inner,                 trackSymbol: (sym, decl, meaning) => {                     if (context.remappedSymbolNames?.has(getSymbolId(sym))) return false; // If the context has a remapped name for the symbol, it *should* mean it's been made visible                     const accessibleResult = isSymbolAccessible(sym, decl, meaning, /*shouldComputeAliasesToMakeVisible* / false);                     if (accessibleResult.accessibility === SymbolAccessibility.Accessible) {                         // Lookup the root symbol of the chain of refs we'll use to access it and serialize it                         const chain = lookupSymbolChainWorker(sym, context, meaning);                         if (!(sym.flags & SymbolFlags.Property)) {                             // Only include referenced privates in the same file. Weird JS aliases may expose privates                             // from other files - assume JS transforms will make those available via expected means                             const root = chain[0];                             const contextFile = getSourceFileOfNode(oldcontext.enclosingDeclaration);                             if (some(root.declarations, d => getSourceFileOfNode(d) === contextFile)) {                                 includePrivateSymbol(root);                             }                         }                     }                     else if (oldcontext.tracker.inner?.trackSymbol) {                         return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning);                     }                     return false;                 },             } */ TODO
			context.tracker = /* TODO(NewExpression): new SymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost) */ TODO
			forEachEntry(symbolTable, func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				baseName := unescapeLeadingUnderscores(name)
				/* TODO(ExpressionStatement): void getInternalSymbolName(symbol, baseName); */
			})
			addingDeclare := !context.bundled
			exportEquals := symbolTable.get(InternalSymbolNameExportEquals)
			if exportEquals && symbolTable.size > 1 && exportEquals.flags&(SymbolFlagsAlias|SymbolFlagsModule) {
				symbolTable = createSymbolTable()
				symbolTable.set(InternalSymbolNameExportEquals, exportEquals)
			}
			visitSymbolTable(symbolTable)
			return mergeRedundantStatements(results)
			isIdentifierAndNotUndefined := func(node Node) /* TODO(TypePredicate): node is Identifier */ TODO {
				return !!node && node.kind == SyntaxKindIdentifier
			}
			getNamesOfDeclaration := func(statement Statement) []Identifier {
				if isVariableStatement(statement) {
					return filter(map_(statement.declarationList.declarations, getNameOfDeclaration), isIdentifierAndNotUndefined)
				}
				return filter( /* TODO(ArrayLiteralExpression): [getNameOfDeclaration(statement as DeclarationStatement)] */ TODO, isIdentifierAndNotUndefined)
			}
			flattenExportAssignedNamespace := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				exportAssignment := find(statements, isExportAssignment)
				nsIndex := findIndex(statements, isModuleDeclaration)
				ns := /* TODO(ConditionalExpression): nsIndex !== -1 ? statements[nsIndex] as ModuleDeclaration : undefined */ TODO
				if ns && exportAssignment && exportAssignment.isExportEquals && isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) == idText(exportAssignment.expression) && ns.body && isModuleBlock(ns.body) {
					excessExports := filter(statements, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(PrefixUnaryExpression): !(getEffectiveModifierFlags(s) & ModifierFlags.Export) */
					})
					name := ns.name
					body := ns.body
					if length(excessExports) {
						ns = factory.updateModuleDeclaration(ns, ns.modifiers, ns.name /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): body = factory.updateModuleBlock(                                 body,                                 factory.createNodeArray([                                     ...ns.body.statements,                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(/*isTypeOnly* / false, /*propertyName* / undefined, id))),                                         /*moduleSpecifier* / undefined,                                     ),                                 ]),                             ) */, TODO)
						statements = /* TODO(ArrayLiteralExpression): [...statements.slice(0, nsIndex), ns, ...statements.slice(nsIndex + 1)] */ TODO
					}
					if !find(statements, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(BinaryExpression): s !== ns */
						/* TODO(AmpersandAmpersandToken): && */
						/* TODO(CallExpression): nodeHasName(s, name) */
					}) {
						results = /* TODO(ArrayLiteralExpression): [] */ TODO
						mixinExportFlag := !some(body.statements, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): boolean */ TODO {
							/* TODO(BinaryExpression): hasSyntacticModifier(s, ModifierFlags.Export) || isExportAssignment(s) */
							/* TODO(BarBarToken): || */
							/* TODO(CallExpression): isExportDeclaration(s) */
						})
						forEach(body.statements, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) {
							addResult(s /* TODO(ConditionalExpression): mixinExportFlag ? ModifierFlags.Export : ModifierFlags.None */, TODO)
						})
						statements = /* TODO(ArrayLiteralExpression): [...filter(statements, s => s !== ns && s !== exportAssignment), ...results] */ TODO
					}
				}
				return statements
			}
			mergeExportDeclarations := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				exports := filter(statements, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(CallExpression): isNamedExports(d.exportClause) */
				}) /* as */ /* TODO(ArrayType): ExportDeclaration[] */
				if length(exports) > 1 {
					nonExports := filter(statements, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(BinaryExpression): !isExportDeclaration(d) || !!d.moduleSpecifier */
						/* TODO(BarBarToken): || */
						/* TODO(PrefixUnaryExpression): !d.exportClause */
					})
					statements = /* TODO(ArrayLiteralExpression): [                         ...nonExports,                         factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports(flatMap(exports, e => cast(e.exportClause, isNamedExports).elements)),                             /*moduleSpecifier* / undefined,                         ),                     ] */ TODO
				}
				reexports := filter(statements, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(CallExpression): isNamedExports(d.exportClause) */
				}) /* as */ /* TODO(ArrayType): ExportDeclaration[] */
				if length(reexports) > 1 {
					groups := group(reexports, func(decl /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration */ TODO) /* TODO(undefined): string */ TODO {
						/* TODO(CallExpression): isStringLiteral(decl.moduleSpecifier!) */
						/* TODO(QuestionToken): ? */
						/* TODO(BinaryExpression): ">" + decl.moduleSpecifier.text */
						/* TODO(ColonToken): : */
						/* TODO(StringLiteral): ">" */
					})
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): groups.length !== reexports.length */ TODO {
						for _, group := range groups {
							if group.length > 1 {
								statements = /* TODO(ArrayLiteralExpression): [                                     ...filter(statements, s => !group.includes(s as ExportDeclaration)),                                     factory.createExportDeclaration(                                         /*modifiers* / undefined,                                         /*isTypeOnly* / false,                                         factory.createNamedExports(flatMap(group, e => cast(e.exportClause, isNamedExports).elements)),                                         group[0].moduleSpecifier,                                     ),                                 ] */ TODO
							}
						}
					}
				}
				return statements
			}
			inlineExportModifiers := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				index := findIndex(statements, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): isExportDeclaration(d) && !d.moduleSpecifier && !d.attributes && !!d.exportClause */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(CallExpression): isNamedExports(d.exportClause) */
				})
				if index >= 0 {
					exportDecl := /* TODO(ElementAccessExpression): statements[index] */ TODO /* as */ /* TODO(IntersectionType): ExportDeclaration & { readonly exportClause: NamedExports; } */
					replacements := mapDefined(exportDecl.exportClause.elements, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier | undefined */ TODO {
						if !e.propertyName && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): e.name.kind !== SyntaxKind.StringLiteral */ TODO {
							name := e.name
							indices := indicesOf(statements)
							associatedIndices := filter(indices, func(i /* TODO(undefined): number */ TODO) /* TODO(undefined): boolean */ TODO {
								/* TODO(Identifier): nodeHasName */
								/* TODO(ElementAccessExpression): statements[i] */
								/* TODO(Identifier): name */
							})
							if length(associatedIndices) && every(associatedIndices, func(i /* TODO(undefined): number */ TODO) /* TODO(undefined): boolean */ TODO {
								/* TODO(Identifier): canHaveExportModifier */
								/* TODO(ElementAccessExpression): statements[i] */
							}) {
								for _, index := range associatedIndices {
									/* TODO(ElementAccessExpression): statements[index] */ TODO = addExportModifier( /* TODO(ElementAccessExpression): statements[index] */ TODO /* as */ /* TODO(TypeReference): Extract<HasModifiers, Statement> */)
								}
								return nil
							}
						}
						return e
					})
					if !length(replacements) {
						orderedRemoveItemAt(statements, index)
					} else {
						/* TODO(ElementAccessExpression): statements[index] */ TODO = factory.updateExportDeclaration(exportDecl, exportDecl.modifiers, exportDecl.isTypeOnly, factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.attributes)
					}
				}
				return statements
			}
			mergeRedundantStatements := func(statements []Statement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement[] */ TODO {
				statements = flattenExportAssignedNamespace(statements)
				statements = mergeExportDeclarations(statements)
				statements = inlineExportModifiers(statements)
				if enclosingDeclaration && ((isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration)) || isModuleDeclaration(enclosingDeclaration)) && (!some(statements, isExternalModuleIndicator) || (!hasScopeMarker(statements) && some(statements, needsScopeMarker))) {
					statements.push(createEmptyExports(factory))
				}
				return statements
			}
			addExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration */ TODO {
				flags := (getEffectiveModifierFlags(node) | ModifierFlagsExport) & ~ModifierFlagsAmbient
				return factory.replaceModifiers(node, flags)
			}
			removeExportModifier := func(node Extract[HasModifiers, Statement]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ModuleDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableStatement | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportEqualsDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ImportDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").EnumDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeAliasDeclaration */ TODO {
				flags := getEffectiveModifierFlags(node) & ~ModifierFlagsExport
				return factory.replaceModifiers(node, flags)
			}
			visitSymbolTable := func(symbolTable SymbolTable, suppressNewPrivateContext bool, propertyAsAlias bool) {
				if !suppressNewPrivateContext {
					deferredPrivatesStack.push( /* TODO(NewExpression): new Map() */ TODO)
				}
				symbolTable.forEach(func(symbol Symbol) {
					serializeSymbol(symbol, false, !!propertyAsAlias)
				})
				if !suppressNewPrivateContext {
					/* TODO(ElementAccessExpression): deferredPrivatesStack[deferredPrivatesStack.length - 1] */ TODO.forEach(func(symbol Symbol) {
						serializeSymbol(symbol, true, !!propertyAsAlias)
					})
					deferredPrivatesStack.pop()
				}
			}
			serializeSymbol := func(symbol Symbol, isPrivate bool, propertyAsAlias bool) {
				/* TODO(ExpressionStatement): void getPropertiesOfType(getTypeOfSymbol(symbol)); */
				visitedSym := getMergedSymbol(symbol)
				if visitedSymbols.has(getSymbolId(visitedSym)) {
					return
				}
				visitedSymbols.add(getSymbolId(visitedSym))
				skipMembershipCheck := !isPrivate
				if skipMembershipCheck || (!!length(symbol.declarations) && some(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !findAncestor(d, n => n === enclosingDeclaration) */
				})) {
					scopeCleanup := cloneNodeBuilderContext(context)
					serializeSymbolWorker(symbol, isPrivate, propertyAsAlias)
					scopeCleanup()
				}
			}
			serializeSymbolWorker := func(symbol Symbol, isPrivate bool, propertyAsAlias bool, escapedSymbolName /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO /* = */ /* TODO(PropertyAccessExpression): symbol.escapedName */) {
				symbolName := unescapeLeadingUnderscores(escapedSymbolName)
				isDefault := escapedSymbolName == InternalSymbolNameDefault
				if isPrivate && !(context.flags & NodeBuilderFlagsAllowAnonymousIdentifier) && isStringANonContextualKeyword(symbolName) && !isDefault {
					context.encounteredError = true
					return
				}
				needsPostExportDefault := isDefault && !!(symbol.flags&SymbolFlagsExportDoesNotSupportDefaultModifier || (symbol.flags&SymbolFlagsFunction && length(getPropertiesOfType(getTypeOfSymbol(symbol))))) && !(symbol.flags & SymbolFlagsAlias)
				needsExportDeclaration := !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName) && !isDefault
				if needsPostExportDefault || needsExportDeclaration {
					isPrivate = true
				}
				modifierFlags := ( /* TODO(ConditionalExpression): !isPrivate ? ModifierFlags.Export : 0 */ TODO) | ( /* TODO(ConditionalExpression): isDefault && !needsPostExportDefault ? ModifierFlags.Default : 0 */ TODO)
				isConstMergedWithNS := symbol.flags&SymbolFlagsModule && symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): escapedSymbolName !== InternalSymbolName.ExportEquals */ TODO
				isConstMergedWithNSPrintableAsSignatureMerge := isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol)
				if symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags & SymbolFlagsTypeAlias {
					serializeTypeAlias(symbol, symbolName, modifierFlags)
				}
				if symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsFunctionScopedVariable|SymbolFlagsProperty|SymbolFlagsAccessor) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): escapedSymbolName !== InternalSymbolName.ExportEquals */ TODO && !(symbol.flags & SymbolFlagsPrototype) && !(symbol.flags & SymbolFlagsClass) && !(symbol.flags & SymbolFlagsMethod) && !isConstMergedWithNSPrintableAsSignatureMerge {
					if propertyAsAlias {
						createdExport := serializeMaybeAliasAssignment(symbol)
						if createdExport {
							needsExportDeclaration = false
							needsPostExportDefault = false
						}
					} else {
						type_ := getTypeOfSymbol(symbol)
						localName := getInternalSymbolName(symbol, symbolName)
						if type_.symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.symbol !== symbol */ TODO && type_.symbol.flags&SymbolFlagsFunction && some(type_.symbol.declarations, isFunctionExpressionOrArrowFunction) && (type_.symbol.members.size || type_.symbol.exports.size) {
							if !context.remappedSymbolReferences {
								context.remappedSymbolReferences = /* TODO(NewExpression): new Map() */ TODO
							}
							context.remappedSymbolReferences.set(getSymbolId(type_.symbol), symbol)
							serializeSymbolWorker(type_.symbol, isPrivate, propertyAsAlias, escapedSymbolName)
							context.remappedSymbolReferences.delete(getSymbolId(type_.symbol))
						} else if !(symbol.flags & SymbolFlagsFunction) && isTypeRepresentableAsFunctionNamespaceMerge(type_, symbol) {
							serializeAsFunctionNamespaceMerge(type_, symbol, localName, modifierFlags)
						} else {
							flags := /* TODO(ConditionalExpression): !(symbol.flags & SymbolFlags.BlockScopedVariable)                                 ? symbol.parent?.valueDeclaration && isSourceFile(symbol.parent?.valueDeclaration)                                     ? NodeFlags.Const // exports are immutable in es6, which is what we emulate and check; so it's safe to mark all exports as `const` (there's no difference to consumers, but it allows unique symbol type declarations)                                     : undefined                                 : isConstantVariable(symbol)                                 ? NodeFlags.Const                                 : NodeFlags.Let */ TODO
							name := /* TODO(ConditionalExpression): (needsPostExportDefault || !(symbol.flags & SymbolFlags.Property)) ? localName : getUnusedName(localName, symbol) */ TODO
							var textRange Node = symbol.declarations && find(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
								/* TODO(Identifier): isVariableDeclaration */
								/* TODO(Identifier): d */
							})
							if textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length == 1 {
								textRange = textRange.parent.parent
							}
							propertyAccessRequire := symbol.declarations.find(isPropertyAccessExpression)
							if propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right) && type_.symbol.valueDeclaration && isSourceFile(type_.symbol.valueDeclaration) {
								alias := /* TODO(ConditionalExpression): localName === propertyAccessRequire.parent.right.escapedText ? undefined : propertyAccessRequire.parent.right */ TODO
								addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, alias, localName)] */ TODO)), ModifierFlagsNone)
								context.tracker.trackSymbol(type_.symbol, context.enclosingDeclaration, SymbolFlagsValue)
							} else {
								statement := setTextRange(context, factory.createVariableStatement(nil, factory.createVariableDeclarationList( /* TODO(ArrayLiteralExpression): [                                             factory.createVariableDeclaration(name, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, type, symbol)),                                         ] */ TODO, flags)), textRange)
								addResult(statement /* TODO(ConditionalExpression): name !== localName ? modifierFlags & ~ModifierFlags.Export : modifierFlags */, TODO)
								if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== localName */ TODO && !isPrivate {
									addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, name, localName)] */ TODO)), ModifierFlagsNone)
									needsExportDeclaration = false
									needsPostExportDefault = false
								}
							}
						}
					}
				}
				if symbol.flags & SymbolFlagsEnum {
					serializeEnum(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsClass {
					if symbol.flags&SymbolFlagsProperty && symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration.parent) && isClassExpression(symbol.valueDeclaration.parent.right) {
						serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					} else {
						serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
					}
				}
				if (symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol))) || isConstMergedWithNSPrintableAsSignatureMerge {
					serializeModule(symbol, symbolName, modifierFlags)
				}
				if symbol.flags&SymbolFlagsInterface && !(symbol.flags & SymbolFlagsClass) {
					serializeInterface(symbol, symbolName, modifierFlags)
				}
				if symbol.flags & SymbolFlagsAlias {
					serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName), modifierFlags)
				}
				if symbol.flags&SymbolFlagsProperty && symbol.escapedName == InternalSymbolNameExportEquals {
					serializeMaybeAliasAssignment(symbol)
				}
				if symbol.flags & SymbolFlagsExportStar {
					if symbol.declarations {
						for _, node := range symbol.declarations {
							resolvedModule := resolveExternalModuleName(node /* TODO(NonNullExpression): (node as ExportDeclaration).moduleSpecifier! */, TODO)
							if !resolvedModule {
							}
							addResult(factory.createExportDeclaration(nil, (node /* as */ /* TODO(TypeReference): ExportDeclaration */).isTypeOnly, nil, factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), ModifierFlagsNone)
						}
					}
				}
				if needsPostExportDefault {
					addResult(factory.createExportAssignment(nil, false, factory.createIdentifier(getInternalSymbolName(symbol, symbolName))), ModifierFlagsNone)
				} else if needsExportDeclaration {
					addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, getInternalSymbolName(symbol, symbolName), symbolName)] */ TODO)), ModifierFlagsNone)
				}
			}
			includePrivateSymbol := func(symbol Symbol) {
				if some(symbol.declarations, isPartOfParameterDeclaration) {
				}
				Debug.assertIsDefined( /* TODO(ElementAccessExpression): deferredPrivatesStack[deferredPrivatesStack.length - 1] */ TODO)
				getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol)
				isExternalImportAlias := !!(symbol.flags & SymbolFlagsAlias) && !some(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): !!findAncestor(d, isExportDeclaration) ||                     isNamespaceExport(d) */
					/* TODO(BarBarToken): || */
					/* TODO(ParenthesizedExpression): (isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference)) */
				})
				/* TODO(ElementAccessExpression): deferredPrivatesStack[isExternalImportAlias ? 0 : (deferredPrivatesStack.length - 1)] */ TODO.set(getSymbolId(symbol), symbol)
			}
			isExportingScope := func(enclosingDeclaration Node) /* TODO(undefined): boolean */ TODO {
				return ((isSourceFile(enclosingDeclaration) && (isExternalOrCommonJsModule(enclosingDeclaration) || isJsonSourceFile(enclosingDeclaration))) || (isAmbientModule(enclosingDeclaration) && !isGlobalScopeAugmentation(enclosingDeclaration)))
			}
			addResult := func(node Statement, additionalModifierFlags ModifierFlags) {
				if canHaveModifiers(node) {
					var newModifierFlags ModifierFlags = ModifierFlagsNone
					enclosingDeclaration := context.enclosingDeclaration && ( /* TODO(ConditionalExpression): isJSDocTypeAlias(context.enclosingDeclaration) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration */ TODO)
					if additionalModifierFlags&ModifierFlagsExport && enclosingDeclaration && (isExportingScope(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) && canHaveExportModifier(node) {
						newModifierFlags |= ModifierFlagsExport
					}
					if addingDeclare && !(newModifierFlags & ModifierFlagsExport) && (!enclosingDeclaration || !(enclosingDeclaration.flags & NodeFlagsAmbient)) && (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node)) {
						newModifierFlags |= ModifierFlagsAmbient
					}
					if (additionalModifierFlags & ModifierFlagsDefault) && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node)) {
						newModifierFlags |= ModifierFlagsDefault
					}
					if newModifierFlags {
						node = factory.replaceModifiers(node, newModifierFlags|getEffectiveModifierFlags(node))
					}
				}
				results.push(node)
			}
			serializeTypeAlias := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				aliasType := getDeclaredTypeOfTypeAlias(symbol)
				typeParams := getSymbolLinks(symbol).typeParameters
				typeParamDecls := map_(typeParams, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					/* TODO(Identifier): typeParameterToDeclaration */
					/* TODO(Identifier): p */
					/* TODO(Identifier): context */
				})
				jsdocAliasDecl := symbol.declarations.find(isJSDocTypeAlias)
				commentText := getTextOfJSDocComment( /* TODO(ConditionalExpression): jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : undefined */ TODO)
				restoreFlags := saveRestoreFlags(context)
				context.flags |= NodeBuilderFlagsInTypeAlias
				oldEnclosingDecl := context.enclosingDeclaration
				context.enclosingDeclaration = jsdocAliasDecl
				typeNode := jsdocAliasDecl && jsdocAliasDecl.typeExpression && isJSDocTypeExpression(jsdocAliasDecl.typeExpression) && tryReuseExistingNonParameterTypeNode(context, jsdocAliasDecl.typeExpression.type_, aliasType, nil) || typeToTypeNodeHelper(aliasType, context)
				addResult(setSyntheticLeadingComments(factory.createTypeAliasDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, typeNode) /* TODO(ConditionalExpression): !commentText ? [] : [{ kind: SyntaxKind.MultiLineCommentTrivia, text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ", pos: -1, end: -1, hasTrailingNewLine: true }] */, TODO), modifierFlags)
				restoreFlags()
				context.enclosingDeclaration = oldEnclosingDecl
			}
			serializeInterface := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				interfaceType := getDeclaredTypeOfClassOrInterface(symbol)
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					/* TODO(Identifier): typeParameterToDeclaration */
					/* TODO(Identifier): p */
					/* TODO(Identifier): context */
				})
				baseTypes := getBaseTypes(interfaceType)
				baseType := /* TODO(ConditionalExpression): length(baseTypes) ? getIntersectionType(baseTypes) : undefined */ TODO
				members := flatMap(getPropertiesOfType(interfaceType), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ TODO {
					/* TODO(Identifier): serializePropertySymbolForInterface */
					/* TODO(Identifier): p */
					/* TODO(Identifier): baseType */
				})
				callSignatures := serializeSignatures(SignatureKindCall, interfaceType, baseType, SyntaxKindCallSignature)                /* as */ /* TODO(ArrayType): CallSignatureDeclaration[] */
				constructSignatures := serializeSignatures(SignatureKindConstruct, interfaceType, baseType, SyntaxKindConstructSignature) /* as */ /* TODO(ArrayType): ConstructSignatureDeclaration[] */
				indexSignatures := serializeIndexSignatures(interfaceType, baseType)
				heritageClauses := /* TODO(ConditionalExpression): !length(baseTypes) ? undefined : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, mapDefined(baseTypes, b => trySerializeAsTypeReference(b, SymbolFlags.Value)))] */ TODO
				addResult(factory.createInterfaceDeclaration(nil, getInternalSymbolName(symbol, symbolName), typeParamDecls, heritageClauses /* TODO(ArrayLiteralExpression): [...indexSignatures, ...constructSignatures, ...callSignatures, ...members] */, TODO), modifierFlags)
			}
			getNamespaceMembersForSerialization := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
				exports := arrayFrom(getExportsOfSymbol(symbol).values())
				merged := getMergedSymbol(symbol)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): merged !== symbol */ TODO {
					membersSet := /* TODO(NewExpression): new Set(exports) */ TODO
					for _, exported := range getExportsOfSymbol(merged).values() {
						if !(getSymbolFlags(resolveSymbol(exported)) & SymbolFlagsValue) {
							membersSet.add(exported)
						}
					}
					exports = arrayFrom(membersSet)
				}
				return filter(exports, func(m /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): isNamespaceMember(m) */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(CallExpression): isIdentifierText(m.escapedName as string, ScriptTarget.ESNext) */
				})
			}
			isTypeOnlyNamespace := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
				return every(getNamespaceMembersForSerialization(symbol), func(m /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(ParenthesizedExpression): (getSymbolFlags(resolveSymbol(m)) & SymbolFlags.Value) */
				})
			}
			serializeModule := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				members := getNamespaceMembersForSerialization(symbol)
				locationMap := arrayToMultiMap(members, func(m /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): "real" | "merged" */ TODO {
					/* TODO(BinaryExpression): m.parent && m.parent === symbol */
					/* TODO(QuestionToken): ? */
					/* TODO(StringLiteral): "real" */
					/* TODO(ColonToken): : */
					/* TODO(StringLiteral): "merged" */
				})
				realMembers := locationMap.get("real") || emptyArray
				mergedMembers := locationMap.get("merged") || emptyArray
				if length(realMembers) {
					localName := getInternalSymbolName(symbol, symbolName)
					serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (SymbolFlagsFunction | SymbolFlagsAssignment)))
				}
				if length(mergedMembers) {
					containingFile := getSourceFileOfNode(context.enclosingDeclaration)
					localName := getInternalSymbolName(symbol, symbolName)
					nsBody := factory.createModuleBlock( /* TODO(ArrayLiteralExpression): [factory.createExportDeclaration(                         /*modifiers* / undefined,                         /*isTypeOnly* / false,                         factory.createNamedExports(mapDefined(filter(mergedMembers, n => n.escapedName !== InternalSymbolName.ExportEquals), s => {                             const name = unescapeLeadingUnderscores(s.escapedName);                             const localName = getInternalSymbolName(s, name);                             const aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);                             if (containingFile && (aliasDecl ? containingFile !== getSourceFileOfNode(aliasDecl) : !some(s.declarations, d => getSourceFileOfNode(d) === containingFile))) {                                 context.tracker?.reportNonlocalAugmentation?.(containingFile, symbol, s);                                 return undefined;                             }                             const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, /*dontRecursivelyResolve* / true);                             includePrivateSymbol(target || s);                             const targetName = target ? getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName)) : localName;                             return factory.createExportSpecifier(/*isTypeOnly* / false, name === targetName ? undefined : targetName, name);                         })),                     )] */ TODO)
					addResult(factory.createModuleDeclaration(nil, factory.createIdentifier(localName), nsBody, NodeFlagsNamespace), ModifierFlagsNone)
				}
			}
			serializeEnum := func(symbol Symbol, symbolName string, modifierFlags ModifierFlags) {
				addResult(factory.createEnumDeclaration(factory.createModifiersFromModifierFlags( /* TODO(ConditionalExpression): isConstEnumSymbol(symbol) ? ModifierFlags.Const : 0 */ TODO), getInternalSymbolName(symbol, symbolName), map_(filter(getPropertiesOfType(getTypeOfSymbol(symbol)), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !(p.flags & SymbolFlags.EnumMember) */
				}), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EnumMember */ TODO {
					initializedValue := /* TODO(ConditionalExpression): p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) ? getConstantValue(p.declarations[0]) : undefined */ TODO
					return factory.createEnumMember(unescapeLeadingUnderscores(p.escapedName) /* TODO(ConditionalExpression): initializedValue === undefined ? undefined :                                     typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) :                                     factory.createNumericLiteral(initializedValue) */, TODO)
				})), modifierFlags)
			}
			serializeAsFunctionNamespaceMerge := func(type_ Type, symbol Symbol, localName string, modifierFlags ModifierFlags) {
				signatures := getSignaturesOfType(type_, SignatureKindCall)
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig, SyntaxKindFunctionDeclaration, context /* TODO(ObjectLiteralExpression): { name: factory.createIdentifier(localName) } */, TODO) /* as */ /* TODO(TypeReference): FunctionDeclaration */
					addResult(setTextRange(context, decl, getSignatureTextRangeLocation(sig)), modifierFlags)
				}
				if !(symbol.flags&(SymbolFlagsValueModule|SymbolFlagsNamespaceModule) && !!symbol.exports && !!symbol.exports.size) {
					props := filter(getPropertiesOfType(type_), isNamespaceMember)
					serializeAsNamespaceDeclaration(props, localName, modifierFlags, true)
				}
			}
			getSignatureTextRangeLocation := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").SignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList | import("/home/jabaile/work/TypeScript/src/compiler/types").CatchClause | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocSignature | undefined */ TODO {
				if signature.declaration && signature.declaration.parent {
					if isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) == AssignmentDeclarationKindProperty {
						return signature.declaration.parent
					}
					if isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent {
						return signature.declaration.parent.parent
					}
				}
				return signature.declaration
			}
			serializeAsNamespaceDeclaration := func(props []Symbol, localName string, modifierFlags ModifierFlags, suppressNewPrivateContext bool) {
				if length(props) {
					localVsRemoteMap := arrayToMultiMap(props, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): "local" | "remote" */ TODO {
						/* TODO(BinaryExpression): !length(p.declarations) || some(p.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration!)) */
						/* TODO(QuestionToken): ? */
						/* TODO(StringLiteral): "local" */
						/* TODO(ColonToken): : */
						/* TODO(StringLiteral): "remote" */
					})
					localProps := localVsRemoteMap.get("local") || emptyArray
					fakespace := parseNodeFactory.createModuleDeclaration(nil, factory.createIdentifier(localName), factory.createModuleBlock( /* TODO(ArrayLiteralExpression): [] */ TODO), NodeFlagsNamespace)
					setParent(fakespace, enclosingDeclaration /* as */ /* TODO(UnionType): SourceFile | NamespaceDeclaration */)
					fakespace.locals = createSymbolTable(props)
					fakespace.symbol = /* TODO(NonNullExpression): props[0].parent! */ TODO
					oldResults := results
					results = /* TODO(ArrayLiteralExpression): [] */ TODO
					oldAddingDeclare := addingDeclare
					addingDeclare = false
					subcontext := /* TODO(ObjectLiteralExpression): { ...context, enclosingDeclaration: fakespace } */ TODO
					oldContext := context
					context = subcontext
					visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext, true)
					context = oldContext
					addingDeclare = oldAddingDeclare
					declarations := results
					results = oldResults
					defaultReplaced := map_(declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Statement */ TODO {
						/* TODO(BinaryExpression): isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) */
						/* TODO(QuestionToken): ? */
						/* TODO(CallExpression): factory.createExportDeclaration(                             /*modifiers* / undefined,                             /*isTypeOnly* / false,                             factory.createNamedExports([factory.createExportSpecifier(/*isTypeOnly* / false, d.expression, factory.createIdentifier(InternalSymbolName.Default))]),                         ) */
						/* TODO(ColonToken): : */
						/* TODO(Identifier): d */
					})
					exportModifierStripped := /* TODO(ConditionalExpression): every(defaultReplaced, d => hasSyntacticModifier(d, ModifierFlags.Export)) ? map(defaultReplaced as Extract<HasModifiers, Statement>[], removeExportModifier) : defaultReplaced */ TODO
					fakespace = factory.updateModuleDeclaration(fakespace, fakespace.modifiers, fakespace.name, factory.createModuleBlock(exportModifierStripped))
					addResult(fakespace, modifierFlags)
				}
			}
			isNamespaceMember := func(p Symbol) /* TODO(undefined): boolean */ TODO {
				return !!(p.flags & (SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsAlias)) || !(p.flags&SymbolFlagsPrototype || p.escapedName == "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent))
			}
			sanitizeJSDocImplements := func(clauses []ExpressionWithTypeArguments) /* TODO(ArrayType): ExpressionWithTypeArguments[] */ any {
				result := mapDefined(clauses, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
					oldEnclosing := context.enclosingDeclaration
					context.enclosingDeclaration = e
					expr := e.expression
					if isEntityNameExpression(expr) {
						if isIdentifier(expr) && idText(expr) == "" {
							return cleanup(nil)
						}
						var introducesError bool
						/* TODO(ExpressionStatement): ({ introducesError, node: expr } = trackExistingEntityName(expr, context)); */
						if introducesError {
							return cleanup(nil)
						}
					}
					return cleanup(factory.createExpressionWithTypeArguments(expr, map_(e.typeArguments, func(a /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
						/* TODO(CallExpression): tryReuseExistingNonParameterTypeNode(context, a, getTypeFromTypeNode(context, a)) */
						/* TODO(BarBarToken): || */
						/* TODO(CallExpression): typeToTypeNodeHelper(getTypeFromTypeNode(context, a), context) */
					})))
					cleanup := func(result T) T {
						context.enclosingDeclaration = oldEnclosing
						return result
					}
				})
				if result.length == clauses.length {
					return result
				}
				return nil
			}
			serializeAsClass := func(symbol Symbol, localName string, modifierFlags ModifierFlags) {
				originalDecl := symbol.declarations.find(isClassLike)
				oldEnclosing := context.enclosingDeclaration
				context.enclosingDeclaration = originalDecl || oldEnclosing
				localParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				typeParamDecls := map_(localParams, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO {
					/* TODO(Identifier): typeParameterToDeclaration */
					/* TODO(Identifier): p */
					/* TODO(Identifier): context */
				})
				classType := getTypeWithThisArgument(getDeclaredTypeOfClassOrInterface(symbol)) /* as */ /* TODO(TypeReference): InterfaceType */
				baseTypes := getBaseTypes(classType)
				originalImplements := originalDecl && getEffectiveImplementsTypeNodes(originalDecl)
				implementsExpressions := originalImplements && sanitizeJSDocImplements(originalImplements) || mapDefined(getImplementsTypes(classType), serializeImplementedType)
				staticType := getTypeOfSymbol(symbol)
				isClass := !!staticType.symbol.valueDeclaration && isClassLike(staticType.symbol.valueDeclaration)
				staticBaseType := /* TODO(ConditionalExpression): isClass                     ? getBaseConstructorTypeOfClass(staticType as InterfaceType)                     : anyType */ TODO
				heritageClauses := /* TODO(ArrayLiteralExpression): [                     ...!length(baseTypes) ? [] : [factory.createHeritageClause(SyntaxKind.ExtendsKeyword, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))],                     ...!length(implementsExpressions) ? [] : [factory.createHeritageClause(SyntaxKind.ImplementsKeyword, implementsExpressions)],                 ] */ TODO
				symbolProps := getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType))
				publicSymbolProps := filter(symbolProps, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					valueDecl := s.valueDeclaration
					return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name))
				})
				hasPrivateIdentifier := some(symbolProps, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					valueDecl := s.valueDeclaration
					return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name)
				})
				privateProperties := /* TODO(ConditionalExpression): hasPrivateIdentifier ?                     [factory.createPropertyDeclaration(                         /*modifiers* / undefined,                         factory.createPrivateIdentifier("#private"),                         /*questionOrExclamationToken* / undefined,                         /*type* / undefined,                         /*initializer* / undefined,                     )] :                     emptyArray */ TODO
				publicProperties := flatMap(publicSymbolProps, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration)[] */ TODO {
					/* TODO(Identifier): serializePropertySymbolForClass */
					/* TODO(Identifier): p */
					/* TODO(FalseKeyword): false */
					/* TODO(ElementAccessExpression): baseTypes[0] */
				})
				staticMembers := flatMap(filter(getPropertiesOfType(staticType), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): !(p.flags & SymbolFlags.Prototype) && p.escapedName !== "prototype" */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(PrefixUnaryExpression): !isNamespaceMember(p) */
				}), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessorDeclaration)[] */ TODO {
					/* TODO(Identifier): serializePropertySymbolForClass */
					/* TODO(Identifier): p */
					/* TODO(TrueKeyword): true */
					/* TODO(Identifier): staticBaseType */
				})
				isNonConstructableClassLikeInJsFile := !isClass && !!symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && !some(getSignaturesOfType(staticType, SignatureKindConstruct))
				constructors := /* TODO(ConditionalExpression): isNonConstructableClassLikeInJsFile ?                     [factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(ModifierFlags.Private), [], /*body* / undefined)] :                     serializeSignatures(SignatureKind.Construct, staticType, staticBaseType, SyntaxKind.Constructor) as ConstructorDeclaration[] */ TODO
				indexSignatures := serializeIndexSignatures(classType /* TODO(ElementAccessExpression): baseTypes[0] */, TODO)
				context.enclosingDeclaration = oldEnclosing
				addResult(setTextRange(context, factory.createClassDeclaration(nil, localName, typeParamDecls, heritageClauses /* TODO(ArrayLiteralExpression): [...indexSignatures, ...staticMembers, ...constructors, ...publicProperties, ...privateProperties] */, TODO), symbol.declarations && /* TODO(ElementAccessExpression): filter(symbol.declarations, d => isClassDeclaration(d) || isClassExpression(d))[0] */ TODO), modifierFlags)
			}
			getSomeTargetNameFromDeclarations := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO(undefined): string | undefined */ TODO {
				return firstDefined(declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): string | undefined */ TODO {
					if isImportSpecifier(d) || isExportSpecifier(d) {
						return moduleExportNameTextUnescaped(d.propertyName || d.name)
					}
					if isBinaryExpression(d) || isExportAssignment(d) {
						expression := /* TODO(ConditionalExpression): isExportAssignment(d) ? d.expression : d.right */ TODO
						if isPropertyAccessExpression(expression) {
							return idText(expression.name)
						}
					}
					if isAliasSymbolDeclaration(d) {
						name := getNameOfDeclaration(d)
						if name && isIdentifier(name) {
							return idText(name)
						}
					}
					return nil
				})
			}
			serializeAsAlias := func(symbol Symbol, localName string, modifierFlags ModifierFlags) /* TODO(undefined): undefined */ TODO {
				node := getDeclarationOfAliasSymbol(symbol)
				if !node {
					/* TODO(CallExpression): Debug.fail() */
				}
				target := getMergedSymbol(getTargetOfAliasDeclaration(node, true))
				if !target {
					return
				}
				verbatimTargetName := isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName)
				if verbatimTargetName == InternalSymbolNameExportEquals && allowSyntheticDefaultImports {
					verbatimTargetName = InternalSymbolNameDefault
				}
				targetName := getInternalSymbolName(target, verbatimTargetName)
				includePrivateSymbol(target)
				/* TODO(SwitchStatement): switch (node.kind) {                     case SyntaxKind.BindingElement:                         if (node.parent?.parent?.kind === SyntaxKind.VariableDeclaration) {                             // const { SomeClass } = require('./lib');                             const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // './lib'                             const { propertyName } = node as BindingElement;                             addResult(                                 factory.createImportDeclaration(                                     /*modifiers* / undefined,                                     factory.createImportClause(                                         /*isTypeOnly* / false,                                         /*name* / undefined,                                         factory.createNamedImports([factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             propertyName && isIdentifier(propertyName) ? factory.createIdentifier(idText(propertyName)) : undefined,                                             factory.createIdentifier(localName),                                         )]),                                     ),                                     factory.createStringLiteral(specifier),                                     /*attributes* / undefined,                                 ),                                 ModifierFlags.None,                             );                             break;                         }                         // We don't know how to serialize this (nested?) binding element                         Debug.failBadSyntaxKind(node.parent?.parent || node, "Unhandled binding element grandparent kind in declaration serialization");                         break;                     case SyntaxKind.ShorthandPropertyAssignment:                         if (node.parent?.parent?.kind === SyntaxKind.BinaryExpression) {                             // module.exports = { SomeClass }                             serializeExportSpecifier(                                 unescapeLeadingUnderscores(symbol.escapedName),                                 targetName,                             );                         }                         break;                     case SyntaxKind.VariableDeclaration:                         // commonjs require: const x = require('y')                         if (isPropertyAccessExpression((node as VariableDeclaration).initializer!)) {                             // const x = require('y').z                             const initializer = (node as VariableDeclaration).initializer! as PropertyAccessExpression; // require('y').z                             const uniqueName = factory.createUniqueName(localName); // _x                             const specifier = getSpecifierForModuleSymbol(target.parent || target, context); // 'y'                             // import _x = require('y');                             addResult(                                 factory.createImportEqualsDeclaration(                                     /*modifiers* / undefined,                                     /*isTypeOnly* / false,                                     uniqueName,                                     factory.createExternalModuleReference(factory.createStringLiteral(specifier)),                                 ),                                 ModifierFlags.None,                             );                             // import x = _x.z                             addResult(                                 factory.createImportEqualsDeclaration(                                     /*modifiers* / undefined,                                     /*isTypeOnly* / false,                                     factory.createIdentifier(localName),                                     factory.createQualifiedName(uniqueName, initializer.name as Identifier),                                 ),                                 modifierFlags,                             );                             break;                         }                         // else fall through and treat commonjs require just like import=                     case SyntaxKind.ImportEqualsDeclaration:                         // This _specifically_ only exists to handle json declarations - where we make aliases, but since                         // we emit no declarations for the json document, must not refer to it in the declarations                         if (target.escapedName === InternalSymbolName.ExportEquals && some(target.declarations, d => isSourceFile(d) && isJsonSourceFile(d))) {                             serializeMaybeAliasAssignment(symbol);                             break;                         }                         // Could be a local `import localName = ns.member` or                         // an external `import localName = require("whatever")`                         const isLocalImport = !(target.flags & SymbolFlags.ValueModule) && !isVariableDeclaration(node);                         addResult(                             factory.createImportEqualsDeclaration(                                 /*modifiers* / undefined,                                 /*isTypeOnly* / false,                                 factory.createIdentifier(localName),                                 isLocalImport                                     ? symbolToName(target, context, SymbolFlags.All, /*expectsIdentifier* / false)                                     : factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))),                             ),                             isLocalImport ? modifierFlags : ModifierFlags.None,                         );                         break;                     case SyntaxKind.NamespaceExportDeclaration:                         // export as namespace foo                         // TODO: Not part of a file's local or export symbol tables                         // Is bound into file.symbol.globalExports instead, which we don't currently traverse                         addResult(factory.createNamespaceExportDeclaration(idText((node as NamespaceExportDeclaration).name)), ModifierFlags.None);                         break;                     case SyntaxKind.ImportClause: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportClause).parent.moduleSpecifier;                         const attributes = isImportDeclaration(node.parent) ? node.parent.attributes : undefined;                         const isTypeOnly = isJSDocImportTag((node as ImportClause).parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(isTypeOnly, factory.createIdentifier(localName), /*namedBindings* / undefined),                                 specifier,                                 attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.NamespaceImport: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as NamespaceImport).parent.parent.moduleSpecifier;                         const isTypeOnly = isJSDocImportTag((node as NamespaceImport).parent.parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(isTypeOnly, /*name* / undefined, factory.createNamespaceImport(factory.createIdentifier(localName))),                                 specifier,                                 (node as ImportClause).parent.attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.NamespaceExport:                         addResult(                             factory.createExportDeclaration(                                 /*modifiers* / undefined,                                 /*isTypeOnly* / false,                                 factory.createNamespaceExport(factory.createIdentifier(localName)),                                 factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)),                             ),                             ModifierFlags.None,                         );                         break;                     case SyntaxKind.ImportSpecifier: {                         const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context); // generate specifier (even though we're reusing and existing one) for ambient module reference include side effects                         const specifier = context.bundled ? factory.createStringLiteral(generatedSpecifier) : (node as ImportSpecifier).parent.parent.parent.moduleSpecifier;                         const isTypeOnly = isJSDocImportTag((node as ImportSpecifier).parent.parent.parent);                         addResult(                             factory.createImportDeclaration(                                 /*modifiers* / undefined,                                 factory.createImportClause(                                     isTypeOnly,                                     /*name* / undefined,                                     factory.createNamedImports([                                         factory.createImportSpecifier(                                             /*isTypeOnly* / false,                                             localName !== verbatimTargetName ? factory.createIdentifier(verbatimTargetName) : undefined,                                             factory.createIdentifier(localName),                                         ),                                     ]),                                 ),                                 specifier,                                 (node as ImportSpecifier).parent.parent.parent.attributes,                             ),                             ModifierFlags.None,                         );                         break;                     }                     case SyntaxKind.ExportSpecifier:                         // does not use localName because the symbol name in this case refers to the name in the exports table,                         // which we must exactly preserve                         const specifier = (node.parent.parent as ExportDeclaration).moduleSpecifier;                         if (specifier) {                             const propertyName = (node as ExportSpecifier).propertyName;                             if (propertyName && moduleExportNameIsDefault(propertyName)) {                                 verbatimTargetName = InternalSymbolName.Default;                             }                         }                         // targetName is only used when the target is local, as otherwise the target is an alias that points at                         // another file                         serializeExportSpecifier(                             unescapeLeadingUnderscores(symbol.escapedName),                             specifier ? verbatimTargetName : targetName,                             specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(specifier.text) : undefined,                         );                         break;                     case SyntaxKind.ExportAssignment:                         serializeMaybeAliasAssignment(symbol);                         break;                     case SyntaxKind.BinaryExpression:                     case SyntaxKind.PropertyAccessExpression:                     case SyntaxKind.ElementAccessExpression:                         // Could be best encoded as though an export specifier or as though an export assignment                         // If name is default or export=, do an export assignment                         // Otherwise do an export specifier                         if (symbol.escapedName === InternalSymbolName.Default || symbol.escapedName === InternalSymbolName.ExportEquals) {                             serializeMaybeAliasAssignment(symbol);                         }                         else {                             serializeExportSpecifier(localName, targetName);                         }                         break;                     default:                         return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!");                 } */
			}
			serializeExportSpecifier := func(localName string, targetName string, specifier Expression) {
				addResult(factory.createExportDeclaration(nil, false, factory.createNamedExports( /* TODO(ArrayLiteralExpression): [factory.createExportSpecifier(/*isTypeOnly* / false, localName !== targetName ? targetName : undefined, localName)] */ TODO), specifier), ModifierFlagsNone)
			}
			serializeMaybeAliasAssignment := func(symbol Symbol) bool {
				if symbol.flags & SymbolFlagsPrototype {
					return false
				}
				name := unescapeLeadingUnderscores(symbol.escapedName)
				isExportEquals := name == InternalSymbolNameExportEquals
				isDefault := name == InternalSymbolNameDefault
				isExportAssignmentCompatibleSymbolName := isExportEquals || isDefault
				aliasDecl := symbol.declarations && getDeclarationOfAliasSymbol(symbol)
				target := aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true)
				if target && length(target.declarations) && some(target.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): getSourceFileOfNode(d) */
					/* TODO(EqualsEqualsEqualsToken): === */
					/* TODO(CallExpression): getSourceFileOfNode(enclosingDeclaration) */
				}) {
					expr := aliasDecl && ( /* TODO(ConditionalExpression): (isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl)) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl as ShorthandPropertyAssignment | PropertyAssignment | PropertyAccessExpression) */ TODO)
					first := /* TODO(ConditionalExpression): expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : undefined */ TODO
					referenced := first && resolveEntityName(first, SymbolFlagsAll, true, true, enclosingDeclaration)
					if referenced || target {
						includePrivateSymbol(referenced || target)
					}
					prevDisableTrackSymbol := context.tracker.disableTrackSymbol
					context.tracker.disableTrackSymbol = true
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, symbolToExpression(target, context, SymbolFlagsAll)))
					} else {
						if first == expr && first {
							serializeExportSpecifier(name, idText(first))
						} else if expr && isClassExpression(expr) {
							serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)))
						} else {
							varName := getUnusedName(name, symbol)
							addResult(factory.createImportEqualsDeclaration(nil, false, factory.createIdentifier(varName), symbolToName(target, context, SymbolFlagsAll, false)), ModifierFlagsNone)
							serializeExportSpecifier(name, varName)
						}
					}
					context.tracker.disableTrackSymbol = prevDisableTrackSymbol
					return true
				} else {
					varName := getUnusedName(name, symbol)
					typeToSerialize := getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)))
					if isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol) {
						serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName /* TODO(ConditionalExpression): isExportAssignmentCompatibleSymbolName ? ModifierFlags.None : ModifierFlags.Export */, TODO)
					} else {
						flags := /* TODO(ConditionalExpression): context.enclosingDeclaration?.kind === SyntaxKind.ModuleDeclaration && (!(symbol.flags & SymbolFlags.Accessor) || symbol.flags & SymbolFlags.SetAccessor) ? NodeFlags.Let : NodeFlags.Const */ TODO
						statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList( /* TODO(ArrayLiteralExpression): [                                 factory.createVariableDeclaration(varName, /*exclamationToken* / undefined, serializeTypeForDeclaration(context, /*declaration* / undefined, typeToSerialize, symbol)),                             ] */ TODO, flags))
						addResult(statement /* TODO(ConditionalExpression): target && target.flags & SymbolFlags.Property && target.escapedName === InternalSymbolName.ExportEquals ? ModifierFlags.Ambient                                 : name === varName ? ModifierFlags.Export                                 : ModifierFlags.None */, TODO)
					}
					if isExportAssignmentCompatibleSymbolName {
						results.push(factory.createExportAssignment(nil, isExportEquals, factory.createIdentifier(varName)))
						return true
					} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== varName */ TODO {
						serializeExportSpecifier(name, varName)
						return true
					}
					return false
				}
			}
			isTypeRepresentableAsFunctionNamespaceMerge := func(typeToSerialize Type, hostSymbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
				ctxSrc := getSourceFileOfNode(context.enclosingDeclaration)
				return getObjectFlags(typeToSerialize)&(ObjectFlagsAnonymous|ObjectFlagsMapped) && !some(typeToSerialize.symbol.declarations, isTypeNode) && !length(getIndexInfosOfType(typeToSerialize)) && !isClassInstanceSide(typeToSerialize) && !!(length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, SignatureKindCall))) && !length(getSignaturesOfType(typeToSerialize, SignatureKindConstruct)) && !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) && !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): getSourceFileOfNode(d) */
					/* TODO(ExclamationEqualsEqualsToken): !== */
					/* TODO(Identifier): ctxSrc */
				})) && !some(getPropertiesOfType(typeToSerialize), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): isLateBoundName */
					/* TODO(PropertyAccessExpression): p.escapedName */
				}) && !some(getPropertiesOfType(typeToSerialize), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): some */
					/* TODO(PropertyAccessExpression): p.declarations */
					/* TODO(ArrowFunction): d => getSourceFileOfNode(d) !== ctxSrc */
				}) && every(getPropertiesOfType(typeToSerialize), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					if !isIdentifierText(symbolName(p), languageVersion) {
						return false
					}
					if !(p.flags & SymbolFlagsAccessor) {
						return true
					}
					return getNonMissingTypeOfSymbol(p) == getWriteTypeOfSymbol(p)
				})
			}
			// OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors /* TODO(LiteralType): true */ TODO) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any
			// OVERLOAD: makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors /* TODO(LiteralType): false */ TODO) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | T[] */ any
			makeSerializePropertySymbol := func(createProperty func(modifiers /* TODO(TypeOperator): readonly Modifier[] */ any, name /* TODO(UnionType): string | PropertyName */ any, questionOrExclamationToken *QuestionToken, type_ *TypeNode, initializer *Expression) T, methodKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO, useAccessors bool) func(p Symbol, isStatic bool, baseType *Type) /* TODO(UnionType): T | AccessorDeclaration | (T | AccessorDeclaration)[] */ any {
				return /* TODO(FunctionExpression): function serializePropertySymbol(p: Symbol, isStatic: boolean, baseType: Type | undefined): T | AccessorDeclaration | (T | AccessorDeclaration)[] {                     const modifierFlags = getDeclarationModifierFlagsFromSymbol(p);                     const isPrivate = !!(modifierFlags & ModifierFlags.Private);                     if (isStatic && (p.flags & (SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias))) {                         // Only value-only-meaning symbols can be correctly encoded as class statics, type/namespace/alias meaning symbols                         // need to be merged namespace members                         return [];                     }                     if (                         p.flags & SymbolFlags.Prototype || p.escapedName === "constructor" ||                         (baseType && getPropertyOfType(baseType, p.escapedName)                             && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)!) === isReadonlySymbol(p)                             && (p.flags & SymbolFlags.Optional) === (getPropertyOfType(baseType, p.escapedName)!.flags & SymbolFlags.Optional)                             && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName)!))                     ) {                         return [];                     }                     const flag = (modifierFlags & ~ModifierFlags.Async) | (isStatic ? ModifierFlags.Static : 0);                     const name = getPropertyNameNodeForSymbol(p, context);                     const firstPropertyLikeDecl = p.declarations?.find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression));                     if (p.flags & SymbolFlags.Accessor && useAccessors) {                         const result: AccessorDeclaration[] = [];                         if (p.flags & SymbolFlags.SetAccessor) {                             const setter = p.declarations && forEach(p.declarations, d => {                                 if (d.kind === SyntaxKind.SetAccessor) {                                     return d as SetAccessorDeclaration;                                 }                                 if (isCallExpression(d) && isBindableObjectDefinePropertyCall(d)) {                                     return forEach(d.arguments[2].properties, propDecl => {                                         const id = getNameOfDeclaration(propDecl);                                         if (!!id && isIdentifier(id) && idText(id) === "set") {                                             return propDecl;                                         }                                     });                                 }                             });                              Debug.assert(!!setter);                             const paramSymbol = isFunctionLikeDeclaration(setter) ? getSignatureFromDeclaration(setter).parameters[0] : undefined;                              result.push(setTextRange(                                 context,                                 factory.createSetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [factory.createParameterDeclaration(                                         /*modifiers* / undefined,                                         /*dotDotDotToken* / undefined,                                         paramSymbol ? parameterToParameterDeclarationName(paramSymbol, getEffectiveParameterDeclaration(paramSymbol), context) : "value",                                         /*questionToken* / undefined,                                         isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                     )],                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isSetAccessor) || firstPropertyLikeDecl,                             ));                         }                         if (p.flags & SymbolFlags.GetAccessor) {                             const isPrivate = modifierFlags & ModifierFlags.Private;                             result.push(setTextRange(                                 context,                                 factory.createGetAccessorDeclaration(                                     factory.createModifiersFromModifierFlags(flag),                                     name,                                     [],                                     isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getTypeOfSymbol(p), p),                                     /*body* / undefined,                                 ),                                 p.declarations?.find(isGetAccessor) || firstPropertyLikeDecl,                             ));                         }                         return result;                     }                     // This is an else/if as accessors and properties can't merge in TS, but might in JS                     // If this happens, we assume the accessor takes priority, as it imposes more constraints                     else if (p.flags & (SymbolFlags.Property | SymbolFlags.Variable | SymbolFlags.Accessor)) {                         return setTextRange(                             context,                             createProperty(                                 factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                 name,                                 p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                 isPrivate ? undefined : serializeTypeForDeclaration(context, /*declaration* / undefined, getWriteTypeOfSymbol(p), p),                                 // TODO: https://github.com/microsoft/TypeScript/pull/32372#discussion_r328386357                                 // interface members can't have initializers, however class members _can_                                 /*initializer* / undefined,                             ),                             p.declarations?.find(or(isPropertyDeclaration, isVariableDeclaration)) || firstPropertyLikeDecl,                         );                     }                     if (p.flags & (SymbolFlags.Method | SymbolFlags.Function)) {                         const type = getTypeOfSymbol(p);                         const signatures = getSignaturesOfType(type, SignatureKind.Call);                         if (flag & ModifierFlags.Private) {                             return setTextRange(                                 context,                                 createProperty(                                     factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? ModifierFlags.Readonly : 0) | flag),                                     name,                                     p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     /*type* / undefined,                                     /*initializer* / undefined,                                 ),                                 p.declarations?.find(isFunctionLikeDeclaration) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0],                             );                         }                          const results = [];                         for (const sig of signatures) {                             // Each overload becomes a separate method declaration, in order                             const decl = signatureToSignatureDeclarationHelper(                                 sig,                                 methodKind,                                 context,                                 {                                     name,                                     questionToken: p.flags & SymbolFlags.Optional ? factory.createToken(SyntaxKind.QuestionToken) : undefined,                                     modifiers: flag ? factory.createModifiersFromModifierFlags(flag) : undefined,                                 },                             );                             const location = sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;                             results.push(setTextRange(context, decl, location));                         }                         return results as unknown as T[];                     }                     // The `Constructor`'s symbol isn't in the class's properties lists, obviously, since it's a signature on the static                     return Debug.fail(`Unhandled class member kind! ${(p as any).__debugFlags || p.flags}`);                 } */ TODO
			}
			serializePropertySymbolForInterface := func(p Symbol, baseType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeElement[] */ TODO {
				return serializePropertySymbolForInterfaceWorker(p, false, baseType)
			}
			serializeSignatures := func(kind SignatureKind, input Type, baseType *Type, outputKind /* TODO(IndexedAccessType): SignatureDeclaration["kind"] */ TODO) /* TODO(undefined): (import("/home/jabaile/work/TypeScript/src/compiler/types").CallSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodSignature | import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorTypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocFunctionType | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").FunctionExpression | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrowFunction)[] */ TODO {
				signatures := getSignaturesOfType(input, kind)
				if kind == SignatureKindConstruct {
					if !baseType && every(signatures, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(CallExpression): length(s.parameters) */
						/* TODO(EqualsEqualsEqualsToken): === */
						/* TODO(NumericLiteral): 0 */
					}) {
						return /* TODO(ArrayLiteralExpression): [] */ TODO
					}
					if baseType {
						baseSigs := getSignaturesOfType(baseType, SignatureKindConstruct)
						if !length(baseSigs) && every(signatures, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
							/* TODO(CallExpression): length(s.parameters) */
							/* TODO(EqualsEqualsEqualsToken): === */
							/* TODO(NumericLiteral): 0 */
						}) {
							return /* TODO(ArrayLiteralExpression): [] */ TODO
						}
						if baseSigs.length == signatures.length {
							failed := false
							/* TODO(ForStatement): for (let i = 0; i < baseSigs.length; i++) {                                 if (!compareSignaturesIdentical(signatures[i], baseSigs[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true, compareTypesIdentical)) {                                     failed = true;                                     break;                                 }                             } */
							if !failed {
								return /* TODO(ArrayLiteralExpression): [] */ TODO
							}
						}
					}
					var privateProtected ModifierFlags = 0
					for _, s := range signatures {
						if s.declaration {
							privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, ModifierFlagsPrivate|ModifierFlagsProtected)
						}
					}
					if privateProtected {
						return /* TODO(ArrayLiteralExpression): [setTextRange(                             context,                             factory.createConstructorDeclaration(                                 factory.createModifiersFromModifierFlags(privateProtected),                                 /*parameters* / [],                                 /*body* / undefined,                             ),                             signatures[0].declaration,                         )] */ TODO
					}
				}
				results := /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, sig := range signatures {
					decl := signatureToSignatureDeclarationHelper(sig, outputKind, context)
					results.push(setTextRange(context, decl, sig.declaration))
				}
				return results
			}
			serializeIndexSignatures := func(input Type, baseType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[] */ TODO {
				var results []IndexSignatureDeclaration = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, info := range getIndexInfosOfType(input) {
					if baseType {
						baseInfo := getIndexInfoOfType(baseType, info.keyType)
						if baseInfo {
							if isTypeIdenticalTo(info.type_, baseInfo.type_) {
								/* TODO(ContinueStatement): continue; */
							}
						}
					}
					results.push(indexInfoToIndexSignatureDeclarationHelper(info, context, nil))
				}
				return results
			}
			serializeBaseType := func(t Type, staticType Type, rootName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO {
				ref := trySerializeAsTypeReference(t, SymbolFlagsValue)
				if ref {
					return ref
				}
				tempName := getUnusedName( /* TODO(TemplateExpression): `${rootName}_base` */ TODO)
				statement := factory.createVariableStatement(nil, factory.createVariableDeclarationList( /* TODO(ArrayLiteralExpression): [                         factory.createVariableDeclaration(tempName, /*exclamationToken* / undefined, typeToTypeNodeHelper(staticType, context)),                     ] */ TODO, NodeFlagsConst))
				addResult(statement, ModifierFlagsNone)
				return factory.createExpressionWithTypeArguments(factory.createIdentifier(tempName), nil)
			}
			trySerializeAsTypeReference := func(t Type, flags SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
				var typeArgs /* TODO(ArrayType): TypeNode[] */ any
				var reference *Expression
				if (t /* as */ /* TODO(TypeReference): TypeReference */).target && isSymbolAccessibleByFlags((t /* as */ /* TODO(TypeReference): TypeReference */).target.symbol, enclosingDeclaration, flags) {
					typeArgs = map_(getTypeArguments(t /* as */ /* TODO(TypeReference): TypeReference */), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode */ TODO {
						/* TODO(Identifier): typeToTypeNodeHelper */
						/* TODO(Identifier): t */
						/* TODO(Identifier): context */
					})
					reference = symbolToExpression((t /* as */ /* TODO(TypeReference): TypeReference */).target.symbol, context, SymbolFlagsType)
				} else if t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags) {
					reference = symbolToExpression(t.symbol, context, SymbolFlagsType)
				}
				if reference {
					return factory.createExpressionWithTypeArguments(reference, typeArgs)
				}
			}
			serializeImplementedType := func(t Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments | undefined */ TODO {
				ref := trySerializeAsTypeReference(t, SymbolFlagsType)
				if ref {
					return ref
				}
				if t.symbol {
					return factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, SymbolFlagsType), nil)
				}
			}
			getUnusedName := func(input string, symbol Symbol) string {
				id := /* TODO(ConditionalExpression): symbol ? getSymbolId(symbol) : undefined */ TODO
				if id {
					if /* TODO(NonNullExpression): context.remappedSymbolNames! */ TODO.has(id) {
						return /* TODO(NonNullExpression): context.remappedSymbolNames!.get(id)! */ TODO
					}
				}
				if symbol {
					input = getNameCandidateWorker(symbol, input)
				}
				i := 0
				original := input
				/* TODO(WhileStatement): while (context.usedSymbolNames?.has(input)) {                     i++;                     input = `${original}_${i}`;                 } */
				context.usedSymbolNames.add(input)
				if id {
					/* TODO(NonNullExpression): context.remappedSymbolNames! */ TODO.set(id, input)
				}
				return input
			}
			getNameCandidateWorker := func(symbol Symbol, localName string) /* TODO(undefined): string */ TODO {
				if localName == InternalSymbolNameDefault || localName == InternalSymbolNameClass || localName == InternalSymbolNameFunction {
					restoreFlags := saveRestoreFlags(context)
					context.flags |= NodeBuilderFlagsInInitialEntityName
					nameCandidate := getNameOfSymbolAsWritten(symbol, context)
					restoreFlags()
					localName = /* TODO(ConditionalExpression): nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? stripQuotes(nameCandidate) : nameCandidate */ TODO
				}
				if localName == InternalSymbolNameDefault {
					localName = "_default"
				} else if localName == InternalSymbolNameExportEquals {
					localName = "_exports"
				}
				localName = /* TODO(ConditionalExpression): isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-z0-9]/gi, "_") */ TODO
				return localName
			}
			getInternalSymbolName := func(symbol Symbol, localName string) /* TODO(undefined): string */ TODO {
				id := getSymbolId(symbol)
				if /* TODO(NonNullExpression): context.remappedSymbolNames! */ TODO.has(id) {
					return /* TODO(NonNullExpression): context.remappedSymbolNames!.get(id)! */ TODO
				}
				localName = getNameCandidateWorker(symbol, localName)
				/* TODO(NonNullExpression): context.remappedSymbolNames! */ TODO.set(id, localName)
				return localName
			}
		}
	}
	typePredicateToString := func(typePredicate TypePredicate, enclosingDeclaration Node, flags TypeFormatFlags /* = */ /* TODO(PropertyAccessExpression): TypeFormatFlags.UseAliasDefinedOutsideCurrentScope */, writer EmitTextWriter) string {
		return /* TODO(ConditionalExpression): writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(typePredicateToStringWorker) */ TODO
		typePredicateToStringWorker := func(writer EmitTextWriter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EmitTextWriter */ TODO {
			nodeBuilderFlags := toNodeBuilderFlags(flags) | NodeBuilderFlagsIgnoreErrors | NodeBuilderFlagsWriteTypeParametersInQualifiedName
			predicate := /* TODO(NonNullExpression): nodeBuilder.typePredicateToTypePredicateNode(typePredicate, enclosingDeclaration, nodeBuilderFlags)! */ TODO
			printer := createPrinterWithRemoveComments()
			sourceFile := enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration)
			printer.writeNode(EmitHintUnspecified, predicate, sourceFile, writer)
			return writer
		}
	}
	formatUnionTypes := func(types []Type) []Type {
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := 0 /* as */ /* TODO(TypeReference): TypeFlags */
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = types[i];             flags |= t.flags;             if (!(t.flags & TypeFlags.Nullable)) {                 if (t.flags & (TypeFlags.BooleanLiteral | TypeFlags.EnumLike)) {                     const baseType = t.flags & TypeFlags.BooleanLiteral ? booleanType : getBaseTypeOfEnumLikeType(t as LiteralType);                     if (baseType.flags & TypeFlags.Union) {                         const count = (baseType as UnionType).types.length;                         if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType((baseType as UnionType).types[count - 1])) {                             result.push(baseType);                             i += count - 1;                             continue;                         }                     }                 }                 result.push(t);             }         } */
		if flags & TypeFlagsNull {
			/* TODO(CallExpression): result.push(nullType) */
		}
		if flags & TypeFlagsUndefined {
			/* TODO(CallExpression): result.push(undefinedType) */
		}
		return result || types
	}
	visibilityToString := func(flags ModifierFlags) string {
		if flags == ModifierFlagsPrivate {
			return "private"
		}
		if flags == ModifierFlagsProtected {
			return "protected"
		}
		return "public"
	}
	getTypeAliasForTypeLiteral := func(type_ Type) *Symbol {
		if type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && type_.symbol.declarations {
			node := walkUpParenthesizedTypes( /* TODO(ElementAccessExpression): type.symbol.declarations[0] */ TODO.parent)
			if isTypeAliasDeclaration(node) {
				return getSymbolOfDeclaration(node)
			}
		}
		return nil
	}
	isTopLevelInExternalModuleAugmentation := func(node Node) bool {
		return node && node.parent && node.parent.kind == SyntaxKindModuleBlock && isExternalModuleAugmentation(node.parent.parent)
	}
	isDefaultBindingContext := func(location Node) /* TODO(undefined): boolean */ TODO {
		return location.kind == SyntaxKindSourceFile || isAmbientModule(location)
	}
	getNameOfSymbolFromNameType := func(symbol Symbol, context NodeBuilderContext) /* TODO(undefined): string | undefined */ TODO {
		nameType := getSymbolLinks(symbol).nameType
		if nameType {
			if nameType.flags & TypeFlagsStringOrNumberLiteral {
				name := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (nameType as StringLiteralType | NumberLiteralType).value */ TODO
				if !isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name) {
					return /* TODO(TemplateExpression): `"${escapeString(name, CharacterCodes.doubleQuote)}"` */ TODO
				}
				if isNumericLiteralName(name) && startsWith(name, "-") {
					return /* TODO(TemplateExpression): `[${name}]` */ TODO
				}
				return name
			}
			if nameType.flags & TypeFlagsUniqueESSymbol {
				return /* TODO(TemplateExpression): `[${getNameOfSymbolAsWritten((nameType as UniqueESSymbolType).symbol, context)}]` */ TODO
			}
		}
	}
	getNameOfSymbolAsWritten := func(symbol Symbol, context NodeBuilderContext) string {
		if context.remappedSymbolReferences.has(getSymbolId(symbol)) {
			symbol = /* TODO(NonNullExpression): context.remappedSymbolReferences.get(getSymbolId(symbol))! */ TODO
		}
		if context && symbol.escapedName == InternalSymbolNameDefault && !(context.flags & NodeBuilderFlagsUseAliasDefinedOutsideCurrentScope) && (!(context.flags & NodeBuilderFlagsInInitialEntityName) || !symbol.declarations || (context.enclosingDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): findAncestor(symbol.declarations[0], isDefaultBindingContext) !== findAncestor(context.enclosingDeclaration, isDefaultBindingContext) */ TODO)) {
			return "default"
		}
		if symbol.declarations && symbol.declarations.length {
			declaration := firstDefined(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration | undefined */ TODO {
				/* TODO(CallExpression): getNameOfDeclaration(d) */
				/* TODO(QuestionToken): ? */
				/* TODO(Identifier): d */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): undefined */
			})
			name := declaration && getNameOfDeclaration(declaration)
			if declaration && name {
				if isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration) {
					return symbolName(symbol)
				}
				if isComputedPropertyName(name) && !(getCheckFlags(symbol) & CheckFlagsLate) {
					nameType := getSymbolLinks(symbol).nameType
					if nameType && nameType.flags&TypeFlagsStringOrNumberLiteral {
						result := getNameOfSymbolFromNameType(symbol, context)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== undefined */ TODO {
							return result
						}
					}
				}
				return declarationNameToString(name)
			}
			if !declaration {
				declaration = /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO
			}
			if declaration.parent && declaration.parent.kind == SyntaxKindVariableDeclaration {
				return declarationNameToString((declaration.parent /* as */ /* TODO(TypeReference): VariableDeclaration */).name)
			}
			/* TODO(SwitchStatement): switch (declaration.kind) {                 case SyntaxKind.ClassExpression:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                     if (context && !context.encounteredError && !(context.flags & NodeBuilderFlags.AllowAnonymousIdentifier)) {                         context.encounteredError = true;                     }                     return declaration.kind === SyntaxKind.ClassExpression ? "(Anonymous class)" : "(Anonymous function)";             } */
		}
		name := getNameOfSymbolFromNameType(symbol, context)
		return /* TODO(ConditionalExpression): name !== undefined ? name : symbolName(symbol) */ TODO
	}
	isDeclarationVisible := func(node Node) bool {
		if node {
			links := getNodeLinks(node)
			if links.isVisible == nil {
				links.isVisible = !!determineIfDeclarationIsVisible()
			}
			return links.isVisible
		}
		return false
		determineIfDeclarationIsVisible := func() /* TODO(undefined): boolean */ TODO {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocEnumTag:                     // Top-level jsdoc type aliases are considered exported                     // First parent is comment node, second is hosting declaration or token; we only care about those tokens or declarations whose parent is a source file                     return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent));                 case SyntaxKind.BindingElement:                     return isDeclarationVisible(node.parent.parent);                 case SyntaxKind.VariableDeclaration:                     if (                         isBindingPattern((node as VariableDeclaration).name) &&                         !((node as VariableDeclaration).name as BindingPattern).elements.length                     ) {                         // If the binding pattern is empty, this variable declaration is not visible                         return false;                     }                     // falls through                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.EnumDeclaration:                 case SyntaxKind.ImportEqualsDeclaration:                     // external module augmentation is always visible                     if (isExternalModuleAugmentation(node)) {                         return true;                     }                     const parent = getDeclarationContainer(node);                     // If the node is not exported or it is not ambient module element (except import declaration)                     if (                         !(getCombinedModifierFlagsCached(node as Declaration) & ModifierFlags.Export) &&                         !(node.kind !== SyntaxKind.ImportEqualsDeclaration && parent.kind !== SyntaxKind.SourceFile && parent.flags & NodeFlags.Ambient)                     ) {                         return isGlobalSourceFile(parent);                     }                     // Exported members/ambient module elements (exception import declaration) are visible if parent is visible                     return isDeclarationVisible(parent);                  case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.PropertySignature:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.MethodSignature:                     if (hasEffectiveModifier(node, ModifierFlags.Private | ModifierFlags.Protected)) {                         // Private/protected properties/methods are not visible                         return false;                     }                     // Public properties/methods are visible if its parents are visible, so:                     // falls through                  case SyntaxKind.Constructor:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.CallSignature:                 case SyntaxKind.IndexSignature:                 case SyntaxKind.Parameter:                 case SyntaxKind.ModuleBlock:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.TypeLiteral:                 case SyntaxKind.TypeReference:                 case SyntaxKind.ArrayType:                 case SyntaxKind.TupleType:                 case SyntaxKind.UnionType:                 case SyntaxKind.IntersectionType:                 case SyntaxKind.ParenthesizedType:                 case SyntaxKind.NamedTupleMember:                     return isDeclarationVisible(node.parent);                  // Default binding, import specifier and namespace import is visible                 // only on demand so by default it is not visible                 case SyntaxKind.ImportClause:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportSpecifier:                     return false;                  // Type parameters are always visible                 case SyntaxKind.TypeParameter:                  // Source file and namespace export are always visible                 // falls through                 case SyntaxKind.SourceFile:                 case SyntaxKind.NamespaceExportDeclaration:                     return true;                  // Export assignments do not create name bindings outside the module                 case SyntaxKind.ExportAssignment:                     return false;                  default:                     return false;             } */
		}
	}
	collectLinkedAliases := func(node ModuleExportName, setVisibility bool) /* TODO(ArrayType): Node[] */ any {
		var exportSymbol *Symbol
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.StringLiteral */ TODO && node.parent && node.parent.kind == SyntaxKindExportAssignment {
			exportSymbol = resolveName(node, node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, false)
		} else if node.parent.kind == SyntaxKindExportSpecifier {
			exportSymbol = getTargetOfExportSpecifier(node.parent /* as */ /* TODO(TypeReference): ExportSpecifier */, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
		var result /* TODO(ArrayType): Node[] */ any
		var visited *Set[number]
		if exportSymbol {
			visited = /* TODO(NewExpression): new Set() */ TODO
			visited.add(getSymbolId(exportSymbol))
			buildVisibleNodeList(exportSymbol.declarations)
		}
		return result
		buildVisibleNodeList := func(declarations /* TODO(ArrayType): Declaration[] */ any) {
			forEach(declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				resultNode := getAnyImportSyntax(declaration) || declaration
				if setVisibility {
					getNodeLinks(declaration).isVisible = true
				} else {
					result = result || /* TODO(ArrayLiteralExpression): [] */ TODO
					pushIfUnique(result, resultNode)
				}
				if isInternalModuleImportEqualsDeclaration(declaration) {
					internalModuleReference := declaration.moduleReference /* as */ /* TODO(UnionType): Identifier | QualifiedName */
					firstIdentifier := getFirstIdentifier(internalModuleReference)
					importSymbol := resolveName(declaration, firstIdentifier.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace, nil, false)
					if importSymbol && visited {
						if tryAddToSet(visited, getSymbolId(importSymbol)) {
							buildVisibleNodeList(importSymbol.declarations)
						}
					}
				}
			})
		}
	}
	pushTypeResolution := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		resolutionCycleStartIndex := findResolutionCycleStartIndex(target, propertyName)
		if resolutionCycleStartIndex >= 0 {
			TODO_IDENTIFIER := resolutionTargets
			/* TODO(ForStatement): for (let i = resolutionCycleStartIndex; i < length; i++) {                 resolutionResults[i] = false;             } */
			return false
		}
		resolutionTargets.push(target)
		resolutionResults.push(true)
		resolutionPropertyNames.push(propertyName)
		return true
	}
	findResolutionCycleStartIndex := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) number {
		/* TODO(ForStatement): for (let i = resolutionTargets.length - 1; i >= resolutionStart; i--) {             if (resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i])) {                 return -1;             }             if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {                 return i;             }         } */
		return -1
	}
	resolutionTargetHasProperty := func(target TypeSystemEntity, propertyName TypeSystemPropertyName) bool {
		/* TODO(SwitchStatement): switch (propertyName) {             case TypeSystemPropertyName.Type:                 return !!getSymbolLinks(target as Symbol).type;             case TypeSystemPropertyName.DeclaredType:                 return !!getSymbolLinks(target as Symbol).declaredType;             case TypeSystemPropertyName.ResolvedBaseConstructorType:                 return !!(target as InterfaceType).resolvedBaseConstructorType;             case TypeSystemPropertyName.ResolvedReturnType:                 return !!(target as Signature).resolvedReturnType;             case TypeSystemPropertyName.ImmediateBaseConstraint:                 return !!(target as Type).immediateBaseConstraint;             case TypeSystemPropertyName.ResolvedTypeArguments:                 return !!(target as TypeReference).resolvedTypeArguments;             case TypeSystemPropertyName.ResolvedBaseTypes:                 return !!(target as InterfaceType).baseTypesResolved;             case TypeSystemPropertyName.WriteType:                 return !!getSymbolLinks(target as Symbol).writeType;             case TypeSystemPropertyName.ParameterInitializerContainsUndefined:                 return getNodeLinks(target as ParameterDeclaration).parameterInitializerContainsUndefined !== undefined;         } */
		return Debug.assertNever(propertyName)
	}
	popTypeResolution := func() bool {
		resolutionTargets.pop()
		resolutionPropertyNames.pop()
		return /* TODO(NonNullExpression): resolutionResults.pop()! */ TODO
	}
	getDeclarationContainer := func(node Node) Node {
		return /* TODO(NonNullExpression): findAncestor(getRootDeclaration(node), node => {             switch (node.kind) {                 case SyntaxKind.VariableDeclaration:                 case SyntaxKind.VariableDeclarationList:                 case SyntaxKind.ImportSpecifier:                 case SyntaxKind.NamedImports:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportClause:                     return false;                 default:                     return true;             }         })! */ TODO.parent
	}
	getTypeOfPrototypeProperty := func(prototype Symbol) Type {
		classType := getDeclaredTypeOfSymbol( /* TODO(NonNullExpression): getParentOfSymbol(prototype)! */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
		return /* TODO(ConditionalExpression): classType.typeParameters ? createTypeReference(classType as GenericType, map(classType.typeParameters, _ => anyType)) : classType */ TODO
	}
	getTypeOfPropertyOfType := func(type_ Type, name __String) *Type {
		prop := getPropertyOfType(type_, name)
		return /* TODO(ConditionalExpression): prop ? getTypeOfSymbol(prop) : undefined */ TODO
	}
	getTypeOfPropertyOrIndexSignatureOfType := func(type_ Type, name __String) *Type {
		var propType TODO
		return getTypeOfPropertyOfType(type_, name) || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): propType = getApplicableIndexInfoForName(type, name)?.type */ TODO) && addOptionality(propType, true, true)
	}
	isTypeAny := func(type_ *Type) /* TODO(undefined): boolean | undefined */ TODO {
		return type_ && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (type.flags & TypeFlags.Any) !== 0 */ TODO
	}
	isErrorType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return type_ == errorType || !!(type_.flags&TypeFlagsAny && type_.aliasSymbol)
	}
	getTypeForBindingElementParent := func(node BindingElementGrandparent, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): checkMode !== CheckMode.Normal */ TODO {
			return getTypeForVariableLikeDeclaration(node, false, checkMode)
		}
		symbol := getSymbolOfDeclaration(node)
		return symbol && getSymbolLinks(symbol).type_ || getTypeForVariableLikeDeclaration(node, false, checkMode)
	}
	getRestType := func(source Type, properties []PropertyName, symbol *Symbol) Type {
		source = filterType(source, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Nullable) */
		})
		if source.flags & TypeFlagsNever {
			return emptyObjectType
		}
		if source.flags & TypeFlagsUnion {
			return mapType(source, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getRestType */
				/* TODO(Identifier): t */
				/* TODO(Identifier): properties */
				/* TODO(Identifier): symbol */
			})
		}
		omitKeyType := getUnionType(map_(properties, getLiteralTypeFromPropertyName))
		var spreadableProperties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var unspreadableToRestKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, prop := range getPropertiesOfType(source) {
			literalTypeFromProperty := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
			if !isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && !(getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected)) && isSpreadableProperty(prop) {
				spreadableProperties.push(prop)
			} else {
				unspreadableToRestKeys.push(literalTypeFromProperty)
			}
		}
		if isGenericObjectType(source) || isGenericIndexType(omitKeyType) {
			if unspreadableToRestKeys.length {
				omitKeyType = getUnionType( /* TODO(ArrayLiteralExpression): [omitKeyType, ...unspreadableToRestKeys] */ TODO)
			}
			if omitKeyType.flags & TypeFlagsNever {
				return source
			}
			omitTypeAlias := getGlobalOmitSymbol()
			if !omitTypeAlias {
				return errorType
			}
			return getTypeAliasInstantiation(omitTypeAlias /* TODO(ArrayLiteralExpression): [source, omitKeyType] */, TODO)
		}
		members := createSymbolTable()
		for _, prop := range spreadableProperties {
			members.set(prop.escapedName, getSpreadSymbol(prop, false))
		}
		result := createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source))
		result.objectFlags |= ObjectFlagsObjectRestType
		return result
	}
	isGenericTypeWithUndefinedConstraint := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags & TypeFlagsInstantiable) && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsUndefined)
	}
	getNonUndefinedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeOrConstraint := /* TODO(ConditionalExpression): someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & TypeFlags.Instantiable ? getBaseConstraintOrType(t) : t) : type */ TODO
		return getTypeWithFacts(typeOrConstraint, TypeFactsNEUndefined)
	}
	getFlowTypeOfDestructuring := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any, declaredType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reference := getSyntheticElementAccess(node)
		return /* TODO(ConditionalExpression): reference ? getFlowTypeOfReference(reference, declaredType) : declaredType */ TODO
	}
	getSyntheticElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) *ElementAccessExpression {
		parentAccess := getParentElementAccess(node)
		if parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode {
			propName := getDestructuringPropertyName(node)
			if propName {
				literal := setTextRangeWorker(parseNodeFactory.createStringLiteral(propName), node)
				lhsExpr := /* TODO(ConditionalExpression): isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess) */ TODO
				result := setTextRangeWorker(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node)
				setParent(literal, result)
				setParent(result, node)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): lhsExpr !== parentAccess */ TODO {
					setParent(lhsExpr, result)
				}
				result.flowNode = parentAccess.flowNode
				return result
			}
		}
	}
	getParentElementAccess := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		ancestor := node.parent.parent
		/* TODO(SwitchStatement): switch (ancestor.kind) {             case SyntaxKind.BindingElement:             case SyntaxKind.PropertyAssignment:                 return getSyntheticElementAccess(ancestor as BindingElement | PropertyAssignment);             case SyntaxKind.ArrayLiteralExpression:                 return getSyntheticElementAccess(node.parent as Expression);             case SyntaxKind.VariableDeclaration:                 return (ancestor as VariableDeclaration).initializer;             case SyntaxKind.BinaryExpression:                 return (ancestor as BinaryExpression).right;         } */
	}
	getDestructuringPropertyName := func(node /* TODO(UnionType): BindingElement | PropertyAssignment | ShorthandPropertyAssignment | Expression */ any) /* TODO(undefined): string | undefined */ TODO {
		parent := node.parent
		if node.kind == SyntaxKindBindingElement && parent.kind == SyntaxKindObjectBindingPattern {
			return getLiteralPropertyNameText((node /* as */ /* TODO(TypeReference): BindingElement */).propertyName || (node /* as */ /* TODO(TypeReference): BindingElement */).name /* as */ /* TODO(TypeReference): Identifier */)
		}
		if node.kind == SyntaxKindPropertyAssignment || node.kind == SyntaxKindShorthandPropertyAssignment {
			return getLiteralPropertyNameText((node /* as */ /* TODO(UnionType): PropertyAssignment | ShorthandPropertyAssignment */).name)
		}
		return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + ((parent as BindingPattern | ArrayLiteralExpression).elements as NodeArray<Node>).indexOf(node) */ TODO
	}
	getLiteralPropertyNameText := func(name PropertyName) /* TODO(undefined): string | undefined */ TODO {
		type_ := getLiteralTypeFromPropertyName(name)
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.NumberLiteral) ? "" + (type as StringLiteralType | NumberLiteralType).value : undefined */ TODO
	}
	getTypeForBindingElement := func(declaration BindingElement) *Type {
		checkMode := /* TODO(ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
		parentType := getTypeForBindingElementParent(declaration.parent.parent, checkMode)
		return parentType && getBindingElementTypeFromParentType(declaration, parentType, false)
	}
	getBindingElementTypeFromParentType := func(declaration BindingElement, parentType Type, noTupleBoundsCheck bool) Type {
		if isTypeAny(parentType) {
			return parentType
		}
		pattern := declaration.parent
		if strictNullChecks && declaration.flags&NodeFlagsAmbient && isPartOfParameterDeclaration(declaration) {
			parentType = getNonNullableType(parentType)
		} else if strictNullChecks && pattern.parent.initializer && !(hasTypeFacts(getTypeOfInitializer(pattern.parent.initializer), TypeFactsEQUndefined)) {
			parentType = getTypeWithFacts(parentType, TypeFactsNEUndefined)
		}
		accessFlags := AccessFlagsExpressionPosition | ( /* TODO(ConditionalExpression): noTupleBoundsCheck || hasDefaultValue(declaration) ? AccessFlags.AllowMissing : 0 */ TODO)
		var type_ *Type
		if pattern.kind == SyntaxKindObjectBindingPattern {
			if declaration.dotDotDotToken {
				parentType = getReducedType(parentType)
				if parentType.flags&TypeFlagsUnknown || !isValidSpreadType(parentType) {
					error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types)
					return errorType
				}
				var literalMembers []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
				for _, element := range pattern.elements {
					if !element.dotDotDotToken {
						literalMembers.push(element.propertyName || element.name /* as */ /* TODO(TypeReference): Identifier */)
					}
				}
				type_ = getRestType(parentType, literalMembers, declaration.symbol)
			} else {
				name := declaration.propertyName || declaration.name /* as */ /* TODO(TypeReference): Identifier */
				indexType := getLiteralTypeFromPropertyName(name)
				declaredType := getIndexedAccessType(parentType, indexType, accessFlags, name)
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			}
		} else {
			elementType := checkIteratedTypeOrElementType(IterationUseDestructuring|( /* TODO(ConditionalExpression): declaration.dotDotDotToken ? 0 : IterationUse.PossiblyOutOfBounds */ TODO), parentType, undefinedType, pattern)
			index := pattern.elements.indexOf(declaration)
			if declaration.dotDotDotToken {
				baseConstraint := mapType(parentType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(BinaryExpression): t.flags & TypeFlags.InstantiableNonPrimitive */
					/* TODO(QuestionToken): ? */
					/* TODO(CallExpression): getBaseConstraintOrType(t) */
					/* TODO(ColonToken): : */
					/* TODO(Identifier): t */
				})
				type_ = /* TODO(ConditionalExpression): everyType(baseConstraint, isTupleType) ?                     mapType(baseConstraint, t => sliceTupleType(t as TupleTypeReference, index)) :                     createArrayType(elementType) */ TODO
			} else if isArrayLikeType(parentType) {
				indexType := getNumberLiteralType(index)
				declaredType := getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType
				type_ = getFlowTypeOfDestructuring(declaration, declaredType)
			} else {
				type_ = elementType
			}
		}
		if !declaration.initializer {
			return type_
		}
		if getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration)) {
			return /* TODO(ConditionalExpression): strictNullChecks && !(hasTypeFacts(checkDeclarationInitializer(declaration, CheckMode.Normal), TypeFacts.IsUndefined)) ? getNonUndefinedType(type) : type */ TODO
		}
		return widenTypeInferredFromInitializer(declaration, getUnionType( /* TODO(ArrayLiteralExpression): [getNonUndefinedType(type), checkDeclarationInitializer(declaration, CheckMode.Normal)] */ TODO, UnionReductionSubtype))
	}
	getTypeForDeclarationFromJSDocComment := func(declaration Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		jsdocType := getJSDocType(declaration)
		if jsdocType {
			return getTypeFromTypeNode(jsdocType)
		}
		return nil
	}
	isNullOrUndefined := func(node Expression) /* TODO(undefined): boolean */ TODO {
		expr := skipParentheses(node, true)
		return expr.kind == SyntaxKindNullKeyword || expr.kind == SyntaxKindIdentifier && getResolvedSymbol(expr /* as */ /* TODO(TypeReference): Identifier */) == undefinedSymbol
	}
	isEmptyArrayLiteral := func(node Expression) /* TODO(undefined): boolean */ TODO {
		expr := skipParentheses(node, true)
		return expr.kind == SyntaxKindArrayLiteralExpression && (expr /* as */ /* TODO(TypeReference): ArrayLiteralExpression */).elements.length == 0
	}
	addOptionality := func(type_ Type, isProperty /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, isOptional /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) Type {
		return /* TODO(ConditionalExpression): strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type */ TODO
	}
	getTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, includeOptionality bool, checkMode CheckMode) *Type {
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForInStatement {
			indexType := getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, checkMode)))
			return /* TODO(ConditionalExpression): indexType.flags & (TypeFlags.TypeParameter | TypeFlags.Index) ? getExtractStringType(indexType) : stringType */ TODO
		}
		if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
			forOfStatement := declaration.parent.parent
			return checkRightHandSideOfForOf(forOfStatement) || anyType
		}
		if isBindingPattern(declaration.parent) {
			return getTypeForBindingElement(declaration /* as */ /* TODO(TypeReference): BindingElement */)
		}
		isProperty := (isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration)) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration)
		isOptional := includeOptionality && isOptionalDeclaration(declaration)
		declaredType := tryGetTypeFromEffectiveTypeNode(declaration)
		if isCatchClauseVariableDeclarationOrBindingElement(declaration) {
			if declaredType {
				return /* TODO(ConditionalExpression): isTypeAny(declaredType) || declaredType === unknownType ? declaredType : errorType */ TODO
			}
			return /* TODO(ConditionalExpression): useUnknownInCatchVariables ? unknownType : anyType */ TODO
		}
		if declaredType {
			return addOptionality(declaredType, isProperty, isOptional)
		}
		if (noImplicitAny || isInJSFile(declaration)) && isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) && !(getCombinedModifierFlagsCached(declaration) & ModifierFlagsExport) && !(declaration.flags & NodeFlagsAmbient) {
			if !(getCombinedNodeFlagsCached(declaration) & NodeFlagsConstant) && (!declaration.initializer || isNullOrUndefined(declaration.initializer)) {
				return autoType
			}
			if declaration.initializer && isEmptyArrayLiteral(declaration.initializer) {
				return autoArrayType
			}
		}
		if isParameter(declaration) {
			if !declaration.symbol {
				return
			}
			func_ := declaration.parent /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */
			if func_.kind == SyntaxKindSetAccessor && hasBindableName(func_) {
				getter := getDeclarationOfKind(getSymbolOfDeclaration(declaration.parent), SyntaxKindGetAccessor)
				if getter {
					getterSignature := getSignatureFromDeclaration(getter)
					thisParameter := getAccessorThisParameter(func_ /* as */ /* TODO(TypeReference): AccessorDeclaration */)
					if thisParameter && declaration == thisParameter {
						Debug.assert(!thisParameter.type_)
						return getTypeOfSymbol( /* TODO(NonNullExpression): getterSignature.thisParameter! */ TODO)
					}
					return getReturnTypeOfSignature(getterSignature)
				}
			}
			parameterTypeOfTypeTag := getParameterTypeOfTypeTag(func_, declaration)
			if parameterTypeOfTypeTag {
				/* TODO(Identifier): parameterTypeOfTypeTag */
			}
			type_ := /* TODO(ConditionalExpression): declaration.symbol.escapedName === InternalSymbolName.This ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration) */ TODO
			if type_ {
				return addOptionality(type_, false, isOptional)
			}
		}
		if hasOnlyExpressionInitializer(declaration) && !!declaration.initializer {
			if isInJSFile(declaration) && !isParameter(declaration) {
				containerObjectType := getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration))
				if containerObjectType {
					return containerObjectType
				}
			}
			type_ := widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode))
			return addOptionality(type_, isProperty, isOptional)
		}
		if isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration)) {
			if !hasStaticModifier(declaration) {
				constructor := findConstructorDeclaration(declaration.parent)
				type_ := /* TODO(ConditionalExpression): constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
				return type_ && addOptionality(type_, true, isOptional)
			} else {
				staticBlocks := filter(declaration.parent.members, isClassStaticBlockDeclaration)
				type_ := /* TODO(ConditionalExpression): staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) :                     getEffectiveModifierFlags(declaration) & ModifierFlags.Ambient ? getTypeOfPropertyInBaseClass(declaration.symbol) :                     undefined */ TODO
				return type_ && addOptionality(type_, true, isOptional)
			}
		}
		if isJsxAttribute(declaration) {
			return trueType
		}
		if isBindingPattern(declaration.name) {
			return getTypeFromBindingPattern(declaration.name, false, true)
		}
		return nil
	}
	isConstructorDeclaredProperty := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isConstructorDeclaredProperty == nil {
				links.isConstructorDeclaredProperty = false
				links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): isBinaryExpression(declaration) &&                     isPossiblyAliasedThisProperty(declaration) &&                     (declaration.left.kind !== SyntaxKind.ElementAccessExpression || isStringOrNumericLiteralLike((declaration.left as ElementAccessExpression).argumentExpression)) */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(PrefixUnaryExpression): !getAnnotatedTypeForAssignmentDeclaration(/*declaredType* / undefined, declaration, symbol, declaration) */
				})
			}
			return links.isConstructorDeclaredProperty
		}
		return false
	}
	isAutoTypedProperty := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		declaration := symbol.valueDeclaration
		return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) && !declaration.initializer && (noImplicitAny || isInJSFile(declaration))
	}
	getDeclaringConstructor := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ConstructorDeclaration | undefined */ TODO {
		if !symbol.declarations {
			return
		}
		for _, declaration := range symbol.declarations {
			container := getThisContainer(declaration, false, false)
			if container && (container.kind == SyntaxKindConstructor || isJSConstructor(container)) {
				return container /* as */ /* TODO(TypeReference): ConstructorDeclaration */
			}
		}
	}
	getFlowTypeFromCommonJSExport := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		file := getSourceFileOfNode( /* TODO(ElementAccessExpression): symbol.declarations![0] */ TODO)
		accessName := unescapeLeadingUnderscores(symbol.escapedName)
		areAllModuleExports := /* TODO(NonNullExpression): symbol.declarations! */ TODO.every(func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): isInJSFile(d) && isAccessExpression(d) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isModuleExportsAccessExpression(d.expression) */
		})
		reference := /* TODO(ConditionalExpression): areAllModuleExports             ? factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName)             : factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName) */ TODO
		if areAllModuleExports {
			setParent((reference.expression /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression, reference.expression)
		}
		setParent(reference.expression, reference)
		setParent(reference, file)
		reference.flowNode = file.endFlowNode
		return getFlowTypeOfReference(reference, autoType, undefinedType)
	}
	getFlowTypeInStaticBlocks := func(symbol Symbol, staticBlocks []ClassStaticBlockDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		for _, staticBlock := range staticBlocks {
			reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
			setParent(reference.expression, reference)
			setParent(reference, staticBlock)
			reference.flowNode = staticBlock.returnFlowNode
			flowType := getFlowTypeOfProperty(reference, symbol)
			if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
				error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
			}
			if everyType(flowType, isNullableType) {
				/* TODO(ContinueStatement): continue; */
			}
			return convertAutoToAny(flowType)
		}
	}
	getFlowTypeInConstructor := func(symbol Symbol, constructor ConstructorDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessName := /* TODO(ConditionalExpression): startsWith(symbol.escapedName as string, "__#")             ? factory.createPrivateIdentifier((symbol.escapedName as string).split("@")[1])             : unescapeLeadingUnderscores(symbol.escapedName) */ TODO
		reference := factory.createPropertyAccessExpression(factory.createThis(), accessName)
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfProperty(reference, symbol)
		if noImplicitAny && (flowType == autoType || flowType == autoArrayType) {
			error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
		}
		return /* TODO(ConditionalExpression): everyType(flowType, isNullableType) ? undefined : convertAutoToAny(flowType) */ TODO
	}
	getFlowTypeOfProperty := func(reference Node, prop *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		initialType := prop.valueDeclaration && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration)&ModifierFlagsAmbient) && getTypeOfPropertyInBaseClass(prop) || undefinedType
		return getFlowTypeOfReference(reference, autoType, initialType)
	}
	getWidenedTypeForAssignmentDeclaration := func(symbol Symbol, resolvedSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		container := getAssignedExpandoInitializer(symbol.valueDeclaration)
		if container {
			tag := /* TODO(ConditionalExpression): isInJSFile(container) ? getJSDocTypeTag(container) : undefined */ TODO
			if tag && tag.typeExpression {
				return getTypeFromTypeNode(tag.typeExpression)
			}
			containerObjectType := symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container)
			return containerObjectType || getWidenedLiteralType(checkExpressionCached(container))
		}
		var type_ TODO
		definedInConstructor := false
		definedInMethod := false
		if isConstructorDeclaredProperty(symbol) {
			type_ = getFlowTypeInConstructor(symbol /* TODO(NonNullExpression): getDeclaringConstructor(symbol)! */, TODO)
		}
		if !type_ {
			var types /* TODO(ArrayType): Type[] */ any
			if symbol.declarations {
				var jsdocType *Type
				for _, declaration := range symbol.declarations {
					expression := /* TODO(ConditionalExpression): (isBinaryExpression(declaration) || isCallExpression(declaration)) ? declaration :                         isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration :                         undefined */ TODO
					if !expression {
						/* TODO(ContinueStatement): continue; */
					}
					kind := /* TODO(ConditionalExpression): isAccessExpression(expression)                         ? getAssignmentDeclarationPropertyAccessKind(expression)                         : getAssignmentDeclarationKind(expression) */ TODO
					if kind == AssignmentDeclarationKindThisProperty || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind) {
						if isDeclarationInConstructor(expression) {
							definedInConstructor = true
						} else {
							definedInMethod = true
						}
					}
					if !isCallExpression(expression) {
						jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration)
					}
					if !jsdocType {
						(types || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): types = [] */ TODO)).push( /* TODO(ConditionalExpression): (isBinaryExpression(expression) || isCallExpression(expression)) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType */ TODO)
					}
				}
				type_ = jsdocType
			}
			if !type_ {
				if !length(types) {
					return errorType
				}
				constructorTypes := /* TODO(ConditionalExpression): definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types!, symbol.declarations) : undefined */ TODO
				if definedInMethod {
					propType := getTypeOfPropertyInBaseClass(symbol)
					if propType {
						(constructorTypes || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): constructorTypes = [] */ TODO)).push(propType)
						definedInConstructor = true
					}
				}
				sourceTypes := /* TODO(ConditionalExpression): some(constructorTypes, t => !!(t.flags & ~TypeFlags.Nullable)) ? constructorTypes : types */ TODO
				type_ = getUnionType( /* TODO(NonNullExpression): sourceTypes! */ TODO)
			}
		}
		widened := getWidenedType(addOptionality(type_, false, definedInMethod && !definedInConstructor))
		if symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && filterType(widened, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(t.flags & ~TypeFlags.Nullable) */
		}) == neverType {
			reportImplicitAny(symbol.valueDeclaration, anyType)
			return anyType
		}
		return widened
	}
	getJSContainerObjectType := func(decl Node, symbol Symbol, init *Expression) *Type {
		if !isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length {
			return nil
		}
		exports := createSymbolTable()
		/* TODO(WhileStatement): while (isBinaryExpression(decl) || isPropertyAccessExpression(decl)) {             const s = getSymbolOfNode(decl);             if (s?.exports?.size) {                 mergeSymbolTable(exports, s.exports);             }             decl = isBinaryExpression(decl) ? decl.parent : decl.parent.parent;         } */
		s := getSymbolOfNode(decl)
		if s.exports.size {
			mergeSymbolTable(exports, s.exports)
		}
		type_ := createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray)
		type_.objectFlags |= ObjectFlagsJSLiteral
		return type_
	}
	getAnnotatedTypeForAssignmentDeclaration := func(declaredType *Type, expression Expression, symbol Symbol, declaration Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		typeNode := getEffectiveTypeAnnotationNode(expression.parent)
		if typeNode {
			type_ := getWidenedType(getTypeFromTypeNode(typeNode))
			if !declaredType {
				return type_
			} else if !isErrorType(declaredType) && !isErrorType(type_) && !isTypeIdenticalTo(declaredType, type_) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(nil, declaredType, declaration, type_)
			}
		}
		if symbol.parent.valueDeclaration {
			possiblyAnnotatedSymbol := getFunctionExpressionParentSymbolOrSymbol(symbol.parent)
			if possiblyAnnotatedSymbol.valueDeclaration {
				typeNode := getEffectiveTypeAnnotationNode(possiblyAnnotatedSymbol.valueDeclaration)
				if typeNode {
					annotationSymbol := getPropertyOfType(getTypeFromTypeNode(typeNode), symbol.escapedName)
					if annotationSymbol {
						return getNonMissingTypeOfSymbol(annotationSymbol)
					}
				}
			}
		}
		return declaredType
	}
	getInitializerTypeFromAssignmentDeclaration := func(symbol Symbol, resolvedSymbol *Symbol, expression /* TODO(UnionType): BinaryExpression | CallExpression */ any, kind AssignmentDeclarationKind) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isCallExpression(expression) {
			if resolvedSymbol {
				return getTypeOfSymbol(resolvedSymbol)
			}
			objectLitType := checkExpressionCached( /* TODO(ElementAccessExpression): (expression as BindableObjectDefinePropertyCall).arguments[2] */ TODO)
			valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as */ /* TODO(TypeReference): __String */)
			if valueType {
				return valueType
			}
			getFunc := getTypeOfPropertyOfType(objectLitType, "get" /* as */ /* TODO(TypeReference): __String */)
			if getFunc {
				getSig := getSingleCallSignature(getFunc)
				if getSig {
					return getReturnTypeOfSignature(getSig)
				}
			}
			setFunc := getTypeOfPropertyOfType(objectLitType, "set" /* as */ /* TODO(TypeReference): __String */)
			if setFunc {
				setSig := getSingleCallSignature(setFunc)
				if setSig {
					return getTypeOfFirstParameterOfSignature(setSig)
				}
			}
			return anyType
		}
		if containsSameNamedThisProperty(expression.left, expression.right) {
			return anyType
		}
		isDirectExport := kind == AssignmentDeclarationKindExportsProperty && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || (isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression)))
		type_ := /* TODO(ConditionalExpression): resolvedSymbol ? getTypeOfSymbol(resolvedSymbol)             : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right))             : getWidenedLiteralType(checkExpressionCached(expression.right)) */ TODO
		if type_.flags&TypeFlagsObject && kind == AssignmentDeclarationKindModuleExports && symbol.escapedName == InternalSymbolNameExportEquals {
			exportedType := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			members := createSymbolTable()
			copyEntries(exportedType.members, members)
			initialSize := members.size
			if resolvedSymbol && !resolvedSymbol.exports {
				resolvedSymbol.exports = createSymbolTable()
			}
			/* TODO(NonNullExpression): (resolvedSymbol || symbol).exports! */ TODO.forEach(func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				exportedMember := /* TODO(NonNullExpression): members.get(name)! */ TODO
				if exportedMember && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): exportedMember !== s */ TODO && !(s.flags & SymbolFlagsAlias) {
					if s.flags&SymbolFlagsValue && exportedMember.flags&SymbolFlagsValue {
						if s.valueDeclaration && exportedMember.valueDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(s.valueDeclaration) !== getSourceFileOfNode(exportedMember.valueDeclaration) */ TODO {
							unescapedName := unescapeLeadingUnderscores(s.escapedName)
							exportedMemberName := tryCast(exportedMember.valueDeclaration, isNamedDeclaration).name || exportedMember.valueDeclaration
							addRelatedInfo(error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName))
							addRelatedInfo(error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName))
						}
						union := createSymbol(s.flags|exportedMember.flags, name)
						union.links.type_ = getUnionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)] */ TODO)
						union.valueDeclaration = exportedMember.valueDeclaration
						union.declarations = concatenate(exportedMember.declarations, s.declarations)
						members.set(name, union)
					} else {
						members.set(name, mergeSymbol(s, exportedMember))
					}
				} else {
					members.set(name, s)
				}
			})
			result := createAnonymousType( /* TODO(ConditionalExpression): initialSize !== members.size ? undefined : exportedType.symbol */ TODO, members, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos)
			if initialSize == members.size {
				if type_.aliasSymbol {
					result.aliasSymbol = type_.aliasSymbol
					result.aliasTypeArguments = type_.aliasTypeArguments
				}
				if getObjectFlags(type_) & ObjectFlagsReference {
					result.aliasSymbol = (type_ /* as */ /* TODO(TypeReference): TypeReference */).symbol
					args := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
					result.aliasTypeArguments = /* TODO(ConditionalExpression): length(args) ? args : undefined */ TODO
				}
			}
			result.objectFlags |= getPropagatingFlagsOfTypes( /* TODO(ArrayLiteralExpression): [type] */ TODO) | getObjectFlags(type_)&(ObjectFlagsJSLiteral|ObjectFlagsArrayLiteral|ObjectFlagsObjectLiteral)
			if result.symbol && result.symbol.flags&SymbolFlagsClass && type_ == getDeclaredTypeOfClassOrInterface(result.symbol) {
				result.objectFlags |= ObjectFlagsIsClassInstanceClone
			}
			return result
		}
		if isEmptyArrayLiteralType(type_) {
			reportImplicitAny(expression, anyArrayType)
			return anyArrayType
		}
		return type_
	}
	containsSameNamedThisProperty := func(thisProperty Expression, expression Expression) /* TODO(undefined): boolean | undefined */ TODO {
		return isPropertyAccessExpression(thisProperty) && thisProperty.expression.kind == SyntaxKindThisKeyword && forEachChildRecursively(expression, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isMatchingReference */
			/* TODO(Identifier): thisProperty */
			/* TODO(Identifier): n */
		})
	}
	isDeclarationInConstructor := func(expression Expression) /* TODO(undefined): boolean */ TODO {
		thisContainer := getThisContainer(expression, false, false)
		return thisContainer.kind == SyntaxKindConstructor || thisContainer.kind == SyntaxKindFunctionDeclaration || (thisContainer.kind == SyntaxKindFunctionExpression && !isPrototypePropertyAssignment(thisContainer.parent))
	}
	getConstructorDefinedThisAssignmentTypes := func(types []Type, declarations []Declaration) /* TODO(ArrayType): Type[] */ any {
		Debug.assert(types.length == declarations.length)
		return types.filter(func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): boolean | undefined */ TODO {
			declaration := /* TODO(ElementAccessExpression): declarations[i] */ TODO
			expression := /* TODO(ConditionalExpression): isBinaryExpression(declaration) ? declaration :                 isBinaryExpression(declaration.parent) ? declaration.parent : undefined */ TODO
			return expression && isDeclarationInConstructor(expression)
		})
	}
	getTypeFromBindingElement := func(element BindingElement, includePatternInType bool, reportErrors bool) Type {
		if element.initializer {
			contextualType := /* TODO(ConditionalExpression): isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, /*includePatternInType* / true, /*reportErrors* / false) : unknownType */ TODO
			return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, CheckModeNormal, contextualType)))
		}
		if isBindingPattern(element.name) {
			return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors)
		}
		if reportErrors && !declarationBelongsToPrivateAmbientMember(element) {
			reportImplicitAny(element, anyType)
		}
		return /* TODO(ConditionalExpression): includePatternInType ? nonInferrableAnyType : anyType */ TODO
	}
	getTypeFromObjectBindingPattern := func(pattern ObjectBindingPattern, includePatternInType bool, reportErrors bool) Type {
		members := createSymbolTable()
		var stringIndexInfo *IndexInfo
		objectFlags := ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		forEach(pattern.elements, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement */ TODO) {
			name := e.propertyName || e.name /* as */ /* TODO(TypeReference): Identifier */
			if e.dotDotDotToken {
				stringIndexInfo = createIndexInfo(stringType, anyType, false)
				return
			}
			exprType := getLiteralTypeFromPropertyName(name)
			if !isTypeUsableAsPropertyName(exprType) {
				objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
				return
			}
			text := getPropertyNameFromType(exprType)
			flags := SymbolFlagsProperty | ( /* TODO(ConditionalExpression): e.initializer ? SymbolFlags.Optional : 0 */ TODO)
			symbol := createSymbol(flags, text)
			symbol.links.type_ = getTypeFromBindingElement(e, includePatternInType, reportErrors)
			symbol.links.bindingElement = e
			members.set(symbol.escapedName, symbol)
		})
		result := createAnonymousType(nil, members, emptyArray, emptyArray /* TODO(ConditionalExpression): stringIndexInfo ? [stringIndexInfo] : emptyArray */, TODO)
		result.objectFlags |= objectFlags
		if includePatternInType {
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	getTypeFromArrayBindingPattern := func(pattern BindingPattern, includePatternInType bool, reportErrors bool) Type {
		elements := pattern.elements
		lastElement := lastOrUndefined(elements)
		restElement := /* TODO(ConditionalExpression): lastElement && lastElement.kind === SyntaxKind.BindingElement && lastElement.dotDotDotToken ? lastElement : undefined */ TODO
		if elements.length == 0 || elements.length == 1 && restElement {
			return /* TODO(ConditionalExpression): languageVersion >= ScriptTarget.ES2015 ? createIterableType(anyType) : anyArrayType */ TODO
		}
		elementTypes := map_(elements, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(CallExpression): isOmittedExpression(e) */
			/* TODO(QuestionToken): ? */
			/* TODO(Identifier): anyType */
			/* TODO(ColonToken): : */
			/* TODO(CallExpression): getTypeFromBindingElement(e, includePatternInType, reportErrors) */
		})
		minLength := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): findLastIndex(elements, e => !(e === restElement || isOmittedExpression(e) || hasDefaultValue(e)), elements.length - 1) + 1 */ TODO
		elementFlags := map_(elements, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest */ TODO {
			/* TODO(BinaryExpression): e === restElement */
			/* TODO(QuestionToken): ? */
			/* TODO(PropertyAccessExpression): ElementFlags.Rest */
			/* TODO(ColonToken): : */
			/* TODO(ConditionalExpression): i >= minLength ? ElementFlags.Optional : ElementFlags.Required */
		})
		result := createTupleType(elementTypes, elementFlags) /* as */ /* TODO(TypeReference): TypeReference */
		if includePatternInType {
			result = cloneTypeReference(result)
			result.pattern = pattern
			result.objectFlags |= ObjectFlagsContainsObjectOrArrayLiteral
		}
		return result
	}
	getTypeFromBindingPattern := func(pattern BindingPattern, includePatternInType /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Type {
		if includePatternInType {
			/* TODO(CallExpression): contextualBindingPatterns.push(pattern) */
		}
		result := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern             ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors)             : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors) */ TODO
		if includePatternInType {
			/* TODO(CallExpression): contextualBindingPatterns.pop() */
		}
		return result
	}
	getWidenedTypeForVariableLikeDeclaration := func(declaration /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement | JSDocPropertyLikeTag */ any, reportErrors bool) Type {
		return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, true, CheckModeNormal), declaration, reportErrors)
	}
	getTypeFromImportAttributes := func(node ImportAttributes) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			symbol := createSymbol(SymbolFlagsObjectLiteral, InternalSymbolNameImportAttributes)
			members := createSymbolTable()
			forEach(node.elements, func(attr /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ImportAttribute */ TODO) {
				member := createSymbol(SymbolFlagsProperty, getNameFromImportAttribute(attr))
				member.parent = symbol
				member.links.type_ = checkImportAttribute(attr)
				member.links.target = member
				members.set(member.escapedName, member)
			})
			type_ := createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
			type_.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsNonInferrableType
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	isGlobalSymbolConstructor := func(node Node) /* TODO(undefined): boolean | undefined */ TODO {
		symbol := getSymbolOfNode(node)
		globalSymbol := getGlobalESSymbolConstructorTypeSymbol(false)
		return globalSymbol && symbol && symbol == globalSymbol
	}
	widenTypeForVariableLikeDeclaration := func(type_ *Type, declaration /* TODO(AnyKeyword): any */ TODO, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_ {
			if type_.flags&TypeFlagsESSymbol && isGlobalSymbolConstructor(declaration.parent) {
				type_ = getESSymbolLikeTypeForNode(declaration)
			}
			if reportErrors {
				reportErrorsFromWidening(declaration, type_)
			}
			if type_.flags&TypeFlagsUniqueESSymbol && (isBindingElement(declaration) || !declaration.type_) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.symbol !== getSymbolOfDeclaration(declaration) */ TODO {
				type_ = esSymbolType
			}
			return getWidenedType(type_)
		}
		type_ = /* TODO(ConditionalExpression): isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType */ TODO
		if reportErrors {
			if !declarationBelongsToPrivateAmbientMember(declaration) {
				reportImplicitAny(declaration, type_)
			}
		}
		return type_
	}
	declarationBelongsToPrivateAmbientMember := func(declaration VariableLikeDeclaration) /* TODO(undefined): boolean */ TODO {
		root := getRootDeclaration(declaration)
		memberDeclaration := /* TODO(ConditionalExpression): root.kind === SyntaxKind.Parameter ? root.parent : root */ TODO
		return isPrivateWithinAmbient(memberDeclaration)
	}
	tryGetTypeFromEffectiveTypeNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		typeNode := getEffectiveTypeAnnotationNode(node)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
	}
	isParameterOfContextSensitiveSignature := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		decl := symbol.valueDeclaration
		if !decl {
			return false
		}
		if isBindingElement(decl) {
			decl = walkUpBindingElementsAndPatterns(decl)
		}
		if isParameter(decl) {
			return isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent)
		}
		return false
	}
	getTypeOfVariableOrParameterOrProperty := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			type_ := getTypeOfVariableOrParameterOrPropertyWorker(symbol)
			if !links.type_ && !isParameterOfContextSensitiveSignature(symbol) {
				links.type_ = type_
			}
			return type_
		}
		return links.type_
	}
	getTypeOfVariableOrParameterOrPropertyWorker := func(symbol Symbol) Type {
		if symbol.flags & SymbolFlagsPrototype {
			return getTypeOfPrototypeProperty(symbol)
		}
		if symbol == requireSymbol {
			return anyType
		}
		if symbol.flags&SymbolFlagsModuleExports && symbol.valueDeclaration {
			fileSymbol := getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration))
			result := createSymbol(fileSymbol.flags, "exports" /* as */ /* TODO(TypeReference): __String */)
			result.declarations = /* TODO(ConditionalExpression): fileSymbol.declarations ? fileSymbol.declarations.slice() : [] */ TODO
			result.parent = symbol
			result.links.target = fileSymbol
			if fileSymbol.valueDeclaration {
				/* TODO(BinaryExpression): result.valueDeclaration = fileSymbol.valueDeclaration */
			}
			if fileSymbol.members {
				/* TODO(BinaryExpression): result.members = new Map(fileSymbol.members) */
			}
			if fileSymbol.exports {
				/* TODO(BinaryExpression): result.exports = new Map(fileSymbol.exports) */
			}
			members := createSymbolTable()
			members.set("exports" /* as */ /* TODO(TypeReference): __String */, result)
			return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		Debug.assertIsDefined(symbol.valueDeclaration)
		declaration := symbol.valueDeclaration
		if isSourceFile(declaration) && isJsonSourceFile(declaration) {
			if !declaration.statements.length {
				return emptyObjectType
			}
			return getWidenedType(getWidenedLiteralType(checkExpression( /* TODO(ElementAccessExpression): declaration.statements[0] */ TODO.expression)))
		}
		if isAccessor(declaration) {
			return getTypeOfAccessors(symbol)
		}
		if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		var type_ Type
		if declaration.kind == SyntaxKindExportAssignment {
			type_ = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached((declaration /* as */ /* TODO(TypeReference): ExportAssignment */).expression), declaration)
		} else if isBinaryExpression(declaration) || (isInJSFile(declaration) && (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) {
			type_ = getWidenedTypeForAssignmentDeclaration(symbol)
		} else if isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(declaration) || isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || (isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration)) || isMethodSignature(declaration) || isSourceFile(declaration) {
			if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			type_ = /* TODO(ConditionalExpression): isBinaryExpression(declaration.parent) ?                 getWidenedTypeForAssignmentDeclaration(symbol) :                 tryGetTypeFromEffectiveTypeNode(declaration) || anyType */ TODO
		} else if isPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration)
		} else if isJsxAttribute(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration)
		} else if isShorthandPropertyAssignment(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, CheckModeNormal)
		} else if isObjectLiteralMethod(declaration) {
			type_ = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, CheckModeNormal)
		} else if isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(declaration) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(declaration) {
			type_ = getWidenedTypeForVariableLikeDeclaration(declaration, true)
		} else if isEnumDeclaration(declaration) {
			type_ = getTypeOfFuncClassEnumModule(symbol)
		} else if isEnumMember(declaration) {
			type_ = getTypeOfEnumMember(symbol)
		} else {
			return Debug.fail( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol) */ TODO)
		}
		if !popTypeResolution() {
			if symbol.flags&SymbolFlagsValueModule && !(symbol.flags & SymbolFlagsAssignment) {
				return getTypeOfFuncClassEnumModule(symbol)
			}
			return reportCircularityError(symbol)
		}
		return type_
	}
	getAnnotatedAccessorTypeNode := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *TypeNode {
		if accessor {
			/* TODO(SwitchStatement): switch (accessor.kind) {                 case SyntaxKind.GetAccessor:                     const getterTypeAnnotation = getEffectiveReturnTypeNode(accessor);                     return getterTypeAnnotation;                 case SyntaxKind.SetAccessor:                     const setterTypeAnnotation = getEffectiveSetAccessorTypeAnnotationNode(accessor);                     return setterTypeAnnotation;                 case SyntaxKind.PropertyDeclaration:                     Debug.assert(hasAccessorModifier(accessor));                     const accessorTypeAnnotation = getEffectiveTypeAnnotationNode(accessor);                     return accessorTypeAnnotation;             } */
		}
		return nil
	}
	getAnnotatedAccessorType := func(accessor /* TODO(UnionType): AccessorDeclaration | PropertyDeclaration | undefined */ any) *Type {
		node := getAnnotatedAccessorTypeNode(accessor)
		return node && getTypeFromTypeNode(node)
	}
	getAnnotatedAccessorThisParameter := func(accessor AccessorDeclaration) *Symbol {
		parameter := getAccessorThisParameter(accessor)
		return parameter && parameter.symbol
	}
	getThisTypeOfDeclaration := func(declaration SignatureDeclaration) *Type {
		return getThisTypeOfSignature(getSignatureFromDeclaration(declaration))
	}
	getTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
			setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
			accessor := tryCast(getDeclarationOfKind(symbol, SyntaxKindPropertyDeclaration), isAutoAccessorPropertyDeclaration)
			type_ := getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) || getAnnotatedAccessorType(getter) || getAnnotatedAccessorType(setter) || getAnnotatedAccessorType(accessor) || getter && getter.body && getReturnTypeFromBody(getter) || accessor && accessor.initializer && getWidenedTypeForVariableLikeDeclaration(accessor, true)
			if !type_ {
				if setter && !isPrivateWithinAmbient(setter) {
					errorOrSuggestion(noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol))
				} else if getter && !isPrivateWithinAmbient(getter) {
					errorOrSuggestion(noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol))
				} else if accessor && !isPrivateWithinAmbient(accessor) {
					errorOrSuggestion(noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any")
				}
				type_ = anyType
			}
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(getter) {
					error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getAnnotatedAccessorTypeNode(accessor) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				} else if getter && noImplicitAny {
					error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol))
				}
				type_ = anyType
			}
			/* TODO(ExpressionStatement): links.type ??= type; */
		}
		return links.type_
	}
	getWriteTypeOfAccessors := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.writeType {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameWriteType) {
				return errorType
			}
			setter := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getDeclarationOfKind<AccessorDeclaration>(symbol, SyntaxKind.SetAccessor)                 ?? tryCast(getDeclarationOfKind<PropertyDeclaration>(symbol, SyntaxKind.PropertyDeclaration), isAutoAccessorPropertyDeclaration) */ TODO
			writeType := getAnnotatedAccessorType(setter)
			if !popTypeResolution() {
				if getAnnotatedAccessorTypeNode(setter) {
					error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				}
				writeType = anyType
			}
			/* TODO(ExpressionStatement): links.writeType ??= writeType || getTypeOfAccessors(symbol); */
		}
		return links.writeType
	}
	getBaseTypeVariableOfClass := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		baseConstructorType := getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol))
		return /* TODO(ConditionalExpression): baseConstructorType.flags & TypeFlags.TypeVariable ? baseConstructorType :             baseConstructorType.flags & TypeFlags.Intersection ? find((baseConstructorType as IntersectionType).types, t => !!(t.flags & TypeFlags.TypeVariable)) :             undefined */ TODO
	}
	getTypeOfFuncClassEnumModule := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.type_ {
			expando := symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, false)
			if expando {
				merged := mergeJSSymbols(symbol, expando)
				if merged {
					symbol = merged
					links = merged.links
				}
			}
			originalLinks.type_ = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.type = getTypeOfFuncClassEnumModuleWorker(symbol) */ TODO
		}
		return links.type_
	}
	getTypeOfFuncClassEnumModuleWorker := func(symbol Symbol) Type {
		declaration := symbol.valueDeclaration
		if symbol.flags&SymbolFlagsModule && isShorthandAmbientModuleSymbol(symbol) {
			return anyType
		} else if declaration && (declaration.kind == SyntaxKindBinaryExpression || isAccessExpression(declaration) && declaration.parent.kind == SyntaxKindBinaryExpression) {
			return getWidenedTypeForAssignmentDeclaration(symbol)
		} else if symbol.flags&SymbolFlagsValueModule && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator {
			resolvedModule := resolveExternalModuleSymbol(symbol)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): resolvedModule !== symbol */ TODO {
				if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
					return errorType
				}
				exportEquals := getMergedSymbol( /* TODO(NonNullExpression): symbol.exports!.get(InternalSymbolName.ExportEquals)! */ TODO)
				type_ := getWidenedTypeForAssignmentDeclaration(exportEquals /* TODO(ConditionalExpression): exportEquals === resolvedModule ? undefined : resolvedModule */, TODO)
				if !popTypeResolution() {
					return reportCircularityError(symbol)
				}
				return type_
			}
		}
		type_ := createObjectType(ObjectFlagsAnonymous, symbol)
		if symbol.flags & SymbolFlagsClass {
			baseTypeVariable := getBaseTypeVariableOfClass(symbol)
			return /* TODO(ConditionalExpression): baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type */ TODO
		} else {
			return /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional ? getOptionalType(type, /*isProperty* / true) : type */ TODO
		}
	}
	getTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.type = getDeclaredTypeOfEnumMember(symbol) */ TODO)
	}
	getTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				return errorType
			}
			targetSymbol := resolveAlias(symbol)
			exportSymbol := symbol.declarations && getTargetOfAliasDeclaration( /* TODO(NonNullExpression): getDeclarationOfAliasSymbol(symbol)! */ TODO, true)
			declaredType := firstDefined(exportSymbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
				/* TODO(CallExpression): isExportAssignment(d) */
				/* TODO(QuestionToken): ? */
				/* TODO(CallExpression): tryGetTypeFromEffectiveTypeNode(d) */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): undefined */
			})
			/* TODO(ExpressionStatement): links.type ??= exportSymbol?.declarations && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations!.length ? getFlowTypeFromCommonJSExport(exportSymbol)                 : isDuplicatedCommonJSExport(symbol.declarations) ? autoType                 : declaredType ? declaredType                 : getSymbolFlags(targetSymbol) & SymbolFlags.Value ? getTypeOfSymbol(targetSymbol)                 : errorType; */
			if !popTypeResolution() {
				reportCircularityError( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): exportSymbol ?? symbol */ TODO)
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): links.type ??= errorType */ TODO
			}
		}
		return links.type_
	}
	getTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.type_ || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.type = instantiateType(getTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	getWriteTypeOfInstantiatedSymbol := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.writeType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.writeType = instantiateType(getWriteTypeOfSymbol(links.target!), links.mapper) */ TODO)
	}
	reportCircularityError := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		declaration := symbol.valueDeclaration
		if declaration {
			if getEffectiveTypeAnnotationNode(declaration) {
				error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol))
				return errorType
			}
			if noImplicitAny && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.Parameter */ TODO || (declaration /* as */ /* TODO(TypeReference): HasInitializer */).initializer) {
				error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol))
			}
		} else if symbol.flags & SymbolFlagsAlias {
			node := getDeclarationOfAliasSymbol(symbol)
			if node {
				error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol))
			}
		}
		return anyType
	}
	getTypeOfSymbolWithDeferredType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			links.type_ = /* TODO(ConditionalExpression): links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents) */ TODO
		}
		return links.type_
	}
	getWriteTypeOfSymbolWithDeferredType := func(symbol Symbol) *Type {
		links := getSymbolLinks(symbol)
		if !links.writeType && links.deferralWriteConstituents {
			Debug.assertIsDefined(links.deferralParent)
			Debug.assertIsDefined(links.deferralConstituents)
			links.writeType = /* TODO(ConditionalExpression): links.deferralParent.flags & TypeFlags.Union ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents) */ TODO
		}
		return links.writeType
	}
	getWriteTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if symbol.flags & SymbolFlagsProperty {
			return /* TODO(ConditionalExpression): checkFlags & CheckFlags.SyntheticProperty ?                 checkFlags & CheckFlags.DeferredType ?                     getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) :                     // NOTE: cast to TransientSymbol should be safe because only TransientSymbols can have CheckFlags.SyntheticProperty                     (symbol as TransientSymbol).links.writeType || (symbol as TransientSymbol).links.type! :                 removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlags.Optional)) */ TODO
		}
		if symbol.flags & SymbolFlagsAccessor {
			return /* TODO(ConditionalExpression): checkFlags & CheckFlags.Instantiated ?                 getWriteTypeOfInstantiatedSymbol(symbol) :                 getWriteTypeOfAccessors(symbol) */ TODO
		}
		return getTypeOfSymbol(symbol)
	}
	getTypeOfSymbol := func(symbol Symbol) Type {
		checkFlags := getCheckFlags(symbol)
		if checkFlags & CheckFlagsDeferredType {
			return getTypeOfSymbolWithDeferredType(symbol)
		}
		if checkFlags & CheckFlagsInstantiated {
			return getTypeOfInstantiatedSymbol(symbol)
		}
		if checkFlags & CheckFlagsMapped {
			return getTypeOfMappedSymbol(symbol /* as */ /* TODO(TypeReference): MappedSymbol */)
		}
		if checkFlags & CheckFlagsReverseMapped {
			return getTypeOfReverseMappedSymbol(symbol /* as */ /* TODO(TypeReference): ReverseMappedSymbol */)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			return getTypeOfVariableOrParameterOrProperty(symbol)
		}
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsEnum | SymbolFlagsValueModule) {
			return getTypeOfFuncClassEnumModule(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAccessor {
			return getTypeOfAccessors(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getTypeOfAlias(symbol)
		}
		return errorType
	}
	getNonMissingTypeOfSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & SymbolFlagsOptional))
	}
	isReferenceToSomeType := func(type_ Type, targets []Type) /* TODO(undefined): boolean */ TODO {
		if type_ == nil || (getObjectFlags(type_)&ObjectFlagsReference) == 0 {
			return false
		}
		for _, target := range targets {
			if (type_ /* as */ /* TODO(TypeReference): TypeReference */).target == target {
				return true
			}
		}
		return false
	}
	isReferenceToType := func(type_ Type, target Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== undefined */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== undefined */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getObjectFlags(type) & ObjectFlags.Reference) !== 0 */ TODO && (type_ /* as */ /* TODO(TypeReference): TypeReference */).target == target
	}
	getTargetType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target : type */ TODO
	}
	hasBaseType := func(type_ Type, checkBase *Type) /* TODO(undefined): boolean */ TODO {
		return check(type_)
		check := func(type_ Type) bool {
			if getObjectFlags(type_) & (ObjectFlagsClassOrInterface | ObjectFlagsReference) {
				target := getTargetType(type_) /* as */ /* TODO(TypeReference): InterfaceType */
				return target == checkBase || some(getBaseTypes(target), check)
			} else if type_.flags & TypeFlagsIntersection {
				return some((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, check)
			}
			return false
		}
	}
	appendTypeParameters := func(typeParameters /* TODO(ArrayType): TypeParameter[] */ any, declarations []TypeParameterDeclaration) /* TODO(ArrayType): TypeParameter[] */ any {
		for _, declaration := range declarations {
			typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)))
		}
		return typeParameters
	}
	getOuterTypeParameters := func(node Node, includeThisTypes bool) /* TODO(ArrayType): TypeParameter[] */ any {
		/* TODO(WhileStatement): while (true) {             node = node.parent; // TODO: GH#18217 Use SourceFile kind check instead             if (node && isBinaryExpression(node)) {                 // prototype assignments get the outer type parameters of their constructor function                 const assignmentKind = getAssignmentDeclarationKind(node);                 if (assignmentKind === AssignmentDeclarationKind.Prototype || assignmentKind === AssignmentDeclarationKind.PrototypeProperty) {                     const symbol = getSymbolOfDeclaration(node.left as BindableStaticNameExpression | PropertyAssignment);                     if (symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, d => node === d)) {                         node = symbol.parent.valueDeclaration!;                     }                 }             }             if (!node) {                 return undefined;             }             const kind = node.kind;             switch (kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.CallSignature:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.MethodSignature:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.JSDocFunctionType:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.JSDocTemplateTag:                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocEnumTag:                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.MappedType:                 case SyntaxKind.ConditionalType: {                     const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);                     if ((kind === SyntaxKind.FunctionExpression || kind === SyntaxKind.ArrowFunction || isObjectLiteralMethod(node)) && isContextSensitive(node as Expression | MethodDeclaration)) {                         const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node as FunctionLikeDeclaration)), SignatureKind.Call));                         if (signature && signature.typeParameters) {                             return [...(outerTypeParameters || emptyArray), ...signature.typeParameters];                         }                     }                     if (kind === SyntaxKind.MappedType) {                         return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration((node as MappedTypeNode).typeParameter)));                     }                     else if (kind === SyntaxKind.ConditionalType) {                         return concatenate(outerTypeParameters, getInferTypeParameters(node as ConditionalTypeNode));                     }                     const outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node as DeclarationWithTypeParameters));                     const thisType = includeThisTypes &&                         (kind === SyntaxKind.ClassDeclaration || kind === SyntaxKind.ClassExpression || kind === SyntaxKind.InterfaceDeclaration || isJSConstructor(node)) &&                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node as ClassLikeDeclaration | InterfaceDeclaration)).thisType;                     return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;                 }                 case SyntaxKind.JSDocParameterTag:                     const paramSymbol = getParameterSymbolFromJSDoc(node as JSDocParameterTag);                     if (paramSymbol) {                         node = paramSymbol.valueDeclaration!;                     }                     break;                 case SyntaxKind.JSDoc: {                     const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);                     return (node as JSDoc).tags                         ? appendTypeParameters(outerTypeParameters, flatMap((node as JSDoc).tags, t => isJSDocTemplateTag(t) ? t.typeParameters : undefined))                         : outerTypeParameters;                 }             }         } */
	}
	getOuterTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		declaration := /* TODO(ConditionalExpression): (symbol.flags & SymbolFlags.Class || symbol.flags & SymbolFlags.Function)             ? symbol.valueDeclaration             : symbol.declarations?.find(decl => {                 if (decl.kind === SyntaxKind.InterfaceDeclaration) {                     return true;                 }                 if (decl.kind !== SyntaxKind.VariableDeclaration) {                     return false;                 }                 const initializer = (decl as VariableDeclaration).initializer;                 return !!initializer && (initializer.kind === SyntaxKind.FunctionExpression || initializer.kind === SyntaxKind.ArrowFunction);             })! */ TODO
		Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations")
		return getOuterTypeParameters(declaration)
	}
	getLocalTypeParametersOfClassOrInterfaceOrTypeAlias := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		if !symbol.declarations {
			return
		}
		var result /* TODO(ArrayType): TypeParameter[] */ any
		for _, node := range symbol.declarations {
			if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression || isJSConstructor(node) || isTypeAlias(node) {
				declaration := node /* as */ /* TODO(UnionType): InterfaceDeclaration | TypeAliasDeclaration | JSDocTypedefTag | JSDocCallbackTag */
				result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration))
			}
		}
		return result
	}
	getTypeParametersOfClassOrInterface := func(symbol Symbol) /* TODO(ArrayType): TypeParameter[] */ any {
		return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol))
	}
	isMixinConstructorType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length == 1 {
			s := /* TODO(ElementAccessExpression): signatures[0] */ TODO
			if !s.typeParameters && s.parameters.length == 1 && signatureHasRestParameter(s) {
				paramType := getTypeOfParameter( /* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
				return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) == anyType
			}
		}
		return false
	}
	isConstructorType := func(type_ Type) bool {
		if getSignaturesOfType(type_, SignatureKindConstruct).length > 0 {
			return true
		}
		if type_.flags & TypeFlagsTypeVariable {
			constraint := getBaseConstraintOfType(type_)
			return !!constraint && isMixinConstructorType(constraint)
		}
		return false
	}
	getBaseTypeNodeOfClass := func(type_ InterfaceType) *ExpressionWithTypeArguments {
		decl := getClassLikeDeclarationOfSymbol(type_.symbol)
		return decl && getEffectiveBaseTypeNode(decl)
	}
	getConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
		typeArgCount := length(typeArgumentNodes)
		isJavascript := isInJSFile(location)
		return filter(getSignaturesOfType(type_, SignatureKindConstruct), func(sig /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(ParenthesizedExpression): (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(BinaryExpression): typeArgCount <= length(sig.typeParameters) */
		})
	}
	getInstantiatedConstructorsForTypeArguments := func(type_ Type, typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any, location Node) []Signature {
		signatures := getConstructorsForTypeArguments(type_, typeArgumentNodes, location)
		typeArguments := map_(typeArgumentNodes, getTypeFromTypeNode)
		return sameMap(signatures, func(sig /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
			/* TODO(CallExpression): some(sig.typeParameters) */
			/* TODO(QuestionToken): ? */
			/* TODO(CallExpression): getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): sig */
		})
	}
	getBaseConstructorTypeOfClass := func(type_ InterfaceType) Type {
		if !type_.resolvedBaseConstructorType {
			decl := getClassLikeDeclarationOfSymbol(type_.symbol)
			extended := decl && getEffectiveBaseTypeNode(decl)
			baseTypeNode := getBaseTypeNodeOfClass(type_)
			if !baseTypeNode {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType = undefinedType */ TODO
			}
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseConstructorType) {
				return errorType
			}
			baseConstructorType := checkExpression(baseTypeNode.expression)
			if extended && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseTypeNode !== extended */ TODO {
				Debug.assert(!extended.typeArguments)
				checkExpression(extended.expression)
			}
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection) {
				resolveStructuredTypeMembers(baseConstructorType /* as */ /* TODO(TypeReference): ObjectType */)
			}
			if !popTypeResolution() {
				error(type_.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type_.symbol))
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			if !(baseConstructorType.flags & TypeFlagsAny) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseConstructorType !== nullWideningType */ TODO && !isConstructorType(baseConstructorType) {
				err := error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType))
				if baseConstructorType.flags & TypeFlagsTypeParameter {
					constraint := getConstraintFromTypeParameter(baseConstructorType)
					var ctorReturn Type = unknownType
					if constraint {
						ctorSig := getSignaturesOfType(constraint, SignatureKindConstruct)
						if /* TODO(ElementAccessExpression): ctorSig[0] */ TODO {
							ctorReturn = getReturnTypeOfSignature( /* TODO(ElementAccessExpression): ctorSig[0] */ TODO)
						}
					}
					if baseConstructorType.symbol.declarations {
						addRelatedInfo(err, createDiagnosticForNode( /* TODO(ElementAccessExpression): baseConstructorType.symbol.declarations[0] */ TODO, Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)))
					}
				}
				return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): type.resolvedBaseConstructorType ??= errorType */ TODO
			}
			/* TODO(ExpressionStatement): type.resolvedBaseConstructorType ??= baseConstructorType; */
		}
		return type_.resolvedBaseConstructorType
	}
	getImplementsTypes := func(type_ InterfaceType) []BaseType {
		var resolvedImplementsTypes []BaseType = emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				implementsTypeNodes := getEffectiveImplementsTypeNodes(declaration /* as */ /* TODO(TypeReference): ClassLikeDeclaration */)
				if !implementsTypeNodes {
				}
				for _, node := range implementsTypeNodes {
					implementsType := getTypeFromTypeNode(node)
					if !isErrorType(implementsType) {
						if resolvedImplementsTypes == emptyArray {
							resolvedImplementsTypes = /* TODO(ArrayLiteralExpression): [implementsType as ObjectType] */ TODO
						} else {
							resolvedImplementsTypes.push(implementsType)
						}
					}
				}
			}
		}
		return resolvedImplementsTypes
	}
	reportCircularBaseType := func(node Node, type_ Type) {
		error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType))
	}
	getBaseTypes := func(type_ InterfaceType) []BaseType {
		if !type_.baseTypesResolved {
			if pushTypeResolution(type_, TypeSystemPropertyNameResolvedBaseTypes) {
				if type_.objectFlags & ObjectFlagsTuple {
					type_.resolvedBaseTypes = /* TODO(ArrayLiteralExpression): [getTupleBaseType(type as TupleType)] */ TODO
				} else if type_.symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
					if type_.symbol.flags & SymbolFlagsClass {
						resolveBaseTypesOfClass(type_)
					}
					if type_.symbol.flags & SymbolFlagsInterface {
						resolveBaseTypesOfInterface(type_)
					}
				} else {
					Debug.fail("type must be class or interface")
				}
				if !popTypeResolution() && type_.symbol.declarations {
					for _, declaration := range type_.symbol.declarations {
						if declaration.kind == SyntaxKindClassDeclaration || declaration.kind == SyntaxKindInterfaceDeclaration {
							reportCircularBaseType(declaration, type_)
						}
					}
				}
			}
			type_.baseTypesResolved = true
		}
		return type_.resolvedBaseTypes
	}
	getTupleBaseType := func(type_ TupleType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		elementTypes := sameMap(type_.typeParameters, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(BinaryExpression): type.elementFlags[i] & ElementFlags.Variadic */
			/* TODO(QuestionToken): ? */
			/* TODO(CallExpression): getIndexedAccessType(t, numberType) */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): t */
		})
		return createArrayType(getUnionType(elementTypes || emptyArray), type_.readonly)
	}
	resolveBaseTypesOfClass := func(type_ InterfaceType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BaseType[] */ TODO {
		type_.resolvedBaseTypes = resolvingEmptyArray
		baseConstructorType := getApparentType(getBaseConstructorTypeOfClass(type_))
		if !(baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsAny)) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		baseTypeNode := /* TODO(NonNullExpression): getBaseTypeNodeOfClass(type)! */ TODO
		var baseType Type
		originalBaseType := /* TODO(ConditionalExpression): baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : undefined */ TODO
		if baseConstructorType.symbol && baseConstructorType.symbol.flags&SymbolFlagsClass && areAllOuterTypeParametersApplied( /* TODO(NonNullExpression): originalBaseType! */ TODO) {
			baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol)
		} else if baseConstructorType.flags & TypeFlagsAny {
			baseType = baseConstructorType
		} else {
			constructors := getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode)
			if !constructors.length {
				error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments)
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
			}
			baseType = getReturnTypeOfSignature( /* TODO(ElementAccessExpression): constructors[0] */ TODO)
		}
		if isErrorType(baseType) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		reducedBaseType := getReducedType(baseType)
		if !isValidBaseType(reducedBaseType) {
			elaboration := elaborateNeverIntersection(nil, baseType)
			diagnostic := chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType))
			diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic))
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		if type_ == reducedBaseType || hasBaseType(reducedBaseType, type_) {
			error(type_.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType))
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = emptyArray */ TODO
		}
		if type_.resolvedBaseTypes == resolvingEmptyArray {
			type_.members = nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseTypes = [reducedBaseType] */ TODO
	}
	areAllOuterTypeParametersApplied := func(type_ Type) bool {
		outerTypeParameters := (type_ /* as */ /* TODO(TypeReference): InterfaceType */).outerTypeParameters
		if outerTypeParameters {
			last := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): outerTypeParameters.length - 1 */ TODO
			typeArguments := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
			return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): outerTypeParameters[last].symbol !== typeArguments[last].symbol */ TODO
		}
		return true
	}
	isValidBaseType := func(type_ Type) /* TODO(TypePredicate): type is BaseType */ TODO {
		if type_.flags & TypeFlagsTypeParameter {
			constraint := getBaseConstraintOfType(type_)
			if constraint {
				return isValidBaseType(constraint)
			}
		}
		return !!(type_.flags&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsAny) && !isGenericMappedType(type_) || type_.flags&TypeFlagsIntersection && every((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isValidBaseType))
	}
	resolveBaseTypesOfInterface := func(type_ InterfaceType) {
		type_.resolvedBaseTypes = type_.resolvedBaseTypes || emptyArray
		if type_.symbol.declarations {
			for _, declaration := range type_.symbol.declarations {
				if declaration.kind == SyntaxKindInterfaceDeclaration && getInterfaceBaseTypeNodes(declaration /* as */ /* TODO(TypeReference): InterfaceDeclaration */) {
					for _, node := range /* TODO(NonNullExpression): getInterfaceBaseTypeNodes(declaration as InterfaceDeclaration)! */ TODO {
						baseType := getReducedType(getTypeFromTypeNode(node))
						if !isErrorType(baseType) {
							if isValidBaseType(baseType) {
								if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== baseType */ TODO && !hasBaseType(baseType, type_) {
									if type_.resolvedBaseTypes == emptyArray {
										type_.resolvedBaseTypes = /* TODO(ArrayLiteralExpression): [baseType as ObjectType] */ TODO
									} else {
										type_.resolvedBaseTypes.push(baseType)
									}
								} else {
									reportCircularBaseType(declaration, type_)
								}
							} else {
								error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members)
							}
						}
					}
				}
			}
		}
	}
	isThislessInterface := func(symbol Symbol) bool {
		if !symbol.declarations {
			return true
		}
		for _, declaration := range symbol.declarations {
			if declaration.kind == SyntaxKindInterfaceDeclaration {
				if declaration.flags & NodeFlagsContainsThis {
					return false
				}
				baseTypeNodes := getInterfaceBaseTypeNodes(declaration /* as */ /* TODO(TypeReference): InterfaceDeclaration */)
				if baseTypeNodes {
					for _, node := range baseTypeNodes {
						if isEntityNameExpression(node.expression) {
							baseSymbol := resolveEntityName(node.expression, SymbolFlagsType, true)
							if !baseSymbol || !(baseSymbol.flags & SymbolFlagsInterface) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType {
								return false
							}
						}
					}
				}
			}
		}
		return true
	}
	getDeclaredTypeOfClassOrInterface := func(symbol Symbol) InterfaceType {
		links := getSymbolLinks(symbol)
		originalLinks := links
		if !links.declaredType {
			kind := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Class ? ObjectFlags.Class : ObjectFlags.Interface */ TODO
			merged := mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration))
			if merged {
				symbol = merged
				links = merged.links
			}
			type_ := /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol) as InterfaceType */ TODO
			outerTypeParameters := getOuterTypeParametersOfClassOrInterface(symbol)
			localTypeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
			if outerTypeParameters || localTypeParameters || kind == ObjectFlagsClass || !isThislessInterface(symbol) {
				type_.objectFlags |= ObjectFlagsReference
				type_.typeParameters = concatenate(outerTypeParameters, localTypeParameters)
				type_.outerTypeParameters = outerTypeParameters
				type_.localTypeParameters = localTypeParameters
				(type_ /* as */ /* TODO(TypeReference): GenericType */).instantiations = /* TODO(NewExpression): new Map<string, TypeReference>() */ TODO
				(type_ /* as */ /* TODO(TypeReference): GenericType */).instantiations.set(getTypeListId(type_.typeParameters), type_ /* as */ /* TODO(TypeReference): GenericType */)
				(type_ /* as */ /* TODO(TypeReference): GenericType */).target = type_ /* as */ /* TODO(TypeReference): GenericType */
				(type_ /* as */ /* TODO(TypeReference): GenericType */).resolvedTypeArguments = type_.typeParameters
				type_.thisType = createTypeParameter(symbol)
				type_.thisType.isThisType = true
				type_.thisType.constraint = type_
			}
		}
		return links.declaredType /* as */ /* TODO(TypeReference): InterfaceType */
	}
	getDeclaredTypeOfTypeAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			if !pushTypeResolution(symbol, TypeSystemPropertyNameDeclaredType) {
				return errorType
			}
			declaration := Debug.checkDefined(symbol.declarations.find(isTypeAlias), "Type alias symbol with no valid declaration found")
			typeNode := /* TODO(ConditionalExpression): isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type */ TODO
			type_ := /* TODO(ConditionalExpression): typeNode ? getTypeFromTypeNode(typeNode) : errorType */ TODO
			if popTypeResolution() {
				typeParameters := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol)
				if typeParameters {
					links.typeParameters = typeParameters
					links.instantiations = /* TODO(NewExpression): new Map<string, Type>() */ TODO
					links.instantiations.set(getTypeListId(typeParameters), type_)
				}
				if type_ == intrinsicMarkerType && symbol.escapedName == "BuiltinIteratorReturn" {
					type_ = getBuiltinIteratorReturnType()
				}
			} else {
				type_ = errorType
				if declaration.kind == SyntaxKindJSDocEnumTag {
					error(declaration.typeExpression.type_, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				} else {
					error( /* TODO(ConditionalExpression): isNamedDeclaration(declaration) ? declaration.name || declaration : declaration */ TODO, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol))
				}
			}
			/* TODO(ExpressionStatement): links.declaredType ??= type; */
		}
		return links.declaredType
	}
	getBaseTypeOfEnumLikeType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && type.symbol.flags & SymbolFlags.EnumMember ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)!) : type */ TODO
	}
	getDeclaredTypeOfEnum := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			var memberTypeList []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			if symbol.declarations {
				for _, declaration := range symbol.declarations {
					if declaration.kind == SyntaxKindEnumDeclaration {
						for _, member := range (declaration /* as */ /* TODO(TypeReference): EnumDeclaration */).members {
							if hasBindableName(member) {
								memberSymbol := getSymbolOfDeclaration(member)
								value := getEnumMemberValue(member).value
								memberType := getFreshTypeOfLiteralType( /* TODO(ConditionalExpression): value !== undefined ?                                         getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) :                                         createComputedEnumType(memberSymbol) */ TODO)
								getSymbolLinks(memberSymbol).declaredType = memberType
								memberTypeList.push(getRegularTypeOfLiteralType(memberType))
							}
						}
					}
				}
			}
			enumType := /* TODO(ConditionalExpression): memberTypeList.length ?                 getUnionType(memberTypeList, UnionReduction.Literal, symbol, /*aliasTypeArguments* / undefined) :                 createComputedEnumType(symbol) */ TODO
			if enumType.flags & TypeFlagsUnion {
				enumType.flags |= TypeFlagsEnumLiteral
				enumType.symbol = symbol
			}
			links.declaredType = enumType
		}
		return links.declaredType
	}
	createComputedEnumType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EnumType */ TODO {
		regularType := createTypeWithSymbol(TypeFlagsEnum, symbol) /* as */ /* TODO(TypeReference): EnumType */
		freshType := createTypeWithSymbol(TypeFlagsEnum, symbol)   /* as */ /* TODO(TypeReference): EnumType */
		regularType.regularType = regularType
		regularType.freshType = freshType
		freshType.regularType = regularType
		freshType.freshType = freshType
		return regularType
	}
	getDeclaredTypeOfEnumMember := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		if !links.declaredType {
			enumType := getDeclaredTypeOfEnum( /* TODO(NonNullExpression): getParentOfSymbol(symbol)! */ TODO)
			if !links.declaredType {
				links.declaredType = enumType
			}
		}
		return links.declaredType
	}
	getDeclaredTypeOfTypeParameter := func(symbol Symbol) TypeParameter {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.declaredType = createTypeParameter(symbol) */ TODO)
	}
	getDeclaredTypeOfAlias := func(symbol Symbol) Type {
		links := getSymbolLinks(symbol)
		return links.declaredType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)) */ TODO)
	}
	getDeclaredTypeOfSymbol := func(symbol Symbol) Type {
		return tryGetDeclaredTypeOfSymbol(symbol) || errorType
	}
	tryGetDeclaredTypeOfSymbol := func(symbol Symbol) *Type {
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getDeclaredTypeOfClassOrInterface(symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getDeclaredTypeOfTypeAlias(symbol)
		}
		if symbol.flags & SymbolFlagsTypeParameter {
			return getDeclaredTypeOfTypeParameter(symbol)
		}
		if symbol.flags & SymbolFlagsEnum {
			return getDeclaredTypeOfEnum(symbol)
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return getDeclaredTypeOfEnumMember(symbol)
		}
		if symbol.flags & SymbolFlagsAlias {
			return getDeclaredTypeOfAlias(symbol)
		}
		return nil
	}
	isThislessType := func(node TypeNode) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AnyKeyword:             case SyntaxKind.UnknownKeyword:             case SyntaxKind.StringKeyword:             case SyntaxKind.NumberKeyword:             case SyntaxKind.BigIntKeyword:             case SyntaxKind.BooleanKeyword:             case SyntaxKind.SymbolKeyword:             case SyntaxKind.ObjectKeyword:             case SyntaxKind.VoidKeyword:             case SyntaxKind.UndefinedKeyword:             case SyntaxKind.NeverKeyword:             case SyntaxKind.LiteralType:                 return true;             case SyntaxKind.ArrayType:                 return isThislessType((node as ArrayTypeNode).elementType);             case SyntaxKind.TypeReference:                 return !(node as TypeReferenceNode).typeArguments || (node as TypeReferenceNode).typeArguments!.every(isThislessType);         } */
		return false
	}
	isThislessTypeParameter := func(node TypeParameterDeclaration) /* TODO(undefined): boolean */ TODO {
		constraint := getEffectiveConstraintOfTypeParameter(node)
		return !constraint || isThislessType(constraint)
	}
	isThislessVariableLikeDeclaration := func(node VariableLikeDeclaration) bool {
		typeNode := getEffectiveTypeAnnotationNode(node)
		return /* TODO(ConditionalExpression): typeNode ? isThislessType(typeNode) : !hasInitializer(node) */ TODO
	}
	isThislessFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		returnType := getEffectiveReturnTypeNode(node)
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		return (node.kind == SyntaxKindConstructor || (!!returnType && isThislessType(returnType))) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(isThislessTypeParameter)
	}
	isThisless := func(symbol Symbol) bool {
		if symbol.declarations && symbol.declarations.length == 1 {
			declaration := /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO
			if declaration {
				/* TODO(SwitchStatement): switch (declaration.kind) {                     case SyntaxKind.PropertyDeclaration:                     case SyntaxKind.PropertySignature:                         return isThislessVariableLikeDeclaration(declaration as VariableLikeDeclaration);                     case SyntaxKind.MethodDeclaration:                     case SyntaxKind.MethodSignature:                     case SyntaxKind.Constructor:                     case SyntaxKind.GetAccessor:                     case SyntaxKind.SetAccessor:                         return isThislessFunctionLikeDeclaration(declaration as FunctionLikeDeclaration | AccessorDeclaration);                 } */
			}
		}
		return false
	}
	createInstantiatedSymbolTable := func(symbols []Symbol, mapper TypeMapper, mappingThisOnly bool) SymbolTable {
		result := createSymbolTable()
		for _, symbol := range symbols {
			result.set(symbol.escapedName /* TODO(ConditionalExpression): mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper) */, TODO)
		}
		return result
	}
	addInheritedMembers := func(symbols SymbolTable, baseSymbols []Symbol) {
		for _, base := range baseSymbols {
			if isStaticPrivateIdentifierProperty(base) {
				/* TODO(ContinueStatement): continue; */
			}
			derived := symbols.get(base.escapedName)
			if !derived || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration) && !isConstructorDeclaredProperty(derived) && !getContainingClassStaticBlock(derived.valueDeclaration) {
				symbols.set(base.escapedName, base)
				symbols.set(base.escapedName, base)
			}
		}
	}
	isStaticPrivateIdentifierProperty := func(s Symbol) bool {
		return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration)
	}
	resolveDeclaredMembers := func(type_ InterfaceType) InterfaceTypeWithDeclaredMembers {
		if !(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredProperties {
			symbol := type_.symbol
			members := getMembersOfSymbol(symbol)
			(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredProperties = getNamedMembers(members)
			(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredCallSignatures = emptyArray
			(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredConstructSignatures = emptyArray
			(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredIndexInfos = emptyArray
			(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredCallSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredConstructSignatures = getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			(type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */).declaredIndexInfos = getIndexInfosOfSymbol(symbol)
		}
		return type_ /* as */ /* TODO(TypeReference): InterfaceTypeWithDeclaredMembers */
	}
	isLateBindableName := func(node DeclarationName) /* TODO(TypePredicate): node is LateBoundName */ TODO {
		if !isComputedPropertyName(node) && !isElementAccessExpression(node) {
			return false
		}
		expr := /* TODO(ConditionalExpression): isComputedPropertyName(node) ? node.expression : node.argumentExpression */ TODO
		return isEntityNameExpression(expr) && isTypeUsableAsPropertyName( /* TODO(ConditionalExpression): isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr) */ TODO)
	}
	isLateBoundName := func(name __String) bool {
		return (name /* as */ /* TODO(StringKeyword): string */).charCodeAt(0) == CharacterCodes_ && (name /* as */ /* TODO(StringKeyword): string */).charCodeAt(1) == CharacterCodes_ && (name /* as */ /* TODO(StringKeyword): string */).charCodeAt(2) == CharacterCodesat
	}
	hasLateBindableName := func(node Declaration) /* TODO(TypePredicate): node is LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ TODO {
		name := getNameOfDeclaration(node)
		return !!name && isLateBindableName(name)
	}
	hasBindableName := func(node Declaration) /* TODO(undefined): boolean */ TODO {
		return !hasDynamicName(node) || hasLateBindableName(node)
	}
	isNonBindableDynamicName := func(node DeclarationName) /* TODO(undefined): boolean */ TODO {
		return isDynamicName(node) && !isLateBindableName(node)
	}
	addDeclarationToLateBoundSymbol := func(symbol Symbol, member /* TODO(UnionType): LateBoundDeclaration | BinaryExpression */ any, symbolFlags SymbolFlags) {
		Debug.assert(!!(getCheckFlags(symbol) & CheckFlagsLate), "Expected a late-bound symbol.")
		symbol.flags |= symbolFlags
		getSymbolLinks(member.symbol).lateSymbol = symbol
		if !symbol.declarations {
			symbol.declarations = /* TODO(ArrayLiteralExpression): [member] */ TODO
		} else if !member.symbol.isReplaceableByMethod {
			symbol.declarations.push(member)
		}
		if symbolFlags & SymbolFlagsValue {
			if !symbol.valueDeclaration || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol.valueDeclaration.kind !== member.kind */ TODO {
				symbol.valueDeclaration = member
			}
		}
	}
	lateBindMember := func(parent Symbol, earlySymbols *SymbolTable, lateSymbols Map[__String, TransientSymbol], decl /* TODO(UnionType): LateBoundDeclaration | LateBoundBinaryExpressionDeclaration */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		Debug.assert(!!decl.symbol, "The member is expected to have a symbol.")
		links := getNodeLinks(decl)
		if !links.resolvedSymbol {
			links.resolvedSymbol = decl.symbol
			declName := /* TODO(ConditionalExpression): isBinaryExpression(decl) ? decl.left : decl.name */ TODO
			type_ := /* TODO(ConditionalExpression): isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName) */ TODO
			if isTypeUsableAsPropertyName(type_) {
				memberName := getPropertyNameFromType(type_)
				symbolFlags := decl.symbol.flags
				lateSymbol := lateSymbols.get(memberName)
				if !lateSymbol {
					/* TODO(CallExpression): lateSymbols.set(memberName, lateSymbol = createSymbol(SymbolFlags.None, memberName, CheckFlags.Late)) */
				}
				earlySymbol := earlySymbols && earlySymbols.get(memberName)
				if !(parent.flags & SymbolFlagsClass) && lateSymbol.flags&getExcludedSymbolFlags(symbolFlags) {
					declarations := /* TODO(ConditionalExpression): earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations */ TODO
					name := !(type_.flags&TypeFlagsUniqueESSymbol) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName)
					forEach(declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
						/* TODO(Identifier): error */
						/* TODO(BinaryExpression): getNameOfDeclaration(declaration) || declaration */
						/* TODO(PropertyAccessExpression): Diagnostics.Property_0_was_also_declared_here */
						/* TODO(Identifier): name */
					})
					error(declName || decl, Diagnostics.Duplicate_property_0, name)
					lateSymbol = createSymbol(SymbolFlagsNone, memberName, CheckFlagsLate)
				}
				lateSymbol.links.nameType = type_
				addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags)
				if lateSymbol.parent {
					Debug.assert(lateSymbol.parent == parent, "Existing symbol parent should match new one")
				} else {
					lateSymbol.parent = parent
				}
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = lateSymbol */ TODO
			}
		}
		return links.resolvedSymbol
	}
	getResolvedMembersOrExportsOfSymbol := func(symbol Symbol, resolutionKind MembersOrExportsResolutionKind) Map[__String, Symbol] {
		links := getSymbolLinks(symbol)
		if ! /* TODO(ElementAccessExpression): links[resolutionKind] */ TODO {
			isStatic := resolutionKind == MembersOrExportsResolutionKindresolvedExports
			earlySymbols := /* TODO(ConditionalExpression): !isStatic ? symbol.members :                 symbol.flags & SymbolFlags.Module ? getExportsOfModuleWorker(symbol).exports :                 symbol.exports */ TODO
			/* TODO(ElementAccessExpression): links[resolutionKind] */ TODO = earlySymbols || emptySymbols
			lateSymbols := createSymbolTable() /* as */ /* TODO(TypeReference): Map<__String, TransientSymbol> */
			for _, decl := range symbol.declarations || emptyArray {
				members := getMembersOfDeclaration(decl)
				if members {
					for _, member := range members {
						if isStatic == hasStaticModifier(member) {
							if hasLateBindableName(member) {
								lateBindMember(symbol, earlySymbols, lateSymbols, member)
							}
						}
					}
				}
			}
			assignments := getFunctionExpressionParentSymbolOrSymbol(symbol).assignmentDeclarationMembers
			if assignments {
				decls := arrayFrom(assignments.values())
				for _, member := range decls {
					assignmentKind := getAssignmentDeclarationKind(member /* as */ /* TODO(UnionType): BinaryExpression | CallExpression */)
					isInstanceMember := assignmentKind == AssignmentDeclarationKindPrototypeProperty || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind == AssignmentDeclarationKindObjectDefinePrototypeProperty || assignmentKind == AssignmentDeclarationKindPrototype
					if isStatic == !isInstanceMember {
						if hasLateBindableName(member) {
							lateBindMember(symbol, earlySymbols, lateSymbols, member)
						}
					}
				}
			}
			resolved := combineSymbolTables(earlySymbols, lateSymbols)
			if symbol.flags&SymbolFlagsTransient && links.cjsExportMerged && symbol.declarations {
				for _, decl := range symbol.declarations {
					original := /* TODO(ElementAccessExpression): getSymbolLinks(decl.symbol)[resolutionKind] */ TODO
					if !resolved {
						resolved = original
						/* TODO(ContinueStatement): continue; */
					}
					if !original {
					}
					original.forEach(func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, name /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
						existing := /* TODO(NonNullExpression): resolved! */ TODO.get(name)
						if !existing {
							/* TODO(CallExpression): resolved!.set(name, s) */
						} else if existing == s {
						} else {
							/* TODO(CallExpression): resolved!.set(name, mergeSymbol(existing, s)) */
						}
					})
				}
			}
			/* TODO(ElementAccessExpression): links[resolutionKind] */ TODO = resolved || emptySymbols
		}
		return /* TODO(ElementAccessExpression): links[resolutionKind] */ TODO
	}
	getMembersOfSymbol := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
		return /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.LateBindingContainer             ? getResolvedMembersOrExportsOfSymbol(symbol, MembersOrExportsResolutionKind.resolvedMembers)             : symbol.members || emptySymbols */ TODO
	}
	getLateBoundSymbol := func(symbol Symbol) Symbol {
		if symbol.flags&SymbolFlagsClassMember && symbol.escapedName == InternalSymbolNameComputed {
			links := getSymbolLinks(symbol)
			if !links.lateSymbol && some(symbol.declarations, hasLateBindableName) {
				parent := /* TODO(NonNullExpression): getMergedSymbol(symbol.parent)! */ TODO
				if some(symbol.declarations, hasStaticModifier) {
					getExportsOfSymbol(parent)
				} else {
					getMembersOfSymbol(parent)
				}
			}
			return links.lateSymbol || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.lateSymbol = symbol */ TODO)
		}
		return symbol
	}
	getTypeWithThisArgument := func(type_ Type, thisArgument Type, needApparentType bool) Type {
		if getObjectFlags(type_) & ObjectFlagsReference {
			target := (type_ /* as */ /* TODO(TypeReference): TypeReference */).target
			typeArguments := getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)
			return /* TODO(ConditionalExpression): length(target.typeParameters) === length(typeArguments) ? createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType!])) : type */ TODO
		} else if type_.flags & TypeFlagsIntersection {
			types := sameMap((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getTypeWithThisArgument */
				/* TODO(Identifier): t */
				/* TODO(Identifier): thisArgument */
				/* TODO(Identifier): needApparentType */
			})
			return /* TODO(ConditionalExpression): types !== (type as IntersectionType).types ? getIntersectionType(types) : type */ TODO
		}
		return /* TODO(ConditionalExpression): needApparentType ? getApparentType(type) : type */ TODO
	}
	resolveObjectTypeMembers := func(type_ ObjectType, source InterfaceTypeWithDeclaredMembers, typeParameters []TypeParameter, typeArguments []Type) {
		var mapper *TypeMapper
		var members SymbolTable
		var callSignatures []Signature
		var constructSignatures []Signature
		var indexInfos []IndexInfo
		if rangeEquals(typeParameters, typeArguments, 0, typeParameters.length) {
			members = /* TODO(ConditionalExpression): source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties) */ TODO
			callSignatures = source.declaredCallSignatures
			constructSignatures = source.declaredConstructSignatures
			indexInfos = source.declaredIndexInfos
		} else {
			mapper = createTypeMapper(typeParameters, typeArguments)
			members = createInstantiatedSymbolTable(source.declaredProperties, mapper, typeParameters.length == 1)
			callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper)
			constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper)
			indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper)
		}
		baseTypes := getBaseTypes(source)
		if baseTypes.length {
			if source.symbol && members == getMembersOfSymbol(source.symbol) {
				symbolTable := createSymbolTable(source.declaredProperties)
				sourceIndex := getIndexSymbol(source.symbol)
				if sourceIndex {
					symbolTable.set(InternalSymbolNameIndex, sourceIndex)
				}
				members = symbolTable
			}
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			thisArgument := lastOrUndefined(typeArguments)
			for _, baseType := range baseTypes {
				instantiatedBaseType := /* TODO(ConditionalExpression): thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType */ TODO
				addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType))
				callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindCall))
				constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, SignatureKindConstruct))
				inheritedIndexInfos := /* TODO(ConditionalExpression): instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, /*isReadonly* / false)] */ TODO
				indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): findIndexInfo(indexInfos, info.keyType) */
				}))
			}
		}
		setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
	}
	resolveClassOrInterfaceMembers := func(type_ InterfaceType) {
		resolveObjectTypeMembers(type_, resolveDeclaredMembers(type_), emptyArray, emptyArray)
	}
	resolveTypeReferenceMembers := func(type_ TypeReference) {
		source := resolveDeclaredMembers(type_.target)
		typeParameters := concatenate( /* TODO(NonNullExpression): source.typeParameters! */ TODO /* TODO(ArrayLiteralExpression): [source.thisType!] */, TODO)
		typeArguments := getTypeArguments(type_)
		paddedTypeArguments := /* TODO(ConditionalExpression): typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]) */ TODO
		resolveObjectTypeMembers(type_, source, typeParameters, paddedTypeArguments)
	}
	createSignature := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature | undefined */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, resolvedReturnType *Type, resolvedTypePredicate *TypePredicate, minArgumentCount number, flags SignatureFlags) Signature {
		sig := /* TODO(NewExpression): new Signature(checker, flags) */ TODO
		sig.declaration = declaration
		sig.typeParameters = typeParameters
		sig.parameters = parameters
		sig.thisParameter = thisParameter
		sig.resolvedReturnType = resolvedReturnType
		sig.resolvedTypePredicate = resolvedTypePredicate
		sig.minArgumentCount = minArgumentCount
		sig.resolvedMinArgumentCount = nil
		sig.target = nil
		sig.mapper = nil
		sig.compositeSignatures = nil
		sig.compositeKind = nil
		return sig
	}
	cloneSignature := func(sig Signature) Signature {
		result := createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, nil, nil, sig.minArgumentCount, sig.flags&SignatureFlagsPropagatingFlags)
		result.target = sig.target
		result.mapper = sig.mapper
		result.compositeSignatures = sig.compositeSignatures
		result.compositeKind = sig.compositeKind
		return result
	}
	createUnionSignature := func(signature Signature, unionSignatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		result := cloneSignature(signature)
		result.compositeSignatures = unionSignatures
		result.compositeKind = TypeFlagsUnion
		result.target = nil
		result.mapper = nil
		return result
	}
	getOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) Signature {
		if (signature.flags & SignatureFlagsCallChainFlags) == callChainFlags {
			return signature
		}
		if !signature.optionalCallSignatureCache {
			signature.optionalCallSignatureCache = /* TODO(ObjectLiteralExpression): {} */ TODO
		}
		key := /* TODO(ConditionalExpression): callChainFlags === SignatureFlags.IsInnerCallChain ? "inner" : "outer" */ TODO
		return /* TODO(ElementAccessExpression): signature.optionalCallSignatureCache[key] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags) */ TODO)
	}
	createOptionalCallSignature := func(signature Signature, callChainFlags SignatureFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		Debug.assert(callChainFlags == SignatureFlagsIsInnerCallChain || callChainFlags == SignatureFlagsIsOuterCallChain, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.")
		result := cloneSignature(signature)
		result.flags |= callChainFlags
		return result
	}
	getExpandedParameters := func(sig Signature, skipUnionExpanding bool) [][]Symbol {
		if signatureHasRestParameter(sig) {
			restIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sig.parameters.length - 1 */ TODO
			restSymbol := /* TODO(ElementAccessExpression): sig.parameters[restIndex] */ TODO
			restType := getTypeOfSymbol(restSymbol)
			if isTupleType(restType) {
				return /* TODO(ArrayLiteralExpression): [expandSignatureParametersWithTupleMembers(restType, restIndex, restSymbol)] */ TODO
			} else if !skipUnionExpanding && restType.flags&TypeFlagsUnion && every((restType /* as */ /* TODO(TypeReference): UnionType */).types, isTupleType) {
				return map_((restType /* as */ /* TODO(TypeReference): UnionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
					/* TODO(Identifier): expandSignatureParametersWithTupleMembers */
					/* TODO(AsExpression): t as TupleTypeReference */
					/* TODO(Identifier): restIndex */
					/* TODO(Identifier): restSymbol */
				})
			}
		}
		return /* TODO(ArrayLiteralExpression): [sig.parameters] */ TODO
		expandSignatureParametersWithTupleMembers := func(restType TupleTypeReference, restIndex number, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			elementTypes := getTypeArguments(restType)
			associatedNames := getUniqAssociatedNamesFromTupleType(restType, restSymbol)
			restParams := map_(elementTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
				name := /* TODO(ConditionalExpression): associatedNames && associatedNames[i] ? associatedNames[i] :                     getParameterNameAtPosition(sig, restIndex + i, restType) */ TODO
				flags := /* TODO(ElementAccessExpression): restType.target.elementFlags[i] */ TODO
				checkFlags := /* TODO(ConditionalExpression): flags & ElementFlags.Variable ? CheckFlags.RestParameter :                     flags & ElementFlags.Optional ? CheckFlags.OptionalParameter : 0 */ TODO
				symbol := createSymbol(SymbolFlagsFunctionScopedVariable, name, checkFlags)
				symbol.links.type_ = /* TODO(ConditionalExpression): flags & ElementFlags.Rest ? createArrayType(t) : t */ TODO
				return symbol
			})
			return concatenate(sig.parameters.slice(0, restIndex), restParams)
		}
		getUniqAssociatedNamesFromTupleType := func(type_ TupleTypeReference, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String[] | undefined */ TODO {
			names := map_(type_.target.labeledElementDeclarations, func(labeledElement /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
				/* TODO(Identifier): getTupleElementLabel */
				/* TODO(Identifier): labeledElement */
				/* TODO(Identifier): i */
				/* TODO(ElementAccessExpression): type.target.elementFlags[i] */
				/* TODO(Identifier): restSymbol */
			})
			if names {
				var duplicates []number = /* TODO(ArrayLiteralExpression): [] */ TODO
				uniqueNames := /* TODO(NewExpression): new Set<__String>() */ TODO
				/* TODO(ForStatement): for (let i = 0; i < names.length; i++) {                     const name = names[i];                     if (!tryAddToSet(uniqueNames, name)) {                         duplicates.push(i);                     }                 } */
				counters := /* TODO(NewExpression): new Map<__String, number>() */ TODO
				for _, i := range duplicates {
					counter := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): counters.get(names[i]) ?? 1 */ TODO
					var name __String
					/* TODO(WhileStatement): while (!tryAddToSet(uniqueNames, name = `${names[i]}_${counter}` as __String)) {                         counter++;                     } */
					/* TODO(ElementAccessExpression): names[i] */
					TODO = name
					counters.set( /* TODO(ElementAccessExpression): names[i] */ TODO /* TODO(PlusToken): + */ /* TODO(BinaryExpression): counter + 1 */, TODO)
				}
			}
			return names
		}
	}
	getDefaultConstructSignatures := func(classType InterfaceType) []Signature {
		baseConstructorType := getBaseConstructorTypeOfClass(classType)
		baseSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
		declaration := getClassLikeDeclarationOfSymbol(classType.symbol)
		isAbstract := !!declaration && hasSyntacticModifier(declaration, ModifierFlagsAbstract)
		if baseSignatures.length == 0 {
			return /* TODO(ArrayLiteralExpression): [createSignature(/*declaration* / undefined, classType.localTypeParameters, /*thisParameter* / undefined, emptyArray, classType, /*resolvedTypePredicate* / undefined, 0, isAbstract ? SignatureFlags.Abstract : SignatureFlags.None)] */ TODO
		}
		baseTypeNode := /* TODO(NonNullExpression): getBaseTypeNodeOfClass(classType)! */ TODO
		isJavaScript := isInJSFile(baseTypeNode)
		typeArguments := typeArgumentsFromTypeReferenceNode(baseTypeNode)
		typeArgCount := length(typeArguments)
		var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, baseSig := range baseSignatures {
			minTypeArgumentCount := getMinTypeArgumentCount(baseSig.typeParameters)
			typeParamCount := length(baseSig.typeParameters)
			if isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount {
				sig := /* TODO(ConditionalExpression): typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig) */ TODO
				sig.typeParameters = classType.localTypeParameters
				sig.resolvedReturnType = classType
				sig.flags = /* TODO(ConditionalExpression): isAbstract ? sig.flags | SignatureFlags.Abstract : sig.flags & ~SignatureFlags.Abstract */ TODO
				result.push(sig)
			}
		}
		return result
	}
	findMatchingSignature := func(signatureList []Signature, signature Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool) *Signature {
		for _, s := range signatureList {
			if compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes /* TODO(ConditionalExpression): partialMatch ? compareTypesSubtypeOf : compareTypesIdentical */, TODO) {
				return s
			}
		}
	}
	findMatchingSignatures := func(signatureLists [][]Signature, signature Signature, listIndex number) /* TODO(ArrayType): Signature[] */ any {
		if signature.typeParameters {
			if listIndex > 0 {
				return nil
			}
			/* TODO(ForStatement): for (let i = 1; i < signatureLists.length; i++) {                 if (!findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false)) {                     return undefined;                 }             } */
			return /* TODO(ArrayLiteralExpression): [signature] */ TODO
		}
		var result /* TODO(ArrayType): Signature[] */ any
		/* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             // Allow matching non-generic signatures to have excess parameters (as a fallback if exact parameter match is not found) and different return types.             // Prefer matching this types if possible.             const match = i === listIndex                 ? signature                 : findMatchingSignature(signatureLists[i], signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)                     || findMatchingSignature(signatureLists[i], signature, /*partialMatch* / true, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true);             if (!match) {                 return undefined;             }             result = appendIfUnique(result, match);         } */
		return result
	}
	getUnionSignatures := func(signatureLists [][]Signature) []Signature {
		var result /* TODO(ArrayType): Signature[] */ any
		var indexWithLengthOverOne /* TODO(NumberKeyword): number */ any
		/* TODO(ForStatement): for (let i = 0; i < signatureLists.length; i++) {             if (signatureLists[i].length === 0) return emptyArray;             if (signatureLists[i].length > 1) {                 indexWithLengthOverOne = indexWithLengthOverOne === undefined ? i : -1; // -1 is a signal there are multiple overload sets             }             for (const signature of signatureLists[i]) {                 // Only process signatures with parameter lists that aren't already in the result list                 if (!result || !findMatchingSignature(result, signature, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / true)) {                     const unionSignatures = findMatchingSignatures(signatureLists, signature, i);                     if (unionSignatures) {                         let s = signature;                         // Union the result types when more than one signature matches                         if (unionSignatures.length > 1) {                             let thisParameter = signature.thisParameter;                             const firstThisParameterOfUnionSignatures = forEach(unionSignatures, sig => sig.thisParameter);                             if (firstThisParameterOfUnionSignatures) {                                 const thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));                                 thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);                             }                             s = createUnionSignature(signature, unionSignatures);                             s.thisParameter = thisParameter;                         }                         (result || (result = [])).push(s);                     }                 }             }         } */
		if !length(result) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexWithLengthOverOne !== -1 */ TODO {
			masterList := /* TODO(ElementAccessExpression): signatureLists[indexWithLengthOverOne !== undefined ? indexWithLengthOverOne : 0] */ TODO
			var results /* TODO(ArrayType): Signature[] */ any = masterList.slice()
			for _, signatures := range signatureLists {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): signatures !== masterList */ TODO {
					signature := /* TODO(ElementAccessExpression): signatures[0] */ TODO
					Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass")
					results = /* TODO(ConditionalExpression): !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? undefined : map(results, sig => combineSignaturesOfUnionMembers(sig, signature)) */ TODO
					if !results {
						/* TODO(BreakStatement): break; */
					}
				}
			}
			result = results
		}
		return result || emptyArray
	}
	compareTypeParametersIdentical := func(sourceParams /* TODO(TypeOperator): readonly TypeParameter[] */ any, targetParams /* TODO(TypeOperator): readonly TypeParameter[] */ any) bool {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(sourceParams) !== length(targetParams) */ TODO {
			return false
		}
		if !sourceParams || !targetParams {
			return true
		}
		mapper := createTypeMapper(targetParams, sourceParams)
		/* TODO(ForStatement): for (let i = 0; i < sourceParams.length; i++) {             const source = sourceParams[i];             const target = targetParams[i];             if (source === target) continue;             // We instantiate the target type parameter constraints into the source types so we can recognize `<T, U extends T>` as the same as `<A, B extends A>`             if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper))) return false;             // We don't compare defaults - we just use the type parameter defaults from the first signature that seems to match.             // It might make sense to combine these defaults in the future, but doing so intelligently requires knowing             // if the parameter is used covariantly or contravariantly (so we intersect if it's used like a parameter or union if used like a return type)             // and, since it's just an inference _default_, just picking one arbitrarily works OK.         } */
		return true
	}
	combineUnionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getIntersectionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
		return createSymbolWithType(left, thisType)
	}
	combineUnionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getIntersectionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,                 isRestParam ? CheckFlags.RestParameter : isOptional ? CheckFlags.OptionalParameter : 0,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args" /* as */ /* TODO(TypeReference): __String */, CheckFlagsRestParameter)
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			/* TODO(ElementAccessExpression): params[longestCount] */ TODO = restParamSymbol
		}
		return params
	}
	combineSignaturesOfUnionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
		}
		declaration := left.declaration
		params := combineUnionParameters(left, right, paramMapper)
		thisParam := combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsUnion
		result.compositeSignatures = concatenate( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): left.compositeKind !== TypeFlags.Intersection */ TODO && left.compositeSignatures || /* TODO(ArrayLiteralExpression): [left] */ TODO /* TODO(ArrayLiteralExpression): [right] */, TODO)
		if paramMapper {
			result.mapper = /* TODO(ConditionalExpression): left.compositeKind !== TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper */ TODO
		} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): left.compositeKind !== TypeFlags.Intersection */ TODO && left.mapper && left.compositeSignatures {
			result.mapper = left.mapper
		}
		return result
	}
	getUnionIndexInfos := func(types []Type) []IndexInfo {
		sourceInfos := getIndexInfosOfType( /* TODO(ElementAccessExpression): types[0] */ TODO)
		if sourceInfos {
			result := /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, info := range sourceInfos {
				indexType := info.keyType
				if every(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !getIndexInfoOfType(t, indexType) */
				}) {
					result.push(createIndexInfo(indexType, getUnionType(map_(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						/* TODO(CallExpression): getIndexTypeOfType(t, indexType) */
					})), some(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(NonNullExpression): getIndexInfoOfType(t, indexType)! */
						/* TODO(Identifier): isReadonly */
					})))
				}
			}
			return result
		}
		return emptyArray
	}
	resolveUnionTypeMembers := func(type_ UnionType) {
		callSignatures := getUnionSignatures(map_(type_.types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
			/* TODO(BinaryExpression): t === globalFunctionType */
			/* TODO(QuestionToken): ? */
			/* TODO(ArrayLiteralExpression): [unknownSignature] */
			/* TODO(ColonToken): : */
			/* TODO(CallExpression): getSignaturesOfType(t, SignatureKind.Call) */
		}))
		constructSignatures := getUnionSignatures(map_(type_.types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
			/* TODO(Identifier): getSignaturesOfType */
			/* TODO(Identifier): t */
			/* TODO(PropertyAccessExpression): SignatureKind.Construct */
		}))
		indexInfos := getUnionIndexInfos(type_.types)
		setStructuredTypeMembers(type_, emptySymbols, callSignatures, constructSignatures, indexInfos)
	}
	// OVERLOAD: intersectTypes := func(type1 Type, type2 Type) Type
	// OVERLOAD: intersectTypes := func(type1 *Type, type2 *Type) *Type
	intersectTypes := func(type1 *Type, type2 *Type) *Type {
		return /* TODO(ConditionalExpression): !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]) */ TODO
	}
	findMixins := func(types []Type) []bool {
		constructorTypeCount := countWhere(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PropertyAccessExpression): getSignaturesOfType(t, SignatureKind.Construct).length */
			/* TODO(GreaterThanToken): > */
			/* TODO(NumericLiteral): 0 */
		})
		mixinFlags := map_(types, isMixinConstructorType)
		if constructorTypeCount > 0 && constructorTypeCount == countWhere(mixinFlags, func(b /* TODO(undefined): boolean */ TODO) /* TODO(undefined): boolean */ TODO {
		}) {
			firstMixinIndex := mixinFlags.indexOf(true)
			/* TODO(ElementAccessExpression): mixinFlags[firstMixinIndex] */ TODO = false
		}
		return mixinFlags
	}
	includeMixinType := func(type_ Type, types []Type, mixinFlags []bool, index number) Type {
		var mixedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             if (i === index) {                 mixedTypes.push(type);             }             else if (mixinFlags[i]) {                 mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], SignatureKind.Construct)[0]));             }         } */
		return getIntersectionType(mixedTypes)
	}
	resolveIntersectionTypeMembers := func(type_ IntersectionType) {
		var callSignatures /* TODO(ArrayType): Signature[] */ any
		var constructSignatures /* TODO(ArrayType): Signature[] */ any
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		types := type_.types
		mixinFlags := findMixins(types)
		mixinCount := countWhere(mixinFlags, func(b /* TODO(undefined): boolean */ TODO) /* TODO(undefined): boolean */ TODO {
		})
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             const t = type.types[i];             // When an intersection type contains mixin constructor types, the construct signatures from             // those types are discarded and their return types are mixed into the return types of all             // other construct signatures in the intersection type. For example, the intersection type             // '{ new(...args: any[]) => A } & { new(s: string) => B }' has a single construct signature             // 'new(s: string) => A & B'.             if (!mixinFlags[i]) {                 let signatures = getSignaturesOfType(t, SignatureKind.Construct);                 if (signatures.length && mixinCount > 0) {                     signatures = map(signatures, s => {                         const clone = cloneSignature(s);                         clone.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);                         return clone;                     });                 }                 constructSignatures = appendSignatures(constructSignatures, signatures);             }             callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, SignatureKind.Call));             indexInfos = reduceLeft(getIndexInfosOfType(t), (infos, newInfo) => appendIndexInfo(infos, newInfo, /*union* / false), indexInfos);         } */
		setStructuredTypeMembers(type_, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray)
	}
	appendSignatures := func(signatures /* TODO(ArrayType): Signature[] */ any, newSignatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] | undefined */ TODO {
		for _, sig := range newSignatures {
			if !signatures || every(signatures, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(CallExpression): compareSignaturesIdentical(s, sig, /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false, compareTypesIdentical) */
			}) {
				signatures = append(signatures, sig)
			}
		}
		return signatures
	}
	appendIndexInfo := func(indexInfos /* TODO(ArrayType): IndexInfo[] */ any, newInfo IndexInfo, union bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ TODO {
		if indexInfos {
			/* TODO(ForStatement): for (let i = 0; i < indexInfos.length; i++) {                 const info = indexInfos[i];                 if (info.keyType === newInfo.keyType) {                     indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);                     return indexInfos;                 }             } */
		}
		return append(indexInfos, newInfo)
	}
	resolveAnonymousTypeMembers := func(type_ AnonymousType) {
		if type_.target {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := createInstantiatedSymbolTable(getPropertiesOfObjectType(type_.target) /* TODO(NonNullExpression): type.mapper! */, TODO, false)
			callSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindCall) /* TODO(NonNullExpression): type.mapper! */, TODO)
			constructSignatures := instantiateSignatures(getSignaturesOfType(type_.target, SignatureKindConstruct) /* TODO(NonNullExpression): type.mapper! */, TODO)
			indexInfos := instantiateIndexInfos(getIndexInfosOfType(type_.target) /* TODO(NonNullExpression): type.mapper! */, TODO)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		symbol := getMergedSymbol(type_.symbol)
		if symbol.flags & SymbolFlagsTypeLiteral {
			setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
			members := getMembersOfSymbol(symbol)
			callSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameCall))
			constructSignatures := getSignaturesOfSymbol(members.get(InternalSymbolNameNew))
			indexInfos := getIndexInfosOfSymbol(symbol)
			setStructuredTypeMembers(type_, members, callSignatures, constructSignatures, indexInfos)
			return
		}
		members := getExportsOfSymbol(symbol)
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		if symbol == globalThisSymbol {
			varsOnly := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
			members.forEach(func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
				if !(p.flags & SymbolFlagsBlockScoped) && !(p.flags&SymbolFlagsValueModule && p.declarations.length && every(p.declarations, isAmbientModule)) {
					varsOnly.set(p.escapedName, p)
				}
			})
			members = varsOnly
		}
		var baseConstructorIndexInfo *IndexInfo
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, emptyArray)
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			baseConstructorType := getBaseConstructorTypeOfClass(classType)
			if baseConstructorType.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsTypeVariable) {
				members = createSymbolTable(getNamedOrIndexSignatureMembers(members))
				addInheritedMembers(members, getPropertiesOfType(baseConstructorType))
			} else if baseConstructorType == anyType {
				baseConstructorIndexInfo = createIndexInfo(stringType, anyType, false)
			}
		}
		indexSymbol := getIndexSymbolFromSymbolTable(members)
		if indexSymbol {
			indexInfos = getIndexInfosOfIndexSymbol(indexSymbol)
		} else {
			if baseConstructorIndexInfo {
				indexInfos = append(indexInfos, baseConstructorIndexInfo)
			}
			if symbol.flags&SymbolFlagsEnum && (getDeclaredTypeOfSymbol(symbol).flags&TypeFlagsEnum || some(type_.properties, func(prop /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(getTypeOfSymbol(prop).flags & TypeFlags.NumberLike) */
			})) {
				indexInfos = append(indexInfos, enumNumberIndexInfo)
			}
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			type_.callSignatures = getSignaturesOfSymbol(symbol)
		}
		if symbol.flags & SymbolFlagsClass {
			classType := getDeclaredTypeOfClassOrInterface(symbol)
			constructSignatures := /* TODO(ConditionalExpression): symbol.members ? getSignaturesOfSymbol(symbol.members.get(InternalSymbolName.Constructor)) : emptyArray */ TODO
			if symbol.flags & SymbolFlagsFunction {
				constructSignatures = addRange(constructSignatures.slice(), mapDefined(type_.callSignatures, func(sig /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
					/* TODO(CallExpression): isJSConstructor(sig.declaration) */
					/* TODO(QuestionToken): ? */
					/* TODO(CallExpression): createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, /*resolvedTypePredicate* / undefined, sig.minArgumentCount, sig.flags & SignatureFlags.PropagatingFlags) */
					/* TODO(ColonToken): : */
					/* TODO(Identifier): undefined */
				}))
			}
			if !constructSignatures.length {
				constructSignatures = getDefaultConstructSignatures(classType)
			}
			type_.constructSignatures = constructSignatures
		}
	}
	type ReplaceableIndexedAccessType /* TODO(IntersectionType): IndexedAccessType & { objectType: TypeParameter; indexType: TypeParameter; } */ TODO
	replaceIndexedAccess := func(instantiable Type, type_ ReplaceableIndexedAccessType, replacement Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return instantiateType(instantiable, createTypeMapper( /* TODO(ArrayLiteralExpression): [type.indexType, type.objectType] */ TODO /* TODO(ArrayLiteralExpression): [getNumberLiteralType(0), createTupleType([replacement])] */, TODO))
	}
	getLimitedConstraint := func(type_ ReverseMappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		constraint := getConstraintTypeFromMappedType(type_.mappedType)
		if !(constraint.flags&TypeFlagsUnion || constraint.flags&TypeFlagsIntersection) {
			return
		}
		origin := /* TODO(ConditionalExpression): (constraint.flags & TypeFlags.Union) ? (constraint as UnionType).origin : (constraint as IntersectionType) */ TODO
		if !origin || !(origin.flags & TypeFlagsIntersection) {
			return
		}
		limitedConstraint := getIntersectionType((origin /* as */ /* TODO(TypeReference): IntersectionType */).types.filter(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): t */
			/* TODO(ExclamationEqualsEqualsToken): !== */
			/* TODO(PropertyAccessExpression): type.constraintType */
		}))
		return /* TODO(ConditionalExpression): limitedConstraint !== neverType ? limitedConstraint : undefined */ TODO
	}
	resolveReverseMappedTypeMembers := func(type_ ReverseMappedType) {
		indexInfo := getIndexInfoOfType(type_.source, stringType)
		modifiers := getMappedTypeModifiers(type_.mappedType)
		readonlyMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? false : true */ TODO
		optionalMask := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? 0 : SymbolFlags.Optional */ TODO
		indexInfos := /* TODO(ConditionalExpression): indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType) || unknownType, readonlyMask && indexInfo.isReadonly)] : emptyArray */ TODO
		members := createSymbolTable()
		limitedConstraint := getLimitedConstraint(type_)
		for _, prop := range getPropertiesOfType(type_.source) {
			if limitedConstraint {
				propertyNameType := getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique)
				if !isTypeAssignableTo(propertyNameType, limitedConstraint) {
					/* TODO(ContinueStatement): continue; */
				}
			}
			checkFlags := CheckFlagsReverseMapped | ( /* TODO(ConditionalExpression): readonlyMask && isReadonlySymbol(prop) ? CheckFlags.Readonly : 0 */ TODO)
			inferredProp := createSymbol(SymbolFlagsProperty|prop.flags&optionalMask, prop.escapedName, checkFlags) /* as */ /* TODO(TypeReference): ReverseMappedSymbol */
			inferredProp.declarations = prop.declarations
			inferredProp.links.nameType = getSymbolLinks(prop).nameType
			inferredProp.links.propertyType = getTypeOfSymbol(prop)
			if type_.constraintType.type_.flags&TypeFlagsIndexedAccess && (type_.constraintType.type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType.flags&TypeFlagsTypeParameter && (type_.constraintType.type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType.flags&TypeFlagsTypeParameter {
				newTypeParam := (type_.constraintType.type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType
				newMappedType := replaceIndexedAccess(type_.mappedType, type_.constraintType.type_ /* as */ /* TODO(TypeReference): ReplaceableIndexedAccessType */, newTypeParam)
				inferredProp.links.mappedType = newMappedType                  /* as */ /* TODO(TypeReference): MappedType */
				inferredProp.links.constraintType = getIndexType(newTypeParam) /* as */ /* TODO(TypeReference): IndexType */
			} else {
				inferredProp.links.mappedType = type_.mappedType
				inferredProp.links.constraintType = type_.constraintType
			}
			members.set(prop.escapedName, inferredProp)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos)
	}
	getLowerBoundOfKeyType := func(type_ Type) Type {
		if type_.flags & TypeFlagsIndex {
			t := getApparentType((type_ /* as */ /* TODO(TypeReference): IndexType */).type_)
			return /* TODO(ConditionalExpression): isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t) */ TODO
		}
		if type_.flags & TypeFlagsConditional {
			if (type_ /* as */ /* TODO(TypeReference): ConditionalType */).root.isDistributive {
				checkType := (type_ /* as */ /* TODO(TypeReference): ConditionalType */).checkType
				constraint := getLowerBoundOfKeyType(checkType)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== checkType */ TODO {
					return getConditionalTypeInstantiation(type_ /* as */ /* TODO(TypeReference): ConditionalType */, prependTypeMapping((type_ /* as */ /* TODO(TypeReference): ConditionalType */).root.checkType, constraint, (type_ /* as */ /* TODO(TypeReference): ConditionalType */).mapper), false)
				}
			}
			return type_
		}
		if type_.flags & TypeFlagsUnion {
			return mapType(type_ /* as */ /* TODO(TypeReference): UnionType */, getLowerBoundOfKeyType, true)
		}
		if type_.flags & TypeFlagsIntersection {
			types := (type_ /* as */ /* TODO(TypeReference): IntersectionType */).types
			if types.length == 2 && !!( /* TODO(ElementAccessExpression): types[0] */ TODO.flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) && /* TODO(ElementAccessExpression): types[1] */ TODO == emptyTypeLiteralType {
				return type_
			}
			return getIntersectionType(sameMap((type_ /* as */ /* TODO(TypeReference): UnionType */).types, getLowerBoundOfKeyType))
		}
		return type_
	}
	getIsLateCheckFlag := func(s Symbol) CheckFlags {
		return getCheckFlags(s) & CheckFlagsLate
	}
	forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType := func(type_ Type, include TypeFlags, stringsOnly bool, cb func(keyType Type)) {
		for _, prop := range getPropertiesOfType(type_) {
			cb(getLiteralTypeFromProperty(prop, include))
		}
		if type_.flags & TypeFlagsAny {
			cb(stringType)
		} else {
			for _, info := range getIndexInfosOfType(type_) {
				if !stringsOnly || info.keyType.flags&(TypeFlagsString|TypeFlagsTemplateLiteral) {
					cb(info.keyType)
				}
			}
		}
	}
	resolveMappedTypeMembers := func(type_ MappedType) {
		var members SymbolTable = createSymbolTable()
		var indexInfos /* TODO(ArrayType): IndexInfo[] */ any
		setStructuredTypeMembers(type_, emptySymbols, emptyArray, emptyArray, emptyArray)
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		mappedType := (type_.target /* as */ /* TODO(TypeReference): MappedType */) || type_
		nameType := getNameTypeFromMappedType(mappedType)
		shouldLinkPropDeclarations := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getMappedTypeNameTypeKind(mappedType) !== MappedTypeNameTypeKind.Remapping */ TODO
		templateType := getTemplateTypeFromMappedType(mappedType)
		modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
		templateModifiers := getMappedTypeModifiers(type_)
		include := TypeFlagsStringOrNumberLiteralOrUnique
		if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, false, addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		setStructuredTypeMembers(type_, members, emptyArray, emptyArray, indexInfos || emptyArray)
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			forEachType(propNameType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
				/* TODO(Identifier): addMemberForKeyTypeWorker */
				/* TODO(Identifier): keyType */
				/* TODO(Identifier): t */
			})
		}
		addMemberForKeyTypeWorker := func(keyType Type, propNameType Type) {
			if isTypeUsableAsPropertyName(propNameType) {
				propName := getPropertyNameFromType(propNameType)
				existingProp := members.get(propName) /* as */ /* TODO(UnionType): MappedSymbol | undefined */
				if existingProp {
					existingProp.links.nameType = getUnionType( /* TODO(ArrayLiteralExpression): [existingProp.links.nameType!, propNameType] */ TODO)
					existingProp.links.keyType = getUnionType( /* TODO(ArrayLiteralExpression): [existingProp.links.keyType, keyType] */ TODO)
				} else {
					modifiersProp := /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : undefined */ TODO
					isOptional := !!(templateModifiers&MappedTypeModifiersIncludeOptional || !(templateModifiers&MappedTypeModifiersExcludeOptional) && modifiersProp && modifiersProp.flags&SymbolFlagsOptional)
					isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersProp && isReadonlySymbol(modifiersProp))
					stripOptional := strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags&SymbolFlagsOptional
					var lateFlag CheckFlags = /* TODO(ConditionalExpression): modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0 */ TODO
					prop := createSymbol(SymbolFlagsProperty|( /* TODO(ConditionalExpression): isOptional ? SymbolFlags.Optional : 0 */ TODO), propName, lateFlag|CheckFlagsMapped|( /* TODO(ConditionalExpression): isReadonly ? CheckFlags.Readonly : 0 */ TODO)|( /* TODO(ConditionalExpression): stripOptional ? CheckFlags.StripOptional : 0 */ TODO)) /* as */ /* TODO(TypeReference): MappedSymbol */
					prop.links.mappedType = type_
					prop.links.nameType = propNameType
					prop.links.keyType = keyType
					if modifiersProp {
						prop.links.syntheticOrigin = modifiersProp
						prop.declarations = /* TODO(ConditionalExpression): shouldLinkPropDeclarations ? modifiersProp.declarations : undefined */ TODO
					}
					members.set(propName, prop)
				}
			} else if isValidIndexKeyType(propNameType) || propNameType.flags&(TypeFlagsAny|TypeFlagsEnum) {
				indexKeyType := /* TODO(ConditionalExpression): propNameType.flags & (TypeFlags.Any | TypeFlags.String) ? stringType :                     propNameType.flags & (TypeFlags.Number | TypeFlags.Enum) ? numberType :                     propNameType */ TODO
				propType := instantiateType(templateType, appendTypeMapping(type_.mapper, typeParameter, keyType))
				modifiersIndexInfo := getApplicableIndexInfo(modifiersType, propNameType)
				isReadonly := !!(templateModifiers&MappedTypeModifiersIncludeReadonly || !(templateModifiers&MappedTypeModifiersExcludeReadonly) && modifiersIndexInfo.isReadonly)
				indexInfo := createIndexInfo(indexKeyType, propType, isReadonly)
				indexInfos = appendIndexInfo(indexInfos, indexInfo, true)
			}
		}
	}
	getTypeOfMappedSymbol := func(symbol MappedSymbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !symbol.links.type_ {
			mappedType := symbol.links.mappedType
			if !pushTypeResolution(symbol, TypeSystemPropertyNameType) {
				mappedType.containsError = true
				return errorType
			}
			templateType := getTemplateTypeFromMappedType(mappedType.target /* as */ /* TODO(TypeReference): MappedType */ || mappedType)
			mapper := appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.links.keyType)
			propType := instantiateType(templateType, mapper)
			type_ := /* TODO(ConditionalExpression): strictNullChecks && symbol.flags & SymbolFlags.Optional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :                 symbol.links.checkFlags & CheckFlags.StripOptional ? removeMissingOrUndefinedType(propType) :                 propType */ TODO
			if !popTypeResolution() {
				error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType))
				type_ = errorType
			}
			/* TODO(ExpressionStatement): symbol.links.type ??= type; */
		}
		return symbol.links.type_
	}
	getTypeParameterFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
		return type_.typeParameter || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)) */ TODO)
	}
	getConstraintTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.constraintType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType */ TODO)
	}
	getNameTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.declaration.nameType ?             type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) :             undefined */ TODO
	}
	getTemplateTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.templateType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.templateType = type.declaration.type ?                 instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), /*isProperty* / true, !!(getMappedTypeModifiers(type) & MappedTypeModifiers.IncludeOptional)), type.mapper) :                 errorType */ TODO)
	}
	getConstraintDeclarationForMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		return getEffectiveConstraintOfTypeParameter(type_.declaration.typeParameter)
	}
	isMappedTypeWithKeyofConstraintDeclaration := func(type_ MappedType) /* TODO(undefined): boolean */ TODO {
		constraintDeclaration := /* TODO(NonNullExpression): getConstraintDeclarationForMappedType(type)! */ TODO
		return constraintDeclaration.kind == SyntaxKindTypeOperator && (constraintDeclaration /* as */ /* TODO(TypeReference): TypeOperatorNode */).operator == SyntaxKindKeyOfKeyword
	}
	getModifiersTypeFromMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !type_.modifiersType {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				type_.modifiersType = instantiateType(getTypeFromTypeNode((getConstraintDeclarationForMappedType(type_) /* as */ /* TODO(TypeReference): TypeOperatorNode */).type_), type_.mapper)
			} else {
				declaredType := getTypeFromMappedTypeNode(type_.declaration) /* as */ /* TODO(TypeReference): MappedType */
				constraint := getConstraintTypeFromMappedType(declaredType)
				extendedConstraint := /* TODO(ConditionalExpression): constraint && constraint.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(constraint as TypeParameter) : constraint */ TODO
				type_.modifiersType = /* TODO(ConditionalExpression): extendedConstraint && extendedConstraint.flags & TypeFlags.Index ? instantiateType((extendedConstraint as IndexType).type, type.mapper) : unknownType */ TODO
			}
		}
		return type_.modifiersType
	}
	getMappedTypeModifiers := func(type_ MappedType) MappedTypeModifiers {
		declaration := type_.declaration
		return ( /* TODO(ConditionalExpression): declaration.readonlyToken ? declaration.readonlyToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeReadonly : MappedTypeModifiers.IncludeReadonly : 0 */ TODO) | ( /* TODO(ConditionalExpression): declaration.questionToken ? declaration.questionToken.kind === SyntaxKind.MinusToken ? MappedTypeModifiers.ExcludeOptional : MappedTypeModifiers.IncludeOptional : 0 */ TODO)
	}
	getMappedTypeOptionality := func(type_ MappedType) number {
		modifiers := getMappedTypeModifiers(type_)
		return /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.ExcludeOptional ? -1 : modifiers & MappedTypeModifiers.IncludeOptional ? 1 : 0 */ TODO
	}
	getCombinedMappedTypeOptionality := func(type_ Type) number {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			return getMappedTypeOptionality(type_ /* as */ /* TODO(TypeReference): MappedType */) || getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */))
		}
		if type_.flags & TypeFlagsIntersection {
			optionality := getCombinedMappedTypeOptionality( /* TODO(ElementAccessExpression): (type as IntersectionType).types[0] */ TODO)
			return /* TODO(ConditionalExpression): every((type as IntersectionType).types, (t, i) => i === 0 || getCombinedMappedTypeOptionality(t) === optionality) ? optionality : 0 */ TODO
		}
		return 0
	}
	isPartialMappedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(getObjectFlags(type_)&ObjectFlagsMapped && getMappedTypeModifiers(type_ /* as */ /* TODO(TypeReference): MappedType */)&MappedTypeModifiersIncludeOptional)
	}
	isGenericMappedType := func(type_ Type) /* TODO(TypePredicate): type is MappedType */ TODO {
		if getObjectFlags(type_) & ObjectFlagsMapped {
			constraint := getConstraintTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
			if isGenericIndexType(constraint) {
				return true
			}
			nameType := getNameTypeFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
			if nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */), constraint))) {
				return true
			}
		}
		return false
	}
	getMappedTypeNameTypeKind := func(type_ MappedType) MappedTypeNameTypeKind {
		nameType := getNameTypeFromMappedType(type_)
		if !nameType {
			return MappedTypeNameTypeKindNone
		}
		return /* TODO(ConditionalExpression): isTypeAssignableTo(nameType, getTypeParameterFromMappedType(type)) ? MappedTypeNameTypeKind.Filtering : MappedTypeNameTypeKind.Remapping */ TODO
	}
	resolveStructuredTypeMembers := func(type_ StructuredType) ResolvedType {
		if !(type_ /* as */ /* TODO(TypeReference): ResolvedType */).members {
			if type_.flags & TypeFlagsObject {
				if (type_ /* as */ /* TODO(TypeReference): ObjectType */).objectFlags & ObjectFlagsReference {
					resolveTypeReferenceMembers(type_ /* as */ /* TODO(TypeReference): TypeReference */)
				} else if (type_ /* as */ /* TODO(TypeReference): ObjectType */).objectFlags & ObjectFlagsClassOrInterface {
					resolveClassOrInterfaceMembers(type_ /* as */ /* TODO(TypeReference): InterfaceType */)
				} else if (type_ /* as */ /* TODO(TypeReference): ReverseMappedType */).objectFlags & ObjectFlagsReverseMapped {
					resolveReverseMappedTypeMembers(type_ /* as */ /* TODO(TypeReference): ReverseMappedType */)
				} else if (type_ /* as */ /* TODO(TypeReference): ObjectType */).objectFlags & ObjectFlagsAnonymous {
					resolveAnonymousTypeMembers(type_ /* as */ /* TODO(TypeReference): AnonymousType */)
				} else if (type_ /* as */ /* TODO(TypeReference): MappedType */).objectFlags & ObjectFlagsMapped {
					resolveMappedTypeMembers(type_ /* as */ /* TODO(TypeReference): MappedType */)
				} else {
					Debug.fail( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled object type " + Debug.formatObjectFlags(type.objectFlags) */ TODO)
				}
			} else if type_.flags & TypeFlagsUnion {
				resolveUnionTypeMembers(type_ /* as */ /* TODO(TypeReference): UnionType */)
			} else if type_.flags & TypeFlagsIntersection {
				resolveIntersectionTypeMembers(type_ /* as */ /* TODO(TypeReference): IntersectionType */)
			} else {
				Debug.fail( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "Unhandled type " + Debug.formatTypeFlags(type.flags) */ TODO)
			}
		}
		return type_ /* as */ /* TODO(TypeReference): ResolvedType */
	}
	getPropertiesOfObjectType := func(type_ Type) []Symbol {
		if type_.flags & TypeFlagsObject {
			return resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */).properties
		}
		return emptyArray
	}
	getPropertyOfObjectType := func(type_ Type, name __String) *Symbol {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			symbol := resolved.members.get(name)
			if symbol && symbolIsValue(symbol) {
				return symbol
			}
		}
	}
	getPropertiesOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType) []Symbol {
		if !type_.resolvedProperties {
			members := createSymbolTable()
			for _, current := range type_.types {
				for _, prop := range getPropertiesOfType(current) {
					if !members.has(prop.escapedName) {
						combinedProp := getPropertyOfUnionOrIntersectionType(type_, prop.escapedName, !!(type_.flags & TypeFlagsIntersection))
						if combinedProp {
							members.set(prop.escapedName, combinedProp)
						}
					}
				}
				if type_.flags&TypeFlagsUnion && getIndexInfosOfType(current).length == 0 {
					/* TODO(BreakStatement): break; */
				}
			}
			type_.resolvedProperties = getNamedMembers(members)
		}
		return type_.resolvedProperties
	}
	getPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getReducedApparentType(type_)
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ?             getPropertiesOfUnionOrIntersectionType(type as UnionType) :             getPropertiesOfObjectType(type) */ TODO
	}
	forEachPropertyOfType := func(type_ Type, action func(symbol Symbol, escapedName __String)) {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsStructuredType {
			resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): StructuredType */).members.forEach(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, escapedName /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				if isNamedMember(symbol, escapedName) {
					action(symbol, escapedName)
				}
			})
		}
	}
	isTypeInvalidDueToUnionDiscriminant := func(contextualType Type, obj /* TODO(UnionType): ObjectLiteralExpression | JsxAttributes */ any) bool {
		list := obj.properties /* as */ /* TODO(TypeReference): NodeArray<ObjectLiteralElementLike | JsxAttributeLike> */
		return list.some(func(property /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralElementLike | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttributeLike */ TODO) /* TODO(undefined): boolean */ TODO {
			nameType := property.name && ( /* TODO(ConditionalExpression): isJsxNamespacedName(property.name) ? getStringLiteralType(getTextOfJsxAttributeName(property.name)) : getLiteralTypeFromPropertyName(property.name) */ TODO)
			name := /* TODO(ConditionalExpression): nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined */ TODO
			expected := /* TODO(ConditionalExpression): name === undefined ? undefined : getTypeOfPropertyOfType(contextualType, name) */ TODO
			return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected)
		})
	}
	getAllPossiblePropertiesOfTypes := func(types []Type) []Symbol {
		unionType := getUnionType(types)
		if !(unionType.flags & TypeFlagsUnion) {
			return getAugmentedPropertiesOfType(unionType)
		}
		props := createSymbolTable()
		for _, memberType := range types {
			for _, TODO_IDENTIFIER := range getAugmentedPropertiesOfType(memberType) {
				if !props.has(escapedName) {
					prop := createUnionOrIntersectionProperty(unionType /* as */ /* TODO(TypeReference): UnionType */, escapedName)
					if prop {
						/* TODO(CallExpression): props.set(escapedName, prop) */
					}
				}
			}
		}
		return arrayFrom(props.values())
	}
	getConstraintOfType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) *Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.TypeParameter ? getConstraintOfTypeParameter(type as TypeParameter) :             type.flags & TypeFlags.IndexedAccess ? getConstraintOfIndexedAccess(type as IndexedAccessType) :             type.flags & TypeFlags.Conditional ? getConstraintOfConditionalType(type as ConditionalType) :             getBaseConstraintOfType(type) */ TODO
	}
	getConstraintOfTypeParameter := func(typeParameter TypeParameter) *Type {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : undefined */ TODO
	}
	isConstMappedType := func(type_ MappedType, depth number) bool {
		typeVariable := getHomomorphicTypeVariable(type_)
		return !!typeVariable && isConstTypeVariable(typeVariable, depth)
	}
	isConstTypeVariable := func(type_ *Type, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) bool {
		return depth < 5 && !!(type_ && (type_.flags&TypeFlagsTypeParameter && some((type_ /* as */ /* TODO(TypeReference): TypeParameter */).symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): hasSyntacticModifier */
			/* TODO(Identifier): d */
			/* TODO(PropertyAccessExpression): ModifierFlags.Const */
		}) || type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isConstTypeVariable */
			/* TODO(Identifier): t */
			/* TODO(Identifier): depth */
		}) || type_.flags&TypeFlagsIndexedAccess && isConstTypeVariable((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO) || type_.flags&TypeFlagsConditional && isConstTypeVariable(getConstraintOfConditionalType(type_ /* as */ /* TODO(TypeReference): ConditionalType */) /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO) || type_.flags&TypeFlagsSubstitution && isConstTypeVariable((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType, depth) || getObjectFlags(type_)&ObjectFlagsMapped && isConstMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */, depth) || isGenericTupleType(type_) && findIndex(getElementTypes(type_), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !!(type.target.elementFlags[i] & ElementFlags.Variadic) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isConstTypeVariable(t, depth) */
		}) >= 0))
	}
	getConstraintOfIndexedAccess := func(type_ IndexedAccessType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : undefined */ TODO
	}
	getSimplifiedTypeOrConstraint := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		simplified := getSimplifiedType(type_, false)
		return /* TODO(ConditionalExpression): simplified !== type ? simplified : getConstraintOfType(type) */ TODO
	}
	getConstraintFromIndexedAccess := func(type_ IndexedAccessType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isMappedTypeGenericIndexedAccess(type_) {
			return substituteIndexedMappedType(type_.objectType /* as */ /* TODO(TypeReference): MappedType */, type_.indexType)
		}
		indexConstraint := getSimplifiedTypeOrConstraint(type_.indexType)
		if indexConstraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexConstraint !== type.indexType */ TODO {
			indexedAccess := getIndexedAccessTypeOrUndefined(type_.objectType, indexConstraint, type_.accessFlags)
			if indexedAccess {
				return indexedAccess
			}
		}
		objectConstraint := getSimplifiedTypeOrConstraint(type_.objectType)
		if objectConstraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): objectConstraint !== type.objectType */ TODO {
			return getIndexedAccessTypeOrUndefined(objectConstraint, type_.indexType, type_.accessFlags)
		}
		return nil
	}
	getDefaultConstraintOfConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !type_.resolvedDefaultConstraint {
			trueConstraint := getInferredTrueTypeFromConditionalType(type_)
			falseConstraint := getFalseTypeFromConditionalType(type_)
			type_.resolvedDefaultConstraint = /* TODO(ConditionalExpression): isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]) */ TODO
		}
		return type_.resolvedDefaultConstraint
	}
	getConstraintOfDistributiveConditionalType := func(type_ ConditionalType) *Type {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.resolvedConstraintOfDistributive !== undefined */ TODO {
			return type_.resolvedConstraintOfDistributive || nil
		}
		if type_.root.isDistributive && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type.restrictiveInstantiation !== type */ TODO {
			simplified := getSimplifiedType(type_.checkType, false)
			constraint := /* TODO(ConditionalExpression): simplified === type.checkType ? getConstraintOfType(simplified) : simplified */ TODO
			if constraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== type.checkType */ TODO {
				instantiated := getConditionalTypeInstantiation(type_, prependTypeMapping(type_.root.checkType, constraint, type_.mapper), true)
				if !(instantiated.flags & TypeFlagsNever) {
					type_.resolvedConstraintOfDistributive = instantiated
					return instantiated
				}
			}
		}
		type_.resolvedConstraintOfDistributive = false
		return nil
	}
	getConstraintFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getConstraintOfDistributiveConditionalType(type_) || getDefaultConstraintOfConditionalType(type_)
	}
	getConstraintOfConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : undefined */ TODO
	}
	getEffectiveConstraintOfIntersection := func(types []Type, targetIsUnion bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var constraints /* TODO(ArrayType): Type[] */ any
		hasDisjointDomainType := false
		for _, t := range types {
			if t.flags & TypeFlagsInstantiable {
				constraint := getConstraintOfType(t)
				/* TODO(WhileStatement): while (constraint && constraint.flags & (TypeFlags.TypeParameter | TypeFlags.Index | TypeFlags.Conditional)) {                     constraint = getConstraintOfType(constraint);                 } */
				if constraint {
					constraints = append(constraints, constraint)
					if targetIsUnion {
						constraints = append(constraints, t)
					}
				}
			} else if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
				hasDisjointDomainType = true
			}
		}
		if constraints && (targetIsUnion || hasDisjointDomainType) {
			if hasDisjointDomainType {
				for _, t := range types {
					if t.flags&TypeFlagsDisjointDomains || isEmptyAnonymousObjectType(t) {
						constraints = append(constraints, t)
					}
				}
			}
			return getNormalizedType(getIntersectionType(constraints, IntersectionFlagsNoConstraintReduction), false)
		}
		return nil
	}
	getBaseConstraintOfType := func(type_ Type) *Type {
		if type_.flags&(TypeFlagsInstantiableNonPrimitive|TypeFlagsUnionOrIntersection|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || isGenericTupleType(type_) {
			constraint := getResolvedBaseConstraint(type_ /* as */ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */)
			return /* TODO(ConditionalExpression): constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : undefined */ TODO
		}
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Index ? stringNumberSymbolType : undefined */ TODO
	}
	getBaseConstraintOrType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getBaseConstraintOfType(type_) || type_
	}
	hasNonCircularBaseConstraint := func(type_ InstantiableType) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getResolvedBaseConstraint(type) !== circularConstraintType */ TODO
	}
	getResolvedBaseConstraint := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) Type {
		if type_.resolvedBaseConstraint {
			return type_.resolvedBaseConstraint
		}
		var stack [] /* TODO(ObjectKeyword): object */ TODO = /* TODO(ArrayLiteralExpression): [] */ TODO
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedBaseConstraint = getImmediateBaseConstraint(type) */ TODO
		getImmediateBaseConstraint := func(t Type) Type {
			if !t.immediateBaseConstraint {
				if !pushTypeResolution(t, TypeSystemPropertyNameImmediateBaseConstraint) {
					return circularConstraintType
				}
				var result TODO
				identity := getRecursionIdentity(t)
				if stack.length < 10 || stack.length < 50 && !contains(stack, identity) {
					stack.push(identity)
					result = computeBaseConstraint(getSimplifiedType(t, false))
					stack.pop()
				}
				if !popTypeResolution() {
					if t.flags & TypeFlagsTypeParameter {
						errorNode := getConstraintDeclaration(t /* as */ /* TODO(TypeReference): TypeParameter */)
						if errorNode {
							diagnostic := error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t))
							if currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode) {
								addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location))
							}
						}
					}
					result = circularConstraintType
				}
				/* TODO(ExpressionStatement): t.immediateBaseConstraint ??= result || noConstraintType; */
			}
			return t.immediateBaseConstraint
		}
		getBaseConstraint := func(t Type) *Type {
			c := getImmediateBaseConstraint(t)
			return /* TODO(ConditionalExpression): c !== noConstraintType && c !== circularConstraintType ? c : undefined */ TODO
		}
		computeBaseConstraint := func(t Type) *Type {
			if t.flags & TypeFlagsTypeParameter {
				constraint := getConstraintFromTypeParameter(t /* as */ /* TODO(TypeReference): TypeParameter */)
				return /* TODO(ConditionalExpression): (t as TypeParameter).isThisType || !constraint ?                     constraint :                     getBaseConstraint(constraint) */ TODO
			}
			if t.flags & TypeFlagsUnionOrIntersection {
				types := (t /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types
				var baseTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
				different := false
				for _, type_ := range types {
					baseType := getBaseConstraint(type_)
					if baseType {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseType !== type */ TODO {
							different = true
						}
						baseTypes.push(baseType)
					} else {
						different = true
					}
				}
				if !different {
					return t
				}
				return /* TODO(ConditionalExpression): t.flags & TypeFlags.Union && baseTypes.length === types.length ? getUnionType(baseTypes) :                     t.flags & TypeFlags.Intersection && baseTypes.length ? getIntersectionType(baseTypes) :                     undefined */ TODO
			}
			if t.flags & TypeFlagsIndex {
				return stringNumberSymbolType
			}
			if t.flags & TypeFlagsTemplateLiteral {
				types := (t /* as */ /* TODO(TypeReference): TemplateLiteralType */).types
				constraints := mapDefined(types, getBaseConstraint)
				return /* TODO(ConditionalExpression): constraints.length === types.length ? getTemplateLiteralType((t as TemplateLiteralType).texts, constraints) : stringType */ TODO
			}
			if t.flags & TypeFlagsStringMapping {
				constraint := getBaseConstraint((t /* as */ /* TODO(TypeReference): StringMappingType */).type_)
				return /* TODO(ConditionalExpression): constraint && constraint !== (t as StringMappingType).type ? getStringMappingType((t as StringMappingType).symbol, constraint) : stringType */ TODO
			}
			if t.flags & TypeFlagsIndexedAccess {
				if isMappedTypeGenericIndexedAccess(t) {
					return getBaseConstraint(substituteIndexedMappedType((t /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType /* as */ /* TODO(TypeReference): MappedType */, (t /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType))
				}
				baseObjectType := getBaseConstraint((t /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType)
				baseIndexType := getBaseConstraint((t /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType)
				baseIndexedAccess := baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, (t /* as */ /* TODO(TypeReference): IndexedAccessType */).accessFlags)
				return baseIndexedAccess && getBaseConstraint(baseIndexedAccess)
			}
			if t.flags & TypeFlagsConditional {
				constraint := getConstraintFromConditionalType(t /* as */ /* TODO(TypeReference): ConditionalType */)
				return constraint && getBaseConstraint(constraint)
			}
			if t.flags & TypeFlagsSubstitution {
				return getBaseConstraint(getSubstitutionIntersection(t /* as */ /* TODO(TypeReference): SubstitutionType */))
			}
			if isGenericTupleType(t) {
				newElements := map_(getElementTypes(t), func(v /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					constraint := v.flags&TypeFlagsTypeParameter && /* TODO(ElementAccessExpression): t.target.elementFlags[i] */ TODO&ElementFlagsVariadic && getBaseConstraint(v) || v
					return /* TODO(ConditionalExpression): constraint !== v && everyType(constraint, c => isArrayOrTupleType(c) && !isGenericTupleType(c)) ? constraint : v */ TODO
				})
				return createTupleType(newElements, t.target.elementFlags, t.target.readonly, t.target.labeledElementDeclarations)
			}
			return t
		}
	}
	getApparentTypeOfIntersectionType := func(type_ IntersectionType, thisArgument Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_ == thisArgument {
			return type_.resolvedApparentType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedApparentType = getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true) */ TODO)
		}
		key := /* TODO(TemplateExpression): `I${getTypeId(type)},${getTypeId(thisArgument)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getTypeWithThisArgument(type, thisArgument, /*needApparentType* / true)) */ TODO
	}
	getResolvedTypeParameterDefault := func(typeParameter TypeParameter) *Type {
		if !typeParameter.default_ {
			if typeParameter.target {
				targetDefault := getResolvedTypeParameterDefault(typeParameter.target)
				typeParameter.default_ = /* TODO(ConditionalExpression): targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType */ TODO
			} else {
				typeParameter.default_ = resolvingDefaultType
				defaultDeclaration := typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
					/* TODO(CallExpression): isTypeParameterDeclaration(decl) */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(PropertyAccessExpression): decl.default */
				})
				defaultType := /* TODO(ConditionalExpression): defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType */ TODO
				if typeParameter.default_ == resolvingDefaultType {
					typeParameter.default_ = defaultType
				}
			}
		} else if typeParameter.default_ == resolvingDefaultType {
			typeParameter.default_ = circularConstraintType
		}
		return typeParameter.default_
	}
	getDefaultFromTypeParameter := func(typeParameter TypeParameter) *Type {
		defaultType := getResolvedTypeParameterDefault(typeParameter)
		return /* TODO(ConditionalExpression): defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : undefined */ TODO
	}
	hasNonCircularTypeParameterDefault := func(typeParameter TypeParameter) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType */ TODO
	}
	hasTypeParameterDefault := func(typeParameter TypeParameter) bool {
		return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, func(decl /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
			/* TODO(CallExpression): isTypeParameterDeclaration(decl) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(PropertyAccessExpression): decl.default */
		}))
	}
	getApparentTypeOfMappedType := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedApparentType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type) */ TODO)
	}
	getResolvedApparentTypeOfMappedType := func(type_ MappedType) Type {
		target := ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): type.target ?? type */ TODO) /* as */ /* TODO(TypeReference): MappedType */
		typeVariable := getHomomorphicTypeVariable(target)
		if typeVariable && !target.declaration.nameType {
			modifiersType := getModifiersTypeFromMappedType(type_)
			baseConstraint := /* TODO(ConditionalExpression): isGenericMappedType(modifiersType) ? getApparentTypeOfMappedType(modifiersType) : getBaseConstraintOfType(modifiersType) */ TODO
			if baseConstraint && everyType(baseConstraint, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(CallExpression): isArrayOrTupleType(t) */
				/* TODO(BarBarToken): || */
				/* TODO(CallExpression): isArrayOrTupleOrIntersection(t) */
			}) {
				return instantiateType(target, prependTypeMapping(typeVariable, baseConstraint, type_.mapper))
			}
		}
		return type_
	}
	isArrayOrTupleOrIntersection := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags & TypeFlagsIntersection) && every((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isArrayOrTupleType)
	}
	isMappedTypeGenericIndexedAccess := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		var objectType TODO
		return !!(type_.flags&TypeFlagsIndexedAccess && getObjectFlags( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): objectType = (type as IndexedAccessType).objectType */ TODO)&ObjectFlagsMapped && !isGenericMappedType(objectType) && isGenericIndexType((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType) && !(getMappedTypeModifiers(objectType /* as */ /* TODO(TypeReference): MappedType */) & MappedTypeModifiersExcludeOptional) && !(objectType /* as */ /* TODO(TypeReference): MappedType */).declaration.nameType)
	}
	getApparentType := func(type_ Type) Type {
		t := /* TODO(ConditionalExpression): type.flags & TypeFlags.Instantiable ? getBaseConstraintOfType(type) || unknownType : type */ TODO
		objectFlags := getObjectFlags(t)
		return /* TODO(ConditionalExpression): objectFlags & ObjectFlags.Mapped ? getApparentTypeOfMappedType(t as MappedType) :             objectFlags & ObjectFlags.Reference && t !== type ? getTypeWithThisArgument(t, type) :             t.flags & TypeFlags.Intersection ? getApparentTypeOfIntersectionType(t as IntersectionType, type) :             t.flags & TypeFlags.StringLike ? globalStringType :             t.flags & TypeFlags.NumberLike ? globalNumberType :             t.flags & TypeFlags.BigIntLike ? getGlobalBigIntType() :             t.flags & TypeFlags.BooleanLike ? globalBooleanType :             t.flags & TypeFlags.ESSymbolLike ? getGlobalESSymbolType() :             t.flags & TypeFlags.NonPrimitive ? emptyObjectType :             t.flags & TypeFlags.Index ? stringNumberSymbolType :             t.flags & TypeFlags.Unknown && !strictNullChecks ? emptyObjectType :             t */ TODO
	}
	getReducedApparentType := func(type_ Type) Type {
		return getReducedType(getApparentType(getReducedType(type_)))
	}
	createUnionOrIntersectionProperty := func(containingType UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		var singleProp *Symbol
		var propSet *Map[SymbolId, Symbol]
		var indexTypes /* TODO(ArrayType): Type[] */ any
		isUnion := containingType.flags & TypeFlagsUnion
		var optionalFlag *SymbolFlags
		syntheticFlag := CheckFlagsSyntheticMethod
		checkFlags := /* TODO(ConditionalExpression): isUnion ? 0 : CheckFlags.Readonly */ TODO
		mergedInstantiations := false
		for _, current := range containingType.types {
			type_ := getApparentType(current)
			if !(isErrorType(type_) || type_.flags&TypeFlagsNever) {
				prop := getPropertyOfType(type_, name, skipObjectFunctionPropertyAugment)
				modifiers := /* TODO(ConditionalExpression): prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0 */ TODO
				if prop {
					if prop.flags & SymbolFlagsClassMember {
						/* TODO(ExpressionStatement): optionalFlag ??= isUnion ? SymbolFlags.None : SymbolFlags.Optional; */
						if isUnion {
							optionalFlag |= prop.flags & SymbolFlagsOptional
						} else {
							optionalFlag &= prop.flags
						}
					}
					if !singleProp {
						singleProp = prop
					} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prop !== singleProp */ TODO {
						isInstantiation := (getTargetSymbol(prop) || prop) == (getTargetSymbol(singleProp) || singleProp)
						if isInstantiation && compareProperties(singleProp, prop, func(a /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, b /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.False | import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.True */ TODO {
							/* TODO(BinaryExpression): a === b */
							/* TODO(QuestionToken): ? */
							/* TODO(PropertyAccessExpression): Ternary.True */
							/* TODO(ColonToken): : */
							/* TODO(PropertyAccessExpression): Ternary.False */
						}) == TernaryTrue {
							mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent))
						} else {
							if !propSet {
								propSet = /* TODO(NewExpression): new Map<SymbolId, Symbol>() */ TODO
								propSet.set(getSymbolId(singleProp), singleProp)
							}
							id := getSymbolId(prop)
							if !propSet.has(id) {
								propSet.set(id, prop)
							}
						}
					}
					if isUnion && isReadonlySymbol(prop) {
						checkFlags |= CheckFlagsReadonly
					} else if !isUnion && !isReadonlySymbol(prop) {
						checkFlags &= ~CheckFlagsReadonly
					}
					checkFlags |= ( /* TODO(ConditionalExpression): !(modifiers & ModifierFlags.NonPublicAccessibilityModifier) ? CheckFlags.ContainsPublic : 0 */ TODO) | ( /* TODO(ConditionalExpression): modifiers & ModifierFlags.Protected ? CheckFlags.ContainsProtected : 0 */ TODO) | ( /* TODO(ConditionalExpression): modifiers & ModifierFlags.Private ? CheckFlags.ContainsPrivate : 0 */ TODO) | ( /* TODO(ConditionalExpression): modifiers & ModifierFlags.Static ? CheckFlags.ContainsStatic : 0 */ TODO)
					if !isPrototypeProperty(prop) {
						syntheticFlag = CheckFlagsSyntheticProperty
					}
				} else if isUnion {
					indexInfo := !isLateBoundName(name) && getApplicableIndexInfoForName(type_, name)
					if indexInfo {
						checkFlags |= CheckFlagsWritePartial | ( /* TODO(ConditionalExpression): indexInfo.isReadonly ? CheckFlags.Readonly : 0 */ TODO)
						indexTypes = append(indexTypes /* TODO(ConditionalExpression): isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type */, TODO)
					} else if isObjectLiteralType(type_) && !(getObjectFlags(type_) & ObjectFlagsContainsSpread) {
						checkFlags |= CheckFlagsWritePartial
						indexTypes = append(indexTypes, undefinedType)
					} else {
						checkFlags |= CheckFlagsReadPartial
					}
				}
			}
		}
		if !singleProp || isUnion && (propSet || checkFlags&CheckFlagsPartial) && checkFlags&(CheckFlagsContainsPrivate|CheckFlagsContainsProtected) && !(propSet && getCommonDeclarationsOfSymbols(propSet.values())) {
			return nil
		}
		if !propSet && !(checkFlags & CheckFlagsReadPartial) && !indexTypes {
			if mergedInstantiations {
				links := tryCast(singleProp, isTransientSymbol).links
				clone := createSymbolWithType(singleProp, links.type_)
				clone.parent = singleProp.valueDeclaration.symbol.parent
				clone.links.containingType = containingType
				clone.links.mapper = links.mapper
				clone.links.writeType = getWriteTypeOfSymbol(singleProp)
				return clone
			} else {
				return singleProp
			}
		}
		props := /* TODO(ConditionalExpression): propSet ? arrayFrom(propSet.values()) : [singleProp] */ TODO
		var declarations /* TODO(ArrayType): Declaration[] */ any
		var firstType *Type
		var nameType *Type
		var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var writeTypes /* TODO(ArrayType): Type[] */ any
		var firstValueDeclaration Declaration
		hasNonUniformValueDeclaration := false
		for _, prop := range props {
			if !firstValueDeclaration {
				firstValueDeclaration = prop.valueDeclaration
			} else if prop.valueDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prop.valueDeclaration !== firstValueDeclaration */ TODO {
				hasNonUniformValueDeclaration = true
			}
			declarations = addRange(declarations, prop.declarations)
			type_ := getTypeOfSymbol(prop)
			if !firstType {
				firstType = type_
				nameType = getSymbolLinks(prop).nameType
			}
			writeType := getWriteTypeOfSymbol(prop)
			if writeTypes || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): writeType !== type */ TODO {
				writeTypes = append( /* TODO(ConditionalExpression): !writeTypes ? propTypes.slice() : writeTypes */ TODO, writeType)
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== firstType */ TODO {
				checkFlags |= CheckFlagsHasNonUniformType
			}
			if isLiteralType(type_) || isPatternLiteralType(type_) {
				checkFlags |= CheckFlagsHasLiteralType
			}
			if type_.flags&TypeFlagsNever && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== uniqueLiteralType */ TODO {
				checkFlags |= CheckFlagsHasNeverType
			}
			propTypes.push(type_)
		}
		addRange(propTypes, indexTypes)
		result := createSymbol(SymbolFlagsProperty|( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): optionalFlag ?? 0 */ TODO), name, syntheticFlag|checkFlags)
		result.links.containingType = containingType
		if !hasNonUniformValueDeclaration && firstValueDeclaration {
			result.valueDeclaration = firstValueDeclaration
			if firstValueDeclaration.symbol.parent {
				result.parent = firstValueDeclaration.symbol.parent
			}
		}
		result.declarations = declarations
		result.links.nameType = nameType
		if propTypes.length > 2 {
			result.links.checkFlags |= CheckFlagsDeferredType
			result.links.deferralParent = containingType
			result.links.deferralConstituents = propTypes
			result.links.deferralWriteConstituents = writeTypes
		} else {
			result.links.type_ = /* TODO(ConditionalExpression): isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes) */ TODO
			if writeTypes {
				result.links.writeType = /* TODO(ConditionalExpression): isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes) */ TODO
			}
		}
		return result
	}
	getUnionOrIntersectionProperty := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?             type.propertyCacheWithoutObjectFunctionPropertyAugment?.get(name) :             type.propertyCache?.get(name) */ TODO
		if !property {
			property = createUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
			if property {
				properties := /* TODO(ConditionalExpression): skipObjectFunctionPropertyAugment ?                     type.propertyCacheWithoutObjectFunctionPropertyAugment ||= createSymbolTable() :                     type.propertyCache ||= createSymbolTable() */ TODO
				properties.set(name, property)
				if skipObjectFunctionPropertyAugment && !(getCheckFlags(property) & CheckFlagsPartial) && !type_.propertyCache.get(name) {
					properties := /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): type.propertyCache ||= createSymbolTable() */ TODO
					properties.set(name, property)
				}
			}
		}
		return property
	}
	getCommonDeclarationsOfSymbols := func(symbols Iterable[Symbol]) /* TODO(undefined): Set<import("/home/jabaile/work/TypeScript/src/compiler/types").Node> | undefined */ TODO {
		var commonDeclarations *Set[Node]
		for _, symbol := range symbols {
			if !symbol.declarations {
				return nil
			}
			if !commonDeclarations {
				commonDeclarations = /* TODO(NewExpression): new Set(symbol.declarations) */ TODO
				/* TODO(ContinueStatement): continue; */
			}
			commonDeclarations.forEach(func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) {
				if !contains(symbol.declarations, declaration) {
					/* TODO(NonNullExpression): commonDeclarations! */ TODO.delete(declaration)
				}
			})
			if commonDeclarations.size == 0 {
				return nil
			}
		}
		return commonDeclarations
	}
	getPropertyOfUnionOrIntersectionType := func(type_ UnionOrIntersectionType, name __String, skipObjectFunctionPropertyAugment bool) *Symbol {
		property := getUnionOrIntersectionProperty(type_, name, skipObjectFunctionPropertyAugment)
		return /* TODO(ConditionalExpression): property && !(getCheckFlags(property) & CheckFlags.ReadPartial) ? property : undefined */ TODO
	}
	getReducedType := func(type_ Type) Type {
		if type_.flags&TypeFlagsUnion && (type_ /* as */ /* TODO(TypeReference): UnionType */).objectFlags&ObjectFlagsContainsIntersections {
			return (type_ /* as */ /* TODO(TypeReference): UnionType */).resolvedReducedType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as UnionType).resolvedReducedType = getReducedUnionType(type as UnionType) */ TODO)
		} else if type_.flags & TypeFlagsIntersection {
			if !((type_ /* as */ /* TODO(TypeReference): IntersectionType */).objectFlags & ObjectFlagsIsNeverIntersectionComputed) {
				(type_ /* as */ /* TODO(TypeReference): IntersectionType */).objectFlags |= ObjectFlagsIsNeverIntersectionComputed | ( /* TODO(ConditionalExpression): some(getPropertiesOfUnionOrIntersectionType(type as IntersectionType), isNeverReducedProperty) ? ObjectFlags.IsNeverIntersection : 0 */ TODO)
			}
			return /* TODO(ConditionalExpression): (type as IntersectionType).objectFlags & ObjectFlags.IsNeverIntersection ? neverType : type */ TODO
		}
		return type_
	}
	getReducedUnionType := func(unionType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reducedTypes := sameMap(unionType.types, getReducedType)
		if reducedTypes == unionType.types {
			return unionType
		}
		reduced := getUnionType(reducedTypes)
		if reduced.flags & TypeFlagsUnion {
			(reduced /* as */ /* TODO(TypeReference): UnionType */).resolvedReducedType = reduced
		}
		return reduced
	}
	isNeverReducedProperty := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
		return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop)
	}
	isDiscriminantWithNeverType := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
		return !(prop.flags & SymbolFlagsOptional) && (getCheckFlags(prop)&(CheckFlagsDiscriminant|CheckFlagsHasNeverType)) == CheckFlagsDiscriminant && !!(getTypeOfSymbol(prop).flags & TypeFlagsNever)
	}
	isConflictingPrivateProperty := func(prop Symbol) /* TODO(undefined): boolean */ TODO {
		return !prop.valueDeclaration && !!(getCheckFlags(prop) & CheckFlagsContainsPrivate)
	}
	isGenericReducibleType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnion && (type_ /* as */ /* TODO(TypeReference): UnionType */).objectFlags&ObjectFlagsContainsIntersections && some((type_ /* as */ /* TODO(TypeReference): UnionType */).types, isGenericReducibleType) || type_.flags&TypeFlagsIntersection && isReducibleIntersection(type_ /* as */ /* TODO(TypeReference): IntersectionType */))
	}
	isReducibleIntersection := func(type_ IntersectionType) /* TODO(undefined): boolean */ TODO {
		uniqueFilled := type_.uniqueLiteralFilledInstantiation || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper) */ TODO)
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getReducedType(uniqueFilled) !== uniqueFilled */ TODO
	}
	elaborateNeverIntersection := func(errorInfo *DiagnosticMessageChain, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
		if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsNeverIntersection {
			neverProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): IntersectionType */), isDiscriminantWithNeverType)
			if neverProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type_, nil, TypeFormatFlagsNoTypeReduction), symbolToString(neverProp))
			}
			privateProp := find(getPropertiesOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): IntersectionType */), isConflictingPrivateProperty)
			if privateProp {
				return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type_, nil, TypeFormatFlagsNoTypeReduction), symbolToString(privateProp))
			}
		}
		return errorInfo
	}
	getPropertyOfType := func(type_ Type, name __String, skipObjectFunctionPropertyAugment bool, includeTypeOnlyMembers bool) *Symbol {
		type_ = getReducedApparentType(type_)
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			symbol := resolved.members.get(name)
			if symbol && !includeTypeOnlyMembers && type_.symbol.flags&SymbolFlagsValueModule && getSymbolLinks(type_.symbol).typeOnlyExportStarMap.has(name) {
				return nil
			}
			if symbol && symbolIsValue(symbol, includeTypeOnlyMembers) {
				return symbol
			}
			if skipObjectFunctionPropertyAugment {
				/* TODO(Identifier): undefined */
			}
			functionType := /* TODO(ConditionalExpression): resolved === anyFunctionType ? globalFunctionType :                 resolved.callSignatures.length ? globalCallableFunctionType :                 resolved.constructSignatures.length ? globalNewableFunctionType :                 undefined */ TODO
			if functionType {
				symbol := getPropertyOfObjectType(functionType, name)
				if symbol {
					return symbol
				}
			}
			return getPropertyOfObjectType(globalObjectType, name)
		}
		if type_.flags & TypeFlagsIntersection {
			prop := getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, true)
			if prop {
				return prop
			}
			if !skipObjectFunctionPropertyAugment {
				return getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
			}
			return nil
		}
		if type_.flags & TypeFlagsUnion {
			return getPropertyOfUnionOrIntersectionType(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, name, skipObjectFunctionPropertyAugment)
		}
		return nil
	}
	getSignaturesOfStructuredType := func(type_ Type, kind SignatureKind) []Signature {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			return /* TODO(ConditionalExpression): kind === SignatureKind.Call ? resolved.callSignatures : resolved.constructSignatures */ TODO
		}
		return emptyArray
	}
	getSignaturesOfType := func(type_ Type, kind SignatureKind) []Signature {
		result := getSignaturesOfStructuredType(getReducedApparentType(type_), kind)
		if kind == SignatureKindCall && !length(result) && type_.flags&TypeFlagsUnion {
			if (type_ /* as */ /* TODO(TypeReference): UnionType */).arrayFallbackSignatures {
				return /* TODO(NonNullExpression): (type as UnionType).arrayFallbackSignatures! */ TODO
			}
			var memberName __String
			if everyType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(BinaryExpression): !!t.symbol?.parent && isArrayOrTupleSymbol(t.symbol.parent) */
				/* TODO(AmpersandAmpersandToken): && */
				/* TODO(ParenthesizedExpression): (!memberName ? (memberName = t.symbol.escapedName, true) : memberName === t.symbol.escapedName) */
			}) {
				arrayArg := mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(Identifier): getMappedType */
					/* TODO(ElementAccessExpression): (isReadonlyArraySymbol(t.symbol.parent) ? globalReadonlyArrayType : globalArrayType).typeParameters![0] */
					/* TODO(NonNullExpression): (t as AnonymousType).mapper! */
				})
				arrayType := createArrayType(arrayArg, someType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): isReadonlyArraySymbol */
					/* TODO(PropertyAccessExpression): t.symbol.parent */
				}))
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as UnionType).arrayFallbackSignatures = getSignaturesOfType(getTypeOfPropertyOfType(arrayType, memberName!)!, kind) */ TODO
			}
			(type_ /* as */ /* TODO(TypeReference): UnionType */).arrayFallbackSignatures = result
		}
		return result
	}
	isArrayOrTupleSymbol := func(symbol *Symbol) /* TODO(undefined): boolean */ TODO {
		if !symbol || !globalArrayType.symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalArrayType.symbol) || !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	isReadonlyArraySymbol := func(symbol *Symbol) /* TODO(undefined): boolean */ TODO {
		if !symbol || !globalReadonlyArrayType.symbol {
			return false
		}
		return !!getSymbolIfSameReference(symbol, globalReadonlyArrayType.symbol)
	}
	findIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
		return find(indexInfos, func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PropertyAccessExpression): info.keyType */
			/* TODO(EqualsEqualsEqualsToken): === */
			/* TODO(Identifier): keyType */
		})
	}
	findApplicableIndexInfo := func(indexInfos []IndexInfo, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo | undefined */ TODO {
		var stringIndexInfo *IndexInfo
		var applicableInfo *IndexInfo
		var applicableInfos /* TODO(ArrayType): IndexInfo[] */ any
		for _, info := range indexInfos {
			if info.keyType == stringType {
				stringIndexInfo = info
			} else if isApplicableIndexType(keyType, info.keyType) {
				if !applicableInfo {
					applicableInfo = info
				} else {
					(applicableInfos || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): applicableInfos = [applicableInfo] */ TODO)).push(info)
				}
			}
		}
		return /* TODO(ConditionalExpression): applicableInfos ? createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, info => info.type)), reduceLeft(applicableInfos, (isReadonly, info) => isReadonly && info.isReadonly, /*initial* / true)) :             applicableInfo ? applicableInfo :             stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo :             undefined */ TODO
	}
	isApplicableIndexType := func(source Type, target Type) bool {
		return isTypeAssignableTo(source, target) || target == stringType && isTypeAssignableTo(source, numberType) || target == numberType && (source == numericStringType || !!(source.flags&TypeFlagsStringLiteral) && isNumericLiteralName((source /* as */ /* TODO(TypeReference): StringLiteralType */).value))
	}
	getIndexInfosOfStructuredType := func(type_ Type) []IndexInfo {
		if type_.flags & TypeFlagsStructuredType {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			return resolved.indexInfos
		}
		return emptyArray
	}
	getIndexInfosOfType := func(type_ Type) []IndexInfo {
		return getIndexInfosOfStructuredType(getReducedApparentType(type_))
	}
	getIndexInfoOfType := func(type_ Type, keyType Type) *IndexInfo {
		return findIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getIndexTypeOfType := func(type_ Type, keyType Type) *Type {
		return getIndexInfoOfType(type_, keyType).type_
	}
	getApplicableIndexInfos := func(type_ Type, keyType Type) []IndexInfo {
		return getIndexInfosOfType(type_).filter(func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isApplicableIndexType */
			/* TODO(Identifier): keyType */
			/* TODO(PropertyAccessExpression): info.keyType */
		})
	}
	getApplicableIndexInfo := func(type_ Type, keyType Type) *IndexInfo {
		return findApplicableIndexInfo(getIndexInfosOfType(type_), keyType)
	}
	getApplicableIndexInfoForName := func(type_ Type, name __String) *IndexInfo {
		return getApplicableIndexInfo(type_ /* TODO(ConditionalExpression): isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)) */, TODO)
	}
	getTypeParametersFromDeclaration := func(declaration DeclarationWithTypeParameters) /* TODO(TypeOperator): readonly TypeParameter[] */ any {
		var result /* TODO(ArrayType): TypeParameter[] */ any
		for _, node := range getEffectiveTypeParameterDeclarations(declaration) {
			result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol))
		}
		return /* TODO(ConditionalExpression): result?.length ? result             : isFunctionDeclaration(declaration) ? getSignatureOfTypeTag(declaration)?.typeParameters             : undefined */ TODO
	}
	symbolsToArray := func(symbols SymbolTable) []Symbol {
		var result []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		symbols.forEach(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
			if !isReservedMemberName(id) {
				result.push(symbol)
			}
		})
		return result
	}
	tryFindAmbientModule := func(moduleName string, withAugmentations bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if isExternalModuleNameRelative(moduleName) {
			return nil
		}
		symbol := getSymbol(globals /* TODO(PlusToken): + */ /* TODO(BinaryExpression): '"' + moduleName + '"' */, TODO /* as */ /* TODO(TypeReference): __String */, SymbolFlagsValueModule)
		return /* TODO(ConditionalExpression): symbol && withAugmentations ? getMergedSymbol(symbol) : symbol */ TODO
	}
	hasEffectiveQuestionToken := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO(undefined): boolean */ TODO {
		return hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isParameter(node) && isJSDocOptionalParameter(node)
	}
	isOptionalParameter := func(node /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag | JSDocPropertyTag */ any) /* TODO(undefined): boolean */ TODO {
		if hasEffectiveQuestionToken(node) {
			return true
		}
		if !isParameter(node) {
			return false
		}
		if node.initializer {
			signature := getSignatureFromDeclaration(node.parent)
			parameterIndex := node.parent.parameters.indexOf(node)
			Debug.assert(parameterIndex >= 0)
			return parameterIndex >= getMinArgumentCount(signature, MinArgumentCountFlagsStrongArityForUntypedJS|MinArgumentCountFlagsVoidIsNonOptional)
		}
		iife := getImmediatelyInvokedFunctionExpression(node.parent)
		if iife {
			return !node.type_ && !node.dotDotDotToken && node.parent.parameters.indexOf(node) >= getEffectiveCallArguments(iife).length
		}
		return false
	}
	isOptionalPropertyDeclaration := func(node Declaration) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").QuestionToken | undefined */ TODO {
		return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken
	}
	createTypePredicate := func(kind TypePredicateKind, parameterName /* TODO(StringKeyword): string */ any, parameterIndex /* TODO(NumberKeyword): number */ any, type_ *Type) TypePredicate {
		return /* TODO(ObjectLiteralExpression): { kind, parameterName, parameterIndex, type } */ TODO /* as */ /* TODO(TypeReference): TypePredicate */
	}
	getMinTypeArgumentCount := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any) number {
		minTypeArgumentCount := 0
		if typeParameters {
			/* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {                 if (!hasTypeParameterDefault(typeParameters[i])) {                     minTypeArgumentCount = i + 1;                 }             } */
		}
		return minTypeArgumentCount
	}
	// OVERLOAD: fillMissingTypeArguments := func(typeArguments []Type, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) []Type
	// OVERLOAD: fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO(ArrayType): Type[] */ any
	fillMissingTypeArguments := func(typeArguments /* TODO(TypeOperator): readonly Type[] */ any, typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, minTypeArgumentCount number, isJavaScriptImplicitAny bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		numTypeParameters := length(typeParameters)
		if !numTypeParameters {
			return /* TODO(ArrayLiteralExpression): [] */ TODO
		}
		numTypeArguments := length(typeArguments)
		if isJavaScriptImplicitAny || (numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) {
			result := /* TODO(ConditionalExpression): typeArguments ? typeArguments.slice() : [] */ TODO
			/* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 result[i] = errorType;             } */
			baseDefaultType := getDefaultTypeArgumentType(isJavaScriptImplicitAny)
			/* TODO(ForStatement): for (let i = numTypeArguments; i < numTypeParameters; i++) {                 let defaultType = getDefaultFromTypeParameter(typeParameters![i]);                 if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {                     defaultType = anyType;                 }                 result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters!, result)) : baseDefaultType;             } */
			result.length = /* TODO(NonNullExpression): typeParameters! */ TODO.length
			return result
		}
		return typeArguments && typeArguments.slice()
	}
	getSignatureFromDeclaration := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) Signature {
		links := getNodeLinks(declaration)
		if !links.resolvedSignature {
			var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
			flags := SignatureFlagsNone
			minArgumentCount := 0
			var thisParameter *Symbol
			var thisTag *JSDocThisTag = /* TODO(ConditionalExpression): isInJSFile(declaration) ? getJSDocThisTag(declaration) : undefined */ TODO
			hasThisParameter := false
			iife := getImmediatelyInvokedFunctionExpression(declaration)
			isJSConstructSignature := isJSDocConstructSignature(declaration)
			isUntypedSignatureInJSFile := !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration)
			if isUntypedSignatureInJSFile {
				flags |= SignatureFlagsIsUntypedSignatureInJSFile
			}
			/* TODO(ForStatement): for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {                 const param = declaration.parameters[i];                 if (isInJSFile(param) && isJSDocThisTag(param)) {                     thisTag = param;                     continue;                 }                  let paramSymbol = param.symbol;                 const type = isJSDocParameterTag(param) ? (param.typeExpression && param.typeExpression.type) : param.type;                 // Include parameter symbol instead of property symbol in the signature                 if (paramSymbol && !!(paramSymbol.flags & SymbolFlags.Property) && !isBindingPattern(param.name)) {                     const resolvedSymbol = resolveName(param, paramSymbol.escapedName, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / false);                     paramSymbol = resolvedSymbol!;                 }                 if (i === 0 && paramSymbol.escapedName === InternalSymbolName.This) {                     hasThisParameter = true;                     thisParameter = param.symbol;                 }                 else {                     parameters.push(paramSymbol);                 }                  if (type && type.kind === SyntaxKind.LiteralType) {                     flags |= SignatureFlags.HasLiteralTypes;                 }                  // Record a new minimum argument count if this is not an optional parameter                 const isOptionalParameter = hasEffectiveQuestionToken(param) ||                     isParameter(param) && param.initializer || isRestParameter(param) ||                     iife && parameters.length > iife.arguments.length && !type;                 if (!isOptionalParameter) {                     minArgumentCount = parameters.length;                 }             } */
			if (declaration.kind == SyntaxKindGetAccessor || declaration.kind == SyntaxKindSetAccessor) && hasBindableName(declaration) && (!hasThisParameter || !thisParameter) {
				otherKind := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor */ TODO
				other := getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind)
				if other {
					thisParameter = getAnnotatedAccessorThisParameter(other)
				}
			}
			if thisTag && thisTag.typeExpression {
				thisParameter = createSymbolWithType(createSymbol(SymbolFlagsFunctionScopedVariable, InternalSymbolNameThis), getTypeFromTypeNode(thisTag.typeExpression))
			}
			hostDeclaration := /* TODO(ConditionalExpression): isJSDocSignature(declaration) ? getEffectiveJSDocHost(declaration) : declaration */ TODO
			classType := /* TODO(ConditionalExpression): hostDeclaration && isConstructorDeclaration(hostDeclaration) ?                 getDeclaredTypeOfClassOrInterface(getMergedSymbol((hostDeclaration.parent as ClassDeclaration).symbol))                 : undefined */ TODO
			typeParameters := /* TODO(ConditionalExpression): classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration) */ TODO
			if hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters) {
				flags |= SignatureFlagsHasRestParameter
			}
			if isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, ModifierFlagsAbstract) || isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, ModifierFlagsAbstract) {
				flags |= SignatureFlagsAbstract
			}
			links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, nil, nil, minArgumentCount, flags)
		}
		return links.resolvedSignature
	}
	maybeAddJsSyntheticRestParameter := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any, parameters []Symbol) bool {
		if isJSDocSignature(declaration) || !containsArgumentsReference(declaration) {
			return false
		}
		lastParam := lastOrUndefined(declaration.parameters)
		lastParamTags := /* TODO(ConditionalExpression): lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag) */ TODO
		lastParamVariadicType := firstDefined(lastParamTags, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocParameterTag */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocVariadicType | undefined */ TODO {
			/* TODO(BinaryExpression): p.typeExpression && isJSDocVariadicType(p.typeExpression.type) */
			/* TODO(QuestionToken): ? */
			/* TODO(PropertyAccessExpression): p.typeExpression.type */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): undefined */
		})
		syntheticArgsSymbol := createSymbol(SymbolFlagsVariable, "args" /* as */ /* TODO(TypeReference): __String */, CheckFlagsRestParameter)
		if lastParamVariadicType {
			syntheticArgsSymbol.links.type_ = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type_))
		} else {
			syntheticArgsSymbol.links.checkFlags |= CheckFlagsDeferredType
			syntheticArgsSymbol.links.deferralParent = neverType
			syntheticArgsSymbol.links.deferralConstituents = /* TODO(ArrayLiteralExpression): [anyArrayType] */ TODO
			syntheticArgsSymbol.links.deferralWriteConstituents = /* TODO(ArrayLiteralExpression): [anyArrayType] */ TODO
		}
		if lastParamVariadicType {
			parameters.pop()
		}
		parameters.push(syntheticArgsSymbol)
		return true
	}
	getSignatureOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		if !(isInJSFile(node) && isFunctionLikeDeclaration(node)) {
			/* TODO(Identifier): undefined */
		}
		typeTag := getJSDocTypeTag(node)
		return typeTag.typeExpression && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
	}
	getParameterTypeOfTypeTag := func(func_ FunctionLikeDeclaration, parameter ParameterDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSignatureOfTypeTag(func_)
		if !signature {
			/* TODO(Identifier): undefined */
		}
		pos := func_.parameters.indexOf(parameter)
		return /* TODO(ConditionalExpression): parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos) */ TODO
	}
	getReturnTypeOfTypeTag := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSignatureOfTypeTag(node)
		return signature && getReturnTypeOfSignature(signature)
	}
	containsArgumentsReference := func(declaration SignatureDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.containsArgumentsReference == nil {
			if links.flags & NodeCheckFlagsCaptureArguments {
				links.containsArgumentsReference = true
			} else {
				links.containsArgumentsReference = traverse( /* TODO(NonNullExpression): (declaration as FunctionLikeDeclaration).body! */ TODO)
			}
		}
		return links.containsArgumentsReference
		traverse := func(node Node) bool {
			if !node {
				/* TODO(FalseKeyword): false */
			}
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.Identifier:                     return (node as Identifier).escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node as Identifier) === argumentsSymbol;                  case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     return (node as NamedDeclaration).name!.kind === SyntaxKind.ComputedPropertyName                         && traverse((node as NamedDeclaration).name!);                  case SyntaxKind.PropertyAccessExpression:                 case SyntaxKind.ElementAccessExpression:                     return traverse((node as PropertyAccessExpression | ElementAccessExpression).expression);                  case SyntaxKind.PropertyAssignment:                     return traverse((node as PropertyAssignment).initializer);                  default:                     return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse);             } */
		}
	}
	getSignaturesOfSymbol := func(symbol *Symbol) []Signature {
		if !symbol || !symbol.declarations {
			/* TODO(Identifier): emptyArray */
		}
		var result []Signature = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < symbol.declarations.length; i++) {             const decl = symbol.declarations[i];             if (!isFunctionLike(decl)) continue;             // Don't include signature if node is the implementation of an overloaded function. A node is considered             // an implementation node if it has a body and the previous node is of the same kind and immediately             // precedes the implementation node (i.e. has the same parent and ends where the implementation starts).             if (i > 0 && (decl as FunctionLikeDeclaration).body) {                 const previous = symbol.declarations[i - 1];                 if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {                     continue;                 }             }             if (isInJSFile(decl) && decl.jsDoc) {                 const tags = getJSDocOverloadTags(decl);                 if (length(tags)) {                     for (const tag of tags) {                         const jsDocSignature = tag.typeExpression;                         if (jsDocSignature.type === undefined && !isConstructorDeclaration(decl)) {                             reportImplicitAny(jsDocSignature, anyType);                         }                         result.push(getSignatureFromDeclaration(jsDocSignature));                     }                     continue;                 }             }             // If this is a function or method declaration, get the signature from the @type tag for the sake of optional parameters.             // Exclude contextually-typed kinds because we already apply the @type tag to the context, plus applying it here to the initializer would supress checks that the two are compatible.             result.push(                 (!isFunctionExpressionOrArrowFunction(decl) &&                     !isObjectLiteralMethod(decl) &&                     getSignatureOfTypeTag(decl)) ||                     getSignatureFromDeclaration(decl),             );         } */
		return result
	}
	resolveExternalModuleTypeByLiteral := func(name StringLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		moduleSym := resolveExternalModuleName(name, name)
		if moduleSym {
			resolvedModuleSymbol := resolveExternalModuleSymbol(moduleSym)
			if resolvedModuleSymbol {
				return getTypeOfSymbol(resolvedModuleSymbol)
			}
		}
		return anyType
	}
	getThisTypeOfSignature := func(signature Signature) *Type {
		if signature.thisParameter {
			return getTypeOfSymbol(signature.thisParameter)
		}
	}
	getTypePredicateOfSignature := func(signature Signature) *TypePredicate {
		if !signature.resolvedTypePredicate {
			if signature.target {
				targetTypePredicate := getTypePredicateOfSignature(signature.target)
				signature.resolvedTypePredicate = /* TODO(ConditionalExpression): targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper!) : noTypePredicate */ TODO
			} else if signature.compositeSignatures {
				signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate
			} else {
				type_ := signature.declaration && getEffectiveReturnTypeNode(signature.declaration)
				var jsdocPredicate *TypePredicate
				if !type_ {
					jsdocSignature := getSignatureOfTypeTag( /* TODO(NonNullExpression): signature.declaration! */ TODO)
					if jsdocSignature && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): signature !== jsdocSignature */ TODO {
						jsdocPredicate = getTypePredicateOfSignature(jsdocSignature)
					}
				}
				if type_ || jsdocPredicate {
					signature.resolvedTypePredicate = /* TODO(ConditionalExpression): type && isTypePredicateNode(type) ?                         createTypePredicateFromTypePredicateNode(type, signature) :                         jsdocPredicate || noTypePredicate */ TODO
				} else if signature.declaration && isFunctionLikeDeclaration(signature.declaration) && (!signature.resolvedReturnType || signature.resolvedReturnType.flags&TypeFlagsBoolean) && getParameterCount(signature) > 0 {
					TODO_IDENTIFIER := signature
					signature.resolvedTypePredicate = noTypePredicate
					signature.resolvedTypePredicate = getTypePredicateFromBody(declaration) || noTypePredicate
				} else {
					signature.resolvedTypePredicate = noTypePredicate
				}
			}
			Debug.assert(!!signature.resolvedTypePredicate)
		}
		return /* TODO(ConditionalExpression): signature.resolvedTypePredicate === noTypePredicate ? undefined : signature.resolvedTypePredicate */ TODO
	}
	createTypePredicateFromTypePredicateNode := func(node TypePredicateNode, signature Signature) TypePredicate {
		parameterName := node.parameterName
		type_ := node.type_ && getTypeFromTypeNode(node.type_)
		return /* TODO(ConditionalExpression): parameterName.kind === SyntaxKind.ThisType ?             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsThis : TypePredicateKind.This, /*parameterName* / undefined, /*parameterIndex* / undefined, type) :             createTypePredicate(node.assertsModifier ? TypePredicateKind.AssertsIdentifier : TypePredicateKind.Identifier, parameterName.escapedText as string, findIndex(signature.parameters, p => p.escapedName === parameterName.escapedText), type) */ TODO
	}
	getUnionOrIntersectionType := func(types []Type, kind *TypeFlags, unionReduction UnionReduction) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): kind !== TypeFlags.Intersection ? getUnionType(types, unionReduction) : getIntersectionType(types) */ TODO
	}
	getReturnTypeOfSignature := func(signature Signature) Type {
		if !signature.resolvedReturnType {
			if !pushTypeResolution(signature, TypeSystemPropertyNameResolvedReturnType) {
				return errorType
			}
			type_ := /* TODO(ConditionalExpression): signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) :                 signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, UnionReduction.Subtype), signature.mapper) :                 getReturnTypeFromAnnotation(signature.declaration!) ||                 (nodeIsMissing((signature.declaration as FunctionLikeDeclaration).body) ? anyType : getReturnTypeFromBody(signature.declaration as FunctionLikeDeclaration)) */ TODO
			if signature.flags & SignatureFlagsIsInnerCallChain {
				type_ = addOptionalTypeMarker(type_)
			} else if signature.flags & SignatureFlagsIsOuterCallChain {
				type_ = getOptionalType(type_)
			}
			if !popTypeResolution() {
				if signature.declaration {
					typeNode := getEffectiveReturnTypeNode(signature.declaration)
					if typeNode {
						error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself)
					} else if noImplicitAny {
						declaration := signature.declaration /* as */ /* TODO(TypeReference): Declaration */
						name := getNameOfDeclaration(declaration)
						if name {
							error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name))
						} else {
							error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions)
						}
					}
				}
				type_ = anyType
			}
			/* TODO(ExpressionStatement): signature.resolvedReturnType ??= type; */
		}
		return signature.resolvedReturnType
	}
	getReturnTypeFromAnnotation := func(declaration /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if declaration.kind == SyntaxKindConstructor {
			return getDeclaredTypeOfClassOrInterface(getMergedSymbol((declaration.parent /* as */ /* TODO(TypeReference): ClassDeclaration */).symbol))
		}
		typeNode := getEffectiveReturnTypeNode(declaration)
		if isJSDocSignature(declaration) {
			root := getJSDocRoot(declaration)
			if root && isConstructorDeclaration(root.parent) && !typeNode {
				return getDeclaredTypeOfClassOrInterface(getMergedSymbol((root.parent.parent /* as */ /* TODO(TypeReference): ClassDeclaration */).symbol))
			}
		}
		if isJSDocConstructSignature(declaration) {
			return getTypeFromTypeNode( /* TODO(NonNullExpression): (declaration.parameters[0] as ParameterDeclaration).type! */ TODO)
		}
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		if declaration.kind == SyntaxKindGetAccessor && hasBindableName(declaration) {
			jsDocType := isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration)
			if jsDocType {
				return jsDocType
			}
			setter := getDeclarationOfKind(getSymbolOfDeclaration(declaration), SyntaxKindSetAccessor)
			setterType := getAnnotatedAccessorType(setter)
			if setterType {
				return setterType
			}
		}
		return getReturnTypeOfTypeTag(declaration)
	}
	isResolvingReturnTypeOfSignature := func(signature Signature) bool {
		return signature.compositeSignatures && some(signature.compositeSignatures, isResolvingReturnTypeOfSignature) || !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, TypeSystemPropertyNameResolvedReturnType) >= 0
	}
	getRestTypeOfSignature := func(signature Signature) Type {
		return tryGetRestTypeOfSignature(signature) || anyType
	}
	tryGetRestTypeOfSignature := func(signature Signature) *Type {
		if signatureHasRestParameter(signature) {
			sigRestType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			restType := /* TODO(ConditionalExpression): isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType */ TODO
			return restType && getIndexTypeOfType(restType, numberType)
		}
		return nil
	}
	getSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, isJavascript bool, inferredTypeParameters []TypeParameter) Signature {
		instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript))
		if inferredTypeParameters {
			returnSignature := getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature))
			if returnSignature {
				newReturnSignature := cloneSignature(returnSignature)
				newReturnSignature.typeParameters = inferredTypeParameters
				newInstantiatedSignature := cloneSignature(instantiatedSignature)
				newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature)
				return newInstantiatedSignature
			}
		}
		return instantiatedSignature
	}
	getSignatureInstantiationWithoutFillingInTypeArguments := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
		instantiations := signature.instantiations || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): signature.instantiations = new Map<string, Signature>() */ TODO)
		id := getTypeListId(typeArguments)
		instantiation := instantiations.get(id)
		if !instantiation {
			instantiations.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): instantiation = createSignatureInstantiation(signature, typeArguments) */, TODO)
		}
		return instantiation
	}
	createSignatureInstantiation := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Signature {
		return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), true)
	}
	getTypeParametersForMapper := func(signature Signature) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		return sameMap(signature.typeParameters, func(tp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(PropertyAccessExpression): tp.mapper */
			/* TODO(QuestionToken): ? */
			/* TODO(CallExpression): instantiateType(tp, tp.mapper) */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): tp */
		})
	}
	createSignatureTypeMapper := func(signature Signature, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return createTypeMapper( /* TODO(NonNullExpression): getTypeParametersForMapper(signature)! */ TODO, typeArguments)
	}
	getErasedSignature := func(signature Signature) Signature {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) :             signature */ TODO
	}
	createErasedSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return instantiateSignature(signature, createTypeEraser( /* TODO(NonNullExpression): signature.typeParameters! */ TODO), true)
	}
	getCanonicalSignature := func(signature Signature) Signature {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) :             signature */ TODO
	}
	createCanonicalSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return getSignatureInstantiation(signature, map_(signature.typeParameters, func(tp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			/* TODO(BinaryExpression): tp.target && !getConstraintOfTypeParameter(tp.target) */
			/* TODO(QuestionToken): ? */
			/* TODO(PropertyAccessExpression): tp.target */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): tp */
		}), isInJSFile(signature.declaration))
	}
	getImplementationSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return /* TODO(ConditionalExpression): signature.typeParameters ?             signature.implementationSignatureCache ||= createImplementationSignature(signature) :             signature */ TODO
	}
	createImplementationSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		return /* TODO(ConditionalExpression): signature.typeParameters ? instantiateSignature(signature, createTypeMapper([], [])) : signature */ TODO
	}
	getBaseSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		typeParameters := signature.typeParameters
		if typeParameters {
			if signature.baseSignatureCache {
				return signature.baseSignatureCache
			}
			typeEraser := createTypeEraser(typeParameters)
			baseConstraintMapper := createTypeMapper(typeParameters, map_(typeParameters, func(tp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(CallExpression): getConstraintOfTypeParameter(tp) */
				/* TODO(BarBarToken): || */
				/* TODO(Identifier): unknownType */
			}))
			var baseConstraints []Type = map_(typeParameters, func(tp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(CallExpression): instantiateType(tp, baseConstraintMapper) */
				/* TODO(BarBarToken): || */
				/* TODO(Identifier): unknownType */
			})
			/* TODO(ForStatement): for (let i = 0; i < typeParameters.length - 1; i++) {                 baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);             } */
			baseConstraints = instantiateTypes(baseConstraints, typeEraser)
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), /*eraseTypeParameters* / true) */ TODO
		}
		return signature
	}
	getOrCreateTypeFromSignature := func(signature Signature, outerTypeParameters []TypeParameter) ObjectType {
		if !signature.isolatedSignatureType {
			kind := signature.declaration.kind
			isConstructor := kind == nil || kind == SyntaxKindConstructor || kind == SyntaxKindConstructSignature || kind == SyntaxKindConstructorType
			type_ := createObjectType(ObjectFlagsAnonymous|ObjectFlagsSingleSignatureType, createSymbol(SymbolFlagsFunction, InternalSymbolNameFunction)) /* as */ /* TODO(TypeReference): SingleSignatureType */
			if signature.declaration && !nodeIsSynthesized(signature.declaration) {
				type_.symbol.declarations = /* TODO(ArrayLiteralExpression): [signature.declaration] */ TODO
				type_.symbol.valueDeclaration = signature.declaration
			}
			/* TODO(ExpressionStatement): outerTypeParameters ||= signature.declaration && getOuterTypeParameters(signature.declaration, /*includeThisTypes* / true); */
			type_.outerTypeParameters = outerTypeParameters
			type_.members = emptySymbols
			type_.properties = emptyArray
			type_.callSignatures = /* TODO(ConditionalExpression): !isConstructor ? [signature] : emptyArray */ TODO
			type_.constructSignatures = /* TODO(ConditionalExpression): isConstructor ? [signature] : emptyArray */ TODO
			type_.indexInfos = emptyArray
			signature.isolatedSignatureType = type_
		}
		return signature.isolatedSignatureType
	}
	getIndexSymbol := func(symbol Symbol) *Symbol {
		return /* TODO(ConditionalExpression): symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : undefined */ TODO
	}
	getIndexSymbolFromSymbolTable := func(symbolTable SymbolTable) *Symbol {
		return symbolTable.get(InternalSymbolNameIndex)
	}
	createIndexInfo := func(keyType Type, type_ Type, isReadonly bool, declaration IndexSignatureDeclaration) IndexInfo {
		return /* TODO(ObjectLiteralExpression): { keyType, type, isReadonly, declaration } */ TODO
	}
	getIndexInfosOfSymbol := func(symbol Symbol) []IndexInfo {
		indexSymbol := getIndexSymbol(symbol)
		return /* TODO(ConditionalExpression): indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray */ TODO
	}
	getIndexInfosOfIndexSymbol := func(indexSymbol Symbol) []IndexInfo {
		if indexSymbol.declarations {
			var indexInfos []IndexInfo = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, declaration := range indexSymbol.declarations /* as */ /* TODO(ArrayType): IndexSignatureDeclaration[] */ {
				if declaration.parameters.length == 1 {
					parameter := /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO
					if parameter.type_ {
						forEachType(getTypeFromTypeNode(parameter.type_), func(keyType /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
							if isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType) {
								indexInfos.push(createIndexInfo(keyType /* TODO(ConditionalExpression): declaration.type ? getTypeFromTypeNode(declaration.type) : anyType */, TODO, hasEffectiveModifier(declaration, ModifierFlagsReadonly), declaration))
							}
						})
					}
				}
			}
			return indexInfos
		}
		return emptyArray
	}
	isValidIndexKeyType := func(type_ Type) bool {
		return !!(type_.flags & (TypeFlagsString | TypeFlagsNumber | TypeFlagsESSymbol)) || isPatternLiteralType(type_) || !!(type_.flags&TypeFlagsIntersection) && !isGenericType(type_) && some((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isValidIndexKeyType)
	}
	getConstraintDeclaration := func(type_ TypeParameter) *TypeNode {
		return /* TODO(ElementAccessExpression): mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0] */ TODO
	}
	getInferredTypeParameterConstraint := func(typeParameter TypeParameter, omitTypeReferences bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var inferences /* TODO(ArrayType): Type[] */ any
		if typeParameter.symbol.declarations {
			for _, declaration := range typeParameter.symbol.declarations {
				if declaration.parent.kind == SyntaxKindInferType {
					TODO_IDENTIFIER := walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent)
					if grandParent.kind == SyntaxKindTypeReference && !omitTypeReferences {
						typeReference := grandParent /* as */ /* TODO(TypeReference): TypeReferenceNode */
						typeParameters := getTypeParametersForTypeReferenceOrImport(typeReference)
						if typeParameters {
							index := /* TODO(NonNullExpression): typeReference.typeArguments! */ TODO.indexOf(childTypeParameter /* as */ /* TODO(TypeReference): TypeNode */)
							if index < typeParameters.length {
								declaredConstraint := getConstraintOfTypeParameter( /* TODO(ElementAccessExpression): typeParameters[index] */ TODO)
								if declaredConstraint {
									mapper := makeDeferredTypeMapper(typeParameters, typeParameters.map_(func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO, index /* TODO(undefined): number */ TODO) /* TODO(undefined): () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
										/* TODO(EqualsGreaterThanToken): => */
										/* TODO(Block): {                                             return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index);                                         } */
									}))
									constraint := instantiateType(declaredConstraint, mapper)
									if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== typeParameter */ TODO {
										inferences = append(inferences, constraint)
									}
								}
							}
						}
					} else if grandParent.kind == SyntaxKindParameter && (grandParent /* as */ /* TODO(TypeReference): ParameterDeclaration */).dotDotDotToken || grandParent.kind == SyntaxKindRestType || grandParent.kind == SyntaxKindNamedTupleMember && (grandParent /* as */ /* TODO(TypeReference): NamedTupleMember */).dotDotDotToken {
						inferences = append(inferences, createArrayType(unknownType))
					} else if grandParent.kind == SyntaxKindTemplateLiteralTypeSpan {
						inferences = append(inferences, stringType)
					} else if grandParent.kind == SyntaxKindTypeParameter && grandParent.parent.kind == SyntaxKindMappedType {
						inferences = append(inferences, stringNumberSymbolType)
					} else if grandParent.kind == SyntaxKindMappedType && (grandParent /* as */ /* TODO(TypeReference): MappedTypeNode */).type_ && skipParentheses( /* TODO(NonNullExpression): (grandParent as MappedTypeNode).type! */ TODO) == declaration.parent && grandParent.parent.kind == SyntaxKindConditionalType && (grandParent.parent /* as */ /* TODO(TypeReference): ConditionalTypeNode */).extendsType == grandParent && (grandParent.parent /* as */ /* TODO(TypeReference): ConditionalTypeNode */).checkType.kind == SyntaxKindMappedType && ((grandParent.parent /* as */ /* TODO(TypeReference): ConditionalTypeNode */).checkType /* as */ /* TODO(TypeReference): MappedTypeNode */).type_ {
						checkMappedType := (grandParent.parent /* as */ /* TODO(TypeReference): ConditionalTypeNode */).checkType /* as */ /* TODO(TypeReference): MappedTypeNode */
						nodeType := getTypeFromTypeNode( /* TODO(NonNullExpression): checkMappedType.type! */ TODO)
						inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType.typeParameter)) /* TODO(ConditionalExpression): checkMappedType.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType.typeParameter.constraint) : stringNumberSymbolType */, TODO)))
					}
				}
			}
		}
		return inferences && getIntersectionType(inferences)
	}
	getConstraintFromTypeParameter := func(typeParameter TypeParameter) *Type {
		if !typeParameter.constraint {
			if typeParameter.target {
				targetConstraint := getConstraintOfTypeParameter(typeParameter.target)
				typeParameter.constraint = /* TODO(ConditionalExpression): targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType */ TODO
			} else {
				constraintDeclaration := getConstraintDeclaration(typeParameter)
				if !constraintDeclaration {
					typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType
				} else {
					type_ := getTypeFromTypeNode(constraintDeclaration)
					if type_.flags&TypeFlagsAny && !isErrorType(type_) {
						type_ = /* TODO(ConditionalExpression): constraintDeclaration.parent.parent.kind === SyntaxKind.MappedType ? stringNumberSymbolType : unknownType */ TODO
					}
					typeParameter.constraint = type_
				}
			}
		}
		return /* TODO(ConditionalExpression): typeParameter.constraint === noConstraintType ? undefined : typeParameter.constraint */ TODO
	}
	getParentSymbolOfTypeParameter := func(typeParameter TypeParameter) *Symbol {
		tp := /* TODO(NonNullExpression): getDeclarationOfKind<TypeParameterDeclaration>(typeParameter.symbol, SyntaxKind.TypeParameter)! */ TODO
		host := /* TODO(ConditionalExpression): isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent */ TODO
		return host && getSymbolOfNode(host)
	}
	getTypeListId := func(types /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): string */ TODO {
		result := ""
		if types {
			length := types.length
			i := 0
			/* TODO(WhileStatement): while (i < length) {                 const startId = types[i].id;                 let count = 1;                 while (i + count < length && types[i + count].id === startId + count) {                     count++;                 }                 if (result.length) {                     result += ",";                 }                 result += startId;                 if (count > 1) {                     result += ":" + count;                 }                 i += count;             } */
		}
		return result
	}
	getAliasId := func(aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): string */ TODO {
		return /* TODO(ConditionalExpression): aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "" */ TODO
	}
	getPropagatingFlagsOfTypes := func(types []Type, excludeKinds TypeFlags) ObjectFlags {
		var result ObjectFlags = 0
		for _, type_ := range types {
			if excludeKinds == nil || !(type_.flags & excludeKinds) {
				result |= getObjectFlags(type_)
			}
		}
		return result & ObjectFlagsPropagatingFlags
	}
	tryCreateTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		if some(typeArguments) && target == emptyGenericType {
			return unknownType
		}
		return createTypeReference(target, typeArguments)
	}
	createTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) TypeReference {
		id := getTypeListId(typeArguments)
		type_ := target.instantiations.get(id)
		if !type_ {
			type_ = createObjectType(ObjectFlagsReference, target.symbol) /* as */ /* TODO(TypeReference): TypeReference */
			target.instantiations.set(id, type_)
			type_.objectFlags |= /* TODO(ConditionalExpression): typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0 */ TODO
			type_.target = target
			type_.resolvedTypeArguments = typeArguments
		}
		return type_
	}
	cloneTypeReference := func(source TypeReference) TypeReference {
		type_ := createTypeWithSymbol(source.flags, source.symbol) /* as */ /* TODO(TypeReference): TypeReference */
		type_.objectFlags = source.objectFlags
		type_.target = source.target
		type_.resolvedTypeArguments = source.resolvedTypeArguments
		return type_
	}
	createDeferredTypeReference := func(target GenericType, node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) DeferredTypeReference {
		if !aliasSymbol {
			aliasSymbol = getAliasSymbolForTypeNode(node)
			localAliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			aliasTypeArguments = /* TODO(ConditionalExpression): mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments */ TODO
		}
		type_ := createObjectType(ObjectFlagsReference, target.symbol) /* as */ /* TODO(TypeReference): DeferredTypeReference */
		type_.target = target
		type_.node = node
		type_.mapper = mapper
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	getTypeArguments := func(type_ TypeReference) []Type {
		if !type_.resolvedTypeArguments {
			if !pushTypeResolution(type_, TypeSystemPropertyNameResolvedTypeArguments) {
				return concatenate(type_.target.outerTypeParameters, type_.target.localTypeParameters.map_(func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
				})) || emptyArray
			}
			node := type_.node
			typeArguments := /* TODO(ConditionalExpression): !node ? emptyArray :                 node.kind === SyntaxKind.TypeReference ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments(node, type.target.localTypeParameters!)) :                 node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] :                 map(node.elements, getTypeFromTypeNode) */ TODO
			if popTypeResolution() {
				/* TODO(ExpressionStatement): type.resolvedTypeArguments ??= type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments; */
			} else {
				/* TODO(ExpressionStatement): type.resolvedTypeArguments ??= concatenate(type.target.outerTypeParameters, type.target.localTypeParameters?.map(() => errorType) || emptyArray); */
				error(type_.node || currentNode /* TODO(ConditionalExpression): type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves */, TODO, type_.target.symbol && symbolToString(type_.target.symbol))
			}
		}
		return type_.resolvedTypeArguments
	}
	getTypeReferenceArity := func(type_ TypeReference) number {
		return length(type_.target.typeParameters)
	}
	getTypeFromClassOrInterfaceReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		type_ := getDeclaredTypeOfSymbol(getMergedSymbol(symbol)) /* as */ /* TODO(TypeReference): InterfaceType */
		typeParameters := type_.localTypeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			isJs := isInJSFile(node)
			isJsImplicitAny := !noImplicitAny && isJs
			if !isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
				missingAugmentsTag := isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent)
				diag := /* TODO(ConditionalExpression): minTypeArgumentCount === typeParameters.length ?                     missingAugmentsTag ?                         Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag :                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                     missingAugmentsTag ?                     Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag :                     Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */ TODO
				typeStr := typeToString(type_, nil, TypeFormatFlagsWriteArrayAsGenericType)
				error(node, diag, typeStr, minTypeArgumentCount, typeParameters.length)
				if !isJs {
					return errorType
				}
			}
			if node.kind == SyntaxKindTypeReference && isDeferredTypeReferenceNode(node /* as */ /* TODO(TypeReference): TypeReferenceNode */ /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(node.typeArguments) !== typeParameters.length */, TODO) {
				return createDeferredTypeReference(type_ /* as */ /* TODO(TypeReference): GenericType */, node /* as */ /* TODO(TypeReference): TypeReferenceNode */, nil)
			}
			typeArguments := concatenate(type_.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs))
			return createTypeReference(type_ /* as */ /* TODO(TypeReference): GenericType */, typeArguments)
		}
		return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
	}
	getTypeAliasInstantiation := func(symbol Symbol, typeArguments /* TODO(TypeOperator): readonly Type[] */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		type_ := getDeclaredTypeOfSymbol(symbol)
		if type_ == intrinsicMarkerType {
			typeKind := intrinsicTypeKinds.get(symbol.escapedName /* as */ /* TODO(StringKeyword): string */)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeKind !== undefined */ TODO && typeArguments && typeArguments.length == 1 {
				return /* TODO(ConditionalExpression): typeKind === IntrinsicTypeKind.NoInfer ? getNoInferType(typeArguments[0]) : getStringMappingType(symbol, typeArguments[0]) */ TODO
			}
		}
		links := getSymbolLinks(symbol)
		typeParameters := /* TODO(NonNullExpression): links.typeParameters! */ TODO
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
		instantiation := /* TODO(NonNullExpression): links.instantiations! */ TODO.get(id)
		if !instantiation {
			/* TODO(NonNullExpression): links.instantiations! */ TODO.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments) */, TODO)
		}
		return instantiation
	}
	getTypeFromTypeAliasReference := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if getCheckFlags(symbol) & CheckFlagsUnresolved {
			typeArguments := typeArgumentsFromTypeReferenceNode(node)
			id := getAliasId(symbol, typeArguments)
			errorType := errorTypes.get(id)
			if !errorType {
				errorType = createIntrinsicType(TypeFlagsAny, "error", nil /* TODO(TemplateExpression): `alias ${id}` */, TODO)
				errorType.aliasSymbol = symbol
				errorType.aliasTypeArguments = typeArguments
				errorTypes.set(id, errorType)
			}
			return errorType
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		typeParameters := getSymbolLinks(symbol).typeParameters
		if typeParameters {
			numTypeArguments := length(node.typeArguments)
			minTypeArgumentCount := getMinTypeArgumentCount(typeParameters)
			if numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length {
				error(node /* TODO(ConditionalExpression): minTypeArgumentCount === typeParameters.length ?                         Diagnostics.Generic_type_0_requires_1_type_argument_s :                         Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments */, TODO, symbolToString(symbol), minTypeArgumentCount, typeParameters.length)
				return errorType
			}
			aliasSymbol := getAliasSymbolForTypeNode(node)
			newAliasSymbol := /* TODO(ConditionalExpression): aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : undefined */ TODO
			var aliasTypeArguments /* TODO(ArrayType): Type[] */ any
			if newAliasSymbol {
				aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol)
			} else if isTypeReferenceType(node) {
				aliasSymbol := resolveTypeReferenceName(node, SymbolFlagsAlias, true)
				if aliasSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): aliasSymbol !== unknownSymbol */ TODO {
					resolved := resolveAlias(aliasSymbol)
					if resolved && resolved.flags&SymbolFlagsTypeAlias {
						newAliasSymbol = resolved
						aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || ( /* TODO(ConditionalExpression): typeParameters ? [] : undefined */ TODO)
					}
				}
			}
			return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments)
		}
		return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? type : errorType */ TODO
	}
	isLocalTypeAlias := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		declaration := symbol.declarations.find(isTypeAlias)
		return !!(declaration && getContainingFunction(declaration))
	}
	getTypeReferenceName := func(node TypeReferenceType) *EntityNameOrEntityNameExpression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.TypeReference:                 return node.typeName;             case SyntaxKind.ExpressionWithTypeArguments:                 // We only support expressions that are simple qualified names. For other                 // expressions this produces undefined.                 const expr = node.expression;                 if (isEntityNameExpression(expr)) {                     return expr;                 }                 // fall through;         } */
		return nil
	}
	getSymbolPath := func(symbol Symbol) string {
		return /* TODO(ConditionalExpression): symbol.parent ? `${getSymbolPath(symbol.parent)}.${symbol.escapedName}` : symbol.escapedName as string */ TODO
	}
	getUnresolvedSymbolForEntityName := func(name EntityNameOrEntityNameExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		identifier := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? name.right :             name.kind === SyntaxKind.PropertyAccessExpression ? name.name :             name */ TODO
		text := identifier.escapedText
		if text {
			parentSymbol := /* TODO(ConditionalExpression): name.kind === SyntaxKind.QualifiedName ? getUnresolvedSymbolForEntityName(name.left) :                 name.kind === SyntaxKind.PropertyAccessExpression ? getUnresolvedSymbolForEntityName(name.expression) :                 undefined */ TODO
			path := /* TODO(ConditionalExpression): parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text as string */ TODO
			result := unresolvedSymbols.get(path)
			if !result {
				unresolvedSymbols.set(path /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = createSymbol(SymbolFlags.TypeAlias, text, CheckFlags.Unresolved) */, TODO)
				result.parent = parentSymbol
				result.links.declaredType = unresolvedType
			}
			return result
		}
		return unknownSymbol
	}
	resolveTypeReferenceName := func(typeReference TypeReferenceType, meaning SymbolFlags, ignoreErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		name := getTypeReferenceName(typeReference)
		if !name {
			return unknownSymbol
		}
		symbol := resolveEntityName(name, meaning, ignoreErrors)
		return /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol :             ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name) */ TODO
	}
	getTypeReferenceType := func(node NodeWithTypeArguments, symbol Symbol) Type {
		if symbol == unknownSymbol {
			return errorType
		}
		symbol = getExpandoSymbol(symbol) || symbol
		if symbol.flags & (SymbolFlagsClass | SymbolFlagsInterface) {
			return getTypeFromClassOrInterfaceReference(node, symbol)
		}
		if symbol.flags & SymbolFlagsTypeAlias {
			return getTypeFromTypeAliasReference(node, symbol)
		}
		res := tryGetDeclaredTypeOfSymbol(symbol)
		if res {
			return /* TODO(ConditionalExpression): checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType */ TODO
		}
		if symbol.flags&SymbolFlagsValue && isJSDocTypeReference(node) {
			jsdocType := getTypeFromJSDocValueReference(node, symbol)
			if jsdocType {
				return jsdocType
			} else {
				resolveTypeReferenceName(node, SymbolFlagsType)
				return getTypeOfSymbol(symbol)
			}
		}
		return errorType
	}
	getTypeFromJSDocValueReference := func(node NodeWithTypeArguments, symbol Symbol) *Type {
		links := getNodeLinks(node)
		if !links.resolvedJSDocType {
			valueType := getTypeOfSymbol(symbol)
			typeType := valueType
			if symbol.valueDeclaration {
				isImportTypeWithQualifier := node.kind == SyntaxKindImportType && (node /* as */ /* TODO(TypeReference): ImportTypeNode */).qualifier
				if valueType.symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): valueType.symbol !== symbol */ TODO && isImportTypeWithQualifier {
					typeType = getTypeReferenceType(node, valueType.symbol)
				}
			}
			links.resolvedJSDocType = typeType
		}
		return links.resolvedJSDocType
	}
	getNoInferType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNoInferTargetType(type) ? getOrCreateSubstitutionType(type, unknownType) : type */ TODO
	}
	isNoInferTargetType := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, isNoInferTargetType) || type_.flags&TypeFlagsSubstitution && !isNoInferType(type_) && isNoInferTargetType((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType) || type_.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(type_) || type_.flags&(TypeFlagsInstantiable&~TypeFlagsSubstitution) && !isPatternLiteralType(type_))
	}
	isNoInferType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags&TypeFlagsSubstitution && (type_ /* as */ /* TODO(TypeReference): SubstitutionType */).constraint.flags&TypeFlagsUnknown)
	}
	getSubstitutionType := func(baseType Type, constraint Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): constraint.flags & TypeFlags.AnyOrUnknown || constraint === baseType || baseType.flags & TypeFlags.Any ?             baseType :             getOrCreateSubstitutionType(baseType, constraint) */ TODO
	}
	getOrCreateSubstitutionType := func(baseType Type, constraint Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SubstitutionType */ TODO {
		id := /* TODO(TemplateExpression): `${getTypeId(baseType)}>${getTypeId(constraint)}` */ TODO
		cached := substitutionTypes.get(id)
		if cached {
			return cached
		}
		result := createType(TypeFlagsSubstitution) /* as */ /* TODO(TypeReference): SubstitutionType */
		result.baseType = baseType
		result.constraint = constraint
		substitutionTypes.set(id, result)
		return result
	}
	getSubstitutionIntersection := func(substitutionType SubstitutionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNoInferType(substitutionType) ? substitutionType.baseType : getIntersectionType([substitutionType.constraint, substitutionType.baseType]) */ TODO
	}
	isUnaryTupleTypeNode := func(node TypeNode) /* TODO(undefined): boolean */ TODO {
		return node.kind == SyntaxKindTupleType && (node /* as */ /* TODO(TypeReference): TupleTypeNode */).elements.length == 1
	}
	getImpliedConstraint := func(type_ Type, checkNode TypeNode, extendsNode TypeNode) *Type {
		return /* TODO(ConditionalExpression): isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, (checkNode as TupleTypeNode).elements[0], (extendsNode as TupleTypeNode).elements[0]) :             getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) :             undefined */ TODO
	}
	getConditionalFlowTypeOfType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var constraints /* TODO(ArrayType): Type[] */ any
		covariant := true
		/* TODO(WhileStatement): while (node && !isStatement(node) && node.kind !== SyntaxKind.JSDoc) {             const parent = node.parent;             // only consider variance flipped by parameter locations - `keyof` types would usually be considered variance inverting, but             // often get used in indexed accesses where they behave sortof invariantly, but our checking is lax             if (parent.kind === SyntaxKind.Parameter) {                 covariant = !covariant;             }             // Always substitute on type parameters, regardless of variance, since even             // in contravariant positions, they may rely on substituted constraints to be valid             if ((covariant || type.flags & TypeFlags.TypeVariable) && parent.kind === SyntaxKind.ConditionalType && node === (parent as ConditionalTypeNode).trueType) {                 const constraint = getImpliedConstraint(type, (parent as ConditionalTypeNode).checkType, (parent as ConditionalTypeNode).extendsType);                 if (constraint) {                     constraints = append(constraints, constraint);                 }             }             // Given a homomorphic mapped type { [K in keyof T]: XXX }, where T is constrained to an array or tuple type, in the             // template type XXX, K has an added constraint of number | `${number}`.             else if (type.flags & TypeFlags.TypeParameter && parent.kind === SyntaxKind.MappedType && !(parent as MappedTypeNode).nameType && node === (parent as MappedTypeNode).type) {                 const mappedType = getTypeFromTypeNode(parent as TypeNode) as MappedType;                 if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {                     const typeParameter = getHomomorphicTypeVariable(mappedType);                     if (typeParameter) {                         const constraint = getConstraintOfTypeParameter(typeParameter);                         if (constraint && everyType(constraint, isArrayOrTupleType)) {                             constraints = append(constraints, getUnionType([numberType, numericStringType]));                         }                     }                 }             }             node = parent;         } */
		return /* TODO(ConditionalExpression): constraints ? getSubstitutionType(type, getIntersectionType(constraints)) : type */ TODO
	}
	isJSDocTypeReference := func(node Node) /* TODO(TypePredicate): node is TypeReferenceNode */ TODO {
		return !!(node.flags & NodeFlagsJSDoc) && (node.kind == SyntaxKindTypeReference || node.kind == SyntaxKindImportType)
	}
	checkNoTypeArguments := func(node NodeWithTypeArguments, symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if node.typeArguments {
			error(node, Diagnostics.Type_0_is_not_generic /* TODO(ConditionalExpression): symbol ? symbolToString(symbol) : (node as TypeReferenceNode).typeName ? declarationNameToString((node as TypeReferenceNode).typeName) : anon */, TODO)
			return false
		}
		return true
	}
	getIntendedTypeFromJSDocTypeReference := func(node TypeReferenceNode) *Type {
		if isIdentifier(node.typeName) {
			typeArgs := node.typeArguments
			/* TODO(SwitchStatement): switch (node.typeName.escapedText) {                 case "String":                     checkNoTypeArguments(node);                     return stringType;                 case "Number":                     checkNoTypeArguments(node);                     return numberType;                 case "Boolean":                     checkNoTypeArguments(node);                     return booleanType;                 case "Void":                     checkNoTypeArguments(node);                     return voidType;                 case "Undefined":                     checkNoTypeArguments(node);                     return undefinedType;                 case "Null":                     checkNoTypeArguments(node);                     return nullType;                 case "Function":                 case "function":                     checkNoTypeArguments(node);                     return globalFunctionType;                 case "array":                     return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : undefined;                 case "promise":                     return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : undefined;                 case "Object":                     if (typeArgs && typeArgs.length === 2) {                         if (isJSDocIndexSignature(node)) {                             const indexed = getTypeFromTypeNode(typeArgs[0]);                             const target = getTypeFromTypeNode(typeArgs[1]);                             const indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, /*isReadonly* / false)] : emptyArray;                             return createAnonymousType(/*symbol* / undefined, emptySymbols, emptyArray, emptyArray, indexInfo);                         }                         return anyType;                     }                     checkNoTypeArguments(node);                     return !noImplicitAny ? anyType : undefined;             } */
		}
	}
	getTypeFromJSDocNullableTypeNode := func(node JSDocNullableType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type_ := getTypeFromTypeNode(node.type_)
		return /* TODO(ConditionalExpression): strictNullChecks ? getNullableType(type, TypeFlags.Null) : type */ TODO
	}
	getTypeFromTypeReference := func(node TypeReferenceType) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			if isConstTypeReference(node) && isAssertionExpression(node.parent) {
				links.resolvedSymbol = unknownSymbol
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = checkExpressionCached(node.parent.expression) */ TODO
			}
			var symbol *Symbol
			var type_ *Type
			meaning := SymbolFlagsType
			if isJSDocTypeReference(node) {
				type_ = getIntendedTypeFromJSDocTypeReference(node)
				if !type_ {
					symbol = resolveTypeReferenceName(node, meaning, true)
					if symbol == unknownSymbol {
						symbol = resolveTypeReferenceName(node, meaning|SymbolFlagsValue)
					} else {
						resolveTypeReferenceName(node, meaning)
					}
					type_ = getTypeReferenceType(node, symbol)
				}
			}
			if !type_ {
				symbol = resolveTypeReferenceName(node, meaning)
				type_ = getTypeReferenceType(node, symbol)
			}
			links.resolvedSymbol = symbol
			links.resolvedType = type_
		}
		return links.resolvedType
	}
	typeArgumentsFromTypeReferenceNode := func(node NodeWithTypeArguments) /* TODO(ArrayType): Type[] */ any {
		return map_(node.typeArguments, getTypeFromTypeNode)
	}
	getTypeFromTypeQueryNode := func(node TypeQueryNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			type_ := checkExpressionWithTypeArguments(node)
			links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type_))
		}
		return links.resolvedType
	}
	getTypeOfGlobalSymbol := func(symbol *Symbol, arity number) ObjectType {
		getTypeDeclaration := func(symbol Symbol) Declaration {
			declarations := symbol.declarations
			if declarations {
				for _, declaration := range declarations {
					/* TODO(SwitchStatement): switch (declaration.kind) {                         case SyntaxKind.ClassDeclaration:                         case SyntaxKind.InterfaceDeclaration:                         case SyntaxKind.EnumDeclaration:                             return declaration;                     } */
				}
			}
		}
		if !symbol {
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		type_ := getDeclaredTypeOfSymbol(symbol)
		if !(type_.flags & TypeFlagsObject) {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol))
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length((type as InterfaceType).typeParameters) !== arity */ TODO {
			error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
			return /* TODO(ConditionalExpression): arity ? emptyGenericType : emptyObjectType */ TODO
		}
		return type_ /* as */ /* TODO(TypeReference): ObjectType */
	}
	getGlobalValueSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name, SymbolFlagsValue /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_value_0 : undefined */, TODO)
	}
	getGlobalTypeSymbol := func(name __String, reportErrors bool) *Symbol {
		return getGlobalSymbol(name, SymbolFlagsType /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
	}
	getGlobalTypeAliasSymbol := func(name __String, arity number, reportErrors bool) *Symbol {
		symbol := getGlobalSymbol(name, SymbolFlagsType /* TODO(ConditionalExpression): reportErrors ? Diagnostics.Cannot_find_global_type_0 : undefined */, TODO)
		if symbol {
			getDeclaredTypeOfSymbol(symbol)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(getSymbolLinks(symbol).typeParameters) !== arity */ TODO {
				decl := symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration)
				error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity)
				return nil
			}
		}
		return symbol
	}
	getGlobalSymbol := func(name __String, meaning SymbolFlags, diagnostic *DiagnosticMessage) *Symbol {
		return resolveName(nil, name, meaning, diagnostic, false, false)
	}
	// OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ TODO, reportErrors /* TODO(LiteralType): true */ TODO) ObjectType
	// OVERLOAD: getGlobalType := func(name __String, arity /* TODO(LiteralType): 0 */ TODO, reportErrors bool) *ObjectType
	// OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors /* TODO(LiteralType): true */ TODO) GenericType
	// OVERLOAD: getGlobalType := func(name __String, arity number, reportErrors bool) *GenericType
	getGlobalType := func(name __String, arity number, reportErrors bool) *ObjectType {
		symbol := getGlobalTypeSymbol(name, reportErrors)
		return /* TODO(ConditionalExpression): symbol || reportErrors ? getTypeOfGlobalSymbol(symbol, arity) : undefined */ TODO
	}
	// OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity /* TODO(LiteralType): 0 */ TODO) []ObjectType
	// OVERLOAD: getGlobalBuiltinTypes := func(typeNames []string, arity number) []GenericType
	getGlobalBuiltinTypes := func(typeNames []string, arity number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		var types /* TODO(ArrayType): Type[] */ any
		for _, typeName := range typeNames {
			types = append(types, getGlobalType(typeName /* as */ /* TODO(TypeReference): __String */, arity, false))
		}
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): types ?? emptyArray */ TODO
	}
	getGlobalTypedPropertyDescriptorType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalTypedPropertyDescriptorType ||= getGlobalType("TypedPropertyDescriptor" as __String, /*arity* / 1, /*reportErrors* / true) || emptyGenericType */ TODO
	}
	getGlobalTemplateStringsArrayType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalTemplateStringsArrayType ||= getGlobalType("TemplateStringsArray" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalImportMetaType ||= getGlobalType("ImportMeta" as __String, /*arity* / 0, /*reportErrors* / true) || emptyObjectType */ TODO
	}
	getGlobalImportMetaExpressionType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if !deferredGlobalImportMetaExpressionType {
			symbol := createSymbol(SymbolFlagsNone, "ImportMetaExpression" /* as */ /* TODO(TypeReference): __String */)
			importMetaType := getGlobalImportMetaType()
			metaPropertySymbol := createSymbol(SymbolFlagsProperty, "meta" /* as */ /* TODO(TypeReference): __String */, CheckFlagsReadonly)
			metaPropertySymbol.parent = symbol
			metaPropertySymbol.links.type_ = importMetaType
			members := createSymbolTable( /* TODO(ArrayLiteralExpression): [metaPropertySymbol] */ TODO)
			symbol.members = members
			deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
		}
		return deferredGlobalImportMetaExpressionType
	}
	getGlobalImportCallOptionsType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalImportCallOptionsType ||= getGlobalType("ImportCallOptions" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalImportAttributesType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalImportAttributesType ||= getGlobalType("ImportAttributes" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalESSymbolConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorSymbol ||= getGlobalValueSymbol("Symbol" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolConstructorTypeSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolConstructorTypeSymbol ||= getGlobalTypeSymbol("SymbolConstructor" as __String, reportErrors) */ TODO
	}
	getGlobalESSymbolType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalESSymbolType ||= getGlobalType("Symbol" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalPromiseType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseType ||= getGlobalType("Promise" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseLikeType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseLikeType ||= getGlobalType("PromiseLike" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalPromiseConstructorSymbol := func(reportErrors bool) *Symbol {
		return /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseConstructorSymbol ||= getGlobalValueSymbol("Promise" as __String, reportErrors) */ TODO
	}
	getGlobalPromiseConstructorLikeType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalPromiseConstructorLikeType ||= getGlobalType("PromiseConstructorLike" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncIterableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIterableType ||= getGlobalType("AsyncIterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIteratorType ||= getGlobalType("AsyncIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncIterableIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIterableIteratorType ||= getGlobalType("AsyncIterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalBuiltinAsyncIteratorTypes := func() /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): deferredGlobalBuiltinAsyncIteratorTypes ??= getGlobalBuiltinTypes(["ReadableStreamAsyncIterator"], 1) */ TODO
	}
	getGlobalAsyncIteratorObjectType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncIteratorObjectType ||= getGlobalType("AsyncIteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalAsyncGeneratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncGeneratorType ||= getGlobalType("AsyncGenerator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIterableType ||= getGlobalType("Iterable" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorType ||= getGlobalType("Iterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIterableIteratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIterableIteratorType ||= getGlobalType("IterableIterator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getBuiltinIteratorReturnType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		return /* TODO(ConditionalExpression): strictBuiltinIteratorReturn ? undefinedType : anyType */ TODO
	}
	getGlobalBuiltinIteratorTypes := func() /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType[] */ TODO {
		return /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): deferredGlobalBuiltinIteratorTypes ??= getGlobalBuiltinTypes(["ArrayIterator", "MapIterator", "SetIterator", "StringIterator"], 1) */ TODO
	}
	getGlobalIteratorObjectType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorObjectType ||= getGlobalType("IteratorObject" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalGeneratorType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalGeneratorType ||= getGlobalType("Generator" as __String, /*arity* / 3, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorYieldResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorYieldResultType ||= getGlobalType("IteratorYieldResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalIteratorReturnResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalIteratorReturnResultType ||= getGlobalType("IteratorReturnResult" as __String, /*arity* / 1, reportErrors) */ TODO) || emptyGenericType
	}
	getGlobalDisposableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalDisposableType ||= getGlobalType("Disposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalAsyncDisposableType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalAsyncDisposableType ||= getGlobalType("AsyncDisposable" as __String, /*arity* / 0, reportErrors) */ TODO) || emptyObjectType
	}
	getGlobalTypeOrUndefined := func(name __String, arity /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) *ObjectType {
		symbol := getGlobalSymbol(name, SymbolFlagsType, nil)
		return symbol && getTypeOfGlobalSymbol(symbol, arity) /* as */ /* TODO(TypeReference): GenericType */
	}
	getGlobalExtractSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalExtractSymbol ||= getGlobalTypeAliasSymbol("Extract" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalExtractSymbol === unknownSymbol ? undefined : deferredGlobalExtractSymbol */ TODO
	}
	getGlobalOmitSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalOmitSymbol ||= getGlobalTypeAliasSymbol("Omit" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalOmitSymbol === unknownSymbol ? undefined : deferredGlobalOmitSymbol */ TODO
	}
	getGlobalAwaitedSymbol := func(reportErrors bool) *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalAwaitedSymbol ||= getGlobalTypeAliasSymbol("Awaited" as __String, /*arity* / 1, reportErrors) || (reportErrors ? unknownSymbol : undefined); */
		return /* TODO(ConditionalExpression): deferredGlobalAwaitedSymbol === unknownSymbol ? undefined : deferredGlobalAwaitedSymbol */ TODO
	}
	getGlobalBigIntType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalBigIntType ||= getGlobalType("BigInt" as __String, /*arity* / 0, /*reportErrors* / false) */ TODO) || emptyObjectType
	}
	getGlobalClassDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassDecoratorContextType ??= getGlobalType("ClassDecoratorContext" as __String, /*arity* / 1, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassMethodDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassMethodDecoratorContextType ??= getGlobalType("ClassMethodDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassGetterDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassGetterDecoratorContextType ??= getGlobalType("ClassGetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassSetterDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassSetterDecoratorContextType ??= getGlobalType("ClassSetterDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorContextType ??= getGlobalType("ClassAccessorDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorTargetType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorTargetType ??= getGlobalType("ClassAccessorDecoratorTarget" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassAccessorDecoratorResultType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassAccessorDecoratorResultType ??= getGlobalType("ClassAccessorDecoratorResult" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalClassFieldDecoratorContextType := func(reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").GenericType */ TODO {
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (deferredGlobalClassFieldDecoratorContextType ??= getGlobalType("ClassFieldDecoratorContext" as __String, /*arity* / 2, reportErrors)) ?? emptyGenericType */ TODO
	}
	getGlobalNaNSymbol := func() *Symbol {
		return ( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): deferredGlobalNaNSymbol ||= getGlobalValueSymbol("NaN" as __String, /*reportErrors* / false) */ TODO)
	}
	getGlobalRecordSymbol := func() *Symbol {
		/* TODO(ExpressionStatement): deferredGlobalRecordSymbol ||= getGlobalTypeAliasSymbol("Record" as __String, /*arity* / 2, /*reportErrors* / true) || unknownSymbol; */
		return /* TODO(ConditionalExpression): deferredGlobalRecordSymbol === unknownSymbol ? undefined : deferredGlobalRecordSymbol */ TODO
	}
	createTypeFromGenericGlobalType := func(genericGlobalType GenericType, typeArguments []Type) ObjectType {
		return /* TODO(ConditionalExpression): genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType */ TODO
	}
	createTypedPropertyDescriptorType := func(propertyType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType() /* TODO(ArrayLiteralExpression): [propertyType] */, TODO)
	}
	createIterableType := func(iteratedType Type) Type {
		return createTypeFromGenericGlobalType(getGlobalIterableType(true) /* TODO(ArrayLiteralExpression): [iteratedType, voidType, undefinedType] */, TODO)
	}
	createArrayType := func(elementType Type, readonly bool) ObjectType {
		return createTypeFromGenericGlobalType( /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO /* TODO(ArrayLiteralExpression): [elementType] */, TODO)
	}
	getTupleElementFlags := func(node TypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Optional | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.OptionalType:                 return ElementFlags.Optional;             case SyntaxKind.RestType:                 return getRestTypeElementFlags(node as RestTypeNode);             case SyntaxKind.NamedTupleMember:                 return (node as NamedTupleMember).questionToken ? ElementFlags.Optional :                     (node as NamedTupleMember).dotDotDotToken ? getRestTypeElementFlags(node as NamedTupleMember) :                     ElementFlags.Required;             default:                 return ElementFlags.Required;         } */
	}
	getRestTypeElementFlags := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Rest | import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Variadic */ TODO {
		return /* TODO(ConditionalExpression): getArrayElementTypeNode(node.type) ? ElementFlags.Rest : ElementFlags.Variadic */ TODO
	}
	getArrayOrTupleTargetType := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) GenericType {
		readonly := isReadonlyTypeOperator(node.parent)
		elementType := getArrayElementTypeNode(node)
		if elementType {
			return /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
		}
		elementFlags := map_((node /* as */ /* TODO(TypeReference): TupleTypeNode */).elements, getTupleElementFlags)
		return getTupleTargetType(elementFlags, readonly, map_((node /* as */ /* TODO(TypeReference): TupleTypeNode */).elements, memberIfLabeledElementDeclaration))
	}
	memberIfLabeledElementDeclaration := func(member Node) /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any {
		return /* TODO(ConditionalExpression): isNamedTupleMember(member) || isParameter(member) ? member : undefined */ TODO
	}
	isDeferredTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ArrayTypeNode | TupleTypeNode */ any, hasDefaultTypeArguments bool) /* TODO(undefined): boolean */ TODO {
		return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && ( /* TODO(ConditionalExpression): node.kind === SyntaxKind.ArrayType ? mayResolveTypeAlias(node.elementType) :                         node.kind === SyntaxKind.TupleType ? some(node.elements, mayResolveTypeAlias) :                         hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias) */ TODO)
	}
	isResolvedByTypeAlias := func(node Node) bool {
		parent := node.parent
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.ParenthesizedType:             case SyntaxKind.NamedTupleMember:             case SyntaxKind.TypeReference:             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:             case SyntaxKind.IndexedAccessType:             case SyntaxKind.ConditionalType:             case SyntaxKind.TypeOperator:             case SyntaxKind.ArrayType:             case SyntaxKind.TupleType:                 return isResolvedByTypeAlias(parent);             case SyntaxKind.TypeAliasDeclaration:                 return true;         } */
		return false
	}
	mayResolveTypeAlias := func(node Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.TypeReference:                 return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node as TypeReferenceNode, SymbolFlags.Type).flags & SymbolFlags.TypeAlias);             case SyntaxKind.TypeQuery:                 return true;             case SyntaxKind.TypeOperator:                 return (node as TypeOperatorNode).operator !== SyntaxKind.UniqueKeyword && mayResolveTypeAlias((node as TypeOperatorNode).type);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.OptionalType:             case SyntaxKind.NamedTupleMember:             case SyntaxKind.JSDocOptionalType:             case SyntaxKind.JSDocNullableType:             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocTypeExpression:                 return mayResolveTypeAlias((node as ParenthesizedTypeNode | OptionalTypeNode | JSDocTypeReferencingNode | NamedTupleMember).type);             case SyntaxKind.RestType:                 return (node as RestTypeNode).type.kind !== SyntaxKind.ArrayType || mayResolveTypeAlias(((node as RestTypeNode).type as ArrayTypeNode).elementType);             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:                 return some((node as UnionOrIntersectionTypeNode).types, mayResolveTypeAlias);             case SyntaxKind.IndexedAccessType:                 return mayResolveTypeAlias((node as IndexedAccessTypeNode).objectType) || mayResolveTypeAlias((node as IndexedAccessTypeNode).indexType);             case SyntaxKind.ConditionalType:                 return mayResolveTypeAlias((node as ConditionalTypeNode).checkType) || mayResolveTypeAlias((node as ConditionalTypeNode).extendsType) ||                     mayResolveTypeAlias((node as ConditionalTypeNode).trueType) || mayResolveTypeAlias((node as ConditionalTypeNode).falseType);         } */
		return false
	}
	getTypeFromArrayOrTupleTypeNode := func(node /* TODO(UnionType): ArrayTypeNode | TupleTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			target := getArrayOrTupleTargetType(node)
			if target == emptyGenericType {
				links.resolvedType = emptyObjectType
			} else if !(node.kind == SyntaxKindTupleType && some(node.elements, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(getTupleElementFlags(e) & ElementFlags.Variadic) */
			})) && isDeferredTypeReferenceNode(node) {
				links.resolvedType = /* TODO(ConditionalExpression): node.kind === SyntaxKind.TupleType && node.elements.length === 0 ? target :                     createDeferredTypeReference(target, node, /*mapper* / undefined) */ TODO
			} else {
				elementTypes := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ArrayType ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode) */ TODO
				links.resolvedType = createNormalizedTypeReference(target, elementTypes)
			}
		}
		return links.resolvedType
	}
	isReadonlyTypeOperator := func(node Node) /* TODO(undefined): boolean */ TODO {
		return isTypeOperatorNode(node) && node.operator == SyntaxKindReadonlyKeyword
	}
	createTupleType := func(elementTypes []Type, elementFlags []ElementFlags, readonly /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any /* = */ /* TODO(ArrayLiteralExpression): [] */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		tupleTarget := getTupleTargetType(elementFlags || map_(elementTypes, func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags.Required */ TODO {
			/* TODO(Identifier): ElementFlags */
			/* TODO(Identifier): Required */
		}), readonly, namedMemberDeclarations)
		return /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) :             tupleTarget */ TODO
	}
	getTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) GenericType {
		if elementFlags.length == 1 && /* TODO(ElementAccessExpression): elementFlags[0] */ TODO&ElementFlagsRest {
			return /* TODO(ConditionalExpression): readonly ? globalReadonlyArrayType : globalArrayType */ TODO
		}
		key := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): map(elementFlags, f => f & ElementFlags.Required ? "#" : f & ElementFlags.Optional ? "?" : f & ElementFlags.Rest ? "." : "*").join() +             (readonly ? "R" : "") +             (some(namedMemberDeclarations, node => !!node) ? "," + map(namedMemberDeclarations, node => node ? getNodeId(node) : "_").join(",") : "") */ TODO
		type_ := tupleTypes.get(key)
		if !type_ {
			tupleTypes.set(key /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) */, TODO)
		}
		return type_
	}
	createTupleTargetType := func(elementFlags []ElementFlags, readonly bool, namedMemberDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) TupleType {
		arity := elementFlags.length
		minLength := countWhere(elementFlags, func(f /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(f & (ElementFlags.Required | ElementFlags.Variadic)) */
		})
		var typeParameters /* TODO(ArrayType): TypeParameter[] */ any
		var properties []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		combinedFlags := 0 /* as */ /* TODO(TypeReference): ElementFlags */
		if arity {
			typeParameters = /* TODO(NewExpression): new Array(arity) */ TODO
			/* TODO(ForStatement): for (let i = 0; i < arity; i++) {                 const typeParameter = typeParameters[i] = createTypeParameter();                 const flags = elementFlags[i];                 combinedFlags |= flags;                 if (!(combinedFlags & ElementFlags.Variable)) {                     const property = createSymbol(SymbolFlags.Property | (flags & ElementFlags.Optional ? SymbolFlags.Optional : 0), "" + i as __String, readonly ? CheckFlags.Readonly : 0);                     property.links.tupleLabelDeclaration = namedMemberDeclarations?.[i];                     property.links.type = typeParameter;                     properties.push(property);                 }             } */
		}
		fixedLength := properties.length
		lengthSymbol := createSymbol(SymbolFlagsProperty, "length" /* as */ /* TODO(TypeReference): __String */ /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */, TODO)
		if combinedFlags & ElementFlagsVariable {
			lengthSymbol.links.type_ = numberType
		} else {
			literalTypes := /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(ForStatement): for (let i = minLength; i <= arity; i++) literalTypes.push(getNumberLiteralType(i)); */
			lengthSymbol.links.type_ = getUnionType(literalTypes)
		}
		properties.push(lengthSymbol)
		type_ := createObjectType(ObjectFlagsTuple | ObjectFlagsReference) /* as */ /* TODO(IntersectionType): TupleType & InterfaceTypeWithDeclaredMembers */
		type_.typeParameters = typeParameters
		type_.outerTypeParameters = nil
		type_.localTypeParameters = typeParameters
		type_.instantiations = /* TODO(NewExpression): new Map<string, TypeReference>() */ TODO
		type_.instantiations.set(getTypeListId(type_.typeParameters), type_ /* as */ /* TODO(TypeReference): GenericType */)
		type_.target = type_ /* as */ /* TODO(TypeReference): GenericType */
		type_.resolvedTypeArguments = type_.typeParameters
		type_.thisType = createTypeParameter()
		type_.thisType.isThisType = true
		type_.thisType.constraint = type_
		type_.declaredProperties = properties
		type_.declaredCallSignatures = emptyArray
		type_.declaredConstructSignatures = emptyArray
		type_.declaredIndexInfos = emptyArray
		type_.elementFlags = elementFlags
		type_.minLength = minLength
		type_.fixedLength = fixedLength
		type_.hasRestElement = !!(combinedFlags & ElementFlagsVariable)
		type_.combinedFlags = combinedFlags
		type_.readonly = readonly
		type_.labeledElementDeclarations = namedMemberDeclarations
		return type_
	}
	createNormalizedTypeReference := func(target GenericType, typeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): target.objectFlags & ObjectFlags.Tuple ? createNormalizedTupleType(target as TupleType, typeArguments!) : createTypeReference(target, typeArguments) */ TODO
	}
	createNormalizedTupleType := func(target TupleType, elementTypes []Type) Type {
		if !(target.combinedFlags & ElementFlagsNonRequired) {
			return createTypeReference(target, elementTypes)
		}
		if target.combinedFlags & ElementFlagsVariadic {
			unionIndex := findIndex(elementTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(target.elementFlags[i] & ElementFlags.Variadic && t.flags & (TypeFlags.Never | TypeFlags.Union)) */
			})
			if unionIndex >= 0 {
				return /* TODO(ConditionalExpression): checkCrossProductUnion(map(elementTypes, (t, i) => target.elementFlags[i] & ElementFlags.Variadic ? t : unknownType)) ?                     mapType(elementTypes[unionIndex], t => createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))) :                     errorType */ TODO
			}
		}
		var expandedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var expandedFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
		var expandedDeclarations [] /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		lastRequiredIndex := -1
		firstRestIndex := -1
		lastOptionalOrRestIndex := -1
		/* TODO(ForStatement): for (let i = 0; i < elementTypes.length; i++) {             const type = elementTypes[i];             const flags = target.elementFlags[i];             if (flags & ElementFlags.Variadic) {                 if (type.flags & TypeFlags.Any) {                     addElement(type, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }                 else if (type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type)) {                     // Generic variadic elements stay as they are.                     addElement(type, ElementFlags.Variadic, target.labeledElementDeclarations?.[i]);                 }                 else if (isTupleType(type)) {                     const elements = getElementTypes(type);                     if (elements.length + expandedTypes.length >= 10_000) {                         error(                             currentNode,                             isPartOfTypeNode(currentNode!)                                 ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent                                 : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent,                         );                         return errorType;                     }                     // Spread variadic elements with tuple types into the resulting tuple.                     forEach(elements, (t, n) => addElement(t, type.target.elementFlags[n], type.target.labeledElementDeclarations?.[n]));                 }                 else {                     // Treat everything else as an array type and create a rest element.                     addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, ElementFlags.Rest, target.labeledElementDeclarations?.[i]);                 }             }             else {                 // Copy other element kinds with no change.                 addElement(type, flags, target.labeledElementDeclarations?.[i]);             }         } */
		/* TODO(ForStatement): for (let i = 0; i < lastRequiredIndex; i++) {             if (expandedFlags[i] & ElementFlags.Optional) expandedFlags[i] = ElementFlags.Required;         } */
		if firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex {
			/* TODO(ElementAccessExpression): expandedTypes[firstRestIndex] */ TODO = getUnionType(sameMap(expandedTypes.slice(firstRestIndex /* TODO(PlusToken): + */ /* TODO(BinaryExpression): lastOptionalOrRestIndex + 1 */, TODO), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(BinaryExpression): expandedFlags[firstRestIndex + i] & ElementFlags.Variadic */
				/* TODO(QuestionToken): ? */
				/* TODO(CallExpression): getIndexedAccessType(t, numberType) */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): t */
			}))
			expandedTypes.splice( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
			expandedFlags.splice( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
			expandedDeclarations.splice( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): firstRestIndex + 1 */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): lastOptionalOrRestIndex - firstRestIndex */, TODO)
		}
		tupleTarget := getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations)
		return /* TODO(ConditionalExpression): tupleTarget === emptyGenericType ? emptyObjectType :             expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) :             tupleTarget */ TODO
		addElement := func(type_ Type, flags ElementFlags, declaration /* TODO(UnionType): NamedTupleMember | ParameterDeclaration | undefined */ any) {
			if flags & ElementFlagsRequired {
				lastRequiredIndex = expandedFlags.length
			}
			if flags&ElementFlagsRest && firstRestIndex < 0 {
				firstRestIndex = expandedFlags.length
			}
			if flags & (ElementFlagsOptional | ElementFlagsRest) {
				lastOptionalOrRestIndex = expandedFlags.length
			}
			expandedTypes.push( /* TODO(ConditionalExpression): flags & ElementFlags.Optional ? addOptionality(type, /*isProperty* / true) : type */ TODO)
			expandedFlags.push(flags)
			expandedDeclarations.push(declaration)
		}
	}
	sliceTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		target := type_.target
		endIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
		return /* TODO(ConditionalExpression): index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(emptyArray) :             createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), /*readonly* / false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex)) */ TODO
	}
	getKnownKeysOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getUnionType(append(arrayOf(type_.target.fixedLength, func(i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralType */ TODO {
			/* TODO(Identifier): getStringLiteralType */
			/* TODO(BinaryExpression): "" + i */
		}), getIndexType( /* TODO(ConditionalExpression): type.target.readonly ? globalReadonlyArrayType : globalArrayType */ TODO)))
	}
	getStartElementCount := func(type_ TupleType, flags ElementFlags) /* TODO(undefined): number */ TODO {
		index := findIndex(type_.elementFlags, func(f /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(ParenthesizedExpression): (f & flags) */
		})
		return /* TODO(ConditionalExpression): index >= 0 ? index : type.elementFlags.length */ TODO
	}
	getEndElementCount := func(type_ TupleType, flags ElementFlags) /* TODO(undefined): number */ TODO {
		return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): type.elementFlags.length - findLastIndex(type.elementFlags, f => !(f & flags)) - 1 */ TODO
	}
	getTotalFixedElementCount := func(type_ TupleType) /* TODO(undefined): number */ TODO {
		return /* TODO(PlusToken): + */ /* TODO(BinaryExpression): type.fixedLength + getEndElementCount(type, ElementFlags.Fixed) */ TODO
	}
	getElementTypes := func(type_ TupleTypeReference) []Type {
		typeArguments := getTypeArguments(type_)
		arity := getTypeReferenceArity(type_)
		return /* TODO(ConditionalExpression): typeArguments.length === arity ? typeArguments : typeArguments.slice(0, arity) */ TODO
	}
	getTypeFromOptionalTypeNode := func(node OptionalTypeNode) Type {
		return addOptionality(getTypeFromTypeNode(node.type_), true)
	}
	getTypeId := func(type_ Type) TypeId {
		return type_.id
	}
	containsType := func(types []Type, type_ Type) bool {
		return binarySearch(types, type_, getTypeId, compareValues) >= 0
	}
	insertType := func(types []Type, type_ Type) bool {
		index := binarySearch(types, type_, getTypeId, compareValues)
		if index < 0 {
			types.splice(~index, 0, type_)
			return true
		}
		return false
	}
	addTypeToUnion := func(typeSet []Type, includes TypeFlags, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		flags := type_.flags
		if !(flags & TypeFlagsNever) {
			includes |= flags & TypeFlagsIncludesMask
			if flags & TypeFlagsInstantiable {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesInstantiable */
			}
			if flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesConstrainedTypeVariable */
			}
			if type_ == wildcardType {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesWildcard */
			}
			if isErrorType(type_) {
				/* TODO(BinaryExpression): includes |= TypeFlags.IncludesError */
			}
			if !strictNullChecks && flags&TypeFlagsNullable {
				if !(getObjectFlags(type_) & ObjectFlagsContainsWideningType) {
					/* TODO(BinaryExpression): includes |= TypeFlags.IncludesNonWideningType */
				}
			} else {
				len := typeSet.length
				index := /* TODO(ConditionalExpression): len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues) */ TODO
				if index < 0 {
					typeSet.splice(~index, 0, type_)
				}
			}
		}
		return includes
	}
	addTypesToUnion := func(typeSet []Type, includes TypeFlags, types []Type) TypeFlags {
		var lastType *Type
		for _, type_ := range types {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== lastType */ TODO {
				includes = /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ?                     addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? TypeFlags.Union : 0), (type as UnionType).types) :                     addTypeToUnion(typeSet, includes, type) */ TODO
				lastType = type_
			}
		}
		return includes
	}
	removeSubtypes := func(types []Type, hasObjectTypes bool) /* TODO(ArrayType): Type[] */ any {
		if types.length < 2 {
			return types
		}
		id := getTypeListId(types)
		match := subtypeReductionCache.get(id)
		if match {
			return match
		}
		hasEmptyObject := hasObjectTypes && some(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): !!(t.flags & TypeFlags.Object) && !isGenericMappedType(t) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isEmptyResolvedType(resolveStructuredTypeMembers(t as ObjectType)) */
		})
		len := types.length
		i := len
		count := 0
		/* TODO(WhileStatement): while (i > 0) {             i--;             const source = types[i];             if (hasEmptyObject || source.flags & TypeFlags.StructuredOrInstantiable) {                 // A type parameter with a union constraint may be a subtype of some union, but not a subtype of the                 // individual constituents of that union. For example, `T extends A | B` is a subtype of `A | B`, but not                 // a subtype of just `A` or just `B`. When we encounter such a type parameter, we therefore check if the                 // type parameter is a subtype of a union of all the other types.                 if (source.flags & TypeFlags.TypeParameter && getBaseConstraintOrType(source).flags & TypeFlags.Union) {                     if (isTypeRelatedTo(source, getUnionType(map(types, t => t === source ? neverType : t)), strictSubtypeRelation)) {                         orderedRemoveItemAt(types, i);                     }                     continue;                 }                 // Find the first property with a unit type, if any. When constituents have a property by the same name                 // but of a different unit type, we can quickly disqualify them from subtype checks. This helps subtype                 // reduction of large discriminated union types.                 const keyProperty = source.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive) ?                     find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) :                     undefined;                 const keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));                 for (const target of types) {                     if (source !== target) {                         if (count === 100000) {                             // After 100000 subtype checks we estimate the remaining amount of work by assuming the                             // same ratio of checks per element. If the estimated number of remaining type checks is                             // greater than 1M we deem the union type too complex to represent. This for example                             // caps union types at 1000 unique object types.                             const estimatedCount = (count / (len - i)) * len;                             if (estimatedCount > 1000000) {                                 tracing?.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", { typeIds: types.map(t => t.id) });                                 error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);                                 return undefined;                             }                         }                         count++;                         if (keyProperty && target.flags & (TypeFlags.Object | TypeFlags.Intersection | TypeFlags.InstantiableNonPrimitive)) {                             const t = getTypeOfPropertyOfType(target, keyProperty.escapedName);                             if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {                                 continue;                             }                         }                         if (                             isTypeRelatedTo(source, target, strictSubtypeRelation) && (                                 !(getObjectFlags(getTargetType(source)) & ObjectFlags.Class) ||                                 !(getObjectFlags(getTargetType(target)) & ObjectFlags.Class) ||                                 isTypeDerivedFrom(source, target)                             )                         ) {                             orderedRemoveItemAt(types, i);                             break;                         }                     }                 }             }         } */
		subtypeReductionCache.set(id, types)
		return types
	}
	removeRedundantLiteralTypes := func(types []Type, includes TypeFlags, reduceVoidUndefined bool) {
		i := types.length
		/* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             const flags = t.flags;             const remove = flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) && includes & TypeFlags.String ||                 flags & TypeFlags.NumberLiteral && includes & TypeFlags.Number ||                 flags & TypeFlags.BigIntLiteral && includes & TypeFlags.BigInt ||                 flags & TypeFlags.UniqueESSymbol && includes & TypeFlags.ESSymbol ||                 reduceVoidUndefined && flags & TypeFlags.Undefined && includes & TypeFlags.Void ||                 isFreshLiteralType(t) && containsType(types, (t as LiteralType).regularType);             if (remove) {                 orderedRemoveItemAt(types, i);             }         } */
	}
	removeStringLiteralsMatchedByTemplateLiterals := func(types []Type) {
		patterns := filter(types, isPatternLiteralType) /* as */ /* TODO(ArrayType): (TemplateLiteralType | StringMappingType)[] */
		templateLiterals := filter(patterns, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.TemplateLiteral) */
		}) /* as */ /* TODO(ArrayType): TemplateLiteralType[] */
		estimatedCount := /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): templateLiterals.length * countWhere(types, t => !!(t.flags & TypeFlags.StringLiteral)) */ TODO
		if estimatedCount > 0 {
			trie := createPrefixSuffixTrie()
			forEach(templateLiterals, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType */ TODO) {
				prefix := /* TODO(ElementAccessExpression): t.texts[0] */ TODO
				suffix := /* TODO(ElementAccessExpression): t.texts[t.texts.length - 1] */ TODO
				trie.set(prefix, suffix, func(templates /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType[] | undefined */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType[] */ TODO {
					/* TODO(Identifier): append */
					/* TODO(Identifier): templates */
					/* TODO(Identifier): t */
				})
			})
			i := types.length
			/* TODO(LabeledStatement): outer: while (i > 0) {                 i--;                 const t = types[i];                 if (!(t.flags & TypeFlags.StringLiteral)) continue;                 const text = (t as StringLiteralType).value;                  for (const templates of trie.iterateAllMatches(text)) {                     if (some(templates, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {                         orderedRemoveItemAt(types, i);                         continue outer;                     }                 }             } */
			patterns = filter(patterns, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType | import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.StringMapping) */
			}) /* as */ /* TODO(ArrayType): StringMappingType[] */
		}
		if patterns.length {
			i := types.length
			/* TODO(WhileStatement): while (i > 0) {                 i--;                 const t = types[i];                 if (!(t.flags & TypeFlags.StringLiteral)) continue;                 if (some(patterns, template => isTypeMatchedByTemplateLiteralOrStringMapping(t, template))) {                     orderedRemoveItemAt(types, i);                 }             } */
		}
	}
	isTypeMatchedByTemplateLiteralOrStringMapping := func(type_ Type, template /* TODO(UnionType): TemplateLiteralType | StringMappingType */ any) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): template.flags & TypeFlags.TemplateLiteral ?             isTypeMatchedByTemplateLiteralType(type, template as TemplateLiteralType) :             isMemberOfStringMapping(type, template) */ TODO
	}
	removeConstrainedTypeVariables := func(types []Type) {
		var typeVariables []TypeVariable = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, type_ := range types {
			if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
				index := /* TODO(ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
				pushIfUnique(typeVariables /* TODO(ElementAccessExpression): (type as IntersectionType).types[index] */, TODO)
			}
		}
		for _, typeVariable := range typeVariables {
			var primitives []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, type_ := range types {
				if type_.flags&TypeFlagsIntersection && getObjectFlags(type_)&ObjectFlagsIsConstrainedTypeVariable {
					index := /* TODO(ConditionalExpression): (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
					if /* TODO(ElementAccessExpression): (type as IntersectionType).types[index] */ TODO == typeVariable {
						insertType(primitives /* TODO(ElementAccessExpression): (type as IntersectionType).types[1 - index] */, TODO)
					}
				}
			}
			constraint := /* TODO(NonNullExpression): getBaseConstraintOfType(typeVariable)! */ TODO
			if everyType(constraint, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): containsType */
				/* TODO(Identifier): primitives */
				/* TODO(Identifier): t */
			}) {
				i := types.length
				/* TODO(WhileStatement): while (i > 0) {                     i--;                     const type = types[i];                     if (type.flags & TypeFlags.Intersection && getObjectFlags(type) & ObjectFlags.IsConstrainedTypeVariable) {                         const index = (type as IntersectionType).types[0].flags & TypeFlags.TypeVariable ? 0 : 1;                         if ((type as IntersectionType).types[index] === typeVariable && containsType(primitives, (type as IntersectionType).types[1 - index])) {                             orderedRemoveItemAt(types, i);                         }                     }                 } */
				insertType(types, typeVariable)
			}
		}
	}
	isNamedUnionType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags&TypeFlagsUnion && (type_.aliasSymbol || (type_ /* as */ /* TODO(TypeReference): UnionType */).origin))
	}
	addNamedUnions := func(namedUnions []Type, types []Type) {
		for _, t := range types {
			if t.flags & TypeFlagsUnion {
				origin := (t /* as */ /* TODO(TypeReference): UnionType */).origin
				if t.aliasSymbol || origin && !(origin.flags&TypeFlagsUnion) {
					pushIfUnique(namedUnions, t)
				} else if origin && origin.flags&TypeFlagsUnion {
					addNamedUnions(namedUnions, (origin /* as */ /* TODO(TypeReference): UnionType */).types)
				}
			}
		}
	}
	createOriginUnionOrIntersectionType := func(flags TypeFlags, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").UnionOrIntersectionType */ TODO {
		result := createOriginType(flags) /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
		result.types = types
		return result
	}
	getUnionType := func(types []Type, unionReduction UnionReduction /* = */ /* TODO(PropertyAccessExpression): UnionReduction.Literal */, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		if types.length == 2 && !origin && ( /* TODO(ElementAccessExpression): types[0] */ TODO.flags&TypeFlagsUnion || /* TODO(ElementAccessExpression): types[1] */ TODO.flags&TypeFlagsUnion) {
			infix := /* TODO(ConditionalExpression): unionReduction === UnionReduction.None ? "N" : unionReduction === UnionReduction.Subtype ? "S" : "L" */ TODO
			index := /* TODO(ConditionalExpression): types[0].id < types[1].id ? 0 : 1 */ TODO
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): types[index].id + infix + types[1 - index].id + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			type_ := unionOfUnionTypes.get(id)
			if !type_ {
				type_ = getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, nil)
				unionOfUnionTypes.set(id, type_)
			}
			return type_
		}
		return getUnionTypeWorker(types, unionReduction, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionTypeWorker := func(types []Type, unionReduction UnionReduction, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, origin *Type) Type {
		var typeSet /* TODO(ArrayType): Type[] */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		includes := addTypesToUnion(typeSet, 0 /* as */ /* TODO(TypeReference): TypeFlags */, types)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): unionReduction !== UnionReduction.None */ TODO {
			if includes & TypeFlagsAnyOrUnknown {
				return /* TODO(ConditionalExpression): includes & TypeFlags.Any ?                     includes & TypeFlags.IncludesWildcard ? wildcardType :                         includes & TypeFlags.IncludesError ? errorType : anyType :                     unknownType */ TODO
			}
			if includes & TypeFlagsUndefined {
				if typeSet.length >= 2 && /* TODO(ElementAccessExpression): typeSet[0] */ TODO == undefinedType && /* TODO(ElementAccessExpression): typeSet[1] */ TODO == missingType {
					orderedRemoveItemAt(typeSet, 1)
				}
			}
			if includes&(TypeFlagsEnum|TypeFlagsLiteral|TypeFlagsUniqueESSymbol|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsVoid && includes&TypeFlagsUndefined {
				removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & UnionReductionSubtype))
			}
			if includes&TypeFlagsStringLiteral && includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) {
				removeStringLiteralsMatchedByTemplateLiterals(typeSet)
			}
			if includes & TypeFlagsIncludesConstrainedTypeVariable {
				removeConstrainedTypeVariables(typeSet)
			}
			if unionReduction == UnionReductionSubtype {
				typeSet = removeSubtypes(typeSet, !!(includes & TypeFlagsObject))
				if !typeSet {
					return errorType
				}
			}
			if typeSet.length == 0 {
				return /* TODO(ConditionalExpression): includes & TypeFlags.Null ? includes & TypeFlags.IncludesNonWideningType ? nullType : nullWideningType :                     includes & TypeFlags.Undefined ? includes & TypeFlags.IncludesNonWideningType ? undefinedType : undefinedWideningType :                     neverType */ TODO
			}
		}
		if !origin && includes&TypeFlagsUnion {
			var namedUnions []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			addNamedUnions(namedUnions, types)
			var reducedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, t := range typeSet {
				if !some(namedUnions, func(union /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): containsType */
					/* TODO(PropertyAccessExpression): (union as UnionType).types */
					/* TODO(Identifier): t */
				}) {
					reducedTypes.push(t)
				}
			}
			if !aliasSymbol && namedUnions.length == 1 && reducedTypes.length == 0 {
				return /* TODO(ElementAccessExpression): namedUnions[0] */ TODO
			}
			namedTypesCount := reduceLeft(namedUnions, func(sum /* TODO(undefined): number */ TODO, union /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): number */ TODO {
				/* TODO(Identifier): sum */
				/* TODO(PlusToken): + */
				/* TODO(PropertyAccessExpression): (union as UnionType).types.length */
			}, 0)
			if /* TODO(PlusToken): + */ /* TODO(BinaryExpression): namedTypesCount + reducedTypes.length */ TODO == typeSet.length {
				for _, t := range namedUnions {
					insertType(reducedTypes, t)
				}
				origin = createOriginUnionOrIntersectionType(TypeFlagsUnion, reducedTypes)
			}
		}
		objectFlags := ( /* TODO(ConditionalExpression): includes & TypeFlags.NotPrimitiveUnion ? 0 : ObjectFlags.PrimitiveUnion */ TODO) | ( /* TODO(ConditionalExpression): includes & TypeFlags.Intersection ? ObjectFlags.ContainsIntersections : 0 */ TODO)
		return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin)
	}
	getUnionOrIntersectionTypePredicate := func(signatures []Signature, kind *TypeFlags) *TypePredicate {
		var last *TypePredicate
		var types []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, sig := range signatures {
			pred := getTypePredicateOfSignature(sig)
			if pred {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): pred.kind !== TypePredicateKind.This */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): pred.kind !== TypePredicateKind.Identifier */ TODO || last && !typePredicateKindsMatch(last, pred) {
					return nil
				}
				last = pred
				types.push(pred.type_)
			} else {
				returnType := /* TODO(ConditionalExpression): kind !== TypeFlags.Intersection ? getReturnTypeOfSignature(sig) : undefined */ TODO
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): returnType !== falseType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): returnType !== regularFalseType */ TODO {
					return nil
				}
			}
		}
		if !last {
			return nil
		}
		compositeType := getUnionOrIntersectionType(types, kind)
		return createTypePredicate(last.kind, last.parameterName, last.parameterIndex, compositeType)
	}
	typePredicateKindsMatch := func(a TypePredicate, b TypePredicate) bool {
		return a.kind == b.kind && a.parameterIndex == b.parameterIndex
	}
	getUnionTypeFromSortedList := func(types []Type, precomputedObjectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type, origin Type) Type {
		if types.length == 0 {
			return neverType
		}
		if types.length == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		typeKey := /* TODO(ConditionalExpression): !origin ? getTypeListId(types) :             origin.flags & TypeFlags.Union ? `|${getTypeListId((origin as UnionType).types)}` :             origin.flags & TypeFlags.Intersection ? `&${getTypeListId((origin as IntersectionType).types)}` :             `#${(origin as IndexType).type.id}|${getTypeListId(types)}` */ TODO
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeKey + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
		type_ := unionTypes.get(id)
		if !type_ {
			type_ = createType(TypeFlagsUnion) /* as */ /* TODO(TypeReference): UnionType */
			type_.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, TypeFlagsNullable)
			type_.types = types
			type_.origin = origin
			type_.aliasSymbol = aliasSymbol
			type_.aliasTypeArguments = aliasTypeArguments
			if types.length == 2 && /* TODO(ElementAccessExpression): types[0] */ TODO.flags&TypeFlagsBooleanLiteral && /* TODO(ElementAccessExpression): types[1] */ TODO.flags&TypeFlagsBooleanLiteral {
				type_.flags |= TypeFlagsBoolean
				(type_ /* as */ /* TODO(IntersectionType): UnionType & IntrinsicType */).intrinsicName = "boolean"
			}
			unionTypes.set(id, type_)
		}
		return type_
	}
	getTypeFromUnionTypeNode := func(node UnionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			links.resolvedType = getUnionType(map_(node.types, getTypeFromTypeNode), UnionReductionLiteral, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	addTypeToIntersection := func(typeSet Map[string, Type], includes TypeFlags, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		flags := type_.flags
		if flags & TypeFlagsIntersection {
			return addTypesToIntersection(typeSet, includes, (type_ /* as */ /* TODO(TypeReference): IntersectionType */).types)
		}
		if isEmptyAnonymousObjectType(type_) {
			if !(includes & TypeFlagsIncludesEmptyObject) {
				includes |= TypeFlagsIncludesEmptyObject
				typeSet.set(type_.id.toString(), type_)
			}
		} else {
			if flags & TypeFlagsAnyOrUnknown {
				if type_ == wildcardType {
					/* TODO(BinaryExpression): includes |= TypeFlags.IncludesWildcard */
				}
				if isErrorType(type_) {
					/* TODO(BinaryExpression): includes |= TypeFlags.IncludesError */
				}
			} else if strictNullChecks || !(flags & TypeFlagsNullable) {
				if type_ == missingType {
					includes |= TypeFlagsIncludesMissingType
					type_ = undefinedType
				}
				if !typeSet.has(type_.id.toString()) {
					if type_.flags&TypeFlagsUnit && includes&TypeFlagsUnit {
						includes |= TypeFlagsNonPrimitive
					}
					typeSet.set(type_.id.toString(), type_)
				}
			}
			includes |= flags & TypeFlagsIncludesMask
		}
		return includes
	}
	addTypesToIntersection := func(typeSet Map[string, Type], includes TypeFlags, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO {
		for _, type_ := range types {
			includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type_))
		}
		return includes
	}
	removeRedundantSupertypes := func(types []Type, includes TypeFlags) {
		i := types.length
		/* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             const remove = t.flags & TypeFlags.String && includes & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ||                 t.flags & TypeFlags.Number && includes & TypeFlags.NumberLiteral ||                 t.flags & TypeFlags.BigInt && includes & TypeFlags.BigIntLiteral ||                 t.flags & TypeFlags.ESSymbol && includes & TypeFlags.UniqueESSymbol ||                 t.flags & TypeFlags.Void && includes & TypeFlags.Undefined ||                 isEmptyAnonymousObjectType(t) && includes & TypeFlags.DefinitelyNonNullable;             if (remove) {                 orderedRemoveItemAt(types, i);             }         } */
	}
	eachUnionContains := func(unionTypes []UnionType, type_ Type) /* TODO(undefined): boolean */ TODO {
		for _, u := range unionTypes {
			if !containsType(u.types, type_) {
				if type_ == missingType {
					return containsType(u.types, undefinedType)
				}
				if type_ == undefinedType {
					return containsType(u.types, missingType)
				}
				primitive := /* TODO(ConditionalExpression): type.flags & TypeFlags.StringLiteral ? stringType :                     type.flags & (TypeFlags.Enum | TypeFlags.NumberLiteral) ? numberType :                     type.flags & TypeFlags.BigIntLiteral ? bigintType :                     type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :                     undefined */ TODO
				if !primitive || !containsType(u.types, primitive) {
					return false
				}
			}
		}
		return true
	}
	extractRedundantTemplateLiterals := func(types []Type) bool {
		i := types.length
		literals := filter(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.StringLiteral) */
		})
		/* TODO(WhileStatement): while (i > 0) {             i--;             const t = types[i];             if (!(t.flags & (TypeFlags.TemplateLiteral | TypeFlags.StringMapping))) continue;             for (const t2 of literals) {                 if (isTypeSubtypeOf(t2, t)) {                     // For example, `get${T}` & "getX" is just "getX", and Lowercase<string> & "foo" is just "foo"                     orderedRemoveItemAt(types, i);                     break;                 }                 else if (isPatternLiteralType(t)) {                     return true;                 }             }         } */
		return false
	}
	removeFromEach := func(types []Type, flag TypeFlags) {
		/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {             types[i] = filterType(types[i], t => !(t.flags & flag));         } */
	}
	intersectUnionsOfPrimitiveTypes := func(types []Type) /* TODO(undefined): boolean */ TODO {
		var unionTypes /* TODO(ArrayType): UnionType[] */ any
		index := findIndex(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(getObjectFlags(t) & ObjectFlags.PrimitiveUnion) */
		})
		if index < 0 {
			return false
		}
		i := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): index + 1 */ TODO
		/* TODO(WhileStatement): while (i < types.length) {             const t = types[i];             if (getObjectFlags(t) & ObjectFlags.PrimitiveUnion) {                 (unionTypes || (unionTypes = [types[index] as UnionType])).push(t as UnionType);                 orderedRemoveItemAt(types, i);             }             else {                 i++;             }         } */
		if !unionTypes {
			return false
		}
		var checked []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, u := range unionTypes {
			for _, t := range u.types {
				if insertType(checked, t) {
					if eachUnionContains(unionTypes, t) {
						if t == undefinedType && result.length && /* TODO(ElementAccessExpression): result[0] */ TODO == missingType {
							/* TODO(ContinueStatement): continue; */
						}
						if t == missingType && result.length && /* TODO(ElementAccessExpression): result[0] */ TODO == undefinedType {
							/* TODO(ElementAccessExpression): result[0] */ TODO = missingType
							/* TODO(ContinueStatement): continue; */
						}
						insertType(result, t)
					}
				}
			}
		}
		/* TODO(ElementAccessExpression): types[index] */ TODO = getUnionTypeFromSortedList(result, ObjectFlagsPrimitiveUnion)
		return true
	}
	createIntersectionType := func(types []Type, objectFlags ObjectFlags, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionType */ TODO {
		result := createType(TypeFlagsIntersection) /* as */ /* TODO(TypeReference): IntersectionType */
		result.objectFlags = objectFlags | getPropagatingFlagsOfTypes(types, TypeFlagsNullable)
		result.types = types
		result.aliasSymbol = aliasSymbol
		result.aliasTypeArguments = aliasTypeArguments
		return result
	}
	getIntersectionType := func(types []Type, flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntersectionFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IntersectionFlags.None */, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeMembershipMap := /* TODO(NewExpression): new Map<string, Type>() */ TODO
		includes := addTypesToIntersection(typeMembershipMap, 0 /* as */ /* TODO(TypeReference): TypeFlags */, types)
		var typeSet []Type = arrayFrom(typeMembershipMap.values())
		objectFlags := ObjectFlagsNone
		if includes & TypeFlagsNever {
			return /* TODO(ConditionalExpression): contains(typeSet, silentNeverType) ? silentNeverType : neverType */ TODO
		}
		if strictNullChecks && includes&TypeFlagsNullable && includes&(TypeFlagsObject|TypeFlagsNonPrimitive|TypeFlagsIncludesEmptyObject) || includes&TypeFlagsNonPrimitive && includes&(TypeFlagsDisjointDomains&~TypeFlagsNonPrimitive) || includes&TypeFlagsStringLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsStringLike) || includes&TypeFlagsNumberLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsNumberLike) || includes&TypeFlagsBigIntLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsBigIntLike) || includes&TypeFlagsESSymbolLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsESSymbolLike) || includes&TypeFlagsVoidLike && includes&(TypeFlagsDisjointDomains&~TypeFlagsVoidLike) {
			return neverType
		}
		if includes&(TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && includes&TypeFlagsStringLiteral && extractRedundantTemplateLiterals(typeSet) {
			return neverType
		}
		if includes & TypeFlagsAny {
			return /* TODO(ConditionalExpression): includes & TypeFlags.IncludesWildcard ? wildcardType : includes & TypeFlags.IncludesError ? errorType : anyType */ TODO
		}
		if !strictNullChecks && includes&TypeFlagsNullable {
			return /* TODO(ConditionalExpression): includes & TypeFlags.IncludesEmptyObject ? neverType : includes & TypeFlags.Undefined ? undefinedType : nullType */ TODO
		}
		if includes&TypeFlagsString && includes&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) || includes&TypeFlagsNumber && includes&TypeFlagsNumberLiteral || includes&TypeFlagsBigInt && includes&TypeFlagsBigIntLiteral || includes&TypeFlagsESSymbol && includes&TypeFlagsUniqueESSymbol || includes&TypeFlagsVoid && includes&TypeFlagsUndefined || includes&TypeFlagsIncludesEmptyObject && includes&TypeFlagsDefinitelyNonNullable {
			if !(flags & IntersectionFlagsNoSupertypeReduction) {
				/* TODO(CallExpression): removeRedundantSupertypes(typeSet, includes) */
			}
		}
		if includes & TypeFlagsIncludesMissingType {
			/* TODO(ElementAccessExpression): typeSet[typeSet.indexOf(undefinedType)] */ TODO = missingType
		}
		if typeSet.length == 0 {
			return unknownType
		}
		if typeSet.length == 1 {
			return /* TODO(ElementAccessExpression): typeSet[0] */ TODO
		}
		if typeSet.length == 2 && !(flags & IntersectionFlagsNoConstraintReduction) {
			typeVarIndex := /* TODO(ConditionalExpression): typeSet[0].flags & TypeFlags.TypeVariable ? 0 : 1 */ TODO
			typeVariable := /* TODO(ElementAccessExpression): typeSet[typeVarIndex] */ TODO
			primitiveType := /* TODO(ElementAccessExpression): typeSet[1 - typeVarIndex] */ TODO
			if typeVariable.flags&TypeFlagsTypeVariable && (primitiveType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) && !isGenericStringLikeType(primitiveType) || includes&TypeFlagsIncludesEmptyObject) {
				constraint := getBaseConstraintOfType(typeVariable)
				if constraint && everyType(constraint, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !!(t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) */
					/* TODO(BarBarToken): || */
					/* TODO(CallExpression): isEmptyAnonymousObjectType(t) */
				}) {
					if isTypeStrictSubtypeOf(constraint, primitiveType) {
						return typeVariable
					}
					if !(constraint.flags&TypeFlagsUnion && someType(constraint, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(Identifier): isTypeStrictSubtypeOf */
						/* TODO(Identifier): c */
						/* TODO(Identifier): primitiveType */
					})) {
						if !isTypeStrictSubtypeOf(primitiveType, constraint) {
							return neverType
						}
					}
					objectFlags = ObjectFlagsIsConstrainedTypeVariable
				}
			}
		}
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeSet) + (flags & IntersectionFlags.NoConstraintReduction ? "*" : getAliasId(aliasSymbol, aliasTypeArguments)) */ TODO
		result := intersectionTypes.get(id)
		if !result {
			if includes & TypeFlagsUnion {
				if intersectUnionsOfPrimitiveTypes(typeSet) {
					result = getIntersectionType(typeSet, flags, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.Union && (t as UnionType).types[0].flags & TypeFlags.Undefined) */
				}) {
					containedUndefinedType := /* TODO(ConditionalExpression): some(typeSet, containsMissingType) ? missingType : undefinedType */ TODO
					removeFromEach(typeSet, TypeFlagsUndefined)
					result = getUnionType( /* TODO(ArrayLiteralExpression): [getIntersectionType(typeSet, flags), containedUndefinedType] */ TODO, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if every(typeSet, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.Union && ((t as UnionType).types[0].flags & TypeFlags.Null || (t as UnionType).types[1].flags & TypeFlags.Null)) */
				}) {
					removeFromEach(typeSet, TypeFlagsNull)
					result = getUnionType( /* TODO(ArrayLiteralExpression): [getIntersectionType(typeSet, flags), nullType] */ TODO, UnionReductionLiteral, aliasSymbol, aliasTypeArguments)
				} else if typeSet.length >= 3 && types.length > 2 {
					middle := Math.floor( /* TODO(SlashToken): / */ /* TODO(BinaryExpression): typeSet.length / 2 */ TODO)
					result = getIntersectionType( /* TODO(ArrayLiteralExpression): [getIntersectionType(typeSet.slice(0, middle), flags), getIntersectionType(typeSet.slice(middle), flags)] */ TODO, flags, aliasSymbol, aliasTypeArguments)
				} else {
					if !checkCrossProductUnion(typeSet) {
						return errorType
					}
					constituents := getCrossProductIntersections(typeSet, flags)
					origin := /* TODO(ConditionalExpression): some(constituents, t => !!(t.flags & TypeFlags.Intersection)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(TypeFlags.Intersection, typeSet) : undefined */ TODO
					result = getUnionType(constituents, UnionReductionLiteral, aliasSymbol, aliasTypeArguments, origin)
				}
			} else {
				result = createIntersectionType(typeSet, objectFlags, aliasSymbol, aliasTypeArguments)
			}
			intersectionTypes.set(id, result)
		}
		return result
	}
	getCrossProductUnionSize := func(types []Type) /* TODO(undefined): number */ TODO {
		return reduceLeft(types, func(n /* TODO(undefined): number */ TODO, t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): number */ TODO {
			/* TODO(BinaryExpression): t.flags & TypeFlags.Union */
			/* TODO(QuestionToken): ? */
			/* TODO(BinaryExpression): n * (t as UnionType).types.length */
			/* TODO(ColonToken): : */
			/* TODO(ConditionalExpression): t.flags & TypeFlags.Never ? 0 : n */
		}, 1)
	}
	checkCrossProductUnion := func(types []Type) /* TODO(undefined): boolean */ TODO {
		size := getCrossProductUnionSize(types)
		if size >= 100000 {
			tracing.instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit" /* TODO(ObjectLiteralExpression): { typeIds: types.map(t => t.id), size } */, TODO)
			error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent)
			return false
		}
		return true
	}
	getCrossProductIntersections := func(types []Type, flags IntersectionFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		count := getCrossProductUnionSize(types)
		var intersections []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < count; i++) {             const constituents = types.slice();             let n = i;             for (let j = types.length - 1; j >= 0; j--) {                 if (types[j].flags & TypeFlags.Union) {                     const sourceTypes = (types[j] as UnionType).types;                     const length = sourceTypes.length;                     constituents[j] = sourceTypes[n % length];                     n = Math.floor(n / length);                 }             }             const t = getIntersectionType(constituents, flags);             if (!(t.flags & TypeFlags.Never)) intersections.push(t);         } */
		return intersections
	}
	getConstituentCount := func(type_ Type) number {
		return /* TODO(ConditionalExpression): !(type.flags & TypeFlags.UnionOrIntersection) || type.aliasSymbol ? 1 :             type.flags & TypeFlags.Union && (type as UnionType).origin ? getConstituentCount((type as UnionType).origin!) :             getConstituentCountOfTypes((type as UnionOrIntersectionType).types) */ TODO
	}
	getConstituentCountOfTypes := func(types []Type) number {
		return reduceLeft(types, func(n /* TODO(undefined): number */ TODO, t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): number */ TODO {
			/* TODO(Identifier): n */
			/* TODO(PlusToken): + */
			/* TODO(CallExpression): getConstituentCount(t) */
		}, 0)
	}
	getTypeFromIntersectionTypeNode := func(node IntersectionTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			types := map_(node.types, getTypeFromTypeNode)
			emptyIndex := /* TODO(ConditionalExpression): types.length === 2 ? types.indexOf(emptyTypeLiteralType) : -1 */ TODO
			t := /* TODO(ConditionalExpression): emptyIndex >= 0 ? types[1 - emptyIndex] : unknownType */ TODO
			noSupertypeReduction := !!(t.flags&(TypeFlagsString|TypeFlagsNumber|TypeFlagsBigInt) || t.flags&TypeFlagsTemplateLiteral && isPatternLiteralType(t))
			links.resolvedType = getIntersectionType(types /* TODO(ConditionalExpression): noSupertypeReduction ? IntersectionFlags.NoSupertypeReduction : 0 */, TODO, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol))
		}
		return links.resolvedType
	}
	createIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		result := createType(TypeFlagsIndex) /* as */ /* TODO(TypeReference): IndexType */
		result.type_ = type_
		result.indexFlags = indexFlags
		return result
	}
	createOriginIndexType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		result := createOriginType(TypeFlagsIndex) /* as */ /* TODO(TypeReference): IndexType */
		result.type_ = type_
		return result
	}
	getIndexTypeForGenericType := func(type_ /* TODO(UnionType): InstantiableType | UnionOrIntersectionType */ any, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexType */ TODO {
		return /* TODO(ConditionalExpression): indexFlags & IndexFlags.StringsOnly ?             type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, IndexFlags.StringsOnly)) :             type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, IndexFlags.None)) */ TODO
	}
	getIndexTypeForMappedType := func(type_ MappedType, indexFlags IndexFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeParameter := getTypeParameterFromMappedType(type_)
		constraintType := getConstraintTypeFromMappedType(type_)
		nameType := getNameTypeFromMappedType(type_.target /* as */ /* TODO(TypeReference): MappedType */ || type_)
		if !nameType && !(indexFlags & IndexFlagsNoIndexSignatures) {
			return constraintType
		}
		var keyTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		if isGenericIndexType(constraintType) {
			if isMappedTypeWithKeyofConstraintDeclaration(type_) {
				return getIndexTypeForGenericType(type_, indexFlags)
			}
			forEachType(constraintType, addMemberForKeyType)
		} else if isMappedTypeWithKeyofConstraintDeclaration(type_) {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(type_))
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, !!(indexFlags & IndexFlagsStringsOnly), addMemberForKeyType)
		} else {
			forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType)
		}
		result := /* TODO(ConditionalExpression): indexFlags & IndexFlags.NoIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (TypeFlags.Any | TypeFlags.String))) : getUnionType(keyTypes) */ TODO
		if result.flags&TypeFlagsUnion && constraintType.flags&TypeFlagsUnion && getTypeListId((result /* as */ /* TODO(TypeReference): UnionType */).types) == getTypeListId((constraintType /* as */ /* TODO(TypeReference): UnionType */).types) {
			return constraintType
		}
		return result
		addMemberForKeyType := func(keyType Type) {
			propNameType := /* TODO(ConditionalExpression): nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType */ TODO
			keyTypes.push( /* TODO(ConditionalExpression): propNameType === stringType ? stringOrNumberType : propNameType */ TODO)
		}
	}
	hasDistributiveNameType := func(mappedType MappedType) /* TODO(undefined): boolean */ TODO {
		typeVariable := getTypeParameterFromMappedType(mappedType)
		return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable)
		isDistributive := func(type_ Type) bool {
			return /* TODO(ConditionalExpression): type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Primitive | TypeFlags.Never | TypeFlags.TypeParameter | TypeFlags.Object | TypeFlags.NonPrimitive) ? true :                 type.flags & TypeFlags.Conditional ? (type as ConditionalType).root.isDistributive && (type as ConditionalType).checkType === typeVariable :                 type.flags & (TypeFlags.UnionOrIntersection | TypeFlags.TemplateLiteral) ? every((type as UnionOrIntersectionType | TemplateLiteralType).types, isDistributive) :                 type.flags & TypeFlags.IndexedAccess ? isDistributive((type as IndexedAccessType).objectType) && isDistributive((type as IndexedAccessType).indexType) :                 type.flags & TypeFlags.Substitution ? isDistributive((type as SubstitutionType).baseType) && isDistributive((type as SubstitutionType).constraint) :                 type.flags & TypeFlags.StringMapping ? isDistributive((type as StringMappingType).type) :                 false */ TODO
		}
	}
	getLiteralTypeFromPropertyName := func(name /* TODO(UnionType): PropertyName | JsxAttributeName */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isPrivateIdentifier(name) {
			return neverType
		}
		if isNumericLiteral(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		if isComputedPropertyName(name) {
			return getRegularTypeOfLiteralType(checkComputedPropertyName(name))
		}
		propertyName := getPropertyNameForPropertyNameNode(name)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propertyName !== undefined */ TODO {
			return getStringLiteralType(unescapeLeadingUnderscores(propertyName))
		}
		if isExpression(name) {
			return getRegularTypeOfLiteralType(checkExpression(name))
		}
		return neverType
	}
	getLiteralTypeFromProperty := func(prop Symbol, include TypeFlags, includeNonPublic bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & ModifierFlagsNonPublicAccessibilityModifier) {
			type_ := getSymbolLinks(getLateBoundSymbol(prop)).nameType
			if !type_ {
				name := getNameOfDeclaration(prop.valueDeclaration) /* as */ /* TODO(UnionType): PropertyName | JsxAttributeName */
				type_ = /* TODO(ConditionalExpression): prop.escapedName === InternalSymbolName.Default ? getStringLiteralType("default") :                     name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : undefined) */ TODO
			}
			if type_ && type_.flags&include {
				return type_
			}
		}
		return neverType
	}
	isKeyTypeIncluded := func(keyType Type, include TypeFlags) bool {
		return !!(keyType.flags&include || keyType.flags&TypeFlagsIntersection && some((keyType /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isKeyTypeIncluded */
			/* TODO(Identifier): t */
			/* TODO(Identifier): include */
		}))
	}
	getLiteralTypeFromProperties := func(type_ Type, include TypeFlags, includeOrigin bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		origin := /* TODO(ConditionalExpression): includeOrigin && (getObjectFlags(type) & (ObjectFlags.ClassOrInterface | ObjectFlags.Reference) || type.aliasSymbol) ? createOriginIndexType(type) : undefined */ TODO
		propertyTypes := map_(getPropertiesOfType(type_), func(prop /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(Identifier): getLiteralTypeFromProperty */
			/* TODO(Identifier): prop */
			/* TODO(Identifier): include */
		})
		indexKeyTypes := map_(getIndexInfosOfType(type_), func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(BinaryExpression): info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) */
			/* TODO(QuestionToken): ? */
			/* TODO(ConditionalExpression): info.keyType === stringType && include & TypeFlags.Number ? stringOrNumberType : info.keyType */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): neverType */
		})
		return getUnionType(concatenate(propertyTypes, indexKeyTypes), UnionReductionLiteral, nil, nil, origin)
	}
	shouldDeferIndexType := func(type_ Type, indexFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IndexFlags.None */) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags&TypeFlagsInstantiableNonPrimitive || isGenericTupleType(type_) || isGenericMappedType(type_) && (!hasDistributiveNameType(type_) || getMappedTypeNameTypeKind(type_) == MappedTypeNameTypeKindRemapping) || type_.flags&TypeFlagsUnion && !(indexFlags&IndexFlagsNoReducibleCheck) && isGenericReducibleType(type_) || type_.flags&TypeFlagsIntersection && maybeTypeOfKind(type_, TypeFlagsInstantiable) && some((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isEmptyAnonymousObjectType))
	}
	getIndexType := func(type_ Type, indexFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): IndexFlags.None */) Type {
		type_ = getReducedType(type_)
		return /* TODO(ConditionalExpression): isNoInferType(type) ? getNoInferType(getIndexType((type as SubstitutionType).baseType, indexFlags)) :             shouldDeferIndexType(type, indexFlags) ? getIndexTypeForGenericType(type as InstantiableType | UnionOrIntersectionType, indexFlags) :             type.flags & TypeFlags.Union ? getIntersectionType(map((type as UnionType).types, t => getIndexType(t, indexFlags))) :             type.flags & TypeFlags.Intersection ? getUnionType(map((type as IntersectionType).types, t => getIndexType(t, indexFlags))) :             getObjectFlags(type) & ObjectFlags.Mapped ? getIndexTypeForMappedType(type as MappedType, indexFlags) :             type === wildcardType ? wildcardType :             type.flags & TypeFlags.Unknown ? neverType :             type.flags & (TypeFlags.Any | TypeFlags.Never) ? stringNumberSymbolType :             getLiteralTypeFromProperties(type, (indexFlags & IndexFlags.NoIndexSignatures ? TypeFlags.StringLiteral : TypeFlags.StringLike) | (indexFlags & IndexFlags.StringsOnly ? 0 : TypeFlags.NumberLike | TypeFlags.ESSymbolLike), indexFlags === IndexFlags.None) */ TODO
	}
	getExtractStringType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		extractTypeAlias := getGlobalExtractSymbol()
		return /* TODO(ConditionalExpression): extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType */ TODO
	}
	getIndexTypeOrString := func(type_ Type) Type {
		indexType := getExtractStringType(getIndexType(type_))
		return /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Never ? stringType : indexType */ TODO
	}
	getTypeFromTypeOperatorNode := func(node TypeOperatorNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			/* TODO(SwitchStatement): switch (node.operator) {                 case SyntaxKind.KeyOfKeyword:                     links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));                     break;                 case SyntaxKind.UniqueKeyword:                     links.resolvedType = node.type.kind === SyntaxKind.SymbolKeyword                         ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent))                         : errorType;                     break;                 case SyntaxKind.ReadonlyKeyword:                     links.resolvedType = getTypeFromTypeNode(node.type);                     break;                 default:                     Debug.assertNever(node.operator);             } */
		}
		return links.resolvedType
	}
	getTypeFromTemplateTypeNode := func(node TemplateLiteralTypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getTemplateLiteralType( /* TODO(ArrayLiteralExpression): [node.head.text, ...map(node.templateSpans, span => span.literal.text)] */ TODO, map_(node.templateSpans, func(span /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralTypeSpan */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getTypeFromTypeNode */
				/* TODO(PropertyAccessExpression): span.type */
			}))
		}
		return links.resolvedType
	}
	getTemplateLiteralType := func(texts []string, types []Type) Type {
		unionIndex := findIndex(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(t.flags & (TypeFlags.Never | TypeFlags.Union)) */
		})
		if unionIndex >= 0 {
			return /* TODO(ConditionalExpression): checkCrossProductUnion(types) ?                 mapType(types[unionIndex], t => getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))) :                 errorType */ TODO
		}
		if contains(types, wildcardType) {
			return wildcardType
		}
		var newTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var newTexts []string = /* TODO(ArrayLiteralExpression): [] */ TODO
		text := /* TODO(ElementAccessExpression): texts[0] */ TODO
		if !addSpans(texts, types) {
			return stringType
		}
		if newTypes.length == 0 {
			return getStringLiteralType(text)
		}
		newTexts.push(text)
		if every(newTexts, func(t /* TODO(undefined): string */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): t */
			/* TODO(EqualsEqualsEqualsToken): === */
			/* TODO(StringLiteral): "" */
		}) {
			if every(newTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.String) */
			}) {
				return stringType
			}
			if newTypes.length == 1 && isPatternLiteralType( /* TODO(ElementAccessExpression): newTypes[0] */ TODO) {
				return /* TODO(ElementAccessExpression): newTypes[0] */ TODO
			}
		}
		id := /* TODO(TemplateExpression): `${getTypeListId(newTypes)}|${map(newTexts, t => t.length).join(",")}|${newTexts.join("")}` */ TODO
		type_ := templateLiteralTypes.get(id)
		if !type_ {
			templateLiteralTypes.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createTemplateLiteralType(newTexts, newTypes) */, TODO)
		}
		return type_
		addSpans := func(texts []string, types []Type) bool {
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 const t = types[i];                 if (t.flags & (TypeFlags.Literal | TypeFlags.Null | TypeFlags.Undefined)) {                     text += getTemplateStringForType(t) || "";                     text += texts[i + 1];                 }                 else if (t.flags & TypeFlags.TemplateLiteral) {                     text += (t as TemplateLiteralType).texts[0];                     if (!addSpans((t as TemplateLiteralType).texts, (t as TemplateLiteralType).types)) return false;                     text += texts[i + 1];                 }                 else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {                     newTypes.push(t);                     newTexts.push(text);                     text = texts[i + 1];                 }                 else {                     return false;                 }             } */
			return true
		}
	}
	getTemplateStringForType := func(type_ Type) /* TODO(undefined): string | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.StringLiteral ? (type as StringLiteralType).value :             type.flags & TypeFlags.NumberLiteral ? "" + (type as NumberLiteralType).value :             type.flags & TypeFlags.BigIntLiteral ? pseudoBigIntToString((type as BigIntLiteralType).value) :             type.flags & (TypeFlags.BooleanLiteral | TypeFlags.Nullable) ? (type as IntrinsicType).intrinsicName :             undefined */ TODO
	}
	createTemplateLiteralType := func(texts []string, types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateLiteralType */ TODO {
		type_ := createType(TypeFlagsTemplateLiteral) /* as */ /* TODO(TypeReference): TemplateLiteralType */
		type_.texts = texts
		type_.types = types
		return type_
	}
	getStringMappingType := func(symbol Symbol, type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Union | TypeFlags.Never) ? mapType(type, t => getStringMappingType(symbol, t)) :             type.flags & TypeFlags.StringLiteral ? getStringLiteralType(applyStringMapping(symbol, (type as StringLiteralType).value)) :             type.flags & TypeFlags.TemplateLiteral ? getTemplateLiteralType(...applyTemplateStringMapping(symbol, (type as TemplateLiteralType).texts, (type as TemplateLiteralType).types)) :             // Mapping<Mapping<T>> === Mapping<T>             type.flags & TypeFlags.StringMapping && symbol === type.symbol ? type :             type.flags & (TypeFlags.Any | TypeFlags.String | TypeFlags.StringMapping) || isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) :             // This handles Mapping<`${number}`> and Mapping<`${bigint}`>             isPatternLiteralPlaceholderType(type) ? getStringMappingTypeForGenericType(symbol, getTemplateLiteralType(["", ""], [type])) :             type */ TODO
	}
	applyStringMapping := func(symbol Symbol, str string) /* TODO(undefined): string */ TODO {
		/* TODO(SwitchStatement): switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {             case IntrinsicTypeKind.Uppercase:                 return str.toUpperCase();             case IntrinsicTypeKind.Lowercase:                 return str.toLowerCase();             case IntrinsicTypeKind.Capitalize:                 return str.charAt(0).toUpperCase() + str.slice(1);             case IntrinsicTypeKind.Uncapitalize:                 return str.charAt(0).toLowerCase() + str.slice(1);         } */
		return str
	}
	applyTemplateStringMapping := func(symbol Symbol, texts []string, types []Type) /* TODO(TupleType): [texts: readonly string[], types: readonly Type[]] */ TODO {
		/* TODO(SwitchStatement): switch (intrinsicTypeKinds.get(symbol.escapedName as string)) {             case IntrinsicTypeKind.Uppercase:                 return [texts.map(t => t.toUpperCase()), types.map(t => getStringMappingType(symbol, t))];             case IntrinsicTypeKind.Lowercase:                 return [texts.map(t => t.toLowerCase()), types.map(t => getStringMappingType(symbol, t))];             case IntrinsicTypeKind.Capitalize:                 return [texts[0] === "" ? texts : [texts[0].charAt(0).toUpperCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];             case IntrinsicTypeKind.Uncapitalize:                 return [texts[0] === "" ? texts : [texts[0].charAt(0).toLowerCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];         } */
		return /* TODO(ArrayLiteralExpression): [texts, types] */ TODO
	}
	getStringMappingTypeForGenericType := func(symbol Symbol, type_ Type) Type {
		id := /* TODO(TemplateExpression): `${getSymbolId(symbol)},${getTypeId(type)}` */ TODO
		result := stringMappingTypes.get(id)
		if !result {
			stringMappingTypes.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = createStringMappingType(symbol, type) */, TODO)
		}
		return result
	}
	createStringMappingType := func(symbol Symbol, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringMappingType */ TODO {
		result := createTypeWithSymbol(TypeFlagsStringMapping, symbol) /* as */ /* TODO(TypeReference): StringMappingType */
		result.type_ = type_
		return result
	}
	createIndexedAccessType := func(objectType Type, indexType Type, accessFlags AccessFlags, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexedAccessType */ TODO {
		type_ := createType(TypeFlagsIndexedAccess) /* as */ /* TODO(TypeReference): IndexedAccessType */
		type_.objectType = objectType
		type_.indexType = indexType
		type_.accessFlags = accessFlags
		type_.aliasSymbol = aliasSymbol
		type_.aliasTypeArguments = aliasTypeArguments
		return type_
	}
	isJSLiteralType := func(type_ Type) bool {
		if noImplicitAny {
			return false
		}
		if getObjectFlags(type_) & ObjectFlagsJSLiteral {
			return true
		}
		if type_.flags & TypeFlagsUnion {
			return every((type_ /* as */ /* TODO(TypeReference): UnionType */).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isJSLiteralType)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getResolvedBaseConstraint(type_)
			return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== type */ TODO && isJSLiteralType(constraint)
		}
		return false
	}
	getPropertyNameFromIndex := func(indexType Type, accessNode /* TODO(UnionType): PropertyName | ObjectBindingPattern | ArrayBindingPattern | IndexedAccessTypeNode | ElementAccessExpression | SyntheticExpression | undefined */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(indexType) ?             getPropertyNameFromType(indexType) :             accessNode && isPropertyName(accessNode) ?             // late bound names are handled in the first branch, so here we only need to handle normal names             getPropertyNameForPropertyNameNode(accessNode) :             undefined */ TODO
	}
	isUncalledFunctionReference := func(node Node, symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod) {
			parent := findAncestor(node.parent, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(CallExpression): isAccessExpression(n) */
			}) || node.parent
			if isCallLikeExpression(parent) {
				return isCallOrNewExpression(parent) && isIdentifier(node) && hasMatchingArgument(parent, node)
			}
			return every(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !isFunctionLike(d) */
				/* TODO(BarBarToken): || */
				/* TODO(CallExpression): isDeprecatedDeclaration(d) */
			})
		}
		return true
	}
	getPropertyTypeForIndexType := func(originalObjectType Type, objectType Type, indexType Type, fullIndexType Type, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression | undefined */ any, accessFlags AccessFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		accessExpression := /* TODO(ConditionalExpression): accessNode && accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode : undefined */ TODO
		propName := /* TODO(ConditionalExpression): accessNode && isPrivateIdentifier(accessNode) ? undefined : getPropertyNameFromIndex(indexType, accessNode) */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO {
			if accessFlags & AccessFlagsContextual {
				return getTypeOfPropertyOfContextualType(objectType, propName) || anyType
			}
			prop := getPropertyOfType(objectType, propName)
			if prop {
				if accessFlags&AccessFlagsReportDeprecated && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop) {
					deprecatedNode := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): accessExpression?.argumentExpression ?? (isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode) */ TODO
					addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName /* as */ /* TODO(StringKeyword): string */)
				}
				if accessExpression {
					markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol))
					if isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression)) {
						error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop))
						return nil
					}
					if accessFlags & AccessFlagsCacheSymbol {
						getNodeLinks( /* TODO(NonNullExpression): accessNode! */ TODO).resolvedSymbol = prop
					}
					if isThisPropertyAccessInConstructor(accessExpression, prop) {
						return autoType
					}
				}
				propType := /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
				return /* TODO(ConditionalExpression): accessExpression && getAssignmentTargetKind(accessExpression) !== AssignmentKind.Definite ? getFlowTypeOfReference(accessExpression, propType) :                     accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) :                     propType */ TODO
			}
			if everyType(objectType, isTupleType) && isNumericLiteralName(propName) {
				index := +propName
				if accessNode && everyType(objectType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(ParenthesizedExpression): ((t as TupleTypeReference).target.combinedFlags & ElementFlags.Variable) */
				}) && !(accessFlags & AccessFlagsAllowMissing) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					if isTupleType(objectType) {
						if index < 0 {
							error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value)
							return undefinedType
						}
						error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName))
					} else {
						error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
					}
				}
				if index >= 0 {
					errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType))
					return getTupleElementTypeOutOfStartCount(objectType, index /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? missingType : undefined */, TODO)
				}
			}
		}
		if !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) {
			if objectType.flags & (TypeFlagsAny | TypeFlagsNever) {
				return objectType
			}
			indexInfo := getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType)
			if indexInfo {
				if accessFlags&AccessFlagsNoIndexSignatures && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexInfo.keyType !== numberType */ TODO {
					if accessExpression {
						if accessFlags & AccessFlagsWriting {
							error(accessExpression, Diagnostics.Type_0_is_generic_and_can_only_be_indexed_for_reading, typeToString(originalObjectType))
						} else {
							error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType))
						}
					}
					return nil
				}
				if accessNode && indexInfo.keyType == stringType && !isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
					indexNode := getIndexNodeForAccessExpression(accessNode)
					error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType))
					return /* TODO(ConditionalExpression): accessFlags & AccessFlags.IncludeUndefined ? getUnionType([indexInfo.type, missingType]) : indexInfo.type */ TODO
				}
				errorIfWritingToReadonlyIndex(indexInfo)
				if (accessFlags & AccessFlagsIncludeUndefined) && !(objectType.symbol && objectType.symbol.flags&(SymbolFlagsRegularEnum|SymbolFlagsConstEnum) && (indexType.symbol && indexType.flags&TypeFlagsEnumLiteral && getParentOfSymbol(indexType.symbol) == objectType.symbol)) {
					return getUnionType( /* TODO(ArrayLiteralExpression): [indexInfo.type, missingType] */ TODO)
				}
				return indexInfo.type_
			}
			if indexType.flags & TypeFlagsNever {
				return neverType
			}
			if isJSLiteralType(objectType) {
				return anyType
			}
			if accessExpression && !isConstEnumObjectType(objectType) {
				if isObjectLiteralType(objectType) {
					if noImplicitAny && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
						diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as */ /* TODO(TypeReference): StringLiteralType */).value, typeToString(objectType)))
						return undefinedType
					} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
						types := map_((objectType /* as */ /* TODO(TypeReference): ResolvedType */).properties, func(property /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
							return getTypeOfSymbol(property)
						})
						return getUnionType(append(types, undefinedType))
					}
				}
				if objectType.symbol == globalThisSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO && /* TODO(NonNullExpression): globalThisSymbol.exports! */ TODO.has(propName) && ( /* TODO(NonNullExpression): globalThisSymbol.exports!.get(propName)! */ TODO.flags & SymbolFlagsBlockScoped) {
					error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType))
				} else if noImplicitAny && !(accessFlags & AccessFlagsSuppressNoImplicitAnyError) {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO && typeHasStaticProperty(propName, objectType) {
						typeName := typeToString(objectType)
						error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName /* as */ /* TODO(StringKeyword): string */, typeName /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]" */, TODO)
					} else if getIndexTypeOfType(objectType, numberType) {
						error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number)
					} else {
						var suggestion /* TODO(StringKeyword): string */ any
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): propName !== undefined */ TODO && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): suggestion = getSuggestionForNonexistentProperty(propName as string, objectType) */ TODO) {
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
								error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName /* as */ /* TODO(StringKeyword): string */, typeToString(objectType), suggestion)
							}
						} else {
							suggestion := getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType)
							if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
								error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion)
							} else {
								var errorInfo *DiagnosticMessageChain
								if indexType.flags & TypeFlagsEnumLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "[" + typeToString(indexType) + "]" */, TODO, typeToString(objectType))
								} else if indexType.flags & TypeFlagsUniqueESSymbol {
									symbolName := getFullyQualifiedName((indexType /* as */ /* TODO(TypeReference): UniqueESSymbolType */).symbol, accessExpression)
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "[" + symbolName + "]" */, TODO, typeToString(objectType))
								} else if indexType.flags & TypeFlagsStringLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as */ /* TODO(TypeReference): StringLiteralType */).value, typeToString(objectType))
								} else if indexType.flags & TypeFlagsNumberLiteral {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.Property_0_does_not_exist_on_type_1, (indexType /* as */ /* TODO(TypeReference): NumberLiteralType */).value, typeToString(objectType))
								} else if indexType.flags & (TypeFlagsNumber | TypeFlagsString) {
									errorInfo = chainDiagnosticMessages(nil, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType))
								}
								errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType))
								diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo))
							}
						}
					}
				}
				return nil
			}
		}
		if accessFlags&AccessFlagsAllowMissing && isObjectLiteralType(objectType) {
			return undefinedType
		}
		if isJSLiteralType(objectType) {
			return anyType
		}
		if accessNode {
			indexNode := getIndexNodeForAccessExpression(accessNode)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): indexNode.kind !== SyntaxKind.BigIntLiteral */ TODO && indexType.flags&(TypeFlagsStringLiteral|TypeFlagsNumberLiteral) {
				error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1 /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + (indexType as StringLiteralType | NumberLiteralType).value */, TODO, typeToString(objectType))
			} else if indexType.flags & (TypeFlagsString | TypeFlagsNumber) {
				error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType))
			} else {
				typeString := /* TODO(ConditionalExpression): indexNode.kind === SyntaxKind.BigIntLiteral ? "bigint" : typeToString(indexType) */ TODO
				error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeString)
			}
		}
		if isTypeAny(indexType) {
			return indexType
		}
		return nil
		errorIfWritingToReadonlyIndex := func(indexInfo *IndexInfo) {
			if indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression)) {
				error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
		}
	}
	getIndexNodeForAccessExpression := func(accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectBindingPattern | import("/home/jabaile/work/TypeScript/src/compiler/types").ArrayBindingPattern */ TODO {
		return /* TODO(ConditionalExpression): accessNode.kind === SyntaxKind.ElementAccessExpression ? accessNode.argumentExpression :             accessNode.kind === SyntaxKind.IndexedAccessType ? accessNode.indexType :             accessNode.kind === SyntaxKind.ComputedPropertyName ? accessNode.expression :             accessNode */ TODO
	}
	isPatternLiteralPlaceholderType := func(type_ Type) bool {
		if type_.flags & TypeFlagsIntersection {
			seenPlaceholder := false
			for _, t := range (type_ /* as */ /* TODO(TypeReference): IntersectionType */).types {
				if t.flags&(TypeFlagsLiteral|TypeFlagsNullable) || isPatternLiteralPlaceholderType(t) {
					seenPlaceholder = true
				} else if !(t.flags & TypeFlagsObject) {
					return false
				}
			}
			return seenPlaceholder
		}
		return !!(type_.flags & (TypeFlagsAny | TypeFlagsString | TypeFlagsNumber | TypeFlagsBigInt)) || isPatternLiteralType(type_)
	}
	isPatternLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags&TypeFlagsTemplateLiteral) && every((type_ /* as */ /* TODO(TypeReference): TemplateLiteralType */).types, isPatternLiteralPlaceholderType) || !!(type_.flags&TypeFlagsStringMapping) && isPatternLiteralPlaceholderType((type_ /* as */ /* TODO(TypeReference): StringMappingType */).type_)
	}
	isGenericStringLikeType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags & (TypeFlagsTemplateLiteral | TypeFlagsStringMapping)) && !isPatternLiteralType(type_)
	}
	isGenericType := func(type_ Type) bool {
		return !!getGenericObjectFlags(type_)
	}
	isGenericObjectType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericObjectType)
	}
	isGenericIndexType := func(type_ Type) bool {
		return !!(getGenericObjectFlags(type_) & ObjectFlagsIsGenericIndexType)
	}
	getGenericObjectFlags := func(type_ Type) ObjectFlags {
		if type_.flags & (TypeFlagsUnionOrIntersection) {
			if !((type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).objectFlags |= ObjectFlagsIsGenericTypeComputed | reduceLeft((type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, func(flags /* TODO(undefined): number */ TODO, t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): number */ TODO {
					/* TODO(Identifier): flags */
					/* TODO(BarToken): | */
					/* TODO(CallExpression): getGenericObjectFlags(t) */
				}, 0)
			}
			return (type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).objectFlags & ObjectFlagsIsGenericType
		}
		if type_.flags & TypeFlagsSubstitution {
			if !((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).objectFlags & ObjectFlagsIsGenericTypeComputed) {
				(type_ /* as */ /* TODO(TypeReference): SubstitutionType */).objectFlags |= ObjectFlagsIsGenericTypeComputed | getGenericObjectFlags((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType) | getGenericObjectFlags((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).constraint)
			}
			return (type_ /* as */ /* TODO(TypeReference): SubstitutionType */).objectFlags & ObjectFlagsIsGenericType
		}
		return ( /* TODO(ConditionalExpression): type.flags & TypeFlags.InstantiableNonPrimitive || isGenericMappedType(type) || isGenericTupleType(type) ? ObjectFlags.IsGenericObjectType : 0 */ TODO) | ( /* TODO(ConditionalExpression): type.flags & (TypeFlags.InstantiableNonPrimitive | TypeFlags.Index) || isGenericStringLikeType(type) ? ObjectFlags.IsGenericIndexType : 0 */ TODO)
	}
	getSimplifiedType := func(type_ Type, writing bool) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.IndexedAccess ? getSimplifiedIndexedAccessType(type as IndexedAccessType, writing) :             type.flags & TypeFlags.Conditional ? getSimplifiedConditionalType(type as ConditionalType, writing) :             type */ TODO
	}
	distributeIndexOverObjectType := func(objectType Type, indexType Type, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if objectType.flags&TypeFlagsUnion || objectType.flags&TypeFlagsIntersection && !shouldDeferIndexType(objectType) {
			types := map_((objectType /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getSimplifiedType */
				/* TODO(CallExpression): getIndexedAccessType(t, indexType) */
				/* TODO(Identifier): writing */
			})
			return /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Intersection || writing ? getIntersectionType(types) : getUnionType(types) */ TODO
		}
	}
	distributeObjectOverIndexType := func(objectType Type, indexType Type, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if indexType.flags & TypeFlagsUnion {
			types := map_((indexType /* as */ /* TODO(TypeReference): UnionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getSimplifiedType */
				/* TODO(CallExpression): getIndexedAccessType(objectType, t) */
				/* TODO(Identifier): writing */
			})
			return /* TODO(ConditionalExpression): writing ? getIntersectionType(types) : getUnionType(types) */ TODO
		}
	}
	getSimplifiedIndexedAccessType := func(type_ IndexedAccessType, writing bool) Type {
		cache := /* TODO(ConditionalExpression): writing ? "simplifiedForWriting" : "simplifiedForReading" */ TODO
		if /* TODO(ElementAccessExpression): type[cache] */ TODO {
			return /* TODO(ConditionalExpression): type[cache] === circularConstraintType ? type : type[cache] */ TODO
		}
		/* TODO(ElementAccessExpression): type[cache] */ TODO = circularConstraintType
		objectType := getSimplifiedType(type_.objectType, writing)
		indexType := getSimplifiedType(type_.indexType, writing)
		distributedOverIndex := distributeObjectOverIndexType(objectType, indexType, writing)
		if distributedOverIndex {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = distributedOverIndex */ TODO
		}
		if !(indexType.flags & TypeFlagsInstantiable) {
			distributedOverObject := distributeIndexOverObjectType(objectType, indexType, writing)
			if distributedOverObject {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = distributedOverObject */ TODO
			}
		}
		if isGenericTupleType(objectType) && indexType.flags&TypeFlagsNumberLike {
			elementType := getElementTypeOfSliceOfTupleType(objectType /* TODO(ConditionalExpression): indexType.flags & TypeFlags.Number ? 0 : objectType.target.fixedLength */, TODO, 0, writing)
			if elementType {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = elementType */ TODO
			}
		}
		if isGenericMappedType(objectType) {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getMappedTypeNameTypeKind(objectType) !== MappedTypeNameTypeKind.Remapping */ TODO {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), t => getSimplifiedType(t, writing)) */ TODO
			}
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type[cache] = type */ TODO
	}
	getSimplifiedConditionalType := func(type_ ConditionalType, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkType := type_.checkType
		extendsType := type_.extendsType
		trueType := getTrueTypeFromConditionalType(type_)
		falseType := getFalseTypeFromConditionalType(type_)
		if falseType.flags&TypeFlagsNever && getActualTypeVariable(trueType) == getActualTypeVariable(checkType) {
			if checkType.flags&TypeFlagsAny || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return getSimplifiedType(trueType, writing)
			} else if isIntersectionEmpty(checkType, extendsType) {
				return neverType
			}
		} else if trueType.flags&TypeFlagsNever && getActualTypeVariable(falseType) == getActualTypeVariable(checkType) {
			if !(checkType.flags & TypeFlagsAny) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType)) {
				return neverType
			} else if checkType.flags&TypeFlagsAny || isIntersectionEmpty(checkType, extendsType) {
				return getSimplifiedType(falseType, writing)
			}
		}
		return type_
	}
	isIntersectionEmpty := func(type1 Type, type2 Type) /* TODO(undefined): boolean */ TODO {
		return !!(getUnionType( /* TODO(ArrayLiteralExpression): [intersectTypes(type1, type2), neverType] */ TODO).flags & TypeFlagsNever)
	}
	substituteIndexedMappedType := func(objectType MappedType, index Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		mapper := createTypeMapper( /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(objectType)] */ TODO /* TODO(ArrayLiteralExpression): [index] */, TODO)
		templateMapper := combineTypeMappers(objectType.mapper, mapper)
		instantiatedTemplateType := instantiateType(getTemplateTypeFromMappedType(objectType.target /* as */ /* TODO(TypeReference): MappedType */ || objectType), templateMapper)
		isOptional := getMappedTypeOptionality(objectType) > 0 || ( /* TODO(ConditionalExpression): isGenericType(objectType) ?             getCombinedMappedTypeOptionality(getModifiersTypeFromMappedType(objectType)) > 0 :             couldAccessOptionalProperty(objectType, index) */ TODO)
		return addOptionality(instantiatedTemplateType, true, isOptional)
	}
	couldAccessOptionalProperty := func(objectType Type, indexType Type) /* TODO(undefined): boolean */ TODO {
		indexConstraint := getBaseConstraintOfType(indexType)
		return !!indexConstraint && some(getPropertiesOfType(objectType), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !!(p.flags & SymbolFlags.Optional) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isTypeAssignableTo(getLiteralTypeFromProperty(p, TypeFlags.StringOrNumberLiteralOrUnique), indexConstraint) */
		})
	}
	getIndexedAccessType := func(objectType Type, indexType Type, accessFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || ( /* TODO(ConditionalExpression): accessNode ? errorType : unknownType */ TODO)
	}
	indexTypeLessThan := func(indexType Type, limit number) /* TODO(undefined): boolean */ TODO {
		return everyType(indexType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			if t.flags & TypeFlagsStringOrNumberLiteral {
				propName := getPropertyNameFromType(t /* as */ /* TODO(UnionType): StringLiteralType | NumberLiteralType */)
				if isNumericLiteralName(propName) {
					index := +propName
					return index >= 0 && index < limit
				}
			}
			return false
		})
	}
	getIndexedAccessTypeOrUndefined := func(objectType Type, indexType Type, accessFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AccessFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): AccessFlags.None */, accessNode /* TODO(UnionType): ElementAccessExpression | IndexedAccessTypeNode | PropertyName | BindingName | SyntheticExpression */ any, aliasSymbol Symbol, aliasTypeArguments []Type) *Type {
		if objectType == wildcardType || indexType == wildcardType {
			return wildcardType
		}
		objectType = getReducedType(objectType)
		if isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & TypeFlagsNullable) && isTypeAssignableToKind(indexType, TypeFlagsString|TypeFlagsNumber) {
			indexType = stringType
		}
		if compilerOptions.noUncheckedIndexedAccess && accessFlags&AccessFlagsExpressionPosition {
			/* TODO(BinaryExpression): accessFlags |= AccessFlags.IncludeUndefined */
		}
		if isGenericIndexType(indexType) || ( /* TODO(ConditionalExpression): accessNode && accessNode.kind !== SyntaxKind.IndexedAccessType ?                 isGenericTupleType(objectType) && !indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target)) :                 isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, getTotalFixedElementCount(objectType.target))) || isGenericReducibleType(objectType) */ TODO) {
			if objectType.flags & TypeFlagsAnyOrUnknown {
				return objectType
			}
			persistentAccessFlags := accessFlags & AccessFlagsPersistent
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			type_ := indexedAccessTypes.get(id)
			if !type_ {
				indexedAccessTypes.set(id /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments) */, TODO)
			}
			return type_
		}
		apparentObjectType := getReducedApparentType(objectType)
		if indexType.flags&TypeFlagsUnion && !(indexType.flags & TypeFlagsBoolean) {
			var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			wasMissingProp := false
			for _, t := range (indexType /* as */ /* TODO(TypeReference): UnionType */).types {
				propType := getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags|( /* TODO(ConditionalExpression): wasMissingProp ? AccessFlags.SuppressNoImplicitAnyError : 0 */ TODO))
				if propType {
					propTypes.push(propType)
				} else if !accessNode {
					return nil
				} else {
					wasMissingProp = true
				}
			}
			if wasMissingProp {
				return nil
			}
			return /* TODO(ConditionalExpression): accessFlags & AccessFlags.Writing                 ? getIntersectionType(propTypes, IntersectionFlags.None, aliasSymbol, aliasTypeArguments)                 : getUnionType(propTypes, UnionReduction.Literal, aliasSymbol, aliasTypeArguments) */ TODO
		}
		return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags|AccessFlagsCacheSymbol|AccessFlagsReportDeprecated)
	}
	getTypeFromIndexedAccessTypeNode := func(node IndexedAccessTypeNode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if !links.resolvedType {
			objectType := getTypeFromTypeNode(node.objectType)
			indexType := getTypeFromTypeNode(node.indexType)
			potentialAlias := getAliasSymbolForTypeNode(node)
			links.resolvedType = getIndexedAccessType(objectType, indexType, AccessFlagsNone, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias))
		}
		return links.resolvedType
	}
	getTypeFromMappedTypeNode := func(node MappedTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			type_ := createObjectType(ObjectFlagsMapped, node.symbol) /* as */ /* TODO(TypeReference): MappedType */
			type_.declaration = node
			type_.aliasSymbol = getAliasSymbolForTypeNode(node)
			type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type_.aliasSymbol)
			links.resolvedType = type_
			getConstraintTypeFromMappedType(type_)
		}
		return links.resolvedType
	}
	getActualTypeVariable := func(type_ Type) Type {
		if type_.flags & TypeFlagsSubstitution {
			return getActualTypeVariable((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType)
		}
		if type_.flags&TypeFlagsIndexedAccess && ((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType.flags&TypeFlagsSubstitution || (type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType.flags&TypeFlagsSubstitution) {
			return getIndexedAccessType(getActualTypeVariable((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType), getActualTypeVariable((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType))
		}
		return type_
	}
	isSimpleTupleType := func(node TypeNode) bool {
		return isTupleTypeNode(node) && length(node.elements) > 0 && !some(node.elements, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): isOptionalTypeNode(e) || isRestTypeNode(e) */
			/* TODO(BarBarToken): || */
			/* TODO(BinaryExpression): isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken) */
		})
	}
	isDeferredType := func(type_ Type, checkTuples bool) /* TODO(undefined): boolean */ TODO {
		return isGenericType(type_) || checkTuples && isTupleType(type_) && some(getElementTypes(type_), isGenericType)
	}
	getConditionalType := func(root ConditionalRoot, mapper *TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		var result TODO
		var extraTypes /* TODO(ArrayType): Type[] */ any
		tailCount := 0
		/* TODO(WhileStatement): while (true) {             if (tailCount === 1000) {                 error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);                 return errorType;             }             const checkType = instantiateType(getActualTypeVariable(root.checkType), mapper);             const extendsType = instantiateType(root.extendsType, mapper);             if (checkType === errorType || extendsType === errorType) {                 return errorType;             }             if (checkType === wildcardType || extendsType === wildcardType) {                 return wildcardType;             }             const checkTypeNode = skipTypeParentheses(root.node.checkType);             const extendsTypeNode = skipTypeParentheses(root.node.extendsType);             // When the check and extends types are simple tuple types of the same arity, we defer resolution of the             // conditional type when any tuple elements are generic. This is such that non-distributable conditional             // types can be written `[X] extends [Y] ? ...` and be deferred similarly to `X extends Y ? ...`.             const checkTuples = isSimpleTupleType(checkTypeNode) && isSimpleTupleType(extendsTypeNode) &&                 length((checkTypeNode as TupleTypeNode).elements) === length((extendsTypeNode as TupleTypeNode).elements);             const checkTypeDeferred = isDeferredType(checkType, checkTuples);             let combinedMapper: TypeMapper | undefined;             if (root.inferTypeParameters) {                 // When we're looking at making an inference for an infer type, when we get its constraint, it'll automagically be                 // instantiated with the context, so it doesn't need the mapper for the inference context - however the constraint                 // may refer to another _root_, _uncloned_ `infer` type parameter [1], or to something mapped by `mapper` [2].                 // [1] Eg, if we have `Foo<T, U extends T>` and `Foo<number, infer B>` - `B` is constrained to `T`, which, in turn, has been instantiated                 // as `number`                 // Conversely, if we have `Foo<infer A, infer B>`, `B` is still constrained to `T` and `T` is instantiated as `A`                 // [2] Eg, if we have `Foo<T, U extends T>` and `Foo<Q, infer B>` where `Q` is mapped by `mapper` into `number` - `B` is constrained to `T`                 // which is in turn instantiated as `Q`, which is in turn instantiated as `number`.                 // So we need to:                 //    * combine `context.nonFixingMapper` with `mapper` so their constraints can be instantiated in the context of `mapper` (otherwise they'd only get inference context information)                 //    * incorporate all of the component mappers into the combined mapper for the true and false members                 // This means we have two mappers that need applying:                 //    * The original `mapper` used to create this conditional                 //    * The mapper that maps the infer type parameter to its inference result (`context.mapper`)                 const context = createInferenceContext(root.inferTypeParameters, /*signature* / undefined, InferenceFlags.None);                 if (mapper) {                     context.nonFixingMapper = combineTypeMappers(context.nonFixingMapper, mapper);                 }                 if (!checkTypeDeferred) {                     // We don't want inferences from constraints as they may cause us to eagerly resolve the                     // conditional type instead of deferring resolution. Also, we always want strict function                     // types rules (i.e. proper contravariance) for inferences.                     inferTypes(context.inferences, checkType, extendsType, InferencePriority.NoConstraints | InferencePriority.AlwaysStrict);                 }                 // It's possible for 'infer T' type paramteters to be given uninstantiated constraints when the                 // those type parameters are used in type references (see getInferredTypeParameterConstraint). For                 // that reason we need context.mapper to be first in the combined mapper. See #42636 for examples.                 combinedMapper = mapper ? combineTypeMappers(context.mapper, mapper) : context.mapper;             }             // Instantiate the extends type including inferences for 'infer T' type parameters             const inferredExtendsType = combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType;             // We attempt to resolve the conditional type only when the check and extends types are non-generic             if (!checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples)) {                 // Return falseType for a definitely false extends check. We check an instantiations of the two                 // types with type parameters mapped to the wildcard type, the most permissive instantiations                 // possible (the wildcard type is assignable to and from all types). If those are not related,                 // then no instantiations will be and we can just return the false branch type.                 if (!(inferredExtendsType.flags & TypeFlags.AnyOrUnknown) && (checkType.flags & TypeFlags.Any || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {                     // Return union of trueType and falseType for 'any' since it matches anything. Furthermore, for a                     // distributive conditional type applied to the constraint of a type variable, include trueType if                     // there are possible values of the check type that are also possible values of the extends type.                     // We use a reverse assignability check as it is less expensive than the comparable relationship                     // and avoids false positives of a non-empty intersection check.                     if (checkType.flags & TypeFlags.Any || forConstraint && !(inferredExtendsType.flags & TypeFlags.Never) && someType(getPermissiveInstantiation(inferredExtendsType), t => isTypeAssignableTo(t, getPermissiveInstantiation(checkType)))) {                         (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));                     }                     // If falseType is an immediately nested conditional type that isn't distributive or has an                     // identical checkType, switch to that type and loop.                     const falseType = getTypeFromTypeNode(root.node.falseType);                     if (falseType.flags & TypeFlags.Conditional) {                         const newRoot = (falseType as ConditionalType).root;                         if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {                             root = newRoot;                             continue;                         }                         if (canTailRecurse(falseType, mapper)) {                             continue;                         }                     }                     result = instantiateType(falseType, mapper);                     break;                 }                 // Return trueType for a definitely true extends check. We check instantiations of the two                 // types with type parameters mapped to their restrictive form, i.e. a form of the type parameter                 // that has no constraint. This ensures that, for example, the type                 //   type Foo<T extends { x: any }> = T extends { x: string } ? string : number                 // doesn't immediately resolve to 'string' instead of being deferred.                 if (inferredExtendsType.flags & TypeFlags.AnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {                     const trueType = getTypeFromTypeNode(root.node.trueType);                     const trueMapper = combinedMapper || mapper;                     if (canTailRecurse(trueType, trueMapper)) {                         continue;                     }                     result = instantiateType(trueType, trueMapper);                     break;                 }             }             // Return a deferred type for a check that is neither definitely true nor definitely false             result = createType(TypeFlags.Conditional) as ConditionalType;             result.root = root;             result.checkType = instantiateType(root.checkType, mapper);             result.extendsType = instantiateType(root.extendsType, mapper);             result.mapper = mapper;             result.combinedMapper = combinedMapper;             result.aliasSymbol = aliasSymbol || root.aliasSymbol;             result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper!); // TODO: GH#18217             break;         } */
		return /* TODO(ConditionalExpression): extraTypes ? getUnionType(append(extraTypes, result)) : result */ TODO
		canTailRecurse := func(newType Type, newMapper *TypeMapper) /* TODO(undefined): boolean */ TODO {
			if newType.flags&TypeFlagsConditional && newMapper {
				newRoot := (newType /* as */ /* TODO(TypeReference): ConditionalType */).root
				if newRoot.outerTypeParameters {
					typeParamMapper := combineTypeMappers((newType /* as */ /* TODO(TypeReference): ConditionalType */).mapper, newMapper)
					typeArguments := map_(newRoot.outerTypeParameters, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						/* TODO(Identifier): getMappedType */
						/* TODO(Identifier): t */
						/* TODO(Identifier): typeParamMapper */
					})
					newRootMapper := createTypeMapper(newRoot.outerTypeParameters, typeArguments)
					newCheckType := /* TODO(ConditionalExpression): newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : undefined */ TODO
					if !newCheckType || newCheckType == newRoot.checkType || !(newCheckType.flags & (TypeFlagsUnion | TypeFlagsNever)) {
						root = newRoot
						mapper = newRootMapper
						aliasSymbol = nil
						aliasTypeArguments = nil
						if newRoot.aliasSymbol {
							tailCount++
						}
						return true
					}
				}
			}
			return false
		}
	}
	getTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedTrueType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper) */ TODO)
	}
	getFalseTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedFalseType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper) */ TODO)
	}
	getInferredTrueTypeFromConditionalType := func(type_ ConditionalType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return type_.resolvedInferredTrueType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type) */ TODO)
	}
	getInferTypeParameters := func(node ConditionalTypeNode) /* TODO(ArrayType): TypeParameter[] */ any {
		var result /* TODO(ArrayType): TypeParameter[] */ any
		if node.locals {
			node.locals.forEach(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
				if symbol.flags & SymbolFlagsTypeParameter {
					result = append(result, getDeclaredTypeOfSymbol(symbol))
				}
			})
		}
		return result
	}
	isDistributionDependent := func(root ConditionalRoot) /* TODO(undefined): boolean */ TODO {
		return root.isDistributive && (isTypeParameterPossiblyReferenced(root.checkType /* as */ /* TODO(TypeReference): TypeParameter */, root.node.trueType) || isTypeParameterPossiblyReferenced(root.checkType /* as */ /* TODO(TypeReference): TypeParameter */, root.node.falseType))
	}
	getTypeFromConditionalTypeNode := func(node ConditionalTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			checkType := getTypeFromTypeNode(node.checkType)
			aliasSymbol := getAliasSymbolForTypeNode(node)
			aliasTypeArguments := getTypeArgumentsForAliasSymbol(aliasSymbol)
			allOuterTypeParameters := getOuterTypeParameters(node, true)
			outerTypeParameters := /* TODO(ConditionalExpression): aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node)) */ TODO
			var root ConditionalRoot = /* TODO(ObjectLiteralExpression): {                 node,                 checkType,                 extendsType: getTypeFromTypeNode(node.extendsType),                 isDistributive: !!(checkType.flags & TypeFlags.TypeParameter),                 inferTypeParameters: getInferTypeParameters(node),                 outerTypeParameters,                 instantiations: undefined,                 aliasSymbol,                 aliasTypeArguments,             } */ TODO
			links.resolvedType = getConditionalType(root, nil, false)
			if outerTypeParameters {
				root.instantiations = /* TODO(NewExpression): new Map<string, Type>() */ TODO
				root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType)
			}
		}
		return links.resolvedType
	}
	getTypeFromInferTypeNode := func(node InferTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter))
		}
		return links.resolvedType
	}
	getIdentifierChain := func(node EntityName) []Identifier {
		if isIdentifier(node) {
			return /* TODO(ArrayLiteralExpression): [node] */ TODO
		} else {
			return append(getIdentifierChain(node.left), node.right)
		}
	}
	getTypeFromImportTypeNode := func(node ImportTypeNode) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			if !isLiteralImportTypeNode(node) {
				error(node.argument, Diagnostics.String_literal_expected)
				links.resolvedSymbol = unknownSymbol
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			targetMeaning := /* TODO(ConditionalExpression): node.isTypeOf ? SymbolFlags.Value : node.flags & NodeFlags.JSDoc ? SymbolFlags.Value | SymbolFlags.Type : SymbolFlags.Type */ TODO
			innerModuleSymbol := resolveExternalModuleName(node, node.argument.literal)
			if !innerModuleSymbol {
				links.resolvedSymbol = unknownSymbol
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			isExportEquals := !!innerModuleSymbol.exports.get(InternalSymbolNameExportEquals)
			moduleSymbol := resolveExternalModuleSymbol(innerModuleSymbol, false)
			if !nodeIsMissing(node.qualifier) {
				var nameStack []Identifier = getIdentifierChain( /* TODO(NonNullExpression): node.qualifier! */ TODO)
				currentNamespace := moduleSymbol
				var current *Identifier
				/* TODO(WhileStatement): while (current = nameStack.shift()) {                     const meaning = nameStack.length ? SymbolFlags.Namespace : targetMeaning;                     // typeof a.b.c is normally resolved using `checkExpression` which in turn defers to `checkQualifiedName`                     // That, in turn, ultimately uses `getPropertyOfType` on the type of the symbol, which differs slightly from                     // the `exports` lookup process that only looks up namespace members which is used for most type references                     const mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));                     const symbolFromVariable = node.isTypeOf || isInJSFile(node) && isExportEquals                         ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, /*skipObjectFunctionPropertyAugment* / false, /*includeTypeOnlyMembers* / true)                         : undefined;                     const symbolFromModule = node.isTypeOf ? undefined : getSymbol(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);                     const next = symbolFromModule ?? symbolFromVariable;                     if (!next) {                         error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current));                         return links.resolvedType = errorType;                     }                     getNodeLinks(current).resolvedSymbol = next;                     getNodeLinks(current.parent).resolvedSymbol = next;                     currentNamespace = next;                 } */
				links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning)
			} else {
				if moduleSymbol.flags & targetMeaning {
					links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning)
				} else {
					errorMessage := /* TODO(ConditionalExpression): targetMeaning === SymbolFlags.Value                         ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here                         : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0 */ TODO
					error(node, errorMessage, node.argument.literal.text)
					links.resolvedSymbol = unknownSymbol
					links.resolvedType = errorType
				}
			}
		}
		return links.resolvedType
	}
	resolveImportSymbolType := func(node ImportTypeNode, links NodeLinks, symbol Symbol, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		resolvedSymbol := resolveSymbol(symbol)
		links.resolvedSymbol = resolvedSymbol
		if meaning == SymbolFlagsValue {
			return getInstantiationExpressionType(getTypeOfSymbol(symbol), node)
		} else {
			return getTypeReferenceType(node, resolvedSymbol)
		}
	}
	getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode := func(node /* TODO(UnionType): TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			aliasSymbol := getAliasSymbolForTypeNode(node)
			if getMembersOfSymbol(node.symbol).size == 0 && !aliasSymbol {
				links.resolvedType = emptyTypeLiteralType
			} else {
				type_ := createObjectType(ObjectFlagsAnonymous, node.symbol)
				type_.aliasSymbol = aliasSymbol
				type_.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol)
				if isJSDocTypeLiteral(node) && node.isArrayType {
					type_ = createArrayType(type_)
				}
				links.resolvedType = type_
			}
		}
		return links.resolvedType
	}
	getAliasSymbolForTypeNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		host := node.parent
		/* TODO(WhileStatement): while (isParenthesizedTypeNode(host) || isJSDocTypeExpression(host) || isTypeOperatorNode(host) && host.operator === SyntaxKind.ReadonlyKeyword) {             host = host.parent;         } */
		return /* TODO(ConditionalExpression): isTypeAlias(host) ? getSymbolOfDeclaration(host) : undefined */ TODO
	}
	getTypeArgumentsForAliasSymbol := func(symbol *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		return /* TODO(ConditionalExpression): symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : undefined */ TODO
	}
	isNonGenericObjectType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags & TypeFlagsObject) && !isGenericMappedType(type_)
	}
	isEmptyObjectTypeOrSpreadsIntoEmptyObject := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return isEmptyObjectType(type_) || !!(type_.flags & (TypeFlagsNull | TypeFlagsUndefined | TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex))
	}
	tryMergeUnionOfObjectTypeAndEmptyObject := func(type_ Type, readonly bool) Type {
		if !(type_.flags & TypeFlagsUnion) {
			return type_
		}
		if every((type_ /* as */ /* TODO(TypeReference): UnionType */).types, isEmptyObjectTypeOrSpreadsIntoEmptyObject) {
			return find((type_ /* as */ /* TODO(TypeReference): UnionType */).types, isEmptyObjectType) || emptyObjectType
		}
		firstType := find((type_ /* as */ /* TODO(TypeReference): UnionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): isEmptyObjectTypeOrSpreadsIntoEmptyObject(t) */
		})
		if !firstType {
			return type_
		}
		secondType := find((type_ /* as */ /* TODO(TypeReference): UnionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): t !== firstType */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(PrefixUnaryExpression): !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t) */
		})
		if secondType {
			return type_
		}
		return getAnonymousPartialType(firstType)
		getAnonymousPartialType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			members := createSymbolTable()
			for _, prop := range getPropertiesOfType(type_) {
				if getDeclarationModifierFlagsFromSymbol(prop) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				} else if isSpreadableProperty(prop) {
					isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
					flags := SymbolFlagsProperty | SymbolFlagsOptional
					result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|( /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */ TODO))
					result.links.type_ = /* TODO(ConditionalExpression): isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), /*isProperty* / true) */ TODO
					result.declarations = prop.declarations
					result.links.nameType = getSymbolLinks(prop).nameType
					result.links.syntheticOrigin = prop
					members.set(prop.escapedName, result)
				}
			}
			spread := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
			spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return spread
		}
	}
	getSpreadType := func(left Type, right Type, symbol *Symbol, objectFlags ObjectFlags, readonly bool) Type {
		if left.flags&TypeFlagsAny || right.flags&TypeFlagsAny {
			return anyType
		}
		if left.flags&TypeFlagsUnknown || right.flags&TypeFlagsUnknown {
			return unknownType
		}
		if left.flags & TypeFlagsNever {
			return right
		}
		if right.flags & TypeFlagsNever {
			return left
		}
		left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly)
		if left.flags & TypeFlagsUnion {
			return /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(left, t => getSpreadType(t, right, symbol, objectFlags, readonly))                 : errorType */ TODO
		}
		right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly)
		if right.flags & TypeFlagsUnion {
			return /* TODO(ConditionalExpression): checkCrossProductUnion([left, right])                 ? mapType(right, t => getSpreadType(left, t, symbol, objectFlags, readonly))                 : errorType */ TODO
		}
		if right.flags & (TypeFlagsBooleanLike | TypeFlagsNumberLike | TypeFlagsBigIntLike | TypeFlagsStringLike | TypeFlagsEnumLike | TypeFlagsNonPrimitive | TypeFlagsIndex) {
			return left
		}
		if isGenericObjectType(left) || isGenericObjectType(right) {
			if isEmptyObjectType(left) {
				return right
			}
			if left.flags & TypeFlagsIntersection {
				types := (left /* as */ /* TODO(TypeReference): IntersectionType */).types
				lastLeft := /* TODO(ElementAccessExpression): types[types.length - 1] */ TODO
				if isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right) {
					return getIntersectionType(concatenate(types.slice(0 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - 1 */, TODO) /* TODO(ArrayLiteralExpression): [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)] */, TODO))
				}
			}
			return getIntersectionType( /* TODO(ArrayLiteralExpression): [left, right] */ TODO)
		}
		members := createSymbolTable()
		skippedPrivateMembers := /* TODO(NewExpression): new Set<__String>() */ TODO
		indexInfos := /* TODO(ConditionalExpression): left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]) */ TODO
		for _, rightProp := range getPropertiesOfType(right) {
			if getDeclarationModifierFlagsFromSymbol(rightProp) & (ModifierFlagsPrivate | ModifierFlagsProtected) {
				skippedPrivateMembers.add(rightProp.escapedName)
			} else if isSpreadableProperty(rightProp) {
				members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly))
			}
		}
		for _, leftProp := range getPropertiesOfType(left) {
			if skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp) {
				/* TODO(ContinueStatement): continue; */
			}
			if members.has(leftProp.escapedName) {
				rightProp := /* TODO(NonNullExpression): members.get(leftProp.escapedName)! */ TODO
				rightType := getTypeOfSymbol(rightProp)
				if rightProp.flags & SymbolFlagsOptional {
					declarations := concatenate(leftProp.declarations, rightProp.declarations)
					flags := SymbolFlagsProperty | (leftProp.flags & SymbolFlagsOptional)
					result := createSymbol(flags, leftProp.escapedName)
					leftType := getTypeOfSymbol(leftProp)
					leftTypeWithoutUndefined := removeMissingOrUndefinedType(leftType)
					rightTypeWithoutUndefined := removeMissingOrUndefinedType(rightType)
					result.links.type_ = /* TODO(ConditionalExpression): leftTypeWithoutUndefined === rightTypeWithoutUndefined ? leftType : getUnionType([leftType, rightTypeWithoutUndefined], UnionReduction.Subtype) */ TODO
					result.links.leftSpread = leftProp
					result.links.rightSpread = rightProp
					result.declarations = declarations
					result.links.nameType = getSymbolLinks(leftProp).nameType
					members.set(leftProp.escapedName, result)
				}
			} else {
				members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly))
			}
		}
		spread := createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
			/* TODO(Identifier): getIndexInfoWithReadonly */
			/* TODO(Identifier): info */
			/* TODO(Identifier): readonly */
		}))
		spread.objectFlags |= ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral | ObjectFlagsContainsSpread | objectFlags
		return spread
	}
	isSpreadableProperty := func(prop Symbol) bool {
		return !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) && (!(prop.flags & (SymbolFlagsMethod | SymbolFlagsGetAccessor | SymbolFlagsSetAccessor)) || !prop.declarations.some(func(decl /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isClassLike */
			/* TODO(PropertyAccessExpression): decl.parent */
		}))
	}
	getSpreadSymbol := func(prop Symbol, readonly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
		if !isSetonlyAccessor && readonly == isReadonlySymbol(prop) {
			return prop
		}
		flags := SymbolFlagsProperty | (prop.flags & SymbolFlagsOptional)
		result := createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop)|( /* TODO(ConditionalExpression): readonly ? CheckFlags.Readonly : 0 */ TODO))
		result.links.type_ = /* TODO(ConditionalExpression): isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop) */ TODO
		result.declarations = prop.declarations
		result.links.nameType = getSymbolLinks(prop).nameType
		result.links.syntheticOrigin = prop
		return result
	}
	getIndexInfoWithReadonly := func(info IndexInfo, readonly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
		return /* TODO(ConditionalExpression): info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info */ TODO
	}
	createLiteralType := func(flags TypeFlags, value /* TODO(UnionType): string | number | PseudoBigInt */ any, symbol Symbol, regularType LiteralType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType */ TODO {
		type_ := createTypeWithSymbol(flags /* TODO(NonNullExpression): symbol! */, TODO) /* as */ /* TODO(TypeReference): LiteralType */
		type_.value = value
		type_.regularType = regularType || type_
		return type_
	}
	getFreshTypeOfLiteralType := func(type_ Type) Type {
		if type_.flags & TypeFlagsFreshable {
			if !(type_ /* as */ /* TODO(TypeReference): FreshableType */).freshType {
				freshType := createLiteralType(type_.flags, (type_ /* as */ /* TODO(TypeReference): LiteralType */).value, (type_ /* as */ /* TODO(TypeReference): LiteralType */).symbol, type_ /* as */ /* TODO(TypeReference): LiteralType */)
				freshType.freshType = freshType
				(type_ /* as */ /* TODO(TypeReference): FreshableType */).freshType = freshType
			}
			return (type_ /* as */ /* TODO(TypeReference): FreshableType */).freshType
		}
		return type_
	}
	getRegularTypeOfLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Freshable ? (type as FreshableType).regularType :             type.flags & TypeFlags.Union ? ((type as UnionType).regularType || ((type as UnionType).regularType = mapType(type, getRegularTypeOfLiteralType) as UnionType)) :             type */ TODO
	}
	isFreshLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.flags & TypeFlagsFreshable) && (type_ /* as */ /* TODO(TypeReference): LiteralType */).freshType == type_
	}
	getStringLiteralType := func(value string) StringLiteralType {
		var type_ TODO
		return stringLiteralTypes.get(value) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): stringLiteralTypes.set(value, type = createLiteralType(TypeFlags.StringLiteral, value) as StringLiteralType), type */ TODO)
	}
	getNumberLiteralType := func(value number) NumberLiteralType {
		var type_ TODO
		return numberLiteralTypes.get(value) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): numberLiteralTypes.set(value, type = createLiteralType(TypeFlags.NumberLiteral, value) as NumberLiteralType), type */ TODO)
	}
	getBigIntLiteralType := func(value PseudoBigInt) BigIntLiteralType {
		var type_ TODO
		key := pseudoBigIntToString(value)
		return bigIntLiteralTypes.get(key) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): bigIntLiteralTypes.set(key, type = createLiteralType(TypeFlags.BigIntLiteral, value) as BigIntLiteralType), type */ TODO)
	}
	getEnumLiteralType := func(value /* TODO(UnionType): string | number */ any, enumId number, symbol Symbol) LiteralType {
		var type_ TODO
		key := /* TODO(TemplateExpression): `${enumId}${typeof value === "string" ? "@" : "#"}${value}` */ TODO
		flags := TypeFlagsEnumLiteral | ( /* TODO(ConditionalExpression): typeof value === "string" ? TypeFlags.StringLiteral : TypeFlags.NumberLiteral */ TODO)
		return enumLiteralTypes.get(key) || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type */ TODO)
	}
	getTypeFromLiteralTypeNode := func(node LiteralTypeNode) Type {
		if node.literal.kind == SyntaxKindNullKeyword {
			return nullType
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal))
		}
		return links.resolvedType
	}
	createUniqueESSymbolType := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").UniqueESSymbolType */ TODO {
		type_ := createTypeWithSymbol(TypeFlagsUniqueESSymbol, symbol)                                                       /* as */ /* TODO(TypeReference): UniqueESSymbolType */
		type_.escapedName = /* TODO(TemplateExpression): `__@${type.symbol.escapedName}@${getSymbolId(type.symbol)}` */ TODO /* as */ /* TODO(TypeReference): __String */
		return type_
	}
	getESSymbolLikeTypeForNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isInJSFile(node) && isJSDocTypeExpression(node) {
			host := getJSDocHost(node)
			if host {
				node = getSingleVariableOfVariableStatement(host) || host
			}
		}
		if isValidESSymbolDeclaration(node) {
			symbol := /* TODO(ConditionalExpression): isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode((node as BinaryExpression).left) : getSymbolOfNode(node) */ TODO
			if symbol {
				links := getSymbolLinks(symbol)
				return links.uniqueESSymbolType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.uniqueESSymbolType = createUniqueESSymbolType(symbol) */ TODO)
			}
		}
		return esSymbolType
	}
	getThisType := func(node Node) Type {
		container := getThisContainer(node, false, false)
		parent := container && container.parent
		if parent && (isClassLike(parent) || parent.kind == SyntaxKindInterfaceDeclaration) {
			if !isStatic(container) && (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body)) {
				return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent as ClassLikeDeclaration | InterfaceDeclaration)).thisType! */ TODO
			}
		}
		if parent && isObjectLiteralExpression(parent) && isBinaryExpression(parent.parent) && getAssignmentDeclarationKind(parent.parent) == AssignmentDeclarationKindPrototype {
			return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent.parent.left)!.parent!).thisType! */ TODO
		}
		host := /* TODO(ConditionalExpression): node.flags & NodeFlags.JSDoc ? getHostSignatureFromJSDoc(node) : undefined */ TODO
		if host && isFunctionExpression(host) && isBinaryExpression(host.parent) && getAssignmentDeclarationKind(host.parent) == AssignmentDeclarationKindPrototypeProperty {
			return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host.parent.left)!.parent!).thisType! */ TODO
		}
		if isJSConstructor(container) && isNodeDescendantOf(node, container.body) {
			return /* TODO(NonNullExpression): getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType! */ TODO
		}
		error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface)
		return errorType
	}
	getTypeFromThisTypeNode := func(node /* TODO(UnionType): ThisExpression | ThisTypeNode */ any) Type {
		links := getNodeLinks(node)
		if !links.resolvedType {
			links.resolvedType = getThisType(node)
		}
		return links.resolvedType
	}
	getTypeFromRestTypeNode := func(node /* TODO(UnionType): RestTypeNode | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeFromTypeNode(getArrayElementTypeNode(node.type_) || node.type_)
	}
	getArrayElementTypeNode := func(node TypeNode) *TypeNode {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ParenthesizedType:                 return getArrayElementTypeNode((node as ParenthesizedTypeNode).type);             case SyntaxKind.TupleType:                 if ((node as TupleTypeNode).elements.length === 1) {                     node = (node as TupleTypeNode).elements[0];                     if (node.kind === SyntaxKind.RestType || node.kind === SyntaxKind.NamedTupleMember && (node as NamedTupleMember).dotDotDotToken) {                         return getArrayElementTypeNode((node as RestTypeNode | NamedTupleMember).type);                     }                 }                 break;             case SyntaxKind.ArrayType:                 return (node as ArrayTypeNode).elementType;         } */
		return nil
	}
	getTypeFromNamedTupleTypeNode := func(node NamedTupleMember) Type {
		links := getNodeLinks(node)
		return links.resolvedType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) :             addOptionality(getTypeFromTypeNode(node.type), /*isProperty* / true, !!node.questionToken) */ TODO)
	}
	getTypeFromTypeNode := func(node TypeNode) Type {
		return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node)
	}
	getTypeFromTypeNodeWorker := func(node TypeNode) Type {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AnyKeyword:             case SyntaxKind.JSDocAllType:             case SyntaxKind.JSDocUnknownType:                 return anyType;             case SyntaxKind.UnknownKeyword:                 return unknownType;             case SyntaxKind.StringKeyword:                 return stringType;             case SyntaxKind.NumberKeyword:                 return numberType;             case SyntaxKind.BigIntKeyword:                 return bigintType;             case SyntaxKind.BooleanKeyword:                 return booleanType;             case SyntaxKind.SymbolKeyword:                 return esSymbolType;             case SyntaxKind.VoidKeyword:                 return voidType;             case SyntaxKind.UndefinedKeyword:                 return undefinedType;             case SyntaxKind.NullKeyword as TypeNodeSyntaxKind:                 // TODO(rbuckton): `NullKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service.                 return nullType;             case SyntaxKind.NeverKeyword:                 return neverType;             case SyntaxKind.ObjectKeyword:                 return node.flags & NodeFlags.JavaScriptFile && !noImplicitAny ? anyType : nonPrimitiveType;             case SyntaxKind.IntrinsicKeyword:                 return intrinsicMarkerType;             case SyntaxKind.ThisType:             case SyntaxKind.ThisKeyword as TypeNodeSyntaxKind:                 // TODO(rbuckton): `ThisKeyword` is no longer a `TypeNode`, but we defensively allow it here because of incorrect casts in the Language Service and because of `isPartOfTypeNode`.                 return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode);             case SyntaxKind.LiteralType:                 return getTypeFromLiteralTypeNode(node as LiteralTypeNode);             case SyntaxKind.TypeReference:                 return getTypeFromTypeReference(node as TypeReferenceNode);             case SyntaxKind.TypePredicate:                 return (node as TypePredicateNode).assertsModifier ? voidType : booleanType;             case SyntaxKind.ExpressionWithTypeArguments:                 return getTypeFromTypeReference(node as ExpressionWithTypeArguments);             case SyntaxKind.TypeQuery:                 return getTypeFromTypeQueryNode(node as TypeQueryNode);             case SyntaxKind.ArrayType:             case SyntaxKind.TupleType:                 return getTypeFromArrayOrTupleTypeNode(node as ArrayTypeNode | TupleTypeNode);             case SyntaxKind.OptionalType:                 return getTypeFromOptionalTypeNode(node as OptionalTypeNode);             case SyntaxKind.UnionType:                 return getTypeFromUnionTypeNode(node as UnionTypeNode);             case SyntaxKind.IntersectionType:                 return getTypeFromIntersectionTypeNode(node as IntersectionTypeNode);             case SyntaxKind.JSDocNullableType:                 return getTypeFromJSDocNullableTypeNode(node as JSDocNullableType);             case SyntaxKind.JSDocOptionalType:                 return addOptionality(getTypeFromTypeNode((node as JSDocOptionalType).type));             case SyntaxKind.NamedTupleMember:                 return getTypeFromNamedTupleTypeNode(node as NamedTupleMember);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocTypeExpression:                 return getTypeFromTypeNode((node as ParenthesizedTypeNode | JSDocTypeReferencingNode | JSDocTypeExpression | NamedTupleMember).type);             case SyntaxKind.RestType:                 return getTypeFromRestTypeNode(node as RestTypeNode);             case SyntaxKind.JSDocVariadicType:                 return getTypeFromJSDocVariadicType(node as JSDocVariadicType);             case SyntaxKind.FunctionType:             case SyntaxKind.ConstructorType:             case SyntaxKind.TypeLiteral:             case SyntaxKind.JSDocTypeLiteral:             case SyntaxKind.JSDocFunctionType:             case SyntaxKind.JSDocSignature:                 return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node as TypeLiteralNode | FunctionOrConstructorTypeNode | JSDocTypeLiteral | JSDocFunctionType | JSDocSignature);             case SyntaxKind.TypeOperator:                 return getTypeFromTypeOperatorNode(node as TypeOperatorNode);             case SyntaxKind.IndexedAccessType:                 return getTypeFromIndexedAccessTypeNode(node as IndexedAccessTypeNode);             case SyntaxKind.MappedType:                 return getTypeFromMappedTypeNode(node as MappedTypeNode);             case SyntaxKind.ConditionalType:                 return getTypeFromConditionalTypeNode(node as ConditionalTypeNode);             case SyntaxKind.InferType:                 return getTypeFromInferTypeNode(node as InferTypeNode);             case SyntaxKind.TemplateLiteralType:                 return getTypeFromTemplateTypeNode(node as TemplateLiteralTypeNode);             case SyntaxKind.ImportType:                 return getTypeFromImportTypeNode(node as ImportTypeNode);             // This function assumes that an identifier, qualified name, or property access expression is a type expression             // Callers should first ensure this by calling `isPartOfTypeNode`             // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.             case SyntaxKind.Identifier as TypeNodeSyntaxKind:             case SyntaxKind.QualifiedName as TypeNodeSyntaxKind:             case SyntaxKind.PropertyAccessExpression as TypeNodeSyntaxKind:                 const symbol = getSymbolAtLocation(node);                 return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;             default:                 return errorType;         } */
	}
	// OVERLOAD: instantiateList := func(items []T, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) []T
	// OVERLOAD: instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any
	instantiateList := func(items /* TODO(TypeOperator): readonly T[] */ any, mapper TypeMapper, instantiator func(item T, mapper TypeMapper) T) /* TODO(TypeOperator): readonly T[] */ any {
		if items && items.length {
			/* TODO(ForStatement): for (let i = 0; i < items.length; i++) {                 const item = items[i];                 const mapped = instantiator(item, mapper);                 if (item !== mapped) {                     const result = i === 0 ? [] : items.slice(0, i);                     result.push(mapped);                     for (i++; i < items.length; i++) {                         result.push(instantiator(items[i], mapper));                     }                     return result;                 }             } */
		}
		return items
	}
	// OVERLOAD: instantiateTypes := func(types []Type, mapper TypeMapper) []Type
	// OVERLOAD: instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any
	instantiateTypes := func(types /* TODO(TypeOperator): readonly Type[] */ any, mapper TypeMapper) /* TODO(TypeOperator): readonly Type[] */ any {
		return instantiateList(types, mapper, instantiateType)
	}
	instantiateSignatures := func(signatures []Signature, mapper TypeMapper) []Signature {
		return instantiateList(signatures, mapper, instantiateSignature)
	}
	instantiateIndexInfos := func(indexInfos []IndexInfo, mapper TypeMapper) []IndexInfo {
		return instantiateList(indexInfos, mapper, instantiateIndexInfo)
	}
	createTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return /* TODO(ConditionalExpression): sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets) */ TODO
	}
	getMappedType := func(type_ Type, mapper TypeMapper) Type {
		/* TODO(SwitchStatement): switch (mapper.kind) {             case TypeMapKind.Simple:                 return type === mapper.source ? mapper.target : type;             case TypeMapKind.Array: {                 const sources = mapper.sources;                 const targets = mapper.targets;                 for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets ? targets[i] : anyType;                     }                 }                 return type;             }             case TypeMapKind.Deferred: {                 const sources = mapper.sources;                 const targets = mapper.targets;                 for (let i = 0; i < sources.length; i++) {                     if (type === sources[i]) {                         return targets[i]();                     }                 }                 return type;             }             case TypeMapKind.Function:                 return mapper.func(type);             case TypeMapKind.Composite:             case TypeMapKind.Merged:                 const t1 = getMappedType(type, mapper.mapper1);                 return t1 !== type && mapper.kind === TypeMapKind.Composite ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);         } */
	}
	makeUnaryTypeMapper := func(source Type, target Type) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Simple, source, target } */ TODO)
	}
	makeArrayTypeMapper := func(sources []TypeParameter, targets /* TODO(TypeOperator): readonly Type[] */ any) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Array, sources, targets } */ TODO)
	}
	makeFunctionTypeMapper := func(func_ func(t Type) Type, debugInfo func() string) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Function, func, debugInfo: Debug.isDebugging ? debugInfo : undefined } */ TODO)
	}
	makeDeferredTypeMapper := func(sources []TypeParameter, targets []func() Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind: TypeMapKind.Deferred, sources, targets } */ TODO)
	}
	makeCompositeTypeMapper := func(kind /* TODO(UnionType): TypeMapKind.Composite | TypeMapKind.Merged */ any, mapper1 TypeMapper, mapper2 TypeMapper) TypeMapper {
		return Debug.attachDebugPrototypeIfDebug( /* TODO(ObjectLiteralExpression): { kind, mapper1, mapper2 } */ TODO)
	}
	createTypeEraser := func(sources []TypeParameter) TypeMapper {
		return createTypeMapper(sources, nil)
	}
	createBackreferenceMapper := func(context InferenceContext, index number) TypeMapper {
		forwardInferences := context.inferences.slice(index)
		return createTypeMapper(map_(forwardInferences, func(i /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			/* TODO(Identifier): i */
			/* TODO(Identifier): typeParameter */
		}), map_(forwardInferences, func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType */ TODO {
		}))
	}
	combineTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		return /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Composite, mapper1, mapper2) : mapper2 */ TODO
	}
	mergeTypeMappers := func(mapper1 *TypeMapper, mapper2 TypeMapper) TypeMapper {
		return /* TODO(ConditionalExpression): mapper1 ? makeCompositeTypeMapper(TypeMapKind.Merged, mapper1, mapper2) : mapper2 */ TODO
	}
	prependTypeMapping := func(source Type, target Type, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, makeUnaryTypeMapper(source, target), mapper) */ TODO
	}
	appendTypeMapping := func(mapper *TypeMapper, source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return /* TODO(ConditionalExpression): !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(TypeMapKind.Merged, mapper, makeUnaryTypeMapper(source, target)) */ TODO
	}
	getRestrictiveTypeParameter := func(tp TypeParameter) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (             tp.restrictiveInstantiation = createTypeParameter(tp.symbol), (tp.restrictiveInstantiation as TypeParameter).constraint = noConstraintType, tp.restrictiveInstantiation         ) */ TODO
	}
	cloneTypeParameter := func(typeParameter TypeParameter) TypeParameter {
		result := createTypeParameter(typeParameter.symbol)
		result.target = typeParameter
		return result
	}
	instantiateTypePredicate := func(predicate TypePredicate, mapper TypeMapper) TypePredicate {
		return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type_, mapper))
	}
	instantiateSignature := func(signature Signature, mapper TypeMapper, eraseTypeParameters bool) Signature {
		var freshTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		if signature.typeParameters && !eraseTypeParameters {
			freshTypeParameters = map_(signature.typeParameters, cloneTypeParameter)
			mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper)
			for _, tp := range freshTypeParameters {
				tp.mapper = mapper
			}
		}
		result := createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), nil, nil, signature.minArgumentCount, signature.flags&SignatureFlagsPropagatingFlags)
		result.target = signature
		result.mapper = mapper
		return result
	}
	instantiateSymbol := func(symbol Symbol, mapper TypeMapper) Symbol {
		links := getSymbolLinks(symbol)
		if links.type_ && !couldContainTypeVariables(links.type_) {
			if !(symbol.flags & SymbolFlagsSetAccessor) {
				return symbol
			}
			if links.writeType && !couldContainTypeVariables(links.writeType) {
				return symbol
			}
		}
		if getCheckFlags(symbol) & CheckFlagsInstantiated {
			symbol = /* TODO(NonNullExpression): links.target! */ TODO
			mapper = combineTypeMappers(links.mapper, mapper)
		}
		result := createSymbol(symbol.flags, symbol.escapedName, CheckFlagsInstantiated|getCheckFlags(symbol)&(CheckFlagsReadonly|CheckFlagsLate|CheckFlagsOptionalParameter|CheckFlagsRestParameter))
		result.declarations = symbol.declarations
		result.parent = symbol.parent
		result.links.target = symbol
		result.links.mapper = mapper
		if symbol.valueDeclaration {
			result.valueDeclaration = symbol.valueDeclaration
		}
		if links.nameType {
			result.links.nameType = links.nameType
		}
		return result
	}
	getObjectTypeInstantiation := func(type_ /* TODO(UnionType): AnonymousType | DeferredTypeReference */ any, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		declaration := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? (type as TypeReference).node! :             type.objectFlags & ObjectFlags.InstantiationExpressionType ? (type as InstantiationExpressionType).node :             type.symbol.declarations![0] */ TODO
		links := getNodeLinks(declaration)
		target := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.Reference ? links.resolvedType! as DeferredTypeReference :             type.objectFlags & ObjectFlags.Instantiated ? type.target! : type */ TODO
		typeParameters := /* TODO(ConditionalExpression): type.objectFlags & ObjectFlags.SingleSignatureType ? (type as SingleSignatureType).outerTypeParameters : links.outerTypeParameters */ TODO
		if !typeParameters {
			outerTypeParameters := getOuterTypeParameters(declaration, true)
			if isJSConstructor(declaration) {
				templateTagParameters := getTypeParametersFromDeclaration(declaration /* as */ /* TODO(TypeReference): DeclarationWithTypeParameters */)
				outerTypeParameters = addRange(outerTypeParameters, templateTagParameters)
			}
			typeParameters = outerTypeParameters || emptyArray
			allDeclarations := /* TODO(ConditionalExpression): type.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) ? [declaration] : type.symbol.declarations! */ TODO
			typeParameters = /* TODO(ConditionalExpression): (target.objectFlags & (ObjectFlags.Reference | ObjectFlags.InstantiationExpressionType) || target.symbol.flags & SymbolFlags.Method || target.symbol.flags & SymbolFlags.TypeLiteral) && !target.aliasTypeArguments ?                 filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) :                 typeParameters */ TODO
			links.outerTypeParameters = typeParameters
		}
		if typeParameters.length {
			combinedMapper := combineTypeMappers(type_.mapper, mapper)
			typeArguments := map_(typeParameters, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getMappedType */
				/* TODO(Identifier): t */
				/* TODO(Identifier): combinedMapper */
			})
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (type.objectFlags & ObjectFlags.SingleSignatureType ? "S" : "") + getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments) */ TODO
			if !target.instantiations {
				target.instantiations = /* TODO(NewExpression): new Map<string, Type>() */ TODO
				target.instantiations.set( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments) */ TODO, target)
			}
			result := target.instantiations.get(id)
			if !result {
				if type_.objectFlags & ObjectFlagsSingleSignatureType {
					result = instantiateAnonymousType(type_, mapper)
					target.instantiations.set(id, result)
					return result
				}
				newMapper := createTypeMapper(typeParameters, typeArguments)
				result = /* TODO(ConditionalExpression): target.objectFlags & ObjectFlags.Reference ? createDeferredTypeReference((type as DeferredTypeReference).target, (type as DeferredTypeReference).node, newMapper, newAliasSymbol, newAliasTypeArguments) :                     target.objectFlags & ObjectFlags.Mapped ? instantiateMappedType(target as MappedType, newMapper, newAliasSymbol, newAliasTypeArguments) :                     instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments) */ TODO
				target.instantiations.set(id, result)
				resultObjectFlags := getObjectFlags(result)
				if result.flags&TypeFlagsObjectFlagsType && !(resultObjectFlags & ObjectFlagsCouldContainTypeVariablesComputed) {
					resultCouldContainTypeVariables := some(typeArguments, couldContainTypeVariables)
					if !(getObjectFlags(result) & ObjectFlagsCouldContainTypeVariablesComputed) {
						if resultObjectFlags & (ObjectFlagsMapped | ObjectFlagsAnonymous | ObjectFlagsReference) {
							(result /* as */ /* TODO(TypeReference): ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | ( /* TODO(ConditionalExpression): resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariables : 0 */ TODO)
						} else {
							(result /* as */ /* TODO(TypeReference): ObjectFlagsType */).objectFlags |= /* TODO(ConditionalExpression): !resultCouldContainTypeVariables ? ObjectFlags.CouldContainTypeVariablesComputed : 0 */ TODO
						}
					}
				}
			}
			return result
		}
		return type_
	}
	maybeTypeParameterReference := func(node Node) /* TODO(undefined): boolean */ TODO {
		return !(node.parent.kind == SyntaxKindTypeReference && (node.parent /* as */ /* TODO(TypeReference): TypeReferenceNode */).typeArguments && node == (node.parent /* as */ /* TODO(TypeReference): TypeReferenceNode */).typeName || node.parent.kind == SyntaxKindImportType && (node.parent /* as */ /* TODO(TypeReference): ImportTypeNode */).typeArguments && node == (node.parent /* as */ /* TODO(TypeReference): ImportTypeNode */).qualifier)
	}
	isTypeParameterPossiblyReferenced := func(tp TypeParameter, node Node) /* TODO(undefined): boolean */ TODO {
		if tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length == 1 {
			container := /* TODO(ElementAccessExpression): tp.symbol.declarations[0] */ TODO.parent
			/* TODO(ForStatement): for (let n = node; n !== container; n = n.parent) {                 if (!n || n.kind === SyntaxKind.Block || n.kind === SyntaxKind.ConditionalType && forEachChild((n as ConditionalTypeNode).extendsType, containsReference)) {                     return true;                 }             } */
			return containsReference(node)
		}
		return true
		containsReference := func(node Node) bool {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ThisType:                     return !!tp.isThisType;                 case SyntaxKind.Identifier:                     return !tp.isThisType && isPartOfTypeNode(node) && maybeTypeParameterReference(node) &&                         getTypeFromTypeNodeWorker(node as TypeNode) === tp; // use worker because we're looking for === equality                 case SyntaxKind.TypeQuery:                     const entityName = (node as TypeQueryNode).exprName;                     const firstIdentifier = getFirstIdentifier(entityName);                     if (!isThisIdentifier(firstIdentifier)) { // Don't attempt to analyze typeof this.xxx                         const firstIdentifierSymbol = getResolvedSymbol(firstIdentifier);                         const tpDeclaration = tp.symbol.declarations![0]; // There is exactly one declaration, otherwise `containsReference` is not called                         const tpScope = tpDeclaration.kind === SyntaxKind.TypeParameter ? tpDeclaration.parent : // Type parameter is a regular type parameter, e.g. foo<T>                             tp.isThisType ? tpDeclaration : // Type parameter is the this type, and its declaration is the class declaration.                             undefined; // Type parameter's declaration was unrecognized, e.g. comes from JSDoc annotation.                         if (firstIdentifierSymbol.declarations && tpScope) {                             return some(firstIdentifierSymbol.declarations, idDecl => isNodeDescendantOf(idDecl, tpScope)) ||                                 some((node as TypeQueryNode).typeArguments, containsReference);                         }                     }                     return true;                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.MethodSignature:                     return !(node as FunctionLikeDeclaration).type && !!(node as FunctionLikeDeclaration).body ||                         some((node as FunctionLikeDeclaration).typeParameters, containsReference) ||                         some((node as FunctionLikeDeclaration).parameters, containsReference) ||                         !!(node as FunctionLikeDeclaration).type && containsReference((node as FunctionLikeDeclaration).type!);             } */
			return !!forEachChild(node, containsReference)
		}
	}
	getHomomorphicTypeVariable := func(type_ MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter | undefined */ TODO {
		constraintType := getConstraintTypeFromMappedType(type_)
		if constraintType.flags & TypeFlagsIndex {
			typeVariable := getActualTypeVariable((constraintType /* as */ /* TODO(TypeReference): IndexType */).type_)
			if typeVariable.flags & TypeFlagsTypeParameter {
				return typeVariable /* as */ /* TODO(TypeReference): TypeParameter */
			}
		}
		return nil
	}
	instantiateMappedType := func(type_ MappedType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		typeVariable := getHomomorphicTypeVariable(type_)
		if typeVariable {
			mappedTypeVariable := instantiateType(typeVariable, mapper)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeVariable !== mappedTypeVariable */ TODO {
				return mapTypeWithAlias(getReducedType(mappedTypeVariable), instantiateConstituent, aliasSymbol, aliasTypeArguments)
			}
		}
		return /* TODO(ConditionalExpression): instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) */ TODO
		instantiateConstituent := func(t Type) Type {
			if t.flags&(TypeFlagsAnyOrUnknown|TypeFlagsInstantiableNonPrimitive|TypeFlagsObject|TypeFlagsIntersection) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): t !== wildcardType */ TODO && !isErrorType(t) {
				if !type_.declaration.nameType {
					var constraint TODO
					if isArrayType(t) || t.flags&TypeFlagsAny && findResolutionCycleStartIndex( /* TODO(NonNullExpression): typeVariable! */ TODO, TypeSystemPropertyNameImmediateBaseConstraint) < 0 && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): constraint = getConstraintOfTypeParameter(typeVariable!) */ TODO) && everyType(constraint, isArrayOrTupleType) {
						return instantiateMappedArrayType(t, type_, prependTypeMapping( /* TODO(NonNullExpression): typeVariable! */ TODO, t, mapper))
					}
					if isTupleType(t) {
						return instantiateMappedTupleType(t, type_ /* TODO(NonNullExpression): typeVariable! */, TODO, mapper)
					}
					if isArrayOrTupleOrIntersection(t) {
						return getIntersectionType(map_((t /* as */ /* TODO(TypeReference): IntersectionType */).types, instantiateConstituent))
					}
				}
				return instantiateAnonymousType(type_, prependTypeMapping( /* TODO(NonNullExpression): typeVariable! */ TODO, t, mapper))
			}
			return t
		}
	}
	getModifiedReadonlyState := func(state bool, modifiers MappedTypeModifiers) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeReadonly ? true : modifiers & MappedTypeModifiers.ExcludeReadonly ? false : state */ TODO
	}
	instantiateMappedTupleType := func(tupleType TupleTypeReference, mappedType MappedType, typeVariable TypeVariable, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		elementFlags := tupleType.target.elementFlags
		fixedLength := tupleType.target.fixedLength
		fixedMapper := /* TODO(ConditionalExpression): fixedLength ? prependTypeMapping(typeVariable, tupleType, mapper) : mapper */ TODO
		newElementTypes := map_(getElementTypes(tupleType), func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			flags := /* TODO(ElementAccessExpression): elementFlags[i] */ TODO
			return /* TODO(ConditionalExpression): i < fixedLength ? instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(flags & ElementFlags.Optional), fixedMapper) :                 flags & ElementFlags.Variadic ? instantiateType(mappedType, prependTypeMapping(typeVariable, type, mapper)) :                 getElementTypeOfArrayType(instantiateType(mappedType, prependTypeMapping(typeVariable, createArrayType(type), mapper))) ?? unknownType */ TODO
		})
		modifiers := getMappedTypeModifiers(mappedType)
		newElementFlags := /* TODO(ConditionalExpression): modifiers & MappedTypeModifiers.IncludeOptional ? map(elementFlags, f => f & ElementFlags.Required ? ElementFlags.Optional : f) :             modifiers & MappedTypeModifiers.ExcludeOptional ? map(elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :             elementFlags */ TODO
		newReadonly := getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType))
		return /* TODO(ConditionalExpression): contains(newElementTypes, errorType) ? errorType :             createTupleType(newElementTypes, newElementFlags, newReadonly, tupleType.target.labeledElementDeclarations) */ TODO
	}
	instantiateMappedArrayType := func(arrayType Type, mappedType MappedType, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		elementType := instantiateMappedTypeTemplate(mappedType, numberType, true, mapper)
		return /* TODO(ConditionalExpression): isErrorType(elementType) ? errorType :             createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType))) */ TODO
	}
	instantiateMappedTypeTemplate := func(type_ MappedType, key Type, isOptional bool, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		templateMapper := appendTypeMapping(mapper, getTypeParameterFromMappedType(type_), key)
		propType := instantiateType(getTemplateTypeFromMappedType(type_.target /* as */ /* TODO(TypeReference): MappedType */ || type_), templateMapper)
		modifiers := getMappedTypeModifiers(type_)
		return /* TODO(ConditionalExpression): strictNullChecks && modifiers & MappedTypeModifiers.IncludeOptional && !maybeTypeOfKind(propType, TypeFlags.Undefined | TypeFlags.Void) ? getOptionalType(propType, /*isProperty* / true) :             strictNullChecks && modifiers & MappedTypeModifiers.ExcludeOptional && isOptional ? getTypeWithFacts(propType, TypeFacts.NEUndefined) :             propType */ TODO
	}
	instantiateAnonymousType := func(type_ AnonymousType, mapper TypeMapper, aliasSymbol Symbol, aliasTypeArguments []Type) AnonymousType {
		Debug.assert(type_.symbol, "anonymous type must have symbol to be instantiated")
		result := createObjectType(type_.objectFlags&~(ObjectFlagsCouldContainTypeVariablesComputed|ObjectFlagsCouldContainTypeVariables)|ObjectFlagsInstantiated, type_.symbol) /* as */ /* TODO(TypeReference): AnonymousType */
		if type_.objectFlags & ObjectFlagsMapped {
			(result /* as */ /* TODO(TypeReference): MappedType */).declaration = (type_ /* as */ /* TODO(TypeReference): MappedType */).declaration
			origTypeParameter := getTypeParameterFromMappedType(type_ /* as */ /* TODO(TypeReference): MappedType */)
			freshTypeParameter := cloneTypeParameter(origTypeParameter)
			(result /* as */ /* TODO(TypeReference): MappedType */).typeParameter = freshTypeParameter
			mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper)
			freshTypeParameter.mapper = mapper
		}
		if type_.objectFlags & ObjectFlagsInstantiationExpressionType {
			(result /* as */ /* TODO(TypeReference): InstantiationExpressionType */).node = (type_ /* as */ /* TODO(TypeReference): InstantiationExpressionType */).node
		}
		if type_.objectFlags & ObjectFlagsSingleSignatureType {
			(result /* as */ /* TODO(TypeReference): SingleSignatureType */).outerTypeParameters = (type_ /* as */ /* TODO(TypeReference): SingleSignatureType */).outerTypeParameters
		}
		result.target = type_
		result.mapper = mapper
		result.aliasSymbol = aliasSymbol || type_.aliasSymbol
		result.aliasTypeArguments = /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
		result.objectFlags |= /* TODO(ConditionalExpression): result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0 */ TODO
		return result
	}
	getConditionalTypeInstantiation := func(type_ ConditionalType, mapper TypeMapper, forConstraint bool, aliasSymbol Symbol, aliasTypeArguments []Type) Type {
		root := type_.root
		if root.outerTypeParameters {
			typeArguments := map_(root.outerTypeParameters, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getMappedType */
				/* TODO(Identifier): t */
				/* TODO(Identifier): mapper */
			})
			id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (forConstraint ? "C" : "") + getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments) */ TODO
			result := /* TODO(NonNullExpression): root.instantiations! */ TODO.get(id)
			if !result {
				newMapper := createTypeMapper(root.outerTypeParameters, typeArguments)
				checkType := root.checkType
				distributionType := /* TODO(ConditionalExpression): root.isDistributive ? getReducedType(getMappedType(checkType, newMapper)) : undefined */ TODO
				result = /* TODO(ConditionalExpression): distributionType && checkType !== distributionType && distributionType.flags & (TypeFlags.Union | TypeFlags.Never) ?                     mapTypeWithAlias(distributionType, t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper), forConstraint), aliasSymbol, aliasTypeArguments) :                     getConditionalType(root, newMapper, forConstraint, aliasSymbol, aliasTypeArguments) */ TODO
				/* TODO(NonNullExpression): root.instantiations! */ TODO.set(id, result)
			}
			return result
		}
		return type_
	}
	// OVERLOAD: instantiateType := func(type_ Type, mapper *TypeMapper) Type
	// OVERLOAD: instantiateType := func(type_ *Type, mapper *TypeMapper) *Type
	instantiateType := func(type_ *Type, mapper *TypeMapper) *Type {
		return /* TODO(ConditionalExpression): type && mapper ? instantiateTypeWithAlias(type, mapper, /*aliasSymbol* / undefined, /*aliasTypeArguments* / undefined) : type */ TODO
	}
	instantiateTypeWithAlias := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		if !couldContainTypeVariables(type_) {
			return type_
		}
		if instantiationDepth == 100 || instantiationCount >= 5000000 {
			tracing.instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit" /* TODO(ObjectLiteralExpression): { typeId: type.id, instantiationDepth, instantiationCount } */, TODO)
			error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite)
			return errorType
		}
		totalInstantiationCount++
		instantiationCount++
		instantiationDepth++
		result := instantiateTypeWorker(type_, mapper, aliasSymbol, aliasTypeArguments)
		instantiationDepth--
		return result
	}
	instantiateTypeWorker := func(type_ Type, mapper TypeMapper, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) Type {
		flags := type_.flags
		if flags & TypeFlagsTypeParameter {
			return getMappedType(type_, mapper)
		}
		if flags & TypeFlagsObject {
			objectFlags := (type_ /* as */ /* TODO(TypeReference): ObjectType */).objectFlags
			if objectFlags & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped) {
				if objectFlags&ObjectFlagsReference && !(type_ /* as */ /* TODO(TypeReference): TypeReference */).node {
					resolvedTypeArguments := (type_ /* as */ /* TODO(TypeReference): TypeReference */).resolvedTypeArguments
					newTypeArguments := instantiateTypes(resolvedTypeArguments, mapper)
					return /* TODO(ConditionalExpression): newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference((type as TypeReference).target, newTypeArguments) : type */ TODO
				}
				if objectFlags & ObjectFlagsReverseMapped {
					return instantiateReverseMappedType(type_ /* as */ /* TODO(TypeReference): ReverseMappedType */, mapper)
				}
				return getObjectTypeInstantiation(type_ /* as */ /* TODO(UnionType): TypeReference | AnonymousType | MappedType */, mapper, aliasSymbol, aliasTypeArguments)
			}
			return type_
		}
		if flags & TypeFlagsUnionOrIntersection {
			origin := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).origin : undefined */ TODO
			types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.UnionOrIntersection ? (origin as UnionOrIntersectionType).types : (type as UnionOrIntersectionType).types */ TODO
			newTypes := instantiateTypes(types, mapper)
			if newTypes == types && aliasSymbol == type_.aliasSymbol {
				return type_
			}
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			return /* TODO(ConditionalExpression): flags & TypeFlags.Intersection || origin && origin.flags & TypeFlags.Intersection ?                 getIntersectionType(newTypes, IntersectionFlags.None, newAliasSymbol, newAliasTypeArguments) :                 getUnionType(newTypes, UnionReduction.Literal, newAliasSymbol, newAliasTypeArguments) */ TODO
		}
		if flags & TypeFlagsIndex {
			return getIndexType(instantiateType((type_ /* as */ /* TODO(TypeReference): IndexType */).type_, mapper))
		}
		if flags & TypeFlagsTemplateLiteral {
			return getTemplateLiteralType((type_ /* as */ /* TODO(TypeReference): TemplateLiteralType */).texts, instantiateTypes((type_ /* as */ /* TODO(TypeReference): TemplateLiteralType */).types, mapper))
		}
		if flags & TypeFlagsStringMapping {
			return getStringMappingType((type_ /* as */ /* TODO(TypeReference): StringMappingType */).symbol, instantiateType((type_ /* as */ /* TODO(TypeReference): StringMappingType */).type_, mapper))
		}
		if flags & TypeFlagsIndexedAccess {
			newAliasSymbol := aliasSymbol || type_.aliasSymbol
			newAliasTypeArguments := /* TODO(ConditionalExpression): aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper) */ TODO
			return getIndexedAccessType(instantiateType((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType, mapper), instantiateType((type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType, mapper), (type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).accessFlags, nil, newAliasSymbol, newAliasTypeArguments)
		}
		if flags & TypeFlagsConditional {
			return getConditionalTypeInstantiation(type_ /* as */ /* TODO(TypeReference): ConditionalType */, combineTypeMappers((type_ /* as */ /* TODO(TypeReference): ConditionalType */).mapper, mapper), false, aliasSymbol, aliasTypeArguments)
		}
		if flags & TypeFlagsSubstitution {
			newBaseType := instantiateType((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType, mapper)
			if isNoInferType(type_) {
				return getNoInferType(newBaseType)
			}
			newConstraint := instantiateType((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).constraint, mapper)
			if newBaseType.flags&TypeFlagsTypeVariable && isGenericType(newConstraint) {
				return getSubstitutionType(newBaseType, newConstraint)
			}
			if newConstraint.flags&TypeFlagsAnyOrUnknown || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint)) {
				return newBaseType
			}
			return /* TODO(ConditionalExpression): newBaseType.flags & TypeFlags.TypeVariable ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]) */ TODO
		}
		return type_
	}
	instantiateReverseMappedType := func(type_ ReverseMappedType, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		innerMappedType := instantiateType(type_.mappedType, mapper)
		if !(getObjectFlags(innerMappedType) & ObjectFlagsMapped) {
			return type_
		}
		innerIndexType := instantiateType(type_.constraintType, mapper)
		if !(innerIndexType.flags & TypeFlagsIndex) {
			return type_
		}
		instantiated := inferTypeForHomomorphicMappedType(instantiateType(type_.source, mapper), innerMappedType /* as */ /* TODO(TypeReference): MappedType */, innerIndexType /* as */ /* TODO(TypeReference): IndexType */)
		if instantiated {
			return instantiated
		}
		return type_
	}
	getPermissiveInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Primitive | TypeFlags.AnyOrUnknown | TypeFlags.Never) ? type :             type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper)) */ TODO
	}
	getRestrictiveInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_.flags & (TypeFlagsPrimitive | TypeFlagsAnyOrUnknown | TypeFlagsNever) {
			return type_
		}
		if type_.restrictiveInstantiation {
			return type_.restrictiveInstantiation
		}
		type_.restrictiveInstantiation = instantiateType(type_, restrictiveMapper)
		type_.restrictiveInstantiation.restrictiveInstantiation = type_.restrictiveInstantiation
		return type_.restrictiveInstantiation
	}
	instantiateIndexInfo := func(info IndexInfo, mapper TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
		return createIndexInfo(info.keyType, instantiateType(info.type_, mapper), info.isReadonly, info.declaration)
	}
	isContextSensitive := func(node /* TODO(UnionType): Expression | MethodDeclaration | ObjectLiteralElementLike | JsxAttributeLike | JsxChild */ any) bool {
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.FunctionDeclaration: // Function declarations can have context when annotated with a jsdoc @type                 return isContextSensitiveFunctionLikeDeclaration(node as FunctionExpression | ArrowFunction | MethodDeclaration);             case SyntaxKind.ObjectLiteralExpression:                 return some((node as ObjectLiteralExpression).properties, isContextSensitive);             case SyntaxKind.ArrayLiteralExpression:                 return some((node as ArrayLiteralExpression).elements, isContextSensitive);             case SyntaxKind.ConditionalExpression:                 return isContextSensitive((node as ConditionalExpression).whenTrue) ||                     isContextSensitive((node as ConditionalExpression).whenFalse);             case SyntaxKind.BinaryExpression:                 return ((node as BinaryExpression).operatorToken.kind === SyntaxKind.BarBarToken || (node as BinaryExpression).operatorToken.kind === SyntaxKind.QuestionQuestionToken) &&                     (isContextSensitive((node as BinaryExpression).left) || isContextSensitive((node as BinaryExpression).right));             case SyntaxKind.PropertyAssignment:                 return isContextSensitive((node as PropertyAssignment).initializer);             case SyntaxKind.ParenthesizedExpression:                 return isContextSensitive((node as ParenthesizedExpression).expression);             case SyntaxKind.JsxAttributes:                 return some((node as JsxAttributes).properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive);             case SyntaxKind.JsxAttribute: {                 // If there is no initializer, JSX attribute has a boolean value of true which is not context sensitive.                 const { initializer } = node as JsxAttribute;                 return !!initializer && isContextSensitive(initializer);             }             case SyntaxKind.JsxExpression: {                 // It is possible to that node.expression is undefined (e.g <div x={} />)                 const { expression } = node as JsxExpression;                 return !!expression && isContextSensitive(expression);             }         } */
		return false
	}
	isContextSensitiveFunctionLikeDeclaration := func(node FunctionLikeDeclaration) bool {
		return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node)
	}
	hasContextSensitiveReturnExpression := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean */ TODO {
		if node.typeParameters || getEffectiveReturnTypeNode(node) || !node.body {
			return false
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.body.kind !== SyntaxKind.Block */ TODO {
			return isContextSensitive(node.body)
		}
		return !!forEachReturnStatement(node.body /* as */ /* TODO(TypeReference): Block */, func(statement /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !!statement.expression */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isContextSensitive(statement.expression) */
		})
	}
	isContextSensitiveFunctionOrObjectLiteralMethod := func(func_ Node) /* TODO(TypePredicate): func is FunctionExpression | ArrowFunction | MethodDeclaration */ TODO {
		return (isFunctionExpressionOrArrowFunction(func_) || isObjectLiteralMethod(func_)) && isContextSensitiveFunctionLikeDeclaration(func_)
	}
	getTypeWithoutSignatures := func(type_ Type) Type {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			if resolved.constructSignatures.length || resolved.callSignatures.length {
				result := createObjectType(ObjectFlagsAnonymous, type_.symbol)
				result.members = resolved.members
				result.properties = resolved.properties
				result.callSignatures = emptyArray
				result.constructSignatures = emptyArray
				result.indexInfos = emptyArray
				return result
			}
		} else if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, getTypeWithoutSignatures))
		}
		return type_
	}
	isTypeIdenticalTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, identityRelation)
	}
	compareTypesIdentical := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, identityRelation) ? Ternary.True : Ternary.False */ TODO
	}
	compareTypesAssignable := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, assignableRelation) ? Ternary.True : Ternary.False */ TODO
	}
	compareTypesSubtypeOf := func(source Type, target Type) Ternary {
		return /* TODO(ConditionalExpression): isTypeRelatedTo(source, target, subtypeRelation) ? Ternary.True : Ternary.False */ TODO
	}
	isTypeSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, subtypeRelation)
	}
	isTypeStrictSubtypeOf := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, strictSubtypeRelation)
	}
	isTypeAssignableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, assignableRelation)
	}
	isTypeDerivedFrom := func(source Type, target Type) bool {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? every((source as UnionType).types, t => isTypeDerivedFrom(t, target)) :             target.flags & TypeFlags.Union ? some((target as UnionType).types, t => isTypeDerivedFrom(source, t)) :             source.flags & TypeFlags.Intersection ? some((source as IntersectionType).types, t => isTypeDerivedFrom(t, target)) :             source.flags & TypeFlags.InstantiableNonPrimitive ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) :             isEmptyAnonymousObjectType(target) ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) :             target === globalObjectType ? !!(source.flags & (TypeFlags.Object | TypeFlags.NonPrimitive)) && !isEmptyAnonymousObjectType(source) :             target === globalFunctionType ? !!(source.flags & TypeFlags.Object) && isFunctionObjectType(source as ObjectType) :             hasBaseType(source, getTargetType(target)) || (isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType)) */ TODO
	}
	isTypeComparableTo := func(source Type, target Type) bool {
		return isTypeRelatedTo(source, target, comparableRelation)
	}
	areTypesComparable := func(type1 Type, type2 Type) bool {
		return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1)
	}
	checkTypeAssignableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputObject /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO) bool {
		return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject)
	}
	checkTypeAssignableToAndOptionallyElaborate := func(source Type, target Type, errorNode Node, expr *Expression, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, nil)
	}
	checkTypeRelatedToAndOptionallyElaborate := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, expr *Expression, headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isTypeRelatedTo(source, target, relation) {
			/* TODO(TrueKeyword): true */
		}
		if !errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	isOrHasGenericConditional := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsConditional || (type_.flags&TypeFlagsIntersection && some((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isOrHasGenericConditional)))
	}
	elaborateError := func(node *Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if !node || isOrHasGenericConditional(target) {
			/* TODO(FalseKeyword): false */
		}
		if !checkTypeRelatedTo(source, target, relation, nil) && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
			return true
		}
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AsExpression:                 if (!isConstAssertion(node)) {                     break;                 }                 // fallthrough             case SyntaxKind.JsxExpression:             case SyntaxKind.ParenthesizedExpression:                 return elaborateError((node as AsExpression | ParenthesizedExpression | JsxExpression).expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);             case SyntaxKind.BinaryExpression:                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.CommaToken:                         return elaborateError((node as BinaryExpression).right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);                 }                 break;             case SyntaxKind.ObjectLiteralExpression:                 return elaborateObjectLiteral(node as ObjectLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.ArrayLiteralExpression:                 return elaborateArrayLiteral(node as ArrayLiteralExpression, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.JsxAttributes:                 return elaborateJsxComponents(node as JsxAttributes, source, target, relation, containingMessageChain, errorOutputContainer);             case SyntaxKind.ArrowFunction:                 return elaborateArrowFunction(node as ArrowFunction, source, target, relation, containingMessageChain, errorOutputContainer);         } */
		return false
	}
	elaborateDidYouMeanToCallOrConstruct := func(node Expression, source Type, target Type, relation Map[string, RelationComparisonResult], headMessage *DiagnosticMessage, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		callSignatures := getSignaturesOfType(source, SignatureKindCall)
		constructSignatures := getSignaturesOfType(source, SignatureKindConstruct)
		for _, signatures := range /* TODO(ArrayLiteralExpression): [constructSignatures, callSignatures] */ TODO {
			if some(signatures, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
				returnType := getReturnTypeOfSignature(s)
				return !(returnType.flags & (TypeFlagsAny | TypeFlagsNever)) && checkTypeRelatedTo(returnType, target, relation, nil)
			}) {
				var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
				checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj)
				diagnostic := /* TODO(ElementAccessExpression): resultObj.errors![resultObj.errors!.length - 1] */ TODO
				addRelatedInfo(diagnostic, createDiagnosticForNode(node /* TODO(ConditionalExpression): signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression */, TODO))
				return true
			}
		}
		return false
	}
	elaborateArrowFunction := func(node ArrowFunction, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) bool {
		if isBlock(node.body) {
			return false
		}
		if some(node.parameters, hasType) {
			return false
		}
		sourceSig := getSingleCallSignature(source)
		if !sourceSig {
			return false
		}
		targetSignatures := getSignaturesOfType(target, SignatureKindCall)
		if !length(targetSignatures) {
			return false
		}
		returnExpression := node.body
		sourceReturn := getReturnTypeOfSignature(sourceSig)
		targetReturn := getUnionType(map_(targetSignatures, getReturnTypeOfSignature))
		if !checkTypeRelatedTo(sourceReturn, targetReturn, relation, nil) {
			elaborated := returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, nil, containingMessageChain, errorOutputContainer)
			if elaborated {
				return elaborated
			}
			var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
			checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, nil, containingMessageChain, resultObj)
			if resultObj.errors {
				if target.symbol && length(target.symbol.declarations) {
					addRelatedInfo( /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO, createDiagnosticForNode( /* TODO(ElementAccessExpression): target.symbol.declarations![0] */ TODO, Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature))
				}
				if (getFunctionFlags(node)&FunctionFlagsAsync) == 0 && !getTypeOfPropertyOfType(sourceReturn, "then" /* as */ /* TODO(TypeReference): __String */) && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, nil) {
					addRelatedInfo( /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO, createDiagnosticForNode(node, Diagnostics.Did_you_mean_to_mark_this_function_as_async))
				}
				return true
			}
		}
		return false
	}
	getBestMatchIndexedAccessTypeOrUndefined := func(source Type, target Type, nameType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		idx := getIndexedAccessTypeOrUndefined(target, nameType)
		if idx {
			return idx
		}
		if target.flags & TypeFlagsUnion {
			best := getBestMatchingType(source, target /* as */ /* TODO(TypeReference): UnionType */)
			if best {
				return getIndexedAccessTypeOrUndefined(best, nameType)
			}
		}
	}
	checkExpressionForMutableLocationWithContextualType := func(next Expression, sourcePropType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		pushContextualType(next, sourcePropType, false)
		result := checkExpressionForMutableLocation(next, CheckModeContextual)
		popContextualType()
		return result
	}
	type ElaborationIterator IterableIterator[ /* TODO(TypeLiteral): { errorNode: Node; innerExpression: Expression | undefined; nameType: Type; errorMessage?: DiagnosticMessage | undefined; } */ TODO]
	elaborateElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		reportedError := false
		for _, value := range iterator {
			TODO_IDENTIFIER := value
			targetPropType := getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType)
			if !targetPropType || targetPropType.flags&TypeFlagsIndexedAccess {
			}
			sourcePropType := getIndexedAccessTypeOrUndefined(source, nameType)
			if !sourcePropType {
			}
			propName := getPropertyNameFromIndex(nameType, nil)
			if !checkTypeRelatedTo(sourcePropType, targetPropType, relation, nil) {
				elaborated := next && elaborateError(next, sourcePropType, targetPropType, relation, nil, containingMessageChain, errorOutputContainer)
				reportedError = true
				if !elaborated {
					var resultObj /* TODO(TypeLiteral): { errors?: Diagnostic[]; } */ TODO = errorOutputContainer || /* TODO(ObjectLiteralExpression): {} */ TODO
					specificSource := /* TODO(ConditionalExpression): next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType */ TODO
					if exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType) {
						diag := createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType))
						diagnostics.add(diag)
						resultObj.errors = /* TODO(ArrayLiteralExpression): [diag] */ TODO
					} else {
						targetIsOptional := !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						sourceIsOptional := !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags&SymbolFlagsOptional)
						targetPropType = removeMissingType(targetPropType, targetIsOptional)
						sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional)
						result := checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						if result && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): specificSource !== sourcePropType */ TODO {
							checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj)
						}
					}
					if resultObj.errors {
						reportedDiag := /* TODO(ElementAccessExpression): resultObj.errors[resultObj.errors.length - 1] */ TODO
						propertyName := /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : undefined */ TODO
						targetProp := /* TODO(ConditionalExpression): propertyName !== undefined ? getPropertyOfType(target, propertyName) : undefined */ TODO
						issuedElaboration := false
						if !targetProp {
							indexInfo := getApplicableIndexInfo(target, nameType)
							if indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib {
								issuedElaboration = true
								addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature))
							}
						}
						if !issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations)) {
							targetNode := /* TODO(ConditionalExpression): targetProp && length(targetProp.declarations) ? targetProp.declarations![0] : target.symbol.declarations![0] */ TODO
							if !getSourceFileOfNode(targetNode).hasNoDefaultLib {
								addRelatedInfo(reportedDiag, createDiagnosticForNode(targetNode, Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1 /* TODO(ConditionalExpression): propertyName && !(nameType.flags & TypeFlags.UniqueESSymbol) ? unescapeLeadingUnderscores(propertyName) : typeToString(nameType) */, TODO, typeToString(target)))
							}
						}
					}
				}
			}
		}
		return reportedError
	}
	elaborateIterableOrArrayLikeTargetElementwise := func(iterator ElaborationIterator, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		tupleOrArrayLikeTargetParts := filterType(target, isArrayOrTupleLikeType)
		nonTupleOrArrayLikeTargetParts := filterType(target, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): isArrayOrTupleLikeType(t) */
		})
		iterationType := /* TODO(ConditionalExpression): nonTupleOrArrayLikeTargetParts !== neverType             ? getIterationTypeOfIterable(IterationUse.ForOf, IterationTypeKind.Yield, nonTupleOrArrayLikeTargetParts, /*errorNode* / undefined)             : undefined */ TODO
		reportedError := false
		/* TODO(ForStatement): for (let status = iterator.next(); !status.done; status = iterator.next()) {             const { errorNode: prop, innerExpression: next, nameType, errorMessage } = status.value;             let targetPropType = iterationType;             const targetIndexedPropType = tupleOrArrayLikeTargetParts !== neverType ? getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType) : undefined;             if (targetIndexedPropType && !(targetIndexedPropType.flags & TypeFlags.IndexedAccess)) { // Don't elaborate on indexes on generic variables                 targetPropType = iterationType ? getUnionType([iterationType, targetIndexedPropType]) : targetIndexedPropType;             }             if (!targetPropType) continue;             let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);             if (!sourcePropType) continue;             const propName = getPropertyNameFromIndex(nameType, /*accessNode* / undefined);             if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, /*errorNode* / undefined)) {                 const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, /*headMessage* / undefined, containingMessageChain, errorOutputContainer);                 reportedError = true;                 if (!elaborated) {                     // Issue error on the prop itself, since the prop couldn't elaborate the error                     const resultObj: { errors?: Diagnostic[]; } = errorOutputContainer || {};                     // Use the expression type, if available                     const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;                     if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {                         const diag = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));                         diagnostics.add(diag);                         resultObj.errors = [diag];                     }                     else {                         const targetIsOptional = !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & SymbolFlags.Optional);                         targetPropType = removeMissingType(targetPropType, targetIsOptional);                         sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);                         const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         if (result && specificSource !== sourcePropType) {                             // If for whatever reason the expression type doesn't yield an error, make sure we still issue an error on the sourcePropType                             checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);                         }                     }                 }             }         } */
		return reportedError
	}
	generateJsxAttributes := func(node JsxAttributes) ElaborationIterator {
		if !length(node.properties) {
		}
		for _, prop := range node.properties {
			if isJsxSpreadAttribute(prop) || isHyphenatedJsxName(getTextOfJsxAttributeName(prop.name)) {
			}
			/* TODO(ExpressionStatement): yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: getStringLiteralType(getTextOfJsxAttributeName(prop.name)) }; */
		}
	}
	generateJsxChildren := func(node JsxElement, getInvalidTextDiagnostic func() DiagnosticMessage) ElaborationIterator {
		if !length(node.children) {
		}
		memberOffset := 0
		/* TODO(ForStatement): for (let i = 0; i < node.children.length; i++) {             const child = node.children[i];             const nameType = getNumberLiteralType(i - memberOffset);             const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);             if (elem) {                 yield elem;             }             else {                 memberOffset++;             }         } */
	}
	getElaborationElementForJsxChild := func(child JsxChild, nameType LiteralType, getInvalidTextDiagnostic func() DiagnosticMessage) /* TODO(undefined): { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxExpression; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxText; innerExpression: undefined; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage; } | { errorNode: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; innerExpression: import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSelfClosingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxElement | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxFragment; nameType: import("/home/jabaile/work/TypeScript/src/compiler/types").LiteralType; errorMessage?: undefined; } | undefined */ TODO {
		/* TODO(SwitchStatement): switch (child.kind) {             case SyntaxKind.JsxExpression:                 // child is of the type of the expression                 return { errorNode: child, innerExpression: child.expression, nameType };             case SyntaxKind.JsxText:                 if (child.containsOnlyTriviaWhiteSpaces) {                     break; // Whitespace only jsx text isn't real jsx text                 }                 // child is a string                 return { errorNode: child, innerExpression: undefined, nameType, errorMessage: getInvalidTextDiagnostic() };             case SyntaxKind.JsxElement:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.JsxFragment:                 // child is of type JSX.Element                 return { errorNode: child, innerExpression: child, nameType };             default:                 return Debug.assertNever(child, "Found invalid jsx child");         } */
	}
	elaborateJsxComponents := func(node JsxAttributes, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		result := elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer)
		var invalidTextDiagnostic *DiagnosticMessage
		if isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent) {
			containingElement := node.parent.parent
			childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
			childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
			childrenNameType := getStringLiteralType(childrenPropName)
			childrenTargetType := getIndexedAccessType(target, childrenNameType)
			validChildren := getSemanticJsxChildren(containingElement.children)
			if !length(validChildren) {
				return result
			}
			moreThanOneRealChildren := length(validChildren) > 1
			var arrayLikeTargetParts Type
			var nonArrayLikeTargetParts Type
			iterableType := getGlobalIterableType(false)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterableType !== emptyGenericType */ TODO {
				anyIterable := createIterableType(anyType)
				arrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): isTypeAssignableTo */
					/* TODO(Identifier): t */
					/* TODO(Identifier): anyIterable */
				})
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): isTypeAssignableTo(t, anyIterable) */
				})
			} else {
				arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType)
				nonArrayLikeTargetParts = filterType(childrenTargetType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): isArrayOrTupleLikeType(t) */
				})
			}
			if moreThanOneRealChildren {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): arrayLikeTargetParts !== neverType */ TODO {
					realSource := createTupleType(checkJsxChildren(containingElement, CheckModeNormal))
					children := generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic)
					result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			} else {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonArrayLikeTargetParts !== neverType */ TODO {
					child := /* TODO(ElementAccessExpression): validChildren[0] */ TODO
					elem := getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic)
					if elem {
						result = elaborateElementwise(( /* TODO(FunctionExpression): function* () {                                 yield elem;                             } */ TODO)(), source, target, relation, containingMessageChain, errorOutputContainer) || result
					}
				} else if !isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation) {
					result = true
					diag := error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, typeToString(childrenTargetType))
					if errorOutputContainer && errorOutputContainer.skipLogging {
						(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
					}
				}
			}
		}
		return result
		getInvalidTextualChildDiagnostic := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
			if !invalidTextDiagnostic {
				tagNameText := getTextOfNode(node.parent.tagName)
				childPropName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
				childrenPropName := /* TODO(ConditionalExpression): childPropName === undefined ? "children" : unescapeLeadingUnderscores(childPropName) */ TODO
				childrenTargetType := getIndexedAccessType(target, getStringLiteralType(childrenPropName))
				diagnostic := Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2
				invalidTextDiagnostic = /* TODO(ObjectLiteralExpression): { ...diagnostic, key: "!!ALREADY FORMATTED!!", message: formatMessage(diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType)) } */ TODO
			}
			return invalidTextDiagnostic
		}
	}
	generateLimitedTupleElements := func(node ArrayLiteralExpression, target Type) ElaborationIterator {
		len := length(node.elements)
		if !len {
		}
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             // Skip elements which do not exist in the target - a length error on the tuple overall is likely better than an error on a mismatched index signature             if (isTupleLikeType(target) && !getPropertyOfType(target, ("" + i) as __String)) continue;             const elem = node.elements[i];             if (isOmittedExpression(elem)) continue;             const nameType = getNumberLiteralType(i);             const checkNode = getEffectiveCheckNode(elem);             yield { errorNode: checkNode, innerExpression: checkNode, nameType };         } */
	}
	elaborateArrayLiteral := func(node ArrayLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			/* TODO(FalseKeyword): false */
		}
		if isTupleLikeType(source) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer)
		}
		pushContextualType(node, target, false)
		tupleizedType := checkArrayLiteral(node, CheckModeContextual, true)
		popContextualType()
		if isTupleLikeType(tupleizedType) {
			return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer)
		}
		return false
	}
	generateObjectLiteralElements := func(node ObjectLiteralExpression) ElaborationIterator {
		if !length(node.properties) {
		}
		for _, prop := range node.properties {
			if isSpreadAssignment(prop) {
			}
			type_ := getLiteralTypeFromProperty(getSymbolOfDeclaration(prop), TypeFlagsStringOrNumberLiteralOrUnique)
			if !type_ || (type_.flags & TypeFlagsNever) {
				/* TODO(ContinueStatement): continue; */
			}
			/* TODO(SwitchStatement): switch (prop.kind) {                 case SyntaxKind.SetAccessor:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.ShorthandPropertyAssignment:                     yield { errorNode: prop.name, innerExpression: undefined, nameType: type };                     break;                 case SyntaxKind.PropertyAssignment:                     yield { errorNode: prop.name, innerExpression: prop.initializer, nameType: type, errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : undefined };                     break;                 default:                     Debug.assertNever(prop);             } */
		}
	}
	elaborateObjectLiteral := func(node ObjectLiteralExpression, source Type, target Type, relation Map[string, RelationComparisonResult], containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ any) /* TODO(undefined): boolean */ TODO {
		if target.flags & (TypeFlagsPrimitive | TypeFlagsNever) {
			/* TODO(FalseKeyword): false */
		}
		return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer)
	}
	checkTypeComparableTo := func(source Type, target Type, errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain) bool {
		return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain)
	}
	isSignatureAssignableTo := func(source Signature, target Signature, ignoreReturnTypes bool) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): compareSignaturesRelated(source, target, ignoreReturnTypes ? SignatureCheckMode.IgnoreReturnTypes : SignatureCheckMode.None, /*reportErrors* / false, /*errorReporter* / undefined, /*incompatibleErrorReporter* / undefined, compareTypesAssignable, /*reportUnreliableMarkers* / undefined) !== Ternary.False */ TODO
	}
	type ErrorReporter func(message DiagnosticMessage, args DiagnosticArguments)
	isTopSignature := func(s Signature) /* TODO(undefined): boolean */ TODO {
		if !s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length == 1 && signatureHasRestParameter(s) {
			paramType := getTypeOfParameter( /* TODO(ElementAccessExpression): s.parameters[0] */ TODO)
			restType := /* TODO(ConditionalExpression): isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType */ TODO
			return !!(restType.flags&(TypeFlagsAny|TypeFlagsNever) && getReturnTypeOfSignature(s).flags&TypeFlagsAnyOrUnknown)
		}
		return false
	}
	compareSignaturesRelated := func(source Signature, target Signature, checkMode SignatureCheckMode, reportErrors bool, errorReporter *ErrorReporter, incompatibleErrorReporter /* TODO(ParenthesizedType): ((source: Type, target: Type) => void) */ any, compareTypes TypeComparer, reportUnreliableMarkers *TypeMapper) Ternary {
		if source == target {
			return TernaryTrue
		}
		if !(checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source)) && isTopSignature(target) {
			return TernaryTrue
		}
		if checkMode&SignatureCheckModeStrictTopSignature && isTopSignature(source) && !isTopSignature(target) {
			return TernaryFalse
		}
		targetCount := getParameterCount(target)
		sourceHasMoreParameters := !hasEffectiveRestParameter(target) && ( /* TODO(ConditionalExpression): checkMode & SignatureCheckMode.StrictArity ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount */ TODO)
		if sourceHasMoreParameters {
			if reportErrors && !(checkMode & SignatureCheckModeStrictArity) {
				/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1, getMinArgumentCount(source), targetCount)
			}
			return TernaryFalse
		}
		if source.typeParameters && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.typeParameters !== target.typeParameters */ TODO {
			target = getCanonicalSignature(target)
			source = instantiateSignatureInContextOf(source, target, nil, compareTypes)
		}
		sourceCount := getParameterCount(source)
		sourceRestType := getNonArrayRestType(source)
		targetRestType := getNonArrayRestType(target)
		if sourceRestType || targetRestType {
			/* TODO(ExpressionStatement): void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers); */
		}
		kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
		strictVariance := !(checkMode & SignatureCheckModeCallback) && strictFunctionTypes && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== SyntaxKind.MethodDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== SyntaxKind.MethodSignature */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== SyntaxKind.Constructor */ TODO
		result := TernaryTrue
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceThisType !== voidType */ TODO {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				related := !strictVariance && compareTypes(sourceThisType, targetThisType, false) || compareTypes(targetThisType, sourceThisType, reportErrors)
				if !related {
					if reportErrors {
						/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.The_this_types_of_each_signature_are_incompatible)
					}
					return TernaryFalse
				}
				result &= related
			}
		}
		paramCount := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount) */ TODO
		restIndex := /* TODO(ConditionalExpression): sourceRestType || targetRestType ? paramCount - 1 : -1 */ TODO
		/* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             const sourceType = i === restIndex ? getRestOrAnyTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);             const targetType = i === restIndex ? getRestOrAnyTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);             if (sourceType && targetType && (sourceType !== targetType || checkMode & SignatureCheckMode.StrictArity)) {                 // In order to ensure that any generic type Foo<T> is at least co-variant with respect to T no matter                 // how Foo uses T, we need to relate parameters bi-variantly (given that parameters are input positions,                 // they naturally relate only contra-variantly). However, if the source and target parameters both have                 // function types with a single call signature, we know we are relating two callback parameters. In                 // that case it is sufficient to only relate the parameters of the signatures co-variantly because,                 // similar to return values, callback parameters are output positions. This means that a Promise<T>,                 // where T is used only in callback parameter positions, will be co-variant (as opposed to bi-variant)                 // with respect to T.                 const sourceSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(source, i) ? undefined : getSingleCallSignature(getNonNullableType(sourceType));                 const targetSig = checkMode & SignatureCheckMode.Callback || isInstantiatedGenericParameter(target, i) ? undefined : getSingleCallSignature(getNonNullableType(targetType));                 const callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) &&                     getTypeFacts(sourceType, TypeFacts.IsUndefinedOrNull) === getTypeFacts(targetType, TypeFacts.IsUndefinedOrNull);                 let related = callbacks ?                     compareSignaturesRelated(targetSig, sourceSig, (checkMode & SignatureCheckMode.StrictArity) | (strictVariance ? SignatureCheckMode.StrictCallback : SignatureCheckMode.BivariantCallback), reportErrors, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) :                     !(checkMode & SignatureCheckMode.Callback) && !strictVariance && compareTypes(sourceType, targetType, /*reportErrors* / false) || compareTypes(targetType, sourceType, reportErrors);                 // With strict arity, (x: number | undefined) => void is a subtype of (x?: number | undefined) => void                 if (related && checkMode & SignatureCheckMode.StrictArity && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, /*reportErrors* / false)) {                     related = Ternary.False;                 }                 if (!related) {                     if (reportErrors) {                         errorReporter!(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));                     }                     return Ternary.False;                 }                 result &= related;             }         } */
		if !(checkMode & SignatureCheckModeIgnoreReturnTypes) {
			targetReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(target) ? anyType                 : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol))                 : getReturnTypeOfSignature(target) */ TODO
			if targetReturnType == voidType || targetReturnType == anyType {
				return result
			}
			sourceReturnType := /* TODO(ConditionalExpression): isResolvingReturnTypeOfSignature(source) ? anyType                 : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol))                 : getReturnTypeOfSignature(source) */ TODO
			targetTypePredicate := getTypePredicateOfSignature(target)
			if targetTypePredicate {
				sourceTypePredicate := getTypePredicateOfSignature(source)
				if sourceTypePredicate {
					result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors, errorReporter, compareTypes)
				} else if isIdentifierTypePredicate(targetTypePredicate) || isThisTypePredicate(targetTypePredicate) {
					if reportErrors {
						/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source))
					}
					return TernaryFalse
				}
			} else {
				result &= checkMode&SignatureCheckModeBivariantCallback && compareTypes(targetReturnType, sourceReturnType, false) || compareTypes(sourceReturnType, targetReturnType, reportErrors)
				if !result && reportErrors && incompatibleErrorReporter {
					incompatibleErrorReporter(sourceReturnType, targetReturnType)
				}
			}
		}
		return result
	}
	compareTypePredicateRelatedTo := func(source TypePredicate, target TypePredicate, reportErrors bool, errorReporter *ErrorReporter, compareTypes func(s Type, t Type, reportErrors bool) Ternary) Ternary {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.kind !== target.kind */ TODO {
			if reportErrors {
				/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard)
				/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
			}
			return TernaryFalse
		}
		if source.kind == TypePredicateKindIdentifier || source.kind == TypePredicateKindAssertsIdentifier {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.parameterIndex !== (target as IdentifierTypePredicate).parameterIndex */ TODO {
				if reportErrors {
					/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, (target /* as */ /* TODO(TypeReference): IdentifierTypePredicate */).parameterName)
					/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
				}
				return TernaryFalse
			}
		}
		related := /* TODO(ConditionalExpression): source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type, reportErrors) :             Ternary.False */ TODO
		if related == TernaryFalse && reportErrors {
			/* TODO(NonNullExpression): errorReporter! */ TODO(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target))
		}
		return related
	}
	isImplementationCompatibleWithOverload := func(implementation Signature, overload Signature) bool {
		erasedSource := getErasedSignature(implementation)
		erasedTarget := getErasedSignature(overload)
		sourceReturnType := getReturnTypeOfSignature(erasedSource)
		targetReturnType := getReturnTypeOfSignature(erasedTarget)
		if targetReturnType == voidType || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation) || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation) {
			return isSignatureAssignableTo(erasedSource, erasedTarget, true)
		}
		return false
	}
	isEmptyResolvedType := func(t ResolvedType) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): t !== anyFunctionType */ TODO && t.properties.length == 0 && t.callSignatures.length == 0 && t.constructSignatures.length == 0 && t.indexInfos.length == 0
	}
	isEmptyObjectType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Object ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type as ObjectType)) :             type.flags & TypeFlags.NonPrimitive ? true :             type.flags & TypeFlags.Union ? some((type as UnionType).types, isEmptyObjectType) :             type.flags & TypeFlags.Intersection ? every((type as UnionType).types, isEmptyObjectType) :             false */ TODO
	}
	isEmptyAnonymousObjectType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(getObjectFlags(type_)&ObjectFlagsAnonymous && ((type_ /* as */ /* TODO(TypeReference): ResolvedType */).members && isEmptyResolvedType(type_ /* as */ /* TODO(TypeReference): ResolvedType */) || type_.symbol && type_.symbol.flags&SymbolFlagsTypeLiteral && getMembersOfSymbol(type_.symbol).size == 0))
	}
	isUnknownLikeUnionType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		if strictNullChecks && type_.flags&TypeFlagsUnion {
			if !((type_ /* as */ /* TODO(TypeReference): UnionType */).objectFlags & ObjectFlagsIsUnknownLikeUnionComputed) {
				types := (type_ /* as */ /* TODO(TypeReference): UnionType */).types
				(type_ /* as */ /* TODO(TypeReference): UnionType */).objectFlags |= ObjectFlagsIsUnknownLikeUnionComputed | ( /* TODO(ConditionalExpression): types.length >= 3 && types[0].flags & TypeFlags.Undefined &&                         types[1].flags & TypeFlags.Null && some(types, isEmptyAnonymousObjectType) ? ObjectFlags.IsUnknownLikeUnion : 0 */ TODO)
			}
			return !!((type_ /* as */ /* TODO(TypeReference): UnionType */).objectFlags & ObjectFlagsIsUnknownLikeUnion)
		}
		return false
	}
	containsUndefinedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(( /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO).flags & TypeFlagsUndefined)
	}
	containsNonMissingUndefinedType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		candidate := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types[0] : type */ TODO
		return !!(candidate.flags & TypeFlagsUndefined) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): candidate !== missingType */ TODO
	}
	isStringIndexSignatureOnlyType := func(type_ Type) bool {
		return type_.flags&TypeFlagsObject && !isGenericMappedType(type_) && getPropertiesOfType(type_).length == 0 && getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, stringType) || type_.flags&TypeFlagsUnionOrIntersection && every((type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, isStringIndexSignatureOnlyType) || false
	}
	isEnumTypeRelatedTo := func(source Symbol, target Symbol, errorReporter ErrorReporter) /* TODO(undefined): boolean */ TODO {
		sourceSymbol := /* TODO(ConditionalExpression): source.flags & SymbolFlags.EnumMember ? getParentOfSymbol(source)! : source */ TODO
		targetSymbol := /* TODO(ConditionalExpression): target.flags & SymbolFlags.EnumMember ? getParentOfSymbol(target)! : target */ TODO
		if sourceSymbol == targetSymbol {
			return true
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSymbol.escapedName !== targetSymbol.escapedName */ TODO || !(sourceSymbol.flags & SymbolFlagsRegularEnum) || !(targetSymbol.flags & SymbolFlagsRegularEnum) {
			return false
		}
		id := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol) */ TODO
		entry := enumRelation.get(id)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): entry !== undefined */ TODO && !(entry&RelationComparisonResultFailed && errorReporter) {
			return !!(entry & RelationComparisonResultSucceeded)
		}
		targetEnumType := getTypeOfSymbol(targetSymbol)
		for _, sourceProperty := range getPropertiesOfType(getTypeOfSymbol(sourceSymbol)) {
			if sourceProperty.flags & SymbolFlagsEnumMember {
				targetProperty := getPropertyOfType(targetEnumType, sourceProperty.escapedName)
				if !targetProperty || !(targetProperty.flags & SymbolFlagsEnumMember) {
					if errorReporter {
						errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(sourceProperty), typeToString(getDeclaredTypeOfSymbol(targetSymbol), nil, TypeFormatFlagsUseFullyQualifiedType))
					}
					enumRelation.set(id, RelationComparisonResultFailed)
					return false
				}
				sourceValue := getEnumMemberValue( /* TODO(NonNullExpression): getDeclarationOfKind(sourceProperty, SyntaxKind.EnumMember)! */ TODO).value
				targetValue := getEnumMemberValue( /* TODO(NonNullExpression): getDeclarationOfKind(targetProperty, SyntaxKind.EnumMember)! */ TODO).value
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceValue !== targetValue */ TODO {
					sourceIsString := /* TODO(TypeOfExpression): typeof sourceValue */ TODO == "string"
					targetIsString := /* TODO(TypeOfExpression): typeof targetValue */ TODO == "string"
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceValue !== undefined */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetValue !== undefined */ TODO {
						if errorReporter {
							escapedSource := /* TODO(ConditionalExpression): sourceIsString ? `"${escapeString(sourceValue)}"` : sourceValue */ TODO
							escapedTarget := /* TODO(ConditionalExpression): targetIsString ? `"${escapeString(targetValue)}"` : targetValue */ TODO
							errorReporter(Diagnostics.Each_declaration_of_0_1_differs_in_its_value_where_2_was_expected_but_3_was_given, symbolName(targetSymbol), symbolName(targetProperty), escapedTarget, escapedSource)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
					if sourceIsString || targetIsString {
						if errorReporter {
							knownStringValue := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): sourceValue ?? targetValue */ TODO
							Debug.assert( /* TODO(TypeOfExpression): typeof knownStringValue */ TODO == "string")
							escapedValue := /* TODO(TemplateExpression): `"${escapeString(knownStringValue)}"` */ TODO
							errorReporter(Diagnostics.One_value_of_0_1_is_the_string_2_and_the_other_is_assumed_to_be_an_unknown_numeric_value, symbolName(targetSymbol), symbolName(targetProperty), escapedValue)
						}
						enumRelation.set(id, RelationComparisonResultFailed)
						return false
					}
				}
			}
		}
		enumRelation.set(id, RelationComparisonResultSucceeded)
		return true
	}
	isSimpleTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorReporter ErrorReporter) /* TODO(undefined): boolean */ TODO {
		s := source.flags
		t := target.flags
		if t&TypeFlagsAny || s&TypeFlagsNever || source == wildcardType {
			/* TODO(TrueKeyword): true */
		}
		if t&TypeFlagsUnknown && !(relation == strictSubtypeRelation && s&TypeFlagsAny) {
			/* TODO(TrueKeyword): true */
		}
		if t & TypeFlagsNever {
			/* TODO(FalseKeyword): false */
		}
		if s&TypeFlagsStringLike && t&TypeFlagsString {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsStringLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsStringLiteral && !(t & TypeFlagsEnumLiteral) && (source /* as */ /* TODO(TypeReference): StringLiteralType */).value == (target /* as */ /* TODO(TypeReference): StringLiteralType */).value {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsNumberLike && t&TypeFlagsNumber {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsNumberLiteral && s&TypeFlagsEnumLiteral && t&TypeFlagsNumberLiteral && !(t & TypeFlagsEnumLiteral) && (source /* as */ /* TODO(TypeReference): NumberLiteralType */).value == (target /* as */ /* TODO(TypeReference): NumberLiteralType */).value {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsBigIntLike && t&TypeFlagsBigInt {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsBooleanLike && t&TypeFlagsBoolean {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsESSymbolLike && t&TypeFlagsESSymbol {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsEnum && t&TypeFlagsEnum && source.symbol.escapedName == target.symbol.escapedName && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsEnumLiteral && t&TypeFlagsEnumLiteral {
			if s&TypeFlagsUnion && t&TypeFlagsUnion && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				/* TODO(TrueKeyword): true */
			}
			if s&TypeFlagsLiteral && t&TypeFlagsLiteral && (source /* as */ /* TODO(TypeReference): LiteralType */).value == (target /* as */ /* TODO(TypeReference): LiteralType */).value && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter) {
				/* TODO(TrueKeyword): true */
			}
		}
		if s&TypeFlagsUndefined && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&(TypeFlagsUndefined|TypeFlagsVoid)) {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsNull && (!strictNullChecks && !(t&TypeFlagsUnionOrIntersection) || t&TypeFlagsNull) {
			/* TODO(TrueKeyword): true */
		}
		if s&TypeFlagsObject && t&TypeFlagsNonPrimitive && !(relation == strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & ObjectFlagsFreshLiteral)) {
			/* TODO(TrueKeyword): true */
		}
		if relation == assignableRelation || relation == comparableRelation {
			if s & TypeFlagsAny {
				/* TODO(TrueKeyword): true */
			}
			if s&TypeFlagsNumber && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral) {
				/* TODO(TrueKeyword): true */
			}
			if s&TypeFlagsNumberLiteral && !(s & TypeFlagsEnumLiteral) && (t&TypeFlagsEnum || t&TypeFlagsNumberLiteral && t&TypeFlagsEnumLiteral && (source /* as */ /* TODO(TypeReference): NumberLiteralType */).value == (target /* as */ /* TODO(TypeReference): NumberLiteralType */).value) {
				/* TODO(TrueKeyword): true */
			}
			if isUnknownLikeUnionType(target) {
				/* TODO(TrueKeyword): true */
			}
		}
		return false
	}
	isTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult]) /* TODO(undefined): boolean */ TODO {
		if isFreshLiteralType(source) {
			source = (source /* as */ /* TODO(TypeReference): FreshableType */).regularType
		}
		if isFreshLiteralType(target) {
			target = (target /* as */ /* TODO(TypeReference): FreshableType */).regularType
		}
		if source == target {
			return true
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation) {
				return true
			}
		} else if !((source.flags | target.flags) & (TypeFlagsUnionOrIntersection | TypeFlagsIndexedAccess | TypeFlagsConditional | TypeFlagsSubstitution)) {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.flags !== target.flags */ TODO {
				/* TODO(FalseKeyword): false */
			}
			if source.flags & TypeFlagsSingleton {
				/* TODO(TrueKeyword): true */
			}
		}
		if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
			related := relation.get(getRelationKey(source, target, IntersectionStateNone, relation, false))
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): related !== undefined */ TODO {
				return !!(related & RelationComparisonResultSucceeded)
			}
		}
		if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
			return checkTypeRelatedTo(source, target, relation, nil)
		}
		return false
	}
	isIgnoredJsxProperty := func(source Type, sourceProp Symbol) /* TODO(undefined): boolean | 0 */ TODO {
		return getObjectFlags(source)&ObjectFlagsJsxAttributes && isHyphenatedJsxName(sourceProp.escapedName)
	}
	getNormalizedType := func(type_ Type, writing bool) Type {
		/* TODO(WhileStatement): while (true) {             const t = isFreshLiteralType(type) ? (type as FreshableType).regularType :                 isGenericTupleType(type) ? getNormalizedTupleType(type, writing) :                 getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).node ? createTypeReference((type as TypeReference).target, getTypeArguments(type as TypeReference)) : getSingleBaseForNonAugmentingSubtype(type) || type :                 type.flags & TypeFlags.UnionOrIntersection ? getNormalizedUnionOrIntersectionType(type as UnionOrIntersectionType, writing) :                 type.flags & TypeFlags.Substitution ? writing ? (type as SubstitutionType).baseType : getSubstitutionIntersection(type as SubstitutionType) :                 type.flags & TypeFlags.Simplifiable ? getSimplifiedType(type, writing) :                 type;             if (t === type) return t;             type = t;         } */
	}
	getNormalizedUnionOrIntersectionType := func(type_ UnionOrIntersectionType, writing bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reduced := getReducedType(type_)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): reduced !== type */ TODO {
			return reduced
		}
		if type_.flags&TypeFlagsIntersection && shouldNormalizeIntersection(type_ /* as */ /* TODO(TypeReference): IntersectionType */) {
			normalizedTypes := sameMap(type_.types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getNormalizedType */
				/* TODO(Identifier): t */
				/* TODO(Identifier): writing */
			})
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): normalizedTypes !== type.types */ TODO {
				return getIntersectionType(normalizedTypes)
			}
		}
		return type_
	}
	shouldNormalizeIntersection := func(type_ IntersectionType) /* TODO(undefined): boolean */ TODO {
		hasInstantiable := false
		hasNullableOrEmpty := false
		for _, t := range type_.types {
			/* TODO(ExpressionStatement): hasInstantiable ||= !!(t.flags & TypeFlags.Instantiable); */
			/* TODO(ExpressionStatement): hasNullableOrEmpty ||= !!(t.flags & TypeFlags.Nullable) || isEmptyAnonymousObjectType(t); */
			if hasInstantiable && hasNullableOrEmpty {
				/* TODO(TrueKeyword): true */
			}
		}
		return false
	}
	getNormalizedTupleType := func(type_ TupleTypeReference, writing bool) Type {
		elements := getElementTypes(type_)
		normalizedElements := sameMap(elements, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(BinaryExpression): t.flags & TypeFlags.Simplifiable */
			/* TODO(QuestionToken): ? */
			/* TODO(CallExpression): getSimplifiedType(t, writing) */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): t */
		})
		return /* TODO(ConditionalExpression): elements !== normalizedElements ? createNormalizedTupleType(type.target, normalizedElements) : type */ TODO
	}
	checkTypeRelatedTo := func(source Type, target Type, relation Map[string, RelationComparisonResult], errorNode Node, headMessage DiagnosticMessage, containingMessageChain func() *DiagnosticMessageChain, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO) bool {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo /* TODO(TupleType): [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] */ any
		var maybeKeys []string
		var maybeKeysSet Set[string]
		var sourceStack []Type
		var targetStack []Type
		maybeCount := 0
		sourceDepth := 0
		targetDepth := 0
		expandingFlags := ExpandingFlagsNone
		overflow := false
		overrideNextErrorInfo := 0
		skipParentCounter := 0
		var lastSkippedInfo /* TODO(TupleType): [Type, Type] */ any
		var incompatibleStack /* TODO(ArrayType): DiagnosticAndArguments[] */ any
		relationCount := /* TODO(GreaterThanGreaterThanToken): >> */ /* TODO(BinaryExpression): (16_000_000 - relation.size) >> 3 */ TODO
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO || !errorNode, "no error reporting in identity checking")
		result := isRelatedTo(source, target, RecursionFlagsBoth, !!errorNode, headMessage)
		if incompatibleStack {
			reportIncompatibleStack()
		}
		if overflow {
			id := getRelationKey(source, target, IntersectionStateNone, relation, false)
			relation.set(id, RelationComparisonResultFailed|( /* TODO(ConditionalExpression): relationCount <= 0 ? RelationComparisonResult.ComplexityOverflow : RelationComparisonResult.StackDepthOverflow */ TODO))
			tracing.instant(tracing.Phase.CheckTypes, "checkTypeRelatedTo_DepthLimit" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, depth: sourceDepth, targetDepth } */, TODO)
			message := /* TODO(ConditionalExpression): relationCount <= 0 ?                 Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                 Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
			diag := error(errorNode || currentNode, message, typeToString(source), typeToString(target))
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
		} else if errorInfo {
			if containingMessageChain {
				chain := containingMessageChain()
				if chain {
					concatenateDiagnosticMessageChains(chain, errorInfo)
					errorInfo = chain
				}
			}
			var relatedInformation /* TODO(ArrayType): DiagnosticRelatedInformation[] */ any
			if headMessage && errorNode && !result && source.symbol {
				links := getSymbolLinks(source.symbol)
				if links.originatingImport && !isImportCall(links.originatingImport) {
					helpfulRetry := checkTypeRelatedTo(getTypeOfSymbol( /* TODO(NonNullExpression): links.target! */ TODO), target, relation, nil)
					if helpfulRetry {
						diag := createDiagnosticForNode(links.originatingImport, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead)
						relatedInformation = append(relatedInformation, diag)
					}
				}
			}
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode( /* TODO(NonNullExpression): errorNode! */ TODO) /* TODO(NonNullExpression): errorNode! */, TODO, errorInfo, relatedInformation)
			if relatedInfo {
				addRelatedInfo(diag /* TODO(SpreadElement): ...relatedInfo */, TODO)
			}
			if errorOutputContainer {
				(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
			}
			if !errorOutputContainer || !errorOutputContainer.skipLogging {
				diagnostics.add(diag)
			}
		}
		if errorNode && errorOutputContainer && errorOutputContainer.skipLogging && result == TernaryFalse {
			Debug.assert(!!errorOutputContainer.errors, "missed opportunity to interact with error.")
		}
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== Ternary.False */ TODO
		resetErrorInfo := func(saved ReturnType[ /* TODO(TypeQuery): typeof captureErrorCalculationState */ TODO]) {
			errorInfo = saved.errorInfo
			lastSkippedInfo = saved.lastSkippedInfo
			incompatibleStack = saved.incompatibleStack
			overrideNextErrorInfo = saved.overrideNextErrorInfo
			skipParentCounter = saved.skipParentCounter
			relatedInfo = saved.relatedInfo
		}
		captureErrorCalculationState := func() /* TODO(undefined): { errorInfo: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined; lastSkippedInfo: [import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").Type] | undefined; incompatibleStack: [message: import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage, ...args: (string | number)[]][] | undefined; overrideNextErrorInfo: number; skipParentCounter: number; relatedInfo: [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined; } */ TODO {
			return /* TODO(ObjectLiteralExpression): {                 errorInfo,                 lastSkippedInfo,                 incompatibleStack: incompatibleStack?.slice(),                 overrideNextErrorInfo,                 skipParentCounter,                 relatedInfo: relatedInfo?.slice() as [DiagnosticRelatedInformation, ...DiagnosticRelatedInformation[]] | undefined,             } */ TODO
		}
		reportIncompatibleError := func(message DiagnosticMessage, args DiagnosticArguments) {
			overrideNextErrorInfo++
			lastSkippedInfo = nil
			( /* TODO(BarBarEqualsToken): ||= */ /* TODO(BinaryExpression): incompatibleStack ||= [] */ TODO).push( /* TODO(ArrayLiteralExpression): [message, ...args] */ TODO)
		}
		reportIncompatibleStack := func() /* TODO(undefined): undefined */ TODO {
			stack := incompatibleStack || /* TODO(ArrayLiteralExpression): [] */ TODO
			incompatibleStack = nil
			info := lastSkippedInfo
			lastSkippedInfo = nil
			if stack.length == 1 {
				reportError( /* TODO(SpreadElement): ...stack[0] */ TODO)
				if info {
					reportRelationError(nil /* TODO(SpreadElement): ...info */, TODO)
				}
				return
			}
			path := ""
			var secondaryRootErrors []DiagnosticAndArguments = /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(WhileStatement): while (stack.length) {                 const [msg, ...args] = stack.pop()!;                 switch (msg.code) {                     case Diagnostics.Types_of_property_0_are_incompatible.code: {                         // Parenthesize a `new` if there is one                         if (path.indexOf("new ") === 0) {                             path = `(${path})`;                         }                         const str = "" + args[0];                         // If leading, just print back the arg (irrespective of if it's a valid identifier)                         if (path.length === 0) {                             path = `${str}`;                         }                         // Otherwise write a dotted name if possible                         else if (isIdentifierText(str, getEmitScriptTarget(compilerOptions))) {                             path = `${path}.${str}`;                         }                         // Failing that, check if the name is already a computed name                         else if (str[0] === "[" && str[str.length - 1] === "]") {                             path = `${path}${str}`;                         }                         // And finally write out a computed name as a last resort                         else {                             path = `${path}[${str}]`;                         }                         break;                     }                     case Diagnostics.Call_signature_return_types_0_and_1_are_incompatible.code:                     case Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code:                     case Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code:                     case Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code: {                         if (path.length === 0) {                             // Don't flatten signature compatability errors at the start of a chain - instead prefer                             // to unify (the with no arguments bit is excessive for printback) and print them back                             let mappedMsg = msg;                             if (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {                                 mappedMsg = Diagnostics.Call_signature_return_types_0_and_1_are_incompatible;                             }                             else if (msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code) {                                 mappedMsg = Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible;                             }                             secondaryRootErrors.unshift([mappedMsg, args[0], args[1]]);                         }                         else {                             const prefix = (msg.code === Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? "new "                                 : "";                             const params = (msg.code === Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code ||                                     msg.code === Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1.code)                                 ? ""                                 : "...";                             path = `${prefix}${path}(${params})`;                         }                         break;                     }                     case Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target.code: {                         secondaryRootErrors.unshift([Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, args[0], args[1]]);                         break;                     }                     case Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target.code: {                         secondaryRootErrors.unshift([Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, args[0], args[1], args[2]]);                         break;                     }                     default:                         return Debug.fail(`Unhandled Diagnostic: ${msg.code}`);                 }             } */
			if path {
				reportError( /* TODO(ConditionalExpression): path[path.length - 1] === ")"                         ? Diagnostics.The_types_returned_by_0_are_incompatible_between_these_types                         : Diagnostics.The_types_of_0_are_incompatible_between_these_types */ TODO, path)
			} else {
				secondaryRootErrors.shift()
			}
			for _, TODO_IDENTIFIER := range secondaryRootErrors {
				originalValue := msg.elidedInCompatabilityPyramid
				msg.elidedInCompatabilityPyramid = false
				reportError(msg /* TODO(SpreadElement): ...args */, TODO)
				msg.elidedInCompatabilityPyramid = originalValue
			}
			if info {
				reportRelationError(nil /* TODO(SpreadElement): ...info */, TODO)
			}
		}
		reportError := func(message DiagnosticMessage, args DiagnosticArguments) {
			Debug.assert(!!errorNode)
			if incompatibleStack {
				/* TODO(CallExpression): reportIncompatibleStack() */
			}
			if message.elidedInCompatabilityPyramid {
			}
			if skipParentCounter == 0 {
				errorInfo = chainDiagnosticMessages(errorInfo, message /* TODO(SpreadElement): ...args */, TODO)
			} else {
				skipParentCounter--
			}
		}
		reportParentSkippedError := func(message DiagnosticMessage, args DiagnosticArguments) {
			reportError(message /* TODO(SpreadElement): ...args */, TODO)
			skipParentCounter++
		}
		associateRelatedInfo := func(info DiagnosticRelatedInformation) {
			Debug.assert(!!errorInfo)
			if !relatedInfo {
				relatedInfo = /* TODO(ArrayLiteralExpression): [info] */ TODO
			} else {
				relatedInfo.push(info)
			}
		}
		reportRelationError := func(message *DiagnosticMessage, source Type, target Type) {
			if incompatibleStack {
				/* TODO(CallExpression): reportIncompatibleStack() */
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(source, target)
			generalizedSource := source
			generalizedSourceType := sourceType
			if isLiteralType(source) && !typeCouldHaveTopLevelSingletonTypes(target) {
				generalizedSource = getBaseTypeOfLiteralType(source)
				Debug.assert(!isTypeAssignableTo(generalizedSource, target), "generalized source shouldn't be assignable")
				generalizedSourceType = getTypeNameForErrorDisplay(generalizedSource)
			}
			targetFlags := /* TODO(ConditionalExpression): target.flags & TypeFlags.IndexedAccess && !(source.flags & TypeFlags.IndexedAccess) ?                 (target as IndexedAccessType).objectType.flags :                 target.flags */ TODO
			if targetFlags&TypeFlagsTypeParameter && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== markerSuperTypeForCheck */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== markerSubTypeForCheck */ TODO {
				constraint := getBaseConstraintOfType(target)
				var needsOriginalSource TODO
				if constraint && (isTypeAssignableTo(generalizedSource, constraint) || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): needsOriginalSource = isTypeAssignableTo(source, constraint) */ TODO)) {
					reportError(Diagnostics._0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2 /* TODO(ConditionalExpression): needsOriginalSource ? sourceType : generalizedSourceType */, TODO, targetType, typeToString(constraint))
				} else {
					errorInfo = nil
					reportError(Diagnostics._0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1, targetType, generalizedSourceType)
				}
			}
			if !message {
				if relation == comparableRelation {
					message = Diagnostics.Type_0_is_not_comparable_to_type_1
				} else if sourceType == targetType {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated
				} else if exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
					message = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
				} else {
					if source.flags&TypeFlagsStringLiteral && target.flags&TypeFlagsUnion {
						suggestedType := getSuggestedTypeForNonexistentStringLiteralType(source /* as */ /* TODO(TypeReference): StringLiteralType */, target /* as */ /* TODO(TypeReference): UnionType */)
						if suggestedType {
							reportError(Diagnostics.Type_0_is_not_assignable_to_type_1_Did_you_mean_2, generalizedSourceType, targetType, typeToString(suggestedType))
							return
						}
					}
					message = Diagnostics.Type_0_is_not_assignable_to_type_1
				}
			} else if message == Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 && exactOptionalPropertyTypes && getExactOptionalUnassignableProperties(source, target).length {
				message = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties
			}
			reportError(message, generalizedSourceType, targetType)
		}
		tryElaborateErrorsForPrimitivesAndObjects := func(source Type, target Type) {
			sourceType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(source.symbol) ? typeToString(source, source.symbol.valueDeclaration) : typeToString(source) */ TODO
			targetType := /* TODO(ConditionalExpression): symbolValueDeclarationIsContextSensitive(target.symbol) ? typeToString(target, target.symbol.valueDeclaration) : typeToString(target) */ TODO
			if (globalStringType == source && stringType == target) || (globalNumberType == source && numberType == target) || (globalBooleanType == source && booleanType == target) || (getGlobalESSymbolType() == source && esSymbolType == target) {
				reportError(Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType)
			}
		}
		tryElaborateArrayLikeErrors := func(source Type, target Type, reportErrors bool) bool {
			if isTupleType(source) {
				if source.target.readonly && isMutableArrayOrTuple(target) {
					if reportErrors {
						reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
					}
					return false
				}
				return isArrayOrTupleType(target)
			}
			if isReadonlyArrayType(source) && isMutableArrayOrTuple(target) {
				if reportErrors {
					reportError(Diagnostics.The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1, typeToString(source), typeToString(target))
				}
				return false
			}
			if isTupleType(target) {
				return isArrayType(source)
			}
			return true
		}
		isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors)
		}
		isRelatedTo := func(originalSource Type, originalTarget Type, recursionFlags RecursionFlags /* = */ /* TODO(PropertyAccessExpression): RecursionFlags.Both */, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, headMessage DiagnosticMessage, intersectionState /* TODO(undefined): IntersectionState */ TODO /* = */ /* TODO(PropertyAccessExpression): IntersectionState.None */) Ternary {
			if originalSource == originalTarget {
				/* TODO(PropertyAccessExpression): Ternary.True */
			}
			if originalSource.flags&TypeFlagsObject && originalTarget.flags&TypeFlagsPrimitive {
				if relation == comparableRelation && !(originalTarget.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(originalTarget, originalSource, relation) || isSimpleTypeRelatedTo(originalSource, originalTarget, relation /* TODO(ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
					return TernaryTrue
				}
				if reportErrors {
					reportErrorResults(originalSource, originalTarget, originalSource, originalTarget, headMessage)
				}
				return TernaryFalse
			}
			source := getNormalizedType(originalSource, false)
			target := getNormalizedType(originalTarget, true)
			if source == target {
				/* TODO(PropertyAccessExpression): Ternary.True */
			}
			if relation == identityRelation {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source.flags !== target.flags */ TODO {
					/* TODO(PropertyAccessExpression): Ternary.False */
				}
				if source.flags & TypeFlagsSingleton {
					/* TODO(PropertyAccessExpression): Ternary.True */
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				return recursiveTypeRelatedTo(source, target, false, IntersectionStateNone, recursionFlags)
			}
			if source.flags&TypeFlagsTypeParameter && getConstraintOfType(source) == target {
				return TernaryTrue
			}
			if source.flags&TypeFlagsDefinitelyNonNullable && target.flags&TypeFlagsUnion {
				types := (target /* as */ /* TODO(TypeReference): UnionType */).types
				candidate := /* TODO(ConditionalExpression): types.length === 2 && types[0].flags & TypeFlags.Nullable ? types[1] :                     types.length === 3 && types[0].flags & TypeFlags.Nullable && types[1].flags & TypeFlags.Nullable ? types[2] :                     undefined */ TODO
				if candidate && !(candidate.flags & TypeFlagsNullable) {
					target = getNormalizedType(candidate, true)
					if source == target {
						/* TODO(PropertyAccessExpression): Ternary.True */
					}
				}
			}
			if relation == comparableRelation && !(target.flags&TypeFlagsNever) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation /* TODO(ConditionalExpression): reportErrors ? reportError : undefined */, TODO) {
				/* TODO(PropertyAccessExpression): Ternary.True */
			}
			if source.flags&TypeFlagsStructuredOrInstantiable || target.flags&TypeFlagsStructuredOrInstantiable {
				isPerformingExcessPropertyChecks := !(intersectionState & IntersectionStateTarget) && (isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral)
				if isPerformingExcessPropertyChecks {
					if hasExcessProperties(source /* as */ /* TODO(TypeReference): FreshObjectLiteralType */, target, reportErrors) {
						if reportErrors {
							reportRelationError(headMessage, source /* TODO(ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */, TODO)
						}
						return TernaryFalse
					}
				}
				isPerformingCommonPropertyChecks := ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== comparableRelation */ TODO || isUnitType(source)) && !(intersectionState & IntersectionStateTarget) && source.flags&(TypeFlagsPrimitive|TypeFlagsObject|TypeFlagsIntersection) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): source !== globalObjectType */ TODO && target.flags&(TypeFlagsObject|TypeFlagsIntersection) && isWeakType(target) && (getPropertiesOfType(source).length > 0 || typeHasCallOrConstructSignatures(source))
				isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
				if isPerformingCommonPropertyChecks && !hasCommonProperties(source, target, isComparingJsxAttributes) {
					if reportErrors {
						sourceString := typeToString( /* TODO(ConditionalExpression): originalSource.aliasSymbol ? originalSource : source */ TODO)
						targetString := typeToString( /* TODO(ConditionalExpression): originalTarget.aliasSymbol ? originalTarget : target */ TODO)
						calls := getSignaturesOfType(source, SignatureKindCall)
						constructs := getSignaturesOfType(source, SignatureKindConstruct)
						if calls.length > 0 && isRelatedTo(getReturnTypeOfSignature( /* TODO(ElementAccessExpression): calls[0] */ TODO), target, RecursionFlagsSource, false) || constructs.length > 0 && isRelatedTo(getReturnTypeOfSignature( /* TODO(ElementAccessExpression): constructs[0] */ TODO), target, RecursionFlagsSource, false) {
							reportError(Diagnostics.Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it, sourceString, targetString)
						} else {
							reportError(Diagnostics.Type_0_has_no_properties_in_common_with_type_1, sourceString, targetString)
						}
					}
					return TernaryFalse
				}
				traceUnionsOrIntersectionsTooLarge(source, target)
				skipCaching := source.flags&TypeFlagsUnion && (source /* as */ /* TODO(TypeReference): UnionType */).types.length < 4 && !(target.flags&TypeFlagsUnion) || target.flags&TypeFlagsUnion && (target /* as */ /* TODO(TypeReference): UnionType */).types.length < 4 && !(source.flags&TypeFlagsStructuredOrInstantiable)
				result := /* TODO(ConditionalExpression): skipCaching ?                     unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) :                     recursiveTypeRelatedTo(source, target, reportErrors, intersectionState, recursionFlags) */ TODO
				if result {
					return result
				}
			}
			if reportErrors {
				reportErrorResults(originalSource, originalTarget, source, target, headMessage)
			}
			return TernaryFalse
		}
		reportErrorResults := func(originalSource Type, originalTarget Type, source Type, target Type, headMessage *DiagnosticMessage) {
			sourceHasBase := !!getSingleBaseForNonAugmentingSubtype(originalSource)
			targetHasBase := !!getSingleBaseForNonAugmentingSubtype(originalTarget)
			source = /* TODO(ConditionalExpression): (originalSource.aliasSymbol || sourceHasBase) ? originalSource : source */ TODO
			target = /* TODO(ConditionalExpression): (originalTarget.aliasSymbol || targetHasBase) ? originalTarget : target */ TODO
			maybeSuppress := overrideNextErrorInfo > 0
			if maybeSuppress {
				overrideNextErrorInfo--
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsObject {
				currentError := errorInfo
				tryElaborateArrayLikeErrors(source, target, true)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorInfo !== currentError */ TODO {
					maybeSuppress = !!errorInfo
				}
			}
			if source.flags&TypeFlagsObject && target.flags&TypeFlagsPrimitive {
				tryElaborateErrorsForPrimitivesAndObjects(source, target)
			} else if source.symbol && source.flags&TypeFlagsObject && globalObjectType == source {
				reportError(Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead)
			} else if getObjectFlags(source)&ObjectFlagsJsxAttributes && target.flags&TypeFlagsIntersection {
				targetTypes := (target /* as */ /* TODO(TypeReference): IntersectionType */).types
				intrinsicAttributes := getJsxType(JsxNames.IntrinsicAttributes, errorNode)
				intrinsicClassAttributes := getJsxType(JsxNames.IntrinsicClassAttributes, errorNode)
				if !isErrorType(intrinsicAttributes) && !isErrorType(intrinsicClassAttributes) && (contains(targetTypes, intrinsicAttributes) || contains(targetTypes, intrinsicClassAttributes)) {
					return
				}
			} else {
				errorInfo = elaborateNeverIntersection(errorInfo, originalTarget)
			}
			if !headMessage && maybeSuppress {
				savedErrorState := captureErrorCalculationState()
				reportRelationError(headMessage, source, target)
				var canonical TODO
				if errorInfo && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorInfo !== savedErrorState.errorInfo */ TODO {
					canonical = /* TODO(ObjectLiteralExpression): { code: errorInfo.code, messageText: errorInfo.messageText } */ TODO
				}
				resetErrorInfo(savedErrorState)
				if canonical && errorInfo {
					errorInfo.canonicalHead = canonical
				}
				lastSkippedInfo = /* TODO(ArrayLiteralExpression): [source, target] */ TODO
				return
			}
			reportRelationError(headMessage, source, target)
			if source.flags&TypeFlagsTypeParameter && /* TODO(ElementAccessExpression): source.symbol?.declarations?.[0] */ TODO && !getConstraintOfType(source /* as */ /* TODO(TypeReference): TypeVariable */) {
				syntheticParam := cloneTypeParameter(source /* as */ /* TODO(TypeReference): TypeParameter */)
				syntheticParam.constraint = instantiateType(target, makeUnaryTypeMapper(source, syntheticParam))
				if hasNonCircularBaseConstraint(syntheticParam) {
					targetConstraintString := typeToString(target /* TODO(ElementAccessExpression): source.symbol.declarations[0] */, TODO)
					associateRelatedInfo(createDiagnosticForNode( /* TODO(ElementAccessExpression): source.symbol.declarations[0] */ TODO, Diagnostics.This_type_parameter_might_need_an_extends_0_constraint, targetConstraintString))
				}
			}
		}
		traceUnionsOrIntersectionsTooLarge := func(source Type, target Type) {
			if !tracing {
				return
			}
			if (source.flags & TypeFlagsUnionOrIntersection) && (target.flags & TypeFlagsUnionOrIntersection) {
				sourceUnionOrIntersection := source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
				targetUnionOrIntersection := target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */
				if sourceUnionOrIntersection.objectFlags & targetUnionOrIntersection.objectFlags & ObjectFlagsPrimitiveUnion {
					return
				}
				sourceSize := sourceUnionOrIntersection.types.length
				targetSize := targetUnionOrIntersection.types.length
				if /* TODO(AsteriskToken): * */ /* TODO(BinaryExpression): sourceSize * targetSize */ TODO > 1e6 {
					tracing.instant(tracing.Phase.CheckTypes, "traceUnionsOrIntersectionsTooLarge_DepthLimit" /* TODO(ObjectLiteralExpression): {                         sourceId: source.id,                         sourceSize,                         targetId: target.id,                         targetSize,                         pos: errorNode?.pos,                         end: errorNode?.end,                     } */, TODO)
				}
			}
		}
		getTypeOfPropertyInTypes := func(types []Type, name __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			appendPropType := func(propTypes /* TODO(ArrayType): Type[] */ any, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
				type_ = getApparentType(type_)
				prop := /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ? getPropertyOfUnionOrIntersectionType(type as UnionOrIntersectionType, name) : getPropertyOfObjectType(type, name) */ TODO
				propType := prop && getTypeOfSymbol(prop) || getApplicableIndexInfoForName(type_, name).type_ || undefinedType
				return append(propTypes, propType)
			}
			return getUnionType(reduceLeft(types, appendPropType, nil) || emptyArray)
		}
		hasExcessProperties := func(source FreshObjectLiteralType, target Type, reportErrors bool) bool {
			if !isExcessPropertyCheckTarget(target) || !noImplicitAny && getObjectFlags(target)&ObjectFlagsJSLiteral {
				return false
			}
			isComparingJsxAttributes := !!(getObjectFlags(source) & ObjectFlagsJsxAttributes)
			if (relation == assignableRelation || relation == comparableRelation) && (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target))) {
				return false
			}
			reducedTarget := target
			var checkTypes /* TODO(ArrayType): Type[] */ any
			if target.flags & TypeFlagsUnion {
				reducedTarget = findMatchingDiscriminantType(source, target /* as */ /* TODO(TypeReference): UnionType */, isRelatedTo) || filterPrimitivesIfContainsNonPrimitive(target /* as */ /* TODO(TypeReference): UnionType */)
				checkTypes = /* TODO(ConditionalExpression): reducedTarget.flags & TypeFlags.Union ? (reducedTarget as UnionType).types : [reducedTarget] */ TODO
			}
			for _, prop := range getPropertiesOfType(source) {
				if shouldCheckAsExcessProperty(prop, source.symbol) && !isIgnoredJsxProperty(source, prop) {
					if !isKnownProperty(reducedTarget, prop.escapedName, isComparingJsxAttributes) {
						if reportErrors {
							errorTarget := filterType(reducedTarget, isExcessPropertyCheckTarget)
							if !errorNode {
								/* TODO(CallExpression): Debug.fail() */
							}
							if isJsxAttributes(errorNode) || isJsxOpeningLikeElement(errorNode) || isJsxOpeningLikeElement(errorNode.parent) {
								if prop.valueDeclaration && isJsxAttribute(prop.valueDeclaration) && getSourceFileOfNode(errorNode) == getSourceFileOfNode(prop.valueDeclaration.name) {
									errorNode = prop.valueDeclaration.name
								}
								propName := symbolToString(prop)
								suggestionSymbol := getSuggestedSymbolForNonexistentJSXAttribute(propName, errorTarget)
								suggestion := /* TODO(ConditionalExpression): suggestionSymbol ? symbolToString(suggestionSymbol) : undefined */ TODO
								if suggestion {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(errorTarget), suggestion)
								} else {
									reportError(Diagnostics.Property_0_does_not_exist_on_type_1, propName, typeToString(errorTarget))
								}
							} else {
								objectLiteralDeclaration := source.symbol.declarations && firstOrUndefined(source.symbol.declarations)
								var suggestion /* TODO(StringKeyword): string */ any
								if prop.valueDeclaration && findAncestor(prop.valueDeclaration, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
									/* TODO(Identifier): d */
									/* TODO(EqualsEqualsEqualsToken): === */
									/* TODO(Identifier): objectLiteralDeclaration */
								}) && getSourceFileOfNode(objectLiteralDeclaration) == getSourceFileOfNode(errorNode) {
									propDeclaration := prop.valueDeclaration /* as */ /* TODO(TypeReference): ObjectLiteralElementLike */
									Debug.assertNode(propDeclaration, isObjectLiteralElementLike)
									name := /* TODO(NonNullExpression): propDeclaration.name! */ TODO
									errorNode = name
									if isIdentifier(name) {
										suggestion = getSuggestionForNonexistentProperty(name, errorTarget)
									}
								}
								if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2, symbolToString(prop), typeToString(errorTarget), suggestion)
								} else {
									reportParentSkippedError(Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(errorTarget))
								}
							}
						}
						return true
					}
					if checkTypes && !isRelatedTo(getTypeOfSymbol(prop), getTypeOfPropertyInTypes(checkTypes, prop.escapedName), RecursionFlagsBoth, reportErrors) {
						if reportErrors {
							reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(prop))
						}
						return true
					}
				}
			}
			return false
		}
		shouldCheckAsExcessProperty := func(prop Symbol, container Symbol) /* TODO(undefined): boolean | undefined */ TODO {
			return prop.valueDeclaration && container.valueDeclaration && prop.valueDeclaration.parent == container.valueDeclaration
		}
		unionOrIntersectionRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			if source.flags & TypeFlagsUnion {
				if target.flags & TypeFlagsUnion {
					sourceOrigin := (source /* as */ /* TODO(TypeReference): UnionType */).origin
					if sourceOrigin && sourceOrigin.flags&TypeFlagsIntersection && target.aliasSymbol && contains((sourceOrigin /* as */ /* TODO(TypeReference): IntersectionType */).types, target) {
						return TernaryTrue
					}
					targetOrigin := (target /* as */ /* TODO(TypeReference): UnionType */).origin
					if targetOrigin && targetOrigin.flags&TypeFlagsUnion && source.aliasSymbol && contains((targetOrigin /* as */ /* TODO(TypeReference): UnionType */).types, source) {
						return TernaryTrue
					}
				}
				return /* TODO(ConditionalExpression): relation === comparableRelation ?                     someTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) :                     eachTypeRelatedToType(source as UnionType, target, reportErrors && !(source.flags & TypeFlags.Primitive), intersectionState) */ TODO
			}
			if target.flags & TypeFlagsUnion {
				return typeRelatedToSomeType(getRegularTypeOfObjectLiteral(source), target /* as */ /* TODO(TypeReference): UnionType */, reportErrors && !(source.flags&TypeFlagsPrimitive) && !(target.flags&TypeFlagsPrimitive), intersectionState)
			}
			if target.flags & TypeFlagsIntersection {
				return typeRelatedToEachType(source, target /* as */ /* TODO(TypeReference): IntersectionType */, reportErrors, IntersectionStateTarget)
			}
			if relation == comparableRelation && target.flags&TypeFlagsPrimitive {
				constraints := sameMap((source /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(BinaryExpression): t.flags & TypeFlags.Instantiable */
					/* TODO(QuestionToken): ? */
					/* TODO(BinaryExpression): getBaseConstraintOfType(t) || unknownType */
					/* TODO(ColonToken): : */
					/* TODO(Identifier): t */
				})
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraints !== (source as IntersectionType).types */ TODO {
					source = getIntersectionType(constraints)
					if source.flags & TypeFlagsNever {
						return TernaryFalse
					}
					if !(source.flags & TypeFlagsIntersection) {
						return isRelatedTo(source, target, RecursionFlagsSource, false) || isRelatedTo(target, source, RecursionFlagsSource, false)
					}
				}
			}
			return someTypeRelatedToType(source /* as */ /* TODO(TypeReference): IntersectionType */, target, false, IntersectionStateSource)
		}
		eachTypeRelatedToSomeType := func(source UnionOrIntersectionType, target UnionOrIntersectionType) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			for _, sourceType := range sourceTypes {
				related := typeRelatedToSomeType(sourceType, target, false, IntersectionStateNone)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToSomeType := func(source Type, target UnionOrIntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetTypes := target.types
			if target.flags & TypeFlagsUnion {
				if containsType(targetTypes, source) {
					return TernaryTrue
				}
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== comparableRelation */ TODO && getObjectFlags(target)&ObjectFlagsPrimitiveUnion && !(source.flags & TypeFlagsEnumLiteral) && (source.flags&(TypeFlagsStringLiteral|TypeFlagsBooleanLiteral|TypeFlagsBigIntLiteral) || (relation == subtypeRelation || relation == strictSubtypeRelation) && source.flags&TypeFlagsNumberLiteral) {
					alternateForm := /* TODO(ConditionalExpression): source === (source as StringLiteralType).regularType ? (source as StringLiteralType).freshType : (source as StringLiteralType).regularType */ TODO
					primitive := /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? stringType :                         source.flags & TypeFlags.NumberLiteral ? numberType :                         source.flags & TypeFlags.BigIntLiteral ? bigintType :                         undefined */ TODO
					return /* TODO(ConditionalExpression): primitive && containsType(targetTypes, primitive) || alternateForm && containsType(targetTypes, alternateForm) ? Ternary.True : Ternary.False */ TODO
				}
				match := getMatchingUnionConstituentForType(target /* as */ /* TODO(TypeReference): UnionType */, source)
				if match {
					related := isRelatedTo(source, match, RecursionFlagsTarget, false, nil, intersectionState)
					if related {
						return related
					}
				}
			}
			for _, type_ := range targetTypes {
				related := isRelatedTo(source, type_, RecursionFlagsTarget, false, nil, intersectionState)
				if related {
					return related
				}
			}
			if reportErrors {
				bestMatchingType := getBestMatchingType(source, target, isRelatedTo)
				if bestMatchingType {
					isRelatedTo(source, bestMatchingType, RecursionFlagsTarget, true, nil, intersectionState)
				}
			}
			return TernaryFalse
		}
		typeRelatedToEachType := func(source Type, target IntersectionType, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			targetTypes := target.types
			for _, targetType := range targetTypes {
				related := isRelatedTo(source, targetType, RecursionFlagsTarget, reportErrors, nil, intersectionState)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		someTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceTypes := source.types
			if source.flags&TypeFlagsUnion && containsType(sourceTypes, target) {
				return TernaryTrue
			}
			len := sourceTypes.length
			/* TODO(ForStatement): for (let i = 0; i < len; i++) {                 const related = isRelatedTo(sourceTypes[i], target, RecursionFlags.Source, reportErrors && i === len - 1, /*headMessage* / undefined, intersectionState);                 if (related) {                     return related;                 }             } */
			return TernaryFalse
		}
		getUndefinedStrippedTargetIfNeeded := func(source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if source.flags&TypeFlagsUnion && target.flags&TypeFlagsUnion && !( /* TODO(ElementAccessExpression): (source as UnionType).types[0] */ TODO.flags & TypeFlagsUndefined) && /* TODO(ElementAccessExpression): (target as UnionType).types[0] */ TODO.flags&TypeFlagsUndefined {
				return extractTypesOfKind(target, ~TypeFlagsUndefined)
			}
			return target
		}
		eachTypeRelatedToType := func(source UnionOrIntersectionType, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			sourceTypes := source.types
			undefinedStrippedTarget := getUndefinedStrippedTargetIfNeeded(source, target /* as */ /* TODO(TypeReference): UnionType */)
			/* TODO(ForStatement): for (let i = 0; i < sourceTypes.length; i++) {                 const sourceType = sourceTypes[i];                 if (undefinedStrippedTarget.flags & TypeFlags.Union && sourceTypes.length >= (undefinedStrippedTarget as UnionType).types.length && sourceTypes.length % (undefinedStrippedTarget as UnionType).types.length === 0) {                     // many unions are mappings of one another; in such cases, simply comparing members at the same index can shortcut the comparison                     // such unions will have identical lengths, and their corresponding elements will match up. Another common scenario is where a large                     // union has a union of objects intersected with it. In such cases, if the input was, eg `("a" | "b" | "c") & (string | boolean | {} | {whatever})`,                     // the result will have the structure `"a" | "b" | "c" | "a" & {} | "b" & {} | "c" & {} | "a" & {whatever} | "b" & {whatever} | "c" & {whatever}`                     // - the resulting union has a length which is a multiple of the original union, and the elements correspond modulo the length of the original union                     const related = isRelatedTo(sourceType, (undefinedStrippedTarget as UnionType).types[i % (undefinedStrippedTarget as UnionType).types.length], RecursionFlags.Both, /*reportErrors* / false, /*headMessage* / undefined, intersectionState);                     if (related) {                         result &= related;                         continue;                     }                 }                 const related = isRelatedTo(sourceType, target, RecursionFlags.Source, reportErrors, /*headMessage* / undefined, intersectionState);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
			return result
		}
		typeArgumentsRelatedTo := func(sources []Type /* = */ /* TODO(Identifier): emptyArray */, targets []Type /* = */ /* TODO(Identifier): emptyArray */, variances []VarianceFlags /* = */ /* TODO(Identifier): emptyArray */, reportErrors bool, intersectionState IntersectionState) Ternary {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sources.length !== targets.length */ TODO && relation == identityRelation {
				return TernaryFalse
			}
			length := /* TODO(ConditionalExpression): sources.length <= targets.length ? sources.length : targets.length */ TODO
			result := TernaryTrue
			/* TODO(ForStatement): for (let i = 0; i < length; i++) {                 // When variance information isn't available we default to covariance. This happens                 // in the process of computing variance information for recursive types and when                 // comparing 'this' type arguments.                 const varianceFlags = i < variances.length ? variances[i] : VarianceFlags.Covariant;                 const variance = varianceFlags & VarianceFlags.VarianceMask;                 // We ignore arguments for independent type parameters (because they're never witnessed).                 if (variance !== VarianceFlags.Independent) {                     const s = sources[i];                     const t = targets[i];                     let related = Ternary.True;                     if (varianceFlags & VarianceFlags.Unmeasurable) {                         // Even an `Unmeasurable` variance works out without a structural check if the source and target are _identical_.                         // We can't simply assume invariance, because `Unmeasurable` marks nonlinear relations, for example, a relation tained by                         // the `-?` modifier in a mapped type (where, no matter how the inputs are related, the outputs still might not be)                         related = relation === identityRelation ? isRelatedTo(s, t, RecursionFlags.Both, /*reportErrors* / false) : compareTypesIdentical(s, t);                     }                     else if (variance === VarianceFlags.Covariant) {                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Contravariant) {                         related = isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                     }                     else if (variance === VarianceFlags.Bivariant) {                         // In the bivariant case we first compare contravariantly without reporting                         // errors. Then, if that doesn't succeed, we compare covariantly with error                         // reporting. Thus, error elaboration will be based on the the covariant check,                         // which is generally easier to reason about.                         related = isRelatedTo(t, s, RecursionFlags.Both, /*reportErrors* / false);                         if (!related) {                             related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     else {                         // In the invariant case we first compare covariantly, and only when that                         // succeeds do we proceed to compare contravariantly. Thus, error elaboration                         // will typically be based on the covariant check.                         related = isRelatedTo(s, t, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (related) {                             related &= isRelatedTo(t, s, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         }                     }                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 }             } */
			return result
		}
		recursiveTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, recursionFlags RecursionFlags) Ternary {
			if overflow {
				return TernaryFalse
			}
			id := getRelationKey(source, target, intersectionState, relation, false)
			entry := relation.get(id)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): entry !== undefined */ TODO {
				if reportErrors && entry&RelationComparisonResultFailed && !(entry & RelationComparisonResultOverflow) {
				} else {
					if outofbandVarianceMarkerHandler {
						saved := entry & RelationComparisonResultReportsMask
						if saved & RelationComparisonResultReportsUnmeasurable {
							instantiateType(source, reportUnmeasurableMapper)
						}
						if saved & RelationComparisonResultReportsUnreliable {
							instantiateType(source, reportUnreliableMapper)
						}
					}
					if reportErrors && entry&RelationComparisonResultOverflow {
						message := /* TODO(ConditionalExpression): entry & RelationComparisonResult.ComplexityOverflow ?                             Diagnostics.Excessive_complexity_comparing_types_0_and_1 :                             Diagnostics.Excessive_stack_depth_comparing_types_0_and_1 */ TODO
						reportError(message, typeToString(source), typeToString(target))
						overrideNextErrorInfo++
					}
					return /* TODO(ConditionalExpression): entry & RelationComparisonResult.Succeeded ? Ternary.True : Ternary.False */ TODO
				}
			}
			if relationCount <= 0 {
				overflow = true
				return TernaryFalse
			}
			if !maybeKeys {
				maybeKeys = /* TODO(ArrayLiteralExpression): [] */ TODO
				maybeKeysSet = /* TODO(NewExpression): new Set() */ TODO
				sourceStack = /* TODO(ArrayLiteralExpression): [] */ TODO
				targetStack = /* TODO(ArrayLiteralExpression): [] */ TODO
			} else {
				if maybeKeysSet.has(id) {
					return TernaryMaybe
				}
				broadestEquivalentId := /* TODO(ConditionalExpression): id.startsWith("*") ? getRelationKey(source, target, intersectionState, relation, /*ignoreConstraints* / true) : undefined */ TODO
				if broadestEquivalentId && maybeKeysSet.has(broadestEquivalentId) {
					return TernaryMaybe
				}
				if sourceDepth == 100 || targetDepth == 100 {
					overflow = true
					return TernaryFalse
				}
			}
			maybeStart := maybeCount
			/* TODO(ElementAccessExpression): maybeKeys[maybeCount] */ TODO = id
			maybeKeysSet.add(id)
			maybeCount++
			saveExpandingFlags := expandingFlags
			if recursionFlags & RecursionFlagsSource {
				/* TODO(ElementAccessExpression): sourceStack[sourceDepth] */ TODO = source
				sourceDepth++
				if !(expandingFlags & ExpandingFlagsSource) && isDeeplyNestedType(source, sourceStack, sourceDepth) {
					/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Source */
				}
			}
			if recursionFlags & RecursionFlagsTarget {
				/* TODO(ElementAccessExpression): targetStack[targetDepth] */ TODO = target
				targetDepth++
				if !(expandingFlags & ExpandingFlagsTarget) && isDeeplyNestedType(target, targetStack, targetDepth) {
					/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Target */
				}
			}
			var originalHandler /* TODO(TypeQuery): typeof outofbandVarianceMarkerHandler */ TODO
			propagatingVarianceFlags := 0 /* as */ /* TODO(TypeReference): RelationComparisonResult */
			if outofbandVarianceMarkerHandler {
				originalHandler = outofbandVarianceMarkerHandler
				outofbandVarianceMarkerHandler = func(onlyUnreliable /* TODO(undefined): boolean */ TODO) {
					propagatingVarianceFlags |= /* TODO(ConditionalExpression): onlyUnreliable ? RelationComparisonResult.ReportsUnreliable : RelationComparisonResult.ReportsUnmeasurable */ TODO
					return /* TODO(NonNullExpression): originalHandler! */ TODO(onlyUnreliable)
				}
			}
			var result Ternary
			if expandingFlags == ExpandingFlagsBoth {
				tracing.instant(tracing.Phase.CheckTypes, "recursiveTypeRelatedTo_DepthLimit" /* TODO(ObjectLiteralExpression): {                     sourceId: source.id,                     sourceIdStack: sourceStack.map(t => t.id),                     targetId: target.id,                     targetIdStack: targetStack.map(t => t.id),                     depth: sourceDepth,                     targetDepth,                 } */, TODO)
				result = TernaryMaybe
			} else {
				tracing.push(tracing.Phase.CheckTypes, "structuredTypeRelatedTo" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id } */, TODO)
				result = structuredTypeRelatedTo(source, target, reportErrors, intersectionState)
				tracing.pop()
			}
			if outofbandVarianceMarkerHandler {
				outofbandVarianceMarkerHandler = originalHandler
			}
			if recursionFlags & RecursionFlagsSource {
				sourceDepth--
			}
			if recursionFlags & RecursionFlagsTarget {
				targetDepth--
			}
			expandingFlags = saveExpandingFlags
			if result {
				if result == TernaryTrue || (sourceDepth == 0 && targetDepth == 0) {
					if result == TernaryTrue || result == TernaryMaybe {
						resetMaybeStack(true)
					} else {
						resetMaybeStack(false)
					}
				}
			} else {
				relation.set(id, RelationComparisonResultFailed|propagatingVarianceFlags)
				relationCount--
				resetMaybeStack(false)
			}
			return result
			resetMaybeStack := func(markAllAsSucceeded bool) {
				/* TODO(ForStatement): for (let i = maybeStart; i < maybeCount; i++) {                     maybeKeysSet.delete(maybeKeys[i]);                     if (markAllAsSucceeded) {                         relation.set(maybeKeys[i], RelationComparisonResult.Succeeded | propagatingVarianceFlags);                         relationCount--;                     }                 } */
				maybeCount = maybeStart
			}
		}
		structuredTypeRelatedTo := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			saveErrorInfo := captureErrorCalculationState()
			result := structuredTypeRelatedToWorker(source, target, reportErrors, intersectionState, saveErrorInfo)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
				if !result && (source.flags&TypeFlagsIntersection || source.flags&TypeFlagsTypeParameter && target.flags&TypeFlagsUnion) {
					constraint := getEffectiveConstraintOfIntersection( /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, !!(target.flags & TypeFlagsUnion))
					if constraint && everyType(constraint, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(Identifier): c */
						/* TODO(ExclamationEqualsEqualsToken): !== */
						/* TODO(Identifier): source */
					}) {
						result = isRelatedTo(constraint, target, RecursionFlagsSource, false, nil, intersectionState)
					}
				}
				if result && !(intersectionState & IntersectionStateTarget) && target.flags&TypeFlagsIntersection && !isGenericObjectType(target) && source.flags&(TypeFlagsObject|TypeFlagsIntersection) {
					result &= propertiesRelatedTo(source, target, reportErrors, nil, false, IntersectionStateNone)
					if result && isObjectLiteralType(source) && getObjectFlags(source)&ObjectFlagsFreshLiteral {
						result &= indexSignaturesRelatedTo(source, target, false, reportErrors, IntersectionStateNone)
					}
				} else if result && isNonGenericObjectType(target) && !isArrayOrTupleType(target) && source.flags&TypeFlagsIntersection && getApparentType(source).flags&TypeFlagsStructuredType && !some((source /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): t === target */
					/* TODO(BarBarToken): || */
					/* TODO(PrefixUnaryExpression): !!(getObjectFlags(t) & ObjectFlags.NonInferrableType) */
				}) {
					result &= propertiesRelatedTo(source, target, reportErrors, nil, true, intersectionState)
				}
			}
			if result {
				resetErrorInfo(saveErrorInfo)
			}
			return result
		}
		getApparentMappedTypeKeys := func(nameType Type, targetType MappedType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			modifiersType := getApparentType(getModifiersTypeFromMappedType(targetType))
			var mappedKeys []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, TypeFlagsStringOrNumberLiteralOrUnique, false, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): undefined */ TODO {
				/* TODO(CallExpression): mappedKeys.push(instantiateType(nameType, appendTypeMapping(targetType.mapper, getTypeParameterFromMappedType(targetType), t))) */
			})
			return getUnionType(mappedKeys)
		}
		structuredTypeRelatedToWorker := func(source Type, target Type, reportErrors bool, intersectionState IntersectionState, saveErrorInfo ReturnType[ /* TODO(TypeQuery): typeof captureErrorCalculationState */ TODO]) Ternary {
			var result Ternary
			var originalErrorInfo *DiagnosticMessageChain
			varianceCheckFailed := false
			sourceFlags := source.flags
			targetFlags := target.flags
			if relation == identityRelation {
				if sourceFlags & TypeFlagsUnionOrIntersection {
					result := eachTypeRelatedToSomeType(source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */)
					if result {
						result &= eachTypeRelatedToSomeType(target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */, source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */)
					}
					return result
				}
				if sourceFlags & TypeFlagsIndex {
					return isRelatedTo((source /* as */ /* TODO(TypeReference): IndexType */).type_, (target /* as */ /* TODO(TypeReference): IndexType */).type_, RecursionFlagsBoth, false)
				}
				if sourceFlags & TypeFlagsIndexedAccess {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as IndexedAccessType).indexType, (target as IndexedAccessType).indexType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if sourceFlags & TypeFlagsConditional {
					if (source /* as */ /* TODO(TypeReference): ConditionalType */).root.isDistributive == (target /* as */ /* TODO(TypeReference): ConditionalType */).root.isDistributive {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as ConditionalType).checkType, (target as ConditionalType).checkType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as ConditionalType).extendsType, (target as ConditionalType).extendsType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
								if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo(getTrueTypeFromConditionalType(source as ConditionalType), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
									if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo(getFalseTypeFromConditionalType(source as ConditionalType), getFalseTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, /*reportErrors* / false) */ TODO {
										return result
									}
								}
							}
						}
					}
				}
				if sourceFlags & TypeFlagsSubstitution {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as SubstitutionType).baseType, (target as SubstitutionType).baseType, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						if /* TODO(AmpersandEqualsToken): &= */ /* TODO(BinaryExpression): result &= isRelatedTo((source as SubstitutionType).constraint, (target as SubstitutionType).constraint, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
							return result
						}
					}
				}
				if !(sourceFlags & TypeFlagsObject) {
					return TernaryFalse
				}
			} else if sourceFlags&TypeFlagsUnionOrIntersection || targetFlags&TypeFlagsUnionOrIntersection {
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = unionOrIntersectionRelatedTo(source, target, reportErrors, intersectionState) */ TODO {
					return result
				}
				if !(sourceFlags&TypeFlagsInstantiable || sourceFlags&TypeFlagsObject && targetFlags&TypeFlagsUnion || sourceFlags&TypeFlagsIntersection && targetFlags&(TypeFlagsObject|TypeFlagsUnion|TypeFlagsInstantiable)) {
					return TernaryFalse
				}
			}
			if sourceFlags&(TypeFlagsObject|TypeFlagsConditional) && source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol == target.aliasSymbol && !(isMarkerType(source) || isMarkerType(target)) {
				variances := getAliasVariances(source.aliasSymbol)
				if variances == emptyArray {
					return TernaryUnknown
				}
				params := /* TODO(NonNullExpression): getSymbolLinks(source.aliasSymbol).typeParameters! */ TODO
				minParams := getMinTypeArgumentCount(params)
				sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
				varianceResult := relateVariances(sourceTypes, targetTypes, variances, intersectionState)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): varianceResult !== undefined */ TODO {
					return varianceResult
				}
			}
			if isSingleElementGenericTupleType(source) && !source.target.readonly && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getTypeArguments(source)[0], target, RecursionFlags.Source) */ TODO) || isSingleElementGenericTupleType(target) && (target.target.readonly || isMutableArrayOrTuple(getBaseConstraintOfType(source) || source)) && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, getTypeArguments(target)[0], RecursionFlags.Target) */ TODO) {
				return result
			}
			if targetFlags & TypeFlagsTypeParameter {
				if getObjectFlags(source)&ObjectFlagsMapped && !(source /* as */ /* TODO(TypeReference): MappedType */).declaration.nameType && isRelatedTo(getIndexType(target), getConstraintTypeFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */), RecursionFlagsBoth) {
					if !(getMappedTypeModifiers(source /* as */ /* TODO(TypeReference): MappedType */) & MappedTypeModifiersIncludeOptional) {
						templateType := getTemplateTypeFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */)
						indexedAccessType := getIndexedAccessType(target, getTypeParameterFromMappedType(source /* as */ /* TODO(TypeReference): MappedType */))
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(templateType, indexedAccessType, RecursionFlags.Both, reportErrors) */ TODO {
							return result
						}
					}
				}
				if relation == comparableRelation && sourceFlags&TypeFlagsTypeParameter {
					constraint := getConstraintOfTypeParameter(source)
					if constraint {
						/* TODO(WhileStatement): while (constraint && someType(constraint, c => !!(c.flags & TypeFlags.TypeParameter))) {                             if (result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false)) {                                 return result;                             }                             constraint = getConstraintOfTypeParameter(constraint);                         } */
					}
					return TernaryFalse
				}
			} else if targetFlags & TypeFlagsIndex {
				targetType := (target /* as */ /* TODO(TypeReference): IndexType */).type_
				if sourceFlags & TypeFlagsIndex {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(targetType, (source as IndexType).type, RecursionFlags.Both, /*reportErrors* / false) */ TODO {
						return result
					}
				}
				if isTupleType(targetType) {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, getKnownKeysOfTupleType(targetType), RecursionFlags.Target, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getSimplifiedTypeOrConstraint(targetType)
					if constraint {
						if isRelatedTo(source, getIndexType(constraint, (target /* as */ /* TODO(TypeReference): IndexType */).indexFlags|IndexFlagsNoReducibleCheck), RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					} else if isGenericMappedType(targetType) {
						nameType := getNameTypeFromMappedType(targetType)
						constraintType := getConstraintTypeFromMappedType(targetType)
						var targetKeys TODO
						if nameType && isMappedTypeWithKeyofConstraintDeclaration(targetType) {
							mappedKeys := getApparentMappedTypeKeys(nameType, targetType)
							targetKeys = getUnionType( /* TODO(ArrayLiteralExpression): [mappedKeys, nameType] */ TODO)
						} else {
							targetKeys = nameType || constraintType
						}
						if isRelatedTo(source, targetKeys, RecursionFlagsTarget, reportErrors) == TernaryTrue {
							return TernaryTrue
						}
					}
				}
			} else if targetFlags & TypeFlagsIndexedAccess {
				if sourceFlags & TypeFlagsIndexedAccess {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as IndexedAccessType).objectType, (target as IndexedAccessType).objectType, RecursionFlags.Both, reportErrors) */ TODO {
						result &= isRelatedTo((source /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType, (target /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType, RecursionFlagsBoth, reportErrors)
					}
					if result {
						return result
					}
					if reportErrors {
						originalErrorInfo = errorInfo
					}
				}
				if relation == assignableRelation || relation == comparableRelation {
					objectType := (target /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType
					indexType := (target /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType
					baseObjectType := getBaseConstraintOfType(objectType) || objectType
					baseIndexType := getBaseConstraintOfType(indexType) || indexType
					if !isGenericObjectType(baseObjectType) && !isGenericIndexType(baseIndexType) {
						accessFlags := AccessFlagsWriting | ( /* TODO(ConditionalExpression): baseObjectType !== objectType ? AccessFlags.NoIndexSignatures : 0 */ TODO)
						constraint := getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, accessFlags)
						if constraint {
							if reportErrors && originalErrorInfo {
								resetErrorInfo(saveErrorInfo)
							}
							if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, constraint, RecursionFlags.Target, reportErrors, /*headMessage* / undefined, intersectionState) */ TODO {
								return result
							}
							if reportErrors && originalErrorInfo && errorInfo {
								errorInfo = /* TODO(ConditionalExpression): countMessageChainBreadth([originalErrorInfo]) <= countMessageChainBreadth([errorInfo]) ? originalErrorInfo : errorInfo */ TODO
							}
						}
					}
				}
				if reportErrors {
					originalErrorInfo = nil
				}
			} else if isGenericMappedType(target) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
				keysRemapped := !!target.declaration.nameType
				templateType := getTemplateTypeFromMappedType(target)
				modifiers := getMappedTypeModifiers(target)
				if !(modifiers & MappedTypeModifiersExcludeOptional) {
					if !keysRemapped && templateType.flags&TypeFlagsIndexedAccess && (templateType /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType == source && (templateType /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType == getTypeParameterFromMappedType(target) {
						return TernaryTrue
					}
					if !isGenericMappedType(source) {
						targetKeys := /* TODO(ConditionalExpression): keysRemapped ? getNameTypeFromMappedType(target)! : getConstraintTypeFromMappedType(target) */ TODO
						sourceKeys := getIndexType(source, IndexFlagsNoIndexSignatures)
						includeOptional := modifiers & MappedTypeModifiersIncludeOptional
						filteredByApplicability := /* TODO(ConditionalExpression): includeOptional ? intersectTypes(targetKeys, sourceKeys) : undefined */ TODO
						if /* TODO(ConditionalExpression): includeOptional                                 ? !(filteredByApplicability!.flags & TypeFlags.Never)                                 : isRelatedTo(targetKeys, sourceKeys, RecursionFlags.Both) */ TODO {
							templateType := getTemplateTypeFromMappedType(target)
							typeParameter := getTypeParameterFromMappedType(target)
							nonNullComponent := extractTypesOfKind(templateType, ~TypeFlagsNullable)
							if !keysRemapped && nonNullComponent.flags&TypeFlagsIndexedAccess && (nonNullComponent /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType == typeParameter {
								if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(source, (nonNullComponent as IndexedAccessType).objectType, RecursionFlags.Target, reportErrors) */ TODO {
									return result
								}
							} else {
								indexingType := /* TODO(ConditionalExpression): keysRemapped                                     ? (filteredByApplicability || targetKeys)                                     : filteredByApplicability                                     ? getIntersectionType([filteredByApplicability, typeParameter])                                     : typeParameter */ TODO
								indexedAccessType := getIndexedAccessType(source, indexingType)
								if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(indexedAccessType, templateType, RecursionFlags.Both, reportErrors) */ TODO {
									return result
								}
							}
						}
						originalErrorInfo = errorInfo
						resetErrorInfo(saveErrorInfo)
					}
				}
			} else if targetFlags & TypeFlagsConditional {
				if isDeeplyNestedType(target, targetStack, targetDepth, 10) {
					return TernaryMaybe
				}
				c := target /* as */ /* TODO(TypeReference): ConditionalType */
				if !c.root.inferTypeParameters && !isDistributionDependent(c.root) && !(source.flags&TypeFlagsConditional && (source /* as */ /* TODO(TypeReference): ConditionalType */).root == c.root) {
					skipTrue := !isTypeAssignableTo(getPermissiveInstantiation(c.checkType), getPermissiveInstantiation(c.extendsType))
					skipFalse := !skipTrue && isTypeAssignableTo(getRestrictiveInstantiation(c.checkType), getRestrictiveInstantiation(c.extendsType))
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = skipTrue ? Ternary.True : isRelatedTo(source, getTrueTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						result &= /* TODO(ConditionalExpression): skipFalse ? Ternary.True : isRelatedTo(source, getFalseTypeFromConditionalType(c), RecursionFlags.Target, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO
						if result {
							return result
						}
					}
				}
			} else if targetFlags & TypeFlagsTemplateLiteral {
				if sourceFlags & TypeFlagsTemplateLiteral {
					if relation == comparableRelation {
						return /* TODO(ConditionalExpression): templateLiteralTypesDefinitelyUnrelated(source as TemplateLiteralType, target as TemplateLiteralType) ? Ternary.False : Ternary.True */ TODO
					}
					instantiateType(source, reportUnreliableMapper)
				}
				if isTypeMatchedByTemplateLiteralType(source, target /* as */ /* TODO(TypeReference): TemplateLiteralType */) {
					return TernaryTrue
				}
			} else if target.flags & TypeFlagsStringMapping {
				if !(source.flags & TypeFlagsStringMapping) {
					if isMemberOfStringMapping(source, target) {
						return TernaryTrue
					}
				}
			}
			if sourceFlags & TypeFlagsTypeVariable {
				if !(sourceFlags&TypeFlagsIndexedAccess && targetFlags&TypeFlagsIndexedAccess) {
					constraint := getConstraintOfType(source /* as */ /* TODO(TypeReference): TypeVariable */) || unknownType
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, /*reportErrors* / false, /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					} else if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getTypeWithThisArgument(constraint, source), target, RecursionFlags.Source, reportErrors && constraint !== unknownType && !(targetFlags & sourceFlags & TypeFlags.TypeParameter), /*headMessage* / undefined, intersectionState) */ TODO {
						return result
					}
					if isMappedTypeGenericIndexedAccess(source) {
						indexConstraint := getConstraintOfType((source /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType)
						if indexConstraint {
							if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(getIndexedAccessType((source as IndexedAccessType).objectType, indexConstraint), target, RecursionFlags.Source, reportErrors) */ TODO {
								return result
							}
						}
					}
				}
			} else if sourceFlags & TypeFlagsIndex {
				isDeferredMappedIndex := shouldDeferIndexType((source /* as */ /* TODO(TypeReference): IndexType */).type_, (source /* as */ /* TODO(TypeReference): IndexType */).indexFlags) && getObjectFlags((source /* as */ /* TODO(TypeReference): IndexType */).type_)&ObjectFlagsMapped
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(stringNumberSymbolType, target, RecursionFlags.Source, reportErrors && !isDeferredMappedIndex) */ TODO {
					return result
				}
				if isDeferredMappedIndex {
					mappedType := (source /* as */ /* TODO(TypeReference): IndexType */).type_ /* as */ /* TODO(TypeReference): MappedType */
					nameType := getNameTypeFromMappedType(mappedType)
					sourceMappedKeys := /* TODO(ConditionalExpression): nameType && isMappedTypeWithKeyofConstraintDeclaration(mappedType) ? getApparentMappedTypeKeys(nameType, mappedType) : (nameType || getConstraintTypeFromMappedType(mappedType)) */ TODO
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(sourceMappedKeys, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else if sourceFlags&TypeFlagsTemplateLiteral && !(targetFlags & TypeFlagsObject) {
				if !(targetFlags & TypeFlagsTemplateLiteral) {
					constraint := getBaseConstraintOfType(source)
					if constraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== source */ TODO && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsStringMapping {
				if targetFlags & TypeFlagsStringMapping {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (source as StringMappingType).symbol !== (target as StringMappingType).symbol */ TODO {
						return TernaryFalse
					}
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo((source as StringMappingType).type, (target as StringMappingType).type, RecursionFlags.Both, reportErrors) */ TODO {
						return result
					}
				} else {
					constraint := getBaseConstraintOfType(source)
					if constraint && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(constraint, target, RecursionFlags.Source, reportErrors) */ TODO) {
						return result
					}
				}
			} else if sourceFlags & TypeFlagsConditional {
				if isDeeplyNestedType(source, sourceStack, sourceDepth, 10) {
					return TernaryMaybe
				}
				if targetFlags & TypeFlagsConditional {
					sourceParams := (source /* as */ /* TODO(TypeReference): ConditionalType */).root.inferTypeParameters
					sourceExtends := (source /* as */ /* TODO(TypeReference): ConditionalType */).extendsType
					var mapper *TypeMapper
					if sourceParams {
						ctx := createInferenceContext(sourceParams, nil, InferenceFlagsNone, isRelatedToWorker)
						inferTypes(ctx.inferences, (target /* as */ /* TODO(TypeReference): ConditionalType */).extendsType, sourceExtends, InferencePriorityNoConstraints|InferencePriorityAlwaysStrict)
						sourceExtends = instantiateType(sourceExtends, ctx.mapper)
						mapper = ctx.mapper
					}
					if isTypeIdenticalTo(sourceExtends, (target /* as */ /* TODO(TypeReference): ConditionalType */).extendsType) && (isRelatedTo((source /* as */ /* TODO(TypeReference): ConditionalType */).checkType, (target /* as */ /* TODO(TypeReference): ConditionalType */).checkType, RecursionFlagsBoth) || isRelatedTo((target /* as */ /* TODO(TypeReference): ConditionalType */).checkType, (source /* as */ /* TODO(TypeReference): ConditionalType */).checkType, RecursionFlagsBoth)) {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(instantiateType(getTrueTypeFromConditionalType(source as ConditionalType), mapper), getTrueTypeFromConditionalType(target as ConditionalType), RecursionFlags.Both, reportErrors) */ TODO {
							result &= isRelatedTo(getFalseTypeFromConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */), getFalseTypeFromConditionalType(target /* as */ /* TODO(TypeReference): ConditionalType */), RecursionFlagsBoth, reportErrors)
						}
						if result {
							return result
						}
					}
				}
				defaultConstraint := getDefaultConstraintOfConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */)
				if defaultConstraint {
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(defaultConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
				distributiveConstraint := /* TODO(ConditionalExpression): !(targetFlags & TypeFlags.Conditional) && hasNonCircularBaseConstraint(source) ? getConstraintOfDistributiveConditionalType(source as ConditionalType) : undefined */ TODO
				if distributiveConstraint {
					resetErrorInfo(saveErrorInfo)
					if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(distributiveConstraint, target, RecursionFlags.Source, reportErrors) */ TODO {
						return result
					}
				}
			} else {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== subtypeRelation */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== strictSubtypeRelation */ TODO && isPartialMappedType(target) && isEmptyObjectType(source) {
					return TernaryTrue
				}
				if isGenericMappedType(target) {
					if isGenericMappedType(source) {
						if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = mappedTypeRelatedTo(source, target, reportErrors) */ TODO {
							return result
						}
					}
					return TernaryFalse
				}
				sourceIsPrimitive := !!(sourceFlags & TypeFlagsPrimitive)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
					source = getApparentType(source)
					sourceFlags = source.flags
				} else if isGenericMappedType(source) {
					return TernaryFalse
				}
				if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && (source /* as */ /* TODO(TypeReference): TypeReference */).target == (target /* as */ /* TODO(TypeReference): TypeReference */).target && !isTupleType(source) && !(isMarkerType(source) || isMarkerType(target)) {
					if isEmptyArrayLiteralType(source) {
						return TernaryTrue
					}
					variances := getVariances((source /* as */ /* TODO(TypeReference): TypeReference */).target)
					if variances == emptyArray {
						return TernaryUnknown
					}
					varianceResult := relateVariances(getTypeArguments(source /* as */ /* TODO(TypeReference): TypeReference */), getTypeArguments(target /* as */ /* TODO(TypeReference): TypeReference */), variances, intersectionState)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): varianceResult !== undefined */ TODO {
						return varianceResult
					}
				} else if /* TODO(ConditionalExpression): isReadonlyArrayType(target) ? everyType(source, isArrayOrTupleType) : isArrayType(target) && everyType(source, t => isTupleType(t) && !t.target.readonly) */ TODO {
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== identityRelation */ TODO {
						return isRelatedTo(getIndexTypeOfType(source, numberType) || anyType, getIndexTypeOfType(target, numberType) || anyType, RecursionFlagsBoth, reportErrors)
					} else {
						return TernaryFalse
					}
				} else if isGenericTupleType(source) && isTupleType(target) && !isGenericTupleType(target) {
					constraint := getBaseConstraintOrType(source)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== source */ TODO {
						return isRelatedTo(constraint, target, RecursionFlagsSource, reportErrors)
					}
				} else if (relation == subtypeRelation || relation == strictSubtypeRelation) && isEmptyObjectType(target) && getObjectFlags(target)&ObjectFlagsFreshLiteral && !isEmptyObjectType(source) {
					return TernaryFalse
				}
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsObject {
					reportStructuralErrors := reportErrors && errorInfo == saveErrorInfo.errorInfo && !sourceIsPrimitive
					result = propertiesRelatedTo(source, target, reportStructuralErrors, nil, false, intersectionState)
					if result {
						result &= signaturesRelatedTo(source, target, SignatureKindCall, reportStructuralErrors, intersectionState)
						if result {
							result &= signaturesRelatedTo(source, target, SignatureKindConstruct, reportStructuralErrors, intersectionState)
							if result {
								result &= indexSignaturesRelatedTo(source, target, sourceIsPrimitive, reportStructuralErrors, intersectionState)
							}
						}
					}
					if varianceCheckFailed && result {
						errorInfo = originalErrorInfo || errorInfo || saveErrorInfo.errorInfo
					} else if result {
						return result
					}
				}
				if sourceFlags&(TypeFlagsObject|TypeFlagsIntersection) && targetFlags&TypeFlagsUnion {
					objectOnlyTarget := extractTypesOfKind(target, TypeFlagsObject|TypeFlagsIntersection|TypeFlagsSubstitution)
					if objectOnlyTarget.flags & TypeFlagsUnion {
						result := typeRelatedToDiscriminatedType(source, objectOnlyTarget /* as */ /* TODO(TypeReference): UnionType */)
						if result {
							return result
						}
					}
				}
			}
			return TernaryFalse
			countMessageChainBreadth := func(info /* TODO(ArrayType): DiagnosticMessageChain[] */ any) number {
				if !info {
					/* TODO(NumericLiteral): 0 */
				}
				return reduceLeft(info, func(value /* TODO(undefined): number */ TODO, chain /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO) /* TODO(undefined): number */ TODO {
					/* TODO(BinaryExpression): value + 1 */
					/* TODO(PlusToken): + */
					/* TODO(CallExpression): countMessageChainBreadth(chain.next) */
				}, 0)
			}
			relateVariances := func(sourceTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, targetTypeArguments /* TODO(TypeOperator): readonly Type[] */ any, variances []VarianceFlags, intersectionState IntersectionState) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary | undefined */ TODO {
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = typeArgumentsRelatedTo(sourceTypeArguments, targetTypeArguments, variances, reportErrors, intersectionState) */ TODO {
					return result
				}
				if some(variances, func(v /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !(v & VarianceFlags.AllowsStructuralFallback) */
				}) {
					originalErrorInfo = nil
					resetErrorInfo(saveErrorInfo)
					return nil
				}
				allowStructuralFallback := targetTypeArguments && hasCovariantVoidArgument(targetTypeArguments, variances)
				varianceCheckFailed = !allowStructuralFallback
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): variances !== emptyArray */ TODO && !allowStructuralFallback {
					if varianceCheckFailed && !(reportErrors && some(variances, func(v /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(ParenthesizedExpression): (v & VarianceFlags.VarianceMask) */
						/* TODO(EqualsEqualsEqualsToken): === */
						/* TODO(PropertyAccessExpression): VarianceFlags.Invariant */
					})) {
						return TernaryFalse
					}
					originalErrorInfo = errorInfo
					resetErrorInfo(saveErrorInfo)
				}
			}
		}
		mappedTypeRelatedTo := func(source MappedType, target MappedType, reportErrors bool) Ternary {
			modifiersRelated := relation == comparableRelation || ( /* TODO(ConditionalExpression): relation === identityRelation ? getMappedTypeModifiers(source) === getMappedTypeModifiers(target) :                 getCombinedMappedTypeOptionality(source) <= getCombinedMappedTypeOptionality(target) */ TODO)
			if modifiersRelated {
				var result Ternary
				targetConstraint := getConstraintTypeFromMappedType(target)
				sourceConstraint := instantiateType(getConstraintTypeFromMappedType(source) /* TODO(ConditionalExpression): getCombinedMappedTypeOptionality(source) < 0 ? reportUnmeasurableMapper : reportUnreliableMapper */, TODO)
				if /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): result = isRelatedTo(targetConstraint, sourceConstraint, RecursionFlags.Both, reportErrors) */ TODO {
					mapper := createTypeMapper( /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(source)] */ TODO /* TODO(ArrayLiteralExpression): [getTypeParameterFromMappedType(target)] */, TODO)
					if instantiateType(getNameTypeFromMappedType(source), mapper) == instantiateType(getNameTypeFromMappedType(target), mapper) {
						return result & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), RecursionFlagsBoth, reportErrors)
					}
				}
			}
			return TernaryFalse
		}
		typeRelatedToDiscriminatedType := func(source Type, target UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			sourceProperties := getPropertiesOfType(source)
			sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
			if !sourcePropertiesFiltered {
				/* TODO(PropertyAccessExpression): Ternary.False */
			}
			numCombinations := 1
			for _, sourceProperty := range sourcePropertiesFiltered {
				numCombinations *= countTypes(getNonMissingTypeOfSymbol(sourceProperty))
				if numCombinations > 25 {
					tracing.instant(tracing.Phase.CheckTypes, "typeRelatedToDiscriminatedType_DepthLimit" /* TODO(ObjectLiteralExpression): { sourceId: source.id, targetId: target.id, numCombinations } */, TODO)
					return TernaryFalse
				}
			}
			var sourceDiscriminantTypes [][]Type = /* TODO(NewExpression): new Array<Type[]>(sourcePropertiesFiltered.length) */ TODO
			excludedProperties := /* TODO(NewExpression): new Set<__String>() */ TODO
			/* TODO(ForStatement): for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                 const sourceProperty = sourcePropertiesFiltered[i];                 const sourcePropertyType = getNonMissingTypeOfSymbol(sourceProperty);                 sourceDiscriminantTypes[i] = sourcePropertyType.flags & TypeFlags.Union                     ? (sourcePropertyType as UnionType).types                     : [sourcePropertyType];                 excludedProperties.add(sourceProperty.escapedName);             } */
			discriminantCombinations := cartesianProduct(sourceDiscriminantTypes)
			var matchingTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, combination := range discriminantCombinations {
				hasMatch := false
				/* TODO(LabeledStatement): outer:                 for (const type of target.types) {                     for (let i = 0; i < sourcePropertiesFiltered.length; i++) {                         const sourceProperty = sourcePropertiesFiltered[i];                         const targetProperty = getPropertyOfType(type, sourceProperty.escapedName);                         if (!targetProperty) continue outer;                         if (sourceProperty === targetProperty) continue;                         // We compare the source property to the target in the context of a single discriminant type.                         const related = propertyRelatedTo(source, target, sourceProperty, targetProperty, _ => combination[i], /*reportErrors* / false, IntersectionState.None, /*skipOptional* / strictNullChecks || relation === comparableRelation);                         // If the target property could not be found, or if the properties were not related,                         // then this constituent is not a match.                         if (!related) {                             continue outer;                         }                     }                     pushIfUnique(matchingTypes, type, equateValues);                     hasMatch = true;                 } */
				if !hasMatch {
					return TernaryFalse
				}
			}
			result := TernaryTrue
			for _, type_ := range matchingTypes {
				result &= propertiesRelatedTo(source, type_, false, excludedProperties, false, IntersectionStateNone)
				if result {
					result &= signaturesRelatedTo(source, type_, SignatureKindCall, false, IntersectionStateNone)
					if result {
						result &= signaturesRelatedTo(source, type_, SignatureKindConstruct, false, IntersectionStateNone)
						if result && !(isTupleType(source) && isTupleType(type_)) {
							result &= indexSignaturesRelatedTo(source, type_, false, false, IntersectionStateNone)
						}
					}
				}
				if !result {
					return result
				}
			}
			return result
		}
		excludeProperties := func(properties []Symbol, excludedProperties *Set[__String]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
			if !excludedProperties || properties.length == 0 {
				/* TODO(Identifier): properties */
			}
			var result /* TODO(ArrayType): Symbol[] */ any
			/* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {                 if (!excludedProperties.has(properties[i].escapedName)) {                     if (result) {                         result.push(properties[i]);                     }                 }                 else if (!result) {                     result = properties.slice(0, i);                 }             } */
			return result || properties
		}
		isPropertySymbolTypeRelated := func(sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState) Ternary {
			targetIsOptional := strictNullChecks && !!(getCheckFlags(targetProp) & CheckFlagsPartial)
			effectiveTarget := addOptionality(getNonMissingTypeOfSymbol(targetProp), false, targetIsOptional)
			effectiveSource := getTypeOfSourceProperty(sourceProp)
			return isRelatedTo(effectiveSource, effectiveTarget, RecursionFlagsBoth, reportErrors, nil, intersectionState)
		}
		propertyRelatedTo := func(source Type, target Type, sourceProp Symbol, targetProp Symbol, getTypeOfSourceProperty func(sym Symbol) Type, reportErrors bool, intersectionState IntersectionState, skipOptional bool) Ternary {
			sourcePropFlags := getDeclarationModifierFlagsFromSymbol(sourceProp)
			targetPropFlags := getDeclarationModifierFlagsFromSymbol(targetProp)
			if sourcePropFlags&ModifierFlagsPrivate || targetPropFlags&ModifierFlagsPrivate {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceProp.valueDeclaration !== targetProp.valueDeclaration */ TODO {
					if reportErrors {
						if sourcePropFlags&ModifierFlagsPrivate && targetPropFlags&ModifierFlagsPrivate {
							reportError(Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp))
						} else {
							reportError(Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString( /* TODO(ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? source : target */ TODO), typeToString( /* TODO(ConditionalExpression): sourcePropFlags & ModifierFlags.Private ? target : source */ TODO))
						}
					}
					return TernaryFalse
				}
			} else if targetPropFlags & ModifierFlagsProtected {
				if !isValidOverrideOf(sourceProp, targetProp) {
					if reportErrors {
						reportError(Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target))
					}
					return TernaryFalse
				}
			} else if sourcePropFlags & ModifierFlagsProtected {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			if relation == strictSubtypeRelation && isReadonlySymbol(sourceProp) && !isReadonlySymbol(targetProp) {
				return TernaryFalse
			}
			related := isPropertySymbolTypeRelated(sourceProp, targetProp, getTypeOfSourceProperty, reportErrors, intersectionState)
			if !related {
				if reportErrors {
					reportIncompatibleError(Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp))
				}
				return TernaryFalse
			}
			if !skipOptional && sourceProp.flags&SymbolFlagsOptional && targetProp.flags&SymbolFlagsClassMember && !(targetProp.flags & SymbolFlagsOptional) {
				if reportErrors {
					reportError(Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target))
				}
				return TernaryFalse
			}
			return related
		}
		reportUnmatchedProperty := func(source Type, target Type, unmatchedProperty Symbol, requireOptionalProperties bool) {
			shouldSkipElaboration := false
			if unmatchedProperty.valueDeclaration && isNamedDeclaration(unmatchedProperty.valueDeclaration) && isPrivateIdentifier(unmatchedProperty.valueDeclaration.name) && source.symbol && source.symbol.flags&SymbolFlagsClass {
				privateIdentifierDescription := unmatchedProperty.valueDeclaration.name.escapedText
				symbolTableKey := getSymbolNameForPrivateIdentifier(source.symbol, privateIdentifierDescription)
				if symbolTableKey && getPropertyOfType(source, symbolTableKey) {
					sourceName := factory.getDeclarationName(source.symbol.valueDeclaration)
					targetName := factory.getDeclarationName(target.symbol.valueDeclaration)
					reportError(Diagnostics.Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2, diagnosticName(privateIdentifierDescription), diagnosticName( /* TODO(ConditionalExpression): sourceName.escapedText === "" ? anon : sourceName */ TODO), diagnosticName( /* TODO(ConditionalExpression): targetName.escapedText === "" ? anon : targetName */ TODO))
					return
				}
			}
			props := arrayFrom(getUnmatchedProperties(source, target, requireOptionalProperties, false))
			if !headMessage || ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): headMessage.code !== Diagnostics.Class_0_incorrectly_implements_interface_1.code */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): headMessage.code !== Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass.code */ TODO) {
				shouldSkipElaboration = true
			}
			if props.length == 1 {
				propName := symbolToString(unmatchedProperty, nil, SymbolFlagsNone, SymbolFormatFlagsAllowAnyNodeKind|SymbolFormatFlagsWriteComputedProps)
				reportError(Diagnostics.Property_0_is_missing_in_type_1_but_required_in_type_2, propName /* TODO(SpreadElement): ...getTypeNamesForErrorDisplay(source, target) */, TODO)
				if length(unmatchedProperty.declarations) {
					associateRelatedInfo(createDiagnosticForNode( /* TODO(ElementAccessExpression): unmatchedProperty.declarations![0] */ TODO, Diagnostics._0_is_declared_here, propName))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			} else if tryElaborateArrayLikeErrors(source, target, false) {
				if props.length > 5 {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more, typeToString(source), typeToString(target), map_(props.slice(0, 4), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): string */ TODO {
						/* TODO(Identifier): symbolToString */
						/* TODO(Identifier): p */
					}).join(", "), /* TODO(MinusToken): - */ /* TODO(BinaryExpression): props.length - 4 */ TODO)
				} else {
					reportError(Diagnostics.Type_0_is_missing_the_following_properties_from_type_1_Colon_2, typeToString(source), typeToString(target), map_(props, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): string */ TODO {
						/* TODO(Identifier): symbolToString */
						/* TODO(Identifier): p */
					}).join(", "))
				}
				if shouldSkipElaboration && errorInfo {
					overrideNextErrorInfo++
				}
			}
		}
		propertiesRelatedTo := func(source Type, target Type, reportErrors bool, excludedProperties *Set[__String], optionalsOnly bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return propertiesIdenticalTo(source, target, excludedProperties)
			}
			result := TernaryTrue
			if isTupleType(target) {
				if isArrayOrTupleType(source) {
					if !target.target.readonly && (isReadonlyArrayType(source) || isTupleType(source) && source.target.readonly) {
						return TernaryFalse
					}
					sourceArity := getTypeReferenceArity(source)
					targetArity := getTypeReferenceArity(target)
					sourceRestFlag := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.combinedFlags & ElementFlags.Rest : ElementFlags.Rest */ TODO
					targetHasRestElement := !!(target.target.combinedFlags & ElementFlagsVariable)
					sourceMinLength := /* TODO(ConditionalExpression): isTupleType(source) ? source.target.minLength : 0 */ TODO
					targetMinLength := target.target.minLength
					if !sourceRestFlag && sourceArity < targetMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_requires_1, sourceArity, targetMinLength)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && targetArity < sourceMinLength {
						if reportErrors {
							reportError(Diagnostics.Source_has_0_element_s_but_target_allows_only_1, sourceMinLength, targetArity)
						}
						return TernaryFalse
					}
					if !targetHasRestElement && (sourceRestFlag || targetArity < sourceArity) {
						if reportErrors {
							if sourceMinLength < targetMinLength {
								reportError(Diagnostics.Target_requires_0_element_s_but_source_may_have_fewer, targetMinLength)
							} else {
								reportError(Diagnostics.Target_allows_only_0_element_s_but_source_may_have_more, targetArity)
							}
						}
						return TernaryFalse
					}
					sourceTypeArguments := getTypeArguments(source)
					targetTypeArguments := getTypeArguments(target)
					targetStartCount := getStartElementCount(target.target, ElementFlagsNonRest)
					targetEndCount := getEndElementCount(target.target, ElementFlagsNonRest)
					canExcludeDiscriminants := !!excludedProperties
					/* TODO(ForStatement): for (let sourcePosition = 0; sourcePosition < sourceArity; sourcePosition++) {                         const sourceFlags = isTupleType(source) ? source.target.elementFlags[sourcePosition] : ElementFlags.Rest;                         const sourcePositionFromEnd = sourceArity - 1 - sourcePosition;                          const targetPosition = targetHasRestElement && sourcePosition >= targetStartCount                             ? targetArity - 1 - Math.min(sourcePositionFromEnd, targetEndCount)                             : sourcePosition;                          const targetFlags = target.target.elementFlags[targetPosition];                          if (targetFlags & ElementFlags.Variadic && !(sourceFlags & ElementFlags.Variadic)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_variadic_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         if (sourceFlags & ElementFlags.Variadic && !(targetFlags & ElementFlags.Variable)) {                             if (reportErrors) {                                 reportError(Diagnostics.Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target, sourcePosition, targetPosition);                             }                             return Ternary.False;                         }                         if (targetFlags & ElementFlags.Required && !(sourceFlags & ElementFlags.Required)) {                             if (reportErrors) {                                 reportError(Diagnostics.Source_provides_no_match_for_required_element_at_position_0_in_target, targetPosition);                             }                             return Ternary.False;                         }                         // We can only exclude discriminant properties if we have not yet encountered a variable-length element.                         if (canExcludeDiscriminants) {                             if (sourceFlags & ElementFlags.Variable || targetFlags & ElementFlags.Variable) {                                 canExcludeDiscriminants = false;                             }                             if (canExcludeDiscriminants && excludedProperties?.has(("" + sourcePosition) as __String)) {                                 continue;                             }                         }                          const sourceType = removeMissingType(sourceTypeArguments[sourcePosition], !!(sourceFlags & targetFlags & ElementFlags.Optional));                         const targetType = targetTypeArguments[targetPosition];                          const targetCheckType = sourceFlags & ElementFlags.Variadic && targetFlags & ElementFlags.Rest ? createArrayType(targetType) :                             removeMissingType(targetType, !!(targetFlags & ElementFlags.Optional));                         const related = isRelatedTo(sourceType, targetCheckType, RecursionFlags.Both, reportErrors, /*headMessage* / undefined, intersectionState);                         if (!related) {                             if (reportErrors && (targetArity > 1 || sourceArity > 1)) {                                 if (targetHasRestElement && sourcePosition >= targetStartCount && sourcePositionFromEnd >= targetEndCount && targetStartCount !== sourceArity - targetEndCount - 1) {                                     reportIncompatibleError(Diagnostics.Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target, targetStartCount, sourceArity - targetEndCount - 1, targetPosition);                                 }                                 else {                                     reportIncompatibleError(Diagnostics.Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target, sourcePosition, targetPosition);                                 }                             }                             return Ternary.False;                         }                         result &= related;                     } */
					return result
				}
				if target.target.combinedFlags & ElementFlagsVariable {
					return TernaryFalse
				}
			}
			requireOptionalProperties := (relation == subtypeRelation || relation == strictSubtypeRelation) && !isObjectLiteralType(source) && !isEmptyArrayLiteralType(source) && !isTupleType(source)
			unmatchedProperty := getUnmatchedProperty(source, target, requireOptionalProperties, false)
			if unmatchedProperty {
				if reportErrors && shouldReportUnmatchedPropertyError(source, target) {
					reportUnmatchedProperty(source, target, unmatchedProperty, requireOptionalProperties)
				}
				return TernaryFalse
			}
			if isObjectLiteralType(target) {
				for _, sourceProp := range excludeProperties(getPropertiesOfType(source), excludedProperties) {
					if !getPropertyOfObjectType(target, sourceProp.escapedName) {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags & TypeFlagsUndefined) {
							if reportErrors {
								reportError(Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(sourceProp), typeToString(target))
							}
							return TernaryFalse
						}
					}
				}
			}
			properties := getPropertiesOfType(target)
			numericNamesOnly := isTupleType(source) && isTupleType(target)
			for _, targetProp := range excludeProperties(properties, excludedProperties) {
				name := targetProp.escapedName
				if !(targetProp.flags & SymbolFlagsPrototype) && (!numericNamesOnly || isNumericLiteralName(name) || name == "length") && (!optionalsOnly || targetProp.flags&SymbolFlagsOptional) {
					sourceProp := getPropertyOfType(source, name)
					if sourceProp && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceProp !== targetProp */ TODO {
						related := propertyRelatedTo(source, target, sourceProp, targetProp, getNonMissingTypeOfSymbol, reportErrors, intersectionState, relation == comparableRelation)
						if !related {
							return TernaryFalse
						}
						result &= related
					}
				}
			}
			return result
		}
		propertiesIdenticalTo := func(source Type, target Type, excludedProperties *Set[__String]) Ternary {
			if !(source.flags&TypeFlagsObject && target.flags&TypeFlagsObject) {
				return TernaryFalse
			}
			sourceProperties := excludeProperties(getPropertiesOfObjectType(source), excludedProperties)
			targetProperties := excludeProperties(getPropertiesOfObjectType(target), excludedProperties)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceProperties.length !== targetProperties.length */ TODO {
				return TernaryFalse
			}
			result := TernaryTrue
			for _, sourceProp := range sourceProperties {
				targetProp := getPropertyOfObjectType(target, sourceProp.escapedName)
				if !targetProp {
					return TernaryFalse
				}
				related := compareProperties(sourceProp, targetProp, isRelatedTo)
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		signaturesRelatedTo := func(source Type, target Type, kind SignatureKind, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return signaturesIdenticalTo(source, target, kind)
			}
			if target == anyFunctionType || source == anyFunctionType {
				return TernaryTrue
			}
			sourceIsJSConstructor := source.symbol && isJSConstructor(source.symbol.valueDeclaration)
			targetIsJSConstructor := target.symbol && isJSConstructor(target.symbol.valueDeclaration)
			sourceSignatures := getSignaturesOfType(source /* TODO(ConditionalExpression): (sourceIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */, TODO)
			targetSignatures := getSignaturesOfType(target /* TODO(ConditionalExpression): (targetIsJSConstructor && kind === SignatureKind.Construct) ?                     SignatureKind.Call : kind */, TODO)
			if kind == SignatureKindConstruct && sourceSignatures.length && targetSignatures.length {
				sourceIsAbstract := !!( /* TODO(ElementAccessExpression): sourceSignatures[0] */ TODO.flags & SignatureFlagsAbstract)
				targetIsAbstract := !!( /* TODO(ElementAccessExpression): targetSignatures[0] */ TODO.flags & SignatureFlagsAbstract)
				if sourceIsAbstract && !targetIsAbstract {
					if reportErrors {
						reportError(Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type)
					}
					return TernaryFalse
				}
				if !constructorVisibilitiesAreCompatible( /* TODO(ElementAccessExpression): sourceSignatures[0] */ TODO /* TODO(ElementAccessExpression): targetSignatures[0] */, TODO, reportErrors) {
					return TernaryFalse
				}
			}
			result := TernaryTrue
			incompatibleReporter := /* TODO(ConditionalExpression): kind === SignatureKind.Construct ? reportIncompatibleConstructSignatureReturn : reportIncompatibleCallSignatureReturn */ TODO
			sourceObjectFlags := getObjectFlags(source)
			targetObjectFlags := getObjectFlags(target)
			if sourceObjectFlags&ObjectFlagsInstantiated && targetObjectFlags&ObjectFlagsInstantiated && source.symbol == target.symbol || sourceObjectFlags&ObjectFlagsReference && targetObjectFlags&ObjectFlagsReference && (source /* as */ /* TODO(TypeReference): TypeReference */).target == (target /* as */ /* TODO(TypeReference): TypeReference */).target {
				Debug.assertEqual(sourceSignatures.length, targetSignatures.length)
				/* TODO(ForStatement): for (let i = 0; i < targetSignatures.length; i++) {                     const related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], /*erase* / true, reportErrors, intersectionState, incompatibleReporter(sourceSignatures[i], targetSignatures[i]));                     if (!related) {                         return Ternary.False;                     }                     result &= related;                 } */
			} else if sourceSignatures.length == 1 && targetSignatures.length == 1 {
				eraseGenerics := relation == comparableRelation
				sourceSignature := first(sourceSignatures)
				targetSignature := first(targetSignatures)
				result = signatureRelatedTo(sourceSignature, targetSignature, eraseGenerics, reportErrors, intersectionState, incompatibleReporter(sourceSignature, targetSignature))
				if !result && reportErrors && kind == SignatureKindConstruct && (sourceObjectFlags & targetObjectFlags) && (targetSignature.declaration.kind == SyntaxKindConstructor || sourceSignature.declaration.kind == SyntaxKindConstructor) {
					constructSignatureToString := func(signature Signature) /* TODO(undefined): string */ TODO {
						/* TODO(Identifier): signatureToString */
						/* TODO(Identifier): signature */
						/* TODO(Identifier): undefined */
						/* TODO(PropertyAccessExpression): TypeFormatFlags.WriteArrowStyleSignature */
						/* TODO(Identifier): kind */
					}
					reportError(Diagnostics.Type_0_is_not_assignable_to_type_1, constructSignatureToString(sourceSignature), constructSignatureToString(targetSignature))
					reportError(Diagnostics.Types_of_construct_signatures_are_incompatible)
					return result
				}
			} else {
				/* TODO(LabeledStatement): outer:                 for (const t of targetSignatures) {                     const saveErrorInfo = captureErrorCalculationState();                     // Only elaborate errors from the first failure                     let shouldElaborateErrors = reportErrors;                     for (const s of sourceSignatures) {                         const related = signatureRelatedTo(s, t, /*erase* / true, shouldElaborateErrors, intersectionState, incompatibleReporter(s, t));                         if (related) {                             result &= related;                             resetErrorInfo(saveErrorInfo);                             continue outer;                         }                         shouldElaborateErrors = false;                     }                     if (shouldElaborateErrors) {                         reportError(Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, /*enclosingDeclaration* / undefined, /*flags* / undefined, kind));                     }                     return Ternary.False;                 } */
			}
			return result
		}
		shouldReportUnmatchedPropertyError := func(source Type, target Type) bool {
			typeCallSignatures := getSignaturesOfStructuredType(source, SignatureKindCall)
			typeConstructSignatures := getSignaturesOfStructuredType(source, SignatureKindConstruct)
			typeProperties := getPropertiesOfObjectType(source)
			if (typeCallSignatures.length || typeConstructSignatures.length) && !typeProperties.length {
				if (getSignaturesOfType(target, SignatureKindCall).length && typeCallSignatures.length) || (getSignaturesOfType(target, SignatureKindConstruct).length && typeConstructSignatures.length) {
					return true
				}
				return false
			}
			return true
		}
		reportIncompatibleCallSignatureReturn := func(siga Signature, sigb Signature) /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					/* TODO(Identifier): reportIncompatibleError */
					/* TODO(PropertyAccessExpression): Diagnostics.Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1 */
					/* TODO(CallExpression): typeToString(source) */
					/* TODO(CallExpression): typeToString(target) */
				}
			}
			return func(source Type, target Type) {
				/* TODO(Identifier): reportIncompatibleError */
				/* TODO(PropertyAccessExpression): Diagnostics.Call_signature_return_types_0_and_1_are_incompatible */
				/* TODO(CallExpression): typeToString(source) */
				/* TODO(CallExpression): typeToString(target) */
			}
		}
		reportIncompatibleConstructSignatureReturn := func(siga Signature, sigb Signature) /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => void */ TODO {
			if siga.parameters.length == 0 && sigb.parameters.length == 0 {
				return func(source Type, target Type) {
					/* TODO(Identifier): reportIncompatibleError */
					/* TODO(PropertyAccessExpression): Diagnostics.Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1 */
					/* TODO(CallExpression): typeToString(source) */
					/* TODO(CallExpression): typeToString(target) */
				}
			}
			return func(source Type, target Type) {
				/* TODO(Identifier): reportIncompatibleError */
				/* TODO(PropertyAccessExpression): Diagnostics.Construct_signature_return_types_0_and_1_are_incompatible */
				/* TODO(CallExpression): typeToString(source) */
				/* TODO(CallExpression): typeToString(target) */
			}
		}
		signatureRelatedTo := func(source Signature, target Signature, erase bool, reportErrors bool, intersectionState IntersectionState, incompatibleReporter func(source Type, target Type)) Ternary {
			checkMode := /* TODO(ConditionalExpression): relation === subtypeRelation ? SignatureCheckMode.StrictTopSignature :                 relation === strictSubtypeRelation ? SignatureCheckMode.StrictTopSignature | SignatureCheckMode.StrictArity :                 SignatureCheckMode.None */ TODO
			return compareSignaturesRelated( /* TODO(ConditionalExpression): erase ? getErasedSignature(source) : source */ TODO /* TODO(ConditionalExpression): erase ? getErasedSignature(target) : target */, TODO, checkMode, reportErrors, reportError, incompatibleReporter, isRelatedToWorker, reportUnreliableMapper)
			isRelatedToWorker := func(source Type, target Type, reportErrors bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
				return isRelatedTo(source, target, RecursionFlagsBoth, reportErrors, nil, intersectionState)
			}
		}
		signaturesIdenticalTo := func(source Type, target Type, kind SignatureKind) Ternary {
			sourceSignatures := getSignaturesOfType(source, kind)
			targetSignatures := getSignaturesOfType(target, kind)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceSignatures.length !== targetSignatures.length */ TODO {
				return TernaryFalse
			}
			result := TernaryTrue
			/* TODO(ForStatement): for (let i = 0; i < sourceSignatures.length; i++) {                 const related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], /*partialMatch* / false, /*ignoreThisTypes* / false, /*ignoreReturnTypes* / false, isRelatedTo);                 if (!related) {                     return Ternary.False;                 }                 result &= related;             } */
			return result
		}
		membersRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			result := TernaryTrue
			keyType := targetInfo.keyType
			props := /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? getPropertiesOfUnionOrIntersectionType(source as IntersectionType) : getPropertiesOfObjectType(source) */ TODO
			for _, prop := range props {
				if isIgnoredJsxProperty(source, prop) {
					/* TODO(ContinueStatement): continue; */
				}
				if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), keyType) {
					propType := getNonMissingTypeOfSymbol(prop)
					type_ := /* TODO(ConditionalExpression): exactOptionalPropertyTypes || propType.flags & TypeFlags.Undefined || keyType === numberType || !(prop.flags & SymbolFlags.Optional)                         ? propType                         : getTypeWithFacts(propType, TypeFacts.NEUndefined) */ TODO
					related := isRelatedTo(type_, targetInfo.type_, RecursionFlagsBoth, reportErrors, nil, intersectionState)
					if !related {
						if reportErrors {
							reportError(Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop))
						}
						return TernaryFalse
					}
					result &= related
				}
			}
			for _, info := range getIndexInfosOfType(source) {
				if isApplicableIndexType(info.keyType, keyType) {
					related := indexInfoRelatedTo(info, targetInfo, reportErrors, intersectionState)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
			return result
		}
		indexInfoRelatedTo := func(sourceInfo IndexInfo, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO {
			related := isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth, reportErrors, nil, intersectionState)
			if !related && reportErrors {
				if sourceInfo.keyType == targetInfo.keyType {
					reportError(Diagnostics._0_index_signatures_are_incompatible, typeToString(sourceInfo.keyType))
				} else {
					reportError(Diagnostics._0_and_1_index_signatures_are_incompatible, typeToString(sourceInfo.keyType), typeToString(targetInfo.keyType))
				}
			}
			return related
		}
		indexSignaturesRelatedTo := func(source Type, target Type, sourceIsPrimitive bool, reportErrors bool, intersectionState IntersectionState) Ternary {
			if relation == identityRelation {
				return indexSignaturesIdenticalTo(source, target)
			}
			indexInfos := getIndexInfosOfType(target)
			targetHasStringIndex := some(indexInfos, func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): info.keyType */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(Identifier): stringType */
			})
			result := TernaryTrue
			for _, targetInfo := range indexInfos {
				related := /* TODO(ConditionalExpression): relation !== strictSubtypeRelation && !sourceIsPrimitive && targetHasStringIndex && targetInfo.type.flags & TypeFlags.Any ? Ternary.True :                     isGenericMappedType(source) && targetHasStringIndex ? isRelatedTo(getTemplateTypeFromMappedType(source), targetInfo.type, RecursionFlags.Both, reportErrors) :                     typeRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState) */ TODO
				if !related {
					return TernaryFalse
				}
				result &= related
			}
			return result
		}
		typeRelatedToIndexInfo := func(source Type, targetInfo IndexInfo, reportErrors bool, intersectionState IntersectionState) Ternary {
			sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
			if sourceInfo {
				return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors, intersectionState)
			}
			if !(intersectionState & IntersectionStateSource) && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): relation !== strictSubtypeRelation */ TODO || getObjectFlags(source)&ObjectFlagsFreshLiteral) && isObjectTypeWithInferableIndex(source) {
				return membersRelatedToIndexInfo(source, targetInfo, reportErrors, intersectionState)
			}
			if reportErrors {
				reportError(Diagnostics.Index_signature_for_type_0_is_missing_in_type_1, typeToString(targetInfo.keyType), typeToString(source))
			}
			return TernaryFalse
		}
		indexSignaturesIdenticalTo := func(source Type, target Type) Ternary {
			sourceInfos := getIndexInfosOfType(source)
			targetInfos := getIndexInfosOfType(target)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceInfos.length !== targetInfos.length */ TODO {
				return TernaryFalse
			}
			for _, targetInfo := range targetInfos {
				sourceInfo := getIndexInfoOfType(source, targetInfo.keyType)
				if !(sourceInfo && isRelatedTo(sourceInfo.type_, targetInfo.type_, RecursionFlagsBoth) && sourceInfo.isReadonly == targetInfo.isReadonly) {
					return TernaryFalse
				}
			}
			return TernaryTrue
		}
		constructorVisibilitiesAreCompatible := func(sourceSignature Signature, targetSignature Signature, reportErrors bool) /* TODO(undefined): boolean */ TODO {
			if !sourceSignature.declaration || !targetSignature.declaration {
				return true
			}
			sourceAccessibility := getSelectedEffectiveModifierFlags(sourceSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			targetAccessibility := getSelectedEffectiveModifierFlags(targetSignature.declaration, ModifierFlagsNonPublicAccessibilityModifier)
			if targetAccessibility == ModifierFlagsPrivate {
				return true
			}
			if targetAccessibility == ModifierFlagsProtected && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceAccessibility !== ModifierFlags.Private */ TODO {
				return true
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetAccessibility !== ModifierFlags.Protected */ TODO && !sourceAccessibility {
				return true
			}
			if reportErrors {
				reportError(Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility))
			}
			return false
		}
	}
	typeCouldHaveTopLevelSingletonTypes := func(type_ Type) bool {
		if type_.flags & TypeFlagsBoolean {
			return false
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			return !!forEach((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, typeCouldHaveTopLevelSingletonTypes)
		}
		if type_.flags & TypeFlagsInstantiable {
			constraint := getConstraintOfType(type_)
			if constraint && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constraint !== type */ TODO {
				return typeCouldHaveTopLevelSingletonTypes(constraint)
			}
		}
		return isUnitType(type_) || !!(type_.flags & TypeFlagsTemplateLiteral) || !!(type_.flags & TypeFlagsStringMapping)
	}
	getExactOptionalUnassignableProperties := func(source Type, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		if isTupleType(source) && isTupleType(target) {
			/* TODO(Identifier): emptyArray */
		}
		return getPropertiesOfType(target).filter(func(targetProp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isExactOptionalPropertyMismatch */
			/* TODO(CallExpression): getTypeOfPropertyOfType(source, targetProp.escapedName) */
			/* TODO(CallExpression): getTypeOfSymbol(targetProp) */
		})
	}
	isExactOptionalPropertyMismatch := func(source *Type, target *Type) /* TODO(undefined): boolean */ TODO {
		return !!source && !!target && maybeTypeOfKind(source, TypeFlagsUndefined) && !!containsMissingType(target)
	}
	getExactOptionalProperties := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		return getPropertiesOfType(type_).filter(func(targetProp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): containsMissingType */
			/* TODO(CallExpression): getTypeOfSymbol(targetProp) */
		})
	}
	getBestMatchingType := func(source Type, target UnionOrIntersectionType, isRelatedTo /* TODO(undefined): (source: import("/home/jabaile/work/TypeScript/src/compiler/types").Type, target: import("/home/jabaile/work/TypeScript/src/compiler/types").Type) => import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary */ TODO /* = */ /* TODO(Identifier): compareTypesAssignable */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return findMatchingDiscriminantType(source, target, isRelatedTo) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(source, target) || findBestTypeForInvokable(source, target) || findMostOverlappyType(source, target)
	}
	discriminateTypeByDiscriminableItems := func(target UnionType, discriminators [] /* TODO(TupleType): [() => Type, __String] */ TODO, related func(source Type, target Type) /* TODO(UnionType): boolean | Ternary */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		types := target.types
		var include []Ternary = types.map_(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.False | import("/home/jabaile/work/TypeScript/src/compiler/types").Ternary.True */ TODO {
			/* TODO(BinaryExpression): t.flags & TypeFlags.Primitive */
			/* TODO(QuestionToken): ? */
			/* TODO(PropertyAccessExpression): Ternary.False */
			/* TODO(ColonToken): : */
			/* TODO(PropertyAccessExpression): Ternary.True */
		})
		for _, TODO_IDENTIFIER := range discriminators {
			matched := false
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 if (include[i]) {                     const targetType = getTypeOfPropertyOrIndexSignatureOfType(types[i], propertyName);                     if (targetType && someType(getDiscriminatingType(), t => !!related(t, targetType))) {                         matched = true;                     }                     else {                         include[i] = Ternary.Maybe;                     }                 }             } */
			/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                 if (include[i] === Ternary.Maybe) {                     include[i] = matched ? Ternary.False : Ternary.True;                 }             } */
		}
		filtered := /* TODO(ConditionalExpression): contains(include, Ternary.False) ? getUnionType(types.filter((_, i) => include[i]), UnionReduction.None) : target */ TODO
		return /* TODO(ConditionalExpression): filtered.flags & TypeFlags.Never ? target : filtered */ TODO
	}
	isWeakType := func(type_ Type) bool {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			return resolved.callSignatures.length == 0 && resolved.constructSignatures.length == 0 && resolved.indexInfos.length == 0 && resolved.properties.length > 0 && every(resolved.properties, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(p.flags & SymbolFlags.Optional) */
			})
		}
		if type_.flags & TypeFlagsSubstitution {
			return isWeakType((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType)
		}
		if type_.flags & TypeFlagsIntersection {
			return every((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isWeakType)
		}
		return false
	}
	hasCommonProperties := func(source Type, target Type, isComparingJsxAttributes bool) /* TODO(undefined): boolean */ TODO {
		for _, prop := range getPropertiesOfType(source) {
			if isKnownProperty(target, prop.escapedName, isComparingJsxAttributes) {
				return true
			}
		}
		return false
	}
	getVariances := func(type_ GenericType) []VarianceFlags {
		return /* TODO(ConditionalExpression): type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & ObjectFlags.Tuple ?             arrayVariances :             getVariancesWorker(type.symbol, type.typeParameters) */ TODO
	}
	getAliasVariances := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").VarianceFlags[] */ TODO {
		return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters)
	}
	getVariancesWorker := func(symbol Symbol, typeParameters []TypeParameter /* = */ /* TODO(Identifier): emptyArray */) []VarianceFlags {
		links := getSymbolLinks(symbol)
		if !links.variances {
			tracing.push(tracing.Phase.CheckTypes, "getVariancesWorker" /* TODO(ObjectLiteralExpression): { arity: typeParameters.length, id: getTypeId(getDeclaredTypeOfSymbol(symbol)) } */, TODO)
			oldVarianceComputation := inVarianceComputation
			saveResolutionStart := resolutionStart
			if !inVarianceComputation {
				inVarianceComputation = true
				resolutionStart = resolutionTargets.length
			}
			links.variances = emptyArray
			variances := /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, tp := range typeParameters {
				modifiers := getTypeParameterModifiers(tp)
				variance := /* TODO(ConditionalExpression): modifiers & ModifierFlags.Out ?                     modifiers & ModifierFlags.In ? VarianceFlags.Invariant : VarianceFlags.Covariant :                     modifiers & ModifierFlags.In ? VarianceFlags.Contravariant : undefined */ TODO
				if variance == nil {
					unmeasurable := false
					unreliable := false
					oldHandler := outofbandVarianceMarkerHandler
					outofbandVarianceMarkerHandler = func(onlyUnreliable /* TODO(undefined): boolean */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(Identifier): onlyUnreliable */
						/* TODO(QuestionToken): ? */
						/* TODO(BinaryExpression): unreliable = true */
						/* TODO(ColonToken): : */
						/* TODO(BinaryExpression): unmeasurable = true */
					}
					typeWithSuper := createMarkerType(symbol, tp, markerSuperType)
					typeWithSub := createMarkerType(symbol, tp, markerSubType)
					variance = ( /* TODO(ConditionalExpression): isTypeAssignableTo(typeWithSub, typeWithSuper) ? VarianceFlags.Covariant : 0 */ TODO) | ( /* TODO(ConditionalExpression): isTypeAssignableTo(typeWithSuper, typeWithSub) ? VarianceFlags.Contravariant : 0 */ TODO)
					if variance == VarianceFlagsBivariant && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper) {
						variance = VarianceFlagsIndependent
					}
					outofbandVarianceMarkerHandler = oldHandler
					if unmeasurable || unreliable {
						if unmeasurable {
							variance |= VarianceFlagsUnmeasurable
						}
						if unreliable {
							variance |= VarianceFlagsUnreliable
						}
					}
				}
				variances.push(variance)
			}
			if !oldVarianceComputation {
				inVarianceComputation = false
				resolutionStart = saveResolutionStart
			}
			links.variances = variances
			tracing.pop( /* TODO(ObjectLiteralExpression): { variances: variances.map(Debug.formatVariance) } */ TODO)
		}
		return links.variances
	}
	createMarkerType := func(symbol Symbol, source TypeParameter, target Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		mapper := makeUnaryTypeMapper(source, target)
		type_ := getDeclaredTypeOfSymbol(symbol)
		if isErrorType(type_) {
			return type_
		}
		result := /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.TypeAlias ?             getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters!, mapper)) :             createTypeReference(type as GenericType, instantiateTypes((type as GenericType).typeParameters, mapper)) */ TODO
		markerTypes.add(getTypeId(result))
		return result
	}
	isMarkerType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return markerTypes.has(getTypeId(type_))
	}
	getTypeParameterModifiers := func(tp TypeParameter) ModifierFlags {
		return reduceLeft(tp.symbol.declarations, func(modifiers /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ TODO, d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): number */ TODO {
			/* TODO(Identifier): modifiers */
			/* TODO(BarToken): | */
			/* TODO(CallExpression): getEffectiveModifierFlags(d) */
		}, ModifierFlagsNone) & (ModifierFlagsIn | ModifierFlagsOut | ModifierFlagsConst)
	}
	hasCovariantVoidArgument := func(typeArguments []Type, variances []VarianceFlags) bool {
		/* TODO(ForStatement): for (let i = 0; i < variances.length; i++) {             if ((variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Covariant && typeArguments[i].flags & TypeFlags.Void) {                 return true;             }         } */
		return false
	}
	isUnconstrainedTypeParameter := func(type_ Type) /* TODO(undefined): boolean | 0 */ TODO {
		return type_.flags&TypeFlagsTypeParameter && !getConstraintOfTypeParameter(type_ /* as */ /* TODO(TypeReference): TypeParameter */)
	}
	isNonDeferredTypeReference := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && !(type_ /* as */ /* TODO(TypeReference): TypeReference */).node
	}
	isTypeReferenceWithGenericArguments := func(type_ Type) bool {
		return isNonDeferredTypeReference(type_) && some(getTypeArguments(type_), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !!(t.flags & TypeFlags.TypeParameter) */
			/* TODO(BarBarToken): || */
			/* TODO(CallExpression): isTypeReferenceWithGenericArguments(t) */
		})
	}
	getGenericTypeReferenceRelationKey := func(source TypeReference, target TypeReference, postFix string, ignoreConstraints bool) /* TODO(undefined): string */ TODO {
		var typeParameters []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		constraintMarker := ""
		sourceId := getTypeReferenceId(source, 0)
		targetId := getTypeReferenceId(target, 0)
		return /* TODO(TemplateExpression): `${constraintMarker}${sourceId},${targetId}${postFix}` */ TODO
		getTypeReferenceId := func(type_ TypeReference, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(undefined): string */ TODO {
			result := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + type.target.id */ TODO
			for _, t := range getTypeArguments(type_) {
				if t.flags & TypeFlagsTypeParameter {
					if ignoreConstraints || isUnconstrainedTypeParameter(t) {
						index := typeParameters.indexOf(t)
						if index < 0 {
							index = typeParameters.length
							typeParameters.push(t)
						}
						result += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "=" + index */ TODO
						/* TODO(ContinueStatement): continue; */
					}
					constraintMarker = "*"
				} else if depth < 4 && isTypeReferenceWithGenericArguments(t) {
					result += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "<" + getTypeReferenceId(t as TypeReference, depth + 1) + ">" */ TODO
					/* TODO(ContinueStatement): continue; */
				}
				result += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "-" + t.id */ TODO
			}
			return result
		}
	}
	getRelationKey := func(source Type, target Type, intersectionState IntersectionState, relation Map[string, RelationComparisonResult], ignoreConstraints bool) /* TODO(undefined): string */ TODO {
		if relation == identityRelation && source.id > target.id {
			temp := source
			source = target
			target = temp
		}
		postFix := /* TODO(ConditionalExpression): intersectionState ? ":" + intersectionState : "" */ TODO
		return /* TODO(ConditionalExpression): isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ?             getGenericTypeReferenceRelationKey(source as TypeReference, target as TypeReference, postFix, ignoreConstraints) :             `${source.id},${target.id}${postFix}` */ TODO
	}
	forEachProperty := func(prop Symbol, callback func(p Symbol) T) *T {
		if getCheckFlags(prop) & CheckFlagsSynthetic {
			for _, t := range /* TODO(NonNullExpression): (prop as TransientSymbol).links.containingType! */ TODO.types {
				p := getPropertyOfType(t, prop.escapedName)
				result := p && forEachProperty(p, callback)
				if result {
					return result
				}
			}
			return nil
		}
		return callback(prop)
	}
	getDeclaringClass := func(prop Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ TODO {
		return /* TODO(ConditionalExpression): prop.parent && prop.parent.flags & SymbolFlags.Class ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)!) as InterfaceType : undefined */ TODO
	}
	getTypeOfPropertyInBaseClass := func(property Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		classType := getDeclaringClass(property)
		baseClassType := classType && /* TODO(ElementAccessExpression): getBaseTypes(classType)[0] */ TODO
		return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName)
	}
	isPropertyInClassDerivedFrom := func(prop Symbol, baseClass *Type) /* TODO(undefined): boolean | undefined */ TODO {
		return forEachProperty(prop, func(sp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			sourceClass := getDeclaringClass(sp)
			return /* TODO(ConditionalExpression): sourceClass ? hasBaseType(sourceClass, baseClass) : false */ TODO
		})
	}
	isValidOverrideOf := func(sourceProp Symbol, targetProp Symbol) /* TODO(undefined): boolean */ TODO {
		return !forEachProperty(targetProp, func(tp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): getDeclarationModifierFlagsFromSymbol(tp) & ModifierFlags.Protected */
			/* TODO(QuestionToken): ? */
			/* TODO(PrefixUnaryExpression): !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) */
			/* TODO(ColonToken): : */
			/* TODO(FalseKeyword): false */
		})
	}
	isClassDerivedFromDeclaringClasses := func(checkClass T, prop Symbol, writing bool) /* TODO(undefined): T | undefined */ TODO {
		return /* TODO(ConditionalExpression): forEachProperty(prop, p =>                 getDeclarationModifierFlagsFromSymbol(p, writing) & ModifierFlags.Protected ?                     !hasBaseType(checkClass, getDeclaringClass(p)) : false) ? undefined : checkClass */ TODO
	}
	isDeeplyNestedType := func(type_ Type, stack []Type, depth number, maxDepth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 3 */) bool {
		if depth >= maxDepth {
			if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
				type_ = getMappedTargetWithSymbol(type_)
			}
			if type_.flags & TypeFlagsIntersection {
				return some((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): isDeeplyNestedType */
					/* TODO(Identifier): t */
					/* TODO(Identifier): stack */
					/* TODO(Identifier): depth */
					/* TODO(Identifier): maxDepth */
				})
			}
			identity := getRecursionIdentity(type_)
			count := 0
			lastTypeId := 0
			/* TODO(ForStatement): for (let i = 0; i < depth; i++) {                 const t = stack[i];                 if (hasMatchingRecursionIdentity(t, identity)) {                     // We only count occurrences with a higher type id than the previous occurrence, since higher                     // type ids are an indicator of newer instantiations caused by recursion.                     if (t.id >= lastTypeId) {                         count++;                         if (count >= maxDepth) {                             return true;                         }                     }                     lastTypeId = t.id;                 }             } */
		}
		return false
	}
	getMappedTargetWithSymbol := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var target TODO
		/* TODO(WhileStatement): while (             (getObjectFlags(type) & ObjectFlags.InstantiatedMapped) === ObjectFlags.InstantiatedMapped &&             (target = getModifiersTypeFromMappedType(type as MappedType)) &&             (target.symbol || target.flags & TypeFlags.Intersection && some((target as IntersectionType).types, t => !!t.symbol))         ) {             type = target;         } */
		return type_
	}
	hasMatchingRecursionIdentity := func(type_ Type, identity /* TODO(ObjectKeyword): object */ TODO) bool {
		if (getObjectFlags(type_) & ObjectFlagsInstantiatedMapped) == ObjectFlagsInstantiatedMapped {
			type_ = getMappedTargetWithSymbol(type_)
		}
		if type_.flags & TypeFlagsIntersection {
			return some((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): hasMatchingRecursionIdentity */
				/* TODO(Identifier): t */
				/* TODO(Identifier): identity */
			})
		}
		return getRecursionIdentity(type_) == identity
	}
	getRecursionIdentity := func(type_ Type) /* TODO(ObjectKeyword): object */ TODO {
		if type_.flags&TypeFlagsObject && !isObjectOrArrayLiteralType(type_) {
			if getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as */ /* TODO(TypeReference): TypeReference */).node {
				return /* TODO(NonNullExpression): (type as TypeReference).node! */ TODO
			}
			if type_.symbol && !(getObjectFlags(type_)&ObjectFlagsAnonymous && type_.symbol.flags&SymbolFlagsClass) {
				return type_.symbol
			}
			if isTupleType(type_) {
				return type_.target
			}
		}
		if type_.flags & TypeFlagsTypeParameter {
			return type_.symbol
		}
		if type_.flags & TypeFlagsIndexedAccess {
			/* TODO(DoStatement): do {                 type = (type as IndexedAccessType).objectType;             }             while (type.flags & TypeFlags.IndexedAccess); */
			return type_
		}
		if type_.flags & TypeFlagsConditional {
			return (type_ /* as */ /* TODO(TypeReference): ConditionalType */).root
		}
		return type_
	}
	isPropertyIdenticalTo := func(sourceProp Symbol, targetProp Symbol) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): compareProperties(sourceProp, targetProp, compareTypesIdentical) !== Ternary.False */ TODO
	}
	compareProperties := func(sourceProp Symbol, targetProp Symbol, compareTypes func(source Type, target Type) Ternary) Ternary {
		if sourceProp == targetProp {
			return TernaryTrue
		}
		sourcePropAccessibility := getDeclarationModifierFlagsFromSymbol(sourceProp) & ModifierFlagsNonPublicAccessibilityModifier
		targetPropAccessibility := getDeclarationModifierFlagsFromSymbol(targetProp) & ModifierFlagsNonPublicAccessibilityModifier
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourcePropAccessibility !== targetPropAccessibility */ TODO {
			return TernaryFalse
		}
		if sourcePropAccessibility {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp) */ TODO {
				return TernaryFalse
			}
		} else {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (sourceProp.flags & SymbolFlags.Optional) !== (targetProp.flags & SymbolFlags.Optional) */ TODO {
				return TernaryFalse
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp) */ TODO {
			return TernaryFalse
		}
		return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp))
	}
	isMatchingSignature := func(source Signature, target Signature, partialMatch bool) /* TODO(undefined): boolean */ TODO {
		sourceParameterCount := getParameterCount(source)
		targetParameterCount := getParameterCount(target)
		sourceMinArgumentCount := getMinArgumentCount(source)
		targetMinArgumentCount := getMinArgumentCount(target)
		sourceHasRestParameter := hasEffectiveRestParameter(source)
		targetHasRestParameter := hasEffectiveRestParameter(target)
		if sourceParameterCount == targetParameterCount && sourceMinArgumentCount == targetMinArgumentCount && sourceHasRestParameter == targetHasRestParameter {
			return true
		}
		if partialMatch && sourceMinArgumentCount <= targetMinArgumentCount {
			return true
		}
		return false
	}
	compareSignaturesIdentical := func(source Signature, target Signature, partialMatch bool, ignoreThisTypes bool, ignoreReturnTypes bool, compareTypes func(s Type, t Type) Ternary) Ternary {
		if source == target {
			return TernaryTrue
		}
		if !(isMatchingSignature(source, target, partialMatch)) {
			return TernaryFalse
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): length(source.typeParameters) !== length(target.typeParameters) */ TODO {
			return TernaryFalse
		}
		if target.typeParameters {
			mapper := createTypeMapper( /* TODO(NonNullExpression): source.typeParameters! */ TODO, target.typeParameters)
			/* TODO(ForStatement): for (let i = 0; i < target.typeParameters.length; i++) {                 const s = source.typeParameters![i];                 const t = target.typeParameters[i];                 if (                     !(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) &&                             compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))                 ) {                     return Ternary.False;                 }             } */
			source = instantiateSignature(source, mapper, true)
		}
		result := TernaryTrue
		if !ignoreThisTypes {
			sourceThisType := getThisTypeOfSignature(source)
			if sourceThisType {
				targetThisType := getThisTypeOfSignature(target)
				if targetThisType {
					related := compareTypes(sourceThisType, targetThisType)
					if !related {
						return TernaryFalse
					}
					result &= related
				}
			}
		}
		targetLen := getParameterCount(target)
		/* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {             const s = getTypeAtPosition(source, i);             const t = getTypeAtPosition(target, i);             const related = compareTypes(t, s);             if (!related) {                 return Ternary.False;             }             result &= related;         } */
		if !ignoreReturnTypes {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			targetTypePredicate := getTypePredicateOfSignature(target)
			result &= /* TODO(ConditionalExpression): sourceTypePredicate || targetTypePredicate ?                 compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) :                 compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target)) */ TODO
		}
		return result
	}
	compareTypePredicatesIdentical := func(source *TypePredicate, target *TypePredicate, compareTypes func(s Type, t Type) Ternary) Ternary {
		return /* TODO(ConditionalExpression): !(source && target && typePredicateKindsMatch(source, target)) ? Ternary.False :             source.type === target.type ? Ternary.True :             source.type && target.type ? compareTypes(source.type, target.type) :             Ternary.False */ TODO
	}
	literalTypesWithSameBaseType := func(types []Type) bool {
		var commonBaseType *Type
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				baseType := getBaseTypeOfLiteralType(t)
				/* TODO(ExpressionStatement): commonBaseType ??= baseType; */
				if baseType == t || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseType !== commonBaseType */ TODO {
					return false
				}
			}
		}
		return true
	}
	getCombinedTypeFlags := func(types []Type) TypeFlags {
		return reduceLeft(types, func(flags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeFlags */ TODO, t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): number */ TODO {
			/* TODO(Identifier): flags */
			/* TODO(BarToken): | */
			/* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Union ? getCombinedTypeFlags((t as UnionType).types) : t.flags) */
		}, 0 /* as */ /* TODO(TypeReference): TypeFlags */)
	}
	getCommonSupertype := func(types []Type) Type {
		if types.length == 1 {
			return /* TODO(ElementAccessExpression): types[0] */ TODO
		}
		primaryTypes := /* TODO(ConditionalExpression): strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & TypeFlags.Nullable))) : types */ TODO
		superTypeOrUnion := /* TODO(ConditionalExpression): literalTypesWithSameBaseType(primaryTypes) ?             getUnionType(primaryTypes) :             reduceLeft(primaryTypes, (s, t) => isTypeSubtypeOf(s, t) ? t : s)! */ TODO
		return /* TODO(ConditionalExpression): primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & TypeFlags.Nullable) */ TODO
	}
	getCommonSubtype := func(types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(NonNullExpression): reduceLeft(types, (s, t) => isTypeSubtypeOf(t, s) ? t : s)! */ TODO
	}
	isArrayType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && ((type_ /* as */ /* TODO(TypeReference): TypeReference */).target == globalArrayType || (type_ /* as */ /* TODO(TypeReference): TypeReference */).target == globalReadonlyArrayType)
	}
	isReadonlyArrayType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsReference) && (type_ /* as */ /* TODO(TypeReference): TypeReference */).target == globalReadonlyArrayType
	}
	isArrayOrTupleType := func(type_ Type) /* TODO(TypePredicate): type is TypeReference */ TODO {
		return isArrayType(type_) || isTupleType(type_)
	}
	isMutableArrayOrTuple := func(type_ Type) bool {
		return isArrayType(type_) && !isReadonlyArrayType(type_) || isTupleType(type_) && !type_.target.readonly
	}
	getElementTypeOfArrayType := func(type_ Type) *Type {
		return /* TODO(ConditionalExpression): isArrayType(type) ? getTypeArguments(type)[0] : undefined */ TODO
	}
	isArrayLikeType := func(type_ Type) bool {
		return isArrayType(type_) || !(type_.flags&TypeFlagsNullable) && isTypeAssignableTo(type_, anyReadonlyArrayType)
	}
	isMutableArrayLikeType := func(type_ Type) bool {
		return isMutableArrayOrTuple(type_) || !(type_.flags&(TypeFlagsAny|TypeFlagsNullable)) && isTypeAssignableTo(type_, anyArrayType)
	}
	getSingleBaseForNonAugmentingSubtype := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if !(getObjectFlags(type_) & ObjectFlagsReference) || !(getObjectFlags((type_ /* as */ /* TODO(TypeReference): TypeReference */).target) & ObjectFlagsClassOrInterface) {
			return nil
		}
		if getObjectFlags(type_) & ObjectFlagsIdenticalBaseTypeCalculated {
			return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.IdenticalBaseTypeExists ? (type as TypeReference).cachedEquivalentBaseType : undefined */ TODO
		}
		(type_ /* as */ /* TODO(TypeReference): TypeReference */).objectFlags |= ObjectFlagsIdenticalBaseTypeCalculated
		target := (type_ /* as */ /* TODO(TypeReference): TypeReference */).target /* as */ /* TODO(TypeReference): InterfaceType */
		if getObjectFlags(target) & ObjectFlagsClass {
			baseTypeNode := getBaseTypeNodeOfClass(target)
			if baseTypeNode && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseTypeNode.expression.kind !== SyntaxKind.Identifier */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): baseTypeNode.expression.kind !== SyntaxKind.PropertyAccessExpression */ TODO {
				return nil
			}
		}
		bases := getBaseTypes(target)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): bases.length !== 1 */ TODO {
			return nil
		}
		if getMembersOfSymbol(type_.symbol).size {
			return nil
		}
		instantiatedBase := /* TODO(ConditionalExpression): !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters!, getTypeArguments(type as TypeReference).slice(0, target.typeParameters!.length))) */ TODO
		if length(getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)) > length(target.typeParameters) {
			instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */)))
		}
		(type_ /* as */ /* TODO(TypeReference): TypeReference */).objectFlags |= ObjectFlagsIdenticalBaseTypeExists
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as TypeReference).cachedEquivalentBaseType = instantiatedBase */ TODO
	}
	isEmptyLiteralType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): strictNullChecks ? type === implicitNeverType : type === undefinedWideningType */ TODO
	}
	isEmptyArrayLiteralType := func(type_ Type) bool {
		elementType := getElementTypeOfArrayType(type_)
		return !!elementType && isEmptyLiteralType(elementType)
	}
	isTupleLikeType := func(type_ Type) bool {
		var lengthType TODO
		return isTupleType(type_) || !!getPropertyOfType(type_, "0" /* as */ /* TODO(TypeReference): __String */) || isArrayLikeType(type_) && !!( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): lengthType = getTypeOfPropertyOfType(type, "length" as __String) */ TODO) && everyType(lengthType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.NumberLiteral) */
		})
	}
	isArrayOrTupleLikeType := func(type_ Type) bool {
		return isArrayLikeType(type_) || isTupleLikeType(type_)
	}
	getTupleElementType := func(type_ Type, index number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		propType := getTypeOfPropertyOfType(type_ /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + index */, TODO /* as */ /* TODO(TypeReference): __String */)
		if propType {
			return propType
		}
		if everyType(type_, isTupleType) {
			return getTupleElementTypeOutOfStartCount(type_, index /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefinedType : undefined */, TODO)
		}
		return nil
	}
	isNeitherUnitTypeNorNever := func(type_ Type) bool {
		return !(type_.flags & (TypeFlagsUnit | TypeFlagsNever))
	}
	isUnitType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsUnit)
	}
	isUnitLikeType := func(type_ Type) bool {
		t := getBaseConstraintOrType(type_)
		return /* TODO(ConditionalExpression): t.flags & TypeFlags.Intersection ? some((t as IntersectionType).types, isUnitType) : isUnitType(t) */ TODO
	}
	extractUnitType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ? find((type as IntersectionType).types, isUnitType) || type : type */ TODO
	}
	isLiteralType := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Boolean ? true :             type.flags & TypeFlags.Union ? type.flags & TypeFlags.EnumLiteral ? true : every((type as UnionType).types, isUnitType) :             isUnitType(type) */ TODO
	}
	getBaseTypeOfLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & TypeFlags.NumberLiteral ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? getBaseTypeOfLiteralTypeUnion(type as UnionType) :             type */ TODO
	}
	getBaseTypeOfLiteralTypeUnion := func(type_ UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `B${getTypeId(type)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, mapType(type, getBaseTypeOfLiteralType)) */ TODO
	}
	getBaseTypeOfLiteralTypeForComparison := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? stringType :             type.flags & (TypeFlags.NumberLiteral | TypeFlags.Enum) ? numberType :             type.flags & TypeFlags.BigIntLiteral ? bigintType :             type.flags & TypeFlags.BooleanLiteral ? booleanType :             type.flags & TypeFlags.Union ? mapType(type, getBaseTypeOfLiteralTypeForComparison) :             type */ TODO
	}
	getWidenedLiteralType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike && isFreshLiteralType(type) ? getBaseTypeOfEnumLikeType(type as LiteralType) :             type.flags & TypeFlags.StringLiteral && isFreshLiteralType(type) ? stringType :             type.flags & TypeFlags.NumberLiteral && isFreshLiteralType(type) ? numberType :             type.flags & TypeFlags.BigIntLiteral && isFreshLiteralType(type) ? bigintType :             type.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(type) ? booleanType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedLiteralType) :             type */ TODO
	}
	getWidenedUniqueESSymbolType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? esSymbolType :             type.flags & TypeFlags.Union ? mapType(type as UnionType, getWidenedUniqueESSymbolType) :             type */ TODO
	}
	getWidenedLiteralLikeTypeForContextualType := func(type_ Type, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !isLiteralOfContextualType(type_, contextualType) {
			type_ = getWidenedUniqueESSymbolType(getWidenedLiteralType(type_))
		}
		return getRegularTypeOfLiteralType(type_)
	}
	getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, isAsync bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) :                 contextualSignatureReturnType */ TODO
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded := func(type_ *Type, contextualSignatureReturnType *Type, kind IterationTypeKind, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if type_ && isUnitType(type_) {
			contextualType := /* TODO(ConditionalExpression): !contextualSignatureReturnType ? undefined :                 getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator) */ TODO
			type_ = getWidenedLiteralLikeTypeForContextualType(type_, contextualType)
		}
		return type_
	}
	isTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
		return !!(getObjectFlags(type_)&ObjectFlagsReference && (type_ /* as */ /* TODO(TypeReference): TypeReference */).target.objectFlags&ObjectFlagsTuple)
	}
	isGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
		return isTupleType(type_) && !!(type_.target.combinedFlags & ElementFlagsVariadic)
	}
	isSingleElementGenericTupleType := func(type_ Type) /* TODO(TypePredicate): type is TupleTypeReference */ TODO {
		return isGenericTupleType(type_) && type_.target.elementFlags.length == 1
	}
	getRestTypeOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength)
	}
	getTupleElementTypeOutOfStartCount := func(type_ Type, index number, undefinedOrMissingType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			tupleType := t /* as */ /* TODO(TypeReference): TupleTypeReference */
			restType := getRestTypeOfTupleType(tupleType)
			if !restType {
				return undefinedType
			}
			if undefinedOrMissingType && index >= getTotalFixedElementCount(tupleType.target) {
				return getUnionType( /* TODO(ArrayLiteralExpression): [restType, undefinedOrMissingType] */ TODO)
			}
			return restType
		})
	}
	getRestArrayTypeOfTupleType := func(type_ TupleTypeReference) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType | undefined */ TODO {
		restType := getRestTypeOfTupleType(type_)
		return restType && createArrayType(restType)
	}
	getElementTypeOfSliceOfTupleType := func(type_ TupleTypeReference, index number, endSkipCount /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */, writing /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */, noReductions /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		length := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): getTypeReferenceArity(type) - endSkipCount */ TODO
		if index < length {
			typeArguments := getTypeArguments(type_)
			var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(ForStatement): for (let i = index; i < length; i++) {                 const t = typeArguments[i];                 elementTypes.push(type.target.elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessType(t, numberType) : t);             } */
			return /* TODO(ConditionalExpression): writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) */ TODO
		}
		return nil
	}
	isTupleTypeStructureMatching := func(t1 TupleTypeReference, t2 TupleTypeReference) /* TODO(undefined): boolean */ TODO {
		return getTypeReferenceArity(t1) == getTypeReferenceArity(t2) && every(t1.target.elementFlags, func(f /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(ParenthesizedExpression): (f & ElementFlags.Variable) */
			/* TODO(EqualsEqualsEqualsToken): === */
			/* TODO(ParenthesizedExpression): (t2.target.elementFlags[i] & ElementFlags.Variable) */
		})
	}
	isZeroBigInt := func(TODO_IDENTIFIER BigIntLiteralType) /* TODO(undefined): boolean */ TODO {
		return value.base10Value == "0"
	}
	removeDefinitelyFalsyTypes := func(type_ Type) Type {
		return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): hasTypeFacts */
			/* TODO(Identifier): t */
			/* TODO(PropertyAccessExpression): TypeFacts.Truthy */
		})
	}
	extractDefinitelyFalsyTypes := func(type_ Type) Type {
		return mapType(type_, getDefinitelyFalsyPartOfType)
	}
	getDefinitelyFalsyPartOfType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? emptyStringType :             type.flags & TypeFlags.Number ? zeroType :             type.flags & TypeFlags.BigInt ? zeroBigIntType :             type === regularFalseType ||                 type === falseType ||                 type.flags & (TypeFlags.Void | TypeFlags.Undefined | TypeFlags.Null | TypeFlags.AnyOrUnknown) ||                 type.flags & TypeFlags.StringLiteral && (type as StringLiteralType).value === "" ||                 type.flags & TypeFlags.NumberLiteral && (type as NumberLiteralType).value === 0 ||                 type.flags & TypeFlags.BigIntLiteral && isZeroBigInt(type as BigIntLiteralType) ? type :             neverType */ TODO
	}
	getNullableType := func(type_ Type, flags TypeFlags) Type {
		missing := (flags & ~type_.flags) & (TypeFlagsUndefined | TypeFlagsNull)
		return /* TODO(ConditionalExpression): missing === 0 ? type :             missing === TypeFlags.Undefined ? getUnionType([type, undefinedType]) :             missing === TypeFlags.Null ? getUnionType([type, nullType]) :             getUnionType([type, undefinedType, nullType]) */ TODO
	}
	getOptionalType := func(type_ Type, isProperty /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) Type {
		Debug.assert(strictNullChecks)
		missingOrUndefined := /* TODO(ConditionalExpression): isProperty ? undefinedOrMissingType : undefinedType */ TODO
		return /* TODO(ConditionalExpression): type === missingOrUndefined || type.flags & TypeFlags.Union && (type as UnionType).types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]) */ TODO
	}
	getGlobalNonNullableTypeInstantiation := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !deferredGlobalNonNullableTypeAlias {
			deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable" /* as */ /* TODO(TypeReference): __String */, SymbolFlagsTypeAlias, nil) || unknownSymbol
		}
		return /* TODO(ConditionalExpression): deferredGlobalNonNullableTypeAlias !== unknownSymbol ?             getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) :             getIntersectionType([type, emptyObjectType]) */ TODO
	}
	getNonNullableType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): strictNullChecks ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
	}
	addOptionalTypeMarker := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): strictNullChecks ? getUnionType([type, optionalType]) : type */ TODO
	}
	removeOptionalTypeMarker := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): strictNullChecks ? removeType(type, optionalType) : type */ TODO
	}
	propagateOptionalTypeMarker := func(type_ Type, node OptionalChain, wasOptional bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type */ TODO
	}
	getOptionalExpressionType := func(exprType Type, expression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) :             isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) :             exprType */ TODO
	}
	removeMissingType := func(type_ Type, isOptional bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type */ TODO
	}
	containsMissingType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return type_ == missingType || !!(type_.flags&TypeFlagsUnion) && /* TODO(ElementAccessExpression): (type as UnionType).types[0] */ TODO == missingType
	}
	removeMissingOrUndefinedType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, TypeFacts.NEUndefined) */ TODO
	}
	isCoercibleUnderDoubleEquals := func(source Type, target Type) bool {
		return ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (source.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.BooleanLiteral)) !== 0 */ TODO) && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (target.flags & (TypeFlags.Number | TypeFlags.String | TypeFlags.Boolean)) !== 0 */ TODO)
	}
	isObjectTypeWithInferableIndex := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection             ? every((type as IntersectionType).types, isObjectTypeWithInferableIndex)             : !!(                 type.symbol                 && (type.symbol.flags & (SymbolFlags.ObjectLiteral | SymbolFlags.TypeLiteral | SymbolFlags.Enum | SymbolFlags.ValueModule)) !== 0                 && !(type.symbol.flags & SymbolFlags.Class)                 && !typeHasCallOrConstructSignatures(type)             ) || !!(                 objectFlags & ObjectFlags.ObjectRestType             ) || !!(objectFlags & ObjectFlags.ReverseMapped && isObjectTypeWithInferableIndex((type as ReverseMappedType).source)) */ TODO
	}
	createSymbolWithType := func(source Symbol, type_ *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol */ TODO {
		symbol := createSymbol(source.flags, source.escapedName, getCheckFlags(source)&CheckFlagsReadonly)
		symbol.declarations = source.declarations
		symbol.parent = source.parent
		symbol.links.type_ = type_
		symbol.links.target = source
		if source.valueDeclaration {
			symbol.valueDeclaration = source.valueDeclaration
		}
		nameType := getSymbolLinks(source).nameType
		if nameType {
			symbol.links.nameType = nameType
		}
		return symbol
	}
	transformTypeOfMembers := func(type_ Type, f func(propertyType Type) Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SymbolTable */ TODO {
		members := createSymbolTable()
		for _, property := range getPropertiesOfObjectType(type_) {
			original := getTypeOfSymbol(property)
			updated := f(original)
			members.set(property.escapedName /* TODO(ConditionalExpression): updated === original ? property : createSymbolWithType(property, updated) */, TODO)
		}
		return members
	}
	getRegularTypeOfObjectLiteral := func(type_ Type) Type {
		if !(isObjectLiteralType(type_) && getObjectFlags(type_)&ObjectFlagsFreshLiteral) {
			return type_
		}
		regularType := (type_ /* as */ /* TODO(TypeReference): FreshObjectLiteralType */).regularType
		if regularType {
			return regularType
		}
		resolved := type_ /* as */ /* TODO(TypeReference): ResolvedType */
		members := transformTypeOfMembers(type_, getRegularTypeOfObjectLiteral)
		regularNew := createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos)
		regularNew.flags = resolved.flags
		regularNew.objectFlags |= resolved.objectFlags & ~ObjectFlagsFreshLiteral
		(type_ /* as */ /* TODO(TypeReference): FreshObjectLiteralType */).regularType = regularNew
		return regularNew
	}
	createWideningContext := func(parent *WideningContext, propertyName *__String, siblings /* TODO(ArrayType): Type[] */ any) WideningContext {
		return /* TODO(ObjectLiteralExpression): { parent, propertyName, siblings, resolvedProperties: undefined } */ TODO
	}
	getSiblingsOfContext := func(context WideningContext) []Type {
		if !context.siblings {
			var siblings []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, type_ := range getSiblingsOfContext( /* TODO(NonNullExpression): context.parent! */ TODO) {
				if isObjectLiteralType(type_) {
					prop := getPropertyOfObjectType(type_ /* TODO(NonNullExpression): context.propertyName! */, TODO)
					if prop {
						forEachType(getTypeOfSymbol(prop), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
							siblings.push(t)
						})
					}
				}
			}
			context.siblings = siblings
		}
		return context.siblings
	}
	getPropertiesOfContext := func(context WideningContext) []Symbol {
		if !context.resolvedProperties {
			names := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
			for _, t := range getSiblingsOfContext(context) {
				if isObjectLiteralType(t) && !(getObjectFlags(t) & ObjectFlagsContainsSpread) {
					for _, prop := range getPropertiesOfType(t) {
						names.set(prop.escapedName, prop)
					}
				}
			}
			context.resolvedProperties = arrayFrom(names.values())
		}
		return context.resolvedProperties
	}
	getWidenedProperty := func(prop Symbol, context *WideningContext) Symbol {
		if !(prop.flags & SymbolFlagsProperty) {
			return prop
		}
		original := getTypeOfSymbol(prop)
		propContext := context && createWideningContext(context, prop.escapedName, nil)
		widened := getWidenedTypeWithContext(original, propContext)
		return /* TODO(ConditionalExpression): widened === original ? prop : createSymbolWithType(prop, widened) */ TODO
	}
	getUndefinedProperty := func(prop Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		cached := undefinedProperties.get(prop.escapedName)
		if cached {
			return cached
		}
		result := createSymbolWithType(prop, undefinedOrMissingType)
		result.flags |= SymbolFlagsOptional
		undefinedProperties.set(prop.escapedName, result)
		return result
	}
	getWidenedTypeOfObjectLiteral := func(type_ Type, context *WideningContext) Type {
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, getWidenedProperty(prop, context))
		}
		if context {
			for _, prop := range getPropertiesOfContext(context) {
				if !members.has(prop.escapedName) {
					members.set(prop.escapedName, getUndefinedProperty(prop))
				}
			}
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type_), func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO {
			/* TODO(Identifier): createIndexInfo */
			/* TODO(PropertyAccessExpression): info.keyType */
			/* TODO(CallExpression): getWidenedType(info.type) */
			/* TODO(PropertyAccessExpression): info.isReadonly */
		}))
		result.objectFlags |= getObjectFlags(type_) & (ObjectFlagsJSLiteral | ObjectFlagsNonInferrableType)
		return result
	}
	getWidenedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getWidenedTypeWithContext(type_, nil)
	}
	getWidenedTypeWithContext := func(type_ Type, context *WideningContext) Type {
		if getObjectFlags(type_) & ObjectFlagsRequiresWidening {
			if context == nil && type_.widened {
				return type_.widened
			}
			var result *Type
			if type_.flags & (TypeFlagsAny | TypeFlagsNullable) {
				result = anyType
			} else if isObjectLiteralType(type_) {
				result = getWidenedTypeOfObjectLiteral(type_, context)
			} else if type_.flags & TypeFlagsUnion {
				unionContext := context || createWideningContext(nil, nil, (type_ /* as */ /* TODO(TypeReference): UnionType */).types)
				widenedTypes := sameMap((type_ /* as */ /* TODO(TypeReference): UnionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(BinaryExpression): t.flags & TypeFlags.Nullable */
					/* TODO(QuestionToken): ? */
					/* TODO(Identifier): t */
					/* TODO(ColonToken): : */
					/* TODO(CallExpression): getWidenedTypeWithContext(t, unionContext) */
				})
				result = getUnionType(widenedTypes /* TODO(ConditionalExpression): some(widenedTypes, isEmptyObjectType) ? UnionReduction.Subtype : UnionReduction.Literal */, TODO)
			} else if type_.flags & TypeFlagsIntersection {
				result = getIntersectionType(sameMap((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, getWidenedType))
			} else if isArrayOrTupleType(type_) {
				result = createTypeReference(type_.target, sameMap(getTypeArguments(type_), getWidenedType))
			}
			if result && context == nil {
				type_.widened = result
			}
			return result || type_
		}
		return type_
	}
	reportWideningErrorsInType := func(type_ Type) bool {
		errorReported := false
		if getObjectFlags(type_) & ObjectFlagsContainsWideningType {
			if type_.flags & TypeFlagsUnion {
				if some((type_ /* as */ /* TODO(TypeReference): UnionType */).types, isEmptyObjectType) {
					errorReported = true
				} else {
					for _, t := range (type_ /* as */ /* TODO(TypeReference): UnionType */).types {
						/* TODO(ExpressionStatement): errorReported ||= reportWideningErrorsInType(t); */
					}
				}
			} else if isArrayOrTupleType(type_) {
				for _, t := range getTypeArguments(type_) {
					/* TODO(ExpressionStatement): errorReported ||= reportWideningErrorsInType(t); */
				}
			} else if isObjectLiteralType(type_) {
				for _, p := range getPropertiesOfObjectType(type_) {
					t := getTypeOfSymbol(p)
					if getObjectFlags(t) & ObjectFlagsContainsWideningType {
						errorReported = reportWideningErrorsInType(t)
						if !errorReported {
							valueDeclaration := p.declarations.find(func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
								/* TODO(PropertyAccessExpression): d.symbol.valueDeclaration?.parent */
								/* TODO(EqualsEqualsEqualsToken): === */
								/* TODO(PropertyAccessExpression): type.symbol.valueDeclaration */
							})
							if valueDeclaration {
								error(valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)))
								errorReported = true
							}
						}
					}
				}
			}
		}
		return errorReported
	}
	reportImplicitAny := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		typeAsString := typeToString(getWidenedType(type_))
		if isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions) {
			return
		}
		var diagnostic DiagnosticMessage
		/* TODO(SwitchStatement): switch (declaration.kind) {             case SyntaxKind.BinaryExpression:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:                 diagnostic = noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;                 break;             case SyntaxKind.Parameter:                 const param = declaration as ParameterDeclaration;                 if (isIdentifier(param.name)) {                     const originalKeywordKind = identifierToKeywordKind(param.name);                     if (                         (isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) &&                         param.parent.parameters.includes(param) &&                         (resolveName(param, param.name.escapedText, SymbolFlags.Type, /*nameNotFoundMessage* / undefined, /*isUse* / true) ||                             originalKeywordKind && isTypeNodeKind(originalKeywordKind))                     ) {                         const newName = "arg" + param.parent.parameters.indexOf(param);                         const typeName = declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");                         errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName);                         return;                     }                 }                 diagnostic = (declaration as ParameterDeclaration).dotDotDotToken ?                     noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage :                     noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;                 break;             case SyntaxKind.BindingElement:                 diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type;                 if (!noImplicitAny) {                     // Don't issue a suggestion for binding elements since the codefix doesn't yet support them.                     return;                 }                 break;             case SyntaxKind.JSDocFunctionType:                 error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);                 return;             case SyntaxKind.JSDocSignature:                 if (noImplicitAny && isJSDocOverloadTag(declaration.parent)) {                     error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString);                 }                 return;             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 if (noImplicitAny && !(declaration as NamedDeclaration).name) {                     if (wideningKind === WideningKind.GeneratorYield) {                         error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString);                     }                     else {                         error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);                     }                     return;                 }                 diagnostic = !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage :                     wideningKind === WideningKind.GeneratorYield ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type :                     Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;                 break;             case SyntaxKind.MappedType:                 if (noImplicitAny) {                     error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type);                 }                 return;             default:                 diagnostic = noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;         } */
		errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString)
	}
	reportErrorsFromWidening := func(declaration Declaration, type_ Type, wideningKind WideningKind) {
		addLazyDiagnostic(func() {
			if noImplicitAny && getObjectFlags(type_)&ObjectFlagsContainsWideningType && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)) {
				if !reportWideningErrorsInType(type_) {
					reportImplicitAny(declaration, type_, wideningKind)
				}
			}
		})
	}
	applyToParameterTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		sourceCount := getParameterCount(source)
		targetCount := getParameterCount(target)
		sourceRestType := getEffectiveRestType(source)
		targetRestType := getEffectiveRestType(target)
		targetNonRestCount := /* TODO(ConditionalExpression): targetRestType ? targetCount - 1 : targetCount */ TODO
		paramCount := /* TODO(ConditionalExpression): sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount) */ TODO
		sourceThisType := getThisTypeOfSignature(source)
		if sourceThisType {
			targetThisType := getThisTypeOfSignature(target)
			if targetThisType {
				callback(sourceThisType, targetThisType)
			}
		}
		/* TODO(ForStatement): for (let i = 0; i < paramCount; i++) {             callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));         } */
		if targetRestType {
			callback(getRestTypeAtPosition(source, paramCount, isConstTypeVariable(targetRestType) && !someType(targetRestType, isMutableArrayLikeType)), targetRestType)
		}
	}
	applyToReturnTypes := func(source Signature, target Signature, callback func(s Type, t Type)) {
		targetTypePredicate := getTypePredicateOfSignature(target)
		if targetTypePredicate {
			sourceTypePredicate := getTypePredicateOfSignature(source)
			if sourceTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type_ && targetTypePredicate.type_ {
				callback(sourceTypePredicate.type_, targetTypePredicate.type_)
				return
			}
		}
		targetReturnType := getReturnTypeOfSignature(target)
		if couldContainTypeVariables(targetReturnType) {
			callback(getReturnTypeOfSignature(source), targetReturnType)
		}
	}
	createInferenceContext := func(typeParameters []TypeParameter, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		return createInferenceContextWorker(typeParameters.map_(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable)
	}
	cloneInferenceContext := func(context T, extraFlags InferenceFlags /* = */ /* TODO(NumericLiteral): 0 */) /* TODO(UnionType): InferenceContext | T & undefined */ any {
		return context && createInferenceContextWorker(map_(context.inferences, cloneInferenceInfo), context.signature, context.flags|extraFlags, context.compareTypes)
	}
	createInferenceContextWorker := func(inferences []InferenceInfo, signature *Signature, flags InferenceFlags, compareTypes TypeComparer) InferenceContext {
		var context InferenceContext = /* TODO(ObjectLiteralExpression): {             inferences,             signature,             flags,             compareTypes,             mapper: reportUnmeasurableMapper, // initialize to a noop mapper so the context object is available, but the underlying object shape is right upon construction             nonFixingMapper: reportUnmeasurableMapper,         } */ TODO
		context.mapper = makeFixingMapperForContext(context)
		context.nonFixingMapper = makeNonFixingMapperForContext(context)
		return context
	}
	makeFixingMapperForContext := func(context InferenceContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return makeDeferredTypeMapper(map_(context.inferences, func(i /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			/* TODO(Identifier): i */
			/* TODO(Identifier): typeParameter */
		}), map_(context.inferences, func(inference /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(EqualsGreaterThanToken): => */
			/* TODO(Block): {                 if (!inference.isFixed) {                     // Before we commit to a particular inference (and thus lock out any further inferences),                     // we infer from any intra-expression inference sites we have collected.                     inferFromIntraExpressionSites(context);                     clearCachedInferences(context.inferences);                     inference.isFixed = true;                 }                 return getInferredType(context, i);             } */
		}))
	}
	makeNonFixingMapperForContext := func(context InferenceContext) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeMapper */ TODO {
		return makeDeferredTypeMapper(map_(context.inferences, func(i /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO {
			/* TODO(Identifier): i */
			/* TODO(Identifier): typeParameter */
		}), map_(context.inferences, func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): () => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(EqualsGreaterThanToken): => */
			/* TODO(Block): {                 return getInferredType(context, i);             } */
		}))
	}
	clearCachedInferences := func(inferences []InferenceInfo) {
		for _, inference := range inferences {
			if !inference.isFixed {
				inference.inferredType = nil
			}
		}
	}
	addIntraExpressionInferenceSite := func(context InferenceContext, node /* TODO(UnionType): Expression | MethodDeclaration */ any, type_ Type) {
		( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): context.intraExpressionInferenceSites ??= [] */ TODO).push( /* TODO(ObjectLiteralExpression): { node, type } */ TODO)
	}
	inferFromIntraExpressionSites := func(context InferenceContext) {
		if context.intraExpressionInferenceSites {
			for _, TODO_IDENTIFIER := range context.intraExpressionInferenceSites {
				contextualType := /* TODO(ConditionalExpression): node.kind === SyntaxKind.MethodDeclaration ?                     getContextualTypeForObjectLiteralMethod(node as MethodDeclaration, ContextFlags.NoConstraints) :                     getContextualType(node, ContextFlags.NoConstraints) */ TODO
				if contextualType {
					inferTypes(context.inferences, type_, contextualType)
				}
			}
			context.intraExpressionInferenceSites = nil
		}
	}
	createInferenceInfo := func(typeParameter TypeParameter) InferenceInfo {
		return /* TODO(ObjectLiteralExpression): {             typeParameter,             candidates: undefined,             contraCandidates: undefined,             inferredType: undefined,             priority: undefined,             topLevel: true,             isFixed: false,             impliedArity: undefined,         } */ TODO
	}
	cloneInferenceInfo := func(inference InferenceInfo) InferenceInfo {
		return /* TODO(ObjectLiteralExpression): {             typeParameter: inference.typeParameter,             candidates: inference.candidates && inference.candidates.slice(),             contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),             inferredType: inference.inferredType,             priority: inference.priority,             topLevel: inference.topLevel,             isFixed: inference.isFixed,             impliedArity: inference.impliedArity,         } */ TODO
	}
	cloneInferredPartOfContext := func(context InferenceContext) *InferenceContext {
		inferences := filter(context.inferences, hasInferenceCandidates)
		return /* TODO(ConditionalExpression): inferences.length ?             createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) :             undefined */ TODO
	}
	getMapperFromContext := func(context T) /* TODO(UnionType): TypeMapper | T & undefined */ any {
		return context && context.mapper
	}
	couldContainTypeVariables := func(type_ Type) bool {
		objectFlags := getObjectFlags(type_)
		if objectFlags & ObjectFlagsCouldContainTypeVariablesComputed {
			return !!(objectFlags & ObjectFlagsCouldContainTypeVariables)
		}
		result := !!(type_.flags&TypeFlagsInstantiable || type_.flags&TypeFlagsObject && !isNonGenericTopLevelType(type_) && (objectFlags&ObjectFlagsReference && ((type_ /* as */ /* TODO(TypeReference): TypeReference */).node || some(getTypeArguments(type_ /* as */ /* TODO(TypeReference): TypeReference */), couldContainTypeVariables)) || objectFlags&ObjectFlagsSingleSignatureType && !!length((type_ /* as */ /* TODO(TypeReference): SingleSignatureType */).outerTypeParameters) || objectFlags&ObjectFlagsAnonymous && type_.symbol && type_.symbol.flags&(SymbolFlagsFunction|SymbolFlagsMethod|SymbolFlagsClass|SymbolFlagsTypeLiteral|SymbolFlagsObjectLiteral) && type_.symbol.declarations || objectFlags&(ObjectFlagsMapped|ObjectFlagsReverseMapped|ObjectFlagsObjectRestType|ObjectFlagsInstantiationExpressionType)) || type_.flags&TypeFlagsUnionOrIntersection && !(type_.flags&TypeFlagsEnumLiteral) && !isNonGenericTopLevelType(type_) && some((type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, couldContainTypeVariables))
		if type_.flags & TypeFlagsObjectFlagsType {
			(type_ /* as */ /* TODO(TypeReference): ObjectFlagsType */).objectFlags |= ObjectFlagsCouldContainTypeVariablesComputed | ( /* TODO(ConditionalExpression): result ? ObjectFlags.CouldContainTypeVariables : 0 */ TODO)
		}
		return result
	}
	isNonGenericTopLevelType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		if type_.aliasSymbol && !type_.aliasTypeArguments {
			declaration := getDeclarationOfKind(type_.aliasSymbol, SyntaxKindTypeAliasDeclaration)
			return !!(declaration && findAncestor(declaration.parent, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
				/* TODO(BinaryExpression): n.kind === SyntaxKind.SourceFile */
				/* TODO(QuestionToken): ? */
				/* TODO(TrueKeyword): true */
				/* TODO(ColonToken): : */
				/* TODO(ConditionalExpression): n.kind === SyntaxKind.ModuleDeclaration ? false : "quit" */
			}))
		}
		return false
	}
	isTypeParameterAtTopLevel := func(type_ Type, tp TypeParameter, depth /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */) bool {
		return !!(type_ == tp || type_.flags&TypeFlagsUnionOrIntersection && some((type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isTypeParameterAtTopLevel */
			/* TODO(Identifier): t */
			/* TODO(Identifier): tp */
			/* TODO(Identifier): depth */
		}) || depth < 3 && type_.flags&TypeFlagsConditional && (isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type_ /* as */ /* TODO(TypeReference): ConditionalType */), tp /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO) || isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type_ /* as */ /* TODO(TypeReference): ConditionalType */), tp /* TODO(PlusToken): + */ /* TODO(BinaryExpression): depth + 1 */, TODO)))
	}
	isTypeParameterAtTopLevelInReturnType := func(signature Signature, typeParameter TypeParameter) /* TODO(undefined): boolean */ TODO {
		typePredicate := getTypePredicateOfSignature(signature)
		return /* TODO(ConditionalExpression): typePredicate ? !!typePredicate.type && isTypeParameterAtTopLevel(typePredicate.type, typeParameter) :             isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter) */ TODO
	}
	createEmptyObjectTypeFromStringLiteral := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
		members := createSymbolTable()
		forEachType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
			if !(t.flags & TypeFlagsStringLiteral) {
				return
			}
			name := escapeLeadingUnderscores((t /* as */ /* TODO(TypeReference): StringLiteralType */).value)
			literalProp := createSymbol(SymbolFlagsProperty, name)
			literalProp.links.type_ = anyType
			if t.symbol {
				literalProp.declarations = t.symbol.declarations
				literalProp.valueDeclaration = t.symbol.valueDeclaration
			}
			members.set(name, literalProp)
		})
		indexInfos := /* TODO(ConditionalExpression): type.flags & TypeFlags.String ? [createIndexInfo(stringType, emptyObjectType, /*isReadonly* / false)] : emptyArray */ TODO
		return createAnonymousType(nil, members, emptyArray, emptyArray, indexInfos)
	}
	inferTypeForHomomorphicMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
		if reverseHomomorphicMappedCache.has(cacheKey) {
			return reverseHomomorphicMappedCache.get(cacheKey)
		}
		type_ := createReverseMappedType(source, target, constraint)
		reverseHomomorphicMappedCache.set(cacheKey, type_)
		return type_
	}
	isPartiallyInferableType := func(type_ Type) bool {
		return !(getObjectFlags(type_) & ObjectFlagsNonInferrableType) || isObjectLiteralType(type_) && some(getPropertiesOfType(type_), func(prop /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isPartiallyInferableType */
			/* TODO(CallExpression): getTypeOfSymbol(prop) */
		}) || isTupleType(type_) && some(getElementTypes(type_), isPartiallyInferableType)
	}
	createReverseMappedType := func(source Type, target MappedType, constraint IndexType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if !(getIndexInfoOfType(source, stringType) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getPropertiesOfType(source).length !== 0 */ TODO && isPartiallyInferableType(source)) {
			return nil
		}
		if isArrayType(source) {
			elementType := inferReverseMappedType( /* TODO(ElementAccessExpression): getTypeArguments(source)[0] */ TODO, target, constraint)
			if !elementType {
				return nil
			}
			return createArrayType(elementType, isReadonlyArrayType(source))
		}
		if isTupleType(source) {
			elementTypes := map_(getElementTypes(source), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
				/* TODO(Identifier): inferReverseMappedType */
				/* TODO(Identifier): t */
				/* TODO(Identifier): target */
				/* TODO(Identifier): constraint */
			})
			if !every(elementTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO) /* TODO(TypePredicate): t is Type */ TODO {
				/* TODO(PrefixUnaryExpression): !t */
			}) {
				return nil
			}
			elementFlags := /* TODO(ConditionalExpression): getMappedTypeModifiers(target) & MappedTypeModifiers.IncludeOptional ?                 sameMap(source.target.elementFlags, f => f & ElementFlags.Optional ? ElementFlags.Required : f) :                 source.target.elementFlags */ TODO
			return createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations)
		}
		reversed := createObjectType(ObjectFlagsReverseMapped|ObjectFlagsAnonymous, nil) /* as */ /* TODO(TypeReference): ReverseMappedType */
		reversed.source = source
		reversed.mappedType = target
		reversed.constraintType = constraint
		return reversed
	}
	getTypeOfReverseMappedSymbol := func(symbol ReverseMappedSymbol) Type {
		links := getSymbolLinks(symbol)
		if !links.type_ {
			links.type_ = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType) || unknownType
		}
		return links.type_
	}
	inferReverseMappedTypeWorker := func(sourceType Type, target MappedType, constraint IndexType) Type {
		typeParameter := getIndexedAccessType(constraint.type_, getTypeParameterFromMappedType(target)) /* as */ /* TODO(TypeReference): TypeParameter */
		templateType := getTemplateTypeFromMappedType(target)
		inference := createInferenceInfo(typeParameter)
		inferTypes( /* TODO(ArrayLiteralExpression): [inference] */ TODO, sourceType, templateType)
		return getTypeFromInference(inference) || unknownType
	}
	inferReverseMappedType := func(source Type, target MappedType, constraint IndexType) *Type {
		cacheKey := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id + "," + constraint.id */ TODO
		if reverseMappedCache.has(cacheKey) {
			return reverseMappedCache.get(cacheKey) || unknownType
		}
		reverseMappedSourceStack.push(source)
		reverseMappedTargetStack.push(target)
		saveExpandingFlags := reverseExpandingFlags
		if isDeeplyNestedType(source, reverseMappedSourceStack, reverseMappedSourceStack.length, 2) {
			/* TODO(BinaryExpression): reverseExpandingFlags |= ExpandingFlags.Source */
		}
		if isDeeplyNestedType(target, reverseMappedTargetStack, reverseMappedTargetStack.length, 2) {
			/* TODO(BinaryExpression): reverseExpandingFlags |= ExpandingFlags.Target */
		}
		var type_ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): reverseExpandingFlags !== ExpandingFlags.Both */ TODO {
			type_ = inferReverseMappedTypeWorker(source, target, constraint)
		}
		reverseMappedSourceStack.pop()
		reverseMappedTargetStack.pop()
		reverseExpandingFlags = saveExpandingFlags
		reverseMappedCache.set(cacheKey, type_)
		return type_
	}
	getUnmatchedProperties := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) IterableIterator[Symbol] {
		properties := getPropertiesOfType(target)
		for _, targetProp := range properties {
			if isStaticPrivateIdentifierProperty(targetProp) {
				/* TODO(ContinueStatement): continue; */
			}
			if requireOptionalProperties || !(targetProp.flags&SymbolFlagsOptional || getCheckFlags(targetProp)&CheckFlagsPartial) {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if !sourceProp {
					/* TODO(ExpressionStatement): yield targetProp; */
				} else if matchDiscriminantProperties {
					targetType := getTypeOfSymbol(targetProp)
					if targetType.flags & TypeFlagsUnit {
						sourceType := getTypeOfSymbol(sourceProp)
						if !(sourceType.flags&TypeFlagsAny || getRegularTypeOfLiteralType(sourceType) == getRegularTypeOfLiteralType(targetType)) {
							/* TODO(ExpressionStatement): yield targetProp; */
						}
					}
				}
			}
		}
	}
	getUnmatchedProperty := func(source Type, target Type, requireOptionalProperties bool, matchDiscriminantProperties bool) *Symbol {
		return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties))
	}
	tupleTypesDefinitelyUnrelated := func(source TupleTypeReference, target TupleTypeReference) /* TODO(undefined): boolean */ TODO {
		return !(target.target.combinedFlags&ElementFlagsVariadic) && target.target.minLength > source.target.minLength || !(target.target.combinedFlags&ElementFlagsVariable) && (!!(source.target.combinedFlags&ElementFlagsVariable) || target.target.fixedLength < source.target.fixedLength)
	}
	typesDefinitelyUnrelated := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(source, target) :             !!getUnmatchedProperty(source, target, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / true) &&             !!getUnmatchedProperty(target, source, /*requireOptionalProperties* / false, /*matchDiscriminantProperties* / false) */ TODO
	}
	getTypeFromInference := func(inference InferenceInfo) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return /* TODO(ConditionalExpression): inference.candidates ? getUnionType(inference.candidates, UnionReduction.Subtype) :             inference.contraCandidates ? getIntersectionType(inference.contraCandidates) :             undefined */ TODO
	}
	hasSkipDirectInferenceFlag := func(node Node) /* TODO(undefined): boolean */ TODO {
		return !!getNodeLinks(node).skipDirectInference
	}
	isFromInferenceBlockedSource := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(type_.symbol && some(type_.symbol.declarations, hasSkipDirectInferenceFlag))
	}
	templateLiteralTypesDefinitelyUnrelated := func(source TemplateLiteralType, target TemplateLiteralType) /* TODO(undefined): boolean */ TODO {
		sourceStart := /* TODO(ElementAccessExpression): source.texts[0] */ TODO
		targetStart := /* TODO(ElementAccessExpression): target.texts[0] */ TODO
		sourceEnd := /* TODO(ElementAccessExpression): source.texts[source.texts.length - 1] */ TODO
		targetEnd := /* TODO(ElementAccessExpression): target.texts[target.texts.length - 1] */ TODO
		startLen := Math.min(sourceStart.length, targetStart.length)
		endLen := Math.min(sourceEnd.length, targetEnd.length)
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceStart.slice(0, startLen) !== targetStart.slice(0, startLen) */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): sourceEnd.slice(sourceEnd.length - endLen) !== targetEnd.slice(targetEnd.length - endLen) */ TODO
	}
	isValidNumberString := func(s string, roundTripOnly bool) bool {
		if s == "" {
			/* TODO(FalseKeyword): false */
		}
		n := +s
		return isFinite(n) && (!roundTripOnly || /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + n */ TODO == s)
	}
	parseBigIntLiteralType := func(text string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BigIntLiteralType */ TODO {
		return getBigIntLiteralType(parseValidBigInt(text))
	}
	isMemberOfStringMapping := func(source Type, target Type) bool {
		if target.flags & TypeFlagsAny {
			return true
		}
		if target.flags & (TypeFlagsString | TypeFlagsTemplateLiteral) {
			return isTypeAssignableTo(source, target)
		}
		if target.flags & TypeFlagsStringMapping {
			mappingStack := /* TODO(ArrayLiteralExpression): [] */ TODO
			/* TODO(WhileStatement): while (target.flags & TypeFlags.StringMapping) {                 mappingStack.unshift(target.symbol);                 target = (target as StringMappingType).type;             } */
			mappedSource := reduceLeft(mappingStack, func(memo /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, value /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): getStringMappingType */
				/* TODO(Identifier): value */
				/* TODO(Identifier): memo */
			}, source)
			return mappedSource == source && isMemberOfStringMapping(source, target)
		}
		return false
	}
	isValidTypeForTemplateLiteralPlaceholder := func(source Type, target Type) bool {
		if target.flags & TypeFlagsIntersection {
			return every((target /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(BinaryExpression): t === emptyTypeLiteralType */
				/* TODO(BarBarToken): || */
				/* TODO(CallExpression): isValidTypeForTemplateLiteralPlaceholder(source, t) */
			})
		}
		if target.flags&TypeFlagsString || isTypeAssignableTo(source, target) {
			return true
		}
		if source.flags & TypeFlagsStringLiteral {
			value := (source /* as */ /* TODO(TypeReference): StringLiteralType */).value
			return !!(target.flags&TypeFlagsNumber && isValidNumberString(value, false) || target.flags&TypeFlagsBigInt && isValidBigIntString(value, false) || target.flags&(TypeFlagsBooleanLiteral|TypeFlagsNullable) && value == (target /* as */ /* TODO(TypeReference): IntrinsicType */).intrinsicName || target.flags&TypeFlagsStringMapping && isMemberOfStringMapping(getStringLiteralType(value), target) || target.flags&TypeFlagsTemplateLiteral && isTypeMatchedByTemplateLiteralType(source, target /* as */ /* TODO(TypeReference): TemplateLiteralType */))
		}
		if source.flags & TypeFlagsTemplateLiteral {
			texts := (source /* as */ /* TODO(TypeReference): TemplateLiteralType */).texts
			return texts.length == 2 && /* TODO(ElementAccessExpression): texts[0] */ TODO == "" && /* TODO(ElementAccessExpression): texts[1] */ TODO == "" && isTypeAssignableTo( /* TODO(ElementAccessExpression): (source as TemplateLiteralType).types[0] */ TODO, target)
		}
		return false
	}
	inferTypesFromTemplateLiteralType := func(source Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.StringLiteral ? inferFromLiteralPartsToTemplateLiteral([(source as StringLiteralType).value], emptyArray, target) :             source.flags & TypeFlags.TemplateLiteral ?             arrayIsEqualTo((source as TemplateLiteralType).texts, target.texts) ? map((source as TemplateLiteralType).types, (s, i) => {                 return isTypeAssignableTo(getBaseConstraintOrType(s), getBaseConstraintOrType(target.types[i])) ? s : getStringLikeTypeForType(s);             }) :                 inferFromLiteralPartsToTemplateLiteral((source as TemplateLiteralType).texts, (source as TemplateLiteralType).types, target) :             undefined */ TODO
	}
	isTypeMatchedByTemplateLiteralType := func(source Type, target TemplateLiteralType) bool {
		inferences := inferTypesFromTemplateLiteralType(source, target)
		return !!inferences && every(inferences, func(r /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): isValidTypeForTemplateLiteralPlaceholder */
			/* TODO(Identifier): r */
			/* TODO(ElementAccessExpression): target.types[i] */
		})
	}
	getStringLikeTypeForType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & (TypeFlags.Any | TypeFlags.StringLike) ? type : getTemplateLiteralType(["", ""], [type]) */ TODO
	}
	inferFromLiteralPartsToTemplateLiteral := func(sourceTexts []string, sourceTypes []Type, target TemplateLiteralType) /* TODO(ArrayType): Type[] */ any {
		lastSourceIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceTexts.length - 1 */ TODO
		sourceStartText := /* TODO(ElementAccessExpression): sourceTexts[0] */ TODO
		sourceEndText := /* TODO(ElementAccessExpression): sourceTexts[lastSourceIndex] */ TODO
		targetTexts := target.texts
		lastTargetIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): targetTexts.length - 1 */ TODO
		targetStartText := /* TODO(ElementAccessExpression): targetTexts[0] */ TODO
		targetEndText := /* TODO(ElementAccessExpression): targetTexts[lastTargetIndex] */ TODO
		if lastSourceIndex == 0 && sourceStartText.length < /* TODO(PlusToken): + */ /* TODO(BinaryExpression): targetStartText.length + targetEndText.length */ TODO || !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText) {
			/* TODO(Identifier): undefined */
		}
		remainingEndText := sourceEndText.slice(0 /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceEndText.length - targetEndText.length */, TODO)
		var matches []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		seg := 0
		pos := targetStartText.length
		/* TODO(ForStatement): for (let i = 1; i < lastTargetIndex; i++) {             const delim = targetTexts[i];             if (delim.length > 0) {                 let s = seg;                 let p = pos;                 while (true) {                     p = getSourceText(s).indexOf(delim, p);                     if (p >= 0) break;                     s++;                     if (s === sourceTexts.length) return undefined;                     p = 0;                 }                 addMatch(s, p);                 pos += delim.length;             }             else if (pos < getSourceText(seg).length) {                 addMatch(seg, pos + 1);             }             else if (seg < lastSourceIndex) {                 addMatch(seg + 1, 0);             }             else {                 return undefined;             }         } */
		addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length)
		return matches
		getSourceText := func(index number) /* TODO(undefined): string */ TODO {
			return /* TODO(ConditionalExpression): index < lastSourceIndex ? sourceTexts[index] : remainingEndText */ TODO
		}
		addMatch := func(s number, p number) {
			matchType := /* TODO(ConditionalExpression): s === seg ?                 getStringLiteralType(getSourceText(s).slice(pos, p)) :                 getTemplateLiteralType(                     [sourceTexts[seg].slice(pos), ...sourceTexts.slice(seg + 1, s), getSourceText(s).slice(0, p)],                     sourceTypes.slice(seg, s),                 ) */ TODO
			matches.push(matchType)
			seg = s
			pos = p
		}
	}
	isTupleOfSelf := func(typeParameter TypeParameter, type_ Type) /* TODO(undefined): boolean */ TODO {
		return isTupleType(type_) && getTupleElementType(type_, 0) == getIndexedAccessType(typeParameter, getNumberLiteralType(0)) && !getTypeOfPropertyOfType(type_, "1" /* as */ /* TODO(TypeReference): __String */)
	}
	inferTypes := func(inferences []InferenceInfo, originalSource Type, originalTarget Type, priority /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferencePriority */ TODO /* = */ /* TODO(PropertyAccessExpression): InferencePriority.None */, contravariant /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) {
		bivariant := false
		var propagationType Type
		var inferencePriority number = InferencePriorityMaxValue
		var visited Map[string, number]
		var sourceStack []Type
		var targetStack []Type
		expandingFlags := ExpandingFlagsNone
		inferFromTypes(originalSource, originalTarget)
		inferFromTypes := func(source Type, target Type) {
			if !couldContainTypeVariables(target) || isNoInferType(target) {
				return
			}
			if source == wildcardType || source == blockedStringType {
				savePropagationType := propagationType
				propagationType = source
				inferFromTypes(target, target)
				propagationType = savePropagationType
				return
			}
			if source.aliasSymbol && source.aliasSymbol == target.aliasSymbol {
				if source.aliasTypeArguments {
					params := /* TODO(NonNullExpression): getSymbolLinks(source.aliasSymbol).typeParameters! */ TODO
					minParams := getMinTypeArgumentCount(params)
					sourceTypes := fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					targetTypes := fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration))
					inferFromTypeArguments(sourceTypes /* TODO(NonNullExpression): targetTypes! */, TODO, getAliasVariances(source.aliasSymbol))
				}
				return
			}
			if source == target && source.flags&TypeFlagsUnionOrIntersection {
				for _, t := range (source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types {
					inferFromTypes(t, t)
				}
				return
			}
			if target.flags & TypeFlagsUnion {
				TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO, (target /* as */ /* TODO(TypeReference): UnionType */).types, isTypeOrBaseIdenticalTo)
				TODO_IDENTIFIER := inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy)
				if targets.length == 0 {
					return
				}
				target = getUnionType(targets)
				if sources.length == 0 {
					inferWithPriority(source, target, InferencePriorityNakedTypeVariable)
					return
				}
				source = getUnionType(sources)
			} else if target.flags&TypeFlagsIntersection && !every((target /* as */ /* TODO(TypeReference): IntersectionType */).types, isNonGenericObjectType) {
				if !(source.flags & TypeFlagsUnion) {
					TODO_IDENTIFIER := inferFromMatchingTypes( /* TODO(ConditionalExpression): source.flags & TypeFlags.Intersection ? (source as IntersectionType).types : [source] */ TODO, (target /* as */ /* TODO(TypeReference): IntersectionType */).types, isTypeIdenticalTo)
					if sources.length == 0 || targets.length == 0 {
						return
					}
					source = getIntersectionType(sources)
					target = getIntersectionType(targets)
				}
			}
			if target.flags & (TypeFlagsIndexedAccess | TypeFlagsSubstitution) {
				if isNoInferType(target) {
					return
				}
				target = getActualTypeVariable(target)
			}
			if target.flags & TypeFlagsTypeVariable {
				if isFromInferenceBlockedSource(source) {
					return
				}
				inference := getInferenceInfoForType(target)
				if inference {
					if getObjectFlags(source)&ObjectFlagsNonInferrableType || source == nonInferrableAnyType {
						return
					}
					if !inference.isFixed {
						candidate := propagationType || source
						if candidate == blockedStringType {
							return
						}
						if inference.priority == nil || priority < inference.priority {
							inference.candidates = nil
							inference.contraCandidates = nil
							inference.topLevel = true
							inference.priority = priority
						}
						if priority == inference.priority {
							if isTupleOfSelf(inference.typeParameter, candidate) {
								return
							}
							if contravariant && !bivariant {
								if !contains(inference.contraCandidates, candidate) {
									inference.contraCandidates = append(inference.contraCandidates, candidate)
									clearCachedInferences(inferences)
								}
							} else if !contains(inference.candidates, candidate) {
								inference.candidates = append(inference.candidates, candidate)
								clearCachedInferences(inferences)
							}
						}
						if !(priority & InferencePriorityReturnType) && target.flags&TypeFlagsTypeParameter && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target /* as */ /* TODO(TypeReference): TypeParameter */) {
							inference.topLevel = false
							clearCachedInferences(inferences)
						}
					}
					inferencePriority = Math.min(inferencePriority, priority)
					return
				}
				simplified := getSimplifiedType(target, false)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): simplified !== target */ TODO {
					inferFromTypes(source, simplified)
				} else if target.flags & TypeFlagsIndexedAccess {
					indexType := getSimplifiedType((target /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType, false)
					if indexType.flags & TypeFlagsInstantiable {
						simplified := distributeIndexOverObjectType(getSimplifiedType((target /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType, false), indexType, false)
						if simplified && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): simplified !== target */ TODO {
							inferFromTypes(source, simplified)
						}
					}
				}
			}
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source /* as */ /* TODO(TypeReference): TypeReference */).target == (target /* as */ /* TODO(TypeReference): TypeReference */).target || isArrayType(source) && isArrayType(target)) && !((source /* as */ /* TODO(TypeReference): TypeReference */).node && (target /* as */ /* TODO(TypeReference): TypeReference */).node) {
				inferFromTypeArguments(getTypeArguments(source /* as */ /* TODO(TypeReference): TypeReference */), getTypeArguments(target /* as */ /* TODO(TypeReference): TypeReference */), getVariances((source /* as */ /* TODO(TypeReference): TypeReference */).target))
			} else if source.flags&TypeFlagsIndex && target.flags&TypeFlagsIndex {
				inferFromContravariantTypes((source /* as */ /* TODO(TypeReference): IndexType */).type_, (target /* as */ /* TODO(TypeReference): IndexType */).type_)
			} else if (isLiteralType(source) || source.flags&TypeFlagsString) && target.flags&TypeFlagsIndex {
				empty := createEmptyObjectTypeFromStringLiteral(source)
				inferFromContravariantTypesWithPriority(empty, (target /* as */ /* TODO(TypeReference): IndexType */).type_, InferencePriorityLiteralKeyof)
			} else if source.flags&TypeFlagsIndexedAccess && target.flags&TypeFlagsIndexedAccess {
				inferFromTypes((source /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType, (target /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType)
				inferFromTypes((source /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType, (target /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType)
			} else if source.flags&TypeFlagsStringMapping && target.flags&TypeFlagsStringMapping {
				if (source /* as */ /* TODO(TypeReference): StringMappingType */).symbol == (target /* as */ /* TODO(TypeReference): StringMappingType */).symbol {
					inferFromTypes((source /* as */ /* TODO(TypeReference): StringMappingType */).type_, (target /* as */ /* TODO(TypeReference): StringMappingType */).type_)
				}
			} else if source.flags & TypeFlagsSubstitution {
				inferFromTypes((source /* as */ /* TODO(TypeReference): SubstitutionType */).baseType, target)
				inferWithPriority(getSubstitutionIntersection(source /* as */ /* TODO(TypeReference): SubstitutionType */), target, InferencePrioritySubstituteSource)
			} else if target.flags & TypeFlagsConditional {
				invokeOnce(source, target /* as */ /* TODO(TypeReference): ConditionalType */, inferToConditionalType)
			} else if target.flags & TypeFlagsUnionOrIntersection {
				inferToMultipleTypes(source, (target /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, target.flags)
			} else if source.flags & TypeFlagsUnion {
				sourceTypes := (source /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types
				for _, sourceType := range sourceTypes {
					inferFromTypes(sourceType, target)
				}
			} else if target.flags & TypeFlagsTemplateLiteral {
				inferToTemplateLiteralType(source, target /* as */ /* TODO(TypeReference): TemplateLiteralType */)
			} else {
				source = getReducedType(source)
				if isGenericMappedType(source) && isGenericMappedType(target) {
					invokeOnce(source, target, inferFromGenericMappedTypes)
				}
				if !(priority&InferencePriorityNoConstraints && source.flags&(TypeFlagsIntersection|TypeFlagsInstantiable)) {
					apparentSource := getApparentType(source)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): apparentSource !== source */ TODO && !(apparentSource.flags & (TypeFlagsObject | TypeFlagsIntersection)) {
						return inferFromTypes(apparentSource, target)
					}
					source = apparentSource
				}
				if source.flags & (TypeFlagsObject | TypeFlagsIntersection) {
					invokeOnce(source, target, inferFromObjectTypes)
				}
			}
		}
		inferWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromTypes(source, target)
			priority = savePriority
		}
		inferFromContravariantTypesWithPriority := func(source Type, target Type, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferFromContravariantTypes(source, target)
			priority = savePriority
		}
		inferToMultipleTypesWithPriority := func(source Type, targets []Type, targetFlags TypeFlags, newPriority InferencePriority) {
			savePriority := priority
			priority |= newPriority
			inferToMultipleTypes(source, targets, targetFlags)
			priority = savePriority
		}
		invokeOnce := func(source Source, target Target, action func(source Source, target Target)) {
			key := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): source.id + "," + target.id */ TODO
			status := visited && visited.get(key)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): status !== undefined */ TODO {
				inferencePriority = Math.min(inferencePriority, status)
				return
			}
			(visited || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): visited = new Map<string, number>() */ TODO)).set(key, InferencePriorityCircularity)
			saveInferencePriority := inferencePriority
			inferencePriority = InferencePriorityMaxValue
			saveExpandingFlags := expandingFlags
			( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): sourceStack ??= [] */ TODO).push(source)
			( /* TODO(QuestionQuestionEqualsToken): ??= */ /* TODO(BinaryExpression): targetStack ??= [] */ TODO).push(target)
			if isDeeplyNestedType(source, sourceStack, sourceStack.length, 2) {
				/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Source */
			}
			if isDeeplyNestedType(target, targetStack, targetStack.length, 2) {
				/* TODO(BinaryExpression): expandingFlags |= ExpandingFlags.Target */
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): expandingFlags !== ExpandingFlags.Both */ TODO {
				action(source, target)
			} else {
				inferencePriority = InferencePriorityCircularity
			}
			targetStack.pop()
			sourceStack.pop()
			expandingFlags = saveExpandingFlags
			visited.set(key, inferencePriority)
			inferencePriority = Math.min(inferencePriority, saveInferencePriority)
		}
		inferFromMatchingTypes := func(sources []Type, targets []Type, matches func(s Type, t Type) bool) /* TODO(TupleType): [Type[], Type[]] */ TODO {
			var matchedSources /* TODO(ArrayType): Type[] */ any
			var matchedTargets /* TODO(ArrayType): Type[] */ any
			for _, t := range targets {
				for _, s := range sources {
					if matches(s, t) {
						inferFromTypes(s, t)
						matchedSources = appendIfUnique(matchedSources, s)
						matchedTargets = appendIfUnique(matchedTargets, t)
					}
				}
			}
			return /* TODO(ArrayLiteralExpression): [                 matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources,                 matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets,             ] */ TODO
		}
		inferFromTypeArguments := func(sourceTypes []Type, targetTypes []Type, variances []VarianceFlags) {
			count := /* TODO(ConditionalExpression): sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length */ TODO
			/* TODO(ForStatement): for (let i = 0; i < count; i++) {                 if (i < variances.length && (variances[i] & VarianceFlags.VarianceMask) === VarianceFlags.Contravariant) {                     inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);                 }                 else {                     inferFromTypes(sourceTypes[i], targetTypes[i]);                 }             } */
		}
		inferFromContravariantTypes := func(source Type, target Type) {
			contravariant = !contravariant
			inferFromTypes(source, target)
			contravariant = !contravariant
		}
		inferFromContravariantTypesIfStrictFunctionTypes := func(source Type, target Type) {
			if strictFunctionTypes || priority&InferencePriorityAlwaysStrict {
				inferFromContravariantTypes(source, target)
			} else {
				inferFromTypes(source, target)
			}
		}
		getInferenceInfoForType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo | undefined */ TODO {
			if type_.flags & TypeFlagsTypeVariable {
				for _, inference := range inferences {
					if type_ == inference.typeParameter {
						return inference
					}
				}
			}
			return nil
		}
		getSingleTypeVariableFromIntersectionTypes := func(types []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			var typeVariable *Type
			for _, type_ := range types {
				t := type_.flags&TypeFlagsIntersection && find((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !getInferenceInfoForType(t) */
				})
				if !t || typeVariable && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): t !== typeVariable */ TODO {
					return nil
				}
				typeVariable = t
			}
			return typeVariable
		}
		inferToMultipleTypes := func(source Type, targets []Type, targetFlags TypeFlags) {
			typeVariableCount := 0
			if targetFlags & TypeFlagsUnion {
				var nakedTypeVariable *Type
				sources := /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? (source as UnionType).types : [source] */ TODO
				matched := /* TODO(NewExpression): new Array<boolean>(sources.length) */ TODO
				inferenceCircularity := false
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						nakedTypeVariable = t
						typeVariableCount++
					} else {
						/* TODO(ForStatement): for (let i = 0; i < sources.length; i++) {                             const saveInferencePriority = inferencePriority;                             inferencePriority = InferencePriority.MaxValue;                             inferFromTypes(sources[i], t);                             if (inferencePriority === priority) matched[i] = true;                             inferenceCircularity = inferenceCircularity || inferencePriority === InferencePriority.Circularity;                             inferencePriority = Math.min(inferencePriority, saveInferencePriority);                         } */
					}
				}
				if typeVariableCount == 0 {
					intersectionTypeVariable := getSingleTypeVariableFromIntersectionTypes(targets)
					if intersectionTypeVariable {
						inferWithPriority(source, intersectionTypeVariable, InferencePriorityNakedTypeVariable)
					}
					return
				}
				if typeVariableCount == 1 && !inferenceCircularity {
					unmatched := flatMap(sources, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
						/* TODO(ElementAccessExpression): matched[i] */
						/* TODO(QuestionToken): ? */
						/* TODO(Identifier): undefined */
						/* TODO(ColonToken): : */
						/* TODO(Identifier): s */
					})
					if unmatched.length {
						inferFromTypes(getUnionType(unmatched) /* TODO(NonNullExpression): nakedTypeVariable! */, TODO)
						return
					}
				}
			} else {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						typeVariableCount++
					} else {
						inferFromTypes(source, t)
					}
				}
			}
			if /* TODO(ConditionalExpression): targetFlags & TypeFlags.Intersection ? typeVariableCount === 1 : typeVariableCount > 0 */ TODO {
				for _, t := range targets {
					if getInferenceInfoForType(t) {
						inferWithPriority(source, t, InferencePriorityNakedTypeVariable)
					}
				}
			}
		}
		inferToMappedType := func(source Type, target MappedType, constraintType Type) bool {
			if (constraintType.flags & TypeFlagsUnion) || (constraintType.flags & TypeFlagsIntersection) {
				result := false
				for _, type_ := range (constraintType /* as */ /* TODO(ParenthesizedType): (UnionType | IntersectionType) */).types {
					result = inferToMappedType(source, target, type_) || result
				}
				return result
			}
			if constraintType.flags & TypeFlagsIndex {
				inference := getInferenceInfoForType((constraintType /* as */ /* TODO(TypeReference): IndexType */).type_)
				if inference && !inference.isFixed && !isFromInferenceBlockedSource(source) {
					inferredType := inferTypeForHomomorphicMappedType(source, target, constraintType /* as */ /* TODO(TypeReference): IndexType */)
					if inferredType {
						inferWithPriority(inferredType, inference.typeParameter /* TODO(ConditionalExpression): getObjectFlags(source) & ObjectFlags.NonInferrableType ?                                 InferencePriority.PartialHomomorphicMappedType :                                 InferencePriority.HomomorphicMappedType */, TODO)
					}
				}
				return true
			}
			if constraintType.flags & TypeFlagsTypeParameter {
				inferWithPriority(getIndexType(source /* TODO(ConditionalExpression): !!source.pattern ? IndexFlags.NoIndexSignatures : IndexFlags.None */, TODO), constraintType, InferencePriorityMappedTypeConstraint)
				extendedConstraint := getConstraintOfType(constraintType)
				if extendedConstraint && inferToMappedType(source, target, extendedConstraint) {
					return true
				}
				propTypes := map_(getPropertiesOfType(source), getTypeOfSymbol)
				indexTypes := map_(getIndexInfosOfType(source), func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(BinaryExpression): info !== enumNumberIndexInfo */
					/* TODO(QuestionToken): ? */
					/* TODO(PropertyAccessExpression): info.type */
					/* TODO(ColonToken): : */
					/* TODO(Identifier): neverType */
				})
				inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target))
				return true
			}
			return false
		}
		inferToConditionalType := func(source Type, target ConditionalType) {
			if source.flags & TypeFlagsConditional {
				inferFromTypes((source /* as */ /* TODO(TypeReference): ConditionalType */).checkType, target.checkType)
				inferFromTypes((source /* as */ /* TODO(TypeReference): ConditionalType */).extendsType, target.extendsType)
				inferFromTypes(getTrueTypeFromConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */), getTrueTypeFromConditionalType(target))
				inferFromTypes(getFalseTypeFromConditionalType(source /* as */ /* TODO(TypeReference): ConditionalType */), getFalseTypeFromConditionalType(target))
			} else {
				targetTypes := /* TODO(ArrayLiteralExpression): [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)] */ TODO
				inferToMultipleTypesWithPriority(source, targetTypes, target.flags /* TODO(ConditionalExpression): contravariant ? InferencePriority.ContravariantConditional : 0 */, TODO)
			}
		}
		inferToTemplateLiteralType := func(source Type, target TemplateLiteralType) {
			matches := inferTypesFromTemplateLiteralType(source, target)
			types := target.types
			if matches || every(target.texts, func(s /* TODO(undefined): string */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): s.length */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(NumericLiteral): 0 */
			}) {
				/* TODO(ForStatement): for (let i = 0; i < types.length; i++) {                     const source = matches ? matches[i] : neverType;                     const target = types[i];                      // If we are inferring from a string literal type to a type variable whose constraint includes one of the                     // allowed template literal placeholder types, infer from a literal type corresponding to the constraint.                     if (source.flags & TypeFlags.StringLiteral && target.flags & TypeFlags.TypeVariable) {                         const inferenceContext = getInferenceInfoForType(target);                         const constraint = inferenceContext ? getBaseConstraintOfType(inferenceContext.typeParameter) : undefined;                         if (constraint && !isTypeAny(constraint)) {                             const constraintTypes = constraint.flags & TypeFlags.Union ? (constraint as UnionType).types : [constraint];                             let allTypeFlags: TypeFlags = reduceLeft(constraintTypes, (flags, t) => flags | t.flags, 0 as TypeFlags);                              // If the constraint contains `string`, we don't need to look for a more preferred type                             if (!(allTypeFlags & TypeFlags.String)) {                                 const str = (source as StringLiteralType).value;                                  // If the type contains `number` or a number literal and the string isn't a valid number, exclude numbers                                 if (allTypeFlags & TypeFlags.NumberLike && !isValidNumberString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.NumberLike;                                 }                                  // If the type contains `bigint` or a bigint literal and the string isn't a valid bigint, exclude bigints                                 if (allTypeFlags & TypeFlags.BigIntLike && !isValidBigIntString(str, /*roundTripOnly* / true)) {                                     allTypeFlags &= ~TypeFlags.BigIntLike;                                 }                                  // for each type in the constraint, find the highest priority matching type                                 const matchingType = reduceLeft(constraintTypes, (left, right) =>                                     !(right.flags & allTypeFlags) ? left :                                         left.flags & TypeFlags.String ? left : right.flags & TypeFlags.String ? source :                                         left.flags & TypeFlags.TemplateLiteral ? left : right.flags & TypeFlags.TemplateLiteral && isTypeMatchedByTemplateLiteralType(source, right as TemplateLiteralType) ? source :                                         left.flags & TypeFlags.StringMapping ? left : right.flags & TypeFlags.StringMapping && str === applyStringMapping(right.symbol, str) ? source :                                         left.flags & TypeFlags.StringLiteral ? left : right.flags & TypeFlags.StringLiteral && (right as StringLiteralType).value === str ? right :                                         left.flags & TypeFlags.Number ? left : right.flags & TypeFlags.Number ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.Enum ? left : right.flags & TypeFlags.Enum ? getNumberLiteralType(+str) :                                         left.flags & TypeFlags.NumberLiteral ? left : right.flags & TypeFlags.NumberLiteral && (right as NumberLiteralType).value === +str ? right :                                         left.flags & TypeFlags.BigInt ? left : right.flags & TypeFlags.BigInt ? parseBigIntLiteralType(str) :                                         left.flags & TypeFlags.BigIntLiteral ? left : right.flags & TypeFlags.BigIntLiteral && pseudoBigIntToString((right as BigIntLiteralType).value) === str ? right :                                         left.flags & TypeFlags.Boolean ? left : right.flags & TypeFlags.Boolean ? str === "true" ? trueType : str === "false" ? falseType : booleanType :                                         left.flags & TypeFlags.BooleanLiteral ? left : right.flags & TypeFlags.BooleanLiteral && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Undefined ? left : right.flags & TypeFlags.Undefined && (right as IntrinsicType).intrinsicName === str ? right :                                         left.flags & TypeFlags.Null ? left : right.flags & TypeFlags.Null && (right as IntrinsicType).intrinsicName === str ? right :                                         left, neverType as Type);                                  if (!(matchingType.flags & TypeFlags.Never)) {                                     inferFromTypes(matchingType, target);                                     continue;                                 }                             }                         }                     }                      inferFromTypes(source, target);                 } */
			}
		}
		inferFromGenericMappedTypes := func(source MappedType, target MappedType) {
			inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target))
			inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target))
			sourceNameType := getNameTypeFromMappedType(source)
			targetNameType := getNameTypeFromMappedType(target)
			if sourceNameType && targetNameType {
				/* TODO(CallExpression): inferFromTypes(sourceNameType, targetNameType) */
			}
		}
		inferFromObjectTypes := func(source Type, target Type) {
			if getObjectFlags(source)&ObjectFlagsReference && getObjectFlags(target)&ObjectFlagsReference && ((source /* as */ /* TODO(TypeReference): TypeReference */).target == (target /* as */ /* TODO(TypeReference): TypeReference */).target || isArrayType(source) && isArrayType(target)) {
				inferFromTypeArguments(getTypeArguments(source /* as */ /* TODO(TypeReference): TypeReference */), getTypeArguments(target /* as */ /* TODO(TypeReference): TypeReference */), getVariances((source /* as */ /* TODO(TypeReference): TypeReference */).target))
				return
			}
			if isGenericMappedType(source) && isGenericMappedType(target) {
				inferFromGenericMappedTypes(source, target)
			}
			if getObjectFlags(target)&ObjectFlagsMapped && !(target /* as */ /* TODO(TypeReference): MappedType */).declaration.nameType {
				constraintType := getConstraintTypeFromMappedType(target /* as */ /* TODO(TypeReference): MappedType */)
				if inferToMappedType(source, target /* as */ /* TODO(TypeReference): MappedType */, constraintType) {
					return
				}
			}
			if !typesDefinitelyUnrelated(source, target) {
				if isArrayOrTupleType(source) {
					if isTupleType(target) {
						sourceArity := getTypeReferenceArity(source)
						targetArity := getTypeReferenceArity(target)
						elementTypes := getTypeArguments(target)
						elementFlags := target.target.elementFlags
						if isTupleType(source) && isTupleTypeStructureMatching(source, target) {
							/* TODO(ForStatement): for (let i = 0; i < targetArity; i++) {                                 inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                             } */
							return
						}
						startLength := /* TODO(ConditionalExpression): isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0 */ TODO
						endLength := Math.min( /* TODO(ConditionalExpression): isTupleType(source) ? getEndElementCount(source.target, ElementFlags.Fixed) : 0 */ TODO /* TODO(ConditionalExpression): target.target.combinedFlags & ElementFlags.Variable ? getEndElementCount(target.target, ElementFlags.Fixed) : 0 */, TODO)
						/* TODO(ForStatement): for (let i = 0; i < startLength; i++) {                             inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);                         } */
						if !isTupleType(source) || /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - startLength - endLength */ TODO == 1 && /* TODO(ElementAccessExpression): source.target.elementFlags[startLength] */ TODO&ElementFlagsRest {
							restType := /* TODO(ElementAccessExpression): getTypeArguments(source)[startLength] */ TODO
							/* TODO(ForStatement): for (let i = startLength; i < targetArity - endLength; i++) {                                 inferFromTypes(elementFlags[i] & ElementFlags.Variadic ? createArrayType(restType) : restType, elementTypes[i]);                             } */
						} else {
							middleLength := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): targetArity - startLength - endLength */ TODO
							if middleLength == 2 {
								if /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO & /* TODO(ElementAccessExpression): elementFlags[startLength + 1] */ TODO & ElementFlagsVariadic {
									targetInfo := getInferenceInfoForType( /* TODO(ElementAccessExpression): elementTypes[startLength] */ TODO)
									if targetInfo && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetInfo.impliedArity !== undefined */ TODO {
										inferFromTypes(sliceTupleType(source, startLength /* TODO(MinusToken): - */ /* TODO(BinaryExpression): endLength + sourceArity - targetInfo.impliedArity */, TODO) /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes(sliceTupleType(source /* TODO(PlusToken): + */ /* TODO(BinaryExpression): startLength + targetInfo.impliedArity */, TODO, endLength) /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								} else if /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsVariadic && /* TODO(ElementAccessExpression): elementFlags[startLength + 1] */ TODO&ElementFlagsRest {
									param := getInferenceInfoForType( /* TODO(ElementAccessExpression): elementTypes[startLength] */ TODO).typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										inferFromTypes(sliceTupleType(source, startLength /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - (startLength + impliedArity) */, TODO) /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes( /* TODO(NonNullExpression): getElementTypeOfSliceOfTupleType(source, startLength + impliedArity, endLength)! */ TODO /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								} else if /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsRest && /* TODO(ElementAccessExpression): elementFlags[startLength + 1] */ TODO&ElementFlagsVariadic {
									param := getInferenceInfoForType( /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */ TODO).typeParameter
									constraint := param && getBaseConstraintOfType(param)
									if constraint && isTupleType(constraint) && !(constraint.target.combinedFlags & ElementFlagsVariable) {
										impliedArity := constraint.target.fixedLength
										endIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): sourceArity - getEndElementCount(target.target, ElementFlags.Fixed) */ TODO
										startIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): endIndex - impliedArity */ TODO
										trailingSlice := createTupleType(getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex), false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex))
										inferFromTypes( /* TODO(NonNullExpression): getElementTypeOfSliceOfTupleType(source, startLength, endLength + impliedArity)! */ TODO /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
										inferFromTypes(trailingSlice /* TODO(ElementAccessExpression): elementTypes[startLength + 1] */, TODO)
									}
								}
							} else if middleLength == 1 && /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsVariadic {
								endsInOptional := /* TODO(ElementAccessExpression): target.target.elementFlags[targetArity - 1] */ TODO & ElementFlagsOptional
								sourceSlice := sliceTupleType(source, startLength, endLength)
								inferWithPriority(sourceSlice /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO /* TODO(ConditionalExpression): endsInOptional ? InferencePriority.SpeculativeTuple : 0 */, TODO)
							} else if middleLength == 1 && /* TODO(ElementAccessExpression): elementFlags[startLength] */ TODO&ElementFlagsRest {
								restType := getElementTypeOfSliceOfTupleType(source, startLength, endLength)
								if restType {
									inferFromTypes(restType /* TODO(ElementAccessExpression): elementTypes[startLength] */, TODO)
								}
							}
						}
						/* TODO(ForStatement): for (let i = 0; i < endLength; i++) {                             inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);                         } */
						return
					}
					if isArrayType(target) {
						inferFromIndexTypes(source, target)
						return
					}
				}
				inferFromProperties(source, target)
				inferFromSignatures(source, target, SignatureKindCall)
				inferFromSignatures(source, target, SignatureKindConstruct)
				inferFromIndexTypes(source, target)
			}
		}
		inferFromProperties := func(source Type, target Type) {
			properties := getPropertiesOfObjectType(target)
			for _, targetProp := range properties {
				sourceProp := getPropertyOfType(source, targetProp.escapedName)
				if sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag) {
					inferFromTypes(removeMissingType(getTypeOfSymbol(sourceProp), !!(sourceProp.flags&SymbolFlagsOptional)), removeMissingType(getTypeOfSymbol(targetProp), !!(targetProp.flags&SymbolFlagsOptional)))
				}
			}
		}
		inferFromSignatures := func(source Type, target Type, kind SignatureKind) {
			sourceSignatures := getSignaturesOfType(source, kind)
			sourceLen := sourceSignatures.length
			if sourceLen > 0 {
				targetSignatures := getSignaturesOfType(target, kind)
				targetLen := targetSignatures.length
				/* TODO(ForStatement): for (let i = 0; i < targetLen; i++) {                     const sourceIndex = Math.max(sourceLen - targetLen + i, 0);                     inferFromSignature(getBaseSignature(sourceSignatures[sourceIndex]), getErasedSignature(targetSignatures[i]));                 } */
			}
		}
		inferFromSignature := func(source Signature, target Signature) {
			if !(source.flags & SignatureFlagsIsNonInferrable) {
				saveBivariant := bivariant
				kind := /* TODO(ConditionalExpression): target.declaration ? target.declaration.kind : SyntaxKind.Unknown */ TODO
				bivariant = bivariant || kind == SyntaxKindMethodDeclaration || kind == SyntaxKindMethodSignature || kind == SyntaxKindConstructor
				applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes)
				bivariant = saveBivariant
			}
			applyToReturnTypes(source, target, inferFromTypes)
		}
		inferFromIndexTypes := func(source Type, target Type) {
			priority := /* TODO(ConditionalExpression): (getObjectFlags(source) & getObjectFlags(target) & ObjectFlags.Mapped) ? InferencePriority.HomomorphicMappedType : 0 */ TODO
			indexInfos := getIndexInfosOfType(target)
			if isObjectTypeWithInferableIndex(source) {
				for _, targetInfo := range indexInfos {
					var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
					for _, prop := range getPropertiesOfType(source) {
						if isApplicableIndexType(getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique), targetInfo.keyType) {
							propType := getTypeOfSymbol(prop)
							propTypes.push( /* TODO(ConditionalExpression): prop.flags & SymbolFlags.Optional ? removeMissingOrUndefinedType(propType) : propType */ TODO)
						}
					}
					for _, info := range getIndexInfosOfType(source) {
						if isApplicableIndexType(info.keyType, targetInfo.keyType) {
							propTypes.push(info.type_)
						}
					}
					if propTypes.length {
						inferWithPriority(getUnionType(propTypes), targetInfo.type_, priority)
					}
				}
			}
			for _, targetInfo := range indexInfos {
				sourceInfo := getApplicableIndexInfo(source, targetInfo.keyType)
				if sourceInfo {
					inferWithPriority(sourceInfo.type_, targetInfo.type_, priority)
				}
			}
		}
	}
	isTypeOrBaseIdenticalTo := func(s Type, t Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): t === missingType ? s === t :             (isTypeIdenticalTo(s, t) || !!(t.flags & TypeFlags.String && s.flags & TypeFlags.StringLiteral || t.flags & TypeFlags.Number && s.flags & TypeFlags.NumberLiteral)) */ TODO
	}
	isTypeCloselyMatchedBy := func(s Type, t Type) /* TODO(undefined): boolean */ TODO {
		return !!(s.flags&TypeFlagsObject && t.flags&TypeFlagsObject && s.symbol && s.symbol == t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol == t.aliasSymbol)
	}
	hasPrimitiveConstraint := func(type_ TypeParameter) bool {
		constraint := getConstraintOfTypeParameter(type_)
		return !!constraint && maybeTypeOfKind( /* TODO(ConditionalExpression): constraint.flags & TypeFlags.Conditional ? getDefaultConstraintOfConditionalType(constraint as ConditionalType) : constraint */ TODO, TypeFlagsPrimitive|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping)
	}
	isObjectLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(getObjectFlags(type_) & ObjectFlagsObjectLiteral)
	}
	isObjectOrArrayLiteralType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return !!(getObjectFlags(type_) & (ObjectFlagsObjectLiteral | ObjectFlagsArrayLiteral))
	}
	unionObjectAndArrayLiteralCandidates := func(candidates []Type) []Type {
		if candidates.length > 1 {
			objectLiterals := filter(candidates, isObjectOrArrayLiteralType)
			if objectLiterals.length {
				literalsType := getUnionType(objectLiterals, UnionReductionSubtype)
				return concatenate(filter(candidates, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): isObjectOrArrayLiteralType(t) */
				}), /* TODO(ArrayLiteralExpression): [literalsType] */ TODO)
			}
		}
		return candidates
	}
	getContravariantInference := func(inference InferenceInfo) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ? getIntersectionType(inference.contraCandidates!) : getCommonSubtype(inference.contraCandidates!) */ TODO
	}
	getCovariantInference := func(inference InferenceInfo, signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		candidates := unionObjectAndArrayLiteralCandidates( /* TODO(NonNullExpression): inference.candidates! */ TODO)
		primitiveConstraint := hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter)
		widenLiteralTypes := !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter))
		baseCandidates := /* TODO(ConditionalExpression): primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) :             widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) :             candidates */ TODO
		unwidenedType := /* TODO(ConditionalExpression): inference.priority! & InferencePriority.PriorityImpliesCombination ?             getUnionType(baseCandidates, UnionReduction.Subtype) :             getCommonSupertype(baseCandidates) */ TODO
		return getWidenedType(unwidenedType)
	}
	getInferredType := func(context InferenceContext, index number) Type {
		inference := /* TODO(ElementAccessExpression): context.inferences[index] */ TODO
		if !inference.inferredType {
			var inferredType *Type
			var fallbackType *Type
			if context.signature {
				inferredCovariantType := /* TODO(ConditionalExpression): inference.candidates ? getCovariantInference(inference, context.signature) : undefined */ TODO
				inferredContravariantType := /* TODO(ConditionalExpression): inference.contraCandidates ? getContravariantInference(inference) : undefined */ TODO
				if inferredCovariantType || inferredContravariantType {
					preferCovariantType := inferredCovariantType && (!inferredContravariantType || !(inferredCovariantType.flags&(TypeFlagsNever|TypeFlagsAny)) && some(inference.contraCandidates, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(Identifier): isTypeAssignableTo */
						/* TODO(Identifier): inferredCovariantType */
						/* TODO(Identifier): t */
					}) && every(context.inferences, func(other /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(BinaryExpression): other !== inference && getConstraintOfTypeParameter(other.typeParameter) !== inference.typeParameter */
						/* TODO(BarBarToken): || */
						/* TODO(CallExpression): every(other.candidates, t => isTypeAssignableTo(t, inferredCovariantType)) */
					}))
					inferredType = /* TODO(ConditionalExpression): preferCovariantType ? inferredCovariantType : inferredContravariantType */ TODO
					fallbackType = /* TODO(ConditionalExpression): preferCovariantType ? inferredContravariantType : inferredCovariantType */ TODO
				} else if context.flags & InferenceFlagsNoDefault {
					inferredType = silentNeverType
				} else {
					defaultType := getDefaultFromTypeParameter(inference.typeParameter)
					if defaultType {
						inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper))
					}
				}
			} else {
				inferredType = getTypeFromInference(inference)
			}
			inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & InferenceFlagsAnyDefault))
			constraint := getConstraintOfTypeParameter(inference.typeParameter)
			if constraint {
				instantiatedConstraint := instantiateType(constraint, context.nonFixingMapper)
				if !inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType)) {
					inference.inferredType = /* TODO(ConditionalExpression): fallbackType && context.compareTypes(fallbackType, getTypeWithThisArgument(instantiatedConstraint, fallbackType)) ? fallbackType : instantiatedConstraint */ TODO
				}
			}
		}
		return inference.inferredType
	}
	getDefaultTypeArgumentType := func(isInJavaScriptFile bool) Type {
		return /* TODO(ConditionalExpression): isInJavaScriptFile ? anyType : unknownType */ TODO
	}
	getInferredTypes := func(context InferenceContext) []Type {
		var result []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < context.inferences.length; i++) {             result.push(getInferredType(context, i));         } */
		return result
	}
	getCannotFindNameDiagnosticForName := func(node Identifier) DiagnosticMessage {
		/* TODO(SwitchStatement): switch (node.escapedText) {             case "document":             case "console":                 return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;             case "$":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery;             case "describe":             case "suite":             case "it":             case "test":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha;             case "process":             case "require":             case "Buffer":             case "module":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode;             case "Bun":                 return compilerOptions.types                     ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun_and_then_add_bun_to_the_types_field_in_your_tsconfig                     : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_Bun_Try_npm_i_save_dev_types_Slashbun;             case "Map":             case "Set":             case "Promise":             case "Symbol":             case "WeakMap":             case "WeakSet":             case "Iterator":             case "AsyncIterator":             case "SharedArrayBuffer":             case "Atomics":             case "AsyncIterable":             case "AsyncIterableIterator":             case "AsyncGenerator":             case "AsyncGeneratorFunction":             case "BigInt":             case "Reflect":             case "BigInt64Array":             case "BigUint64Array":                 return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later;             case "await":                 if (isCallExpression(node.parent)) {                     return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function;                 }                 // falls through             default:                 if (node.parent.kind === SyntaxKind.ShorthandPropertyAssignment) {                     return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;                 }                 else {                     return Diagnostics.Cannot_find_name_0;                 }         } */
	}
	getResolvedSymbol := func(node Identifier) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			links.resolvedSymbol = !nodeIsMissing(node) && resolveName(node, node, SymbolFlagsValue|SymbolFlagsExportValue, getCannotFindNameDiagnosticForName(node), !isWriteOnlyAccess(node), false) || unknownSymbol
		}
		return links.resolvedSymbol
	}
	isInAmbientOrTypeNode := func(node Node) bool {
		return !!(node.flags&NodeFlagsAmbient || findAncestor(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): isInterfaceDeclaration(n) || isTypeAliasDeclaration(n) */
			/* TODO(BarBarToken): || */
			/* TODO(CallExpression): isTypeLiteralNode(n) */
		}))
	}
	getFlowCacheKey := func(node Node, declaredType Type, initialType Type, flowContainer Node) /* TODO(StringKeyword): string */ any {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 if (!isThisInTypeQuery(node)) {                     const symbol = getResolvedSymbol(node as Identifier);                     return symbol !== unknownSymbol ? `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` : undefined;                 }                 // falls through             case SyntaxKind.ThisKeyword:                 return `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}`;             case SyntaxKind.NonNullExpression:             case SyntaxKind.ParenthesizedExpression:                 return getFlowCacheKey((node as NonNullExpression | ParenthesizedExpression).expression, declaredType, initialType, flowContainer);             case SyntaxKind.QualifiedName:                 const left = getFlowCacheKey((node as QualifiedName).left, declaredType, initialType, flowContainer);                 return left && `${left}.${(node as QualifiedName).right.escapedText}`;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const propName = getAccessedPropertyName(node as AccessExpression);                 if (propName !== undefined) {                     const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);                     return key && `${key}.${propName}`;                 }                 if (isElementAccessExpression(node) && isIdentifier(node.argumentExpression)) {                     const symbol = getResolvedSymbol(node.argumentExpression);                     if (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)) {                         const key = getFlowCacheKey((node as AccessExpression).expression, declaredType, initialType, flowContainer);                         return key && `${key}.@${getSymbolId(symbol)}`;                     }                 }                 break;             case SyntaxKind.ObjectBindingPattern:             case SyntaxKind.ArrayBindingPattern:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:                 // Handle pseudo-references originating in getNarrowedTypeOfSymbol.                 return `${getNodeId(node)}#${getTypeId(declaredType)}`;         } */
		return nil
	}
	isMatchingReference := func(source Node, target Node) bool {
		/* TODO(SwitchStatement): switch (target.kind) {             case SyntaxKind.ParenthesizedExpression:             case SyntaxKind.NonNullExpression:                 return isMatchingReference(source, (target as NonNullExpression | ParenthesizedExpression).expression);             case SyntaxKind.BinaryExpression:                 return (isAssignmentExpression(target) && isMatchingReference(source, target.left)) ||                     (isBinaryExpression(target) && target.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source, target.right));         } */
		/* TODO(SwitchStatement): switch (source.kind) {             case SyntaxKind.MetaProperty:                 return target.kind === SyntaxKind.MetaProperty                     && (source as MetaProperty).keywordToken === (target as MetaProperty).keywordToken                     && (source as MetaProperty).name.escapedText === (target as MetaProperty).name.escapedText;             case SyntaxKind.Identifier:             case SyntaxKind.PrivateIdentifier:                 return isThisInTypeQuery(source) ?                     target.kind === SyntaxKind.ThisKeyword :                     target.kind === SyntaxKind.Identifier && getResolvedSymbol(source as Identifier) === getResolvedSymbol(target as Identifier) ||                     (isVariableDeclaration(target) || isBindingElement(target)) &&                         getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source as Identifier)) === getSymbolOfDeclaration(target);             case SyntaxKind.ThisKeyword:                 return target.kind === SyntaxKind.ThisKeyword;             case SyntaxKind.SuperKeyword:                 return target.kind === SyntaxKind.SuperKeyword;             case SyntaxKind.NonNullExpression:             case SyntaxKind.ParenthesizedExpression:                 return isMatchingReference((source as NonNullExpression | ParenthesizedExpression).expression, target);             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const sourcePropertyName = getAccessedPropertyName(source as AccessExpression);                 if (sourcePropertyName !== undefined) {                     const targetPropertyName = isAccessExpression(target) ? getAccessedPropertyName(target) : undefined;                     if (targetPropertyName !== undefined) {                         return targetPropertyName === sourcePropertyName && isMatchingReference((source as AccessExpression).expression, (target as AccessExpression).expression);                     }                 }                 if (isElementAccessExpression(source) && isElementAccessExpression(target) && isIdentifier(source.argumentExpression) && isIdentifier(target.argumentExpression)) {                     const symbol = getResolvedSymbol(source.argumentExpression);                     if (symbol === getResolvedSymbol(target.argumentExpression) && (isConstantVariable(symbol) || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol))) {                         return isMatchingReference(source.expression, target.expression);                     }                 }                 break;             case SyntaxKind.QualifiedName:                 return isAccessExpression(target) &&                     (source as QualifiedName).right.escapedText === getAccessedPropertyName(target) &&                     isMatchingReference((source as QualifiedName).left, target.expression);             case SyntaxKind.BinaryExpression:                 return (isBinaryExpression(source) && source.operatorToken.kind === SyntaxKind.CommaToken && isMatchingReference(source.right, target));         } */
		return false
	}
	getAccessedPropertyName := func(access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any) *__String {
		if isPropertyAccessExpression(access) {
			return access.name.escapedText
		}
		if isElementAccessExpression(access) {
			return tryGetElementAccessExpressionName(access)
		}
		if isBindingElement(access) {
			name := getDestructuringPropertyName(access)
			return /* TODO(ConditionalExpression): name ? escapeLeadingUnderscores(name) : undefined */ TODO
		}
		if isParameter(access) {
			return ( /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + access.parent.parameters.indexOf(access) */ TODO) /* as */ /* TODO(TypeReference): __String */
		}
		return nil
	}
	tryGetNameFromType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UniqueESSymbol ? (type as UniqueESSymbolType).escapedName :             type.flags & TypeFlags.StringOrNumberLiteral ? escapeLeadingUnderscores("" + (type as StringLiteralType | NumberLiteralType).value) : undefined */ TODO
	}
	tryGetElementAccessExpressionName := func(node ElementAccessExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return /* TODO(ConditionalExpression): isStringOrNumericLiteralLike(node.argumentExpression) ? escapeLeadingUnderscores(node.argumentExpression.text) :             isEntityNameExpression(node.argumentExpression) ? tryGetNameFromEntityNameExpression(node.argumentExpression) : undefined */ TODO
	}
	tryGetNameFromEntityNameExpression := func(node EntityNameOrEntityNameExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		symbol := resolveEntityName(node, SymbolFlagsValue, true)
		if !symbol || !(isConstantVariable(symbol) || (symbol.flags & SymbolFlagsEnumMember)) {
			/* TODO(Identifier): undefined */
		}
		declaration := symbol.valueDeclaration
		if declaration == nil {
			/* TODO(Identifier): undefined */
		}
		type_ := tryGetTypeFromEffectiveTypeNode(declaration)
		if type_ {
			name := tryGetNameFromType(type_)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name !== undefined */ TODO {
				return name
			}
		}
		if hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node) {
			initializer := getEffectiveInitializer(declaration)
			if initializer {
				initializerType := /* TODO(ConditionalExpression): isBindingPattern(declaration.parent) ? getTypeForBindingElement(declaration as BindingElement) : getTypeOfExpression(initializer) */ TODO
				return initializerType && tryGetNameFromType(initializerType)
			}
			if isEnumMember(declaration) {
				return getTextOfPropertyName(declaration.name)
			}
		}
		return nil
	}
	containsMatchingReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
		/* TODO(WhileStatement): while (isAccessExpression(source)) {             source = source.expression;             if (isMatchingReference(source, target)) {                 return true;             }         } */
		return false
	}
	optionalChainContainsReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
		/* TODO(WhileStatement): while (isOptionalChain(source)) {             source = source.expression;             if (isMatchingReference(source, target)) {                 return true;             }         } */
		return false
	}
	isDiscriminantProperty := func(type_ *Type, name __String) /* TODO(undefined): boolean */ TODO {
		if type_ && type_.flags&TypeFlagsUnion {
			prop := getUnionOrIntersectionProperty(type_ /* as */ /* TODO(TypeReference): UnionType */, name)
			if prop && getCheckFlags(prop)&CheckFlagsSyntheticProperty {
				if (prop /* as */ /* TODO(TypeReference): TransientSymbol */).links.isDiscriminantProperty == nil {
					(prop /* as */ /* TODO(TypeReference): TransientSymbol */).links.isDiscriminantProperty = ((prop /* as */ /* TODO(TypeReference): TransientSymbol */).links.checkFlags&CheckFlagsDiscriminant) == CheckFlagsDiscriminant && !isGenericType(getTypeOfSymbol(prop))
				}
				return !!(prop /* as */ /* TODO(TypeReference): TransientSymbol */).links.isDiscriminantProperty
			}
		}
		return false
	}
	findDiscriminantProperties := func(sourceProperties []Symbol, target Type) /* TODO(ArrayType): Symbol[] */ any {
		var result /* TODO(ArrayType): Symbol[] */ any
		for _, sourceProperty := range sourceProperties {
			if isDiscriminantProperty(target, sourceProperty.escapedName) {
				if result {
					result.push(sourceProperty)
					/* TODO(ContinueStatement): continue; */
				}
				result = /* TODO(ArrayLiteralExpression): [sourceProperty] */ TODO
			}
		}
		return result
	}
	mapTypesByKeyProperty := func(types []Type, name __String) /* TODO(undefined): Map<number, import("/home/jabaile/work/TypeScript/src/compiler/types").Type> | undefined */ TODO {
		map_ := /* TODO(NewExpression): new Map<TypeId, Type>() */ TODO
		count := 0
		for _, type_ := range types {
			if type_.flags & (TypeFlagsObject | TypeFlagsIntersection | TypeFlagsInstantiableNonPrimitive) {
				discriminant := getTypeOfPropertyOfType(type_, name)
				if discriminant {
					if !isLiteralType(discriminant) {
						return nil
					}
					duplicate := false
					forEachType(discriminant, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
						id := getTypeId(getRegularTypeOfLiteralType(t))
						existing := map_.get(id)
						if !existing {
							map_.set(id, type_)
						} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): existing !== unknownType */ TODO {
							map_.set(id, unknownType)
							duplicate = true
						}
					})
					if !duplicate {
						/* TODO(PostfixUnaryExpression): count++ */
					}
				}
			}
		}
		return /* TODO(ConditionalExpression): count >= 10 && count * 2 >= types.length ? map : undefined */ TODO
	}
	getKeyPropertyName := func(unionType UnionType) *__String {
		types := unionType.types
		if types.length < 10 || getObjectFlags(unionType)&ObjectFlagsPrimitiveUnion || countWhere(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive)) */
		}) < 10 {
			return nil
		}
		if unionType.keyPropertyName == nil {
			keyPropertyName := forEach(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): (string & { __escapedIdentifier: void; }) | (void & { __escapedIdentifier: void; }) | import("/home/jabaile/work/TypeScript/src/compiler/types").InternalSymbolName | undefined */ TODO {
				/* TODO(BinaryExpression): t.flags & (TypeFlags.Object | TypeFlags.InstantiableNonPrimitive) */
				/* TODO(QuestionToken): ? */
				/* TODO(CallExpression): forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : undefined) */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): undefined */
			})
			mapByKeyProperty := keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName)
			unionType.keyPropertyName = /* TODO(ConditionalExpression): mapByKeyProperty ? keyPropertyName : "" as __String */ TODO
			unionType.constituentMap = mapByKeyProperty
		}
		return /* TODO(ConditionalExpression): (unionType.keyPropertyName as string).length ? unionType.keyPropertyName : undefined */ TODO
	}
	getConstituentTypeForKeyType := func(unionType UnionType, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		result := unionType.constituentMap.get(getTypeId(getRegularTypeOfLiteralType(keyType)))
		return /* TODO(ConditionalExpression): result !== unknownType ? result : undefined */ TODO
	}
	getMatchingUnionConstituentForType := func(unionType UnionType, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		keyPropertyName := getKeyPropertyName(unionType)
		propType := keyPropertyName && getTypeOfPropertyOfType(type_, keyPropertyName)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	getMatchingUnionConstituentForObjectLiteral := func(unionType UnionType, node ObjectLiteralExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		keyPropertyName := getKeyPropertyName(unionType)
		propNode := keyPropertyName && find(node.properties, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").MethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").GetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").SetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").ShorthandPropertyAssignment | import("/home/jabaile/work/TypeScript/src/compiler/types").SpreadAssignment */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): p.symbol && p.kind === SyntaxKind.PropertyAssignment &&             p.symbol.escapedName === keyPropertyName */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isPossiblyDiscriminantValue(p.initializer) */
		})
		propType := propNode && getContextFreeTypeOfExpression((propNode /* as */ /* TODO(TypeReference): PropertyAssignment */).initializer)
		return propType && getConstituentTypeForKeyType(unionType, propType)
	}
	isOrContainsMatchingReference := func(source Node, target Node) /* TODO(undefined): boolean */ TODO {
		return isMatchingReference(source, target) || containsMatchingReference(source, target)
	}
	hasMatchingArgument := func(expression /* TODO(UnionType): CallExpression | NewExpression */ any, reference Node) /* TODO(undefined): boolean */ TODO {
		if expression.arguments {
			for _, argument := range expression.arguments {
				if isOrContainsMatchingReference(reference, argument) || optionalChainContainsReference(argument, reference) {
					return true
				}
			}
		}
		if expression.expression.kind == SyntaxKindPropertyAccessExpression && isOrContainsMatchingReference(reference, (expression.expression /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression) {
			return true
		}
		return false
	}
	getFlowNodeId := func(flow FlowNode) number {
		if flow.id <= 0 {
			flow.id = nextFlowId
			nextFlowId++
		}
		return flow.id
	}
	typeMaybeAssignableTo := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		if !(source.flags & TypeFlagsUnion) {
			return isTypeAssignableTo(source, target)
		}
		for _, t := range (source /* as */ /* TODO(TypeReference): UnionType */).types {
			if isTypeAssignableTo(t, target) {
				return true
			}
		}
		return false
	}
	getAssignmentReducedType := func(declaredType UnionType, assignedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if declaredType == assignedType {
			return declaredType
		}
		if assignedType.flags & TypeFlagsNever {
			return assignedType
		}
		key := /* TODO(TemplateExpression): `A${getTypeId(declaredType)},${getTypeId(assignedType)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType)) */ TODO
	}
	getAssignmentReducedTypeWorker := func(declaredType UnionType, assignedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		filteredType := filterType(declaredType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): typeMaybeAssignableTo */
			/* TODO(Identifier): assignedType */
			/* TODO(Identifier): t */
		})
		reducedType := /* TODO(ConditionalExpression): assignedType.flags & TypeFlags.BooleanLiteral && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType */ TODO
		return /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, reducedType) ? reducedType : declaredType */ TODO
	}
	isFunctionObjectType := func(type_ ObjectType) bool {
		if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
			return false
		}
		resolved := resolveStructuredTypeMembers(type_)
		return !!(resolved.callSignatures.length || resolved.constructSignatures.length || resolved.members.get("bind" /* as */ /* TODO(TypeReference): __String */) && isTypeSubtypeOf(type_, globalFunctionType))
	}
	getTypeFacts := func(type_ Type, mask TypeFacts) TypeFacts {
		return getTypeFactsWorker(type_, mask) & mask
	}
	hasTypeFacts := func(type_ Type, mask TypeFacts) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getTypeFacts(type, mask) !== 0 */ TODO
	}
	getTypeFactsWorker := func(type_ Type, callerOnlyNeeds TypeFacts) TypeFacts {
		if type_.flags & (TypeFlagsIntersection | TypeFlagsInstantiable) {
			type_ = getBaseConstraintOfType(type_) || unknownType
		}
		flags := type_.flags
		if flags & (TypeFlagsString | TypeFlagsStringMapping) {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.StringStrictFacts : TypeFacts.StringFacts */ TODO
		}
		if flags & (TypeFlagsStringLiteral | TypeFlagsTemplateLiteral) {
			isEmpty := flags&TypeFlagsStringLiteral && (type_ /* as */ /* TODO(TypeReference): StringLiteralType */).value == ""
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isEmpty ? TypeFacts.EmptyStringStrictFacts : TypeFacts.NonEmptyStringStrictFacts :                 isEmpty ? TypeFacts.EmptyStringFacts : TypeFacts.NonEmptyStringFacts */ TODO
		}
		if flags & (TypeFlagsNumber | TypeFlagsEnum) {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.NumberStrictFacts : TypeFacts.NumberFacts */ TODO
		}
		if flags & TypeFlagsNumberLiteral {
			isZero := (type_ /* as */ /* TODO(TypeReference): NumberLiteralType */).value == 0
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroNumberStrictFacts : TypeFacts.NonZeroNumberStrictFacts :                 isZero ? TypeFacts.ZeroNumberFacts : TypeFacts.NonZeroNumberFacts */ TODO
		}
		if flags & TypeFlagsBigInt {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BigIntStrictFacts : TypeFacts.BigIntFacts */ TODO
		}
		if flags & TypeFlagsBigIntLiteral {
			isZero := isZeroBigInt(type_ /* as */ /* TODO(TypeReference): BigIntLiteralType */)
			return /* TODO(ConditionalExpression): strictNullChecks ?                 isZero ? TypeFacts.ZeroBigIntStrictFacts : TypeFacts.NonZeroBigIntStrictFacts :                 isZero ? TypeFacts.ZeroBigIntFacts : TypeFacts.NonZeroBigIntFacts */ TODO
		}
		if flags & TypeFlagsBoolean {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.BooleanStrictFacts : TypeFacts.BooleanFacts */ TODO
		}
		if flags & TypeFlagsBooleanLike {
			return /* TODO(ConditionalExpression): strictNullChecks ?                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseStrictFacts : TypeFacts.TrueStrictFacts :                 (type === falseType || type === regularFalseType) ? TypeFacts.FalseFacts : TypeFacts.TrueFacts */ TODO
		}
		if flags & TypeFlagsObject {
			possibleFacts := /* TODO(ConditionalExpression): strictNullChecks                 ? TypeFacts.EmptyObjectStrictFacts | TypeFacts.FunctionStrictFacts | TypeFacts.ObjectStrictFacts                 : TypeFacts.EmptyObjectFacts | TypeFacts.FunctionFacts | TypeFacts.ObjectFacts */ TODO
			if (callerOnlyNeeds & possibleFacts) == 0 {
				return 0
			}
			return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Anonymous && isEmptyObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.EmptyObjectStrictFacts : TypeFacts.EmptyObjectFacts :                 isFunctionObjectType(type as ObjectType) ?                 strictNullChecks ? TypeFacts.FunctionStrictFacts : TypeFacts.FunctionFacts :                 strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
		}
		if flags & TypeFlagsVoid {
			return TypeFactsVoidFacts
		}
		if flags & TypeFlagsUndefined {
			return TypeFactsUndefinedFacts
		}
		if flags & TypeFlagsNull {
			return TypeFactsNullFacts
		}
		if flags & TypeFlagsESSymbolLike {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.SymbolStrictFacts : TypeFacts.SymbolFacts */ TODO
		}
		if flags & TypeFlagsNonPrimitive {
			return /* TODO(ConditionalExpression): strictNullChecks ? TypeFacts.ObjectStrictFacts : TypeFacts.ObjectFacts */ TODO
		}
		if flags & TypeFlagsNever {
			return TypeFactsNone
		}
		if flags & TypeFlagsUnion {
			return reduceLeft((type_ /* as */ /* TODO(TypeReference): UnionType */).types, func(facts /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/checker").TypeFacts.None */ TODO, t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): number */ TODO {
				/* TODO(Identifier): facts */
				/* TODO(BarToken): | */
				/* TODO(CallExpression): getTypeFactsWorker(t, callerOnlyNeeds) */
			}, TypeFactsNone)
		}
		if flags & TypeFlagsIntersection {
			return getIntersectionTypeFacts(type_ /* as */ /* TODO(TypeReference): IntersectionType */, callerOnlyNeeds)
		}
		return TypeFactsUnknownFacts
	}
	getIntersectionTypeFacts := func(type_ IntersectionType, callerOnlyNeeds TypeFacts) TypeFacts {
		ignoreObjects := maybeTypeOfKind(type_, TypeFlagsPrimitive)
		oredFacts := TypeFactsNone
		andedFacts := TypeFactsAll
		for _, t := range type_.types {
			if !(ignoreObjects && t.flags&TypeFlagsObject) {
				f := getTypeFactsWorker(t, callerOnlyNeeds)
				oredFacts |= f
				andedFacts &= f
			}
		}
		return oredFacts&TypeFactsOrFactsMask | andedFacts&TypeFactsAndFactsMask
	}
	getTypeWithFacts := func(type_ Type, include TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): hasTypeFacts */
			/* TODO(Identifier): t */
			/* TODO(Identifier): include */
		})
	}
	getAdjustedTypeWithFacts := func(type_ Type, facts TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		reduced := recombineUnknownType(getTypeWithFacts( /* TODO(ConditionalExpression): strictNullChecks && type.flags & TypeFlags.Unknown ? unknownUnionType : type */ TODO, facts))
		if strictNullChecks {
			/* TODO(SwitchStatement): switch (facts) {                 case TypeFacts.NEUndefined:                     return removeNullableByIntersection(reduced, TypeFacts.EQUndefined, TypeFacts.EQNull, TypeFacts.IsNull, nullType);                 case TypeFacts.NENull:                     return removeNullableByIntersection(reduced, TypeFacts.EQNull, TypeFacts.EQUndefined, TypeFacts.IsUndefined, undefinedType);                 case TypeFacts.NEUndefinedOrNull:                 case TypeFacts.Truthy:                     return mapType(reduced, t => hasTypeFacts(t, TypeFacts.EQUndefinedOrNull) ? getGlobalNonNullableTypeInstantiation(t) : t);             } */
		}
		return reduced
	}
	removeNullableByIntersection := func(type_ Type, targetFacts TypeFacts, otherFacts TypeFacts, otherIncludesFacts TypeFacts, otherType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		facts := getTypeFacts(type_, TypeFactsEQUndefined|TypeFactsEQNull|TypeFactsIsUndefined|TypeFactsIsNull)
		if !(facts & targetFacts) {
			return type_
		}
		emptyAndOtherUnion := getUnionType( /* TODO(ArrayLiteralExpression): [emptyObjectType, otherType] */ TODO)
		return mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(CallExpression): hasTypeFacts(t, targetFacts) */
			/* TODO(QuestionToken): ? */
			/* TODO(CallExpression): getIntersectionType([t, !(facts & otherIncludesFacts) && hasTypeFacts(t, otherFacts) ? emptyAndOtherUnion : emptyObjectType]) */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): t */
		})
	}
	recombineUnknownType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type === unknownUnionType ? unknownType : type */ TODO
	}
	getTypeWithDefault := func(type_ Type, defaultExpression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): defaultExpression ?             getUnionType([getNonUndefinedType(type), getTypeOfExpression(defaultExpression)]) :             type */ TODO
	}
	getTypeOfDestructuredProperty := func(type_ Type, name PropertyName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		nameType := getLiteralTypeFromPropertyName(name)
		if !isTypeUsableAsPropertyName(nameType) {
			/* TODO(Identifier): errorType */
		}
		text := getPropertyNameFromType(nameType)
		return getTypeOfPropertyOfType(type_, text) || includeUndefinedInIndexSignature(getApplicableIndexInfoForName(type_, text).type_) || errorType
	}
	getTypeOfDestructuredArrayElement := func(type_ Type, index number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return everyType(type_, isTupleLikeType) && getTupleElementType(type_, index) || includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType, nil)) || errorType
	}
	includeUndefinedInIndexSignature := func(type_ *Type) *Type {
		if !type_ {
			/* TODO(Identifier): type */
		}
		return /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ?             getUnionType([type, missingType]) :             type */ TODO
	}
	getTypeOfDestructuredSpreadExpression := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return createArrayType(checkIteratedTypeOrElementType(IterationUseDestructuring, type_, undefinedType, nil) || errorType)
	}
	getAssignedTypeOfBinaryExpression := func(node BinaryExpression) Type {
		isDestructuringDefaultAssignment := node.parent.kind == SyntaxKindArrayLiteralExpression && isDestructuringAssignmentTarget(node.parent) || node.parent.kind == SyntaxKindPropertyAssignment && isDestructuringAssignmentTarget(node.parent.parent)
		return /* TODO(ConditionalExpression): isDestructuringDefaultAssignment ?             getTypeWithDefault(getAssignedType(node), node.right) :             getTypeOfExpression(node.right) */ TODO
	}
	isDestructuringAssignmentTarget := func(parent Node) /* TODO(undefined): boolean */ TODO {
		return parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent /* as */ /* TODO(TypeReference): BinaryExpression */).left == parent || parent.parent.kind == SyntaxKindForOfStatement && (parent.parent /* as */ /* TODO(TypeReference): ForOfStatement */).initializer == parent
	}
	getAssignedTypeOfArrayLiteralElement := func(node ArrayLiteralExpression, element Expression) Type {
		return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element))
	}
	getAssignedTypeOfSpreadExpression := func(node SpreadElement) Type {
		return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent /* as */ /* TODO(TypeReference): ArrayLiteralExpression */))
	}
	getAssignedTypeOfPropertyAssignment := func(node /* TODO(UnionType): PropertyAssignment | ShorthandPropertyAssignment */ any) Type {
		return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name)
	}
	getAssignedTypeOfShorthandPropertyAssignment := func(node ShorthandPropertyAssignment) Type {
		return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node) /* TODO(NonNullExpression): node.objectAssignmentInitializer! */, TODO)
	}
	getAssignedType := func(node Expression) Type {
		TODO_IDENTIFIER := node
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.ForInStatement:                 return stringType;             case SyntaxKind.ForOfStatement:                 return checkRightHandSideOfForOf(parent as ForOfStatement) || errorType;             case SyntaxKind.BinaryExpression:                 return getAssignedTypeOfBinaryExpression(parent as BinaryExpression);             case SyntaxKind.DeleteExpression:                 return undefinedType;             case SyntaxKind.ArrayLiteralExpression:                 return getAssignedTypeOfArrayLiteralElement(parent as ArrayLiteralExpression, node);             case SyntaxKind.SpreadElement:                 return getAssignedTypeOfSpreadExpression(parent as SpreadElement);             case SyntaxKind.PropertyAssignment:                 return getAssignedTypeOfPropertyAssignment(parent as PropertyAssignment);             case SyntaxKind.ShorthandPropertyAssignment:                 return getAssignedTypeOfShorthandPropertyAssignment(parent as ShorthandPropertyAssignment);         } */
		return errorType
	}
	getInitialTypeOfBindingElement := func(node BindingElement) Type {
		pattern := node.parent
		parentType := getInitialType(pattern.parent /* as */ /* TODO(UnionType): VariableDeclaration | BindingElement */)
		type_ := /* TODO(ConditionalExpression): pattern.kind === SyntaxKind.ObjectBindingPattern ?             getTypeOfDestructuredProperty(parentType, node.propertyName || node.name as Identifier) :             !node.dotDotDotToken ?             getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node)) :             getTypeOfDestructuredSpreadExpression(parentType) */ TODO
		return getTypeWithDefault(type_ /* TODO(NonNullExpression): node.initializer! */, TODO)
	}
	getTypeOfInitializer := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		return links.resolvedType || getTypeOfExpression(node)
	}
	getInitialTypeOfVariableDeclaration := func(node VariableDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if node.initializer {
			return getTypeOfInitializer(node.initializer)
		}
		if node.parent.parent.kind == SyntaxKindForInStatement {
			return stringType
		}
		if node.parent.parent.kind == SyntaxKindForOfStatement {
			return checkRightHandSideOfForOf(node.parent.parent) || errorType
		}
		return errorType
	}
	getInitialType := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration ?             getInitialTypeOfVariableDeclaration(node) :             getInitialTypeOfBindingElement(node) */ TODO
	}
	isEmptyArrayAssignment := func(node /* TODO(UnionType): VariableDeclaration | BindingElement | Expression */ any) /* TODO(undefined): boolean */ TODO {
		return node.kind == SyntaxKindVariableDeclaration && (node /* as */ /* TODO(TypeReference): VariableDeclaration */).initializer && isEmptyArrayLiteral( /* TODO(NonNullExpression): (node as VariableDeclaration).initializer! */ TODO) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.BindingElement */ TODO && node.parent.kind == SyntaxKindBinaryExpression && isEmptyArrayLiteral((node.parent /* as */ /* TODO(TypeReference): BinaryExpression */).right)
	}
	getReferenceCandidate := func(node Expression) Expression {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ParenthesizedExpression:                 return getReferenceCandidate((node as ParenthesizedExpression).expression);             case SyntaxKind.BinaryExpression:                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.BarBarEqualsToken:                     case SyntaxKind.AmpersandAmpersandEqualsToken:                     case SyntaxKind.QuestionQuestionEqualsToken:                         return getReferenceCandidate((node as BinaryExpression).left);                     case SyntaxKind.CommaToken:                         return getReferenceCandidate((node as BinaryExpression).right);                 }         } */
		return node
	}
	getReferenceRoot := func(node Node) Node {
		TODO_IDENTIFIER := node
		return /* TODO(ConditionalExpression): parent.kind === SyntaxKind.ParenthesizedExpression ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.EqualsToken && (parent as BinaryExpression).left === node ||                 parent.kind === SyntaxKind.BinaryExpression && (parent as BinaryExpression).operatorToken.kind === SyntaxKind.CommaToken && (parent as BinaryExpression).right === node ?             getReferenceRoot(parent) : node */ TODO
	}
	getTypeOfSwitchClause := func(clause /* TODO(UnionType): CaseClause | DefaultClause */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if clause.kind == SyntaxKindCaseClause {
			return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression))
		}
		return neverType
	}
	getSwitchClauseTypes := func(switchStatement SwitchStatement) []Type {
		links := getNodeLinks(switchStatement)
		if !links.switchTypes {
			links.switchTypes = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, clause := range switchStatement.caseBlock.clauses {
				links.switchTypes.push(getTypeOfSwitchClause(clause))
			}
		}
		return links.switchTypes
	}
	getSwitchClauseTypeOfWitnesses := func(switchStatement SwitchStatement) /* TODO(ArrayType): (string | undefined)[] */ any {
		if some(switchStatement.caseBlock.clauses, func(clause /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): clause.kind === SyntaxKind.CaseClause */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(PrefixUnaryExpression): !isStringLiteralLike(clause.expression) */
		}) {
			return nil
		}
		var witnesses [] /* TODO(StringKeyword): string */ any = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, clause := range switchStatement.caseBlock.clauses {
			text := /* TODO(ConditionalExpression): clause.kind === SyntaxKind.CaseClause ? (clause.expression as StringLiteralLike).text : undefined */ TODO
			witnesses.push( /* TODO(ConditionalExpression): text && !contains(witnesses, text) ? text : undefined */ TODO)
		}
		return witnesses
	}
	eachTypeContainedIn := func(source Type, types []Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ? !forEach((source as UnionType).types, t => !contains(types, t)) : contains(types, source) */ TODO
	}
	isTypeSubsetOf := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		return !!(source == target || source.flags&TypeFlagsNever || target.flags&TypeFlagsUnion && isTypeSubsetOfUnion(source, target /* as */ /* TODO(TypeReference): UnionType */))
	}
	isTypeSubsetOfUnion := func(source Type, target UnionType) /* TODO(undefined): boolean */ TODO {
		if source.flags & TypeFlagsUnion {
			for _, t := range (source /* as */ /* TODO(TypeReference): UnionType */).types {
				if !containsType(target.types, t) {
					return false
				}
			}
			return true
		}
		if source.flags&TypeFlagsEnumLike && getBaseTypeOfEnumLikeType(source /* as */ /* TODO(TypeReference): LiteralType */) == target {
			return true
		}
		return containsType(target.types, source)
	}
	forEachType := func(type_ Type, f func(t Type) *T) *T {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? forEach((type as UnionType).types, f) : f(type) */ TODO
	}
	someType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? some((type as UnionType).types, f) : f(type) */ TODO
	}
	everyType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? every((type as UnionType).types, f) : f(type) */ TODO
	}
	everyContainedType := func(type_ Type, f func(t Type) bool) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.UnionOrIntersection ? every((type as UnionOrIntersectionType).types, f) : f(type) */ TODO
	}
	filterType := func(type_ Type, f func(t Type) bool) Type {
		if type_.flags & TypeFlagsUnion {
			types := (type_ /* as */ /* TODO(TypeReference): UnionType */).types
			filtered := filter(types, f)
			if filtered == types {
				return type_
			}
			origin := (type_ /* as */ /* TODO(TypeReference): UnionType */).origin
			var newOrigin *Type
			if origin && origin.flags&TypeFlagsUnion {
				originTypes := (origin /* as */ /* TODO(TypeReference): UnionType */).types
				originFiltered := filter(originTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(PrefixUnaryExpression): !!(t.flags & TypeFlags.Union) */
					/* TODO(BarBarToken): || */
					/* TODO(CallExpression): f(t) */
				})
				if /* TODO(MinusToken): - */ /* TODO(BinaryExpression): originTypes.length - originFiltered.length */ TODO == /* TODO(MinusToken): - */ /* TODO(BinaryExpression): types.length - filtered.length */ TODO {
					if originFiltered.length == 1 {
						return /* TODO(ElementAccessExpression): originFiltered[0] */ TODO
					}
					newOrigin = createOriginUnionOrIntersectionType(TypeFlagsUnion, originFiltered)
				}
			}
			return getUnionTypeFromSortedList(filtered, (type_ /* as */ /* TODO(TypeReference): UnionType */).objectFlags&(ObjectFlagsPrimitiveUnion|ObjectFlagsContainsIntersections), nil, nil, newOrigin)
		}
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Never || f(type) ? type : neverType */ TODO
	}
	removeType := func(type_ Type, targetType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): t */
			/* TODO(ExclamationEqualsEqualsToken): !== */
			/* TODO(Identifier): targetType */
		})
	}
	countTypes := func(type_ Type) /* TODO(undefined): number */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? (type as UnionType).types.length : 1 */ TODO
	}
	// OVERLOAD: mapType := func(type_ Type, mapper func(t Type) Type, noReductions bool) Type
	// OVERLOAD: mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type
	mapType := func(type_ Type, mapper func(t Type) *Type, noReductions bool) *Type {
		if type_.flags & TypeFlagsNever {
			return type_
		}
		if !(type_.flags & TypeFlagsUnion) {
			return mapper(type_)
		}
		origin := (type_ /* as */ /* TODO(TypeReference): UnionType */).origin
		types := /* TODO(ConditionalExpression): origin && origin.flags & TypeFlags.Union ? (origin as UnionType).types : (type as UnionType).types */ TODO
		var mappedTypes /* TODO(ArrayType): Type[] */ any
		changed := false
		for _, t := range types {
			mapped := /* TODO(ConditionalExpression): t.flags & TypeFlags.Union ? mapType(t, mapper, noReductions) : mapper(t) */ TODO
			/* TODO(ExpressionStatement): changed ||= t !== mapped; */
			if mapped {
				if !mappedTypes {
					mappedTypes = /* TODO(ArrayLiteralExpression): [mapped] */ TODO
				} else {
					mappedTypes.push(mapped)
				}
			}
		}
		return /* TODO(ConditionalExpression): changed ? mappedTypes && getUnionType(mappedTypes, noReductions ? UnionReduction.None : UnionReduction.Literal) : type */ TODO
	}
	mapTypeWithAlias := func(type_ Type, mapper func(t Type) Type, aliasSymbol *Symbol, aliasTypeArguments /* TODO(TypeOperator): readonly Type[] */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && aliasSymbol ?             getUnionType(map((type as UnionType).types, mapper), UnionReduction.Literal, aliasSymbol, aliasTypeArguments) :             mapType(type, mapper) */ TODO
	}
	extractTypesOfKind := func(type_ Type, kind TypeFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(ParenthesizedExpression): (t.flags & kind) */
			/* TODO(ExclamationEqualsEqualsToken): !== */
			/* TODO(NumericLiteral): 0 */
		})
	}
	replacePrimitivesWithLiterals := func(typeWithPrimitives Type, typeWithLiterals Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if maybeTypeOfKind(typeWithPrimitives, TypeFlagsString|TypeFlagsTemplateLiteral|TypeFlagsNumber|TypeFlagsBigInt) && maybeTypeOfKind(typeWithLiterals, TypeFlagsStringLiteral|TypeFlagsTemplateLiteral|TypeFlagsStringMapping|TypeFlagsNumberLiteral|TypeFlagsBigIntLiteral) {
			return mapType(typeWithPrimitives, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(BinaryExpression): t.flags & TypeFlags.String */
				/* TODO(QuestionToken): ? */
				/* TODO(CallExpression): extractTypesOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.StringLiteral | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) */
				/* TODO(ColonToken): : */
				/* TODO(ConditionalExpression): isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, TypeFlags.String | TypeFlags.TemplateLiteral | TypeFlags.StringMapping) ? extractTypesOfKind(typeWithLiterals, TypeFlags.StringLiteral) :                     t.flags & TypeFlags.Number ? extractTypesOfKind(typeWithLiterals, TypeFlags.Number | TypeFlags.NumberLiteral) :                     t.flags & TypeFlags.BigInt ? extractTypesOfKind(typeWithLiterals, TypeFlags.BigInt | TypeFlags.BigIntLiteral) : t */
			})
		}
		return typeWithPrimitives
	}
	isIncomplete := func(flowType FlowType) /* TODO(undefined): boolean */ TODO {
		return flowType.flags == 0
	}
	getTypeFromFlowType := func(flowType FlowType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): flowType.flags === 0 ? flowType.type : flowType as Type */ TODO
	}
	createFlowType := func(type_ Type, incomplete bool) FlowType {
		return /* TODO(ConditionalExpression): incomplete ? { flags: 0, type: type.flags & TypeFlags.Never ? silentNeverType : type } : type */ TODO
	}
	createEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		result := createObjectType(ObjectFlagsEvolvingArray) /* as */ /* TODO(TypeReference): EvolvingArrayType */
		result.elementType = elementType
		return result
	}
	getEvolvingArrayType := func(elementType Type) EvolvingArrayType {
		return /* TODO(ElementAccessExpression): evolvingArrayTypes[elementType.id] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType) */ TODO)
	}
	addEvolvingArrayElementType := func(evolvingArrayType EvolvingArrayType, node Expression) EvolvingArrayType {
		elementType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)))
		return /* TODO(ConditionalExpression): isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType])) */ TODO
	}
	createFinalArrayType := func(elementType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): elementType.flags & TypeFlags.Never ?             autoArrayType :             createArrayType(                 elementType.flags & TypeFlags.Union ?                     getUnionType((elementType as UnionType).types, UnionReduction.Subtype) :                     elementType,             ) */ TODO
	}
	getFinalArrayType := func(evolvingArrayType EvolvingArrayType) Type {
		return evolvingArrayType.finalArrayType || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType) */ TODO)
	}
	finalizeEvolvingArrayType := func(type_ Type) Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? getFinalArrayType(type as EvolvingArrayType) : type */ TODO
	}
	getElementTypeOfEvolvingArrayType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.EvolvingArray ? (type as EvolvingArrayType).elementType : neverType */ TODO
	}
	isEvolvingArrayTypeList := func(types []Type) /* TODO(undefined): boolean */ TODO {
		hasEvolvingArrayType := false
		for _, t := range types {
			if !(t.flags & TypeFlagsNever) {
				if !(getObjectFlags(t) & ObjectFlagsEvolvingArray) {
					return false
				}
				hasEvolvingArrayType = true
			}
		}
		return hasEvolvingArrayType
	}
	isEvolvingArrayOperationTarget := func(node Node) /* TODO(undefined): boolean */ TODO {
		root := getReferenceRoot(node)
		parent := root.parent
		isLengthPushOrUnshift := isPropertyAccessExpression(parent) && (parent.name.escapedText == "length" || parent.parent.kind == SyntaxKindCallExpression && isIdentifier(parent.name) && isPushOrUnshiftIdentifier(parent.name))
		isElementAssignment := parent.kind == SyntaxKindElementAccessExpression && (parent /* as */ /* TODO(TypeReference): ElementAccessExpression */).expression == root && parent.parent.kind == SyntaxKindBinaryExpression && (parent.parent /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken && (parent.parent /* as */ /* TODO(TypeReference): BinaryExpression */).left == parent && !isAssignmentTarget(parent.parent) && isTypeAssignableToKind(getTypeOfExpression((parent /* as */ /* TODO(TypeReference): ElementAccessExpression */).argumentExpression), TypeFlagsNumberLike)
		return isLengthPushOrUnshift || isElementAssignment
	}
	isDeclarationWithExplicitTypeAnnotation := func(node Declaration) /* TODO(undefined): boolean */ TODO {
		return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) && !!(getEffectiveTypeAnnotationNode(node) || isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer))
	}
	getExplicitTypeOfSymbol := func(symbol Symbol, diagnostic Diagnostic) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		symbol = resolveSymbol(symbol)
		if symbol.flags & (SymbolFlagsFunction | SymbolFlagsMethod | SymbolFlagsClass | SymbolFlagsValueModule) {
			return getTypeOfSymbol(symbol)
		}
		if symbol.flags & (SymbolFlagsVariable | SymbolFlagsProperty) {
			if getCheckFlags(symbol) & CheckFlagsMapped {
				origin := (symbol /* as */ /* TODO(TypeReference): MappedSymbol */).links.syntheticOrigin
				if origin && getExplicitTypeOfSymbol(origin) {
					return getTypeOfSymbol(symbol)
				}
			}
			declaration := symbol.valueDeclaration
			if declaration {
				if isDeclarationWithExplicitTypeAnnotation(declaration) {
					return getTypeOfSymbol(symbol)
				}
				if isVariableDeclaration(declaration) && declaration.parent.parent.kind == SyntaxKindForOfStatement {
					statement := declaration.parent.parent
					expressionType := getTypeOfDottedName(statement.expression, nil)
					if expressionType {
						use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
						return checkIteratedTypeOrElementType(use, expressionType, undefinedType, nil)
					}
				}
				if diagnostic {
					addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)))
				}
			}
		}
	}
	getTypeOfDottedName := func(node Expression, diagnostic *Diagnostic) *Type {
		if !(node.flags & NodeFlagsInWithStatement) {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.Identifier:                     const symbol = getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node as Identifier));                     return getExplicitTypeOfSymbol(symbol, diagnostic);                 case SyntaxKind.ThisKeyword:                     return getExplicitThisType(node);                 case SyntaxKind.SuperKeyword:                     return checkSuperExpression(node);                 case SyntaxKind.PropertyAccessExpression: {                     const type = getTypeOfDottedName((node as PropertyAccessExpression).expression, diagnostic);                     if (type) {                         const name = (node as PropertyAccessExpression).name;                         let prop: Symbol | undefined;                         if (isPrivateIdentifier(name)) {                             if (!type.symbol) {                                 return undefined;                             }                             prop = getPropertyOfType(type, getSymbolNameForPrivateIdentifier(type.symbol, name.escapedText));                         }                         else {                             prop = getPropertyOfType(type, name.escapedText);                         }                         return prop && getExplicitTypeOfSymbol(prop, diagnostic);                     }                     return undefined;                 }                 case SyntaxKind.ParenthesizedExpression:                     return getTypeOfDottedName((node as ParenthesizedExpression).expression, diagnostic);             } */
		}
	}
	getEffectsSignature := func(node /* TODO(UnionType): CallExpression | InstanceofExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		links := getNodeLinks(node)
		signature := links.effectsSignature
		if signature == nil {
			var funcType *Type
			if isBinaryExpression(node) {
				rightType := checkNonNullExpression(node.right)
				funcType = getSymbolHasInstanceMethodOfObjectType(rightType)
			} else if node.parent.kind == SyntaxKindExpressionStatement {
				funcType = getTypeOfDottedName(node.expression, nil)
			} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.expression.kind !== SyntaxKind.SuperKeyword */ TODO {
				if isOptionalChain(node) {
					funcType = checkNonNullType(getOptionalExpressionType(checkExpression(node.expression), node.expression), node.expression)
				} else {
					funcType = checkNonNullExpression(node.expression)
				}
			}
			signatures := getSignaturesOfType(funcType && getApparentType(funcType) || unknownType, SignatureKindCall)
			candidate := /* TODO(ConditionalExpression): signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] :                 some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) :                 undefined */ TODO
			signature = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature */ TODO
		}
		return /* TODO(ConditionalExpression): signature === unknownSignature ? undefined : signature */ TODO
	}
	hasTypePredicateOrNeverReturnType := func(signature Signature) /* TODO(undefined): boolean */ TODO {
		return !!(getTypePredicateOfSignature(signature) || signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags&TypeFlagsNever)
	}
	getTypePredicateArgument := func(predicate TypePredicate, callExpression CallExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		if predicate.kind == TypePredicateKindIdentifier || predicate.kind == TypePredicateKindAssertsIdentifier {
			return /* TODO(ElementAccessExpression): callExpression.arguments[predicate.parameterIndex] */ TODO
		}
		invokedExpression := skipParentheses(callExpression.expression)
		return /* TODO(ConditionalExpression): isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : undefined */ TODO
	}
	reportFlowControlError := func(node Node) {
		block := findAncestor(node, isFunctionOrModuleBlock) /* as */ /* TODO(UnionType): Block | ModuleBlock | SourceFile */
		sourceFile := getSourceFileOfNode(node)
		span := getSpanOfTokenAtPosition(sourceFile, block.statements.pos)
		diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis))
	}
	isReachableFlowNode := func(flow FlowNode) /* TODO(undefined): boolean */ TODO {
		result := isReachableFlowNodeWorker(flow, false)
		lastFlowNode = flow
		lastFlowNodeReachable = result
		return result
	}
	isFalseExpression := func(expr Expression) bool {
		node := skipParentheses(expr, true)
		return node.kind == SyntaxKindFalseKeyword || node.kind == SyntaxKindBinaryExpression && ((node /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindAmpersandAmpersandToken && (isFalseExpression((node /* as */ /* TODO(TypeReference): BinaryExpression */).left) || isFalseExpression((node /* as */ /* TODO(TypeReference): BinaryExpression */).right)) || (node /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken && isFalseExpression((node /* as */ /* TODO(TypeReference): BinaryExpression */).left) && isFalseExpression((node /* as */ /* TODO(TypeReference): BinaryExpression */).right))
	}
	isReachableFlowNodeWorker := func(flow FlowNode, noCacheCheck bool) bool {
		/* TODO(WhileStatement): while (true) {             if (flow === lastFlowNode) {                 return lastFlowNodeReachable;             }             const flags = flow.flags;             if (flags & FlowFlags.Shared) {                 if (!noCacheCheck) {                     const id = getFlowNodeId(flow);                     const reachable = flowNodeReachable[id];                     return reachable !== undefined ? reachable : (flowNodeReachable[id] = isReachableFlowNodeWorker(flow, /*noCacheCheck* / true));                 }                 noCacheCheck = false;             }             if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation)) {                 flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation).antecedent;             }             else if (flags & FlowFlags.Call) {                 const signature = getEffectsSignature((flow as FlowCall).node);                 if (signature) {                     const predicate = getTypePredicateOfSignature(signature);                     if (predicate && predicate.kind === TypePredicateKind.AssertsIdentifier && !predicate.type) {                         const predicateArgument = (flow as FlowCall).node.arguments[predicate.parameterIndex];                         if (predicateArgument && isFalseExpression(predicateArgument)) {                             return false;                         }                     }                     if (getReturnTypeOfSignature(signature).flags & TypeFlags.Never) {                         return false;                     }                 }                 flow = (flow as FlowCall).antecedent;             }             else if (flags & FlowFlags.BranchLabel) {                 // A branching point is reachable if any branch is reachable.                 return some((flow as FlowLabel).antecedent, f => isReachableFlowNodeWorker(f, /*noCacheCheck* / false));             }             else if (flags & FlowFlags.LoopLabel) {                 const antecedents = (flow as FlowLabel).antecedent;                 if (antecedents === undefined || antecedents.length === 0) {                     return false;                 }                 // A loop is reachable if the control flow path that leads to the top is reachable.                 flow = antecedents[0];             }             else if (flags & FlowFlags.SwitchClause) {                 // The control flow path representing an unmatched value in a switch statement with                 // no default clause is unreachable if the switch statement is exhaustive.                 const data = (flow as FlowSwitchClause).node;                 if (data.clauseStart === data.clauseEnd && isExhaustiveSwitchStatement(data.switchStatement)) {                     return false;                 }                 flow = (flow as FlowSwitchClause).antecedent;             }             else if (flags & FlowFlags.ReduceLabel) {                 // Cache is unreliable once we start adjusting labels                 lastFlowNode = undefined;                 const target = (flow as FlowReduceLabel).node.target;                 const saveAntecedents = target.antecedent;                 target.antecedent = (flow as FlowReduceLabel).node.antecedents;                 const result = isReachableFlowNodeWorker((flow as FlowReduceLabel).antecedent, /*noCacheCheck* / false);                 target.antecedent = saveAntecedents;                 return result;             }             else {                 return !(flags & FlowFlags.Unreachable);             }         } */
	}
	isPostSuperFlowNode := func(flow FlowNode, noCacheCheck bool) bool {
		/* TODO(WhileStatement): while (true) {             const flags = flow.flags;             if (flags & FlowFlags.Shared) {                 if (!noCacheCheck) {                     const id = getFlowNodeId(flow);                     const postSuper = flowNodePostSuper[id];                     return postSuper !== undefined ? postSuper : (flowNodePostSuper[id] = isPostSuperFlowNode(flow, /*noCacheCheck* / true));                 }                 noCacheCheck = false;             }             if (flags & (FlowFlags.Assignment | FlowFlags.Condition | FlowFlags.ArrayMutation | FlowFlags.SwitchClause)) {                 flow = (flow as FlowAssignment | FlowCondition | FlowArrayMutation | FlowSwitchClause).antecedent;             }             else if (flags & FlowFlags.Call) {                 if ((flow as FlowCall).node.expression.kind === SyntaxKind.SuperKeyword) {                     return true;                 }                 flow = (flow as FlowCall).antecedent;             }             else if (flags & FlowFlags.BranchLabel) {                 // A branching point is post-super if every branch is post-super.                 return every((flow as FlowLabel).antecedent, f => isPostSuperFlowNode(f, /*noCacheCheck* / false));             }             else if (flags & FlowFlags.LoopLabel) {                 // A loop is post-super if the control flow path that leads to the top is post-super.                 flow = (flow as FlowLabel).antecedent![0];             }             else if (flags & FlowFlags.ReduceLabel) {                 const target = (flow as FlowReduceLabel).node.target;                 const saveAntecedents = target.antecedent;                 target.antecedent = (flow as FlowReduceLabel).node.antecedents;                 const result = isPostSuperFlowNode((flow as FlowReduceLabel).antecedent, /*noCacheCheck* / false);                 target.antecedent = saveAntecedents;                 return result;             }             else {                 // Unreachable nodes are considered post-super to silence errors                 return !!(flags & FlowFlags.Unreachable);             }         } */
	}
	isConstantReference := func(node Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ThisKeyword:                 return true;             case SyntaxKind.Identifier:                 if (!isThisInTypeQuery(node)) {                     const symbol = getResolvedSymbol(node as Identifier);                     return isConstantVariable(symbol)                         || isParameterOrMutableLocalVariable(symbol) && !isSymbolAssigned(symbol)                         || !!symbol.valueDeclaration && isFunctionExpression(symbol.valueDeclaration);                 }                 break;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 // The resolvedSymbol property is initialized by checkPropertyAccess or checkElementAccess before we get here.                 return isConstantReference((node as AccessExpression).expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol);             case SyntaxKind.ObjectBindingPattern:             case SyntaxKind.ArrayBindingPattern:                 const rootDeclaration = getRootDeclaration(node.parent);                 return isParameter(rootDeclaration) || isCatchClauseVariableDeclaration(rootDeclaration)                     ? !isSomeSymbolAssigned(rootDeclaration)                     : isVariableDeclaration(rootDeclaration) && isVarConstLike(rootDeclaration);         } */
		return false
	}
	getFlowTypeOfReference := func(reference Node, declaredType Type, initialType /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO /* = */ /* TODO(Identifier): declaredType */, flowContainer Node, flowNode /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FlowNode | undefined */ TODO /* = */ /* TODO(PropertyAccessExpression): tryCast(reference, canHaveFlowNode)?.flowNode */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		var key /* TODO(StringKeyword): string */ any
		isKeySet := false
		flowDepth := 0
		if flowAnalysisDisabled {
			return errorType
		}
		if !flowNode {
			return declaredType
		}
		flowInvocationCount++
		sharedFlowStart := sharedFlowCount
		evolvedType := getTypeFromFlowType(getTypeAtFlowNode(flowNode))
		sharedFlowCount = sharedFlowStart
		resultType := /* TODO(ConditionalExpression): getObjectFlags(evolvedType) & ObjectFlags.EvolvingArray && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType) */ TODO
		if resultType == unreachableNeverType || reference.parent && reference.parent.kind == SyntaxKindNonNullExpression && !(resultType.flags&TypeFlagsNever) && getTypeWithFacts(resultType, TypeFactsNEUndefinedOrNull).flags&TypeFlagsNever {
			return declaredType
		}
		return resultType
		getOrSetCacheKey := func() /* TODO(undefined): string | undefined */ TODO {
			if isKeySet {
				return key
			}
			isKeySet = true
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): key = getFlowCacheKey(reference, declaredType, initialType, flowContainer) */ TODO
		}
		getTypeAtFlowNode := func(flow FlowNode) FlowType {
			if flowDepth == 2000 {
				tracing.instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit" /* TODO(ObjectLiteralExpression): { flowId: flow.id } */, TODO)
				flowAnalysisDisabled = true
				reportFlowControlError(reference)
				return errorType
			}
			flowDepth++
			var sharedFlow *FlowNode
			/* TODO(WhileStatement): while (true) {                 const flags = flow.flags;                 if (flags & FlowFlags.Shared) {                     // We cache results of flow type resolution for shared nodes that were previously visited in                     // the same getFlowTypeOfReference invocation. A node is considered shared when it is the                     // antecedent of more than one node.                     for (let i = sharedFlowStart; i < sharedFlowCount; i++) {                         if (sharedFlowNodes[i] === flow) {                             flowDepth--;                             return sharedFlowTypes[i];                         }                     }                     sharedFlow = flow;                 }                 let type: FlowType | undefined;                 if (flags & FlowFlags.Assignment) {                     type = getTypeAtFlowAssignment(flow as FlowAssignment);                     if (!type) {                         flow = (flow as FlowAssignment).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.Call) {                     type = getTypeAtFlowCall(flow as FlowCall);                     if (!type) {                         flow = (flow as FlowCall).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.Condition) {                     type = getTypeAtFlowCondition(flow as FlowCondition);                 }                 else if (flags & FlowFlags.SwitchClause) {                     type = getTypeAtSwitchClause(flow as FlowSwitchClause);                 }                 else if (flags & FlowFlags.Label) {                     if ((flow as FlowLabel).antecedent!.length === 1) {                         flow = (flow as FlowLabel).antecedent![0];                         continue;                     }                     type = flags & FlowFlags.BranchLabel ?                         getTypeAtFlowBranchLabel(flow as FlowLabel) :                         getTypeAtFlowLoopLabel(flow as FlowLabel);                 }                 else if (flags & FlowFlags.ArrayMutation) {                     type = getTypeAtFlowArrayMutation(flow as FlowArrayMutation);                     if (!type) {                         flow = (flow as FlowArrayMutation).antecedent;                         continue;                     }                 }                 else if (flags & FlowFlags.ReduceLabel) {                     const target = (flow as FlowReduceLabel).node.target;                     const saveAntecedents = target.antecedent;                     target.antecedent = (flow as FlowReduceLabel).node.antecedents;                     type = getTypeAtFlowNode((flow as FlowReduceLabel).antecedent);                     target.antecedent = saveAntecedents;                 }                 else if (flags & FlowFlags.Start) {                     // Check if we should continue with the control flow of the containing function.                     const container = (flow as FlowStart).node;                     if (                         container && container !== flowContainer &&                         reference.kind !== SyntaxKind.PropertyAccessExpression &&                         reference.kind !== SyntaxKind.ElementAccessExpression &&                         !(reference.kind === SyntaxKind.ThisKeyword && container.kind !== SyntaxKind.ArrowFunction)                     ) {                         flow = container.flowNode!;                         continue;                     }                     // At the top of the flow we have the initial type.                     type = initialType;                 }                 else {                     // Unreachable code errors are reported in the binding phase. Here we                     // simply return the non-auto declared type to reduce follow-on errors.                     type = convertAutoToAny(declaredType);                 }                 if (sharedFlow) {                     // Record visited node and the associated type in the cache.                     sharedFlowNodes[sharedFlowCount] = sharedFlow;                     sharedFlowTypes[sharedFlowCount] = type;                     sharedFlowCount++;                 }                 flowDepth--;                 return type;             } */
		}
		getInitialOrAssignedType := func(flow FlowAssignment) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			node := flow.node
			return getNarrowableTypeForReference( /* TODO(ConditionalExpression): node.kind === SyntaxKind.VariableDeclaration || node.kind === SyntaxKind.BindingElement ?                     getInitialType(node as VariableDeclaration | BindingElement) :                     getAssignedType(node) */ TODO, reference)
		}
		getTypeAtFlowAssignment := func(flow FlowAssignment) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").FlowType | undefined */ TODO {
			node := flow.node
			if isMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if getAssignmentTargetKind(node) == AssignmentKindCompound {
					flowType := getTypeAtFlowNode(flow.antecedent)
					return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType))
				}
				if declaredType == autoType || declaredType == autoArrayType {
					if isEmptyArrayAssignment(node) {
						return getEvolvingArrayType(neverType)
					}
					assignedType := getWidenedLiteralType(getInitialOrAssignedType(flow))
					return /* TODO(ConditionalExpression): isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType */ TODO
				}
				t := /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(declaredType) : declaredType */ TODO
				if t.flags & TypeFlagsUnion {
					return getAssignmentReducedType(t /* as */ /* TODO(TypeReference): UnionType */, getInitialOrAssignedType(flow))
				}
				return t
			}
			if containsMatchingReference(reference, node) {
				if !isReachableFlowNode(flow) {
					return unreachableNeverType
				}
				if isVariableDeclaration(node) && (isInJSFile(node) || isVarConstLike(node)) {
					init := getDeclaredExpandoInitializer(node)
					if init && (init.kind == SyntaxKindFunctionExpression || init.kind == SyntaxKindArrowFunction) {
						return getTypeAtFlowNode(flow.antecedent)
					}
				}
				return declaredType
			}
			if isVariableDeclaration(node) && node.parent.parent.kind == SyntaxKindForInStatement && (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference)) {
				return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))))
			}
			return nil
		}
		narrowTypeByAssertion := func(type_ Type, expr Expression) Type {
			node := skipParentheses(expr, true)
			if node.kind == SyntaxKindFalseKeyword {
				return unreachableNeverType
			}
			if node.kind == SyntaxKindBinaryExpression {
				if (node /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindAmpersandAmpersandToken {
					return narrowTypeByAssertion(narrowTypeByAssertion(type_, (node /* as */ /* TODO(TypeReference): BinaryExpression */).left), (node /* as */ /* TODO(TypeReference): BinaryExpression */).right)
				}
				if (node /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindBarBarToken {
					return getUnionType( /* TODO(ArrayLiteralExpression): [narrowTypeByAssertion(type, (node as BinaryExpression).left), narrowTypeByAssertion(type, (node as BinaryExpression).right)] */ TODO)
				}
			}
			return narrowType(type_, node, true)
		}
		getTypeAtFlowCall := func(flow FlowCall) *FlowType {
			signature := getEffectsSignature(flow.node)
			if signature {
				predicate := getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindAssertsThis || predicate.kind == TypePredicateKindAssertsIdentifier) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := finalizeEvolvingArrayType(getTypeFromFlowType(flowType))
					narrowedType := /* TODO(ConditionalExpression): predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, /*assumeTrue* / true) :                         predicate.kind === TypePredicateKind.AssertsIdentifier && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) :                         type */ TODO
					return /* TODO(ConditionalExpression): narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType)) */ TODO
				}
				if getReturnTypeOfSignature(signature).flags & TypeFlagsNever {
					return unreachableNeverType
				}
			}
			return nil
		}
		getTypeAtFlowArrayMutation := func(flow FlowArrayMutation) *FlowType {
			if declaredType == autoType || declaredType == autoArrayType {
				node := flow.node
				expr := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ?                     (node.expression as PropertyAccessExpression).expression :                     (node.left as ElementAccessExpression).expression */ TODO
				if isMatchingReference(reference, getReferenceCandidate(expr)) {
					flowType := getTypeAtFlowNode(flow.antecedent)
					type_ := getTypeFromFlowType(flowType)
					if getObjectFlags(type_) & ObjectFlagsEvolvingArray {
						evolvedType := type_ /* as */ /* TODO(TypeReference): EvolvingArrayType */
						if node.kind == SyntaxKindCallExpression {
							for _, arg := range node.arguments {
								evolvedType = addEvolvingArrayElementType(evolvedType, arg)
							}
						} else {
							indexType := getContextFreeTypeOfExpression((node.left /* as */ /* TODO(TypeReference): ElementAccessExpression */).argumentExpression)
							if isTypeAssignableToKind(indexType, TypeFlagsNumberLike) {
								evolvedType = addEvolvingArrayElementType(evolvedType, node.right)
							}
						}
						return /* TODO(ConditionalExpression): evolvedType === type ? flowType : createFlowType(evolvedType, isIncomplete(flowType)) */ TODO
					}
					return flowType
				}
			}
			return nil
		}
		getTypeAtFlowCondition := func(flow FlowCondition) FlowType {
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if type_.flags & TypeFlagsNever {
				return flowType
			}
			assumeTrue := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (flow.flags & FlowFlags.TrueCondition) !== 0 */ TODO
			nonEvolvingType := finalizeEvolvingArrayType(type_)
			narrowedType := narrowType(nonEvolvingType, flow.node, assumeTrue)
			if narrowedType == nonEvolvingType {
				return flowType
			}
			return createFlowType(narrowedType, isIncomplete(flowType))
		}
		getTypeAtSwitchClause := func(flow FlowSwitchClause) FlowType {
			expr := skipParentheses(flow.node.switchStatement.expression)
			flowType := getTypeAtFlowNode(flow.antecedent)
			type_ := getTypeFromFlowType(flowType)
			if isMatchingReference(reference, expr) {
				type_ = narrowTypeBySwitchOnDiscriminant(type_, flow.node)
			} else if expr.kind == SyntaxKindTypeOfExpression && isMatchingReference(reference, (expr /* as */ /* TODO(TypeReference): TypeOfExpression */).expression) {
				type_ = narrowTypeBySwitchOnTypeOf(type_, flow.node)
			} else if expr.kind == SyntaxKindTrueKeyword {
				type_ = narrowTypeBySwitchOnTrue(type_, flow.node)
			} else {
				if strictNullChecks {
					if optionalChainContainsReference(expr, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
							/* TODO(ParenthesizedExpression): (t.flags & (TypeFlags.Undefined | TypeFlags.Never)) */
						})
					} else if expr.kind == SyntaxKindTypeOfExpression && optionalChainContainsReference((expr /* as */ /* TODO(TypeReference): TypeOfExpression */).expression, reference) {
						type_ = narrowTypeBySwitchOptionalChainContainment(type_, flow.node, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
							/* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Never || t.flags & TypeFlags.StringLiteral && (t as StringLiteralType).value === "undefined") */
						})
					}
				}
				access := getDiscriminantPropertyAccess(expr, type_)
				if access {
					type_ = narrowTypeBySwitchOnDiscriminantProperty(type_, access, flow.node)
				}
			}
			return createFlowType(type_, isIncomplete(flowType))
		}
		getTypeAtFlowBranchLabel := func(flow FlowLabel) FlowType {
			var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			subtypeReduction := false
			seenIncomplete := false
			var bypassFlow *FlowSwitchClause
			for _, antecedent := range /* TODO(NonNullExpression): flow.antecedent! */ TODO {
				if !bypassFlow && antecedent.flags&FlowFlagsSwitchClause && (antecedent /* as */ /* TODO(TypeReference): FlowSwitchClause */).node.clauseStart == (antecedent /* as */ /* TODO(TypeReference): FlowSwitchClause */).node.clauseEnd {
					bypassFlow = antecedent /* as */ /* TODO(TypeReference): FlowSwitchClause */
					/* TODO(ContinueStatement): continue; */
				}
				flowType := getTypeAtFlowNode(antecedent)
				type_ := getTypeFromFlowType(flowType)
				if type_ == declaredType && declaredType == initialType {
					return type_
				}
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if isIncomplete(flowType) {
					seenIncomplete = true
				}
			}
			if bypassFlow {
				flowType := getTypeAtFlowNode(bypassFlow)
				type_ := getTypeFromFlowType(flowType)
				if !(type_.flags & TypeFlagsNever) && !contains(antecedentTypes, type_) && !isExhaustiveSwitchStatement(bypassFlow.node.switchStatement) {
					if type_ == declaredType && declaredType == initialType {
						return type_
					}
					antecedentTypes.push(type_)
					if !isTypeSubsetOf(type_, initialType) {
						subtypeReduction = true
					}
					if isIncomplete(flowType) {
						seenIncomplete = true
					}
				}
			}
			return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO), seenIncomplete)
		}
		getTypeAtFlowLoopLabel := func(flow FlowLabel) FlowType {
			id := getFlowNodeId(flow)
			cache := /* TODO(ElementAccessExpression): flowLoopCaches[id] */ TODO || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): flowLoopCaches[id] = new Map<string, Type>() */ TODO)
			key := getOrSetCacheKey()
			if !key {
				return declaredType
			}
			cached := cache.get(key)
			if cached {
				return cached
			}
			/* TODO(ForStatement): for (let i = flowLoopStart; i < flowLoopCount; i++) {                 if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {                     return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], UnionReduction.Literal), /*incomplete* / true);                 }             } */
			var antecedentTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			subtypeReduction := false
			var firstAntecedentType *FlowType
			for _, antecedent := range /* TODO(NonNullExpression): flow.antecedent! */ TODO {
				var flowType TODO
				if !firstAntecedentType {
					flowType = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): firstAntecedentType = getTypeAtFlowNode(antecedent) */ TODO
				} else {
					/* TODO(ElementAccessExpression): flowLoopNodes[flowLoopCount] */ TODO = flow
					/* TODO(ElementAccessExpression): flowLoopKeys[flowLoopCount] */ TODO = key
					/* TODO(ElementAccessExpression): flowLoopTypes[flowLoopCount] */ TODO = antecedentTypes
					flowLoopCount++
					saveFlowTypeCache := flowTypeCache
					flowTypeCache = nil
					flowType = getTypeAtFlowNode(antecedent)
					flowTypeCache = saveFlowTypeCache
					flowLoopCount--
					cached := cache.get(key)
					if cached {
						return cached
					}
				}
				type_ := getTypeFromFlowType(flowType)
				pushIfUnique(antecedentTypes, type_)
				if !isTypeSubsetOf(type_, initialType) {
					subtypeReduction = true
				}
				if type_ == declaredType {
					/* TODO(BreakStatement): break; */
				}
			}
			result := getUnionOrEvolvingArrayType(antecedentTypes /* TODO(ConditionalExpression): subtypeReduction ? UnionReduction.Subtype : UnionReduction.Literal */, TODO)
			if isIncomplete( /* TODO(NonNullExpression): firstAntecedentType! */ TODO) {
				return createFlowType(result, true)
			}
			cache.set(key, result)
			return result
		}
		getUnionOrEvolvingArrayType := func(types []Type, subtypeReduction UnionReduction) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if isEvolvingArrayTypeList(types) {
				return getEvolvingArrayType(getUnionType(map_(types, getElementTypeOfEvolvingArrayType)))
			}
			result := recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction))
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== declaredType */ TODO && result.flags&declaredType.flags&TypeFlagsUnion && arrayIsEqualTo((result /* as */ /* TODO(TypeReference): UnionType */).types, (declaredType /* as */ /* TODO(TypeReference): UnionType */).types) {
				return declaredType
			}
			return result
		}
		getCandidateDiscriminantPropertyAccess := func(expr Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
			if isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference) {
				if isIdentifier(expr) {
					symbol := getResolvedSymbol(expr)
					declaration := symbol.valueDeclaration
					if declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference == declaration.parent && !declaration.initializer && !declaration.dotDotDotToken {
						return declaration
					}
				}
			} else if isAccessExpression(expr) {
				if isMatchingReference(reference, expr.expression) {
					return expr
				}
			} else if isIdentifier(expr) {
				symbol := getResolvedSymbol(expr)
				if isConstantVariable(symbol) {
					declaration := /* TODO(NonNullExpression): symbol.valueDeclaration! */ TODO
					if isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && isAccessExpression(declaration.initializer) && isMatchingReference(reference, declaration.initializer.expression) {
						return declaration.initializer
					}
					if isBindingElement(declaration) && !declaration.initializer {
						parent := declaration.parent.parent
						if isVariableDeclaration(parent) && !parent.type_ && parent.initializer && (isIdentifier(parent.initializer) || isAccessExpression(parent.initializer)) && isMatchingReference(reference, parent.initializer) {
							return declaration
						}
					}
				}
			}
			return nil
		}
		getDiscriminantPropertyAccess := func(expr Expression, computedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").AccessExpression | undefined */ TODO {
			if declaredType.flags&TypeFlagsUnion || computedType.flags&TypeFlagsUnion {
				access := getCandidateDiscriminantPropertyAccess(expr)
				if access {
					name := getAccessedPropertyName(access)
					if name {
						type_ := /* TODO(ConditionalExpression): declaredType.flags & TypeFlags.Union && isTypeSubsetOf(computedType, declaredType) ? declaredType : computedType */ TODO
						if isDiscriminantProperty(type_, name) {
							return access
						}
					}
				}
			}
			return nil
		}
		narrowTypeByDiscriminant := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, narrowType func(t Type) Type) Type {
			propName := getAccessedPropertyName(access)
			if propName == nil {
				return type_
			}
			optionalChain := isOptionalChain(access)
			removeNullable := strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type_, TypeFlagsNullable)
			propType := getTypeOfPropertyOfType( /* TODO(ConditionalExpression): removeNullable ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO, propName)
			if !propType {
				return type_
			}
			propType = /* TODO(ConditionalExpression): removeNullable && optionalChain ? getOptionalType(propType) : propType */ TODO
			narrowedPropType := narrowType(propType)
			return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				discriminantType := getTypeOfPropertyOrIndexSignatureOfType(t, propName) || unknownType
				return !(discriminantType.flags & TypeFlagsNever) && !(narrowedPropType.flags & TypeFlagsNever) && areTypesComparable(narrowedPropType, discriminantType)
			})
		}
		narrowTypeByDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, operator SyntaxKind, value Expression, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if (operator == SyntaxKindEqualsEqualsEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken) && type_.flags&TypeFlagsUnion {
				keyPropertyName := getKeyPropertyName(type_ /* as */ /* TODO(TypeReference): UnionType */)
				if keyPropertyName && keyPropertyName == getAccessedPropertyName(access) {
					candidate := getConstituentTypeForKeyType(type_ /* as */ /* TODO(TypeReference): UnionType */, getTypeOfExpression(value))
					if candidate {
						return /* TODO(ConditionalExpression): operator === (assumeTrue ? SyntaxKind.EqualsEqualsEqualsToken : SyntaxKind.ExclamationEqualsEqualsToken) ? candidate :                             isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) :                             type */ TODO
					}
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): narrowTypeByEquality */
				/* TODO(Identifier): t */
				/* TODO(Identifier): operator */
				/* TODO(Identifier): value */
				/* TODO(Identifier): assumeTrue */
			})
		}
		narrowTypeBySwitchOnDiscriminantProperty := func(type_ Type, access /* TODO(UnionType): AccessExpression | BindingElement | ParameterDeclaration */ any, data FlowSwitchClauseData) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if data.clauseStart < data.clauseEnd && type_.flags&TypeFlagsUnion && getKeyPropertyName(type_ /* as */ /* TODO(TypeReference): UnionType */) == getAccessedPropertyName(access) {
				clauseTypes := getSwitchClauseTypes(data.switchStatement).slice(data.clauseStart, data.clauseEnd)
				candidate := getUnionType(map_(clauseTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(CallExpression): getConstituentTypeForKeyType(type as UnionType, t) */
					/* TODO(BarBarToken): || */
					/* TODO(Identifier): unknownType */
				}))
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): candidate !== unknownType */ TODO {
					return candidate
				}
			}
			return narrowTypeByDiscriminant(type_, access, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): narrowTypeBySwitchOnDiscriminant */
				/* TODO(Identifier): t */
				/* TODO(Identifier): data */
			})
		}
		narrowTypeByTruthiness := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */, TODO)
			}
			if strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference) {
				type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(Identifier): getTypeWithFacts */
					/* TODO(Identifier): t */
					/* TODO(ConditionalExpression): assumeTrue ? TypeFacts.Truthy : TypeFacts.Falsy */
				})
			}
			return type_
		}
		isTypePresencePossible := func(type_ Type, propName __String, assumeTrue bool) /* TODO(undefined): boolean */ TODO {
			prop := getPropertyOfType(type_, propName)
			return /* TODO(ConditionalExpression): prop ?                 !!(prop.flags & SymbolFlags.Optional || getCheckFlags(prop) & CheckFlags.Partial) || assumeTrue :                 !!getApplicableIndexInfoForName(type, propName) || !assumeTrue */ TODO
		}
		narrowTypeByInKeyword := func(type_ Type, nameType /* TODO(UnionType): StringLiteralType | NumberLiteralType | UniqueESSymbolType */ any, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			name := getPropertyNameFromType(nameType)
			isKnownProperty := someType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): isTypePresencePossible */
				/* TODO(Identifier): t */
				/* TODO(Identifier): name */
				/* TODO(TrueKeyword): true */
			})
			if isKnownProperty {
				return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): isTypePresencePossible */
					/* TODO(Identifier): t */
					/* TODO(Identifier): name */
					/* TODO(Identifier): assumeTrue */
				})
			}
			if assumeTrue {
				recordSymbol := getGlobalRecordSymbol()
				if recordSymbol {
					return getIntersectionType( /* TODO(ArrayLiteralExpression): [type, getTypeAliasInstantiation(recordSymbol, [nameType, unknownType])] */ TODO)
				}
			}
			return type_
		}
		narrowTypeByBooleanComparison := func(type_ Type, expr Expression, bool BooleanLiteral, operator BinaryOperator, assumeTrue bool) Type {
			assumeTrue = /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (assumeTrue !== (bool.kind === SyntaxKind.TrueKeyword)) !== (operator !== SyntaxKind.ExclamationEqualsEqualsToken && operator !== SyntaxKind.ExclamationEqualsToken) */ TODO
			return narrowType(type_, expr, assumeTrue)
		}
		narrowTypeByBinaryExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			/* TODO(SwitchStatement): switch (expr.operatorToken.kind) {                 case SyntaxKind.EqualsToken:                 case SyntaxKind.BarBarEqualsToken:                 case SyntaxKind.AmpersandAmpersandEqualsToken:                 case SyntaxKind.QuestionQuestionEqualsToken:                     return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);                 case SyntaxKind.EqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsToken:                 case SyntaxKind.EqualsEqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsEqualsToken:                     const operator = expr.operatorToken.kind;                     const left = getReferenceCandidate(expr.left);                     const right = getReferenceCandidate(expr.right);                     if (left.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(right)) {                         return narrowTypeByTypeof(type, left as TypeOfExpression, operator, right, assumeTrue);                     }                     if (right.kind === SyntaxKind.TypeOfExpression && isStringLiteralLike(left)) {                         return narrowTypeByTypeof(type, right as TypeOfExpression, operator, left, assumeTrue);                     }                     if (isMatchingReference(reference, left)) {                         return narrowTypeByEquality(type, operator, right, assumeTrue);                     }                     if (isMatchingReference(reference, right)) {                         return narrowTypeByEquality(type, operator, left, assumeTrue);                     }                     if (strictNullChecks) {                         if (optionalChainContainsReference(left, reference)) {                             type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);                         }                         else if (optionalChainContainsReference(right, reference)) {                             type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);                         }                     }                     const leftAccess = getDiscriminantPropertyAccess(left, type);                     if (leftAccess) {                         return narrowTypeByDiscriminantProperty(type, leftAccess, operator, right, assumeTrue);                     }                     const rightAccess = getDiscriminantPropertyAccess(right, type);                     if (rightAccess) {                         return narrowTypeByDiscriminantProperty(type, rightAccess, operator, left, assumeTrue);                     }                     if (isMatchingConstructorReference(left)) {                         return narrowTypeByConstructor(type, operator, right, assumeTrue);                     }                     if (isMatchingConstructorReference(right)) {                         return narrowTypeByConstructor(type, operator, left, assumeTrue);                     }                     if (isBooleanLiteral(right) && !isAccessExpression(left)) {                         return narrowTypeByBooleanComparison(type, left, right, operator, assumeTrue);                     }                     if (isBooleanLiteral(left) && !isAccessExpression(right)) {                         return narrowTypeByBooleanComparison(type, right, left, operator, assumeTrue);                     }                     break;                 case SyntaxKind.InstanceOfKeyword:                     return narrowTypeByInstanceof(type, expr as InstanceofExpression, assumeTrue);                 case SyntaxKind.InKeyword:                     if (isPrivateIdentifier(expr.left)) {                         return narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue);                     }                     const target = getReferenceCandidate(expr.right);                     if (containsMissingType(type) && isAccessExpression(reference) && isMatchingReference(reference.expression, target)) {                         const leftType = getTypeOfExpression(expr.left);                         if (isTypeUsableAsPropertyName(leftType) && getAccessedPropertyName(reference) === getPropertyNameFromType(leftType)) {                             return getTypeWithFacts(type, assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined);                         }                     }                     if (isMatchingReference(reference, target)) {                         const leftType = getTypeOfExpression(expr.left);                         if (isTypeUsableAsPropertyName(leftType)) {                             return narrowTypeByInKeyword(type, leftType, assumeTrue);                         }                     }                     break;                 case SyntaxKind.CommaToken:                     return narrowType(type, expr.right, assumeTrue);                 // Ordinarily we won't see && and || expressions in control flow analysis because the Binder breaks those                 // expressions down to individual conditional control flows. However, we may encounter them when analyzing                 // aliased conditional expressions.                 case SyntaxKind.AmpersandAmpersandToken:                     return assumeTrue ?                         narrowType(narrowType(type, expr.left, /*assumeTrue* / true), expr.right, /*assumeTrue* / true) :                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / false), narrowType(type, expr.right, /*assumeTrue* / false)]);                 case SyntaxKind.BarBarToken:                     return assumeTrue ?                         getUnionType([narrowType(type, expr.left, /*assumeTrue* / true), narrowType(type, expr.right, /*assumeTrue* / true)]) :                         narrowType(narrowType(type, expr.left, /*assumeTrue* / false), expr.right, /*assumeTrue* / false);             } */
			return type_
		}
		narrowTypeByPrivateIdentifierInInExpression := func(type_ Type, expr BinaryExpression, assumeTrue bool) Type {
			target := getReferenceCandidate(expr.right)
			if !isMatchingReference(reference, target) {
				return type_
			}
			Debug.assertNode(expr.left, isPrivateIdentifier)
			symbol := getSymbolForPrivateIdentifierExpression(expr.left)
			if symbol == nil {
				return type_
			}
			classSymbol := /* TODO(NonNullExpression): symbol.parent! */ TODO
			targetType := /* TODO(ConditionalExpression): hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration"))                 ? getTypeOfSymbol(classSymbol) as InterfaceType                 : getDeclaredTypeOfSymbol(classSymbol) */ TODO
			return getNarrowedType(type_, targetType, assumeTrue, true)
		}
		narrowTypeByOptionalChainContainment := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			equalsOperator := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindEqualsEqualsEqualsToken
			nullableFlags := /* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? TypeFlags.Nullable : TypeFlags.Undefined */ TODO
			valueType := getTypeOfExpression(value)
			removeNullable := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): equalsOperator !== assumeTrue */ TODO && everyType(valueType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(t.flags & nullableFlags) */
			}) || equalsOperator == assumeTrue && everyType(valueType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(ParenthesizedExpression): (t.flags & (TypeFlags.AnyOrUnknown | nullableFlags)) */
			})
			return /* TODO(ConditionalExpression): removeNullable ? getAdjustedTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
		}
		narrowTypeByEquality := func(type_ Type, operator SyntaxKind, value Expression, assumeTrue bool) Type {
			if type_.flags & TypeFlagsAny {
				return type_
			}
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			valueType := getTypeOfExpression(value)
			doubleEquals := operator == SyntaxKindEqualsEqualsToken || operator == SyntaxKindExclamationEqualsToken
			if valueType.flags & TypeFlagsNullable {
				if !strictNullChecks {
					return type_
				}
				facts := /* TODO(ConditionalExpression): doubleEquals ?                     assumeTrue ? TypeFacts.EQUndefinedOrNull : TypeFacts.NEUndefinedOrNull :                     valueType.flags & TypeFlags.Null ?                     assumeTrue ? TypeFacts.EQNull : TypeFacts.NENull :                     assumeTrue ? TypeFacts.EQUndefined : TypeFacts.NEUndefined */ TODO
				return getAdjustedTypeWithFacts(type_, facts)
			}
			if assumeTrue {
				if !doubleEquals && (type_.flags&TypeFlagsUnknown || someType(type_, isEmptyAnonymousObjectType)) {
					if valueType.flags&(TypeFlagsPrimitive|TypeFlagsNonPrimitive) || isEmptyAnonymousObjectType(valueType) {
						return valueType
					}
					if valueType.flags & TypeFlagsObject {
						return nonPrimitiveType
					}
				}
				filteredType := filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): areTypesComparable(t, valueType) */
					/* TODO(BarBarToken): || */
					/* TODO(BinaryExpression): doubleEquals && isCoercibleUnderDoubleEquals(t, valueType) */
				})
				return replacePrimitivesWithLiterals(filteredType, valueType)
			}
			if isUnitType(valueType) {
				return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(ParenthesizedExpression): (isUnitLikeType(t) && areTypesComparable(t, valueType)) */
				})
			}
			return type_
		}
		narrowTypeByTypeof := func(type_ Type, typeOfExpr TypeOfExpression, operator SyntaxKind, literal LiteralExpression, assumeTrue bool) Type {
			if operator == SyntaxKindExclamationEqualsToken || operator == SyntaxKindExclamationEqualsEqualsToken {
				assumeTrue = !assumeTrue
			}
			target := getReferenceCandidate(typeOfExpr.expression)
			if !isMatchingReference(reference, target) {
				if strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue == ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): literal.text !== "undefined" */ TODO) {
					type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				propertyAccess := getDiscriminantPropertyAccess(target, type_)
				if propertyAccess {
					return narrowTypeByDiscriminant(type_, propertyAccess, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
						/* TODO(Identifier): narrowTypeByLiteralExpression */
						/* TODO(Identifier): t */
						/* TODO(Identifier): literal */
						/* TODO(Identifier): assumeTrue */
					})
				}
				return type_
			}
			return narrowTypeByLiteralExpression(type_, literal, assumeTrue)
		}
		narrowTypeByLiteralExpression := func(type_ Type, literal LiteralExpression, assumeTrue bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return /* TODO(ConditionalExpression): assumeTrue ?                 narrowTypeByTypeName(type, literal.text) :                 getAdjustedTypeWithFacts(type, typeofNEFacts.get(literal.text) || TypeFacts.TypeofNEHostObject) */ TODO
		}
		narrowTypeBySwitchOptionalChainContainment := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData, clauseCheck func(type_ Type) bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			everyClauseChecks := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): clauseStart !== clauseEnd */ TODO && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck)
			return /* TODO(ConditionalExpression): everyClauseChecks ? getTypeWithFacts(type, TypeFacts.NEUndefinedOrNull) : type */ TODO
		}
		narrowTypeBySwitchOnDiscriminant := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			switchTypes := getSwitchClauseTypes(switchStatement)
			if !switchTypes.length {
				return type_
			}
			clauseTypes := switchTypes.slice(clauseStart, clauseEnd)
			hasDefaultClause := clauseStart == clauseEnd || contains(clauseTypes, neverType)
			if (type_.flags & TypeFlagsUnknown) && !hasDefaultClause {
				var groundClauseTypes /* TODO(ArrayType): Type[] */ any
				/* TODO(ForStatement): for (let i = 0; i < clauseTypes.length; i += 1) {                     const t = clauseTypes[i];                     if (t.flags & (TypeFlags.Primitive | TypeFlags.NonPrimitive)) {                         if (groundClauseTypes !== undefined) {                             groundClauseTypes.push(t);                         }                     }                     else if (t.flags & TypeFlags.Object) {                         if (groundClauseTypes === undefined) {                             groundClauseTypes = clauseTypes.slice(0, i);                         }                         groundClauseTypes.push(nonPrimitiveType);                     }                     else {                         return type;                     }                 } */
				return getUnionType( /* TODO(ConditionalExpression): groundClauseTypes === undefined ? clauseTypes : groundClauseTypes */ TODO)
			}
			discriminantType := getUnionType(clauseTypes)
			caseType := /* TODO(ConditionalExpression): discriminantType.flags & TypeFlags.Never ? neverType :                 replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType) */ TODO
			if !hasDefaultClause {
				return caseType
			}
			defaultType := filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(ParenthesizedExpression): (isUnitLikeType(t) && contains(switchTypes, t.flags & TypeFlags.Undefined ? undefinedType : getRegularTypeOfLiteralType(extractUnitType(t)))) */
			})
			return /* TODO(ConditionalExpression): caseType.flags & TypeFlags.Never ? defaultType : getUnionType([caseType, defaultType]) */ TODO
		}
		narrowTypeByTypeName := func(type_ Type, typeName string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			/* TODO(SwitchStatement): switch (typeName) {                 case "string":                     return narrowTypeByTypeFacts(type, stringType, TypeFacts.TypeofEQString);                 case "number":                     return narrowTypeByTypeFacts(type, numberType, TypeFacts.TypeofEQNumber);                 case "bigint":                     return narrowTypeByTypeFacts(type, bigintType, TypeFacts.TypeofEQBigInt);                 case "boolean":                     return narrowTypeByTypeFacts(type, booleanType, TypeFacts.TypeofEQBoolean);                 case "symbol":                     return narrowTypeByTypeFacts(type, esSymbolType, TypeFacts.TypeofEQSymbol);                 case "object":                     return type.flags & TypeFlags.Any ? type : getUnionType([narrowTypeByTypeFacts(type, nonPrimitiveType, TypeFacts.TypeofEQObject), narrowTypeByTypeFacts(type, nullType, TypeFacts.EQNull)]);                 case "function":                     return type.flags & TypeFlags.Any ? type : narrowTypeByTypeFacts(type, globalFunctionType, TypeFacts.TypeofEQFunction);                 case "undefined":                     return narrowTypeByTypeFacts(type, undefinedType, TypeFacts.EQUndefined);             } */
			return narrowTypeByTypeFacts(type_, nonPrimitiveType, TypeFactsTypeofEQHostObject)
		}
		narrowTypeByTypeFacts := func(type_ Type, impliedType Type, facts TypeFacts) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			return mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(CallExpression): isTypeRelatedTo(t, impliedType, strictSubtypeRelation) */
				/* TODO(QuestionToken): ? */
				/* TODO(ConditionalExpression): hasTypeFacts(t, facts) ? t : neverType */
				/* TODO(ColonToken): : */
				/* TODO(ConditionalExpression): isTypeSubtypeOf(impliedType, t) ? impliedType :                     // Neither the constituent nor the implied type is a subtype of the other, however their domains may still                     // overlap. For example, an unconstrained type parameter and type `string`. If the type facts indicate                     // possible overlap, we form an intersection. Otherwise, we eliminate the constituent.                     hasTypeFacts(t, facts) ? getIntersectionType([t, impliedType]) :                     neverType */
			})
		}
		narrowTypeBySwitchOnTypeOf := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			witnesses := getSwitchClauseTypeOfWitnesses(switchStatement)
			if !witnesses {
				return type_
			}
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): clause.kind */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(PropertyAccessExpression): SyntaxKind.DefaultClause */
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			if hasDefaultClause {
				notEqualFacts := getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses)
				return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): getTypeFacts(t, notEqualFacts) */
					/* TODO(EqualsEqualsEqualsToken): === */
					/* TODO(Identifier): notEqualFacts */
				})
			}
			clauseWitnesses := witnesses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauseWitnesses, func(text /* TODO(undefined): string | undefined */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): text */
				/* TODO(QuestionToken): ? */
				/* TODO(CallExpression): narrowTypeByTypeName(type, text) */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): neverType */
			}))
		}
		narrowTypeBySwitchOnTrue := func(type_ Type, TODO_IDENTIFIER FlowSwitchClauseData) Type {
			defaultIndex := findIndex(switchStatement.caseBlock.clauses, func(clause /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): clause.kind */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(PropertyAccessExpression): SyntaxKind.DefaultClause */
			})
			hasDefaultClause := clauseStart == clauseEnd || (defaultIndex >= clauseStart && defaultIndex < clauseEnd)
			/* TODO(ForStatement): for (let i = 0; i < clauseStart; i++) {                 const clause = switchStatement.caseBlock.clauses[i];                 if (clause.kind === SyntaxKind.CaseClause) {                     type = narrowType(type, clause.expression, /*assumeTrue* / false);                 }             } */
			if hasDefaultClause {
				/* TODO(ForStatement): for (let i = clauseEnd; i < switchStatement.caseBlock.clauses.length; i++) {                     const clause = switchStatement.caseBlock.clauses[i];                     if (clause.kind === SyntaxKind.CaseClause) {                         type = narrowType(type, clause.expression, /*assumeTrue* / false);                     }                 } */
				return type_
			}
			clauses := switchStatement.caseBlock.clauses.slice(clauseStart, clauseEnd)
			return getUnionType(map_(clauses, func(clause /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").CaseOrDefaultClause */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(BinaryExpression): clause.kind === SyntaxKind.CaseClause */
				/* TODO(QuestionToken): ? */
				/* TODO(CallExpression): narrowType(type, clause.expression, /*assumeTrue* / true) */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): neverType */
			}))
		}
		isMatchingConstructorReference := func(expr Expression) /* TODO(undefined): boolean */ TODO {
			return (isPropertyAccessExpression(expr) && idText(expr.name) == "constructor" || isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text == "constructor") && isMatchingReference(reference, expr.expression)
		}
		narrowTypeByConstructor := func(type_ Type, operator SyntaxKind, identifier Expression, assumeTrue bool) Type {
			if /* TODO(ConditionalExpression): assumeTrue ? (operator !== SyntaxKind.EqualsEqualsToken && operator !== SyntaxKind.EqualsEqualsEqualsToken) : (operator !== SyntaxKind.ExclamationEqualsToken && operator !== SyntaxKind.ExclamationEqualsEqualsToken) */ TODO {
				return type_
			}
			identifierType := getTypeOfExpression(identifier)
			if !isFunctionType(identifierType) && !isConstructorType(identifierType) {
				return type_
			}
			prototypeProperty := getPropertyOfType(identifierType, "prototype" /* as */ /* TODO(TypeReference): __String */)
			if !prototypeProperty {
				return type_
			}
			prototypeType := getTypeOfSymbol(prototypeProperty)
			candidate := /* TODO(ConditionalExpression): !isTypeAny(prototypeType) ? prototypeType : undefined */ TODO
			if !candidate || candidate == globalObjectType || candidate == globalFunctionType {
				return type_
			}
			if isTypeAny(type_) {
				return candidate
			}
			return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): isConstructedBy */
				/* TODO(Identifier): t */
				/* TODO(Identifier): candidate */
			})
			isConstructedBy := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
				if source.flags&TypeFlagsObject && getObjectFlags(source)&ObjectFlagsClass || target.flags&TypeFlagsObject && getObjectFlags(target)&ObjectFlagsClass {
					return source.symbol == target.symbol
				}
				return isTypeSubtypeOf(source, target)
			}
		}
		narrowTypeByInstanceof := func(type_ Type, expr InstanceofExpression, assumeTrue bool) Type {
			left := getReferenceCandidate(expr.left)
			if !isMatchingReference(reference, left) {
				if assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference) {
					return getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
				}
				return type_
			}
			right := expr.right
			rightType := getTypeOfExpression(right)
			if !isTypeDerivedFrom(rightType, globalObjectType) {
				return type_
			}
			signature := getEffectsSignature(expr)
			predicate := signature && getTypePredicateOfSignature(signature)
			if predicate && predicate.kind == TypePredicateKindIdentifier && predicate.parameterIndex == 0 {
				return getNarrowedType(type_, predicate.type_, assumeTrue, true)
			}
			if !isTypeDerivedFrom(rightType, globalFunctionType) {
				return type_
			}
			instanceType := mapType(rightType, getInstanceType)
			if isTypeAny(type_) && (instanceType == globalObjectType || instanceType == globalFunctionType) || !assumeTrue && !(instanceType.flags&TypeFlagsObject && !isEmptyAnonymousObjectType(instanceType)) {
				return type_
			}
			return getNarrowedType(type_, instanceType, assumeTrue, true)
		}
		getInstanceType := func(constructorType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			prototypePropertyType := getTypeOfPropertyOfType(constructorType, "prototype" /* as */ /* TODO(TypeReference): __String */)
			if prototypePropertyType && !isTypeAny(prototypePropertyType) {
				return prototypePropertyType
			}
			constructSignatures := getSignaturesOfType(constructorType, SignatureKindConstruct)
			if constructSignatures.length {
				return getUnionType(map_(constructSignatures, func(signature /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(Identifier): getReturnTypeOfSignature */
					/* TODO(CallExpression): getErasedSignature(signature) */
				}))
			}
			return emptyObjectType
		}
		getNarrowedType := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) Type {
			key := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : undefined */ TODO
			return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(key, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived)) */ TODO
		}
		getNarrowedTypeWorker := func(type_ Type, candidate Type, assumeTrue bool, checkDerived bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			if !assumeTrue {
				if type_ == candidate {
					return neverType
				}
				if checkDerived {
					return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(CallExpression): isTypeDerivedFrom(t, candidate) */
					})
				}
				trueType := getNarrowedType(type_, candidate, true, false)
				return filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): isTypeSubsetOf(t, trueType) */
				})
			}
			if type_.flags & TypeFlagsAnyOrUnknown {
				return candidate
			}
			if type_ == candidate {
				return candidate
			}
			isRelated := /* TODO(ConditionalExpression): checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf */ TODO
			keyPropertyName := /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? getKeyPropertyName(type as UnionType) : undefined */ TODO
			narrowedType := mapType(candidate, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				discriminant := keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName)
				matching := discriminant && getConstituentTypeForKeyType(type_ /* as */ /* TODO(TypeReference): UnionType */, discriminant)
				directlyRelated := mapType(matching || type_ /* TODO(ConditionalExpression): checkDerived ?                         t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType :                         t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType */, TODO)
				return /* TODO(ConditionalExpression): directlyRelated.flags & TypeFlags.Never ?                     mapType(type, t => maybeTypeOfKind(t, TypeFlags.Instantiable) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) :                     directlyRelated */ TODO
			})
			return /* TODO(ConditionalExpression): !(narrowedType.flags & TypeFlags.Never) ? narrowedType :                 isTypeSubtypeOf(candidate, type) ? candidate :                 isTypeAssignableTo(type, candidate) ? type :                 isTypeAssignableTo(candidate, type) ? candidate :                 getIntersectionType([type, candidate]) */ TODO
		}
		narrowTypeByCallExpression := func(type_ Type, callExpression CallExpression, assumeTrue bool) Type {
			if hasMatchingArgument(callExpression, reference) {
				signature := /* TODO(ConditionalExpression): assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : undefined */ TODO
				predicate := signature && getTypePredicateOfSignature(signature)
				if predicate && (predicate.kind == TypePredicateKindThis || predicate.kind == TypePredicateKindIdentifier) {
					return narrowTypeByTypePredicate(type_, predicate, callExpression, assumeTrue)
				}
			}
			if containsMissingType(type_) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression) {
				callAccess := callExpression.expression
				if isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) && isIdentifier(callAccess.name) && callAccess.name.escapedText == "hasOwnProperty" && callExpression.arguments.length == 1 {
					argument := /* TODO(ElementAccessExpression): callExpression.arguments[0] */ TODO
					if isStringLiteralLike(argument) && getAccessedPropertyName(reference) == escapeLeadingUnderscores(argument.text) {
						return getTypeWithFacts(type_ /* TODO(ConditionalExpression): assumeTrue ? TypeFacts.NEUndefined : TypeFacts.EQUndefined */, TODO)
					}
				}
			}
			return type_
		}
		narrowTypeByTypePredicate := func(type_ Type, predicate TypePredicate, callExpression CallExpression, assumeTrue bool) Type {
			if predicate.type_ && !(isTypeAny(type_) && (predicate.type_ == globalObjectType || predicate.type_ == globalFunctionType)) {
				predicateArgument := getTypePredicateArgument(predicate, callExpression)
				if predicateArgument {
					if isMatchingReference(reference, predicateArgument) {
						return getNarrowedType(type_, predicate.type_, assumeTrue, false)
					}
					if strictNullChecks && optionalChainContainsReference(predicateArgument, reference) && (assumeTrue && !(hasTypeFacts(predicate.type_, TypeFactsEQUndefined)) || !assumeTrue && everyType(predicate.type_, isNullableType)) {
						type_ = getAdjustedTypeWithFacts(type_, TypeFactsNEUndefinedOrNull)
					}
					access := getDiscriminantPropertyAccess(predicateArgument, type_)
					if access {
						return narrowTypeByDiscriminant(type_, access, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
							/* TODO(Identifier): getNarrowedType */
							/* TODO(Identifier): t */
							/* TODO(NonNullExpression): predicate.type! */
							/* TODO(Identifier): assumeTrue */
							/* TODO(FalseKeyword): false */
						})
					}
				}
			}
			return type_
		}
		narrowType := func(type_ Type, expr Expression, assumeTrue bool) Type {
			if isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionToken || expr.parent.operatorToken.kind == SyntaxKindQuestionQuestionEqualsToken) && expr.parent.left == expr {
				return narrowTypeByOptionality(type_, expr, assumeTrue)
			}
			/* TODO(SwitchStatement): switch (expr.kind) {                 case SyntaxKind.Identifier:                     // When narrowing a reference to a const variable, non-assigned parameter, or readonly property, we inline                     // up to five levels of aliased conditional expressions that are themselves declared as const variables.                     if (!isMatchingReference(reference, expr) && inlineLevel < 5) {                         const symbol = getResolvedSymbol(expr as Identifier);                         if (isConstantVariable(symbol)) {                             const declaration = symbol.valueDeclaration;                             if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(reference)) {                                 inlineLevel++;                                 const result = narrowType(type, declaration.initializer, assumeTrue);                                 inlineLevel--;                                 return result;                             }                         }                     }                     // falls through                 case SyntaxKind.ThisKeyword:                 case SyntaxKind.SuperKeyword:                 case SyntaxKind.PropertyAccessExpression:                 case SyntaxKind.ElementAccessExpression:                     return narrowTypeByTruthiness(type, expr, assumeTrue);                 case SyntaxKind.CallExpression:                     return narrowTypeByCallExpression(type, expr as CallExpression, assumeTrue);                 case SyntaxKind.ParenthesizedExpression:                 case SyntaxKind.NonNullExpression:                     return narrowType(type, (expr as ParenthesizedExpression | NonNullExpression).expression, assumeTrue);                 case SyntaxKind.BinaryExpression:                     return narrowTypeByBinaryExpression(type, expr as BinaryExpression, assumeTrue);                 case SyntaxKind.PrefixUnaryExpression:                     if ((expr as PrefixUnaryExpression).operator === SyntaxKind.ExclamationToken) {                         return narrowType(type, (expr as PrefixUnaryExpression).operand, !assumeTrue);                     }                     break;             } */
			return type_
		}
		narrowTypeByOptionality := func(type_ Type, expr Expression, assumePresent bool) Type {
			if isMatchingReference(reference, expr) {
				return getAdjustedTypeWithFacts(type_ /* TODO(ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */, TODO)
			}
			access := getDiscriminantPropertyAccess(expr, type_)
			if access {
				return narrowTypeByDiscriminant(type_, access, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
					/* TODO(Identifier): getTypeWithFacts */
					/* TODO(Identifier): t */
					/* TODO(ConditionalExpression): assumePresent ? TypeFacts.NEUndefinedOrNull : TypeFacts.EQUndefinedOrNull */
				})
			}
			return type_
		}
	}
	getTypeOfSymbolAtLocation := func(symbol Symbol, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		symbol = getExportSymbolOfValueSymbolIfExported(symbol)
		if location.kind == SyntaxKindIdentifier || location.kind == SyntaxKindPrivateIdentifier {
			if isRightSideOfQualifiedNameOrPropertyAccess(location) {
				location = location.parent
			}
			if isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location)) {
				type_ := removeOptionalTypeMarker( /* TODO(ConditionalExpression): isWriteAccess(location) && location.kind === SyntaxKind.PropertyAccessExpression ?                         checkPropertyAccessExpression(location as PropertyAccessExpression, /*checkMode* / undefined, /*writeOnly* / true) :                         getTypeOfExpression(location as Expression) */ TODO)
				if getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) == symbol {
					return type_
				}
			}
		}
		if isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent) {
			return getWriteTypeOfAccessors(location.parent.symbol)
		}
		return /* TODO(ConditionalExpression): isRightSideOfAccessExpression(location) && isWriteAccess(location.parent) ? getWriteTypeOfSymbol(symbol) : getNonMissingTypeOfSymbol(symbol) */ TODO
	}
	getControlFlowContainer := func(node Node) Node {
		return /* TODO(NonNullExpression): findAncestor(node.parent, node =>             isFunctionLike(node) && !getImmediatelyInvokedFunctionExpression(node) ||             node.kind === SyntaxKind.ModuleBlock ||             node.kind === SyntaxKind.SourceFile ||             node.kind === SyntaxKind.PropertyDeclaration)! */ TODO
	}
	isSymbolAssignedDefinitely := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol.lastAssignmentPos !== undefined */ TODO {
			return symbol.lastAssignmentPos < 0
		}
		return isSymbolAssigned(symbol) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol.lastAssignmentPos !== undefined */ TODO && symbol.lastAssignmentPos < 0
	}
	isSymbolAssigned := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		return !isPastLastAssignment(symbol, nil)
	}
	isPastLastAssignment := func(symbol Symbol, location Node) /* TODO(undefined): boolean | undefined */ TODO {
		parent := findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile)
		if !parent {
			return false
		}
		links := getNodeLinks(parent)
		if !(links.flags & NodeCheckFlagsAssignmentsMarked) {
			links.flags |= NodeCheckFlagsAssignmentsMarked
			if !hasParentWithAssignmentsMarked(parent) {
				markNodeAssignments(parent)
			}
		}
		return !symbol.lastAssignmentPos || location && Math.abs(symbol.lastAssignmentPos) < location.pos
	}
	isSomeSymbolAssigned := func(rootDeclaration Node) /* TODO(undefined): boolean */ TODO {
		Debug.assert(isVariableDeclaration(rootDeclaration) || isParameter(rootDeclaration))
		return isSomeSymbolAssignedWorker(rootDeclaration.name)
	}
	isSomeSymbolAssignedWorker := func(node BindingName) bool {
		if node.kind == SyntaxKindIdentifier {
			return isSymbolAssigned(getSymbolOfDeclaration(node.parent /* as */ /* TODO(TypeReference): Declaration */))
		}
		return some(node.elements, func(e /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement | import("/home/jabaile/work/TypeScript/src/compiler/types").OmittedExpression */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): e.kind !== SyntaxKind.OmittedExpression */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isSomeSymbolAssignedWorker(e.name) */
		})
	}
	hasParentWithAssignmentsMarked := func(node Node) /* TODO(undefined): boolean */ TODO {
		return !!findAncestor(node.parent, func(node /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): isFunctionOrSourceFile(node) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(PrefixUnaryExpression): !!(getNodeLinks(node).flags & NodeCheckFlags.AssignmentsMarked) */
		})
	}
	isFunctionOrSourceFile := func(node Node) /* TODO(undefined): boolean */ TODO {
		return isFunctionLikeDeclaration(node) || isSourceFile(node)
	}
	markNodeAssignments := func(node Node) {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 const assigmentTarget = getAssignmentTargetKind(node);                 if (assigmentTarget !== AssignmentKind.None) {                     const symbol = getResolvedSymbol(node as Identifier);                     const hasDefiniteAssignment = assigmentTarget === AssignmentKind.Definite || (symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0);                     if (isParameterOrMutableLocalVariable(symbol)) {                         if (symbol.lastAssignmentPos === undefined || Math.abs(symbol.lastAssignmentPos) !== Number.MAX_VALUE) {                             const referencingFunction = findAncestor(node, isFunctionOrSourceFile);                             const declaringFunction = findAncestor(symbol.valueDeclaration, isFunctionOrSourceFile);                             symbol.lastAssignmentPos = referencingFunction === declaringFunction ? extendAssignmentPosition(node, symbol.valueDeclaration!) : Number.MAX_VALUE;                         }                         if (hasDefiniteAssignment && symbol.lastAssignmentPos > 0) {                             symbol.lastAssignmentPos *= -1;                         }                     }                 }                 return;             case SyntaxKind.ExportSpecifier:                 const exportDeclaration = (node as ExportSpecifier).parent.parent;                 const name = (node as ExportSpecifier).propertyName || (node as ExportSpecifier).name;                 if (!(node as ExportSpecifier).isTypeOnly && !exportDeclaration.isTypeOnly && !exportDeclaration.moduleSpecifier && name.kind !== SyntaxKind.StringLiteral) {                     const symbol = resolveEntityName(name, SymbolFlags.Value, /*ignoreErrors* / true, /*dontResolveAlias* / true);                     if (symbol && isParameterOrMutableLocalVariable(symbol)) {                         const sign = symbol.lastAssignmentPos !== undefined && symbol.lastAssignmentPos < 0 ? -1 : 1;                         symbol.lastAssignmentPos = sign * Number.MAX_VALUE;                     }                 }                 return;             case SyntaxKind.InterfaceDeclaration:             case SyntaxKind.TypeAliasDeclaration:             case SyntaxKind.EnumDeclaration:                 return;         } */
		if isTypeNode(node) {
			return
		}
		forEachChild(node, markNodeAssignments)
	}
	extendAssignmentPosition := func(node Node, declaration Declaration) /* TODO(undefined): number */ TODO {
		pos := node.pos
		/* TODO(WhileStatement): while (node && node.pos > declaration.pos) {             switch (node.kind) {                 case SyntaxKind.VariableStatement:                 case SyntaxKind.ExpressionStatement:                 case SyntaxKind.IfStatement:                 case SyntaxKind.DoStatement:                 case SyntaxKind.WhileStatement:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForInStatement:                 case SyntaxKind.ForOfStatement:                 case SyntaxKind.WithStatement:                 case SyntaxKind.SwitchStatement:                 case SyntaxKind.TryStatement:                 case SyntaxKind.ClassDeclaration:                     pos = node.end;             }             node = node.parent;         } */
		return pos
	}
	isConstantVariable := func(symbol Symbol) /* TODO(undefined): boolean | 0 */ TODO {
		return symbol.flags&SymbolFlagsVariable && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getDeclarationNodeFlagsFromSymbol(symbol) & NodeFlags.Constant) !== 0 */ TODO
	}
	isParameterOrMutableLocalVariable := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		declaration := symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration)
		return !!declaration && (isParameter(declaration) || isVariableDeclaration(declaration) && (isCatchClause(declaration.parent) || isMutableLocalVariableDeclaration(declaration)))
	}
	isMutableLocalVariableDeclaration := func(declaration VariableDeclaration) /* TODO(undefined): boolean */ TODO {
		return !!(declaration.parent.flags & NodeFlagsLet) && !(getCombinedModifierFlags(declaration)&ModifierFlagsExport || declaration.parent.parent.kind == SyntaxKindVariableStatement && isGlobalSourceFile(declaration.parent.parent.parent))
	}
	parameterInitializerContainsUndefined := func(declaration ParameterDeclaration) bool {
		links := getNodeLinks(declaration)
		if links.parameterInitializerContainsUndefined == nil {
			if !pushTypeResolution(declaration, TypeSystemPropertyNameParameterInitializerContainsUndefined) {
				reportCircularityError(declaration.symbol)
				return true
			}
			containsUndefined := !!(hasTypeFacts(checkDeclarationInitializer(declaration, CheckModeNormal), TypeFactsIsUndefined))
			if !popTypeResolution() {
				reportCircularityError(declaration.symbol)
				return true
			}
			/* TODO(ExpressionStatement): links.parameterInitializerContainsUndefined ??= containsUndefined; */
		}
		return links.parameterInitializerContainsUndefined
	}
	removeOptionalityFromDeclaredType := func(declaredType Type, declaration VariableLikeDeclaration) Type {
		removeUndefined := strictNullChecks && declaration.kind == SyntaxKindParameter && declaration.initializer && hasTypeFacts(declaredType, TypeFactsIsUndefined) && !parameterInitializerContainsUndefined(declaration)
		return /* TODO(ConditionalExpression): removeUndefined ? getTypeWithFacts(declaredType, TypeFacts.NEUndefined) : declaredType */ TODO
	}
	isConstraintPosition := func(type_ Type, node Node) /* TODO(undefined): boolean */ TODO {
		parent := node.parent
		return parent.kind == SyntaxKindPropertyAccessExpression || parent.kind == SyntaxKindQualifiedName || parent.kind == SyntaxKindCallExpression && (parent /* as */ /* TODO(TypeReference): CallExpression */).expression == node || parent.kind == SyntaxKindNewExpression && (parent /* as */ /* TODO(TypeReference): NewExpression */).expression == node || parent.kind == SyntaxKindElementAccessExpression && (parent /* as */ /* TODO(TypeReference): ElementAccessExpression */).expression == node && !(someType(type_, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression((parent /* as */ /* TODO(TypeReference): ElementAccessExpression */).argumentExpression)))
	}
	isGenericTypeWithUnionConstraint := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithUnionConstraint) :             !!(type.flags & TypeFlags.Instantiable && getBaseConstraintOrType(type).flags & (TypeFlags.Nullable | TypeFlags.Union)) */ TODO
	}
	isGenericTypeWithoutNullableConstraint := func(type_ Type) bool {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Intersection ?             some((type as IntersectionType).types, isGenericTypeWithoutNullableConstraint) :             !!(type.flags & TypeFlags.Instantiable && !maybeTypeOfKind(getBaseConstraintOrType(type), TypeFlags.Nullable)) */ TODO
	}
	hasContextualTypeWithNoGenericTypes := func(node Node, checkMode *CheckMode) /* TODO(undefined): boolean | undefined */ TODO {
		contextualType := (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) && !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName == node) && ( /* TODO(ConditionalExpression): checkMode && checkMode & CheckMode.RestBindingElement ?                 getContextualType(node, ContextFlags.SkipBindingPatterns)                 : getContextualType(node, /*contextFlags* / undefined) */ TODO)
		return contextualType && !isGenericType(contextualType)
	}
	getNarrowableTypeForReference := func(type_ Type, reference Node, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isNoInferType(type_) {
			type_ = (type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType
		}
		substituteConstraints := !(checkMode && checkMode&CheckModeInferential) && someType(type_, isGenericTypeWithUnionConstraint) && (isConstraintPosition(type_, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode))
		return /* TODO(ConditionalExpression): substituteConstraints ? mapType(type, getBaseConstraintOrType) : type */ TODO
	}
	isExportOrExportExpression := func(location Node) /* TODO(undefined): boolean */ TODO {
		return !!findAncestor(location, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			parent := n.parent
			if parent == nil {
				return "quit"
			}
			if isExportAssignment(parent) {
				return parent.expression == n && isEntityNameExpression(n)
			}
			if isExportSpecifier(parent) {
				return parent.name == n || parent.propertyName == n
			}
			return false
		})
	}
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, hint /* TODO(QualifiedName): ReferenceHint.Property */ TODO, propSymbol *Symbol, parentType Type)
	// OVERLOAD: markLinkedReferences := func(location Identifier, hint /* TODO(QualifiedName): ReferenceHint.Identifier */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ExportAssignment, hint /* TODO(QualifiedName): ReferenceHint.ExportAssignment */ TODO)
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any, hint /* TODO(QualifiedName): ReferenceHint.Jsx */ TODO)
	// OVERLOAD: markLinkedReferences := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, hint /* TODO(QualifiedName): ReferenceHint.AsyncFunction */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ImportEqualsDeclaration, hint /* TODO(QualifiedName): ReferenceHint.ExportImportEquals */ TODO)
	// OVERLOAD: markLinkedReferences := func(location ExportSpecifier, hint /* TODO(QualifiedName): ReferenceHint.ExportSpecifier */ TODO)
	// OVERLOAD: markLinkedReferences := func(location HasDecorators, hint /* TODO(QualifiedName): ReferenceHint.Decorator */ TODO)
	// OVERLOAD: markLinkedReferences := func(location Node, hint /* TODO(QualifiedName): ReferenceHint.Unspecified */ TODO, propSymbol Symbol, parentType Type)
	markLinkedReferences := func(location Node, hint ReferenceHint, propSymbol Symbol, parentType Type) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if location.flags&NodeFlagsAmbient && !isPropertySignature(location) && !isPropertyDeclaration(location) {
			return
		}
		/* TODO(SwitchStatement): switch (hint) {             case ReferenceHint.Identifier:                 return markIdentifierAliasReferenced(location as Identifier);             case ReferenceHint.Property:                 return markPropertyAliasReferenced(location as PropertyAccessExpression | QualifiedName, propSymbol, parentType);             case ReferenceHint.ExportAssignment:                 return markExportAssignmentAliasReferenced(location as ExportAssignment);             case ReferenceHint.Jsx:                 return markJsxAliasReferenced(location as JsxOpeningLikeElement | JsxOpeningFragment);             case ReferenceHint.AsyncFunction:                 return markAsyncFunctionAliasReferenced(location as FunctionLikeDeclaration | MethodSignature);             case ReferenceHint.ExportImportEquals:                 return markImportEqualsAliasReferenced(location as ImportEqualsDeclaration);             case ReferenceHint.ExportSpecifier:                 return markExportSpecifierAliasReferenced(location as ExportSpecifier);             case ReferenceHint.Decorator:                 return markDecoratorAliasReferenced(location as HasDecorators);             case ReferenceHint.Unspecified: {                 // Identifiers in expression contexts are emitted, so we need to follow their referenced aliases and mark them as used                 // Some non-expression identifiers are also treated as expression identifiers for this purpose, eg, `a` in `b = {a}` or `q` in `import r = q`                 // This is the exception, rather than the rule - most non-expression identifiers are declaration names.                 if (isIdentifier(location) && (isExpressionNode(location) || isShorthandPropertyAssignment(location.parent) || (isImportEqualsDeclaration(location.parent) && location.parent.moduleReference === location)) && shouldMarkIdentifierAliasReferenced(location)) {                     if (isPropertyAccessOrQualifiedName(location.parent)) {                         const left = isPropertyAccessExpression(location.parent) ? location.parent.expression : location.parent.left;                         if (left !== location) return; // Only mark the LHS (the RHS is a property lookup)                     }                     markIdentifierAliasReferenced(location);                     return;                 }                 if (isPropertyAccessOrQualifiedName(location)) {                     let topProp: Node | undefined = location;                     while (isPropertyAccessOrQualifiedName(topProp)) {                         if (isPartOfTypeNode(topProp)) return;                         topProp = topProp.parent;                     }                     return markPropertyAliasReferenced(location);                 }                 if (isExportAssignment(location)) {                     return markExportAssignmentAliasReferenced(location);                 }                 if (isJsxOpeningLikeElement(location) || isJsxOpeningFragment(location)) {                     return markJsxAliasReferenced(location);                 }                 if (isImportEqualsDeclaration(location)) {                     if (isInternalModuleImportEqualsDeclaration(location) || checkExternalImportOrExportDeclaration(location)) {                         return markImportEqualsAliasReferenced(location);                     }                     return;                 }                 if (isExportSpecifier(location)) {                     return markExportSpecifierAliasReferenced(location);                 }                 if (isFunctionLikeDeclaration(location) || isMethodSignature(location)) {                     markAsyncFunctionAliasReferenced(location);                     // Might be decorated, fall through to decorator final case                 }                 if (!compilerOptions.emitDecoratorMetadata) {                     return;                 }                 if (!canHaveDecorators(location) || !hasDecorators(location) || !location.modifiers || !nodeCanBeDecorated(legacyDecorators, location, location.parent, location.parent.parent)) {                     return;                 }                  return markDecoratorAliasReferenced(location);             }             default:                 Debug.assertNever(hint, `Unhandled reference hint: ${hint}`);         } */
	}
	markIdentifierAliasReferenced := func(location Identifier) {
		symbol := getResolvedSymbol(location)
		if symbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol !== argumentsSymbol */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol !== unknownSymbol */ TODO && !isThisInTypeQuery(location) {
			markAliasReferenced(symbol, location)
		}
	}
	markPropertyAliasReferenced := func(location /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, propSymbol Symbol, parentType Type) {
		left := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.expression : location.left */ TODO
		if isThisIdentifier(left) || !isIdentifier(left) {
			return
		}
		parentSymbol := getResolvedSymbol(left)
		if !parentSymbol || parentSymbol == unknownSymbol {
			return
		}
		if getIsolatedModules(compilerOptions) || (shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location)) {
			markAliasReferenced(parentSymbol, location)
			return
		}
		leftType := parentType || checkExpressionCached(left)
		if isTypeAny(leftType) || leftType == silentNeverType {
			markAliasReferenced(parentSymbol, location)
			return
		}
		prop := propSymbol
		if !prop && !parentType {
			right := /* TODO(ConditionalExpression): isPropertyAccessExpression(location) ? location.name : location.right */ TODO
			lexicallyScopedSymbol := isPrivateIdentifier(right) && lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			assignmentKind := getAssignmentTargetKind(location)
			apparentType := getApparentType( /* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(location) ? getWidenedType(leftType) : leftType */ TODO)
			prop = /* TODO(ConditionalExpression): isPrivateIdentifier(right) ? lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(apparentType, lexicallyScopedSymbol) || undefined : getPropertyOfType(apparentType, right.escapedText) */ TODO
		}
		if !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags&SymbolFlagsEnumMember && location.parent.kind == SyntaxKindEnumMember)) {
			markAliasReferenced(parentSymbol, location)
		}
		return
	}
	markExportAssignmentAliasReferenced := func(location ExportAssignment) {
		if isIdentifier(location.expression) {
			id := location.expression
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll, true, true, location))
			if sym {
				markAliasReferenced(sym, id)
			}
		}
	}
	markJsxAliasReferenced := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		if !getJsxNamespaceContainerForImplicitImport(node) {
			jsxFactoryRefErr := /* TODO(ConditionalExpression): diagnostics && compilerOptions.jsx === JsxEmit.React ? Diagnostics.Cannot_find_name_0 : undefined */ TODO
			jsxFactoryNamespace := getJsxNamespace(node)
			jsxFactoryLocation := /* TODO(ConditionalExpression): isJsxOpeningLikeElement(node) ? node.tagName : node */ TODO
			var jsxFactorySym *Symbol
			if !(isJsxOpeningFragment(node) && jsxFactoryNamespace == "null") {
				jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, SymbolFlagsValue, jsxFactoryRefErr, true)
			}
			if jsxFactorySym {
				jsxFactorySym.isReferenced = SymbolFlagsAll
				if canCollectSymbolAliasAccessabilityData && jsxFactorySym.flags&SymbolFlagsAlias && !getTypeOnlyAliasDeclaration(jsxFactorySym) {
					markAliasSymbolAsReferenced(jsxFactorySym)
				}
			}
			if isJsxOpeningFragment(node) {
				file := getSourceFileOfNode(node)
				localJsxNamespace := getLocalJsxNamespace(file)
				if localJsxNamespace {
					resolveName(jsxFactoryLocation, localJsxNamespace, SymbolFlagsValue, jsxFactoryRefErr, true)
				}
			}
		}
		return
	}
	markAsyncFunctionAliasReferenced := func(location /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) {
		if languageVersion < ScriptTargetES2015 {
			if getFunctionFlags(location) & FunctionFlagsAsync {
				returnTypeNode := getEffectiveReturnTypeNode(location)
				markTypeNodeAsReferenced(returnTypeNode)
			}
		}
	}
	markImportEqualsAliasReferenced := func(location ImportEqualsDeclaration) {
		if hasSyntacticModifier(location, ModifierFlagsExport) {
			markExportAsReferenced(location)
		}
	}
	markExportSpecifierAliasReferenced := func(location ExportSpecifier) {
		if !location.parent.parent.moduleSpecifier && !location.isTypeOnly && !location.parent.parent.isTypeOnly {
			exportedName := location.propertyName || location.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
			}
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer( /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO))) {
			} else {
				target := symbol && ( /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Alias ? resolveAlias(symbol) : symbol */ TODO)
				if !target || getSymbolFlags(target)&SymbolFlagsValue {
					markExportAsReferenced(location)
					markIdentifierAliasReferenced(exportedName)
				}
			}
			return
		}
	}
	markDecoratorAliasReferenced := func(node HasDecorators) {
		if compilerOptions.emitDecoratorMetadata {
			firstDecorator := find(node.modifiers, isDecorator)
			if !firstDecorator {
				return
			}
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersMetadata)
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ClassDeclaration:                     const constructor = getFirstConstructorWithBody(node);                     if (constructor) {                         for (const parameter of constructor.parameters) {                             markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                         }                     }                     break;                  case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     const otherKind = node.kind === SyntaxKind.GetAccessor ? SyntaxKind.SetAccessor : SyntaxKind.GetAccessor;                     const otherAccessor = getDeclarationOfKind<AccessorDeclaration>(getSymbolOfDeclaration(node), otherKind);                     markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor));                     break;                 case SyntaxKind.MethodDeclaration:                     for (const parameter of node.parameters) {                         markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                     }                      markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node));                     break;                  case SyntaxKind.PropertyDeclaration:                     markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node));                     break;                  case SyntaxKind.Parameter:                     markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));                     const containingSignature = node.parent;                     for (const parameter of containingSignature.parameters) {                         markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));                     }                     markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(containingSignature));                     break;             } */
		}
	}
	markAliasReferenced := func(symbol Symbol, location Node) {
		if !canCollectSymbolAliasAccessabilityData {
			return
		}
		if isNonLocalAlias(symbol, SymbolFlagsValue) && !isInTypeQuery(location) {
			target := resolveAlias(symbol)
			if getSymbolFlags(symbol, true) & (SymbolFlagsValue | SymbolFlagsExportValue) {
				if getIsolatedModules(compilerOptions) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target)) {
					markAliasSymbolAsReferenced(symbol)
				}
			}
		}
	}
	markAliasSymbolAsReferenced := func(symbol Symbol) /* TODO(undefined): undefined */ TODO {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		links := getSymbolLinks(symbol)
		if !links.referenced {
			links.referenced = true
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				/* TODO(CallExpression): Debug.fail() */
			}
			if isInternalModuleImportEqualsDeclaration(node) {
				if getSymbolFlags(resolveSymbol(symbol)) & SymbolFlagsValue {
					left := getFirstIdentifier(node.moduleReference /* as */ /* TODO(TypeReference): EntityNameExpression */)
					markIdentifierAliasReferenced(left)
				}
			}
		}
	}
	markExportAsReferenced := func(node /* TODO(UnionType): ImportEqualsDeclaration | ExportSpecifier */ any) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if target {
			markAlias := target == unknownSymbol || ((getSymbolFlags(symbol, true) & SymbolFlagsValue) && !isConstEnumOrConstEnumOnlyModule(target))
			if markAlias {
				markAliasSymbolAsReferenced(symbol)
			}
		}
	}
	markEntityNameOrEntityExpressionAsReference := func(typeName *EntityNameOrEntityNameExpression, forDecoratorMetadata bool) {
		if !typeName {
		}
		rootName := getFirstIdentifier(typeName)
		meaning := ( /* TODO(ConditionalExpression): typeName.kind === SyntaxKind.Identifier ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO) | SymbolFlagsAlias
		rootSymbol := resolveName(rootName, rootName.escapedText, meaning, nil, true)
		if rootSymbol && rootSymbol.flags&SymbolFlagsAlias {
			if canCollectSymbolAliasAccessabilityData && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(rootSymbol) {
				markAliasSymbolAsReferenced(rootSymbol)
			} else if forDecoratorMetadata && getIsolatedModules(compilerOptions) && getEmitModuleKind(compilerOptions) >= ModuleKindES2015 && !symbolIsValue(rootSymbol) && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration) {
				diag := error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled)
				aliasDeclaration := find(rootSymbol.declarations || emptyArray, isAliasSymbolDeclaration)
				if aliasDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)))
				}
			}
		}
	}
	markTypeNodeAsReferenced := func(node *TypeNode) {
		markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node), false)
	}
	markDecoratorMedataDataTypeNodeAsReferenced := func(node *TypeNode) {
		entityName := getEntityNameForDecoratorMetadata(node)
		if entityName && isEntityName(entityName) {
			markEntityNameOrEntityExpressionAsReference(entityName, true)
		}
	}
	getNarrowedTypeOfSymbol := func(symbol Symbol, location Identifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type_ := getTypeOfSymbol(symbol)
		declaration := symbol.valueDeclaration
		if declaration {
			if isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2 {
				parent := declaration.parent.parent
				rootDeclaration := getRootDeclaration(parent)
				if rootDeclaration.kind == SyntaxKindVariableDeclaration && getCombinedNodeFlagsCached(rootDeclaration)&NodeFlagsConstant || rootDeclaration.kind == SyntaxKindParameter {
					links := getNodeLinks(parent)
					if !(links.flags & NodeCheckFlagsInCheckIdentifier) {
						links.flags |= NodeCheckFlagsInCheckIdentifier
						parentType := getTypeForBindingElementParent(parent, CheckModeNormal)
						parentTypeConstraint := parentType && mapType(parentType, getBaseConstraintOrType)
						links.flags &= ~NodeCheckFlagsInCheckIdentifier
						if parentTypeConstraint && parentTypeConstraint.flags&TypeFlagsUnion && !(rootDeclaration.kind == SyntaxKindParameter && isSomeSymbolAssigned(rootDeclaration)) {
							pattern := declaration.parent
							narrowedType := getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, nil, location.flowNode)
							if narrowedType.flags & TypeFlagsNever {
								return neverType
							}
							return getBindingElementTypeFromParentType(declaration, narrowedType, true)
						}
					}
				}
			}
			if isParameter(declaration) && !declaration.type_ && !declaration.initializer && !declaration.dotDotDotToken {
				func_ := declaration.parent
				if func_.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
					contextualSignature := getContextualSignature(func_)
					if contextualSignature && contextualSignature.parameters.length == 1 && signatureHasRestParameter(contextualSignature) {
						restType := getReducedApparentType(instantiateType(getTypeOfSymbol( /* TODO(ElementAccessExpression): contextualSignature.parameters[0] */ TODO), getInferenceContext(func_).nonFixingMapper))
						if restType.flags&TypeFlagsUnion && everyType(restType, isTupleType) && !some(func_.parameters, isSomeSymbolAssigned) {
							narrowedType := getFlowTypeOfReference(func_, restType, restType, nil, location.flowNode)
							index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): func.parameters.indexOf(declaration) - (getThisParameter(func) ? 1 : 0) */ TODO
							return getIndexedAccessType(narrowedType, getNumberLiteralType(index))
						}
					}
				}
			}
		}
		return type_
	}
	checkIdentifierCalculateNodeCheckFlags := func(node Identifier, symbol Symbol) {
		if isThisInTypeQuery(node) {
		}
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers)
				return
			}
			container := getContainingFunction(node)
			if container {
				if languageVersion < ScriptTargetES2015 {
					if container.kind == SyntaxKindArrowFunction {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES5_Consider_using_a_standard_function_expression)
					} else if hasSyntacticModifier(container, ModifierFlagsAsync) {
						error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES5_Consider_using_a_standard_function_or_method)
					}
				}
				getNodeLinks(container).flags |= NodeCheckFlagsCaptureArguments
				/* TODO(WhileStatement): while (container && isArrowFunction(container)) {                     container = getContainingFunction(container);                     if (container) {                         getNodeLinks(container).flags |= NodeCheckFlags.CaptureArguments;                     }                 } */
			}
			return
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		targetSymbol := resolveAliasWithDeprecationCheck(localOrExportSymbol, node)
		if isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations {
			addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText /* as */ /* TODO(StringKeyword): string */)
		}
		declaration := localOrExportSymbol.valueDeclaration
		if declaration && localOrExportSymbol.flags&SymbolFlagsClass {
			if isClassLike(declaration) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.name !== node */ TODO {
				container := getThisContainer(node, false, false)
				/* TODO(WhileStatement): while (container.kind !== SyntaxKind.SourceFile && container.parent !== declaration) {                     container = getThisContainer(container, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false);                 } */
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): container.kind !== SyntaxKind.SourceFile */ TODO {
					getNodeLinks(declaration).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(container).flags |= NodeCheckFlagsContainsConstructorReference
					getNodeLinks(node).flags |= NodeCheckFlagsConstructorReference
				}
			}
		}
		checkNestedBlockScopedBinding(node, symbol)
	}
	checkIdentifier := func(node Identifier, checkMode *CheckMode) Type {
		if isThisInTypeQuery(node) {
			return checkThisExpression(node)
		}
		symbol := getResolvedSymbol(node)
		if symbol == unknownSymbol {
			return errorType
		}
		checkIdentifierCalculateNodeCheckFlags(node, symbol)
		if symbol == argumentsSymbol {
			if isInPropertyInitializerOrClassStaticBlock(node) {
				return errorType
			}
			return getTypeOfSymbol(symbol)
		}
		if shouldMarkIdentifierAliasReferenced(node) {
			markLinkedReferences(node, ReferenceHintIdentifier)
		}
		localOrExportSymbol := getExportSymbolOfValueSymbolIfExported(symbol)
		declaration := localOrExportSymbol.valueDeclaration
		immediateDeclaration := declaration
		if declaration && declaration.kind == SyntaxKindBindingElement && contains(contextualBindingPatterns, declaration.parent) && findAncestor(node, func(parent /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): parent */
			/* TODO(EqualsEqualsEqualsToken): === */
			/* TODO(PropertyAccessExpression): declaration!.parent */
		}) {
			return nonInferrableAnyType
		}
		type_ := getNarrowedTypeOfSymbol(localOrExportSymbol, node)
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind {
			if !(localOrExportSymbol.flags & SymbolFlagsVariable) && !(isInJSFile(node) && localOrExportSymbol.flags&SymbolFlagsValueModule) {
				assignmentError := /* TODO(ConditionalExpression): localOrExportSymbol.flags & SymbolFlags.Enum ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum                     : localOrExportSymbol.flags & SymbolFlags.Class ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class                     : localOrExportSymbol.flags & SymbolFlags.Module ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace                     : localOrExportSymbol.flags & SymbolFlags.Function ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function                     : localOrExportSymbol.flags & SymbolFlags.Alias ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import                     : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable */ TODO
				error(node, assignmentError, symbolToString(symbol))
				return errorType
			}
			if isReadonlySymbol(localOrExportSymbol) {
				if localOrExportSymbol.flags & SymbolFlagsVariable {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol))
				} else {
					error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol))
				}
				return errorType
			}
		}
		isAlias := localOrExportSymbol.flags & SymbolFlagsAlias
		if localOrExportSymbol.flags & SymbolFlagsVariable {
			if assignmentKind == AssignmentKindDefinite {
				return /* TODO(ConditionalExpression): isInCompoundLikeAssignment(node) ? getBaseTypeOfLiteralType(type) : type */ TODO
			}
		} else if isAlias {
			declaration = getDeclarationOfAliasSymbol(symbol)
		} else {
			return type_
		}
		if !declaration {
			return type_
		}
		type_ = getNarrowableTypeForReference(type_, node, checkMode)
		isParameter := getRootDeclaration(declaration).kind == SyntaxKindParameter
		declarationContainer := getControlFlowContainer(declaration)
		flowContainer := getControlFlowContainer(node)
		isOuterVariable := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): flowContainer !== declarationContainer */ TODO
		isSpreadDestructuringAssignmentTarget := node.parent && node.parent.parent && isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent)
		isModuleExports := symbol.flags & SymbolFlagsModuleExports
		typeIsAutomatic := type_ == autoType || type_ == autoArrayType
		isAutomaticTypeInNonNull := typeIsAutomatic && node.parent.kind == SyntaxKindNonNullExpression
		/* TODO(WhileStatement): while (             flowContainer !== declarationContainer && (                 flowContainer.kind === SyntaxKind.FunctionExpression ||                 flowContainer.kind === SyntaxKind.ArrowFunction ||                 isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)             ) && (                 isConstantVariable(localOrExportSymbol) && type !== autoArrayType ||                 isParameterOrMutableLocalVariable(localOrExportSymbol) && isPastLastAssignment(localOrExportSymbol, node)             )         ) {             flowContainer = getControlFlowContainer(flowContainer);         } */
		isNeverInitialized := immediateDeclaration && isVariableDeclaration(immediateDeclaration) && !immediateDeclaration.initializer && !immediateDeclaration.exclamationToken && isMutableLocalVariableDeclaration(immediateDeclaration) && !isSymbolAssignedDefinitely(symbol)
		assumeInitialized := isParameter || isAlias || (isOuterVariable && !isNeverInitialized) || isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== autoType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== autoArrayType */ TODO && (!strictNullChecks || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (type.flags & (TypeFlags.AnyOrUnknown | TypeFlags.Void)) !== 0 */ TODO || isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind == SyntaxKindExportSpecifier) || node.parent.kind == SyntaxKindNonNullExpression || declaration.kind == SyntaxKindVariableDeclaration && (declaration /* as */ /* TODO(TypeReference): VariableDeclaration */).exclamationToken || declaration.flags&NodeFlagsAmbient
		initialType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? undefinedType :             assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, declaration as VariableLikeDeclaration) : type) :             typeIsAutomatic ? undefinedType : getOptionalType(type) */ TODO
		flowType := /* TODO(ConditionalExpression): isAutomaticTypeInNonNull ? getNonNullableType(getFlowTypeOfReference(node, type, initialType, flowContainer)) :             getFlowTypeOfReference(node, type, initialType, flowContainer) */ TODO
		if !isEvolvingArrayOperationTarget(node) && (type_ == autoType || type_ == autoArrayType) {
			if flowType == autoType || flowType == autoArrayType {
				if noImplicitAny {
					error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType))
					error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType))
				}
				return convertAutoToAny(flowType)
			}
		} else if !assumeInitialized && !containsUndefinedType(type_) && containsUndefinedType(flowType) {
			error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol))
			return type_
		}
		return /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
	}
	isSameScopedBindingElement := func(node Identifier, declaration Declaration) /* TODO(undefined): boolean | undefined */ TODO {
		if isBindingElement(declaration) {
			bindingElement := findAncestor(node, isBindingElement)
			return bindingElement && getRootDeclaration(bindingElement) == getRootDeclaration(declaration)
		}
	}
	shouldMarkIdentifierAliasReferenced := func(node Identifier) bool {
		parent := node.parent
		if parent {
			if isPropertyAccessExpression(parent) && parent.expression == node {
				return false
			}
			if isExportSpecifier(parent) && parent.isTypeOnly {
				return false
			}
			greatGrandparent := parent.parent.parent
			if greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly {
				return false
			}
		}
		return true
	}
	isInsideFunctionOrInstancePropertyInitializer := func(node Node, threshold Node) bool {
		return !!findAncestor(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(BinaryExpression): n === threshold */
			/* TODO(QuestionToken): ? */
			/* TODO(StringLiteral): "quit" */
			/* TODO(ColonToken): : */
			/* TODO(BinaryExpression): isFunctionLike(n) || (                 n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer === n             ) */
		})
	}
	getPartOfForStatementContainingNode := func(node Node, container ForStatement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
		return findAncestor(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(BinaryExpression): n === container */
			/* TODO(QuestionToken): ? */
			/* TODO(StringLiteral): "quit" */
			/* TODO(ColonToken): : */
			/* TODO(BinaryExpression): n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement */
		})
	}
	getEnclosingIterationStatement := func(node Node) Node {
		return findAncestor(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(ParenthesizedExpression): (!n || nodeStartsNewLexicalEnvironment(n)) */
			/* TODO(QuestionToken): ? */
			/* TODO(StringLiteral): "quit" */
			/* TODO(ColonToken): : */
			/* TODO(CallExpression): isIterationStatement(n, /*lookInLabeledStatements* / false) */
		})
	}
	checkNestedBlockScopedBinding := func(node Identifier, symbol Symbol) {
		if languageVersion >= ScriptTargetES2015 || (symbol.flags&(SymbolFlagsBlockScopedVariable|SymbolFlagsClass)) == 0 || !symbol.valueDeclaration || isSourceFile(symbol.valueDeclaration) || symbol.valueDeclaration.parent.kind == SyntaxKindCatchClause {
			return
		}
		container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
		isCaptured := isInsideFunctionOrInstancePropertyInitializer(node, container)
		enclosingIterationStatement := getEnclosingIterationStatement(container)
		if enclosingIterationStatement {
			if isCaptured {
				capturesBlockScopeBindingInLoopBody := true
				if isForStatement(container) {
					varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
					if varDeclList && varDeclList.parent == container {
						part := getPartOfForStatementContainingNode(node.parent, container)
						if part {
							links := getNodeLinks(part)
							links.flags |= NodeCheckFlagsContainsCapturedBlockScopeBinding
							capturedBindings := links.capturedBlockScopeBindings || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.capturedBlockScopeBindings = [] */ TODO)
							pushIfUnique(capturedBindings, symbol)
							if part == container.initializer {
								capturesBlockScopeBindingInLoopBody = false
							}
						}
					}
				}
				if capturesBlockScopeBindingInLoopBody {
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
				}
			}
			if isForStatement(container) {
				varDeclList := getAncestor(symbol.valueDeclaration, SyntaxKindVariableDeclarationList)
				if varDeclList && varDeclList.parent == container && isAssignedInBodyOfForStatement(node, container) {
					getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsNeedsLoopOutParameter
				}
			}
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsBlockScopedBindingInLoop
		}
		if isCaptured {
			getNodeLinks(symbol.valueDeclaration).flags |= NodeCheckFlagsCapturedBlockScopedBinding
		}
	}
	isBindingCapturedByNode := func(node Node, decl /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): boolean */ TODO {
		links := getNodeLinks(node)
		return !!links && contains(links.capturedBlockScopeBindings, getSymbolOfDeclaration(decl))
	}
	isAssignedInBodyOfForStatement := func(node Identifier, container ForStatement) bool {
		var current Node = node
		/* TODO(WhileStatement): while (current.parent.kind === SyntaxKind.ParenthesizedExpression) {             current = current.parent;         } */
		isAssigned := false
		if isAssignmentTarget(current) {
			isAssigned = true
		} else if current.parent.kind == SyntaxKindPrefixUnaryExpression || current.parent.kind == SyntaxKindPostfixUnaryExpression {
			expr := current.parent /* as */ /* TODO(UnionType): PrefixUnaryExpression | PostfixUnaryExpression */
			isAssigned = expr.operator == SyntaxKindPlusPlusToken || expr.operator == SyntaxKindMinusMinusToken
		}
		if !isAssigned {
			return false
		}
		return !!findAncestor(current, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(BinaryExpression): n === container */
			/* TODO(QuestionToken): ? */
			/* TODO(StringLiteral): "quit" */
			/* TODO(ColonToken): : */
			/* TODO(BinaryExpression): n === container.statement */
		})
	}
	captureLexicalThis := func(node Node, container Node) {
		getNodeLinks(node).flags |= NodeCheckFlagsLexicalThis
		if container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindConstructor {
			classNode := container.parent
			getNodeLinks(classNode).flags |= NodeCheckFlagsCaptureThis
		} else {
			getNodeLinks(container).flags |= NodeCheckFlagsCaptureThis
		}
	}
	findFirstSuperCall := func(node Node) *SuperCall {
		return /* TODO(ConditionalExpression): isSuperCall(node) ? node :             isFunctionLike(node) ? undefined :             forEachChild(node, findFirstSuperCall) */ TODO
	}
	classDeclarationExtendsNull := func(classDecl ClassLikeDeclaration) bool {
		classSymbol := getSymbolOfDeclaration(classDecl)
		classInstanceType := getDeclaredTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): InterfaceType */
		baseConstructorType := getBaseConstructorTypeOfClass(classInstanceType)
		return baseConstructorType == nullWideningType
	}
	checkThisBeforeSuper := func(node Node, container Node, diagnosticMessage DiagnosticMessage) {
		containingClassDecl := container.parent /* as */ /* TODO(TypeReference): ClassDeclaration */
		baseTypeNode := getClassExtendsHeritageElement(containingClassDecl)
		if baseTypeNode && !classDeclarationExtendsNull(containingClassDecl) {
			if canHaveFlowNode(node) && node.flowNode && !isPostSuperFlowNode(node.flowNode, false) {
				error(node, diagnosticMessage)
			}
		}
	}
	checkThisInStaticClassFieldInitializerInDecoratedClass := func(thisExpression Node, container Node) {
		if isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators && container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent) {
			error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class)
		}
	}
	checkThisExpression := func(node Node) Type {
		isNodeInTypeQuery := isInTypeQuery(node)
		container := getThisContainer(node, true, true)
		capturedByArrowFunction := false
		thisInComputedPropertyName := false
		if container.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class)
		}
		/* TODO(WhileStatement): while (true) {             // Now skip arrow functions to get the "real" owner of 'this'.             if (container.kind === SyntaxKind.ArrowFunction) {                 container = getThisContainer(container, /*includeArrowFunctions* / false, !thisInComputedPropertyName);                 capturedByArrowFunction = true;             }              if (container.kind === SyntaxKind.ComputedPropertyName) {                 container = getThisContainer(container, !capturedByArrowFunction, /*includeClassComputedPropertyName* / false);                 thisInComputedPropertyName = true;                 continue;             }              break;         } */
		checkThisInStaticClassFieldInitializerInDecoratedClass(node, container)
		if thisInComputedPropertyName {
			error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name)
		} else {
			/* TODO(SwitchStatement): switch (container.kind) {                 case SyntaxKind.ModuleDeclaration:                     error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);                     // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks                     break;                 case SyntaxKind.EnumDeclaration:                     error(node, Diagnostics.this_cannot_be_referenced_in_current_location);                     // do not return here so in case if lexical this is captured - it will be reflected in flags on NodeLinks                     break;             } */
		}
		if !isNodeInTypeQuery && capturedByArrowFunction && languageVersion < ScriptTargetES2015 {
			captureLexicalThis(node, container)
		}
		type_ := tryGetThisTypeAt(node, true, container)
		if noImplicitThis {
			globalThisType := getTypeOfSymbol(globalThisSymbol)
			if type_ == globalThisType && capturedByArrowFunction {
				error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this)
			} else if !type_ {
				diag := error(node, Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation)
				if !isSourceFile(container) {
					outsideThis := tryGetThisTypeAt(container)
					if outsideThis && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): outsideThis !== globalThisType */ TODO {
						addRelatedInfo(diag, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container))
					}
				}
			}
		}
		return type_ || anyType
	}
	tryGetThisTypeAt := func(node Node, includeGlobalThis /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */, container /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/utilities").ThisContainer */ TODO /* = */ /* TODO(CallExpression): getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false) */) *Type {
		isInJS := isInJSFile(node)
		if isFunctionLike(container) && (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container)) {
			thisType := getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container)
			if !thisType {
				className := getClassNameFromPrototypeMethod(container)
				if isInJS && className {
					classSymbol := checkExpression(className).symbol
					if classSymbol && classSymbol.members && (classSymbol.flags & SymbolFlagsFunction) {
						thisType = (getDeclaredTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): InterfaceType */).thisType
					}
				} else if isJSConstructor(container) {
					thisType = (getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)) /* as */ /* TODO(TypeReference): InterfaceType */).thisType
				}
				/* TODO(ExpressionStatement): thisType ||= getContextualThisParameterType(container); */
			}
			if thisType {
				return getFlowTypeOfReference(node, thisType)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			type_ := /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
			return getFlowTypeOfReference(node, type_)
		}
		if isSourceFile(container) {
			if container.commonJsModuleIndicator {
				fileSymbol := getSymbolOfDeclaration(container)
				return fileSymbol && getTypeOfSymbol(fileSymbol)
			} else if container.externalModuleIndicator {
				return undefinedType
			} else if includeGlobalThis {
				return getTypeOfSymbol(globalThisSymbol)
			}
		}
	}
	getExplicitThisType := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		container := getThisContainer(node, false, false)
		if isFunctionLike(container) {
			signature := getSignatureFromDeclaration(container)
			if signature.thisParameter {
				return getExplicitTypeOfSymbol(signature.thisParameter)
			}
		}
		if isClassLike(container.parent) {
			symbol := getSymbolOfDeclaration(container.parent)
			return /* TODO(ConditionalExpression): isStatic(container) ? getTypeOfSymbol(symbol) : (getDeclaredTypeOfSymbol(symbol) as InterfaceType).thisType! */ TODO
		}
	}
	getClassNameFromPrototypeMethod := func(container Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").LeftHandSideExpression | undefined */ TODO {
		if container.kind == SyntaxKindFunctionExpression && isBinaryExpression(container.parent) && getAssignmentDeclarationKind(container.parent) == AssignmentDeclarationKindPrototypeProperty {
			return ((container.parent.left /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression
		} else if container.kind == SyntaxKindMethodDeclaration && container.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent) && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.left /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression
		} else if container.kind == SyntaxKindFunctionExpression && container.parent.kind == SyntaxKindPropertyAssignment && container.parent.parent.kind == SyntaxKindObjectLiteralExpression && isBinaryExpression(container.parent.parent.parent) && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindPrototype {
			return (container.parent.parent.parent.left /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression
		} else if container.kind == SyntaxKindFunctionExpression && isPropertyAssignment(container.parent) && isIdentifier(container.parent.name) && (container.parent.name.escapedText == "value" || container.parent.name.escapedText == "get" || container.parent.name.escapedText == "set") && isObjectLiteralExpression(container.parent.parent) && isCallExpression(container.parent.parent.parent) && /* TODO(ElementAccessExpression): container.parent.parent.parent.arguments[2] */ TODO == container.parent.parent && getAssignmentDeclarationKind(container.parent.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return ( /* TODO(ElementAccessExpression): container.parent.parent.parent.arguments[0] */ TODO /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression
		} else if isMethodDeclaration(container) && isIdentifier(container.name) && (container.name.escapedText == "value" || container.name.escapedText == "get" || container.name.escapedText == "set") && isObjectLiteralExpression(container.parent) && isCallExpression(container.parent.parent) && /* TODO(ElementAccessExpression): container.parent.parent.arguments[2] */ TODO == container.parent && getAssignmentDeclarationKind(container.parent.parent) == AssignmentDeclarationKindObjectDefinePrototypeProperty {
			return ( /* TODO(ElementAccessExpression): container.parent.parent.arguments[0] */ TODO /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression
		}
	}
	getTypeForThisExpressionFromJSDoc := func(node SignatureDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		thisTag := getJSDocThisTag(node)
		if thisTag && thisTag.typeExpression {
			return getTypeFromTypeNode(thisTag.typeExpression)
		}
		signature := getSignatureOfTypeTag(node)
		if signature {
			return getThisTypeOfSignature(signature)
		}
	}
	isInConstructorArgumentInitializer := func(node Node, constructorDecl Node) bool {
		return !!findAncestor(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(CallExpression): isFunctionLikeDeclaration(n) */
			/* TODO(QuestionToken): ? */
			/* TODO(StringLiteral): "quit" */
			/* TODO(ColonToken): : */
			/* TODO(BinaryExpression): n.kind === SyntaxKind.Parameter && n.parent === constructorDecl */
		})
	}
	checkSuperExpression := func(node Node) Type {
		isCallExpression := node.parent.kind == SyntaxKindCallExpression && (node.parent /* as */ /* TODO(TypeReference): CallExpression */).expression == node
		immediateContainer := getSuperContainer(node, true)
		container := immediateContainer
		needToCaptureLexicalThis := false
		inAsyncFunction := false
		if !isCallExpression {
			/* TODO(WhileStatement): while (container && container.kind === SyntaxKind.ArrowFunction) {                 if (hasSyntacticModifier(container, ModifierFlags.Async)) inAsyncFunction = true;                 container = getSuperContainer(container, /*stopOnFunctions* / true);                 needToCaptureLexicalThis = languageVersion < ScriptTarget.ES2015;             } */
			if container && hasSyntacticModifier(container, ModifierFlagsAsync) {
				/* TODO(BinaryExpression): inAsyncFunction = true */
			}
		}
		var nodeCheckFlag NodeCheckFlags = 0
		if !container || !isLegalUsageOfSuperExpression(container) {
			current := findAncestor(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
				/* TODO(BinaryExpression): n === container */
				/* TODO(QuestionToken): ? */
				/* TODO(StringLiteral): "quit" */
				/* TODO(ColonToken): : */
				/* TODO(BinaryExpression): n.kind === SyntaxKind.ComputedPropertyName */
			})
			if current && current.kind == SyntaxKindComputedPropertyName {
				error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name)
			} else if isCallExpression {
				error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors)
			} else if !container || !container.parent || !(isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression) {
				error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions)
			} else {
				error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class)
			}
			return errorType
		}
		if !isCallExpression && /* TODO(NonNullExpression): immediateContainer! */ TODO.kind == SyntaxKindConstructor {
			checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class)
		}
		if isStatic(container) || isCallExpression {
			nodeCheckFlag = NodeCheckFlagsSuperStatic
			if !isCallExpression && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container)) {
				forEachEnclosingBlockScopeContainer(node.parent, func(current /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) {
					if !isSourceFile(current) || isExternalOrCommonJsModule(current) {
						getNodeLinks(current).flags |= NodeCheckFlagsContainsSuperPropertyInStaticInitializer
					}
				})
			}
		} else {
			nodeCheckFlag = NodeCheckFlagsSuperInstance
		}
		getNodeLinks(node).flags |= nodeCheckFlag
		if container.kind == SyntaxKindMethodDeclaration && inAsyncFunction {
			if isSuperProperty(node.parent) && isAssignmentTarget(node.parent) {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync
			} else {
				getNodeLinks(container).flags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync
			}
		}
		if needToCaptureLexicalThis {
			captureLexicalThis(node.parent, container)
		}
		if container.parent.kind == SyntaxKindObjectLiteralExpression {
			if languageVersion < ScriptTargetES2015 {
				error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher)
				return errorType
			} else {
				return anyType
			}
		}
		classLikeDeclaration := container.parent /* as */ /* TODO(TypeReference): ClassLikeDeclaration */
		if !getClassExtendsHeritageElement(classLikeDeclaration) {
			error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class)
			return errorType
		}
		if classDeclarationExtendsNull(classLikeDeclaration) {
			return /* TODO(ConditionalExpression): isCallExpression ? errorType : nullWideningType */ TODO
		}
		classType := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration)) /* as */ /* TODO(TypeReference): InterfaceType */
		baseClassType := classType && /* TODO(ElementAccessExpression): getBaseTypes(classType)[0] */ TODO
		if !baseClassType {
			return errorType
		}
		if container.kind == SyntaxKindConstructor && isInConstructorArgumentInitializer(node, container) {
			error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments)
			return errorType
		}
		return /* TODO(ConditionalExpression): nodeCheckFlag === NodeCheckFlags.SuperStatic             ? getBaseConstructorTypeOfClass(classType)             : getTypeWithThisArgument(baseClassType, classType.thisType) */ TODO
		isLegalUsageOfSuperExpression := func(container Node) bool {
			if isCallExpression {
				return container.kind == SyntaxKindConstructor
			} else {
				if isClassLike(container.parent) || container.parent.kind == SyntaxKindObjectLiteralExpression {
					if isStatic(container) {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindClassStaticBlockDeclaration
					} else {
						return container.kind == SyntaxKindMethodDeclaration || container.kind == SyntaxKindMethodSignature || container.kind == SyntaxKindGetAccessor || container.kind == SyntaxKindSetAccessor || container.kind == SyntaxKindPropertyDeclaration || container.kind == SyntaxKindPropertySignature || container.kind == SyntaxKindConstructor
					}
				}
			}
			return false
		}
	}
	getContainingObjectLiteral := func(func_ SignatureDeclaration) *ObjectLiteralExpression {
		return /* TODO(ConditionalExpression): (func.kind === SyntaxKind.MethodDeclaration ||                 func.kind === SyntaxKind.GetAccessor ||                 func.kind === SyntaxKind.SetAccessor) && func.parent.kind === SyntaxKind.ObjectLiteralExpression ? func.parent :             func.kind === SyntaxKind.FunctionExpression && func.parent.kind === SyntaxKind.PropertyAssignment ? func.parent.parent as ObjectLiteralExpression :             undefined */ TODO
	}
	getThisTypeArgument := func(type_ Type) *Type {
		return /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference && (type as TypeReference).target === globalThisType ? getTypeArguments(type as TypeReference)[0] : undefined */ TODO
	}
	getThisTypeFromContextualType := func(type_ Type) *Type {
		return mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ConditionalExpression): t.flags & TypeFlags.Intersection ? forEach((t as IntersectionType).types, getThisTypeArgument) : getThisTypeArgument(t) */ TODO
		})
	}
	getThisTypeOfObjectLiteralFromContextualType := func(containingLiteral ObjectLiteralExpression, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		literal := containingLiteral
		type_ := contextualType
		/* TODO(WhileStatement): while (type) {             const thisType = getThisTypeFromContextualType(type);             if (thisType) {                 return thisType;             }             if (literal.parent.kind !== SyntaxKind.PropertyAssignment) {                 break;             }             literal = literal.parent.parent as ObjectLiteralExpression;             type = getApparentTypeOfContextualType(literal, /*contextFlags* / undefined);         } */
	}
	getContextualThisParameterType := func(func_ SignatureDeclaration) *Type {
		if func_.kind == SyntaxKindArrowFunction {
			return nil
		}
		if isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			contextualSignature := getContextualSignature(func_)
			if contextualSignature {
				thisParameter := contextualSignature.thisParameter
				if thisParameter {
					return getTypeOfSymbol(thisParameter)
				}
			}
		}
		inJs := isInJSFile(func_)
		if noImplicitThis || inJs {
			containingLiteral := getContainingObjectLiteral(func_)
			if containingLiteral {
				contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
				thisType := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
				if thisType {
					return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)))
				}
				return getWidenedType( /* TODO(ConditionalExpression): contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral) */ TODO)
			}
			parent := walkUpParenthesizedExpressions(func_.parent)
			if isAssignmentExpression(parent) {
				target := parent.left
				if isAccessExpression(target) {
					TODO_IDENTIFIER := target
					if inJs && isIdentifier(expression) {
						sourceFile := getSourceFileOfNode(parent)
						if sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) == sourceFile.symbol {
							return nil
						}
					}
					return getWidenedType(checkExpressionCached(expression))
				}
			}
		}
		return nil
	}
	getContextuallyTypedParameterType := func(parameter ParameterDeclaration) *Type {
		func_ := parameter.parent
		if !isContextSensitiveFunctionOrObjectLiteralMethod(func_) {
			return nil
		}
		iife := getImmediatelyInvokedFunctionExpression(func_)
		if iife && iife.arguments {
			args := getEffectiveCallArguments(iife)
			indexOfParameter := func_.parameters.indexOf(parameter)
			if parameter.dotDotDotToken {
				return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, nil, CheckModeNormal)
			}
			links := getNodeLinks(iife)
			cached := links.resolvedSignature
			links.resolvedSignature = anySignature
			type_ := /* TODO(ConditionalExpression): indexOfParameter < args.length ?                 getWidenedLiteralType(checkExpression(args[indexOfParameter])) :                 parameter.initializer ? undefined : undefinedWideningType */ TODO
			links.resolvedSignature = cached
			return type_
		}
		contextualSignature := getContextualSignature(func_)
		if contextualSignature {
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): func.parameters.indexOf(parameter) - (getThisParameter(func) ? 1 : 0) */ TODO
			return /* TODO(ConditionalExpression): parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ?                 getRestTypeAtPosition(contextualSignature, index) :                 tryGetTypeAtPosition(contextualSignature, index) */ TODO
		}
	}
	getContextualTypeForVariableLikeDeclaration := func(declaration VariableLikeDeclaration, contextFlags *ContextFlags) *Type {
		typeNode := getEffectiveTypeAnnotationNode(declaration) || ( /* TODO(ConditionalExpression): isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : undefined */ TODO)
		if typeNode {
			return getTypeFromTypeNode(typeNode)
		}
		/* TODO(SwitchStatement): switch (declaration.kind) {             case SyntaxKind.Parameter:                 return getContextuallyTypedParameterType(declaration);             case SyntaxKind.BindingElement:                 return getContextualTypeForBindingElement(declaration, contextFlags);             case SyntaxKind.PropertyDeclaration:                 if (isStatic(declaration)) {                     return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags);                 }                 // By default, do nothing and return undefined - only the above cases have context implied by a parent         } */
	}
	getContextualTypeForBindingElement := func(declaration BindingElement, contextFlags *ContextFlags) *Type {
		parent := declaration.parent.parent
		name := declaration.propertyName || declaration.name
		parentType := getContextualTypeForVariableLikeDeclaration(parent, contextFlags) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): parent.kind !== SyntaxKind.BindingElement */ TODO && parent.initializer && checkDeclarationInitializer(parent /* TODO(ConditionalExpression): declaration.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */, TODO)
		if !parentType || isBindingPattern(name) || isComputedNonLiteralName(name) {
			/* TODO(Identifier): undefined */
		}
		if parent.name.kind == SyntaxKindArrayBindingPattern {
			index := indexOfNode(declaration.parent.elements, declaration)
			if index < 0 {
				/* TODO(Identifier): undefined */
			}
			return getContextualTypeForElementExpression(parentType, index)
		}
		nameType := getLiteralTypeFromPropertyName(name)
		if isTypeUsableAsPropertyName(nameType) {
			text := getPropertyNameFromType(nameType)
			return getTypeOfPropertyOfType(parentType, text)
		}
	}
	getContextualTypeForStaticPropertyDeclaration := func(declaration PropertyDeclaration, contextFlags *ContextFlags) *Type {
		parentType := isExpression(declaration.parent) && getContextualType(declaration.parent, contextFlags)
		if !parentType {
			/* TODO(Identifier): undefined */
		}
		return getTypeOfPropertyOfContextualType(parentType, getSymbolOfDeclaration(declaration).escapedName)
	}
	getContextualTypeForInitializerExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		declaration := node.parent /* as */ /* TODO(TypeReference): VariableLikeDeclaration */
		if hasInitializer(declaration) && node == declaration.initializer {
			result := getContextualTypeForVariableLikeDeclaration(declaration, contextFlags)
			if result {
				return result
			}
			if !( /* TODO(NonNullExpression): contextFlags! */ TODO & ContextFlagsSkipBindingPatterns) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0 {
				return getTypeFromBindingPattern(declaration.name, true, false)
			}
		}
		return nil
	}
	getContextualTypeForReturnExpression := func(node Expression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				functionFlags := getFunctionFlags(func_)
				if functionFlags & FunctionFlagsGenerator {
					isAsyncGenerator := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
					if contextualReturnType.flags & TypeFlagsUnion {
						contextualReturnType = filterType(contextualReturnType, func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
							/* TODO(PrefixUnaryExpression): !getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator) */
						})
					}
					iterationReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, contextualReturnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO)
					if !iterationReturnType {
						return nil
					}
					contextualReturnType = iterationReturnType
				}
				if functionFlags & FunctionFlagsAsync {
					contextualAwaitedType := mapType(contextualReturnType, getAwaitedTypeNoAlias)
					return contextualAwaitedType && getUnionType( /* TODO(ArrayLiteralExpression): [contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)] */ TODO)
				}
				return contextualReturnType
			}
		}
		return nil
	}
	getContextualTypeForAwaitOperand := func(node AwaitExpression, contextFlags *ContextFlags) *Type {
		contextualType := getContextualType(node, contextFlags)
		if contextualType {
			contextualAwaitedType := getAwaitedTypeNoAlias(contextualType)
			return contextualAwaitedType && getUnionType( /* TODO(ArrayLiteralExpression): [contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)] */ TODO)
		}
		return nil
	}
	getContextualTypeForYieldOperand := func(node YieldExpression, contextFlags *ContextFlags) *Type {
		func_ := getContainingFunction(node)
		if func_ {
			functionFlags := getFunctionFlags(func_)
			contextualReturnType := getContextualReturnType(func_, contextFlags)
			if contextualReturnType {
				isAsyncGenerator := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
				if !node.asteriskToken && contextualReturnType.flags&TypeFlagsUnion {
					contextualReturnType = filterType(contextualReturnType, func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(PrefixUnaryExpression): !getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKind.Return, type, isAsyncGenerator) */
					})
				}
				if node.asteriskToken {
					iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(contextualReturnType, isAsyncGenerator)
					yieldType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): iterationTypes?.yieldType ?? silentNeverType */ TODO
					returnType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getContextualType(node, contextFlags) ?? silentNeverType */ TODO
					nextType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): iterationTypes?.nextType ?? unknownType */ TODO
					generatorType := createGeneratorType(yieldType, returnType, nextType, false)
					if isAsyncGenerator {
						asyncGeneratorType := createGeneratorType(yieldType, returnType, nextType, true)
						return getUnionType( /* TODO(ArrayLiteralExpression): [generatorType, asyncGeneratorType] */ TODO)
					}
					return generatorType
				}
				return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, contextualReturnType, isAsyncGenerator)
			}
		}
		return nil
	}
	isInParameterInitializerBeforeContainingFunction := func(node Node) /* TODO(undefined): boolean */ TODO {
		inBindingInitializer := false
		/* TODO(WhileStatement): while (node.parent && !isFunctionLike(node.parent)) {             if (isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)) {                 return true;             }             if (isBindingElement(node.parent) && node.parent.initializer === node) {                 inBindingInitializer = true;             }              node = node.parent;         } */
		return false
	}
	getContextualIterationType := func(kind IterationTypeKind, functionDecl SignatureDeclaration) *Type {
		isAsync := !!(getFunctionFlags(functionDecl) & FunctionFlagsAsync)
		contextualReturnType := getContextualReturnType(functionDecl, nil)
		if contextualReturnType {
			return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || nil
		}
		return nil
	}
	getContextualReturnType := func(functionDecl SignatureDeclaration, contextFlags *ContextFlags) *Type {
		returnType := getReturnTypeFromAnnotation(functionDecl)
		if returnType {
			return returnType
		}
		signature := getContextualSignatureForFunctionLikeDeclaration(functionDecl /* as */ /* TODO(TypeReference): FunctionExpression */)
		if signature && !isResolvingReturnTypeOfSignature(signature) {
			returnType := getReturnTypeOfSignature(signature)
			functionFlags := getFunctionFlags(functionDecl)
			if functionFlags & FunctionFlagsGenerator {
				return filterType(returnType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || checkGeneratorInstantiationAssignabilityToReturnType(t, functionFlags, nil)
				})
			}
			if functionFlags & FunctionFlagsAsync {
				return filterType(returnType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					return !!(t.flags & (TypeFlagsAnyOrUnknown | TypeFlagsVoid | TypeFlagsInstantiableNonPrimitive)) || !!getAwaitedTypeOfPromise(t)
				})
			}
			return returnType
		}
		iife := getImmediatelyInvokedFunctionExpression(functionDecl)
		if iife {
			return getContextualType(iife, contextFlags)
		}
		return nil
	}
	getContextualTypeForArgument := func(callTarget CallLikeExpression, arg Expression) *Type {
		args := getEffectiveCallArguments(callTarget)
		argIndex := args.indexOf(arg)
		return /* TODO(ConditionalExpression): argIndex === -1 ? undefined : getContextualTypeForArgumentAtIndex(callTarget, argIndex) */ TODO
	}
	getContextualTypeForArgumentAtIndex := func(callTarget CallLikeExpression, argIndex number) Type {
		if isImportCall(callTarget) {
			return /* TODO(ConditionalExpression): argIndex === 0 ? stringType :                 argIndex === 1 ? getGlobalImportCallOptionsType(/*reportErrors* / false) :                 anyType */ TODO
		}
		signature := /* TODO(ConditionalExpression): getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget) */ TODO
		if isJsxOpeningLikeElement(callTarget) && argIndex == 0 {
			return getEffectiveFirstArgumentForJsxSignature(signature, callTarget)
		}
		restIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - 1 */ TODO
		return /* TODO(ConditionalExpression): signatureHasRestParameter(signature) && argIndex >= restIndex ?             getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), AccessFlags.Contextual) :             getTypeAtPosition(signature, argIndex) */ TODO
	}
	getContextualTypeForDecorator := func(decorator Decorator) *Type {
		signature := getDecoratorCallSignature(decorator)
		return /* TODO(ConditionalExpression): signature ? getOrCreateTypeFromSignature(signature) : undefined */ TODO
	}
	getContextualTypeForSubstitutionExpression := func(template TemplateExpression, substitutionExpression Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if template.parent.kind == SyntaxKindTaggedTemplateExpression {
			return getContextualTypeForArgument(template.parent /* as */ /* TODO(TypeReference): TaggedTemplateExpression */, substitutionExpression)
		}
		return nil
	}
	getContextualTypeForBinaryOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		binaryExpression := node.parent /* as */ /* TODO(TypeReference): BinaryExpression */
		TODO_IDENTIFIER := binaryExpression
		/* TODO(SwitchStatement): switch (operatorToken.kind) {             case SyntaxKind.EqualsToken:             case SyntaxKind.AmpersandAmpersandEqualsToken:             case SyntaxKind.BarBarEqualsToken:             case SyntaxKind.QuestionQuestionEqualsToken:                 return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : undefined;             case SyntaxKind.BarBarToken:             case SyntaxKind.QuestionQuestionToken:                 // When an || expression has a contextual type, the operands are contextually typed by that type, except                 // when that type originates in a binding pattern, the right operand is contextually typed by the type of                 // the left operand. When an || expression has no contextual type, the right operand is contextually typed                 // by the type of the left operand, except for the special case of Javascript declarations of the form                 // `namespace.prop = namespace.prop || {}`.                 const type = getContextualType(binaryExpression, contextFlags);                 return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ?                     getTypeOfExpression(left) : type;             case SyntaxKind.AmpersandAmpersandToken:             case SyntaxKind.CommaToken:                 return node === right ? getContextualType(binaryExpression, contextFlags) : undefined;             default:                 return undefined;         } */
	}
	getSymbolForExpression := func(e Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		if canHaveSymbol(e) && e.symbol {
			return e.symbol
		}
		if isIdentifier(e) {
			return getResolvedSymbol(e)
		}
		if isPropertyAccessExpression(e) {
			lhsType := getTypeOfExpression(e.expression)
			return /* TODO(ConditionalExpression): isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText) */ TODO
		}
		if isElementAccessExpression(e) {
			propType := checkExpressionCached(e.argumentExpression)
			if !isTypeUsableAsPropertyName(propType) {
				return nil
			}
			lhsType := getTypeOfExpression(e.expression)
			return getPropertyOfType(lhsType, getPropertyNameFromType(propType))
		}
		return nil
		tryGetPrivateIdentifierPropertyOfType := func(type_ Type, id PrivateIdentifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id)
			return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type_, lexicallyScopedSymbol)
		}
	}
	getContextualTypeForAssignmentDeclaration := func(binaryExpression BinaryExpression) *Type {
		kind := getAssignmentDeclarationKind(binaryExpression)
		/* TODO(SwitchStatement): switch (kind) {             case AssignmentDeclarationKind.None:             case AssignmentDeclarationKind.ThisProperty:                 const lhsSymbol = getSymbolForExpression(binaryExpression.left);                 const decl = lhsSymbol && lhsSymbol.valueDeclaration;                 // Unannotated, uninitialized property declarations have a type implied by their usage in the constructor.                 // We avoid calling back into `getTypeOfExpression` and reentering contextual typing to avoid a bogus circularity error in that case.                 if (decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))) {                     const overallAnnotation = getEffectiveTypeAnnotationNode(decl);                     return (overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper)) ||                         (isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : undefined);                 }                 if (kind === AssignmentDeclarationKind.None) {                     return getTypeOfExpression(binaryExpression.left);                 }                 return getContextualTypeForThisPropertyAssignment(binaryExpression);             case AssignmentDeclarationKind.Property:                 if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {                     return getContextualTypeForThisPropertyAssignment(binaryExpression);                 }                 // If `binaryExpression.left` was assigned a symbol, then this is a new declaration; otherwise it is an assignment to an existing declaration.                 // See `bindStaticPropertyAssignment` in `binder.ts`.                 else if (!canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol) {                     return getTypeOfExpression(binaryExpression.left);                 }                 else {                     const decl = binaryExpression.left.symbol.valueDeclaration;                     if (!decl) {                         return undefined;                     }                     const lhs = cast(binaryExpression.left, isAccessExpression);                     const overallAnnotation = getEffectiveTypeAnnotationNode(decl);                     if (overallAnnotation) {                         return getTypeFromTypeNode(overallAnnotation);                     }                     else if (isIdentifier(lhs.expression)) {                         const id = lhs.expression;                         const parentSymbol = resolveName(id, id.escapedText, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / true);                         if (parentSymbol) {                             const annotated = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);                             if (annotated) {                                 const nameStr = getElementOrPropertyAccessName(lhs);                                 if (nameStr !== undefined) {                                     return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated), nameStr);                                 }                             }                             return undefined;                         }                     }                     return isInJSFile(decl) || decl === binaryExpression.left ? undefined : getTypeOfExpression(binaryExpression.left);                 }             case AssignmentDeclarationKind.ExportsProperty:             case AssignmentDeclarationKind.Prototype:             case AssignmentDeclarationKind.PrototypeProperty:             case AssignmentDeclarationKind.ModuleExports:                 let valueDeclaration: Declaration | undefined;                 if (kind !== AssignmentDeclarationKind.ModuleExports) {                     valueDeclaration = canHaveSymbol(binaryExpression.left) ? binaryExpression.left.symbol?.valueDeclaration : undefined;                 }                 valueDeclaration ||= binaryExpression.symbol?.valueDeclaration;                 const annotated = valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration);                 return annotated ? getTypeFromTypeNode(annotated) : undefined;             case AssignmentDeclarationKind.ObjectDefinePropertyValue:             case AssignmentDeclarationKind.ObjectDefinePropertyExports:             case AssignmentDeclarationKind.ObjectDefinePrototypeProperty:                 return Debug.fail("Does not apply");             default:                 return Debug.assertNever(kind);         } */
	}
	isPossiblyAliasedThisProperty := func(declaration BinaryExpression, kind /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").AssignmentDeclarationKind */ TODO /* = */ /* TODO(CallExpression): getAssignmentDeclarationKind(declaration) */) /* TODO(undefined): boolean */ TODO {
		if kind == AssignmentDeclarationKindThisProperty {
			return true
		}
		if !isInJSFile(declaration) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): kind !== AssignmentDeclarationKind.Property */ TODO || !isIdentifier((declaration.left /* as */ /* TODO(TypeReference): AccessExpression */).expression) {
			return false
		}
		name := ((declaration.left /* as */ /* TODO(TypeReference): AccessExpression */).expression /* as */ /* TODO(TypeReference): Identifier */).escapedText
		symbol := resolveName(declaration.left, name, SymbolFlagsValue, nil, true, true)
		return isThisInitializedDeclaration(symbol.valueDeclaration)
	}
	getContextualTypeForThisPropertyAssignment := func(binaryExpression BinaryExpression) *Type {
		if !binaryExpression.symbol {
			/* TODO(CallExpression): getTypeOfExpression(binaryExpression.left) */
		}
		if binaryExpression.symbol.valueDeclaration {
			annotated := getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration)
			if annotated {
				type_ := getTypeFromTypeNode(annotated)
				if type_ {
					return type_
				}
			}
		}
		thisAccess := cast(binaryExpression.left, isAccessExpression)
		if !isObjectLiteralMethod(getThisContainer(thisAccess.expression, false, false)) {
			return nil
		}
		thisType := checkThisExpression(thisAccess.expression)
		nameStr := getElementOrPropertyAccessName(thisAccess)
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nameStr !== undefined */ TODO && getTypeOfPropertyOfContextualType(thisType, nameStr) || nil
	}
	isCircularMappedProperty := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		return !!(getCheckFlags(symbol)&CheckFlagsMapped && !(symbol /* as */ /* TODO(TypeReference): MappedSymbol */).links.type_ && findResolutionCycleStartIndex(symbol, TypeSystemPropertyNameType) >= 0)
	}
	isExcludedMappedPropertyName := func(constraint Type, propertyNameType Type) bool {
		if constraint.flags & TypeFlagsConditional {
			type_ := constraint /* as */ /* TODO(TypeReference): ConditionalType */
			return !!(getReducedType(getTrueTypeFromConditionalType(type_)).flags & TypeFlagsNever) && getActualTypeVariable(getFalseTypeFromConditionalType(type_)) == getActualTypeVariable(type_.checkType) && isTypeAssignableTo(propertyNameType, type_.extendsType)
		}
		if constraint.flags & TypeFlagsIntersection {
			return some((constraint /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): isExcludedMappedPropertyName */
				/* TODO(Identifier): t */
				/* TODO(Identifier): propertyNameType */
			})
		}
		return false
	}
	getTypeOfPropertyOfContextualType := func(type_ Type, name __String, nameType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			if t.flags & TypeFlagsIntersection {
				var types /* TODO(ArrayType): Type[] */ any
				var indexInfoCandidates /* TODO(ArrayType): Type[] */ any
				ignoreIndexInfos := false
				for _, constituentType := range (t /* as */ /* TODO(TypeReference): IntersectionType */).types {
					if !(constituentType.flags & TypeFlagsObject) {
						/* TODO(ContinueStatement): continue; */
					}
					if isGenericMappedType(constituentType) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getMappedTypeNameTypeKind(constituentType) !== MappedTypeNameTypeKind.Remapping */ TODO {
						substitutedType := getIndexedMappedTypeSubstitutedTypeOfContextualType(constituentType, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, substitutedType)
						/* TODO(ContinueStatement): continue; */
					}
					propertyType := getTypeOfConcretePropertyOfContextualType(constituentType, name)
					if !propertyType {
						if !ignoreIndexInfos {
							indexInfoCandidates = append(indexInfoCandidates, constituentType)
						}
						/* TODO(ContinueStatement): continue; */
					}
					ignoreIndexInfos = true
					indexInfoCandidates = nil
					types = appendContextualPropertyTypeConstituent(types, propertyType)
				}
				if indexInfoCandidates {
					for _, candidate := range indexInfoCandidates {
						indexInfoType := getTypeFromIndexInfosOfContextualType(candidate, name, nameType)
						types = appendContextualPropertyTypeConstituent(types, indexInfoType)
					}
				}
				if !types {
					return
				}
				if types.length == 1 {
					return /* TODO(ElementAccessExpression): types[0] */ TODO
				}
				return getIntersectionType(types)
			}
			if !(t.flags & TypeFlagsObject) {
				return
			}
			return /* TODO(ConditionalExpression): isGenericMappedType(t) && getMappedTypeNameTypeKind(t) !== MappedTypeNameTypeKind.Remapping                 ? getIndexedMappedTypeSubstitutedTypeOfContextualType(t, name, nameType)                 : getTypeOfConcretePropertyOfContextualType(t, name) ?? getTypeFromIndexInfosOfContextualType(t, name, nameType) */ TODO
		}, true)
	}
	appendContextualPropertyTypeConstituent := func(types /* TODO(ArrayType): Type[] */ any, type_ *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] | undefined */ TODO {
		return /* TODO(ConditionalExpression): type ? append(types, type.flags & TypeFlags.Any ? unknownType : type) : types */ TODO
	}
	getIndexedMappedTypeSubstitutedTypeOfContextualType := func(type_ MappedType, name __String, nameType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		propertyNameType := nameType || getStringLiteralType(unescapeLeadingUnderscores(name))
		constraint := getConstraintTypeFromMappedType(type_)
		if type_.nameType && isExcludedMappedPropertyName(type_.nameType, propertyNameType) || isExcludedMappedPropertyName(constraint, propertyNameType) {
			return
		}
		constraintOfConstraint := getBaseConstraintOfType(constraint) || constraint
		if !isTypeAssignableTo(propertyNameType, constraintOfConstraint) {
			return
		}
		return substituteIndexedMappedType(type_, propertyNameType)
	}
	getTypeOfConcretePropertyOfContextualType := func(type_ Type, name __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		prop := getPropertyOfType(type_, name)
		if !prop || isCircularMappedProperty(prop) {
			return
		}
		return removeMissingType(getTypeOfSymbol(prop), !!(prop.flags & SymbolFlagsOptional))
	}
	getTypeFromIndexInfosOfContextualType := func(type_ Type, name __String, nameType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isTupleType(type_) && isNumericLiteralName(name) && +name >= 0 {
			restType := getElementTypeOfSliceOfTupleType(type_, type_.target.fixedLength, 0, false, true)
			if restType {
				return restType
			}
		}
		return findApplicableIndexInfo(getIndexInfosOfStructuredType(type_), nameType || getStringLiteralType(unescapeLeadingUnderscores(name))).type_
	}
	getContextualTypeForObjectLiteralMethod := func(node MethodDeclaration, contextFlags *ContextFlags) *Type {
		Debug.assert(isObjectLiteralMethod(node))
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		return getContextualTypeForObjectLiteralElement(node, contextFlags)
	}
	getContextualTypeForObjectLiteralElement := func(element ObjectLiteralElementLike, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		objectLiteral := element.parent /* as */ /* TODO(TypeReference): ObjectLiteralExpression */
		propertyAssignmentType := isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags)
		if propertyAssignmentType {
			return propertyAssignmentType
		}
		type_ := getApparentTypeOfContextualType(objectLiteral, contextFlags)
		if type_ {
			if hasBindableName(element) {
				symbol := getSymbolOfDeclaration(element)
				return getTypeOfPropertyOfContextualType(type_, symbol.escapedName, getSymbolLinks(symbol).nameType)
			}
			if hasDynamicName(element) {
				name := getNameOfDeclaration(element)
				if name && isComputedPropertyName(name) {
					exprType := checkExpression(name.expression)
					propType := isTypeUsableAsPropertyName(exprType) && getTypeOfPropertyOfContextualType(type_, getPropertyNameFromType(exprType))
					if propType {
						return propType
					}
				}
			}
			if element.name {
				nameType := getLiteralTypeFromPropertyName(element.name)
				return mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
					/* TODO(CallExpression): findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType) */
					/* TODO(QuestionDotToken): ?. */
					/* TODO(Identifier): type */
				}, true)
			}
		}
		return nil
	}
	getSpreadIndices := func(elements []Node) /* TODO(undefined): { first: number | undefined; last: number | undefined; } */ TODO {
		var first TODO
		var last TODO
		/* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             if (isSpreadElement(elements[i])) {                 first ??= i;                 last = i;             }         } */
		return /* TODO(ObjectLiteralExpression): { first, last } */ TODO
	}
	getContextualTypeForElementExpression := func(type_ *Type, index number, length number, firstSpreadIndex number, lastSpreadIndex number) *Type {
		return type_ && mapType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			if isTupleType(t) {
				if (firstSpreadIndex == nil || index < firstSpreadIndex) && index < t.target.fixedLength {
					return removeMissingType( /* TODO(ElementAccessExpression): getTypeArguments(t)[index] */ TODO, !!( /* TODO(ElementAccessExpression): t.target.elementFlags[index] */ TODO && ElementFlagsOptional))
				}
				offset := /* TODO(ConditionalExpression): length !== undefined && (lastSpreadIndex === undefined || index > lastSpreadIndex) ? length - index : 0 */ TODO
				fixedEndLength := /* TODO(ConditionalExpression): offset > 0 && (t.target.combinedFlags & ElementFlags.Variable) ? getEndElementCount(t.target, ElementFlags.Fixed) : 0 */ TODO
				if offset > 0 && offset <= fixedEndLength {
					return /* TODO(ElementAccessExpression): getTypeArguments(t)[getTypeReferenceArity(t) - offset] */ TODO
				}
				return getElementTypeOfSliceOfTupleType(t /* TODO(ConditionalExpression): firstSpreadIndex === undefined ? t.target.fixedLength : Math.min(t.target.fixedLength, firstSpreadIndex) */, TODO /* TODO(ConditionalExpression): length === undefined || lastSpreadIndex === undefined ? fixedEndLength : Math.min(fixedEndLength, length - lastSpreadIndex) */, TODO, false, true)
			}
			return (!firstSpreadIndex || index < firstSpreadIndex) && getTypeOfPropertyOfContextualType(t /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "" + index */, TODO /* as */ /* TODO(TypeReference): __String */) || getIteratedTypeOrElementType(IterationUseElement, t, undefinedType, nil, false)
		}, true)
	}
	getContextualTypeForConditionalOperand := func(node Expression, contextFlags *ContextFlags) *Type {
		conditional := node.parent /* as */ /* TODO(TypeReference): ConditionalExpression */
		return /* TODO(ConditionalExpression): node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional, contextFlags) : undefined */ TODO
	}
	getContextualTypeForChildJsxExpression := func(node JsxElement, child JsxChild, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		attributesType := getApparentTypeOfContextualType(node.openingElement.attributes, contextFlags)
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		if !(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): jsxChildrenPropertyName !== "" */ TODO) {
			return nil
		}
		realChildren := getSemanticJsxChildren(node.children)
		childIndex := realChildren.indexOf(child)
		childFieldType := getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName)
		return childFieldType && ( /* TODO(ConditionalExpression): realChildren.length === 1 ? childFieldType : mapType(childFieldType, t => {             if (isArrayLikeType(t)) {                 return getIndexedAccessType(t, getNumberLiteralType(childIndex));             }             else {                 return t;             }         }, /*noReductions* / true) */ TODO)
	}
	getContextualTypeForJsxExpression := func(node JsxExpression, contextFlags *ContextFlags) *Type {
		exprParent := node.parent
		return /* TODO(ConditionalExpression): isJsxAttributeLike(exprParent)             ? getContextualType(node, contextFlags)             : isJsxElement(exprParent)             ? getContextualTypeForChildJsxExpression(exprParent, node, contextFlags)             : undefined */ TODO
	}
	getContextualTypeForJsxAttribute := func(attribute /* TODO(UnionType): JsxAttribute | JsxSpreadAttribute */ any, contextFlags *ContextFlags) *Type {
		if isJsxAttribute(attribute) {
			attributesType := getApparentTypeOfContextualType(attribute.parent, contextFlags)
			if !attributesType || isTypeAny(attributesType) {
				return nil
			}
			return getTypeOfPropertyOfContextualType(attributesType, getEscapedTextOfJsxAttributeName(attribute.name))
		} else {
			return getContextualType(attribute.parent, contextFlags)
		}
	}
	isPossiblyDiscriminantValue := func(node Expression) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.StringLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.TemplateExpression:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.NullKeyword:             case SyntaxKind.Identifier:             case SyntaxKind.UndefinedKeyword:                 return true;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ParenthesizedExpression:                 return isPossiblyDiscriminantValue((node as PropertyAccessExpression | ParenthesizedExpression).expression);             case SyntaxKind.JsxExpression:                 return !(node as JsxExpression).expression || isPossiblyDiscriminantValue((node as JsxExpression).expression!);         } */
		return false
	}
	discriminateContextualTypeByObjectMembers := func(node ObjectLiteralExpression, contextualType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getCachedType(key) ?? setCachedType(             key,             getMatchingUnionConstituentForObjectLiteral(contextualType, node) ?? discriminateTypeByDiscriminableItems(                 contextualType,                 concatenate(                     map(                         filter(node.properties, (p): p is PropertyAssignment | ShorthandPropertyAssignment => {                             if (!p.symbol) {                                 return false;                             }                             if (p.kind === SyntaxKind.PropertyAssignment) {                                 return isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             if (p.kind === SyntaxKind.ShorthandPropertyAssignment) {                                 return isDiscriminantProperty(contextualType, p.symbol.escapedName);                             }                             return false;                         }),                         prop => ([() => getContextFreeTypeOfExpression(prop.kind === SyntaxKind.PropertyAssignment ? prop.initializer : prop.name), prop.symbol.escapedName] as const),                     ),                     map(                         filter(getPropertiesOfType(contextualType), s => !!(s.flags & SymbolFlags.Optional) && !!node?.symbol?.members && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)),                         s => [() => undefinedType, s.escapedName] as const,                     ),                 ),                 isTypeAssignableTo,             ),         ) */ TODO
	}
	discriminateContextualTypeByJSXAttributes := func(node JsxAttributes, contextualType UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `D${getNodeId(node)},${getTypeId(contextualType)}` */ TODO
		cached := getCachedType(key)
		if cached {
			/* TODO(Identifier): cached */
		}
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(node))
		return setCachedType(key, discriminateTypeByDiscriminableItems(contextualType, concatenate(map_(filter(node.properties, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttribute | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSpreadAttribute */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): !!p.symbol && p.kind === SyntaxKind.JsxAttribute && isDiscriminantProperty(contextualType, p.symbol.escapedName) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(ParenthesizedExpression): (!p.initializer || isPossiblyDiscriminantValue(p.initializer)) */
		}), func(prop /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JsxAttribute | import("/home/jabaile/work/TypeScript/src/compiler/types").JsxSpreadAttribute */ TODO) /* TODO(undefined): readonly [() => import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ TODO {
			/* TODO(AsExpression): [!(prop as JsxAttribute).initializer ? (() => trueType) : (() => getContextFreeTypeOfExpression((prop as JsxAttribute).initializer!)), prop.symbol.escapedName] as const */
		}), map_(filter(getPropertiesOfType(contextualType), func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			if !(s.flags & SymbolFlagsOptional) || !node.symbol.members {
				return false
			}
			element := node.parent.parent
			if s.escapedName == jsxChildrenPropertyName && isJsxElement(element) && getSemanticJsxChildren(element.children).length {
				return false
			}
			return !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName)
		}), func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): readonly [() => import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ TODO {
			/* TODO(ArrayLiteralExpression): [() => undefinedType, s.escapedName] */
			/* TODO(TypeReference): const */
		})), isTypeAssignableTo))
	}
	getApparentTypeOfContextualType := func(node /* TODO(UnionType): Expression | MethodDeclaration */ any, contextFlags *ContextFlags) *Type {
		contextualType := /* TODO(ConditionalExpression): isObjectLiteralMethod(node) ?             getContextualTypeForObjectLiteralMethod(node, contextFlags) :             getContextualType(node, contextFlags) */ TODO
		instantiatedType := instantiateContextualType(contextualType, node, contextFlags)
		if instantiatedType && !(contextFlags && contextFlags&ContextFlagsNoConstraints && instantiatedType.flags&TypeFlagsTypeVariable) {
			apparentType := mapType(instantiatedType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(BinaryExpression): getObjectFlags(t) & ObjectFlags.Mapped */
				/* TODO(QuestionToken): ? */
				/* TODO(Identifier): t */
				/* TODO(ColonToken): : */
				/* TODO(CallExpression): getApparentType(t) */
			}, true)
			return /* TODO(ConditionalExpression): apparentType.flags & TypeFlags.Union && isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType as UnionType) :                 apparentType.flags & TypeFlags.Union && isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType as UnionType) :                 apparentType */ TODO
		}
	}
	instantiateContextualType := func(contextualType *Type, node Node, contextFlags *ContextFlags) *Type {
		if contextualType && maybeTypeOfKind(contextualType, TypeFlagsInstantiable) {
			inferenceContext := getInferenceContext(node)
			if inferenceContext && /* TODO(NonNullExpression): contextFlags! */ TODO&ContextFlagsSignature && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault) {
				return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper)
			}
			if inferenceContext.returnMapper {
				type_ := instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper)
				return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union && containsType((type as UnionType).types, regularFalseType) && containsType((type as UnionType).types, regularTrueType) ?                     filterType(type, t => t !== regularFalseType && t !== regularTrueType) :                     type */ TODO
			}
		}
		return contextualType
	}
	instantiateInstantiableTypes := func(type_ Type, mapper TypeMapper) Type {
		if type_.flags & TypeFlagsInstantiable {
			return instantiateType(type_, mapper)
		}
		if type_.flags & TypeFlagsUnion {
			return getUnionType(map_((type_ /* as */ /* TODO(TypeReference): UnionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): instantiateInstantiableTypes */
				/* TODO(Identifier): t */
				/* TODO(Identifier): mapper */
			}), UnionReductionNone)
		}
		if type_.flags & TypeFlagsIntersection {
			return getIntersectionType(map_((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(Identifier): instantiateInstantiableTypes */
				/* TODO(Identifier): t */
				/* TODO(Identifier): mapper */
			}))
		}
		return type_
	}
	getContextualType := func(node Expression, contextFlags *ContextFlags) *Type {
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		index := findContextualNode(node, !contextFlags)
		if index >= 0 {
			return /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
		}
		TODO_IDENTIFIER := node
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.VariableDeclaration:             case SyntaxKind.Parameter:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:             case SyntaxKind.BindingElement:                 return getContextualTypeForInitializerExpression(node, contextFlags);             case SyntaxKind.ArrowFunction:             case SyntaxKind.ReturnStatement:                 return getContextualTypeForReturnExpression(node, contextFlags);             case SyntaxKind.YieldExpression:                 return getContextualTypeForYieldOperand(parent as YieldExpression, contextFlags);             case SyntaxKind.AwaitExpression:                 return getContextualTypeForAwaitOperand(parent as AwaitExpression, contextFlags);             case SyntaxKind.CallExpression:             case SyntaxKind.NewExpression:                 return getContextualTypeForArgument(parent as CallExpression | NewExpression | Decorator, node);             case SyntaxKind.Decorator:                 return getContextualTypeForDecorator(parent as Decorator);             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:                 return isConstTypeReference((parent as AssertionExpression).type) ? getContextualType(parent as AssertionExpression, contextFlags) : getTypeFromTypeNode((parent as AssertionExpression).type);             case SyntaxKind.BinaryExpression:                 return getContextualTypeForBinaryOperand(node, contextFlags);             case SyntaxKind.PropertyAssignment:             case SyntaxKind.ShorthandPropertyAssignment:                 return getContextualTypeForObjectLiteralElement(parent as PropertyAssignment | ShorthandPropertyAssignment, contextFlags);             case SyntaxKind.SpreadAssignment:                 return getContextualType(parent.parent as ObjectLiteralExpression, contextFlags);             case SyntaxKind.ArrayLiteralExpression: {                 const arrayLiteral = parent as ArrayLiteralExpression;                 const type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);                 const elementIndex = indexOfNode(arrayLiteral.elements, node);                 const spreadIndices = getNodeLinks(arrayLiteral).spreadIndices ??= getSpreadIndices(arrayLiteral.elements);                 return getContextualTypeForElementExpression(type, elementIndex, arrayLiteral.elements.length, spreadIndices.first, spreadIndices.last);             }             case SyntaxKind.ConditionalExpression:                 return getContextualTypeForConditionalOperand(node, contextFlags);             case SyntaxKind.TemplateSpan:                 Debug.assert(parent.parent.kind === SyntaxKind.TemplateExpression);                 return getContextualTypeForSubstitutionExpression(parent.parent as TemplateExpression, node);             case SyntaxKind.ParenthesizedExpression: {                 if (isInJSFile(parent)) {                     if (isJSDocSatisfiesExpression(parent)) {                         return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent));                     }                     // Like in `checkParenthesizedExpression`, an `/** @type {xyz} * /` comment before a parenthesized expression acts as a type cast.                     const typeTag = getJSDocTypeTag(parent);                     if (typeTag && !isConstTypeReference(typeTag.typeExpression.type)) {                         return getTypeFromTypeNode(typeTag.typeExpression.type);                     }                 }                 return getContextualType(parent as ParenthesizedExpression, contextFlags);             }             case SyntaxKind.NonNullExpression:                 return getContextualType(parent as NonNullExpression, contextFlags);             case SyntaxKind.SatisfiesExpression:                 return getTypeFromTypeNode((parent as SatisfiesExpression).type);             case SyntaxKind.ExportAssignment:                 return tryGetTypeFromEffectiveTypeNode(parent as ExportAssignment);             case SyntaxKind.JsxExpression:                 return getContextualTypeForJsxExpression(parent as JsxExpression, contextFlags);             case SyntaxKind.JsxAttribute:             case SyntaxKind.JsxSpreadAttribute:                 return getContextualTypeForJsxAttribute(parent as JsxAttribute | JsxSpreadAttribute, contextFlags);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return getContextualJsxElementAttributesType(parent as JsxOpeningLikeElement, contextFlags);             case SyntaxKind.ImportAttribute:                 return getContextualImportAttributeType(parent as ImportAttribute);         } */
		return nil
	}
	pushCachedContextualType := func(node Expression) {
		pushContextualType(node, getContextualType(node, nil), true)
	}
	pushContextualType := func(node Expression, type_ *Type, isCache bool) {
		/* TODO(ElementAccessExpression): contextualTypeNodes[contextualTypeCount] */ TODO = node
		/* TODO(ElementAccessExpression): contextualTypes[contextualTypeCount] */ TODO = type_
		/* TODO(ElementAccessExpression): contextualIsCache[contextualTypeCount] */ TODO = isCache
		contextualTypeCount++
	}
	popContextualType := func() {
		contextualTypeCount--
	}
	findContextualNode := func(node Node, includeCaches bool) /* TODO(undefined): number */ TODO {
		/* TODO(ForStatement): for (let i = contextualTypeCount - 1; i >= 0; i--) {             if (node === contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i])) {                 return i;             }         } */
		return -1
	}
	pushInferenceContext := func(node Node, inferenceContext *InferenceContext) {
		/* TODO(ElementAccessExpression): inferenceContextNodes[inferenceContextCount] */ TODO = node
		/* TODO(ElementAccessExpression): inferenceContexts[inferenceContextCount] */ TODO = inferenceContext
		inferenceContextCount++
	}
	popInferenceContext := func() {
		inferenceContextCount--
	}
	getInferenceContext := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ TODO {
		/* TODO(ForStatement): for (let i = inferenceContextCount - 1; i >= 0; i--) {             if (isNodeDescendantOf(node, inferenceContextNodes[i])) {                 return inferenceContexts[i];             }         } */
	}
	getContextualImportAttributeType := func(node ImportAttribute) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		return getTypeOfPropertyOfContextualType(getGlobalImportAttributesType(false), getNameFromImportAttribute(node))
	}
	getContextualJsxElementAttributesType := func(node JsxOpeningLikeElement, contextFlags *ContextFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if isJsxOpeningElement(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): contextFlags !== ContextFlags.Completions */ TODO {
			index := findContextualNode(node.parent, !contextFlags)
			if index >= 0 {
				return /* TODO(ElementAccessExpression): contextualTypes[index] */ TODO
			}
		}
		return getContextualTypeForArgumentAtIndex(node, 0)
	}
	getEffectiveFirstArgumentForJsxSignature := func(signature Signature, node JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): getJsxReferenceKind(node) !== JsxReferenceKind.Component             ? getJsxPropsTypeFromCallSignature(signature, node)             : getJsxPropsTypeFromClassType(signature, node) */ TODO
	}
	getJsxPropsTypeFromCallSignature := func(sig Signature, context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		propsType := getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)
		propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType)
		intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
		if !isErrorType(intrinsicAttribs) {
			propsType = intersectTypes(intrinsicAttribs, propsType)
		}
		return propsType
	}
	getJsxPropsTypeForSignatureFromMember := func(sig Signature, forcedLookupLocation __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if sig.compositeSignatures {
			var results []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, signature := range sig.compositeSignatures {
				instance := getReturnTypeOfSignature(signature)
				if isTypeAny(instance) {
					return instance
				}
				propType := getTypeOfPropertyOfType(instance, forcedLookupLocation)
				if !propType {
					return
				}
				results.push(propType)
			}
			return getIntersectionType(results)
		}
		instanceType := getReturnTypeOfSignature(sig)
		return /* TODO(ConditionalExpression): isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation) */ TODO
	}
	getStaticTypeOfReferencedJsxConstructor := func(context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if isJsxIntrinsicTagName(context.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context)
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		tagType := checkExpressionCached(context.tagName)
		if tagType.flags & TypeFlagsStringLiteral {
			result := getIntrinsicAttributesTypeFromStringLiteralType(tagType /* as */ /* TODO(TypeReference): StringLiteralType */, context)
			if !result {
				return errorType
			}
			fakeSignature := createSignatureForJSXIntrinsic(context, result)
			return getOrCreateTypeFromSignature(fakeSignature)
		}
		return tagType
	}
	getJsxManagedAttributesFromLocatedAttributes := func(context JsxOpeningLikeElement, ns Symbol, attributesType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		managedSym := getJsxLibraryManagedAttributes(ns)
		if managedSym {
			ctorType := getStaticTypeOfReferencedJsxConstructor(context)
			result := instantiateAliasOrInterfaceWithDefaults(managedSym, isInJSFile(context), ctorType, attributesType)
			if result {
				return result
			}
		}
		return attributesType
	}
	getJsxPropsTypeFromClassType := func(sig Signature, context JsxOpeningLikeElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		ns := getJsxNamespaceAt(context)
		forcedLookupLocation := getJsxElementPropertiesName(ns)
		attributesType := /* TODO(ConditionalExpression): forcedLookupLocation === undefined             // If there is no type ElementAttributesProperty, return the type of the first parameter of the signature, which should be the props type             ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType)             : forcedLookupLocation === ""             // If there is no e.g. 'props' member in ElementAttributesProperty, use the element class type instead             ? getReturnTypeOfSignature(sig)             // Otherwise get the type of the property on the signature return type             : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) */ TODO
		if !attributesType {
			if !!forcedLookupLocation && !!length(context.attributes.properties) {
				error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation))
			}
			return unknownType
		}
		attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType)
		if isTypeAny(attributesType) {
			return attributesType
		} else {
			apparentAttributesType := attributesType
			intrinsicClassAttribs := getJsxType(JsxNames.IntrinsicClassAttributes, context)
			if !isErrorType(intrinsicClassAttribs) {
				typeParams := getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol)
				hostClassType := getReturnTypeOfSignature(sig)
				var libraryManagedAttributeType Type
				if typeParams {
					inferredArgs := fillMissingTypeArguments( /* TODO(ArrayLiteralExpression): [hostClassType] */ TODO, typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context))
					libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs))
				} else {
					/* TODO(BinaryExpression): libraryManagedAttributeType = intrinsicClassAttribs */
				}
				apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType)
			}
			intrinsicAttribs := getJsxType(JsxNames.IntrinsicAttributes, context)
			if !isErrorType(intrinsicAttribs) {
				apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType)
			}
			return apparentAttributesType
		}
	}
	getIntersectedSignatures := func(signatures []Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		return /* TODO(ConditionalExpression): getStrictOptionValue(compilerOptions, "noImplicitAny")             ? reduceLeft(                 signatures,                 (left: Signature | undefined, right) =>                     left === right || !left ? left                         : compareTypeParametersIdentical(left.typeParameters, right!.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right!)                         : undefined,             )             : undefined */ TODO
	}
	combineIntersectionThisParam := func(left *Symbol, right *Symbol, mapper *TypeMapper) *Symbol {
		if !left || !right {
			return left || right
		}
		thisType := getUnionType( /* TODO(ArrayLiteralExpression): [getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)] */ TODO)
		return createSymbolWithType(left, thisType)
	}
	combineIntersectionParameters := func(left Signature, right Signature, mapper *TypeMapper) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		leftCount := getParameterCount(left)
		rightCount := getParameterCount(right)
		longest := /* TODO(ConditionalExpression): leftCount >= rightCount ? left : right */ TODO
		shorter := /* TODO(ConditionalExpression): longest === left ? right : left */ TODO
		longestCount := /* TODO(ConditionalExpression): longest === left ? leftCount : rightCount */ TODO
		eitherHasEffectiveRest := hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right)
		needsExtraRestElement := eitherHasEffectiveRest && !hasEffectiveRestParameter(longest)
		params := /* TODO(NewExpression): new Array<Symbol>(longestCount + (needsExtraRestElement ? 1 : 0)) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < longestCount; i++) {             let longestParamType = tryGetTypeAtPosition(longest, i)!;             if (longest === right) {                 longestParamType = instantiateType(longestParamType, mapper);             }             let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;             if (shorter === right) {                 shorterParamType = instantiateType(shorterParamType, mapper);             }             const unionParamType = getUnionType([longestParamType, shorterParamType]);             const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === (longestCount - 1);             const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);             const leftName = i >= leftCount ? undefined : getParameterNameAtPosition(left, i);             const rightName = i >= rightCount ? undefined : getParameterNameAtPosition(right, i);              const paramName = leftName === rightName ? leftName :                 !leftName ? rightName :                 !rightName ? leftName :                 undefined;             const paramSymbol = createSymbol(                 SymbolFlags.FunctionScopedVariable | (isOptional && !isRestParam ? SymbolFlags.Optional : 0),                 paramName || `arg${i}` as __String,             );             paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;             params[i] = paramSymbol;         } */
		if needsExtraRestElement {
			restParamSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "args" /* as */ /* TODO(TypeReference): __String */)
			restParamSymbol.links.type_ = createArrayType(getTypeAtPosition(shorter, longestCount))
			if shorter == right {
				restParamSymbol.links.type_ = instantiateType(restParamSymbol.links.type_, mapper)
			}
			/* TODO(ElementAccessExpression): params[longestCount] */ TODO = restParamSymbol
		}
		return params
	}
	combineSignaturesOfIntersectionMembers := func(left Signature, right Signature) Signature {
		typeParams := left.typeParameters || right.typeParameters
		var paramMapper *TypeMapper
		if left.typeParameters && right.typeParameters {
			paramMapper = createTypeMapper(right.typeParameters, left.typeParameters)
		}
		declaration := left.declaration
		params := combineIntersectionParameters(left, right, paramMapper)
		thisParam := combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper)
		minArgCount := Math.max(left.minArgumentCount, right.minArgumentCount)
		result := createSignature(declaration, typeParams, thisParam, params, nil, nil, minArgCount, (left.flags|right.flags)&SignatureFlagsPropagatingFlags)
		result.compositeKind = TypeFlagsIntersection
		result.compositeSignatures = concatenate(left.compositeKind == TypeFlagsIntersection && left.compositeSignatures || /* TODO(ArrayLiteralExpression): [left] */ TODO /* TODO(ArrayLiteralExpression): [right] */, TODO)
		if paramMapper {
			result.mapper = /* TODO(ConditionalExpression): left.compositeKind === TypeFlags.Intersection && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper */ TODO
		}
		return result
	}
	getContextualCallSignature := func(type_ Type, node SignatureDeclaration) *Signature {
		signatures := getSignaturesOfType(type_, SignatureKindCall)
		applicableByArity := filter(signatures, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): isAritySmaller(s, node) */
		})
		return /* TODO(ConditionalExpression): applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity) */ TODO
	}
	isAritySmaller := func(signature Signature, target SignatureDeclaration) /* TODO(undefined): boolean */ TODO {
		targetParameterCount := 0
		/* TODO(ForStatement): for (; targetParameterCount < target.parameters.length; targetParameterCount++) {             const param = target.parameters[targetParameterCount];             if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {                 break;             }         } */
		if target.parameters.length && parameterIsThisKeyword( /* TODO(ElementAccessExpression): target.parameters[0] */ TODO) {
			targetParameterCount--
		}
		return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount
	}
	getContextualSignatureForFunctionLikeDeclaration := func(node FunctionLikeDeclaration) *Signature {
		return /* TODO(ConditionalExpression): isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node)             ? getContextualSignature(node as FunctionExpression)             : undefined */ TODO
	}
	getContextualSignature := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any) *Signature {
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		typeTagSignature := getSignatureOfTypeTag(node)
		if typeTagSignature {
			return typeTagSignature
		}
		type_ := getApparentTypeOfContextualType(node, ContextFlagsSignature)
		if !type_ {
			return nil
		}
		if !(type_.flags & TypeFlagsUnion) {
			return getContextualCallSignature(type_, node)
		}
		var signatureList /* TODO(ArrayType): Signature[] */ any
		types := (type_ /* as */ /* TODO(TypeReference): UnionType */).types
		for _, current := range types {
			signature := getContextualCallSignature(current, node)
			if signature {
				if !signatureList {
					signatureList = /* TODO(ArrayLiteralExpression): [signature] */ TODO
				} else if !compareSignaturesIdentical( /* TODO(ElementAccessExpression): signatureList[0] */ TODO, signature, false, true, true, compareTypesIdentical) {
					return nil
				} else {
					signatureList.push(signature)
				}
			}
		}
		if signatureList {
			return /* TODO(ConditionalExpression): signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList) */ TODO
		}
	}
	checkGrammarRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO(undefined): boolean */ TODO {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) && !node.isUnterminated {
			var lastError *DiagnosticWithLocation
			/* TODO(ExpressionStatement): scanner ??= createScanner(ScriptTarget.ESNext, /*skipTrivia* / true); */
			scanner.setScriptTarget(sourceFile.languageVersion)
			scanner.setLanguageVariant(sourceFile.languageVariant)
			scanner.setOnError(func(message /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO, length /* TODO(undefined): number */ TODO, arg0 /* TODO(undefined): any */ TODO) {
				start := /* TODO(NonNullExpression): scanner! */ TODO.getTokenEnd()
				if message.category == DiagnosticCategoryMessage && lastError && start == lastError.start && length == lastError.length {
					error := createDetachedDiagnostic(sourceFile.fileName, sourceFile.text, start, length, message, arg0)
					addRelatedInfo(lastError, error)
				} else if !lastError || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): start !== lastError.start */ TODO {
					lastError = createFileDiagnostic(sourceFile, start, length, message, arg0)
					diagnostics.add(lastError)
				}
			})
			scanner.setText(sourceFile.text, node.pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.end - node.pos */, TODO)
			/* TODO(TryStatement): try {                 scanner.scan();                 Debug.assert(scanner.reScanSlashToken(/*reportErrors* / true) === SyntaxKind.RegularExpressionLiteral, "Expected scanner to rescan RegularExpressionLiteral");                 return !!lastError;             }             finally {                 scanner.setText("");                 scanner.setOnError(/*onError* / undefined);             } */
		}
		return false
	}
	checkRegularExpressionLiteral := func(node RegularExpressionLiteral) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsTypeChecked) {
			nodeLinks.flags |= NodeCheckFlagsTypeChecked
			addLazyDiagnostic(func() /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): checkGrammarRegularExpressionLiteral */
				/* TODO(Identifier): node */
			})
		}
		return globalRegExpType
	}
	checkSpreadExpression := func(node SpreadElement, checkMode CheckMode) Type {
		if languageVersion < LanguageFeatureMinimumTargetSpreadElements {
			checkExternalEmitHelpers(node /* TODO(ConditionalExpression): compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray */, TODO)
		}
		arrayOrIterableType := checkExpression(node.expression, checkMode)
		return checkIteratedTypeOrElementType(IterationUseSpread, arrayOrIterableType, undefinedType, node.expression)
	}
	checkSyntheticExpression := func(node SyntheticExpression) Type {
		return /* TODO(ConditionalExpression): node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type */ TODO
	}
	hasDefaultValue := func(node /* TODO(UnionType): BindingElement | ObjectLiteralElementLike | Expression */ any) bool {
		return node.kind == SyntaxKindBindingElement && !!(node /* as */ /* TODO(TypeReference): BindingElement */).initializer || node.kind == SyntaxKindPropertyAssignment && hasDefaultValue((node /* as */ /* TODO(TypeReference): PropertyAssignment */).initializer) || node.kind == SyntaxKindShorthandPropertyAssignment && !!(node /* as */ /* TODO(TypeReference): ShorthandPropertyAssignment */).objectAssignmentInitializer || node.kind == SyntaxKindBinaryExpression && (node /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken
	}
	isSpreadIntoCallOrNew := func(node ArrayLiteralExpression) /* TODO(undefined): boolean */ TODO {
		parent := walkUpParenthesizedExpressions(node.parent)
		return isSpreadElement(parent) && isCallOrNewExpression(parent.parent)
	}
	checkArrayLiteral := func(node ArrayLiteralExpression, checkMode *CheckMode, forceTuple /* TODO(BooleanKeyword): boolean */ any) Type {
		elements := node.elements
		elementCount := elements.length
		var elementTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var elementFlags []ElementFlags = /* TODO(ArrayLiteralExpression): [] */ TODO
		pushCachedContextualType(node)
		inDestructuringPattern := isAssignmentTarget(node)
		inConstContext := isConstContext(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		inTupleContext := isSpreadIntoCallOrNew(node) || !!contextualType && someType(contextualType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): isTupleLikeType(t) */
			/* TODO(BarBarToken): || */
			/* TODO(BinaryExpression): isGenericMappedType(t) && !t.nameType && !!getHomomorphicTypeVariable(t.target as MappedType || t) */
		})
		hasOmittedExpression := false
		/* TODO(ForStatement): for (let i = 0; i < elementCount; i++) {             const e = elements[i];             if (e.kind === SyntaxKind.SpreadElement) {                 if (languageVersion < LanguageFeatureMinimumTarget.SpreadElements) {                     checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? ExternalEmitHelpers.SpreadIncludes : ExternalEmitHelpers.SpreadArray);                 }                 const spreadType = checkExpression((e as SpreadElement).expression, checkMode, forceTuple);                 if (isArrayLikeType(spreadType)) {                     elementTypes.push(spreadType);                     elementFlags.push(ElementFlags.Variadic);                 }                 else if (inDestructuringPattern) {                     // Given the following situation:                     //    var c: {};                     //    [...c] = ["", 0];                     //                     // c is represented in the tree as a spread element in an array literal.                     // But c really functions as a rest element, and its purpose is to provide                     // a contextual type for the right hand side of the assignment. Therefore,                     // instead of calling checkExpression on "...c", which will give an error                     // if c is not iterable/array-like, we need to act as if we are trying to                     // get the contextual element type from it. So we do something similar to                     // getContextualTypeForElementExpression, which will crucially not error                     // if there is no index type / iterated type.                     const restElementType = getIndexTypeOfType(spreadType, numberType) ||                         getIteratedTypeOrElementType(IterationUse.Destructuring, spreadType, undefinedType, /*errorNode* / undefined, /*checkAssignability* / false) ||                         unknownType;                     elementTypes.push(restElementType);                     elementFlags.push(ElementFlags.Rest);                 }                 else {                     elementTypes.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, (e as SpreadElement).expression));                     elementFlags.push(ElementFlags.Rest);                 }             }             else if (exactOptionalPropertyTypes && e.kind === SyntaxKind.OmittedExpression) {                 hasOmittedExpression = true;                 elementTypes.push(undefinedOrMissingType);                 elementFlags.push(ElementFlags.Optional);             }             else {                 const type = checkExpressionForMutableLocation(e, checkMode, forceTuple);                 elementTypes.push(addOptionality(type, /*isProperty* / true, hasOmittedExpression));                 elementFlags.push(hasOmittedExpression ? ElementFlags.Optional : ElementFlags.Required);                 if (inTupleContext && checkMode && checkMode & CheckMode.Inferential && !(checkMode & CheckMode.SkipContextSensitive) && isContextSensitive(e)) {                     const inferenceContext = getInferenceContext(node);                     Debug.assert(inferenceContext); // In CheckMode.Inferential we should always have an inference context                     addIntraExpressionInferenceSite(inferenceContext, e, type);                 }             }         } */
		popContextualType()
		if inDestructuringPattern {
			return createTupleType(elementTypes, elementFlags)
		}
		if forceTuple || inConstContext || inTupleContext {
			return createArrayLiteralType(createTupleType(elementTypes, elementFlags, inConstContext && !(contextualType && someType(contextualType, isMutableArrayLikeType))))
		}
		return createArrayLiteralType(createArrayType( /* TODO(ConditionalExpression): elementTypes.length ?                 getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & ElementFlags.Variadic ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), UnionReduction.Subtype) :                 strictNullChecks ? implicitNeverType : undefinedWideningType */ TODO, inConstContext))
	}
	createArrayLiteralType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !(getObjectFlags(type_) & ObjectFlagsReference) {
			return type_
		}
		literalType := (type_ /* as */ /* TODO(TypeReference): TypeReference */).literalType
		if !literalType {
			literalType = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as TypeReference).literalType = cloneTypeReference(type as TypeReference) */ TODO
			literalType.objectFlags |= ObjectFlagsArrayLiteral | ObjectFlagsContainsObjectOrArrayLiteral
		}
		return literalType
	}
	isNumericName := func(name DeclarationName) bool {
		/* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.ComputedPropertyName:                 return isNumericComputedName(name);             case SyntaxKind.Identifier:                 return isNumericLiteralName(name.escapedText);             case SyntaxKind.NumericLiteral:             case SyntaxKind.StringLiteral:                 return isNumericLiteralName(name.text);             default:                 return false;         } */
	}
	isNumericComputedName := func(name ComputedPropertyName) bool {
		return isTypeAssignableToKind(checkComputedPropertyName(name), TypeFlagsNumberLike)
	}
	checkComputedPropertyName := func(node ComputedPropertyName) Type {
		links := getNodeLinks(node.expression)
		if !links.resolvedType {
			if (isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent)) && isBinaryExpression(node.expression) && node.expression.operatorToken.kind == SyntaxKindInKeyword && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.GetAccessor */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SetAccessor */ TODO {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedType = errorType */ TODO
			}
			links.resolvedType = checkExpression(node.expression)
			if isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent) {
				container := getEnclosingBlockScopeContainer(node.parent.parent)
				enclosingIterationStatement := getEnclosingIterationStatement(container)
				if enclosingIterationStatement {
					getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					getNodeLinks(node).flags |= NodeCheckFlagsBlockScopedBindingInLoop
					getNodeLinks(node.parent.parent).flags |= NodeCheckFlagsBlockScopedBindingInLoop
				}
			}
			if links.resolvedType.flags&TypeFlagsNullable || !isTypeAssignableToKind(links.resolvedType, TypeFlagsStringLike|TypeFlagsNumberLike|TypeFlagsESSymbolLike) && !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType) {
				error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any)
			}
		}
		return links.resolvedType
	}
	isSymbolWithNumericName := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
		return isNumericLiteralName(symbol.escapedName) || (firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name))
	}
	isSymbolWithSymbolName := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		firstDecl := /* TODO(ElementAccessExpression): symbol.declarations?.[0] */ TODO
		return isKnownSymbol(symbol) || (firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) && isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), TypeFlagsESSymbol))
	}
	getObjectLiteralIndexInfo := func(node ObjectLiteralExpression, offset number, properties []Symbol, keyType Type) IndexInfo {
		var propTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = offset; i < properties.length; i++) {             const prop = properties[i];             if (                 keyType === stringType && !isSymbolWithSymbolName(prop) ||                 keyType === numberType && isSymbolWithNumericName(prop) ||                 keyType === esSymbolType && isSymbolWithSymbolName(prop)             ) {                 propTypes.push(getTypeOfSymbol(properties[i]));             }         } */
		unionType := /* TODO(ConditionalExpression): propTypes.length ? getUnionType(propTypes, UnionReduction.Subtype) : undefinedType */ TODO
		return createIndexInfo(keyType, unionType, isConstContext(node))
	}
	getImmediateAliasedSymbol := func(symbol Symbol) *Symbol {
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.Alias) !== 0 */ TODO, "Should only get Alias here.")
		links := getSymbolLinks(symbol)
		if !links.immediateTarget {
			node := getDeclarationOfAliasSymbol(symbol)
			if !node {
				/* TODO(CallExpression): Debug.fail() */
			}
			links.immediateTarget = getTargetOfAliasDeclaration(node, true)
		}
		return links.immediateTarget
	}
	checkObjectLiteral := func(node ObjectLiteralExpression, checkMode CheckMode /* = */ /* TODO(PropertyAccessExpression): CheckMode.Normal */) Type {
		inDestructuringPattern := isAssignmentTarget(node)
		checkGrammarObjectLiteralExpression(node, inDestructuringPattern)
		allPropertiesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		propertiesTable := createSymbolTable()
		var propertiesArray []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		var spread Type = emptyObjectType
		pushCachedContextualType(node)
		contextualType := getApparentTypeOfContextualType(node, nil)
		contextualTypeHasPattern := contextualType && contextualType.pattern && (contextualType.pattern.kind == SyntaxKindObjectBindingPattern || contextualType.pattern.kind == SyntaxKindObjectLiteralExpression)
		inConstContext := isConstContext(node)
		checkFlags := /* TODO(ConditionalExpression): inConstContext ? CheckFlags.Readonly : 0 */ TODO
		isInJavascript := isInJSFile(node) && !isInJsonFile(node)
		enumTag := /* TODO(ConditionalExpression): isInJavascript ? getJSDocEnumTag(node) : undefined */ TODO
		isJSObjectLiteral := !contextualType && isInJavascript && !enumTag
		var objectFlags ObjectFlags = ObjectFlagsFreshLiteral
		patternWithComputedProperties := false
		hasComputedStringProperty := false
		hasComputedNumberProperty := false
		hasComputedSymbolProperty := false
		for _, elem := range node.properties {
			if elem.name && isComputedPropertyName(elem.name) {
				checkComputedPropertyName(elem.name)
			}
		}
		offset := 0
		for _, memberDecl := range node.properties {
			member := getSymbolOfDeclaration(memberDecl)
			computedNameType := /* TODO(ConditionalExpression): memberDecl.name && memberDecl.name.kind === SyntaxKind.ComputedPropertyName ?                 checkComputedPropertyName(memberDecl.name) : undefined */ TODO
			if memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindShorthandPropertyAssignment || isObjectLiteralMethod(memberDecl) {
				type_ := /* TODO(ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? checkPropertyAssignment(memberDecl, checkMode) :                     // avoid resolving the left side of the ShorthandPropertyAssignment outside of the destructuring                     // for error recovery purposes. For example, if a user wrote `{ a = 100 }` instead of `{ a: 100 }`.                     // we don't want to say "could not find 'a'".                     memberDecl.kind === SyntaxKind.ShorthandPropertyAssignment ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) :                     checkObjectLiteralMethod(memberDecl, checkMode) */ TODO
				if isInJavascript {
					jsDocType := getTypeForDeclarationFromJSDocComment(memberDecl)
					if jsDocType {
						checkTypeAssignableTo(type_, jsDocType, memberDecl)
						type_ = jsDocType
					} else if enumTag && enumTag.typeExpression {
						checkTypeAssignableTo(type_, getTypeFromTypeNode(enumTag.typeExpression), memberDecl)
					}
				}
				objectFlags |= getObjectFlags(type_) & ObjectFlagsPropagatingFlags
				nameType := /* TODO(ConditionalExpression): computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : undefined */ TODO
				prop := /* TODO(ConditionalExpression): nameType ?                     createSymbol(SymbolFlags.Property | member.flags, getPropertyNameFromType(nameType), checkFlags | CheckFlags.Late) :                     createSymbol(SymbolFlags.Property | member.flags, member.escapedName, checkFlags) */ TODO
				if nameType {
					prop.links.nameType = nameType
				}
				if inDestructuringPattern && hasDefaultValue(memberDecl) {
					prop.flags |= SymbolFlagsOptional
				} else if contextualTypeHasPattern && !(getObjectFlags(contextualType) & ObjectFlagsObjectLiteralPatternWithComputedProperties) {
					impliedProp := getPropertyOfType(contextualType, member.escapedName)
					if impliedProp {
						prop.flags |= impliedProp.flags & SymbolFlagsOptional
					} else if !getIndexInfoOfType(contextualType, stringType) {
						error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType))
					}
				}
				prop.declarations = member.declarations
				prop.parent = member.parent
				if member.valueDeclaration {
					prop.valueDeclaration = member.valueDeclaration
				}
				prop.links.type_ = type_
				prop.links.target = member
				member = prop
				allPropertiesTable.set(prop.escapedName, prop)
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && (memberDecl.kind == SyntaxKindPropertyAssignment || memberDecl.kind == SyntaxKindMethodDeclaration) && isContextSensitive(memberDecl) {
					inferenceContext := getInferenceContext(node)
					Debug.assert(inferenceContext)
					inferenceNode := /* TODO(ConditionalExpression): memberDecl.kind === SyntaxKind.PropertyAssignment ? memberDecl.initializer : memberDecl */ TODO
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type_)
				}
			} else if memberDecl.kind == SyntaxKindSpreadAssignment {
				if languageVersion < LanguageFeatureMinimumTargetObjectAssign {
					checkExternalEmitHelpers(memberDecl, ExternalEmitHelpersAssign)
				}
				if propertiesArray.length > 0 {
					spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
					propertiesArray = /* TODO(ArrayLiteralExpression): [] */ TODO
					propertiesTable = createSymbolTable()
					hasComputedStringProperty = false
					hasComputedNumberProperty = false
					hasComputedSymbolProperty = false
				}
				type_ := getReducedType(checkExpression(memberDecl.expression, checkMode&CheckModeInferential))
				if isValidSpreadType(type_) {
					mergedType := tryMergeUnionOfObjectTypeAndEmptyObject(type_, inConstContext)
					if allPropertiesTable {
						checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl)
					}
					offset = propertiesArray.length
					if isErrorType(spread) {
						/* TODO(ContinueStatement): continue; */
					}
					spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext)
				} else {
					error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					spread = errorType
				}
				/* TODO(ContinueStatement): continue; */
			} else {
				Debug.assert(memberDecl.kind == SyntaxKindGetAccessor || memberDecl.kind == SyntaxKindSetAccessor)
				checkNodeDeferred(memberDecl)
			}
			if computedNameType && !(computedNameType.flags & TypeFlagsStringOrNumberLiteralOrUnique) {
				if isTypeAssignableTo(computedNameType, stringNumberSymbolType) {
					if isTypeAssignableTo(computedNameType, numberType) {
						hasComputedNumberProperty = true
					} else if isTypeAssignableTo(computedNameType, esSymbolType) {
						hasComputedSymbolProperty = true
					} else {
						hasComputedStringProperty = true
					}
					if inDestructuringPattern {
						patternWithComputedProperties = true
					}
				}
			} else {
				propertiesTable.set(member.escapedName, member)
			}
			propertiesArray.push(member)
		}
		popContextualType()
		if isErrorType(spread) {
			return errorType
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): spread !== emptyObjectType */ TODO {
			if propertiesArray.length > 0 {
				spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext)
				propertiesArray = /* TODO(ArrayLiteralExpression): [] */ TODO
				propertiesTable = createSymbolTable()
				hasComputedStringProperty = false
				hasComputedNumberProperty = false
			}
			return mapType(spread, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
				/* TODO(BinaryExpression): t === emptyObjectType */
				/* TODO(QuestionToken): ? */
				/* TODO(CallExpression): createObjectLiteralType() */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): t */
			})
		}
		return createObjectLiteralType()
		createObjectLiteralType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			indexInfos := /* TODO(ArrayLiteralExpression): [] */ TODO
			if hasComputedStringProperty {
				/* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType)) */
			}
			if hasComputedNumberProperty {
				/* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType)) */
			}
			if hasComputedSymbolProperty {
				/* TODO(CallExpression): indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType)) */
			}
			result := createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			if isJSObjectLiteral {
				result.objectFlags |= ObjectFlagsJSLiteral
			}
			if patternWithComputedProperties {
				result.objectFlags |= ObjectFlagsObjectLiteralPatternWithComputedProperties
			}
			if inDestructuringPattern {
				result.pattern = node
			}
			return result
		}
	}
	isValidSpreadType := func(type_ Type) bool {
		t := removeDefinitelyFalsyTypes(mapType(type_, getBaseConstraintOrType))
		return !!(t.flags&(TypeFlagsAny|TypeFlagsNonPrimitive|TypeFlagsObject|TypeFlagsInstantiableNonPrimitive) || t.flags&TypeFlagsUnionOrIntersection && every((t /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types, isValidSpreadType))
	}
	checkJsxSelfClosingElementDeferred := func(node JsxSelfClosingElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node)
	}
	checkJsxSelfClosingElement := func(node JsxSelfClosingElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxElementDeferred := func(node JsxElement) {
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement)
		if isJsxIntrinsicTagName(node.closingElement.tagName) {
			getIntrinsicTagSymbol(node.closingElement)
		} else {
			checkExpression(node.closingElement.tagName)
		}
		checkJsxChildren(node)
	}
	checkJsxElement := func(node JsxElement, _checkMode *CheckMode) Type {
		checkNodeDeferred(node)
		return getJsxElementTypeAt(node) || anyType
	}
	checkJsxFragment := func(node JsxFragment) Type {
		checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment)
		nodeSourceFile := getSourceFileOfNode(node)
		if getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx")) && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag") {
			error(node /* TODO(ConditionalExpression): compilerOptions.jsxFactory                     ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option                     : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments */, TODO)
		}
		checkJsxChildren(node)
		return getJsxElementTypeAt(node) || anyType
	}
	isHyphenatedJsxName := func(name /* TODO(UnionType): string | __String */ any) /* TODO(undefined): boolean */ TODO {
		return (name /* as */ /* TODO(StringKeyword): string */).includes("-")
	}
	isJsxIntrinsicTagName := func(tagName Node) /* TODO(TypePredicate): tagName is Identifier | JsxNamespacedName */ TODO {
		return isIdentifier(tagName) && isIntrinsicJsxName(tagName.escapedText) || isJsxNamespacedName(tagName)
	}
	checkJsxAttribute := func(node JsxAttribute, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.initializer             ? checkExpressionForMutableLocation(node.initializer, checkMode)             : trueType */ TODO
	}
	createJsxAttributesTypeFromAttributesProperty := func(openingLikeElement JsxOpeningLikeElement, checkMode CheckMode /* = */ /* TODO(PropertyAccessExpression): CheckMode.Normal */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		attributes := openingLikeElement.attributes
		contextualType := getContextualType(attributes, ContextFlagsNone)
		allAttributesTable := /* TODO(ConditionalExpression): strictNullChecks ? createSymbolTable() : undefined */ TODO
		attributesTable := createSymbolTable()
		var spread Type = emptyJsxObjectType
		hasSpreadAnyType := false
		var typeToIntersect *Type
		explicitlySpecifyChildrenAttribute := false
		var objectFlags ObjectFlags = ObjectFlagsJsxAttributes
		jsxChildrenPropertyName := getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement))
		for _, attributeDecl := range attributes.properties {
			member := attributeDecl.symbol
			if isJsxAttribute(attributeDecl) {
				exprType := checkJsxAttribute(attributeDecl, checkMode)
				objectFlags |= getObjectFlags(exprType) & ObjectFlagsPropagatingFlags
				attributeSymbol := createSymbol(SymbolFlagsProperty|member.flags, member.escapedName)
				attributeSymbol.declarations = member.declarations
				attributeSymbol.parent = member.parent
				if member.valueDeclaration {
					attributeSymbol.valueDeclaration = member.valueDeclaration
				}
				attributeSymbol.links.type_ = exprType
				attributeSymbol.links.target = member
				attributesTable.set(attributeSymbol.escapedName, attributeSymbol)
				allAttributesTable.set(attributeSymbol.escapedName, attributeSymbol)
				if getEscapedTextOfJsxAttributeName(attributeDecl.name) == jsxChildrenPropertyName {
					explicitlySpecifyChildrenAttribute = true
				}
				if contextualType {
					prop := getPropertyOfType(contextualType, member.escapedName)
					if prop && prop.declarations && isDeprecatedSymbol(prop) && isIdentifier(attributeDecl.name) {
						addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText /* as */ /* TODO(StringKeyword): string */)
					}
				}
				if contextualType && checkMode&CheckModeInferential && !(checkMode & CheckModeSkipContextSensitive) && isContextSensitive(attributeDecl) {
					inferenceContext := getInferenceContext(attributes)
					Debug.assert(inferenceContext)
					inferenceNode := /* TODO(NonNullExpression): (attributeDecl.initializer as JsxExpression).expression! */ TODO
					addIntraExpressionInferenceSite(inferenceContext, inferenceNode, exprType)
				}
			} else {
				Debug.assert(attributeDecl.kind == SyntaxKindJsxSpreadAttribute)
				if attributesTable.size > 0 {
					spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false)
					attributesTable = createSymbolTable()
				}
				exprType := getReducedType(checkExpression(attributeDecl.expression, checkMode&CheckModeInferential))
				if isTypeAny(exprType) {
					hasSpreadAnyType = true
				}
				if isValidSpreadType(exprType) {
					spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, false)
					if allAttributesTable {
						checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl)
					}
				} else {
					error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types)
					typeToIntersect = /* TODO(ConditionalExpression): typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType */ TODO
				}
			}
		}
		if !hasSpreadAnyType {
			if attributesTable.size > 0 {
				spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false)
			}
		}
		parent := /* TODO(ConditionalExpression): openingLikeElement.parent.kind === SyntaxKind.JsxElement ? openingLikeElement.parent as JsxElement : undefined */ TODO
		if parent && parent.openingElement == openingLikeElement && getSemanticJsxChildren(parent.children).length > 0 {
			var childrenTypes []Type = checkJsxChildren(parent, checkMode)
			if !hasSpreadAnyType && jsxChildrenPropertyName && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): jsxChildrenPropertyName !== "" */ TODO {
				if explicitlySpecifyChildrenAttribute {
					error(attributes, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName))
				}
				contextualType := getApparentTypeOfContextualType(openingLikeElement.attributes, nil)
				childrenContextualType := contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName)
				childrenPropSymbol := createSymbol(SymbolFlagsProperty, jsxChildrenPropertyName)
				childrenPropSymbol.links.type_ = /* TODO(ConditionalExpression): childrenTypes.length === 1 ? childrenTypes[0] :                     childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) :                     createArrayType(getUnionType(childrenTypes)) */ TODO
				childrenPropSymbol.valueDeclaration = factory.createPropertySignature(nil, unescapeLeadingUnderscores(jsxChildrenPropertyName), nil, nil)
				setParent(childrenPropSymbol.valueDeclaration, attributes)
				childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol
				childPropMap := createSymbolTable()
				childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol)
				spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags, false)
			}
		}
		if hasSpreadAnyType {
			return anyType
		}
		if typeToIntersect && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): spread !== emptyJsxObjectType */ TODO {
			return getIntersectionType( /* TODO(ArrayLiteralExpression): [typeToIntersect, spread] */ TODO)
		}
		return typeToIntersect || ( /* TODO(ConditionalExpression): spread === emptyJsxObjectType ? createJsxAttributesType() : spread */ TODO)
		createJsxAttributesType := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
			objectFlags |= ObjectFlagsFreshLiteral
			result := createAnonymousType(attributes.symbol, attributesTable, emptyArray, emptyArray, emptyArray)
			result.objectFlags |= objectFlags | ObjectFlagsObjectLiteral | ObjectFlagsContainsObjectOrArrayLiteral
			return result
		}
	}
	checkJsxChildren := func(node /* TODO(UnionType): JsxElement | JsxFragment */ any, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type[] */ TODO {
		var childrenTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, child := range node.children {
			if child.kind == SyntaxKindJsxText {
				if !child.containsOnlyTriviaWhiteSpaces {
					childrenTypes.push(stringType)
				}
			} else if child.kind == SyntaxKindJsxExpression && !child.expression {
				/* TODO(ContinueStatement): continue; */
			} else {
				childrenTypes.push(checkExpressionForMutableLocation(child, checkMode))
			}
		}
		return childrenTypes
	}
	checkSpreadPropOverrides := func(type_ Type, props SymbolTable, spread /* TODO(UnionType): SpreadAssignment | JsxSpreadAttribute */ any) {
		for _, right := range getPropertiesOfType(type_) {
			if !(right.flags & SymbolFlagsOptional) {
				left := props.get(right.escapedName)
				if left {
					diagnostic := error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName))
					addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property))
				}
			}
		}
	}
	checkJsxAttributes := func(node JsxAttributes, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode)
	}
	getJsxType := func(name __String, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		namespace := getJsxNamespaceAt(location)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, name, SymbolFlagsType)
		return /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */ TODO
	}
	getIntrinsicTagSymbol := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxClosingElement */ any) Symbol {
		links := getNodeLinks(node)
		if !links.resolvedSymbol {
			intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, node)
			if !isErrorType(intrinsicElementsType) {
				if !isIdentifier(node.tagName) && !isJsxNamespacedName(node.tagName) {
					/* TODO(CallExpression): Debug.fail() */
				}
				propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				intrinsicProp := getPropertyOfType(intrinsicElementsType, propName)
				if intrinsicProp {
					links.jsxFlags |= JsxFlagsIntrinsicNamedElement
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicProp */ TODO
				}
				indexSymbol := getApplicableIndexSymbol(intrinsicElementsType, getStringLiteralType(unescapeLeadingUnderscores(propName)))
				if indexSymbol {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = indexSymbol */ TODO
				}
				if getTypeOfPropertyOrIndexSignatureOfType(intrinsicElementsType, propName) {
					links.jsxFlags |= JsxFlagsIntrinsicIndexedElement
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = intrinsicElementsType.symbol */ TODO
				}
				error(node, Diagnostics.Property_0_does_not_exist_on_type_1, intrinsicTagNameToString(node.tagName) /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "JSX." + JsxNames.IntrinsicElements */, TODO)
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
			} else {
				if noImplicitAny {
					error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements))
				}
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedSymbol = unknownSymbol */ TODO
			}
		}
		return links.resolvedSymbol
	}
	getJsxNamespaceContainerForImplicitImport := func(location Node) *Symbol {
		file := location && getSourceFileOfNode(location)
		links := file && getNodeLinks(file)
		if links && links.jsxImplicitImportContainer == false {
			return nil
		}
		if links && links.jsxImplicitImportContainer {
			return links.jsxImplicitImportContainer
		}
		runtimeImportSpecifier := getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions)
		if !runtimeImportSpecifier {
			return nil
		}
		isClassic := getEmitModuleResolutionKind(compilerOptions) == ModuleResolutionKindClassic
		errorMessage := /* TODO(ConditionalExpression): isClassic             ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option             : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations */ TODO
		specifier := getJSXRuntimeImportSpecifier(file, runtimeImportSpecifier)
		mod := resolveExternalModule(specifier || /* TODO(NonNullExpression): location! */ TODO, runtimeImportSpecifier, errorMessage, location)
		result := /* TODO(ConditionalExpression): mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : undefined */ TODO
		if links {
			links.jsxImplicitImportContainer = result || false
		}
		return result
	}
	getJsxNamespaceAt := func(location Node) Symbol {
		links := location && getNodeLinks(location)
		if links && links.jsxNamespace {
			return links.jsxNamespace
		}
		if !links || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): links.jsxNamespace !== false */ TODO {
			resolvedNamespace := getJsxNamespaceContainerForImplicitImport(location)
			if !resolvedNamespace || resolvedNamespace == unknownSymbol {
				namespaceName := getJsxNamespace(location)
				resolvedNamespace = resolveName(location, namespaceName, SymbolFlagsNamespace, nil, false)
			}
			if resolvedNamespace {
				candidate := resolveSymbol(getSymbol(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), JsxNames.JSX, SymbolFlagsNamespace))
				if candidate && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): candidate !== unknownSymbol */ TODO {
					if links {
						links.jsxNamespace = candidate
					}
					return candidate
				}
			}
			if links {
				links.jsxNamespace = false
			}
		}
		s := resolveSymbol(getGlobalSymbol(JsxNames.JSX, SymbolFlagsNamespace, nil))
		if s == unknownSymbol {
			return /* TODO(NonNullExpression): undefined! */ TODO
		}
		return /* TODO(NonNullExpression): s! */ TODO
	}
	getNameFromJsxElementAttributesContainer := func(nameOfAttribPropContainer __String, jsxNamespace Symbol) *__String {
		jsxElementAttribPropInterfaceSym := jsxNamespace && getSymbol( /* TODO(NonNullExpression): jsxNamespace.exports! */ TODO, nameOfAttribPropContainer, SymbolFlagsType)
		jsxElementAttribPropInterfaceType := jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym)
		propertiesOfJsxElementAttribPropInterface := jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType)
		if propertiesOfJsxElementAttribPropInterface {
			if propertiesOfJsxElementAttribPropInterface.length == 0 {
				return "" /* as */ /* TODO(TypeReference): __String */
			} else if propertiesOfJsxElementAttribPropInterface.length == 1 {
				return /* TODO(ElementAccessExpression): propertiesOfJsxElementAttribPropInterface[0] */ TODO.escapedName
			} else if propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations {
				error( /* TODO(ElementAccessExpression): jsxElementAttribPropInterfaceSym.declarations[0] */ TODO, Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer))
			}
		}
		return nil
	}
	getJsxLibraryManagedAttributes := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		return jsxNamespace && getSymbol( /* TODO(NonNullExpression): jsxNamespace.exports! */ TODO, JsxNames.LibraryManagedAttributes, SymbolFlagsType)
	}
	getJsxElementTypeSymbol := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		return jsxNamespace && getSymbol( /* TODO(NonNullExpression): jsxNamespace.exports! */ TODO, JsxNames.ElementType, SymbolFlagsType)
	}
	getJsxElementPropertiesName := func(jsxNamespace Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace)
	}
	getJsxElementChildrenPropertyName := func(jsxNamespace Symbol) *__String {
		return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace)
	}
	getUninstantiatedJsxSignaturesOfType := func(elementType Type, caller JsxOpeningLikeElement) []Signature {
		if elementType.flags & TypeFlagsString {
			return /* TODO(ArrayLiteralExpression): [anySignature] */ TODO
		} else if elementType.flags & TypeFlagsStringLiteral {
			intrinsicType := getIntrinsicAttributesTypeFromStringLiteralType(elementType /* as */ /* TODO(TypeReference): StringLiteralType */, caller)
			if !intrinsicType {
				error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, (elementType /* as */ /* TODO(TypeReference): StringLiteralType */).value /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "JSX." + JsxNames.IntrinsicElements */, TODO)
				return emptyArray
			} else {
				fakeSignature := createSignatureForJSXIntrinsic(caller, intrinsicType)
				return /* TODO(ArrayLiteralExpression): [fakeSignature] */ TODO
			}
		}
		apparentElemType := getApparentType(elementType)
		signatures := getSignaturesOfType(apparentElemType, SignatureKindConstruct)
		if signatures.length == 0 {
			signatures = getSignaturesOfType(apparentElemType, SignatureKindCall)
		}
		if signatures.length == 0 && apparentElemType.flags&TypeFlagsUnion {
			signatures = getUnionSignatures(map_((apparentElemType /* as */ /* TODO(TypeReference): UnionType */).types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
				/* TODO(Identifier): getUninstantiatedJsxSignaturesOfType */
				/* TODO(Identifier): t */
				/* TODO(Identifier): caller */
			}))
		}
		return signatures
	}
	getIntrinsicAttributesTypeFromStringLiteralType := func(type_ StringLiteralType, location Node) *Type {
		intrinsicElementsType := getJsxType(JsxNames.IntrinsicElements, location)
		if !isErrorType(intrinsicElementsType) {
			stringLiteralTypeName := type_.value
			intrinsicProp := getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName))
			if intrinsicProp {
				return getTypeOfSymbol(intrinsicProp)
			}
			indexSignatureType := getIndexTypeOfType(intrinsicElementsType, stringType)
			if indexSignatureType {
				return indexSignatureType
			}
			return nil
		}
		return anyType
	}
	checkJsxReturnAssignableToAppropriateBound := func(refKind JsxReferenceKind, elemInstanceType Type, openingLikeElement JsxOpeningLikeElement) {
		if refKind == JsxReferenceKindFunction {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			if sfcReturnConstraint {
				checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else if refKind == JsxReferenceKindComponent {
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if classConstraint {
				checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
			}
		} else {
			sfcReturnConstraint := getJsxStatelessElementTypeAt(openingLikeElement)
			classConstraint := getJsxElementClassTypeAt(openingLikeElement)
			if !sfcReturnConstraint || !classConstraint {
				return
			}
			combined := getUnionType( /* TODO(ArrayLiteralExpression): [sfcReturnConstraint, classConstraint] */ TODO)
			checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain)
		}
		generateInitialErrorChain := func() DiagnosticMessageChain {
			componentName := getTextOfNode(openingLikeElement.tagName)
			return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
		}
	}
	getIntrinsicAttributesTypeFromJsxOpeningLikeElement := func(node JsxOpeningLikeElement) Type {
		Debug.assert(isJsxIntrinsicTagName(node.tagName))
		links := getNodeLinks(node)
		if !links.resolvedJsxElementAttributesType {
			symbol := getIntrinsicTagSymbol(node)
			if links.jsxFlags & JsxFlagsIntrinsicNamedElement {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType */ TODO
			} else if links.jsxFlags & JsxFlagsIntrinsicIndexedElement {
				propName := /* TODO(ConditionalExpression): isJsxNamespacedName(node.tagName) ? getEscapedTextOfJsxNamespacedName(node.tagName) : node.tagName.escapedText */ TODO
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = getApplicableIndexInfoForName(getJsxType(JsxNames.IntrinsicElements, node), propName)?.type || errorType */ TODO
			} else {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.resolvedJsxElementAttributesType = errorType */ TODO
			}
		}
		return links.resolvedJsxElementAttributesType
	}
	getJsxElementClassTypeAt := func(location Node) *Type {
		type_ := getJsxType(JsxNames.ElementClass, location)
		if isErrorType(type_) {
			/* TODO(Identifier): undefined */
		}
		return type_
	}
	getJsxElementTypeAt := func(location Node) Type {
		return getJsxType(JsxNames.Element, location)
	}
	getJsxStatelessElementTypeAt := func(location Node) *Type {
		jsxElementType := getJsxElementTypeAt(location)
		if jsxElementType {
			return getUnionType( /* TODO(ArrayLiteralExpression): [jsxElementType, nullType] */ TODO)
		}
	}
	getJsxElementTypeTypeAt := func(location Node) *Type {
		ns := getJsxNamespaceAt(location)
		if !ns {
			/* TODO(Identifier): undefined */
		}
		sym := getJsxElementTypeSymbol(ns)
		if !sym {
			/* TODO(Identifier): undefined */
		}
		type_ := instantiateAliasOrInterfaceWithDefaults(sym, isInJSFile(location))
		if !type_ || isErrorType(type_) {
			/* TODO(Identifier): undefined */
		}
		return type_
	}
	instantiateAliasOrInterfaceWithDefaults := func(managedSym Symbol, inJs bool, typeArguments []Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		declaredManagedType := getDeclaredTypeOfSymbol(managedSym)
		if managedSym.flags & SymbolFlagsTypeAlias {
			params := getSymbolLinks(managedSym).typeParameters
			if length(params) >= typeArguments.length {
				args := fillMissingTypeArguments(typeArguments, params, typeArguments.length, inJs)
				return /* TODO(ConditionalExpression): length(args) === 0 ? declaredManagedType : getTypeAliasInstantiation(managedSym, args) */ TODO
			}
		}
		if length((declaredManagedType /* as */ /* TODO(TypeReference): GenericType */).typeParameters) >= typeArguments.length {
			args := fillMissingTypeArguments(typeArguments, (declaredManagedType /* as */ /* TODO(TypeReference): GenericType */).typeParameters, typeArguments.length, inJs)
			return createTypeReference(declaredManagedType /* as */ /* TODO(TypeReference): GenericType */, args)
		}
		return nil
	}
	getJsxIntrinsicTagNamesAt := func(location Node) []Symbol {
		intrinsics := getJsxType(JsxNames.IntrinsicElements, location)
		return /* TODO(ConditionalExpression): intrinsics ? getPropertiesOfType(intrinsics) : emptyArray */ TODO
	}
	checkJsxPreconditions := func(errorNode Node) {
		if (compilerOptions.jsx || JsxEmitNone) == JsxEmitNone {
			error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided)
		}
		if getJsxElementTypeAt(errorNode) == nil {
			if noImplicitAny {
				error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist)
			}
		}
	}
	checkJsxOpeningLikeElementOrOpeningFragment := func(node /* TODO(UnionType): JsxOpeningLikeElement | JsxOpeningFragment */ any) {
		isNodeOpeningLikeElement := isJsxOpeningLikeElement(node)
		if isNodeOpeningLikeElement {
			checkGrammarJsxElement(node)
		}
		checkJsxPreconditions(node)
		markJsxAliasReferenced(node)
		if isNodeOpeningLikeElement {
			jsxOpeningLikeNode := node
			sig := getResolvedSignature(jsxOpeningLikeNode)
			checkDeprecatedSignature(sig, node)
			elementTypeConstraint := getJsxElementTypeTypeAt(jsxOpeningLikeNode)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): elementTypeConstraint !== undefined */ TODO {
				tagName := jsxOpeningLikeNode.tagName
				tagType := /* TODO(ConditionalExpression): isJsxIntrinsicTagName(tagName)                     ? getStringLiteralType(intrinsicTagNameToString(tagName))                     : checkExpression(tagName) */ TODO
				checkTypeRelatedTo(tagType, elementTypeConstraint, assignableRelation, tagName, Diagnostics.Its_type_0_is_not_a_valid_JSX_element_type, func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
					componentName := getTextOfNode(tagName)
					return chainDiagnosticMessages(nil, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName)
				})
			} else {
				checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode)
			}
		}
	}
	isKnownProperty := func(targetType Type, name __String, isComparingJsxAttributes bool) bool {
		if targetType.flags & TypeFlagsObject {
			if getPropertyOfObjectType(targetType, name) || getApplicableIndexInfoForName(targetType, name) || isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) || isComparingJsxAttributes && isHyphenatedJsxName(name) {
				return true
			}
		}
		if targetType.flags & TypeFlagsSubstitution {
			return isKnownProperty((targetType /* as */ /* TODO(TypeReference): SubstitutionType */).baseType, name, isComparingJsxAttributes)
		}
		if targetType.flags&TypeFlagsUnionOrIntersection && isExcessPropertyCheckTarget(targetType) {
			for _, t := range (targetType /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types {
				if isKnownProperty(t, name, isComparingJsxAttributes) {
					return true
				}
			}
		}
		return false
	}
	isExcessPropertyCheckTarget := func(type_ Type) bool {
		return !!(type_.flags&TypeFlagsObject && !(getObjectFlags(type_)&ObjectFlagsObjectLiteralPatternWithComputedProperties) || type_.flags&TypeFlagsNonPrimitive || type_.flags&TypeFlagsSubstitution && isExcessPropertyCheckTarget((type_ /* as */ /* TODO(TypeReference): SubstitutionType */).baseType) || type_.flags&TypeFlagsUnion && some((type_ /* as */ /* TODO(TypeReference): UnionType */).types, isExcessPropertyCheckTarget) || type_.flags&TypeFlagsIntersection && every((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, isExcessPropertyCheckTarget))
	}
	checkJsxExpression := func(node JsxExpression, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkGrammarJsxExpression(node)
		if node.expression {
			type_ := checkExpression(node.expression, checkMode)
			if node.dotDotDotToken && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): type !== anyType */ TODO && !isArrayType(type_) {
				error(node, Diagnostics.JSX_spread_child_must_be_an_array_type)
			}
			return type_
		} else {
			return errorType
		}
	}
	getDeclarationNodeFlagsFromSymbol := func(s Symbol) NodeFlags {
		return /* TODO(ConditionalExpression): s.valueDeclaration ? getCombinedNodeFlagsCached(s.valueDeclaration) : 0 */ TODO
	}
	isPrototypeProperty := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		if symbol.flags&SymbolFlagsMethod || getCheckFlags(symbol)&CheckFlagsSyntheticMethod {
			return true
		}
		if isInJSFile(symbol.valueDeclaration) {
			parent := /* TODO(NonNullExpression): symbol.valueDeclaration! */ TODO.parent
			return parent && isBinaryExpression(parent) && getAssignmentDeclarationKind(parent) == AssignmentDeclarationKindPrototypeProperty
		}
	}
	checkPropertyAccessibility := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | PropertyAccessExpression | VariableDeclaration | ParameterDeclaration | ImportTypeNode | PropertyAssignment | ShorthandPropertyAssignment | BindingElement */ any, isSuper bool, writing bool, type_ Type, prop Symbol, reportError /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) bool {
		errorNode := /* TODO(ConditionalExpression): !reportError ? undefined :             node.kind === SyntaxKind.QualifiedName ? node.right :             node.kind === SyntaxKind.ImportType ? node :             node.kind === SyntaxKind.BindingElement && node.propertyName ? node.propertyName : node.name */ TODO
		return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type_, prop, errorNode)
	}
	checkPropertyAccessibilityAtLocation := func(location Node, isSuper bool, writing bool, containingType Type, prop Symbol, errorNode Node) bool {
		flags := getDeclarationModifierFlagsFromSymbol(prop, writing)
		if isSuper {
			if languageVersion < ScriptTargetES2015 {
				if symbolHasNonMethodDeclaration(prop) {
					if errorNode {
						error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword)
					}
					return false
				}
			}
			if flags & ModifierFlagsAbstract {
				if errorNode {
					error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString( /* TODO(NonNullExpression): getDeclaringClass(prop)! */ TODO))
				}
				return false
			}
			if !(flags & ModifierFlagsStatic) && prop.declarations.some(isClassInstanceProperty) {
				if errorNode {
					error(errorNode, Diagnostics.Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super, symbolToString(prop))
				}
				return false
			}
		}
		if (flags & ModifierFlagsAbstract) && symbolHasNonMethodDeclaration(prop) && (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent)) {
			declaringClassDeclaration := getClassLikeDeclarationOfSymbol( /* TODO(NonNullExpression): getParentOfSymbol(prop)! */ TODO)
			if declaringClassDeclaration && isNodeUsedDuringClassInitialization(location) {
				if errorNode {
					error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral( /* TODO(NonNullExpression): declaringClassDeclaration.name! */ TODO))
				}
				return false
			}
		}
		if !(flags & ModifierFlagsNonPublicAccessibilityModifier) {
			return true
		}
		if flags & ModifierFlagsPrivate {
			declaringClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop)!)! */ TODO
			if !isNodeWithinClass(location, declaringClassDeclaration) {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString( /* TODO(NonNullExpression): getDeclaringClass(prop)! */ TODO))
				}
				return false
			}
			return true
		}
		if isSuper {
			return true
		}
		enclosingClass := forEachEnclosingClass(location, func(enclosingDeclaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceType | undefined */ TODO {
			enclosingClass := getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration)) /* as */ /* TODO(TypeReference): InterfaceType */
			return isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
		})
		if !enclosingClass {
			enclosingClass = getEnclosingClassFromThisParameter(location)
			enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing)
			if flags&ModifierFlagsStatic || !enclosingClass {
				if errorNode {
					error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType))
				}
				return false
			}
		}
		if flags & ModifierFlagsStatic {
			return true
		}
		if containingType.flags & TypeFlagsTypeParameter {
			containingType = /* TODO(ConditionalExpression): (containingType as TypeParameter).isThisType ? getConstraintOfTypeParameter(containingType as TypeParameter)! : getBaseConstraintOfType(containingType as TypeParameter)! */ TODO
		}
		if !containingType || !hasBaseType(containingType, enclosingClass) {
			if errorNode {
				error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType))
			}
			return false
		}
		return true
	}
	getEnclosingClassFromThisParameter := func(node Node) *InterfaceType {
		thisParameter := getThisParameterFromNodeContext(node)
		thisType := thisParameter.type_ && getTypeFromTypeNode(thisParameter.type_)
		if thisType {
			if thisType.flags & TypeFlagsTypeParameter {
				thisType = getConstraintOfTypeParameter(thisType /* as */ /* TODO(TypeReference): TypeParameter */)
			}
		} else {
			thisContainer := getThisContainer(node, false, false)
			if isFunctionLike(thisContainer) {
				thisType = getContextualThisParameterType(thisContainer)
			}
		}
		if thisType && getObjectFlags(thisType)&(ObjectFlagsClassOrInterface|ObjectFlagsReference) {
			return getTargetType(thisType) /* as */ /* TODO(TypeReference): InterfaceType */
		}
		return nil
	}
	getThisParameterFromNodeContext := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | undefined */ TODO {
		thisContainer := getThisContainer(node, false, false)
		return /* TODO(ConditionalExpression): thisContainer && isFunctionLike(thisContainer) ? getThisParameter(thisContainer) : undefined */ TODO
	}
	symbolHasNonMethodDeclaration := func(symbol Symbol) /* TODO(undefined): boolean */ TODO {
		return !!forEachProperty(symbol, func(prop /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(ParenthesizedExpression): (prop.flags & SymbolFlags.Method) */
		})
	}
	checkNonNullExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkNonNullType(checkExpression(node), node)
	}
	isNullableType := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return hasTypeFacts(type_, TypeFactsIsUndefinedOrNull)
	}
	getNonNullableTypeIfNeeded := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): isNullableType(type) ? getNonNullableType(type) : type */ TODO
	}
	reportObjectPossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		nodeText := /* TODO(ConditionalExpression): isEntityNameExpression(node) ? entityNameToString(node) : undefined */ TODO
		if node.kind == SyntaxKindNullKeyword {
			error(node, Diagnostics.The_value_0_cannot_be_used_here, "null")
			return
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nodeText !== undefined */ TODO && nodeText.length < 100 {
			if isIdentifier(node) && nodeText == "undefined" {
				error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined")
				return
			}
			error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics._0_is_possibly_null_or_undefined :                     Diagnostics._0_is_possibly_undefined :                     Diagnostics._0_is_possibly_null */, TODO, nodeText)
		} else {
			error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                     Diagnostics.Object_is_possibly_null_or_undefined :                     Diagnostics.Object_is_possibly_undefined :                     Diagnostics.Object_is_possibly_null */, TODO)
		}
	}
	reportCannotInvokePossiblyNullOrUndefinedError := func(node Node, facts TypeFacts) {
		error(node /* TODO(ConditionalExpression): facts & TypeFacts.IsUndefined ? facts & TypeFacts.IsNull ?                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined :                 Diagnostics.Cannot_invoke_an_object_which_is_possibly_null */, TODO)
	}
	checkNonNullTypeWithReporter := func(type_ Type, node Node, reportError func(node Node, facts TypeFacts)) Type {
		if strictNullChecks && type_.flags&TypeFlagsUnknown {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_of_type_unknown, nodeText)
					return errorType
				}
			}
			error(node, Diagnostics.Object_is_of_type_unknown)
			return errorType
		}
		facts := getTypeFacts(type_, TypeFactsIsUndefinedOrNull)
		if facts & TypeFactsIsUndefinedOrNull {
			reportError(node, facts)
			t := getNonNullableType(type_)
			return /* TODO(ConditionalExpression): t.flags & (TypeFlags.Nullable | TypeFlags.Never) ? errorType : t */ TODO
		}
		return type_
	}
	checkNonNullType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkNonNullTypeWithReporter(type_, node, reportObjectPossiblyNullOrUndefinedError)
	}
	checkNonNullNonVoidType := func(type_ Type, node Node) Type {
		nonNullType := checkNonNullType(type_, node)
		if nonNullType.flags & TypeFlagsVoid {
			if isEntityNameExpression(node) {
				nodeText := entityNameToString(node)
				if isIdentifier(node) && nodeText == "undefined" {
					error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText)
					return nonNullType
				}
				if nodeText.length < 100 {
					error(node, Diagnostics._0_is_possibly_undefined, nodeText)
					return nonNullType
				}
			}
			error(node, Diagnostics.Object_is_possibly_undefined)
		}
		return nonNullType
	}
	checkPropertyAccessExpression := func(node PropertyAccessExpression, checkMode *CheckMode, writeOnly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkPropertyAccessChain(node as PropertyAccessChain, checkMode) :             checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode, writeOnly) */ TODO
	}
	checkPropertyAccessChain := func(node PropertyAccessChain, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== leftType */, TODO)
	}
	checkQualifiedName := func(node QualifiedName, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := /* TODO(ConditionalExpression): isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left) */ TODO
		return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode)
	}
	isMethodAccessForCall := func(node Node) /* TODO(undefined): boolean */ TODO {
		/* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.ParenthesizedExpression) {             node = node.parent;         } */
		return isCallOrNewExpression(node.parent) && node.parent.expression == node
	}
	lookupSymbolForPrivateIdentifierDeclaration := func(propName __String, location Node) *Symbol {
		/* TODO(ForStatement): for (let containingClass = getContainingClassExcludingClassDecorators(location); !!containingClass; containingClass = getContainingClass(containingClass)) {             const { symbol } = containingClass;             const name = getSymbolNameForPrivateIdentifier(symbol, propName);             const prop = (symbol.members && symbol.members.get(name)) || (symbol.exports && symbol.exports.get(name));             if (prop) {                 return prop;             }         } */
	}
	checkGrammarPrivateIdentifierExpression := func(privId PrivateIdentifier) bool {
		if !getContainingClass(privId) {
			return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		if !isForInStatement(privId.parent) {
			if !isExpressionNode(privId) {
				return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression)
			}
			isInOperation := isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind == SyntaxKindInKeyword
			if !getSymbolForPrivateIdentifierExpression(privId) && !isInOperation {
				return grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId))
			}
		}
		return false
	}
	checkPrivateIdentifierExpression := func(privId PrivateIdentifier) Type {
		checkGrammarPrivateIdentifierExpression(privId)
		symbol := getSymbolForPrivateIdentifierExpression(privId)
		if symbol {
			markPropertyAsReferenced(symbol, nil, false)
		}
		return anyType
	}
	getSymbolForPrivateIdentifierExpression := func(privId PrivateIdentifier) *Symbol {
		if !isExpressionNode(privId) {
			return nil
		}
		links := getNodeLinks(privId)
		if links.resolvedSymbol == nil {
			links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId)
		}
		return links.resolvedSymbol
	}
	getPrivateIdentifierPropertyOfType := func(leftType Type, lexicallyScopedIdentifier Symbol) *Symbol {
		return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName)
	}
	checkPrivateIdentifierPropertyAccess := func(leftType Type, right PrivateIdentifier, lexicallyScopedIdentifier *Symbol) bool {
		var propertyOnType *Symbol
		properties := getPropertiesOfType(leftType)
		if properties {
			forEach(properties, func(symbol Symbol) /* TODO(undefined): true | undefined */ TODO {
				decl := symbol.valueDeclaration
				if decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText == right.escapedText {
					propertyOnType = symbol
					return true
				}
			})
		}
		diagName := diagnosticName(right)
		if propertyOnType {
			typeValueDecl := Debug.checkDefined(propertyOnType.valueDeclaration)
			typeClass := Debug.checkDefined(getContainingClass(typeValueDecl))
			if lexicallyScopedIdentifier.valueDeclaration {
				lexicalValueDecl := lexicallyScopedIdentifier.valueDeclaration
				lexicalClass := getContainingClass(lexicalValueDecl)
				Debug.assert(!!lexicalClass)
				if findAncestor(lexicalClass, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): typeClass */
					/* TODO(EqualsEqualsEqualsToken): === */
					/* TODO(Identifier): n */
				}) {
					diagnostic := error(right, Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling, diagName, typeToString(leftType))
					addRelatedInfo(diagnostic, createDiagnosticForNode(lexicalValueDecl, Diagnostics.The_shadowing_declaration_of_0_is_defined_here, diagName), createDiagnosticForNode(typeValueDecl, Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName))
					return true
				}
			}
			error(right, Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, diagnosticName(typeClass.name || anon))
			return true
		}
		return false
	}
	isThisPropertyAccessInConstructor := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		return (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop)) && getThisContainer(node, true, false) == getDeclaringConstructor(prop)
	}
	checkPropertyAccessExpressionOrQualifiedName := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, left /* TODO(UnionType): Expression | QualifiedName */ any, leftType Type, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any, checkMode *CheckMode, writeOnly bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		parentSymbol := getNodeLinks(left).resolvedSymbol
		assignmentKind := getAssignmentTargetKind(node)
		apparentType := getApparentType( /* TODO(ConditionalExpression): assignmentKind !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType */ TODO)
		isAnyLike := isTypeAny(apparentType) || apparentType == silentNeverType
		var prop *Symbol
		if isPrivateIdentifier(right) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.None */ TODO {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldSet)
				}
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.Definite */ TODO {
					checkExternalEmitHelpers(node, ExternalEmitHelpersClassPrivateFieldGet)
				}
			}
			lexicallyScopedSymbol := lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right)
			if assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration) {
				grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right))
			}
			if isAnyLike {
				if lexicallyScopedSymbol {
					return /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
				}
				if getContainingClassExcludingClassDecorators(right) == nil {
					grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
					return anyType
				}
			}
			prop = lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol)
			if prop == nil {
				if checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol) {
					return errorType
				}
				containingClass := getContainingClassExcludingClassDecorators(right)
				if containingClass && isPlainJsFile(getSourceFileOfNode(containingClass), compilerOptions.checkJs) {
					grammarErrorOnNode(right, Diagnostics.Private_field_0_must_be_declared_in_an_enclosing_class, idText(right))
				}
			} else {
				isSetonlyAccessor := prop.flags&SymbolFlagsSetAccessor && !(prop.flags & SymbolFlagsGetAccessor)
				if isSetonlyAccessor && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): assignmentKind !== AssignmentKind.Definite */ TODO {
					error(node, Diagnostics.Private_accessor_was_defined_without_a_getter)
				}
			}
		} else {
			if isAnyLike {
				if isIdentifier(left) && parentSymbol {
					markLinkedReferences(node, ReferenceHintProperty, nil, leftType)
				}
				return /* TODO(ConditionalExpression): isErrorType(apparentType) ? errorType : apparentType */ TODO
			}
			prop = getPropertyOfType(apparentType, right.escapedText, isConstEnumObjectType(apparentType), node.kind == SyntaxKindQualifiedName)
		}
		markLinkedReferences(node, ReferenceHintProperty, prop, leftType)
		var propType Type
		if !prop {
			indexInfo := /* TODO(ConditionalExpression): !isPrivateIdentifier(right) && (assignmentKind === AssignmentKind.None || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)) ?                 getApplicableIndexInfoForName(apparentType, right.escapedText) : undefined */ TODO
			if !(indexInfo && indexInfo.type_) {
				isUncheckedJS := isUncheckedJSSuggestion(node, leftType.symbol, true)
				if !isUncheckedJS && isJSLiteralType(leftType) {
					return anyType
				}
				if leftType.symbol == globalThisSymbol {
					if /* TODO(NonNullExpression): globalThisSymbol.exports! */ TODO.has(right.escapedText) && ( /* TODO(NonNullExpression): globalThisSymbol.exports!.get(right.escapedText)! */ TODO.flags & SymbolFlagsBlockScoped) {
						error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType))
					} else if noImplicitAny {
						error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType))
					}
					return anyType
				}
				if right.escapedText && !checkAndReportErrorForExtendingInterface(node) {
					reportNonexistentProperty(right /* TODO(ConditionalExpression): isThisTypeParameter(leftType) ? apparentType : leftType */, TODO, isUncheckedJS)
				}
				return errorType
			}
			if indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node)) {
				error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType))
			}
			propType = indexInfo.type_
			if compilerOptions.noUncheckedIndexedAccess && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getAssignmentTargetKind(node) !== AssignmentKind.Definite */ TODO {
				propType = getUnionType( /* TODO(ArrayLiteralExpression): [propType, missingType] */ TODO)
			}
			if compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node) {
				error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText))
			}
			if indexInfo.declaration && isDeprecatedDeclaration(indexInfo.declaration) {
				addDeprecatedSuggestion(right /* TODO(ArrayLiteralExpression): [indexInfo.declaration] */, TODO, right.escapedText /* as */ /* TODO(StringKeyword): string */)
			}
		} else {
			targetPropSymbol := resolveAliasWithDeprecationCheck(prop, right)
			if isDeprecatedSymbol(targetPropSymbol) && isUncalledFunctionReference(node, targetPropSymbol) && targetPropSymbol.declarations {
				addDeprecatedSuggestion(right, targetPropSymbol.declarations, right.escapedText /* as */ /* TODO(StringKeyword): string */)
			}
			checkPropertyNotUsedBeforeDeclaration(prop, node, right)
			markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol))
			getNodeLinks(node).resolvedSymbol = prop
			checkPropertyAccessibility(node, left.kind == SyntaxKindSuperKeyword, isWriteAccess(node), apparentType, prop)
			if isAssignmentToReadonlyEntity(node /* as */ /* TODO(TypeReference): Expression */, prop, assignmentKind) {
				error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right))
				return errorType
			}
			propType = /* TODO(ConditionalExpression): isThisPropertyAccessInConstructor(node, prop) ? autoType : writeOnly || isWriteOnlyAccess(node) ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop) */ TODO
		}
		return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode)
	}
	isUncheckedJSSuggestion := func(node Node, suggestion *Symbol, excludeClasses bool) bool {
		file := getSourceFileOfNode(node)
		if file {
			if compilerOptions.checkJs == nil && file.checkJsDirective == nil && (file.scriptKind == ScriptKindJS || file.scriptKind == ScriptKindJSX) {
				declarationFile := forEach(suggestion.declarations, getSourceFileOfNode)
				suggestionHasNoExtendsOrDecorators := !suggestion.valueDeclaration || !isClassLike(suggestion.valueDeclaration) || suggestion.valueDeclaration.heritageClauses.length || classOrConstructorParameterIsDecorated(false, suggestion.valueDeclaration)
				return !( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): file !== declarationFile */ TODO && !!declarationFile && isGlobalSourceFile(declarationFile)) && !(excludeClasses && suggestion && suggestion.flags&SymbolFlagsClass && suggestionHasNoExtendsOrDecorators) && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword && suggestionHasNoExtendsOrDecorators)
			}
		}
		return false
	}
	getFlowTypeOfAccessExpression := func(node /* TODO(UnionType): ElementAccessExpression | PropertyAccessExpression | QualifiedName */ any, prop *Symbol, propType Type, errorNode Node, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		assignmentKind := getAssignmentTargetKind(node)
		if assignmentKind == AssignmentKindDefinite {
			return removeMissingType(propType, !!(prop && prop.flags&SymbolFlagsOptional))
		}
		if prop && !(prop.flags & (SymbolFlagsVariable | SymbolFlagsProperty | SymbolFlagsAccessor)) && !(prop.flags&SymbolFlagsMethod && propType.flags&TypeFlagsUnion) && !isDuplicatedCommonJSExport(prop.declarations) {
			return propType
		}
		if propType == autoType {
			return getFlowTypeOfProperty(node, prop)
		}
		propType = getNarrowableTypeForReference(propType, node, checkMode)
		assumeUninitialized := false
		if strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind == SyntaxKindThisKeyword {
			declaration := prop && prop.valueDeclaration
			if declaration && isPropertyWithoutInitializer(declaration) {
				if !isStatic(declaration) {
					flowContainer := getControlFlowContainer(node)
					if flowContainer.kind == SyntaxKindConstructor && flowContainer.parent == declaration.parent && !(declaration.flags & NodeFlagsAmbient) {
						assumeUninitialized = true
					}
				}
			}
		} else if strictNullChecks && prop && prop.valueDeclaration && isPropertyAccessExpression(prop.valueDeclaration) && getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) && getControlFlowContainer(node) == getControlFlowContainer(prop.valueDeclaration) {
			assumeUninitialized = true
		}
		flowType := getFlowTypeOfReference(node, propType /* TODO(ConditionalExpression): assumeUninitialized ? getOptionalType(propType) : propType */, TODO)
		if assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType) {
			error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString( /* TODO(NonNullExpression): prop! */ TODO))
			return propType
		}
		return /* TODO(ConditionalExpression): assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType */ TODO
	}
	checkPropertyNotUsedBeforeDeclaration := func(prop Symbol, node /* TODO(UnionType): PropertyAccessExpression | QualifiedName */ any, right /* TODO(UnionType): Identifier | PrivateIdentifier */ any) {
		TODO_IDENTIFIER := prop
		if !valueDeclaration || getSourceFileOfNode(node).isDeclarationFile {
			return
		}
		var diagnosticMessage TODO
		declarationName := idText(right)
		if isInPropertyInitializerOrClassStaticBlock(node) && !isOptionalPropertyDeclaration(valueDeclaration) && !(isAccessExpression(node) && isAccessExpression(node.expression)) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) && !(isMethodDeclaration(valueDeclaration) && getCombinedModifierFlagsCached(valueDeclaration)&ModifierFlagsStatic) && (useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop)) {
			diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName)
		} else if valueDeclaration.kind == SyntaxKindClassDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.TypeReference */ TODO && !(valueDeclaration.flags & NodeFlagsAmbient) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) {
			diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName)
		}
		if diagnosticMessage {
			addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName))
		}
	}
	isInPropertyInitializerOrClassStaticBlock := func(node Node) bool {
		return !!findAncestor(node, func(node /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.PropertyDeclaration:                     return true;                 case SyntaxKind.PropertyAssignment:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.SpreadAssignment:                 case SyntaxKind.ComputedPropertyName:                 case SyntaxKind.TemplateSpan:                 case SyntaxKind.JsxExpression:                 case SyntaxKind.JsxAttribute:                 case SyntaxKind.JsxAttributes:                 case SyntaxKind.JsxSpreadAttribute:                 case SyntaxKind.JsxOpeningElement:                 case SyntaxKind.ExpressionWithTypeArguments:                 case SyntaxKind.HeritageClause:                     return false;                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.ExpressionStatement:                     return isBlock(node.parent) && isClassStaticBlockDeclaration(node.parent.parent) ? true : "quit";                 default:                     return isExpressionNode(node) ? false : "quit";             } */
		})
	}
	isPropertyDeclaredInAncestorClass := func(prop Symbol) bool {
		if !( /* TODO(NonNullExpression): prop.parent! */ TODO.flags & SymbolFlagsClass) {
			return false
		}
		var classType *InterfaceType = getTypeOfSymbol( /* TODO(NonNullExpression): prop.parent! */ TODO) /* as */ /* TODO(TypeReference): InterfaceType */
		/* TODO(WhileStatement): while (true) {             classType = classType.symbol && getSuperClass(classType) as InterfaceType | undefined;             if (!classType) {                 return false;             }             const superProperty = getPropertyOfType(classType, prop.escapedName);             if (superProperty && superProperty.valueDeclaration) {                 return true;             }         } */
	}
	getSuperClass := func(classType InterfaceType) *Type {
		x := getBaseTypes(classType)
		if x.length == 0 {
			return nil
		}
		return getIntersectionType(x)
	}
	reportNonexistentProperty := func(propNode /* TODO(UnionType): Identifier | PrivateIdentifier */ any, containingType Type, isUncheckedJS bool) {
		var errorInfo *DiagnosticMessageChain
		var relatedInfo *Diagnostic
		if !isPrivateIdentifier(propNode) && containingType.flags&TypeFlagsUnion && !(containingType.flags & TypeFlagsPrimitive) {
			for _, subtype := range (containingType /* as */ /* TODO(TypeReference): UnionType */).types {
				if !getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(subtype, propNode.escapedText) {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype))
					/* TODO(BreakStatement): break; */
				}
			}
		}
		if typeHasStaticProperty(propNode.escapedText, containingType) {
			propName := declarationNameToString(propNode)
			typeName := typeToString(containingType)
			errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName /* TODO(PlusToken): + */ /* TODO(BinaryExpression): typeName + "." + propName */, TODO)
		} else {
			promisedType := getPromisedTypeOfPromise(containingType)
			if promisedType && getPropertyOfType(promisedType, propNode.escapedText) {
				errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType))
				relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await)
			} else {
				missingProperty := declarationNameToString(propNode)
				container := typeToString(containingType)
				libSuggestion := getSuggestedLibForNonExistentProperty(missingProperty, containingType)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): libSuggestion !== undefined */ TODO {
					errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion)
				} else {
					suggestion := getSuggestedSymbolForNonexistentProperty(propNode, containingType)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): suggestion !== undefined */ TODO {
						suggestedName := symbolName(suggestion)
						message := /* TODO(ConditionalExpression): isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2 */ TODO
						errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName)
						relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName)
					} else {
						diagnostic := /* TODO(ConditionalExpression): containerSeemsToBeEmptyDomElement(containingType)                             ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom                             : Diagnostics.Property_0_does_not_exist_on_type_1 */ TODO
						errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container)
					}
				}
			}
		}
		resultDiagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo)
		if relatedInfo {
			addRelatedInfo(resultDiagnostic, relatedInfo)
		}
		addErrorOrSuggestion(!isUncheckedJS || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorInfo.code !== Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code */ TODO, resultDiagnostic)
	}
	containerSeemsToBeEmptyDomElement := func(containingType Type) /* TODO(undefined): boolean | undefined */ TODO {
		return (compilerOptions.lib && !compilerOptions.lib.includes("dom")) && everyContainedType(containingType, func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PropertyAccessExpression): type.symbol */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): /^(?:EventTarget|Node|(?:HTML[a-zA-Z]*)?Element)$/.test(unescapeLeadingUnderscores(type.symbol.escapedName)) */
		}) && isEmptyObjectType(containingType)
	}
	typeHasStaticProperty := func(propName __String, containingType Type) bool {
		prop := containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName)
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prop !== undefined */ TODO && !!prop.valueDeclaration && isStatic(prop.valueDeclaration)
	}
	getSuggestedLibForNonExistentName := func(name /* TODO(UnionType): __String | Identifier */ any) /* TODO(undefined): string | undefined */ TODO {
		missingName := diagnosticName(name)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(missingName)
		return typeFeatures && firstIterator(typeFeatures.keys())
	}
	getSuggestedLibForNonExistentProperty := func(missingProperty string, containingType Type) /* TODO(undefined): string | undefined */ TODO {
		container := getApparentType(containingType).symbol
		if !container {
			return nil
		}
		containingTypeName := symbolName(container)
		allFeatures := getScriptTargetFeatures()
		typeFeatures := allFeatures.get(containingTypeName)
		if typeFeatures {
			for _, TODO_IDENTIFIER := range typeFeatures {
				if contains(featuresOfType, missingProperty) {
					return libTarget
				}
			}
		}
	}
	getSuggestedSymbolForNonexistentClassMember := func(name string, baseType Type) *Symbol {
		return getSpellingSuggestionForName(name, getPropertiesOfType(baseType), SymbolFlagsClassMember)
	}
	getSuggestedSymbolForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		props := getPropertiesOfType(containingType)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typeof name !== "string" */ TODO {
			parent := name.parent
			if isPropertyAccessExpression(parent) {
				props = filter(props, func(prop /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): isValidPropertyAccessForCompletions */
					/* TODO(Identifier): parent */
					/* TODO(Identifier): containingType */
					/* TODO(Identifier): prop */
				})
			}
			name = idText(name)
		}
		return getSpellingSuggestionForName(name, props, SymbolFlagsValue)
	}
	getSuggestedSymbolForNonexistentJSXAttribute := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) *Symbol {
		strName := /* TODO(ConditionalExpression): isString(name) ? name : idText(name) */ TODO
		properties := getPropertiesOfType(containingType)
		jsxSpecific := /* TODO(ConditionalExpression): strName === "for" ? find(properties, x => symbolName(x) === "htmlFor")             : strName === "class" ? find(properties, x => symbolName(x) === "className")             : undefined */ TODO
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): jsxSpecific ?? getSpellingSuggestionForName(strName, properties, SymbolFlags.Value) */ TODO
	}
	getSuggestionForNonexistentProperty := func(name /* TODO(UnionType): Identifier | PrivateIdentifier | string */ any, containingType Type) /* TODO(StringKeyword): string */ any {
		suggestion := getSuggestedSymbolForNonexistentProperty(name, containingType)
		return suggestion && symbolName(suggestion)
	}
	getSuggestionForSymbolNameLookup := func(symbols SymbolTable, name __String, meaning SymbolFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		symbol := getSymbol(symbols, name, meaning)
		if symbol {
			/* TODO(Identifier): symbol */
		}
		var candidates []Symbol
		if symbols == globals {
			primitives := mapDefined( /* TODO(ArrayLiteralExpression): ["string", "number", "boolean", "object", "bigint", "symbol"] */ TODO, func(s /* TODO(undefined): string */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
				/* TODO(CallExpression): symbols.has((s.charAt(0).toUpperCase() + s.slice(1)) as __String) */
				/* TODO(QuestionToken): ? */
				/* TODO(AsExpression): createSymbol(SymbolFlags.TypeAlias, s as __String) as Symbol */
				/* TODO(ColonToken): : */
				/* TODO(Identifier): undefined */
			})
			candidates = primitives.concat(arrayFrom(symbols.values()))
		} else {
			candidates = arrayFrom(symbols.values())
		}
		return getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning)
	}
	getSuggestedSymbolForNonexistentSymbol := func(location Node, outerName __String, meaning SymbolFlags) *Symbol {
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): outerName !== undefined */ TODO, "outername should always be defined")
		result := resolveNameForSymbolSuggestion(location, outerName, meaning, nil, false, false)
		return result
	}
	getSuggestedSymbolForNonexistentModule := func(name Identifier, targetModule Symbol) *Symbol {
		return targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), SymbolFlagsModuleMember)
	}
	getSuggestionForNonexistentIndexSignature := func(objectType Type, expr ElementAccessExpression, keyedType Type) /* TODO(StringKeyword): string */ any {
		hasProp := func(name /* TODO(UnionType): "set" | "get" */ any) /* TODO(undefined): boolean */ TODO {
			prop := getPropertyOfObjectType(objectType, name /* as */ /* TODO(TypeReference): __String */)
			if prop {
				s := getSingleCallSignature(getTypeOfSymbol(prop))
				return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0))
			}
			return false
		}
		suggestedMethod := /* TODO(ConditionalExpression): isAssignmentTarget(expr) ? "set" : "get" */ TODO
		if !hasProp(suggestedMethod) {
			return nil
		}
		suggestion := tryGetPropertyAccessOrIdentifierToString(expr.expression)
		if suggestion == nil {
			suggestion = suggestedMethod
		} else {
			suggestion += /* TODO(PlusToken): + */ /* TODO(BinaryExpression): "." + suggestedMethod */ TODO
		}
		return suggestion
	}
	getSuggestedTypeForNonexistentStringLiteralType := func(source StringLiteralType, target UnionType) *StringLiteralType {
		candidates := target.types.filter(func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(TypePredicate): type is StringLiteralType */ TODO {
			/* TODO(PrefixUnaryExpression): !(type.flags & TypeFlags.StringLiteral) */
		})
		return getSpellingSuggestion(source.value, candidates, func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralType */ TODO) /* TODO(undefined): string */ TODO {
			/* TODO(Identifier): type */
			/* TODO(Identifier): value */
		})
	}
	getSpellingSuggestionForName := func(name string, symbols []Symbol, meaning SymbolFlags) *Symbol {
		return getSpellingSuggestion(name, symbols, getCandidateName)
		getCandidateName := func(candidate Symbol) /* TODO(undefined): string | undefined */ TODO {
			candidateName := symbolName(candidate)
			if startsWith(candidateName, '"') {
				return nil
			}
			if candidate.flags & meaning {
				return candidateName
			}
			if candidate.flags & SymbolFlagsAlias {
				alias := tryResolveAlias(candidate)
				if alias && alias.flags&meaning {
					return candidateName
				}
			}
			return nil
		}
	}
	markPropertyAsReferenced := func(prop Symbol, nodeForCheckWriteOnly Node, isSelfTypeAccess bool) {
		valueDeclaration := prop && (prop.flags & SymbolFlagsClassMember) && prop.valueDeclaration
		if !valueDeclaration {
			return
		}
		hasPrivateModifier := hasEffectiveModifier(valueDeclaration, ModifierFlagsPrivate)
		hasPrivateIdentifier := prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name)
		if !hasPrivateModifier && !hasPrivateIdentifier {
			return
		}
		if nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & SymbolFlagsSetAccessor) {
			return
		}
		if isSelfTypeAccess {
			containingMethod := findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration)
			if containingMethod && containingMethod.symbol == prop {
				return
			}
		}
		/* TODO(NonNullExpression): (getCheckFlags(prop) & CheckFlags.Instantiated ? getSymbolLinks(prop).target : prop)! */ TODO.isReferenced = SymbolFlagsAll
	}
	isSelfTypeAccess := func(name /* TODO(UnionType): Expression | QualifiedName */ any, parent *Symbol) /* TODO(undefined): boolean */ TODO {
		return name.kind == SyntaxKindThisKeyword || !!parent && isEntityNameExpression(name) && parent == getResolvedSymbol(getFirstIdentifier(name))
	}
	isValidPropertyAccess := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, propertyName __String) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.PropertyAccessExpression:                 return isValidPropertyAccessWithType(node, node.expression.kind === SyntaxKind.SuperKeyword, propertyName, getWidenedType(checkExpression(node.expression)));             case SyntaxKind.QualifiedName:                 return isValidPropertyAccessWithType(node, /*isSuper* / false, propertyName, getWidenedType(checkExpression(node.left)));             case SyntaxKind.ImportType:                 return isValidPropertyAccessWithType(node, /*isSuper* / false, propertyName, getTypeFromTypeNode(node));         } */
	}
	isValidPropertyAccessForCompletions := func(node /* TODO(UnionType): PropertyAccessExpression | ImportTypeNode | QualifiedName */ any, type_ Type, property Symbol) bool {
		return isPropertyAccessible(node, node.kind == SyntaxKindPropertyAccessExpression && node.expression.kind == SyntaxKindSuperKeyword, false, type_, property)
	}
	isValidPropertyAccessWithType := func(node /* TODO(UnionType): PropertyAccessExpression | QualifiedName | ImportTypeNode */ any, isSuper bool, propertyName __String, type_ Type) bool {
		if isTypeAny(type_) {
			return true
		}
		prop := getPropertyOfType(type_, propertyName)
		return !!prop && isPropertyAccessible(node, isSuper, false, type_, prop)
	}
	isPropertyAccessible := func(node Node, isSuper bool, isWrite bool, containingType Type, property Symbol) bool {
		if isTypeAny(containingType) {
			return true
		}
		if property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration) {
			declClass := getContainingClass(property.valueDeclaration)
			return !isOptionalChain(node) && !!findAncestor(node, func(parent /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): parent */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(Identifier): declClass */
			})
		}
		return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property)
	}
	getForInVariableSymbol := func(node ForInStatement) *Symbol {
		initializer := node.initializer
		if initializer.kind == SyntaxKindVariableDeclarationList {
			variable := /* TODO(ElementAccessExpression): (initializer as VariableDeclarationList).declarations[0] */ TODO
			if variable && !isBindingPattern(variable.name) {
				return getSymbolOfDeclaration(variable)
			}
		} else if initializer.kind == SyntaxKindIdentifier {
			return getResolvedSymbol(initializer /* as */ /* TODO(TypeReference): Identifier */)
		}
		return nil
	}
	hasNumericPropertyNames := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return getIndexInfosOfType(type_).length == 1 && !!getIndexInfoOfType(type_, numberType)
	}
	isForInVariableForNumericPropertyNames := func(expr Expression) /* TODO(undefined): boolean */ TODO {
		e := skipParentheses(expr)
		if e.kind == SyntaxKindIdentifier {
			symbol := getResolvedSymbol(e /* as */ /* TODO(TypeReference): Identifier */)
			if symbol.flags & SymbolFlagsVariable {
				var child Node = expr
				node := expr.parent
				/* TODO(WhileStatement): while (node) {                     if (                         node.kind === SyntaxKind.ForInStatement &&                         child === (node as ForInStatement).statement &&                         getForInVariableSymbol(node as ForInStatement) === symbol &&                         hasNumericPropertyNames(getTypeOfExpression((node as ForInStatement).expression))                     ) {                         return true;                     }                     child = node;                     node = node.parent;                 } */
			}
		}
		return false
	}
	checkIndexedAccess := func(node ElementAccessExpression, checkMode *CheckMode) Type {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkElementAccessChain(node as ElementAccessChain, checkMode) :             checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode) */ TODO
	}
	checkElementAccessChain := func(node ElementAccessChain, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		exprType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(exprType, node.expression)
		return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression), checkMode), node /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== exprType */, TODO)
	}
	checkElementAccessExpression := func(node ElementAccessExpression, exprType Type, checkMode *CheckMode) Type {
		objectType := /* TODO(ConditionalExpression): getAssignmentTargetKind(node) !== AssignmentKind.None || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType */ TODO
		indexExpression := node.argumentExpression
		indexType := checkExpression(indexExpression)
		if isErrorType(objectType) || objectType == silentNeverType {
			return objectType
		}
		if isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression) {
			error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal)
			return errorType
		}
		effectiveIndexType := /* TODO(ConditionalExpression): isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType */ TODO
		assignmentTargetKind := getAssignmentTargetKind(node)
		var accessFlags AccessFlags
		if assignmentTargetKind == AssignmentKindNone {
			accessFlags = AccessFlagsExpressionPosition
		} else {
			accessFlags = AccessFlagsWriting | ( /* TODO(ConditionalExpression): isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? AccessFlags.NoIndexSignatures : 0 */ TODO)
			if assignmentTargetKind == AssignmentKindCompound {
				accessFlags |= AccessFlagsExpressionPosition
			}
		}
		indexedAccessType := getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType
		return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node)
	}
	callLikeExpressionMayHaveTypeArguments := func(node CallLikeExpression) /* TODO(TypePredicate): node is CallExpression | NewExpression | TaggedTemplateExpression | JsxOpeningElement */ TODO {
		return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node)
	}
	resolveUntypedCall := func(node CallLikeExpression) Signature {
		if callLikeExpressionMayHaveTypeArguments(node) {
			forEach(node.typeArguments, checkSourceElement)
		}
		if node.kind == SyntaxKindTaggedTemplateExpression {
			checkExpression(node.template)
		} else if isJsxOpeningLikeElement(node) {
			checkExpression(node.attributes)
		} else if isBinaryExpression(node) {
			checkExpression(node.left)
		} else if isCallOrNewExpression(node) {
			forEach(node.arguments, func(argument /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO) {
				checkExpression(argument)
			})
		}
		return anySignature
	}
	resolveErrorCall := func(node CallLikeExpression) Signature {
		resolveUntypedCall(node)
		return unknownSignature
	}
	reorderCandidates := func(signatures []Signature, result []Signature, callChainFlags SignatureFlags) {
		var lastParent Node
		var lastSymbol *Symbol
		cutoffIndex := 0
		var index /* TODO(NumberKeyword): number */ any
		specializedIndex := -1
		var spliceIndex number
		Debug.assert(!result.length)
		for _, signature := range signatures {
			symbol := signature.declaration && getSymbolOfDeclaration(signature.declaration)
			parent := signature.declaration && signature.declaration.parent
			if !lastSymbol || symbol == lastSymbol {
				if lastParent && parent == lastParent {
					index = /* TODO(PlusToken): + */ /* TODO(BinaryExpression): index! + 1 */ TODO
				} else {
					lastParent = parent
					index = cutoffIndex
				}
			} else {
				index = /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): cutoffIndex = result.length */ TODO
				lastParent = parent
			}
			lastSymbol = symbol
			if signatureHasLiteralTypes(signature) {
				specializedIndex++
				spliceIndex = specializedIndex
				cutoffIndex++
			} else {
				spliceIndex = index
			}
			result.splice(spliceIndex, 0 /* TODO(ConditionalExpression): callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature */, TODO)
		}
	}
	isSpreadArgument := func(arg *Expression) /* TODO(TypePredicate): arg is Expression */ TODO {
		return !!arg && (arg.kind == SyntaxKindSpreadElement || arg.kind == SyntaxKindSyntheticExpression && (arg /* as */ /* TODO(TypeReference): SyntheticExpression */).isSpread)
	}
	getSpreadArgumentIndex := func(args []Expression) number {
		return findIndex(args, isSpreadArgument)
	}
	acceptsVoid := func(t Type) bool {
		return !!(t.flags & TypeFlagsVoid)
	}
	acceptsVoidUndefinedUnknownOrAny := func(t Type) bool {
		return !!(t.flags & (TypeFlagsVoid | TypeFlagsUndefined | TypeFlagsUnknown | TypeFlagsAny))
	}
	hasCorrectArity := func(node CallLikeExpression, args []Expression, signature Signature, signatureHelpTrailingComma /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): boolean */ TODO {
		var argCount number
		callIsIncomplete := false
		effectiveParameterCount := getParameterCount(signature)
		effectiveMinimumArguments := getMinArgumentCount(signature)
		if node.kind == SyntaxKindTaggedTemplateExpression {
			argCount = args.length
			if node.template.kind == SyntaxKindTemplateExpression {
				lastSpan := last(node.template.templateSpans)
				callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated
			} else {
				templateLiteral := node.template /* as */ /* TODO(TypeReference): LiteralExpression */
				Debug.assert(templateLiteral.kind == SyntaxKindNoSubstitutionTemplateLiteral)
				callIsIncomplete = !!templateLiteral.isUnterminated
			}
		} else if node.kind == SyntaxKindDecorator {
			argCount = getDecoratorArgumentCount(node, signature)
		} else if node.kind == SyntaxKindBinaryExpression {
			argCount = 1
		} else if isJsxOpeningLikeElement(node) {
			callIsIncomplete = node.attributes.end == node.end
			if callIsIncomplete {
				return true
			}
			argCount = /* TODO(ConditionalExpression): effectiveMinimumArguments === 0 ? args.length : 1 */ TODO
			effectiveParameterCount = /* TODO(ConditionalExpression): args.length === 0 ? effectiveParameterCount : 1 */ TODO
			effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1)
		} else if !node.arguments {
			Debug.assert(node.kind == SyntaxKindNewExpression)
			return getMinArgumentCount(signature) == 0
		} else {
			argCount = /* TODO(ConditionalExpression): signatureHelpTrailingComma ? args.length + 1 : args.length */ TODO
			callIsIncomplete = node.arguments.end == node.end
			spreadArgIndex := getSpreadArgumentIndex(args)
			if spreadArgIndex >= 0 {
				return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature))
			}
		}
		if !hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount {
			return false
		}
		if callIsIncomplete || argCount >= effectiveMinimumArguments {
			return true
		}
		/* TODO(ForStatement): for (let i = argCount; i < effectiveMinimumArguments; i++) {             const type = getTypeAtPosition(signature, i);             if (filterType(type, isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid).flags & TypeFlags.Never) {                 return false;             }         } */
		return true
	}
	hasCorrectTypeArgumentArity := func(signature Signature, typeArguments *NodeArray[TypeNode]) /* TODO(undefined): boolean */ TODO {
		numTypeParameters := length(signature.typeParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(signature.typeParameters)
		return !some(typeArguments) || (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters)
	}
	isInstantiatedGenericParameter := func(signature Signature, pos number) /* TODO(undefined): boolean */ TODO {
		var type_ TODO
		return !!(signature.target && ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): type = tryGetTypeAtPosition(signature.target, pos) */ TODO) && isGenericType(type_))
	}
	getSingleCallSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall, false)
	}
	getSingleCallOrConstructSignature := func(type_ Type) *Signature {
		return getSingleSignature(type_, SignatureKindCall, false) || getSingleSignature(type_, SignatureKindConstruct, false)
	}
	getSingleSignature := func(type_ Type, kind SignatureKind, allowMembers bool) *Signature {
		if type_.flags & TypeFlagsObject {
			resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
			if allowMembers || resolved.properties.length == 0 && resolved.indexInfos.length == 0 {
				if kind == SignatureKindCall && resolved.callSignatures.length == 1 && resolved.constructSignatures.length == 0 {
					return /* TODO(ElementAccessExpression): resolved.callSignatures[0] */ TODO
				}
				if kind == SignatureKindConstruct && resolved.constructSignatures.length == 1 && resolved.callSignatures.length == 0 {
					return /* TODO(ElementAccessExpression): resolved.constructSignatures[0] */ TODO
				}
			}
		}
		return nil
	}
	instantiateSignatureInContextOf := func(signature Signature, contextualSignature Signature, inferenceContext InferenceContext, compareTypes TypeComparer) Signature {
		context := createInferenceContext( /* TODO(NonNullExpression): getTypeParametersForMapper(signature)! */ TODO, signature, InferenceFlagsNone, compareTypes)
		restType := getEffectiveRestType(contextualSignature)
		mapper := inferenceContext && ( /* TODO(ConditionalExpression): restType && restType.flags & TypeFlags.TypeParameter ? inferenceContext.nonFixingMapper : inferenceContext.mapper */ TODO)
		sourceSignature := /* TODO(ConditionalExpression): mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature */ TODO
		applyToParameterTypes(sourceSignature, signature, func(source /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
			inferTypes(context.inferences, source, target)
		})
		if !inferenceContext {
			applyToReturnTypes(contextualSignature, signature, func(source /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
				inferTypes(context.inferences, source, target, InferencePriorityReturnType)
			})
		}
		return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration))
	}
	inferJsxTypeArguments := func(node JsxOpeningLikeElement, signature Signature, checkMode CheckMode, context InferenceContext) []Type {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		checkAttrType := checkExpressionWithContextualType(node.attributes, paramType, context, checkMode)
		inferTypes(context.inferences, checkAttrType, paramType)
		return getInferredTypes(context)
	}
	getThisArgumentType := func(thisArgumentNode *Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !thisArgumentNode {
			return voidType
		}
		thisArgumentType := checkExpression(thisArgumentNode)
		return /* TODO(ConditionalExpression): isRightSideOfInstanceofExpression(thisArgumentNode) ? thisArgumentType :             isOptionalChainRoot(thisArgumentNode.parent) ? getNonNullableType(thisArgumentType) :             isOptionalChain(thisArgumentNode.parent) ? removeOptionalTypeMarker(thisArgumentType) :             thisArgumentType */ TODO
	}
	inferTypeArguments := func(node CallLikeExpression, signature Signature, args []Expression, checkMode CheckMode, context InferenceContext) []Type {
		if isJsxOpeningLikeElement(node) {
			return inferJsxTypeArguments(node, signature, checkMode, context)
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.Decorator */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.BinaryExpression */ TODO {
			skipBindingPatterns := every(signature.typeParameters, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !getDefaultFromTypeParameter(p) */
			})
			contextualType := getContextualType(node /* TODO(ConditionalExpression): skipBindingPatterns ? ContextFlags.SkipBindingPatterns : ContextFlags.None */, TODO)
			if contextualType {
				inferenceTargetType := getReturnTypeOfSignature(signature)
				if couldContainTypeVariables(inferenceTargetType) {
					outerContext := getInferenceContext(node)
					isFromBindingPattern := !skipBindingPatterns && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getContextualType(node, ContextFlags.SkipBindingPatterns) !== contextualType */ TODO
					if !isFromBindingPattern {
						outerMapper := getMapperFromContext(cloneInferenceContext(outerContext, InferenceFlagsNoDefault))
						instantiatedType := instantiateType(contextualType, outerMapper)
						contextualSignature := getSingleCallSignature(instantiatedType)
						inferenceSourceType := /* TODO(ConditionalExpression): contextualSignature && contextualSignature.typeParameters ?                             getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) :                             instantiatedType */ TODO
						inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, InferencePriorityReturnType)
					}
					returnContext := createInferenceContext( /* TODO(NonNullExpression): signature.typeParameters! */ TODO, signature, context.flags)
					returnSourceType := instantiateType(contextualType, outerContext && outerContext.returnMapper)
					inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType)
					context.returnMapper = /* TODO(ConditionalExpression): some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : undefined */ TODO
				}
			}
		}
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		if restType && restType.flags&TypeFlagsTypeParameter {
			info := find(context.inferences, func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): info.typeParameter */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(Identifier): restType */
			})
			if info {
				info.impliedArity = /* TODO(ConditionalExpression): findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : undefined */ TODO
			}
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && couldContainTypeVariables(thisType) {
			thisArgumentNode := getThisArgumentOfCall(node)
			inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType)
		}
		/* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 if (couldContainTypeVariables(paramType)) {                     const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);                     inferTypes(context.inferences, argType, paramType);                 }             }         } */
		if restType && couldContainTypeVariables(restType) {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode)
			inferTypes(context.inferences, spreadType, restType)
		}
		return getInferredTypes(context)
	}
	getMutableArrayOrTupleType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, getMutableArrayOrTupleType) :             type.flags & TypeFlags.Any || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type :             isTupleType(type) ? createTupleType(getElementTypes(type), type.target.elementFlags, /*readonly* / false, type.target.labeledElementDeclarations) :             createTupleType([type], [ElementFlags.Variadic]) */ TODO
	}
	getSpreadArgumentType := func(args []Expression, index number, argCount number, restType Type, context *InferenceContext, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		inConstContext := isConstTypeVariable(restType)
		if index >= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): argCount - 1 */ TODO {
			arg := /* TODO(ElementAccessExpression): args[argCount - 1] */ TODO
			if isSpreadArgument(arg) {
				spreadType := /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type :                     checkExpressionWithContextualType((arg as SpreadElement).expression, restType, context, checkMode) */ TODO
				if isArrayLikeType(spreadType) {
					return getMutableArrayOrTupleType(spreadType)
				}
				return createArrayType(checkIteratedTypeOrElementType(IterationUseSpread, spreadType, undefinedType /* TODO(ConditionalExpression): arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg */, TODO), inConstContext)
			}
		}
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := /* TODO(ArrayLiteralExpression): [] */ TODO
		names := /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = index; i < argCount; i++) {             const arg = args[i];             if (isSpreadArgument(arg)) {                 const spreadType = arg.kind === SyntaxKind.SyntheticExpression ? (arg as SyntheticExpression).type : checkExpression((arg as SpreadElement).expression);                 if (isArrayLikeType(spreadType)) {                     types.push(spreadType);                     flags.push(ElementFlags.Variadic);                 }                 else {                     types.push(checkIteratedTypeOrElementType(IterationUse.Spread, spreadType, undefinedType, arg.kind === SyntaxKind.SpreadElement ? (arg as SpreadElement).expression : arg));                     flags.push(ElementFlags.Rest);                 }             }             else {                 const contextualType = isTupleType(restType) ?                     getContextualTypeForElementExpression(restType, i - index, argCount - index) || unknownType :                     getIndexedAccessType(restType, getNumberLiteralType(i - index), AccessFlags.Contextual);                 const argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);                 const hasPrimitiveContextualType = inConstContext || maybeTypeOfKind(contextualType, TypeFlags.Primitive | TypeFlags.Index | TypeFlags.TemplateLiteral | TypeFlags.StringMapping);                 types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));                 flags.push(ElementFlags.Required);             }             if (arg.kind === SyntaxKind.SyntheticExpression && (arg as SyntheticExpression).tupleNameSource) {                 names.push((arg as SyntheticExpression).tupleNameSource!);             }             else {                 names.push(undefined);             }         } */
		return createTupleType(types, flags, inConstContext && !someType(restType, isMutableArrayLikeType), names)
	}
	checkTypeArguments := func(signature Signature, typeArgumentNodes []TypeNode, reportErrors bool, headMessage DiagnosticMessage) /* TODO(ArrayType): Type[] */ any {
		isJavascript := isInJSFile(signature.declaration)
		typeParameters := /* TODO(NonNullExpression): signature.typeParameters! */ TODO
		typeArgumentTypes := fillMissingTypeArguments(map_(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript)
		var mapper *TypeMapper
		/* TODO(ForStatement): for (let i = 0; i < typeArgumentNodes.length; i++) {             Debug.assert(typeParameters[i] !== undefined, "Should not call checkTypeArguments with too many type arguments");             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 const errorInfo = reportErrors && headMessage ? (() => chainDiagnosticMessages(/*details* / undefined, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)) : undefined;                 const typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;                 if (!mapper) {                     mapper = createTypeMapper(typeParameters, typeArgumentTypes);                 }                 const typeArgument = typeArgumentTypes[i];                 if (                     !checkTypeAssignableTo(                         typeArgument,                         getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument),                         reportErrors ? typeArgumentNodes[i] : undefined,                         typeArgumentHeadMessage,                         errorInfo,                     )                 ) {                     return undefined;                 }             }         } */
		return typeArgumentTypes
	}
	getJsxReferenceKind := func(node JsxOpeningLikeElement) JsxReferenceKind {
		if isJsxIntrinsicTagName(node.tagName) {
			return JsxReferenceKindMixed
		}
		tagType := getApparentType(checkExpression(node.tagName))
		if length(getSignaturesOfType(tagType, SignatureKindConstruct)) {
			return JsxReferenceKindComponent
		}
		if length(getSignaturesOfType(tagType, SignatureKindCall)) {
			return JsxReferenceKindFunction
		}
		return JsxReferenceKindMixed
	}
	checkApplicableSignatureForJsxOpeningLikeElement := func(node JsxOpeningLikeElement, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO) /* TODO(undefined): boolean */ TODO {
		paramType := getEffectiveFirstArgumentForJsxSignature(signature, node)
		attributesType := checkExpressionWithContextualType(node.attributes, paramType, nil, checkMode)
		checkAttributesType := /* TODO(ConditionalExpression): checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(attributesType) : attributesType */ TODO
		return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(checkAttributesType, paramType, relation /* TODO(ConditionalExpression): reportErrors ? node.tagName : undefined */, TODO, node.attributes, nil, containingMessageChain, errorOutputContainer)
		checkTagNameDoesNotExpectTooManyArguments := func() bool {
			if getJsxNamespaceContainerForImplicitImport(node) {
				return true
			}
			tagType := /* TODO(ConditionalExpression): (isJsxOpeningElement(node) || isJsxSelfClosingElement(node)) && !(isJsxIntrinsicTagName(node.tagName) || isJsxNamespacedName(node.tagName)) ? checkExpression(node.tagName) : undefined */ TODO
			if !tagType {
				return true
			}
			tagCallSignatures := getSignaturesOfType(tagType, SignatureKindCall)
			if !length(tagCallSignatures) {
				return true
			}
			factory := getJsxFactoryEntity(node)
			if !factory {
				return true
			}
			factorySymbol := resolveEntityName(factory, SymbolFlagsValue, true, false, node)
			if !factorySymbol {
				return true
			}
			factoryType := getTypeOfSymbol(factorySymbol)
			callSignatures := getSignaturesOfType(factoryType, SignatureKindCall)
			if !length(callSignatures) {
				return true
			}
			hasFirstParamSignatures := false
			maxParamCount := 0
			for _, sig := range callSignatures {
				firstparam := getTypeAtPosition(sig, 0)
				signaturesOfParam := getSignaturesOfType(firstparam, SignatureKindCall)
				if !length(signaturesOfParam) {
				}
				for _, paramSig := range signaturesOfParam {
					hasFirstParamSignatures = true
					if hasEffectiveRestParameter(paramSig) {
						return true
					}
					paramCount := getParameterCount(paramSig)
					if paramCount > maxParamCount {
						maxParamCount = paramCount
					}
				}
			}
			if !hasFirstParamSignatures {
				return true
			}
			absoluteMinArgCount := Infinity
			for _, tagSig := range tagCallSignatures {
				tagRequiredArgCount := getMinArgumentCount(tagSig)
				if tagRequiredArgCount < absoluteMinArgCount {
					absoluteMinArgCount = tagRequiredArgCount
				}
			}
			if absoluteMinArgCount <= maxParamCount {
				return true
			}
			if reportErrors {
				diag := createDiagnosticForNode(node.tagName, Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, entityNameToString(node.tagName), absoluteMinArgCount, entityNameToString(factory), maxParamCount)
				tagNameDeclaration := getSymbolAtLocation(node.tagName).valueDeclaration
				if tagNameDeclaration {
					addRelatedInfo(diag, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(node.tagName)))
				}
				if errorOutputContainer && errorOutputContainer.skipLogging {
					(errorOutputContainer.errors || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): errorOutputContainer.errors = [] */ TODO)).push(diag)
				}
				if !errorOutputContainer.skipLogging {
					diagnostics.add(diag)
				}
			}
			return false
		}
	}
	getEffectiveCheckNode := func(argument Expression) Expression {
		argument = skipParentheses(argument)
		return /* TODO(ConditionalExpression): isSatisfiesExpression(argument) ? skipParentheses(argument.expression) : argument */ TODO
	}
	getSignatureApplicabilityError := func(node CallLikeExpression, args []Expression, signature Signature, relation Map[string, RelationComparisonResult], checkMode CheckMode, reportErrors bool, containingMessageChain /* TODO(ParenthesizedType): (() => DiagnosticMessageChain | undefined) */ any, inferenceContext *InferenceContext) /* TODO(TypeOperator): readonly Diagnostic[] */ any {
		var errorOutputContainer /* TODO(TypeLiteral): { errors?: Diagnostic[]; skipLogging?: boolean; } */ TODO = /* TODO(ObjectLiteralExpression): { errors: undefined, skipLogging: true } */ TODO
		if isJsxOpeningLikeElement(node) {
			if !checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "jsx should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
			return nil
		}
		thisType := getThisTypeOfSignature(signature)
		if thisType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): thisType !== voidType */ TODO && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression)) {
			thisArgumentNode := getThisArgumentOfCall(node)
			thisArgumentType := getThisArgumentType(thisArgumentNode)
			errorNode := /* TODO(ConditionalExpression): reportErrors ? (thisArgumentNode || node) : undefined */ TODO
			headMessage := Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1
			if !checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors")
				return errorOutputContainer.errors || emptyArray
			}
		}
		headMessage := Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1
		restType := getNonArrayRestType(signature)
		argCount := /* TODO(ConditionalExpression): restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length */ TODO
		/* TODO(ForStatement): for (let i = 0; i < argCount; i++) {             const arg = args[i];             if (arg.kind !== SyntaxKind.OmittedExpression) {                 const paramType = getTypeAtPosition(signature, i);                 const argType = checkExpressionWithContextualType(arg, paramType, /*inferenceContext* / undefined, checkMode);                 // If one or more arguments are still excluded (as indicated by CheckMode.SkipContextSensitive),                 // we obtain the regular type of any object literal arguments because we may not have inferred complete                 // parameter types yet and therefore excess property checks may yield false positives (see #17041).                 const regularArgType = checkMode & CheckMode.SkipContextSensitive ? getRegularTypeOfObjectLiteral(argType) : argType;                 // If this was inferred under a given inference context, we may need to instantiate the expression type to finish resolving                 // the type variables in the expression.                 const checkArgType = inferenceContext ? instantiateType(regularArgType, inferenceContext.nonFixingMapper) : regularArgType;                 const effectiveCheckArgumentNode = getEffectiveCheckNode(arg);                 if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors ? effectiveCheckArgumentNode : undefined, effectiveCheckArgumentNode, headMessage, containingMessageChain, errorOutputContainer)) {                     Debug.assert(!reportErrors || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");                     maybeAddMissingAwaitInfo(arg, checkArgType, paramType);                     return errorOutputContainer.errors || emptyArray;                 }             }         } */
		if restType {
			spreadType := getSpreadArgumentType(args, argCount, args.length, restType, nil, checkMode)
			restArgCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): args.length - argCount */ TODO
			errorNode := /* TODO(ConditionalExpression): !reportErrors ? undefined :                 restArgCount === 0 ? node :                 restArgCount === 1 ? getEffectiveCheckNode(args[argCount]) :                 setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end) */ TODO
			if !checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, nil, errorOutputContainer) {
				Debug.assert(!reportErrors || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors")
				maybeAddMissingAwaitInfo(errorNode, spreadType, restType)
				return errorOutputContainer.errors || emptyArray
			}
		}
		return nil
		maybeAddMissingAwaitInfo := func(errorNode Node, source Type, target Type) {
			if errorNode && reportErrors && errorOutputContainer.errors && errorOutputContainer.errors.length {
				if getAwaitedTypeOfPromise(target) {
					return
				}
				awaitedTypeOfSource := getAwaitedTypeOfPromise(source)
				if awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation) {
					addRelatedInfo( /* TODO(ElementAccessExpression): errorOutputContainer.errors[0] */ TODO, createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await))
				}
			}
		}
	}
	getThisArgumentOfCall := func(node CallLikeExpression) *Expression {
		if node.kind == SyntaxKindBinaryExpression {
			return node.right
		}
		expression := /* TODO(ConditionalExpression): node.kind === SyntaxKind.CallExpression ? node.expression :             node.kind === SyntaxKind.TaggedTemplateExpression ? node.tag :             node.kind === SyntaxKind.Decorator && !legacyDecorators ? node.expression :             undefined */ TODO
		if expression {
			callee := skipOuterExpressions(expression)
			if isAccessExpression(callee) {
				return callee.expression
			}
		}
	}
	createSyntheticExpression := func(parent Node, type_ Type, isSpread bool, tupleNameSource /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SyntheticExpression */ TODO {
		result := parseNodeFactory.createSyntheticExpression(type_, isSpread, tupleNameSource)
		setTextRangeWorker(result, parent)
		setParent(result, parent)
		return result
	}
	getEffectiveCallArguments := func(node CallLikeExpression) []Expression {
		if node.kind == SyntaxKindTaggedTemplateExpression {
			template := node.template
			var args []Expression = /* TODO(ArrayLiteralExpression): [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())] */ TODO
			if template.kind == SyntaxKindTemplateExpression {
				forEach(template.templateSpans, func(span /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TemplateSpan */ TODO) {
					args.push(span.expression)
				})
			}
			return args
		}
		if node.kind == SyntaxKindDecorator {
			return getEffectiveDecoratorArguments(node)
		}
		if node.kind == SyntaxKindBinaryExpression {
			return /* TODO(ArrayLiteralExpression): [node.left] */ TODO
		}
		if isJsxOpeningLikeElement(node) {
			return /* TODO(ConditionalExpression): node.attributes.properties.length > 0 || (isJsxOpeningElement(node) && node.parent.children.length > 0) ? [node.attributes] : emptyArray */ TODO
		}
		args := node.arguments || emptyArray
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex >= 0 {
			effectiveArgs := args.slice(0, spreadIndex)
			/* TODO(ForStatement): for (let i = spreadIndex; i < args.length; i++) {                 const arg = args[i];                 // We can call checkExpressionCached because spread expressions never have a contextual type.                 const spreadType = arg.kind === SyntaxKind.SpreadElement && (flowLoopCount ? checkExpression((arg as SpreadElement).expression) : checkExpressionCached((arg as SpreadElement).expression));                 if (spreadType && isTupleType(spreadType)) {                     forEach(getElementTypes(spreadType), (t, i) => {                         const flags = spreadType.target.elementFlags[i];                         const syntheticArg = createSyntheticExpression(arg, flags & ElementFlags.Rest ? createArrayType(t) : t, !!(flags & ElementFlags.Variable), spreadType.target.labeledElementDeclarations?.[i]);                         effectiveArgs.push(syntheticArg);                     });                 }                 else {                     effectiveArgs.push(arg);                 }             } */
			return effectiveArgs
		}
		return args
	}
	getEffectiveDecoratorArguments := func(node Decorator) []Expression {
		expr := node.expression
		signature := getDecoratorCallSignature(node)
		if signature {
			var args []Expression = /* TODO(ArrayLiteralExpression): [] */ TODO
			for _, param := range signature.parameters {
				type_ := getTypeOfSymbol(param)
				args.push(createSyntheticExpression(expr, type_))
			}
			return args
		}
		return Debug.fail()
	}
	getDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO(undefined): number */ TODO {
		return /* TODO(ConditionalExpression): compilerOptions.experimentalDecorators ?             getLegacyDecoratorArgumentCount(node, signature) :             // Allow the runtime to oversupply arguments to an ES decorator as long as there's at least one parameter.             Math.min(Math.max(getParameterCount(signature), 1), 2) */ TODO
	}
	getLegacyDecoratorArgumentCount := func(node Decorator, signature Signature) /* TODO(undefined): 1 | 2 | 3 */ TODO {
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 return 1;             case SyntaxKind.PropertyDeclaration:                 return hasAccessorModifier(node.parent) ? 3 : 2;             case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 // For decorators with only two parameters we supply only two arguments                 return signature.parameters.length <= 2 ? 2 : 3;             case SyntaxKind.Parameter:                 return 3;             default:                 return Debug.fail();         } */
	}
	getDiagnosticSpanForCallNode := func(node CallExpression) /* TODO(undefined): { start: number; length: number; sourceFile: import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile; } */ TODO {
		sourceFile := getSourceFileOfNode(node)
		TODO_IDENTIFIER := getErrorSpanForNode(sourceFile /* TODO(ConditionalExpression): isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression */, TODO)
		return /* TODO(ObjectLiteralExpression): { start, length, sourceFile } */ TODO
	}
	getDiagnosticForCallNode := func(node CallLikeExpression, message /* TODO(UnionType): DiagnosticMessage | DiagnosticMessageChain */ any, args DiagnosticArguments) DiagnosticWithLocation {
		if isCallExpression(node) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(node)
			if /* TODO(InKeyword): in */ /* TODO(BinaryExpression): "message" in message */ TODO {
				return createFileDiagnostic(sourceFile, start, length, message /* TODO(SpreadElement): ...args */, TODO)
			}
			return createDiagnosticForFileFromMessageChain(sourceFile, message)
		} else {
			if /* TODO(InKeyword): in */ /* TODO(BinaryExpression): "message" in message */ TODO {
				return createDiagnosticForNode(node, message /* TODO(SpreadElement): ...args */, TODO)
			}
			return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message)
		}
	}
	getErrorNodeForCallNode := func(callLike CallLikeExpression) Node {
		if isCallOrNewExpression(callLike) {
			return /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.expression) ? callLike.expression.name : callLike.expression */ TODO
		}
		if isTaggedTemplateExpression(callLike) {
			return /* TODO(ConditionalExpression): isPropertyAccessExpression(callLike.tag) ? callLike.tag.name : callLike.tag */ TODO
		}
		if isJsxOpeningLikeElement(callLike) {
			return callLike.tagName
		}
		return callLike
	}
	isPromiseResolveArityError := func(node CallLikeExpression) /* TODO(undefined): boolean */ TODO {
		if !isCallExpression(node) || !isIdentifier(node.expression) {
			/* TODO(FalseKeyword): false */
		}
		symbol := resolveName(node.expression, node.expression.escapedText, SymbolFlagsValue, nil, false)
		decl := symbol.valueDeclaration
		if !decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression) {
			return false
		}
		globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
		if !globalPromiseSymbol {
			/* TODO(FalseKeyword): false */
		}
		constructorSymbol := getSymbolAtLocation(decl.parent.parent.expression, true)
		return constructorSymbol == globalPromiseSymbol
	}
	getArgumentArityError := func(node CallLikeExpression, signatures []Signature, args []Expression, headMessage DiagnosticMessage) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic */ TODO {
		spreadIndex := getSpreadArgumentIndex(args)
		if spreadIndex > -1 {
			return createDiagnosticForNode( /* TODO(ElementAccessExpression): args[spreadIndex] */ TODO, Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter)
		}
		min := Number.POSITIVE_INFINITY
		max := Number.NEGATIVE_INFINITY
		maxBelow := Number.NEGATIVE_INFINITY
		minAbove := Number.POSITIVE_INFINITY
		var closestSignature *Signature
		for _, sig := range signatures {
			minParameter := getMinArgumentCount(sig)
			maxParameter := getParameterCount(sig)
			if minParameter < min {
				min = minParameter
				closestSignature = sig
			}
			max = Math.max(max, maxParameter)
			if minParameter < args.length && minParameter > maxBelow {
				/* TODO(BinaryExpression): maxBelow = minParameter */
			}
			if args.length < maxParameter && maxParameter < minAbove {
				/* TODO(BinaryExpression): minAbove = maxParameter */
			}
		}
		hasRestParameter := some(signatures, hasEffectiveRestParameter)
		parameterRange := /* TODO(ConditionalExpression): hasRestParameter ? min             : min < max ? min + "-" + max             : min */ TODO
		isVoidPromiseError := !hasRestParameter && parameterRange == 1 && args.length == 0 && isPromiseResolveArityError(node)
		if isVoidPromiseError && isInJSFile(node) {
			return getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments)
		}
		error := /* TODO(ConditionalExpression): isDecorator(node) ?             hasRestParameter ? Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 :                 Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 :             hasRestParameter ? Diagnostics.Expected_at_least_0_arguments_but_got_1 :             isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise :             Diagnostics.Expected_0_arguments_but_got_1 */ TODO
		if min < args.length && args.length < max {
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
				chain = chainDiagnosticMessages(chain, headMessage)
				return getDiagnosticForCallNode(node, chain)
			}
			return getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove)
		} else if args.length < min {
			var diagnostic Diagnostic
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				diagnostic = getDiagnosticForCallNode(node, chain)
			} else {
				diagnostic = getDiagnosticForCallNode(node, error, parameterRange, args.length)
			}
			parameter := /* TODO(ElementAccessExpression): closestSignature?.declaration?.parameters[closestSignature.thisParameter ? args.length + 1 : args.length] */ TODO
			if parameter {
				var messageAndArgs DiagnosticAndArguments = /* TODO(ConditionalExpression): isBindingPattern(parameter.name) ? [Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided]                     : isRestParameter(parameter) ? [Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided, idText(getFirstIdentifier(parameter.name))]                     : [Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : idText(getFirstIdentifier(parameter.name))] */ TODO
				parameterError := createDiagnosticForNode(parameter /* TODO(SpreadElement): ...messageAndArgs */, TODO)
				return addRelatedInfo(diagnostic, parameterError)
			}
			return diagnostic
		} else {
			errorSpan := factory.createNodeArray(args.slice(max))
			pos := first(errorSpan).pos
			end := last(errorSpan).end
			if end == pos {
				end++
			}
			setTextRangePosEnd(errorSpan, pos, end)
			if headMessage {
				chain := chainDiagnosticMessages(nil, error, parameterRange, args.length)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error, parameterRange, args.length)
		}
	}
	getTypeArgumentArityError := func(node Node, signatures []Signature, typeArguments NodeArray[TypeNode], headMessage DiagnosticMessage) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
		argCount := typeArguments.length
		if signatures.length == 1 {
			sig := /* TODO(ElementAccessExpression): signatures[0] */ TODO
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): min < max ? min + "-" + max : min */, TODO, argCount)
		}
		belowArgCount := -Infinity
		aboveArgCount := Infinity
		for _, sig := range signatures {
			min := getMinTypeArgumentCount(sig.typeParameters)
			max := length(sig.typeParameters)
			if min > argCount {
				aboveArgCount = Math.min(aboveArgCount, min)
			} else if max < argCount {
				belowArgCount = Math.max(belowArgCount, max)
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): belowArgCount !== -Infinity */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): aboveArgCount !== Infinity */ TODO {
			if headMessage {
				chain := chainDiagnosticMessages(nil, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
				chain = chainDiagnosticMessages(chain, headMessage)
				return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
			}
			return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount)
		}
		if headMessage {
			chain := chainDiagnosticMessages(nil, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
			chain = chainDiagnosticMessages(chain, headMessage)
			return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain)
		}
		return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1 /* TODO(ConditionalExpression): belowArgCount === -Infinity ? aboveArgCount : belowArgCount */, TODO, argCount)
	}
	resolveCall := func(node CallLikeExpression, signatures []Signature, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode, callChainFlags SignatureFlags, headMessage DiagnosticMessage) Signature {
		isTaggedTemplate := node.kind == SyntaxKindTaggedTemplateExpression
		isDecorator := node.kind == SyntaxKindDecorator
		isJsxOpeningOrSelfClosingElement := isJsxOpeningLikeElement(node)
		isInstanceof := node.kind == SyntaxKindBinaryExpression
		reportErrors := !isInferencePartiallyBlocked && !candidatesOutArray
		var typeArguments *NodeArray[TypeNode]
		if !isDecorator && !isInstanceof && !isSuperCall(node) {
			typeArguments = (node /* as */ /* TODO(TypeReference): CallExpression */).typeArguments
			if isTaggedTemplate || isJsxOpeningOrSelfClosingElement || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (node as CallExpression).expression.kind !== SyntaxKind.SuperKeyword */ TODO {
				forEach(typeArguments, checkSourceElement)
			}
		}
		candidates := candidatesOutArray || /* TODO(ArrayLiteralExpression): [] */ TODO
		reorderCandidates(signatures, candidates, callChainFlags)
		Debug.assert(candidates.length, "Revert #54442 and add a testcase with whatever triggered this")
		args := getEffectiveCallArguments(node)
		isSingleNonGenericCandidate := candidates.length == 1 && ! /* TODO(ElementAccessExpression): candidates[0] */ TODO.typeParameters
		argCheckMode := /* TODO(ConditionalExpression): !isDecorator && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? CheckMode.SkipContextSensitive : CheckMode.Normal */ TODO
		var candidatesForArgumentError /* TODO(ArrayType): Signature[] */ any
		var candidateForArgumentArityError *Signature
		var candidateForTypeArgumentError *Signature
		var result *Signature
		signatureHelpTrailingComma := !!(checkMode & CheckModeIsForSignatureHelp) && node.kind == SyntaxKindCallExpression && node.arguments.hasTrailingComma
		if candidates.length > 1 {
			result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if !result {
			result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma)
		}
		if result {
			return result
		}
		result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode)
		getNodeLinks(node).resolvedSignature = result
		if reportErrors {
			if !headMessage && isInstanceof {
				headMessage = Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method
			}
			if candidatesForArgumentError {
				if candidatesForArgumentError.length == 1 || candidatesForArgumentError.length > 3 {
					last := /* TODO(ElementAccessExpression): candidatesForArgumentError[candidatesForArgumentError.length - 1] */ TODO
					var chain *DiagnosticMessageChain
					if candidatesForArgumentError.length > 3 {
						chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error)
						chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call)
					}
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					diags := getSignatureApplicabilityError(node, args, last, assignableRelation, CheckModeNormal, true, func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
					}, nil)
					if diags {
						for _, d := range diags {
							if last.declaration && candidatesForArgumentError.length > 3 {
								addRelatedInfo(d, createDiagnosticForNode(last.declaration, Diagnostics.The_last_overload_is_declared_here))
							}
							addImplementationSuccessElaboration(last, d)
							diagnostics.add(d)
						}
					} else {
						Debug.fail("No error for last overload signature")
					}
				} else {
					var allDiagnostics [][]DiagnosticRelatedInformation = /* TODO(ArrayLiteralExpression): [] */ TODO
					max := 0
					min := Number.MAX_VALUE
					minIndex := 0
					i := 0
					for _, c := range candidatesForArgumentError {
						chain := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
							/* TODO(Identifier): chainDiagnosticMessages */
							/* TODO(Identifier): undefined */
							/* TODO(PropertyAccessExpression): Diagnostics.Overload_0_of_1_2_gave_the_following_error */
							/* TODO(BinaryExpression): i + 1 */
							/* TODO(PropertyAccessExpression): candidates.length */
							/* TODO(CallExpression): signatureToString(c) */
						}
						diags := getSignatureApplicabilityError(node, args, c, assignableRelation, CheckModeNormal, true, chain, nil)
						if diags {
							if diags.length <= min {
								min = diags.length
								minIndex = i
							}
							max = Math.max(max, diags.length)
							allDiagnostics.push(diags)
						} else {
							Debug.fail("No error for 3 or fewer overload signatures")
						}
						i++
					}
					diags := /* TODO(ConditionalExpression): max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics) */ TODO
					Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures")
					chain := chainDiagnosticMessages(map_(diags, createDiagnosticMessageChainFromDiagnostic), Diagnostics.No_overload_matches_this_call)
					if headMessage {
						chain = chainDiagnosticMessages(chain, headMessage)
					}
					related := /* TODO(ArrayLiteralExpression): [...flatMap(diags, d => (d as Diagnostic).relatedInformation) as DiagnosticRelatedInformation[]] */ TODO
					var diag Diagnostic
					if every(diags, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticRelatedInformation */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(BinaryExpression): d.start === diags[0].start && d.length === diags[0].length */
						/* TODO(AmpersandAmpersandToken): && */
						/* TODO(BinaryExpression): d.file === diags[0].file */
					}) {
						TODO_IDENTIFIER := /* TODO(ElementAccessExpression): diags[0] */ TODO
						diag = /* TODO(ObjectLiteralExpression): { file, start, length, code: chain.code, category: chain.category, messageText: chain, relatedInformation: related } */ TODO
					} else {
						diag = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), getErrorNodeForCallNode(node), chain, related)
					}
					addImplementationSuccessElaboration( /* TODO(ElementAccessExpression): candidatesForArgumentError[0] */ TODO, diag)
					diagnostics.add(diag)
				}
			} else if candidateForArgumentArityError {
				diagnostics.add(getArgumentArityError(node /* TODO(ArrayLiteralExpression): [candidateForArgumentArityError] */, TODO, args, headMessage))
			} else if candidateForTypeArgumentError {
				checkTypeArguments(candidateForTypeArgumentError /* TODO(NonNullExpression): (node as CallExpression | TaggedTemplateExpression | JsxOpeningLikeElement).typeArguments! */, TODO, true, headMessage)
			} else {
				signaturesWithCorrectTypeArgumentArity := filter(signatures, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): hasCorrectTypeArgumentArity */
					/* TODO(Identifier): s */
					/* TODO(Identifier): typeArguments */
				})
				if signaturesWithCorrectTypeArgumentArity.length == 0 {
					diagnostics.add(getTypeArgumentArityError(node, signatures /* TODO(NonNullExpression): typeArguments! */, TODO, headMessage))
				} else {
					diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage))
				}
			}
		}
		return result
		addImplementationSuccessElaboration := func(failed Signature, diagnostic Diagnostic) {
			oldCandidatesForArgumentError := candidatesForArgumentError
			oldCandidateForArgumentArityError := candidateForArgumentArityError
			oldCandidateForTypeArgumentError := candidateForTypeArgumentError
			failedSignatureDeclarations := failed.declaration.symbol.declarations || emptyArray
			isOverload := failedSignatureDeclarations.length > 1
			implDecl := /* TODO(ConditionalExpression): isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : undefined */ TODO
			if implDecl {
				candidate := getSignatureFromDeclaration(implDecl /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
				isSingleNonGenericCandidate := !candidate.typeParameters
				if chooseOverload( /* TODO(ArrayLiteralExpression): [candidate] */ TODO, assignableRelation, isSingleNonGenericCandidate) {
					addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible))
				}
			}
			candidatesForArgumentError = oldCandidatesForArgumentError
			candidateForArgumentArityError = oldCandidateForArgumentArityError
			candidateForTypeArgumentError = oldCandidateForTypeArgumentError
		}
		chooseOverload := func(candidates []Signature, relation Map[string, RelationComparisonResult], isSingleNonGenericCandidate bool, signatureHelpTrailingComma /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
			candidatesForArgumentError = nil
			candidateForArgumentArityError = nil
			candidateForTypeArgumentError = nil
			if isSingleNonGenericCandidate {
				candidate := /* TODO(ElementAccessExpression): candidates[0] */ TODO
				if some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma) {
					return nil
				}
				if getSignatureApplicabilityError(node, args, candidate, relation, CheckModeNormal, false, nil, nil) {
					candidatesForArgumentError = /* TODO(ArrayLiteralExpression): [candidate] */ TODO
					return nil
				}
				return candidate
			}
			/* TODO(ForStatement): for (let candidateIndex = 0; candidateIndex < candidates.length; candidateIndex++) {                 let candidate = candidates[candidateIndex];                 if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma)) {                     continue;                 }                  let checkCandidate: Signature;                 let inferenceContext: InferenceContext | undefined;                  if (candidate.typeParameters) {                     // If we are *inside the body of candidate*, we need to create a clone of `candidate` with differing type parameter identities,                     // so our inference results for this call doesn't pollute expression types referencing the outer type parameter!                     const paramLocation = candidate.typeParameters[0].symbol.declarations?.[0]?.parent;                     const candidateParameterContext = paramLocation || (candidate.declaration && isConstructorDeclaration(candidate.declaration) ? candidate.declaration.parent : candidate.declaration);                     if (candidateParameterContext && findAncestor(node, a => a === candidateParameterContext)) {                         candidate = getImplementationSignature(candidate);                     }                     let typeArgumentTypes: readonly Type[] | undefined;                     if (some(typeArguments)) {                         typeArgumentTypes = checkTypeArguments(candidate, typeArguments, /*reportErrors* / false);                         if (!typeArgumentTypes) {                             candidateForTypeArgumentError = candidate;                             continue;                         }                     }                     else {                         inferenceContext = createInferenceContext(candidate.typeParameters!, candidate, /*flags* / isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None);                         // The resulting type arguments are instantiated with the inference context mapper, as the inferred types may still contain references to the inference context's                         //  type variables via contextual projection. These are kept generic until all inferences are locked in, so the dependencies expressed can pass constraint checks.                         typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode | CheckMode.SkipGenericFunctions, inferenceContext), inferenceContext.nonFixingMapper);                         argCheckMode |= inferenceContext.flags & InferenceFlags.SkippedGenericFunction ? CheckMode.SkipGenericFunctions : CheckMode.Normal;                     }                     checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);                     // If the original signature has a generic rest type, instantiation may produce a                     // signature with different arity and we need to perform another arity check.                     if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                         candidateForArgumentArityError = checkCandidate;                         continue;                     }                 }                 else {                     checkCandidate = candidate;                 }                 if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                     // Give preference to error candidates that have no rest parameters (as they are more specific)                     (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                     continue;                 }                 if (argCheckMode) {                     // If one or more context sensitive arguments were excluded, we start including                     // them now (and keeping do so for any subsequent candidates) and perform a second                     // round of type inference and applicability checking for this particular candidate.                     argCheckMode = CheckMode.Normal;                     if (inferenceContext) {                         const typeArgumentTypes = instantiateTypes(inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext), inferenceContext.mapper);                         checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters);                         // If the original signature has a generic rest type, instantiation may produce a                         // signature with different arity and we need to perform another arity check.                         if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma)) {                             candidateForArgumentArityError = checkCandidate;                             continue;                         }                     }                     if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, /*reportErrors* / false, /*containingMessageChain* / undefined, inferenceContext)) {                         // Give preference to error candidates that have no rest parameters (as they are more specific)                         (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);                         continue;                     }                 }                 candidates[candidateIndex] = checkCandidate;                 return checkCandidate;             } */
			return nil
		}
	}
	getCandidateForOverloadFailure := func(node CallLikeExpression, candidates []Signature, args []Expression, hasCandidatesOutArray bool, checkMode CheckMode) Signature {
		Debug.assert(candidates.length > 0)
		checkNodeDeferred(node)
		return /* TODO(ConditionalExpression): hasCandidatesOutArray || candidates.length === 1 || candidates.some(c => !!c.typeParameters)             ? pickLongestCandidateSignature(node, candidates, args, checkMode)             : createUnionOfSignaturesForOverloadFailure(candidates) */ TODO
	}
	createUnionOfSignaturesForOverloadFailure := func(candidates []Signature) Signature {
		thisParameters := mapDefined(candidates, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			/* TODO(Identifier): c */
			/* TODO(Identifier): thisParameter */
		})
		var thisParameter *Symbol
		if thisParameters.length {
			thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map_(getTypeOfParameter))
		}
		TODO_IDENTIFIER := minAndMax(candidates, getNumNonRestParameters)
		var parameters []Symbol = /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = 0; i < maxNonRestParam; i++) {             const symbols = mapDefined(candidates, s =>                 signatureHasRestParameter(s) ?                     i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) :                     i < s.parameters.length ? s.parameters[i] : undefined);             Debug.assert(symbols.length !== 0);             parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, candidate => tryGetTypeAtPosition(candidate, i))));         } */
		restParameterSymbols := mapDefined(candidates, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
			/* TODO(CallExpression): signatureHasRestParameter(c) */
			/* TODO(QuestionToken): ? */
			/* TODO(CallExpression): last(c.parameters) */
			/* TODO(ColonToken): : */
			/* TODO(Identifier): undefined */
		})
		flags := SignatureFlagsIsSignatureCandidateForOverloadFailure
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): restParameterSymbols.length !== 0 */ TODO {
			type_ := createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), UnionReductionSubtype))
			parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type_))
			flags |= SignatureFlagsHasRestParameter
		}
		if candidates.some(signatureHasLiteralTypes) {
			flags |= SignatureFlagsHasLiteralTypes
		}
		return createSignature( /* TODO(ElementAccessExpression): candidates[0] */ TODO.declaration, nil, thisParameter, parameters, getIntersectionType(candidates.map_(getReturnTypeOfSignature)), nil, minArgumentCount, flags)
	}
	getNumNonRestParameters := func(signature Signature) number {
		numParams := signature.parameters.length
		return /* TODO(ConditionalExpression): signatureHasRestParameter(signature) ? numParams - 1 : numParams */ TODO
	}
	createCombinedSymbolFromTypes := func(sources []Symbol, types []Type) Symbol {
		return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, UnionReductionSubtype))
	}
	createCombinedSymbolForOverloadFailure := func(sources []Symbol, type_ Type) Symbol {
		return createSymbolWithType(first(sources), type_)
	}
	pickLongestCandidateSignature := func(node CallLikeExpression, candidates []Signature, args []Expression, checkMode CheckMode) Signature {
		bestIndex := getLongestCandidateIndex(candidates /* TODO(ConditionalExpression): apparentArgumentCount === undefined ? args.length : apparentArgumentCount */, TODO)
		candidate := /* TODO(ElementAccessExpression): candidates[bestIndex] */ TODO
		TODO_IDENTIFIER := candidate
		if !typeParameters {
			return candidate
		}
		var typeArgumentNodes /* TODO(TypeOperator): readonly TypeNode[] */ any = /* TODO(ConditionalExpression): callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : undefined */ TODO
		instantiated := /* TODO(ConditionalExpression): typeArgumentNodes             ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node)))             : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode) */ TODO
		/* TODO(ElementAccessExpression): candidates[bestIndex] */ TODO = instantiated
		return instantiated
	}
	getTypeArgumentsFromNodes := func(typeArgumentNodes []TypeNode, typeParameters []TypeParameter, isJs bool) []Type {
		typeArguments := typeArgumentNodes.map_(getTypeOfNode)
		/* TODO(WhileStatement): while (typeArguments.length > typeParameters.length) {             typeArguments.pop();         } */
		/* TODO(WhileStatement): while (typeArguments.length < typeParameters.length) {             typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));         } */
		return typeArguments
	}
	inferSignatureInstantiationForOverloadFailure := func(node CallLikeExpression, typeParameters []TypeParameter, candidate Signature, args []Expression, checkMode CheckMode) Signature {
		inferenceContext := createInferenceContext(typeParameters, candidate /* TODO(ConditionalExpression): isInJSFile(node) ? InferenceFlags.AnyDefault : InferenceFlags.None */, TODO)
		typeArgumentTypes := inferTypeArguments(node, candidate, args, checkMode|CheckModeSkipContextSensitive|CheckModeSkipGenericFunctions, inferenceContext)
		return createSignatureInstantiation(candidate, typeArgumentTypes)
	}
	getLongestCandidateIndex := func(candidates []Signature, argsCount number) number {
		maxParamsIndex := -1
		maxParams := -1
		/* TODO(ForStatement): for (let i = 0; i < candidates.length; i++) {             const candidate = candidates[i];             const paramCount = getParameterCount(candidate);             if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {                 return i;             }             if (paramCount > maxParams) {                 maxParams = paramCount;                 maxParamsIndex = i;             }         } */
		return maxParamsIndex
	}
	resolveCallExpression := func(node CallExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		if node.expression.kind == SyntaxKindSuperKeyword {
			superType := checkSuperExpression(node.expression)
			if isTypeAny(superType) {
				for _, arg := range node.arguments {
					checkExpression(arg)
				}
				return anySignature
			}
			if !isErrorType(superType) {
				baseTypeNode := getEffectiveBaseTypeNode( /* TODO(NonNullExpression): getContainingClass(node)! */ TODO)
				if baseTypeNode {
					baseConstructors := getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode)
					return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			}
			return resolveUntypedCall(node)
		}
		var callChainFlags SignatureFlags
		funcType := checkExpression(node.expression)
		if isCallChain(node) {
			nonOptionalType := getOptionalExpressionType(funcType, node.expression)
			callChainFlags = /* TODO(ConditionalExpression): nonOptionalType === funcType ? SignatureFlags.None :                 isOutermostOptionalChain(node) ? SignatureFlags.IsOuterCallChain :                 SignatureFlags.IsInnerCallChain */ TODO
			funcType = nonOptionalType
		} else {
			callChainFlags = SignatureFlagsNone
		}
		funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError)
		if funcType == silentNeverType {
			return silentNeverSignature
		}
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			if !isErrorType(funcType) && node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		if !callSignatures.length {
			if numConstructSignatures {
				error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			} else {
				var relatedInformation *DiagnosticRelatedInformation
				if node.arguments.length == 1 {
					text := getSourceFileOfNode(node).text
					if isLineBreak(text.charCodeAt( /* TODO(MinusToken): - */ /* TODO(BinaryExpression): skipTrivia(text, node.expression.end, /*stopAfterLineBreak* / true) - 1 */ TODO)) {
						relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon)
					}
				}
				invocationError(node.expression, apparentType, SignatureKindCall, relatedInformation)
			}
			return resolveErrorCall(node)
		}
		if checkMode&CheckModeSkipGenericFunctions && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction) {
			skippedGenericFunction(node, checkMode)
			return resolvingSignature
		}
		if callSignatures.some(func(sig /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): isInJSFile(sig.declaration) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(PrefixUnaryExpression): !!getJSDocClassTag(sig.declaration!) */
		}) {
			error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType))
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags)
	}
	isGenericFunctionReturningFunction := func(signature Signature) /* TODO(undefined): boolean */ TODO {
		return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)))
	}
	isUntypedFunctionCall := func(funcType Type, apparentFuncType Type, numCallSignatures number, numConstructSignatures number) bool {
		return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags&TypeFlagsTypeParameter) || !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags&TypeFlagsUnion) && !(getReducedType(apparentFuncType).flags&TypeFlagsNever) && isTypeAssignableTo(funcType, globalFunctionType)
	}
	resolveNewExpression := func(node NewExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		expressionType := checkNonNullExpression(node.expression)
		if expressionType == silentNeverType {
			return silentNeverSignature
		}
		expressionType = getApparentType(expressionType)
		if isErrorType(expressionType) {
			return resolveErrorCall(node)
		}
		if isTypeAny(expressionType) {
			if node.typeArguments {
				error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments)
			}
			return resolveUntypedCall(node)
		}
		constructSignatures := getSignaturesOfType(expressionType, SignatureKindConstruct)
		if constructSignatures.length {
			if !isConstructorAccessible(node /* TODO(ElementAccessExpression): constructSignatures[0] */, TODO) {
				return resolveErrorCall(node)
			}
			if someSignature(constructSignatures, func(signature /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !(signature.flags & SignatureFlags.Abstract) */
			}) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			valueDecl := expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol)
			if valueDecl && hasSyntacticModifier(valueDecl, ModifierFlagsAbstract) {
				error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class)
				return resolveErrorCall(node)
			}
			return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
		}
		callSignatures := getSignaturesOfType(expressionType, SignatureKindCall)
		if callSignatures.length {
			signature := resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
			if !noImplicitAny {
				if signature.declaration && !isJSConstructor(signature.declaration) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getReturnTypeOfSignature(signature) !== voidType */ TODO {
					error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword)
				}
				if getThisTypeOfSignature(signature) == voidType {
					error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void)
				}
			}
			return signature
		}
		invocationError(node.expression, expressionType, SignatureKindConstruct)
		return resolveErrorCall(node)
	}
	someSignature := func(signatures /* TODO(UnionType): Signature | readonly Signature[] */ any, f func(s Signature) bool) bool {
		if isArray(signatures) {
			return some(signatures, func(signature /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): someSignature */
				/* TODO(Identifier): signature */
				/* TODO(Identifier): f */
			})
		}
		return /* TODO(ConditionalExpression): signatures.compositeKind === TypeFlags.Union ? some(signatures.compositeSignatures, f) : f(signatures) */ TODO
	}
	typeHasProtectedAccessibleBase := func(target Symbol, type_ InterfaceType) bool {
		baseTypes := getBaseTypes(type_)
		if !length(baseTypes) {
			return false
		}
		firstBase := /* TODO(ElementAccessExpression): baseTypes[0] */ TODO
		if firstBase.flags & TypeFlagsIntersection {
			types := (firstBase /* as */ /* TODO(TypeReference): IntersectionType */).types
			mixinFlags := findMixins(types)
			i := 0
			for _, intersectionMember := range (firstBase /* as */ /* TODO(TypeReference): IntersectionType */).types {
				if ! /* TODO(ElementAccessExpression): mixinFlags[i] */ TODO {
					if getObjectFlags(intersectionMember) & (ObjectFlagsClass | ObjectFlagsInterface) {
						if intersectionMember.symbol == target {
							return true
						}
						if typeHasProtectedAccessibleBase(target, intersectionMember /* as */ /* TODO(TypeReference): InterfaceType */) {
							return true
						}
					}
				}
				i++
			}
			return false
		}
		if firstBase.symbol == target {
			return true
		}
		return typeHasProtectedAccessibleBase(target, firstBase /* as */ /* TODO(TypeReference): InterfaceType */)
	}
	isConstructorAccessible := func(node NewExpression, signature Signature) /* TODO(undefined): boolean */ TODO {
		if !signature || !signature.declaration {
			return true
		}
		declaration := signature.declaration
		modifiers := getSelectedEffectiveModifierFlags(declaration, ModifierFlagsNonPublicAccessibilityModifier)
		if !modifiers || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.Constructor */ TODO {
			return true
		}
		declaringClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(declaration.parent.symbol)! */ TODO
		declaringClass := getDeclaredTypeOfSymbol(declaration.parent.symbol) /* as */ /* TODO(TypeReference): InterfaceType */
		if !isNodeWithinClass(node, declaringClassDeclaration) {
			containingClass := getContainingClass(node)
			if containingClass && modifiers&ModifierFlagsProtected {
				containingType := getTypeOfNode(containingClass)
				if typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType /* as */ /* TODO(TypeReference): InterfaceType */) {
					return true
				}
			}
			if modifiers & ModifierFlagsPrivate {
				error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			if modifiers & ModifierFlagsProtected {
				error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass))
			}
			return false
		}
		return true
	}
	invocationErrorDetails := func(errorTarget Node, apparentType Type, kind SignatureKind) /* TODO(TypeLiteral): { messageChain: DiagnosticMessageChain; relatedMessage: DiagnosticMessage | undefined; } */ TODO {
		var errorInfo *DiagnosticMessageChain
		isCall := kind == SignatureKindCall
		awaitedType := getAwaitedType(apparentType)
		maybeMissingAwait := awaitedType && getSignaturesOfType(awaitedType, kind).length > 0
		if apparentType.flags & TypeFlagsUnion {
			types := (apparentType /* as */ /* TODO(TypeReference): UnionType */).types
			hasSignatures := false
			for _, constituent := range types {
				signatures := getSignaturesOfType(constituent, kind)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): signatures.length !== 0 */ TODO {
					hasSignatures = true
					if errorInfo {
						/* TODO(BreakStatement): break; */
					}
				} else {
					if !errorInfo {
						errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                                 Diagnostics.Type_0_has_no_call_signatures :                                 Diagnostics.Type_0_has_no_construct_signatures */, TODO, typeToString(constituent))
						errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                                 Diagnostics.Not_all_constituents_of_type_0_are_callable :                                 Diagnostics.Not_all_constituents_of_type_0_are_constructable */, TODO, typeToString(apparentType))
					}
					if hasSignatures {
						/* TODO(BreakStatement): break; */
					}
				}
			}
			if !hasSignatures {
				errorInfo = chainDiagnosticMessages(nil /* TODO(ConditionalExpression): isCall ?                         Diagnostics.No_constituent_of_type_0_is_callable :                         Diagnostics.No_constituent_of_type_0_is_constructable */, TODO, typeToString(apparentType))
			}
			if !errorInfo {
				errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                         Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other :                         Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other */, TODO, typeToString(apparentType))
			}
		} else {
			errorInfo = chainDiagnosticMessages(errorInfo /* TODO(ConditionalExpression): isCall ?                     Diagnostics.Type_0_has_no_call_signatures :                     Diagnostics.Type_0_has_no_construct_signatures */, TODO, typeToString(apparentType))
		}
		headMessage := /* TODO(ConditionalExpression): isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable */ TODO
		if isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length == 0 {
			TODO_IDENTIFIER := getNodeLinks(errorTarget)
			if resolvedSymbol && resolvedSymbol.flags&SymbolFlagsGetAccessor {
				headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without
			}
		}
		return /* TODO(ObjectLiteralExpression): {             messageChain: chainDiagnosticMessages(errorInfo, headMessage),             relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : undefined,         } */ TODO
	}
	invocationError := func(errorTarget Node, apparentType Type, kind SignatureKind, relatedInformation DiagnosticRelatedInformation) {
		TODO_IDENTIFIER := invocationErrorDetails(errorTarget, apparentType, kind)
		diagnostic := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain)
		if relatedInfo {
			addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo))
		}
		if isCallExpression(errorTarget.parent) {
			TODO_IDENTIFIER := getDiagnosticSpanForCallNode(errorTarget.parent)
			diagnostic.start = start
			diagnostic.length = length
		}
		diagnostics.add(diagnostic)
		invocationErrorRecovery(apparentType, kind /* TODO(ConditionalExpression): relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic */, TODO)
	}
	invocationErrorRecovery := func(apparentType Type, kind SignatureKind, diagnostic Diagnostic) {
		if !apparentType.symbol {
			return
		}
		importNode := getSymbolLinks(apparentType.symbol).originatingImport
		if importNode && !isImportCall(importNode) {
			sigs := getSignaturesOfType(getTypeOfSymbol( /* TODO(NonNullExpression): getSymbolLinks(apparentType.symbol).target! */ TODO), kind)
			if !sigs || !sigs.length {
			}
			addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead))
		}
	}
	resolveTaggedTemplateExpression := func(node TaggedTemplateExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		tagType := checkExpression(node.tag)
		apparentType := getApparentType(tagType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if !callSignatures.length {
			if isArrayLiteralExpression(node.parent) {
				diagnostic := createDiagnosticForNode(node.tag, Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked)
				diagnostics.add(diagnostic)
				return resolveErrorCall(node)
			}
			invocationError(node.tag, apparentType, SignatureKindCall)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	getDiagnosticHeadMessageForDecoratorResolution := func(node Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO {
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;              case SyntaxKind.Parameter:                 return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;              case SyntaxKind.PropertyDeclaration:                 return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;              case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;              default:                 return Debug.fail();         } */
	}
	resolveDecorator := func(node Decorator, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		funcType := checkExpression(node.expression)
		apparentType := getApparentType(funcType)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
		numConstructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct).length
		if isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures) {
			return resolveUntypedCall(node)
		}
		if isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression) {
			nodeStr := getTextOfNode(node.expression, false)
			error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr)
			return resolveErrorCall(node)
		}
		headMessage := getDiagnosticHeadMessageForDecoratorResolution(node)
		if !callSignatures.length {
			errorDetails := invocationErrorDetails(node.expression, apparentType, SignatureKindCall)
			messageChain := chainDiagnosticMessages(errorDetails.messageChain, headMessage)
			diag := createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node.expression), node.expression, messageChain)
			if errorDetails.relatedMessage {
				addRelatedInfo(diag, createDiagnosticForNode(node.expression, errorDetails.relatedMessage))
			}
			diagnostics.add(diag)
			invocationErrorRecovery(apparentType, SignatureKindCall, diag)
			return resolveErrorCall(node)
		}
		return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone, headMessage)
	}
	createSignatureForJSXIntrinsic := func(node JsxOpeningLikeElement, result Type) Signature {
		namespace := getJsxNamespaceAt(node)
		exports := namespace && getExportsOfSymbol(namespace)
		typeSymbol := exports && getSymbol(exports, JsxNames.Element, SymbolFlagsType)
		returnNode := typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, SymbolFlagsType, node)
		declaration := factory.createFunctionTypeNode(nil /* TODO(ArrayLiteralExpression): [factory.createParameterDeclaration(/*modifiers* / undefined, /*dotDotDotToken* / undefined, "props", /*questionToken* / undefined, nodeBuilder.typeToTypeNode(result, node))] */, TODO /* TODO(ConditionalExpression): returnNode ? factory.createTypeReferenceNode(returnNode, /*typeArguments* / undefined) : factory.createKeywordTypeNode(SyntaxKind.AnyKeyword) */, TODO)
		parameterSymbol := createSymbol(SymbolFlagsFunctionScopedVariable, "props" /* as */ /* TODO(TypeReference): __String */)
		parameterSymbol.links.type_ = result
		return createSignature(declaration, nil, nil /* TODO(ArrayLiteralExpression): [parameterSymbol] */, TODO /* TODO(ConditionalExpression): typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType */, TODO, nil, 1, SignatureFlagsNone)
	}
	resolveJsxOpeningLikeElement := func(node JsxOpeningLikeElement, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		if isJsxIntrinsicTagName(node.tagName) {
			result := getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node)
			fakeSignature := createSignatureForJSXIntrinsic(node, result)
			checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), nil, CheckModeNormal), result, node.tagName, node.attributes)
			if length(node.typeArguments) {
				forEach(node.typeArguments, checkSourceElement)
				diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node) /* TODO(NonNullExpression): node.typeArguments! */, TODO, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments)))
			}
			return fakeSignature
		}
		exprTypes := checkExpression(node.tagName)
		apparentType := getApparentType(exprTypes)
		if isErrorType(apparentType) {
			return resolveErrorCall(node)
		}
		signatures := getUninstantiatedJsxSignaturesOfType(exprTypes, node)
		if isUntypedFunctionCall(exprTypes, apparentType, signatures.length, 0) {
			return resolveUntypedCall(node)
		}
		if signatures.length == 0 {
			error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName))
			return resolveErrorCall(node)
		}
		return resolveCall(node, signatures, candidatesOutArray, checkMode, SignatureFlagsNone)
	}
	resolveInstanceofExpression := func(node InstanceofExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		rightType := checkExpression(node.right)
		if !isTypeAny(rightType) {
			hasInstanceMethodType := getSymbolHasInstanceMethodOfObjectType(rightType)
			if hasInstanceMethodType {
				apparentType := getApparentType(hasInstanceMethodType)
				if isErrorType(apparentType) {
					return resolveErrorCall(node)
				}
				callSignatures := getSignaturesOfType(apparentType, SignatureKindCall)
				constructSignatures := getSignaturesOfType(apparentType, SignatureKindConstruct)
				if isUntypedFunctionCall(hasInstanceMethodType, apparentType, callSignatures.length, constructSignatures.length) {
					return resolveUntypedCall(node)
				}
				if callSignatures.length {
					return resolveCall(node, callSignatures, candidatesOutArray, checkMode, SignatureFlagsNone)
				}
			} else if !(typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType)) {
				error(node.right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method)
				return resolveErrorCall(node)
			}
		}
		return anySignature
	}
	isPotentiallyUncalledDecorator := func(decorator Decorator, signatures []Signature) /* TODO(undefined): boolean | 0 */ TODO {
		return signatures.length && every(signatures, func(signature /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): signature.minArgumentCount === 0 &&             !signatureHasRestParameter(signature) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(BinaryExpression): signature.parameters.length < getDecoratorArgumentCount(decorator, signature) */
		})
	}
	resolveSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:                 return resolveCallExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.NewExpression:                 return resolveNewExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.TaggedTemplateExpression:                 return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);             case SyntaxKind.Decorator:                 return resolveDecorator(node, candidatesOutArray, checkMode);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);             case SyntaxKind.BinaryExpression:                 return resolveInstanceofExpression(node, candidatesOutArray, checkMode);         } */
		Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.")
	}
	getResolvedSignature := func(node CallLikeExpression, candidatesOutArray /* TODO(ArrayType): Signature[] */ any, checkMode CheckMode) Signature {
		links := getNodeLinks(node)
		cached := links.resolvedSignature
		if cached && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): cached !== resolvingSignature */ TODO && !candidatesOutArray {
			return cached
		}
		saveResolutionStart := resolutionStart
		if !cached {
			resolutionStart = resolutionTargets.length
		}
		links.resolvedSignature = resolvingSignature
		result := resolveSignature(node, candidatesOutArray, checkMode || CheckModeNormal)
		resolutionStart = saveResolutionStart
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result !== resolvingSignature */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): links.resolvedSignature !== resolvingSignature */ TODO {
				result = links.resolvedSignature
			}
			links.resolvedSignature = /* TODO(ConditionalExpression): flowLoopStart === flowLoopCount ? result : cached */ TODO
		}
		return result
	}
	isJSConstructor := func(node Node) /* TODO(TypePredicate): node is FunctionDeclaration | FunctionExpression */ TODO {
		if !node || !isInJSFile(node) {
			return false
		}
		func_ := /* TODO(ConditionalExpression): isFunctionDeclaration(node) || isFunctionExpression(node) ? node :             (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer :             undefined */ TODO
		if func_ {
			if getJSDocClassTag(node) {
				/* TODO(TrueKeyword): true */
			}
			if isPropertyAssignment(walkUpParenthesizedExpressions(func_.parent)) {
				/* TODO(FalseKeyword): false */
			}
			symbol := getSymbolOfDeclaration(func_)
			return !!symbol.members.size
		}
		return false
	}
	mergeJSSymbols := func(target Symbol, source *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TransientSymbol | undefined */ TODO {
		if source {
			links := getSymbolLinks(source)
			if !links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target)) {
				inferred := /* TODO(ConditionalExpression): isTransientSymbol(target) ? target : cloneSymbol(target) */ TODO
				inferred.exports = inferred.exports || createSymbolTable()
				inferred.members = inferred.members || createSymbolTable()
				inferred.flags |= source.flags & SymbolFlagsClass
				if source.exports.size {
					mergeSymbolTable(inferred.exports, source.exports)
				}
				if source.members.size {
					mergeSymbolTable(inferred.members, source.members)
				}
				(links.inferredClassSymbol || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.inferredClassSymbol = new Map() */ TODO)).set(getSymbolId(inferred), inferred)
				return inferred
			}
			return links.inferredClassSymbol.get(getSymbolId(target))
		}
	}
	getAssignedClassSymbol := func(decl Declaration) *Symbol {
		assignmentSymbol := decl && getSymbolOfExpando(decl, true)
		prototype := assignmentSymbol.exports.get("prototype" /* as */ /* TODO(TypeReference): __String */)
		init := prototype.valueDeclaration && getAssignedJSPrototype(prototype.valueDeclaration)
		return /* TODO(ConditionalExpression): init ? getSymbolOfDeclaration(init) : undefined */ TODO
	}
	getSymbolOfExpando := func(node Node, allowDeclaration bool) *Symbol {
		if !node.parent {
			return nil
		}
		var name /* TODO(UnionType): Expression | BindingName | undefined */ any
		var decl Node
		if isVariableDeclaration(node.parent) && node.parent.initializer == node {
			if !isInJSFile(node) && !(isVarConstLike(node.parent) && isFunctionLikeDeclaration(node)) {
				return nil
			}
			name = node.parent.name
			decl = node.parent
		} else if isBinaryExpression(node.parent) {
			parentNode := node.parent
			parentNodeOperator := node.parent.operatorToken.kind
			if parentNodeOperator == SyntaxKindEqualsToken && (allowDeclaration || parentNode.right == node) {
				name = parentNode.left
				decl = name
			} else if parentNodeOperator == SyntaxKindBarBarToken || parentNodeOperator == SyntaxKindQuestionQuestionToken {
				if isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer == parentNode {
					name = parentNode.parent.name
					decl = parentNode.parent
				} else if isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind == SyntaxKindEqualsToken && (allowDeclaration || parentNode.parent.right == parentNode) {
					name = parentNode.parent.left
					decl = name
				}
				if !name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left) {
					return nil
				}
			}
		} else if allowDeclaration && isFunctionDeclaration(node) {
			name = node.name
			decl = node
		}
		if !decl || !name || (!allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) {
			return nil
		}
		return getSymbolOfNode(decl)
	}
	getAssignedJSPrototype := func(node Node) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectLiteralExpression | undefined */ TODO {
		if !node.parent {
			return false
		}
		var parent Node = node.parent
		/* TODO(WhileStatement): while (parent && parent.kind === SyntaxKind.PropertyAccessExpression) {             parent = parent.parent;         } */
		if parent && isBinaryExpression(parent) && isPrototypeAccess(parent.left) && parent.operatorToken.kind == SyntaxKindEqualsToken {
			right := getInitializerOfBinaryExpression(parent)
			return isObjectLiteralExpression(right) && right
		}
	}
	checkCallExpression := func(node /* TODO(UnionType): CallExpression | NewExpression */ any, checkMode CheckMode) Type {
		checkGrammarTypeArguments(node, node.typeArguments)
		signature := getResolvedSignature(node, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		checkDeprecatedSignature(signature, node)
		if node.expression.kind == SyntaxKindSuperKeyword {
			return voidType
		}
		if node.kind == SyntaxKindNewExpression {
			declaration := signature.declaration
			if declaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.Constructor */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.ConstructSignature */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.ConstructorType */ TODO && !(isJSDocSignature(declaration) && getJSDocRoot(declaration).parent.kind == SyntaxKindConstructor) && !isJSDocConstructSignature(declaration) && !isJSConstructor(declaration) {
				if noImplicitAny {
					error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type)
				}
				return anyType
			}
		}
		if isInJSFile(node) && isCommonJsRequire(node) {
			return resolveExternalModuleTypeByLiteral( /* TODO(ElementAccessExpression): node.arguments![0] */ TODO /* as */ /* TODO(TypeReference): StringLiteral */)
		}
		returnType := getReturnTypeOfSignature(signature)
		if returnType.flags&TypeFlagsESSymbolLike && isSymbolOrSymbolForCall(node) {
			return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent))
		}
		if node.kind == SyntaxKindCallExpression && !node.questionDotToken && node.parent.kind == SyntaxKindExpressionStatement && returnType.flags&TypeFlagsVoid && getTypePredicateOfSignature(signature) {
			if !isDottedName(node.expression) {
				error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name)
			} else if !getEffectsSignature(node) {
				diagnostic := error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation)
				getTypeOfDottedName(node.expression, diagnostic)
			}
		}
		if isInJSFile(node) {
			jsSymbol := getSymbolOfExpando(node, false)
			if jsSymbol.exports.size {
				jsAssignmentType := createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray)
				jsAssignmentType.objectFlags |= ObjectFlagsJSLiteral
				return getIntersectionType( /* TODO(ArrayLiteralExpression): [returnType, jsAssignmentType] */ TODO)
			}
		}
		return returnType
	}
	checkDeprecatedSignature := func(signature Signature, node CallLikeExpression) {
		if signature.flags & SignatureFlagsIsSignatureCandidateForOverloadFailure {
		}
		if signature.declaration && signature.declaration.flags&NodeFlagsDeprecated {
			suggestionNode := getDeprecatedSuggestionNode(node)
			name := tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node))
			addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature))
		}
	}
	getDeprecatedSuggestionNode := func(node Node) Node {
		node = skipParentheses(node)
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:             case SyntaxKind.Decorator:             case SyntaxKind.NewExpression:                 return getDeprecatedSuggestionNode((node as Decorator | CallExpression | NewExpression).expression);             case SyntaxKind.TaggedTemplateExpression:                 return getDeprecatedSuggestionNode((node as TaggedTemplateExpression).tag);             case SyntaxKind.JsxOpeningElement:             case SyntaxKind.JsxSelfClosingElement:                 return getDeprecatedSuggestionNode((node as JsxOpeningLikeElement).tagName);             case SyntaxKind.ElementAccessExpression:                 return (node as ElementAccessExpression).argumentExpression;             case SyntaxKind.PropertyAccessExpression:                 return (node as PropertyAccessExpression).name;             case SyntaxKind.TypeReference:                 const typeReference = node as TypeReferenceNode;                 return isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;             default:                 return node;         } */
	}
	isSymbolOrSymbolForCall := func(node Node) /* TODO(undefined): boolean */ TODO {
		if !isCallExpression(node) {
			/* TODO(FalseKeyword): false */
		}
		left := node.expression
		if isPropertyAccessExpression(left) && left.name.escapedText == "for" {
			left = left.expression
		}
		if !isIdentifier(left) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): left.escapedText !== "Symbol" */ TODO {
			return false
		}
		globalESSymbol := getGlobalESSymbolConstructorSymbol(false)
		if !globalESSymbol {
			return false
		}
		return globalESSymbol == resolveName(left, "Symbol" /* as */ /* TODO(TypeReference): __String */, SymbolFlagsValue, nil, false)
	}
	checkImportCallExpression := func(node ImportCall) Type {
		checkGrammarImportCallExpression(node)
		if node.arguments.length == 0 {
			return createPromiseReturnType(node, anyType)
		}
		specifier := /* TODO(ElementAccessExpression): node.arguments[0] */ TODO
		specifierType := checkExpressionCached(specifier)
		optionsType := /* TODO(ConditionalExpression): node.arguments.length > 1 ? checkExpressionCached(node.arguments[1]) : undefined */ TODO
		/* TODO(ForStatement): for (let i = 2; i < node.arguments.length; ++i) {             checkExpressionCached(node.arguments[i]);         } */
		if specifierType.flags&TypeFlagsUndefined || specifierType.flags&TypeFlagsNull || !isTypeAssignableTo(specifierType, stringType) {
			error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType))
		}
		if optionsType {
			importCallOptionsType := getGlobalImportCallOptionsType(true)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): importCallOptionsType !== emptyObjectType */ TODO {
				checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType, TypeFlagsUndefined) /* TODO(ElementAccessExpression): node.arguments[1] */, TODO)
			}
		}
		moduleSymbol := resolveExternalModuleName(node, specifier)
		if moduleSymbol {
			esModuleSymbol := resolveESModuleSymbol(moduleSymbol, specifier, true, false)
			if esModuleSymbol {
				return createPromiseReturnType(node, getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) || getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier))
			}
		}
		return createPromiseReturnType(node, anyType)
	}
	createDefaultPropertyWrapperForModule := func(symbol Symbol, originalSymbol *Symbol, anonymousSymbol *Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ResolvedType */ TODO {
		memberTable := createSymbolTable()
		newSymbol := createSymbol(SymbolFlagsAlias, InternalSymbolNameDefault)
		newSymbol.parent = originalSymbol
		newSymbol.links.nameType = getStringLiteralType("default")
		newSymbol.links.aliasTarget = resolveSymbol(symbol)
		memberTable.set(InternalSymbolNameDefault, newSymbol)
		return createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray)
	}
	getTypeWithSyntheticDefaultOnly := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		hasDefaultOnly := isOnlyImportableAsDefault(moduleSpecifier)
		if hasDefaultOnly && type_ && !isErrorType(type_) {
			synthType := type_ /* as */ /* TODO(TypeReference): SyntheticDefaultModuleType */
			if !synthType.defaultOnlyType {
				type_ := createDefaultPropertyWrapperForModule(symbol, originalSymbol)
				synthType.defaultOnlyType = type_
			}
			return synthType.defaultOnlyType
		}
		return nil
	}
	getTypeWithSyntheticDefaultImportType := func(type_ Type, symbol Symbol, originalSymbol Symbol, moduleSpecifier Expression) Type {
		if allowSyntheticDefaultImports && type_ && !isErrorType(type_) {
			synthType := type_ /* as */ /* TODO(TypeReference): SyntheticDefaultModuleType */
			if !synthType.syntheticType {
				file := originalSymbol.declarations.find(isSourceFile)
				hasSyntheticDefault := canHaveSyntheticDefault(file, originalSymbol, false, moduleSpecifier)
				if hasSyntheticDefault {
					anonymousSymbol := createSymbol(SymbolFlagsTypeLiteral, InternalSymbolNameType)
					defaultContainingObject := createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol)
					anonymousSymbol.links.type_ = defaultContainingObject
					synthType.syntheticType = /* TODO(ConditionalExpression): isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, /*objectFlags* / 0, /*readonly* / false) : defaultContainingObject */ TODO
				} else {
					synthType.syntheticType = type_
				}
			}
			return synthType.syntheticType
		}
		return type_
	}
	isCommonJsRequire := func(node Node) bool {
		if !isRequireCall(node, true) {
			return false
		}
		if !isIdentifier(node.expression) {
			/* TODO(CallExpression): Debug.fail() */
		}
		resolvedRequire := /* TODO(NonNullExpression): resolveName(node.expression, node.expression.escapedText, SymbolFlags.Value, /*nameNotFoundMessage* / undefined, /*isUse* / true)! */ TODO
		if resolvedRequire == requireSymbol {
			return true
		}
		if resolvedRequire.flags & SymbolFlagsAlias {
			return false
		}
		targetDeclarationKind := /* TODO(ConditionalExpression): resolvedRequire.flags & SymbolFlags.Function             ? SyntaxKind.FunctionDeclaration             : resolvedRequire.flags & SymbolFlags.Variable             ? SyntaxKind.VariableDeclaration             : SyntaxKind.Unknown */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): targetDeclarationKind !== SyntaxKind.Unknown */ TODO {
			decl := /* TODO(NonNullExpression): getDeclarationOfKind(resolvedRequire, targetDeclarationKind)! */ TODO
			return !!decl && !!(decl.flags & NodeFlagsAmbient)
		}
		return false
	}
	checkTaggedTemplateExpression := func(node TaggedTemplateExpression) Type {
		if !checkGrammarTaggedTemplateChain(node) {
			/* TODO(CallExpression): checkGrammarTypeArguments(node, node.typeArguments) */
		}
		if languageVersion < LanguageFeatureMinimumTargetTaggedTemplates {
			checkExternalEmitHelpers(node, ExternalEmitHelpersMakeTemplateObject)
		}
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		return getReturnTypeOfSignature(signature)
	}
	checkAssertion := func(node AssertionExpression, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if node.kind == SyntaxKindTypeAssertionExpression {
			file := getSourceFileOfNode(node)
			if file && fileExtensionIsOneOf(file.fileName /* TODO(ArrayLiteralExpression): [Extension.Cts, Extension.Mts] */, TODO) {
				grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead)
			}
		}
		return checkAssertionWorker(node, checkMode)
	}
	isValidConstAssertionArgument := func(node Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.StringLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.TemplateExpression:                 return true;             case SyntaxKind.ParenthesizedExpression:                 return isValidConstAssertionArgument((node as ParenthesizedExpression).expression);             case SyntaxKind.PrefixUnaryExpression:                 const op = (node as PrefixUnaryExpression).operator;                 const arg = (node as PrefixUnaryExpression).operand;                 return op === SyntaxKind.MinusToken && (arg.kind === SyntaxKind.NumericLiteral || arg.kind === SyntaxKind.BigIntLiteral) ||                     op === SyntaxKind.PlusToken && arg.kind === SyntaxKind.NumericLiteral;             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 const expr = skipParentheses((node as PropertyAccessExpression | ElementAccessExpression).expression);                 const symbol = isEntityNameExpression(expr) ? resolveEntityName(expr, SymbolFlags.Value, /*ignoreErrors* / true) : undefined;                 return !!(symbol && symbol.flags & SymbolFlags.Enum);         } */
		return false
	}
	checkAssertionWorker := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		exprType := checkExpression(expression, checkMode)
		if isConstTypeReference(type_) {
			if !isValidConstAssertionArgument(expression) {
				error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals)
			}
			return getRegularTypeOfLiteralType(exprType)
		}
		links := getNodeLinks(node)
		links.assertionExpressionType = exprType
		checkSourceElement(type_)
		checkNodeDeferred(node)
		return getTypeFromTypeNode(type_)
	}
	getAssertionTypeAndExpression := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) /* TODO(undefined): { type: import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode; expression: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; } */ TODO {
		var type_ TypeNode
		var expression Expression
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AsExpression:             case SyntaxKind.TypeAssertionExpression:                 type = node.type;                 expression = node.expression;                 break;             case SyntaxKind.ParenthesizedExpression:                 type = getJSDocTypeAssertionType(node);                 expression = node.expression;                 break;         } */
		return /* TODO(ObjectLiteralExpression): { type, expression } */ TODO
	}
	checkAssertionDeferred := func(node /* TODO(UnionType): JSDocTypeAssertion | AssertionExpression */ any) {
		TODO_IDENTIFIER := getAssertionTypeAndExpression(node)
		errNode := /* TODO(ConditionalExpression): isParenthesizedExpression(node) ? type : node */ TODO
		links := getNodeLinks(node)
		Debug.assertIsDefined(links.assertionExpressionType)
		exprType := getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(links.assertionExpressionType))
		targetType := getTypeFromTypeNode(type_)
		if !isErrorType(targetType) {
			addLazyDiagnostic(func() {
				widenedType := getWidenedType(exprType)
				if !isTypeComparableTo(targetType, widenedType) {
					checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first)
				}
			})
		}
	}
	checkNonNullChain := func(node NonNullChain) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		leftType := checkExpression(node.expression)
		nonOptionalType := getOptionalExpressionType(leftType, node.expression)
		return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== leftType */, TODO)
	}
	checkNonNullAssertion := func(node NonNullExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): node.flags & NodeFlags.OptionalChain ? checkNonNullChain(node as NonNullChain) :             getNonNullableType(checkExpression(node.expression)) */ TODO
	}
	checkExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkGrammarExpressionWithTypeArguments(node)
		forEach(node.typeArguments, checkSourceElement)
		if node.kind == SyntaxKindExpressionWithTypeArguments {
			parent := walkUpParenthesizedExpressions(node.parent)
			if parent.kind == SyntaxKindBinaryExpression && (parent /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindInstanceOfKeyword && isNodeDescendantOf(node, (parent /* as */ /* TODO(TypeReference): BinaryExpression */).right) {
				error(node, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression)
			}
		}
		exprType := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExpressionWithTypeArguments ? checkExpression(node.expression) :             isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) :             checkExpression(node.exprName) */ TODO
		return getInstantiationExpressionType(exprType, node)
	}
	getInstantiationExpressionType := func(exprType Type, node NodeWithTypeArguments) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		typeArguments := node.typeArguments
		if exprType == silentNeverType || isErrorType(exprType) || !some(typeArguments) {
			return exprType
		}
		hasSomeApplicableSignature := false
		var nonApplicableType *Type
		result := getInstantiatedType(exprType)
		errorType := /* TODO(ConditionalExpression): hasSomeApplicableSignature ? nonApplicableType : exprType */ TODO
		if errorType {
			diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, typeToString(errorType)))
		}
		return result
		getInstantiatedType := func(type_ Type) Type {
			hasSignatures := false
			hasApplicableSignature := false
			result := getInstantiatedTypePart(type_)
			/* TODO(ExpressionStatement): hasSomeApplicableSignature ||= hasApplicableSignature; */
			if hasSignatures && !hasApplicableSignature {
				/* TODO(ExpressionStatement): nonApplicableType ??= type; */
			}
			return result
			getInstantiatedTypePart := func(type_ Type) Type {
				if type_.flags & TypeFlagsObject {
					resolved := resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */)
					callSignatures := getInstantiatedSignatures(resolved.callSignatures)
					constructSignatures := getInstantiatedSignatures(resolved.constructSignatures)
					/* TODO(ExpressionStatement): hasSignatures ||= resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0; */
					/* TODO(ExpressionStatement): hasApplicableSignature ||= callSignatures.length !== 0 || constructSignatures.length !== 0; */
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): callSignatures !== resolved.callSignatures */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): constructSignatures !== resolved.constructSignatures */ TODO {
						result := createAnonymousType(createSymbol(SymbolFlagsNone, InternalSymbolNameInstantiationExpression), resolved.members, callSignatures, constructSignatures, resolved.indexInfos) /* as */ /* TODO(IntersectionType): ResolvedType & InstantiationExpressionType */
						result.objectFlags |= ObjectFlagsInstantiationExpressionType
						result.node = node
						return result
					}
				} else if type_.flags & TypeFlagsInstantiableNonPrimitive {
					constraint := getBaseConstraintOfType(type_)
					if constraint {
						instantiated := getInstantiatedTypePart(constraint)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): instantiated !== constraint */ TODO {
							return instantiated
						}
					}
				} else if type_.flags & TypeFlagsUnion {
					return mapType(type_, getInstantiatedType)
				} else if type_.flags & TypeFlagsIntersection {
					return getIntersectionType(sameMap((type_ /* as */ /* TODO(TypeReference): IntersectionType */).types, getInstantiatedTypePart))
				}
				return type_
			}
		}
		getInstantiatedSignatures := func(signatures []Signature) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Signature[] */ TODO {
			applicableSignatures := filter(signatures, func(sig /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PrefixUnaryExpression): !!sig.typeParameters */
				/* TODO(AmpersandAmpersandToken): && */
				/* TODO(CallExpression): hasCorrectTypeArgumentArity(sig, typeArguments) */
			})
			return sameMap(applicableSignatures, func(sig /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
				typeArgumentTypes := checkTypeArguments(sig /* TODO(NonNullExpression): typeArguments! */, TODO, true)
				return /* TODO(ConditionalExpression): typeArgumentTypes ? getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration)) : sig */ TODO
			})
		}
	}
	checkSatisfiesExpression := func(node SatisfiesExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		checkSourceElement(node.type_)
		return checkSatisfiesExpressionWorker(node.expression, node.type_)
	}
	checkSatisfiesExpressionWorker := func(expression Expression, target TypeNode, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		exprType := checkExpression(expression, checkMode)
		targetType := getTypeFromTypeNode(target)
		if isErrorType(targetType) {
			return targetType
		}
		errorNode := findAncestor(target.parent, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): n.kind === SyntaxKind.SatisfiesExpression */
			/* TODO(BarBarToken): || */
			/* TODO(BinaryExpression): n.kind === SyntaxKind.JSDocSatisfiesTag */
		})
		checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, errorNode, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1)
		return exprType
	}
	checkMetaProperty := func(node MetaProperty) Type {
		checkGrammarMetaProperty(node)
		if node.keywordToken == SyntaxKindNewKeyword {
			return checkNewTargetMetaProperty(node)
		}
		if node.keywordToken == SyntaxKindImportKeyword {
			return checkImportMetaProperty(node)
		}
		return Debug.assertNever(node.keywordToken)
	}
	checkMetaPropertyKeyword := func(node MetaProperty) Type {
		/* TODO(SwitchStatement): switch (node.keywordToken) {             case SyntaxKind.ImportKeyword:                 return getGlobalImportMetaExpressionType();             case SyntaxKind.NewKeyword:                 const type = checkNewTargetMetaProperty(node);                 return isErrorType(type) ? errorType : createNewTargetExpressionType(type);             default:                 Debug.assertNever(node.keywordToken);         } */
	}
	checkNewTargetMetaProperty := func(node MetaProperty) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		container := getNewTargetContainer(node)
		if !container {
			error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target")
			return errorType
		} else if container.kind == SyntaxKindConstructor {
			symbol := getSymbolOfDeclaration(container.parent)
			return getTypeOfSymbol(symbol)
		} else {
			symbol := getSymbolOfDeclaration(container)
			return getTypeOfSymbol(symbol)
		}
	}
	checkImportMetaProperty := func(node MetaProperty) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IntrinsicType | import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		if moduleKind == ModuleKindNode16 || moduleKind == ModuleKindNodeNext {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(node).impliedNodeFormat !== ModuleKind.ESNext */ TODO {
				error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output)
			}
		} else if moduleKind < ModuleKindES2020 && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.System */ TODO {
			error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext)
		}
		file := getSourceFileOfNode(node)
		Debug.assert(!!(file.flags & NodeFlagsPossiblyContainsImportMeta), "Containing file is missing import meta node flag.")
		return /* TODO(ConditionalExpression): node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType */ TODO
	}
	getTypeOfParameter := func(symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		declaration := symbol.valueDeclaration
		return addOptionality(getTypeOfSymbol(symbol), false, !!declaration && (hasInitializer(declaration) || isOptionalDeclaration(declaration)))
	}
	getTupleElementLabelFromBindingElement := func(node /* TODO(UnionType): BindingElement | ParameterDeclaration */ any, index number, elementFlags ElementFlags) __String {
		/* TODO(SwitchStatement): switch (node.name.kind) {             case SyntaxKind.Identifier: {                 const name = node.name.escapedText;                 if (node.dotDotDotToken) {                     // given                     //   (...[x, y, ...z]: [number, number, ...number[]]) => ...                     // this produces                     //   (x: number, y: number, ...z: number[]) => ...                     // which preserves rest elements of 'z'                      // given                     //   (...[x, y, ...z]: [number, number, ...[...number[], number]]) => ...                     // this produces                     //   (x: number, y: number, ...z: number[], z_1: number) => ...                     // which preserves rest elements of z but gives distinct numbers to fixed elements of 'z'                     return elementFlags & ElementFlags.Variable ? name : `${name}_${index}` as __String;                 }                 else {                     // given                     //   (...[x]: [number]) => ...                     // this produces                     //   (x: number) => ...                     // which preserves fixed elements of 'x'                      // given                     //   (...[x]: ...number[]) => ...                     // this produces                     //   (x_0: number) => ...                     // which which numbers fixed elements of 'x' whose tuple element type is variable                     return elementFlags & ElementFlags.Fixed ? name : `${name}_n` as __String;                 }             }             case SyntaxKind.ArrayBindingPattern: {                 if (node.dotDotDotToken) {                     const elements = node.name.elements;                     const lastElement = tryCast(lastOrUndefined(elements), isBindingElement);                     const elementCount = elements.length - (lastElement?.dotDotDotToken ? 1 : 0);                     if (index < elementCount) {                         const element = elements[index];                         if (isBindingElement(element)) {                             return getTupleElementLabelFromBindingElement(element, index, elementFlags);                         }                     }                     else if (lastElement?.dotDotDotToken) {                         return getTupleElementLabelFromBindingElement(lastElement, index - elementCount, elementFlags);                     }                 }                 break;             }         } */
		return /* TODO(TemplateExpression): `arg_${index}` */ TODO /* as */ /* TODO(TypeReference): __String */
	}
	// OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember */ any) __String
	// OVERLOAD: getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index number, elementFlags ElementFlags, restSymbol Symbol) __String
	getTupleElementLabel := func(d /* TODO(UnionType): ParameterDeclaration | NamedTupleMember | undefined */ any, index /* TODO(undefined): number */ TODO /* = */ /* TODO(NumericLiteral): 0 */, elementFlags /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO /* = */ /* TODO(PropertyAccessExpression): ElementFlags.Fixed */, restSymbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		if !d {
			restParameter := tryCast(restSymbol.valueDeclaration, isParameter)
			return /* TODO(ConditionalExpression): restParameter ? getTupleElementLabelFromBindingElement(restParameter, index, elementFlags) :                 `${restSymbol?.escapedName ?? "arg"}_${index}` as __String */ TODO
		}
		Debug.assert(isIdentifier(d.name))
		return d.name.escapedText
	}
	getParameterNameAtPosition := func(signature Signature, pos number, overrideRestType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			return /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO.escapedName
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restType := overrideRestType || getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			tupleType := (restType /* as */ /* TODO(TypeReference): TypeReference */).target /* as */ /* TODO(TypeReference): TupleType */
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			associatedName := /* TODO(ElementAccessExpression): tupleType.labeledElementDeclarations?.[index] */ TODO
			elementFlags := /* TODO(ElementAccessExpression): tupleType.elementFlags[index] */ TODO
			return getTupleElementLabel(associatedName, index, elementFlags, restParameter)
		}
		return restParameter.escapedName
	}
	getParameterIdentifierInfoAtPosition := func(signature Signature, pos number) /* TODO(TypeLiteral): { parameter: Identifier; parameterName: __String; isRestParameter: boolean; } */ any {
		if signature.declaration.kind == SyntaxKindJSDocFunctionType {
			return nil
		}
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			param := /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO
			paramIdent := getParameterDeclarationIdentifier(param)
			return /* TODO(ConditionalExpression): paramIdent ? {                 parameter: paramIdent,                 parameterName: param.escapedName,                 isRestParameter: false,             } : undefined */ TODO
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restIdent := getParameterDeclarationIdentifier(restParameter)
		if !restIdent {
			return nil
		}
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType /* as */ /* TODO(TypeReference): TypeReference */).target /* as */ /* TODO(TypeReference): TupleType */).labeledElementDeclarations
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			associatedName := /* TODO(ElementAccessExpression): associatedNames?.[index] */ TODO
			isRestTupleElement := !!associatedName.dotDotDotToken
			if associatedName {
				Debug.assert(isIdentifier(associatedName.name))
				return /* TODO(ObjectLiteralExpression): { parameter: associatedName.name, parameterName: associatedName.name.escapedText, isRestParameter: isRestTupleElement } */ TODO
			}
			return nil
		}
		if pos == paramCount {
			return /* TODO(ObjectLiteralExpression): { parameter: restIdent, parameterName: restParameter.escapedName, isRestParameter: true } */ TODO
		}
		return nil
	}
	getParameterDeclarationIdentifier := func(symbol Symbol) /* TODO(undefined): false | import("/home/jabaile/work/TypeScript/src/compiler/types").Identifier | undefined */ TODO {
		return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name) && symbol.valueDeclaration.name
	}
	isValidDeclarationForTupleLabel := func(d Declaration) /* TODO(TypePredicate): d is NamedTupleMember | (ParameterDeclaration & { name: Identifier; }) */ TODO {
		return d.kind == SyntaxKindNamedTupleMember || (isParameter(d) && d.name && isIdentifier(d.name))
	}
	getNameableDeclarationAtPosition := func(signature Signature, pos number) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").NamedTupleMember | undefined */ TODO {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			decl := /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO.valueDeclaration
			return /* TODO(ConditionalExpression): decl && isValidDeclarationForTupleLabel(decl) ? decl : undefined */ TODO
		}
		restParameter := /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO || unknownSymbol
		restType := getTypeOfSymbol(restParameter)
		if isTupleType(restType) {
			associatedNames := ((restType /* as */ /* TODO(TypeReference): TypeReference */).target /* as */ /* TODO(TypeReference): TupleType */).labeledElementDeclarations
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			return associatedNames && /* TODO(ElementAccessExpression): associatedNames[index] */ TODO
		}
		return /* TODO(ConditionalExpression): restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : undefined */ TODO
	}
	getTypeAtPosition := func(signature Signature, pos number) Type {
		return tryGetTypeAtPosition(signature, pos) || anyType
	}
	tryGetTypeAtPosition := func(signature Signature, pos number) *Type {
		paramCount := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		if pos < paramCount {
			return getTypeOfParameter( /* TODO(ElementAccessExpression): signature.parameters[pos] */ TODO)
		}
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[paramCount] */ TODO)
			index := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): pos - paramCount */ TODO
			if !isTupleType(restType) || restType.target.combinedFlags&ElementFlagsVariable || index < restType.target.fixedLength {
				return getIndexedAccessType(restType, getNumberLiteralType(index))
			}
		}
		return nil
	}
	getRestTypeAtPosition := func(source Signature, pos number, readonly bool) Type {
		parameterCount := getParameterCount(source)
		minArgumentCount := getMinArgumentCount(source)
		restType := getEffectiveRestType(source)
		if restType && pos >= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): parameterCount - 1 */ TODO {
			return /* TODO(ConditionalExpression): pos === parameterCount - 1 ? restType : createArrayType(getIndexedAccessType(restType, numberType)) */ TODO
		}
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		flags := /* TODO(ArrayLiteralExpression): [] */ TODO
		names := /* TODO(ArrayLiteralExpression): [] */ TODO
		/* TODO(ForStatement): for (let i = pos; i < parameterCount; i++) {             if (!restType || i < parameterCount - 1) {                 types.push(getTypeAtPosition(source, i));                 flags.push(i < minArgumentCount ? ElementFlags.Required : ElementFlags.Optional);             }             else {                 types.push(restType);                 flags.push(ElementFlags.Variadic);             }             names.push(getNameableDeclarationAtPosition(source, i));         } */
		return createTupleType(types, flags, readonly, names)
	}
	getRestOrAnyTypeAtPosition := func(source Signature, pos number) Type {
		restType := getRestTypeAtPosition(source, pos)
		elementType := restType && getElementTypeOfArrayType(restType)
		return /* TODO(ConditionalExpression): elementType && isTypeAny(elementType) ? anyType : restType */ TODO
	}
	getParameterCount := func(signature Signature) /* TODO(undefined): number */ TODO {
		length := signature.parameters.length
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[length - 1] */ TODO)
			if isTupleType(restType) {
				return /* TODO(MinusToken): - */ /* TODO(BinaryExpression): length + restType.target.fixedLength - (restType.target.combinedFlags & ElementFlags.Variable ? 0 : 1) */ TODO
			}
		}
		return length
	}
	getMinArgumentCount := func(signature Signature, flags MinArgumentCountFlags) /* TODO(undefined): number */ TODO {
		strongArityForUntypedJS := /* TODO(NonNullExpression): flags! */ TODO & MinArgumentCountFlagsStrongArityForUntypedJS
		voidIsNonOptional := /* TODO(NonNullExpression): flags! */ TODO & MinArgumentCountFlagsVoidIsNonOptional
		if voidIsNonOptional || signature.resolvedMinArgumentCount == nil {
			var minArgumentCount /* TODO(NumberKeyword): number */ any
			if signatureHasRestParameter(signature) {
				restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
				if isTupleType(restType) {
					firstOptionalIndex := findIndex(restType.target.elementFlags, func(f /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ElementFlags */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(ParenthesizedExpression): (f & ElementFlags.Required) */
					})
					requiredCount := /* TODO(ConditionalExpression): firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex */ TODO
					if requiredCount > 0 {
						minArgumentCount = /* TODO(PlusToken): + */ /* TODO(BinaryExpression): signature.parameters.length - 1 + requiredCount */ TODO
					}
				}
			}
			if minArgumentCount == nil {
				if !strongArityForUntypedJS && signature.flags&SignatureFlagsIsUntypedSignatureInJSFile {
					return 0
				}
				minArgumentCount = signature.minArgumentCount
			}
			if voidIsNonOptional {
				return minArgumentCount
			}
			/* TODO(ForStatement): for (let i = minArgumentCount - 1; i >= 0; i--) {                 const type = getTypeAtPosition(signature, i);                 if (filterType(type, acceptsVoid).flags & TypeFlags.Never) {                     break;                 }                 minArgumentCount = i;             } */
			signature.resolvedMinArgumentCount = minArgumentCount
		}
		return signature.resolvedMinArgumentCount
	}
	hasEffectiveRestParameter := func(signature Signature) /* TODO(undefined): boolean */ TODO {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			return !isTupleType(restType) || !!(restType.target.combinedFlags & ElementFlagsVariable)
		}
		return false
	}
	getEffectiveRestType := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if signatureHasRestParameter(signature) {
			restType := getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[signature.parameters.length - 1] */ TODO)
			if !isTupleType(restType) {
				return /* TODO(ConditionalExpression): isTypeAny(restType) ? anyArrayType : restType */ TODO
			}
			if restType.target.combinedFlags & ElementFlagsVariable {
				return sliceTupleType(restType, restType.target.fixedLength)
			}
		}
		return nil
	}
	getNonArrayRestType := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		restType := getEffectiveRestType(signature)
		return /* TODO(ConditionalExpression): restType && !isArrayType(restType) && !isTypeAny(restType) ? restType : undefined */ TODO
	}
	getTypeOfFirstParameterOfSignature := func(signature Signature) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType)
	}
	getTypeOfFirstParameterOfSignatureWithFallback := func(signature Signature, fallbackType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType */ TODO
	}
	inferFromAnnotatedParameters := func(signature Signature, context Signature, inferenceContext InferenceContext) {
		len := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             const declaration = signature.parameters[i].valueDeclaration as ParameterDeclaration;             const typeNode = getEffectiveTypeAnnotationNode(declaration);             if (typeNode) {                 const source = addOptionality(getTypeFromTypeNode(typeNode), /*isProperty* / false, isOptionalDeclaration(declaration));                 const target = getTypeAtPosition(context, i);                 inferTypes(inferenceContext.inferences, source, target);             }         } */
	}
	assignContextualParameterTypes := func(signature Signature, context Signature) {
		if context.typeParameters {
			if !signature.typeParameters {
				signature.typeParameters = context.typeParameters
			} else {
				return
			}
		}
		if context.thisParameter {
			parameter := signature.thisParameter
			if !parameter || parameter.valueDeclaration && !(parameter.valueDeclaration /* as */ /* TODO(TypeReference): ParameterDeclaration */).type_ {
				if !parameter {
					signature.thisParameter = createSymbolWithType(context.thisParameter, nil)
				}
				assignParameterType( /* TODO(NonNullExpression): signature.thisParameter! */ TODO, getTypeOfSymbol(context.thisParameter))
			}
		}
		len := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0) */ TODO
		/* TODO(ForStatement): for (let i = 0; i < len; i++) {             const parameter = signature.parameters[i];             const declaration = parameter.valueDeclaration as ParameterDeclaration;             if (!getEffectiveTypeAnnotationNode(declaration)) {                 let type = tryGetTypeAtPosition(context, i);                 if (type && declaration.initializer) {                     let initializerType = checkDeclarationInitializer(declaration, CheckMode.Normal);                     if (!isTypeAssignableTo(initializerType, type) && isTypeAssignableTo(type, initializerType = widenTypeInferredFromInitializer(declaration, initializerType))) {                         type = initializerType;                     }                 }                 assignParameterType(parameter, type);             }         } */
		if signatureHasRestParameter(signature) {
			parameter := last(signature.parameters)
			if /* TODO(ConditionalExpression): parameter.valueDeclaration                     ? !getEffectiveTypeAnnotationNode(parameter.valueDeclaration as ParameterDeclaration)                     // a declarationless parameter may still have a `.type` already set by its construction logic                     // (which may pull a type from a jsdoc) - only allow fixing on `DeferredType` parameters with a fallback type                     : !!(getCheckFlags(parameter) & CheckFlags.DeferredType) */ TODO {
				contextualParameterType := getRestTypeAtPosition(context, len)
				assignParameterType(parameter, contextualParameterType)
			}
		}
	}
	assignNonContextualParameterTypes := func(signature Signature) {
		if signature.thisParameter {
			assignParameterType(signature.thisParameter)
		}
		for _, parameter := range signature.parameters {
			assignParameterType(parameter)
		}
	}
	assignParameterType := func(parameter Symbol, contextualType Type) {
		links := getSymbolLinks(parameter)
		if !links.type_ {
			declaration := parameter.valueDeclaration /* as */ /* TODO(UnionType): ParameterDeclaration | undefined */
			links.type_ = addOptionality(contextualType || ( /* TODO(ConditionalExpression): declaration ? getWidenedTypeForVariableLikeDeclaration(declaration, /*reportErrors* / true) : getTypeOfSymbol(parameter) */ TODO), false, !!declaration && !declaration.initializer && isOptionalDeclaration(declaration))
			if declaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.name.kind !== SyntaxKind.Identifier */ TODO {
				if links.type_ == unknownType {
					links.type_ = getTypeFromBindingPattern(declaration.name)
				}
				assignBindingElementTypes(declaration.name, links.type_)
			}
		} else if contextualType {
			Debug.assertEqual(links.type_, contextualType, "Parameter symbol already has a cached type which differs from newly assigned type")
		}
	}
	assignBindingElementTypes := func(pattern BindingPattern, parentType Type) {
		for _, element := range pattern.elements {
			if !isOmittedExpression(element) {
				type_ := getBindingElementTypeFromParentType(element, parentType, false)
				if element.name.kind == SyntaxKindIdentifier {
					getSymbolLinks(getSymbolOfDeclaration(element)).type_ = type_
				} else {
					assignBindingElementTypes(element.name, type_)
				}
			}
		}
	}
	createClassDecoratorContextType := func(classType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [classType] */, TODO)
	}
	createClassMethodDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassMethodDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassGetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassGetterDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassSetterDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassSetterDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassAccessorDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassFieldDecoratorContextType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassFieldDecoratorContextType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	getClassMemberDecoratorContextOverrideType := func(nameType Type, isPrivate bool, isStatic bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		key := /* TODO(TemplateExpression): `${isPrivate ? "p" : "P"}${isStatic ? "s" : "S"}${nameType.id}` */ TODO /* as */ /* TODO(TypeReference): const */
		overrideType := decoratorContextOverrideTypeCache.get(key)
		if !overrideType {
			members := createSymbolTable()
			members.set("name" /* as */ /* TODO(TypeReference): __String */, createProperty("name" /* as */ /* TODO(TypeReference): __String */, nameType))
			members.set("private" /* as */ /* TODO(TypeReference): __String */, createProperty("private" /* as */ /* TODO(TypeReference): __String */ /* TODO(ConditionalExpression): isPrivate ? trueType : falseType */, TODO))
			members.set("static" /* as */ /* TODO(TypeReference): __String */, createProperty("static" /* as */ /* TODO(TypeReference): __String */ /* TODO(ConditionalExpression): isStatic ? trueType : falseType */, TODO))
			overrideType = createAnonymousType(nil, members, emptyArray, emptyArray, emptyArray)
			decoratorContextOverrideTypeCache.set(key, overrideType)
		}
		return overrideType
	}
	createClassMemberDecoratorContextTypeForNode := func(node /* TODO(UnionType): MethodDeclaration | AccessorDeclaration | PropertyDeclaration */ any, thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		isStatic := hasStaticModifier(node)
		isPrivate := isPrivateIdentifier(node.name)
		nameType := /* TODO(ConditionalExpression): isPrivate ? getStringLiteralType(idText(node.name)) : getLiteralTypeFromPropertyName(node.name) */ TODO
		contextType := /* TODO(ConditionalExpression): isMethodDeclaration(node) ? createClassMethodDecoratorContextType(thisType, valueType) :             isGetAccessorDeclaration(node) ? createClassGetterDecoratorContextType(thisType, valueType) :             isSetAccessorDeclaration(node) ? createClassSetterDecoratorContextType(thisType, valueType) :             isAutoAccessorPropertyDeclaration(node) ? createClassAccessorDecoratorContextType(thisType, valueType) :             isPropertyDeclaration(node) ? createClassFieldDecoratorContextType(thisType, valueType) :             Debug.failBadSyntaxKind(node) */ TODO
		overrideType := getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic)
		return getIntersectionType( /* TODO(ArrayLiteralExpression): [contextType, overrideType] */ TODO)
	}
	createClassAccessorDecoratorTargetType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassAccessorDecoratorResultType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType(true) /* TODO(ArrayLiteralExpression): [thisType, valueType] */, TODO)
	}
	createClassFieldDecoratorInitializerMutatorType := func(thisType Type, valueType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		thisParam := createParameter("this" /* as */ /* TODO(TypeReference): __String */, thisType)
		valueParam := createParameter("value" /* as */ /* TODO(TypeReference): __String */, valueType)
		return createFunctionType(nil, thisParam /* TODO(ArrayLiteralExpression): [valueParam] */, TODO, valueType, nil, 1)
	}
	createESDecoratorCallSignature := func(targetType Type, contextType Type, nonOptionalReturnType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		targetParam := createParameter("target" /* as */ /* TODO(TypeReference): __String */, targetType)
		contextParam := createParameter("context" /* as */ /* TODO(TypeReference): __String */, contextType)
		returnType := getUnionType( /* TODO(ArrayLiteralExpression): [nonOptionalReturnType, voidType] */ TODO)
		return createCallSignature(nil, nil /* TODO(ArrayLiteralExpression): [targetParam, contextParam] */, TODO, returnType)
	}
	getESDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			/* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression: {                     // Class decorators have a `context` of `ClassDecoratorContext<Class>`, where the `Class` type                     // argument will be the "final type" of the class after all decorators are applied.                      const node = parent as ClassDeclaration | ClassExpression;                     const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));                     const contextType = createClassDecoratorContextType(targetType);                     links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType);                     break;                 }                  case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor: {                     const node = parent as MethodDeclaration | GetAccessorDeclaration | SetAccessorDeclaration;                     if (!isClassLike(node.parent)) break;                      // Method decorators have a `context` of `ClassMethodDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the method.                     //                     // Getter decorators have a `context` of `ClassGetterDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the value returned by the getter.                     //                     // Setter decorators have a `context` of `ClassSetterDecoratorContext<This, Value>`, where the                     // `Value` type argument corresponds to the "final type" of the parameter of the setter.                     //                     // In all three cases, the `This` type argument is the "final type" of either the class or                     // instance, depending on whether the member was `static`.                      const valueType = isMethodDeclaration(node) ? getOrCreateTypeFromSignature(getSignatureFromDeclaration(node)) :                         getTypeOfNode(node);                      const thisType = hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));                      // We wrap the "input type", if necessary, to match the decoration target. For getters this is                     // something like `() => inputType`, for setters it's `(value: inputType) => void` and for                     // methods it is just the input type.                     const targetType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType;                      const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);                      // We also wrap the "output type", as needed.                     const returnType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) :                         isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) :                         valueType;                      links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);                     break;                 }                  case SyntaxKind.PropertyDeclaration: {                     const node = parent as PropertyDeclaration;                     if (!isClassLike(node.parent)) break;                      // Field decorators have a `context` of `ClassFieldDecoratorContext<This, Value>` and                     // auto-accessor decorators have a `context` of `ClassAccessorDecoratorContext<This, Value>. In                     // both cases, the `This` type argument is the "final type" of either the class or instance,                     // depending on whether the member was `static`, and the `Value` type argument corresponds to                     // the "final type" of the value stored in the field.                      const valueType = getTypeOfNode(node);                     const thisType = hasStaticModifier(node) ?                         getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) :                         getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));                      // The `target` of an auto-accessor decorator is a `{ get, set }` object, representing the                     // runtime-generated getter and setter that are added to the class/prototype. The `target` of a                     // regular field decorator is always `undefined` as it isn't installed until it is initialized.                     const targetType = hasAccessorModifier(node) ? createClassAccessorDecoratorTargetType(thisType, valueType) :                         undefinedType;                      const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);                      // We wrap the "output type" depending on the declaration. For auto-accessors, we wrap the                     // "output type" in a `ClassAccessorDecoratorResult<This, In, Out>` type, which allows for                     // mutation of the runtime-generated getter and setter, as well as the injection of an                     // initializer mutator. For regular fields, we wrap the "output type" in an initializer mutator.                     const returnType = hasAccessorModifier(node) ? createClassAccessorDecoratorResultType(thisType, valueType) :                         createClassFieldDecoratorInitializerMutatorType(thisType, valueType);                      links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);                     break;                 }             } */
		}
		return /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
	}
	getLegacyDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		TODO_IDENTIFIER := decorator
		links := getNodeLinks(parent)
		if !links.decoratorSignature {
			links.decoratorSignature = anySignature
			/* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression: {                     const node = parent as ClassDeclaration | ClassExpression;                     // For a class decorator, the `target` is the type of the class (e.g. the                     // "static" or "constructor" side of the class).                     const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));                     const targetParam = createParameter("target" as __String, targetType);                     links.decoratorSignature = createCallSignature(                         /*typeParameters* / undefined,                         /*thisParameter* / undefined,                         [targetParam],                         getUnionType([targetType, voidType]),                     );                     break;                 }                 case SyntaxKind.Parameter: {                     const node = parent as ParameterDeclaration;                     if (                         !isConstructorDeclaration(node.parent) &&                         !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent))                     ) {                         break;                     }                      if (getThisParameter(node.parent) === node) {                         break;                     }                      const index = getThisParameter(node.parent) ?                         node.parent.parameters.indexOf(node) - 1 :                         node.parent.parameters.indexOf(node);                     Debug.assert(index >= 0);                      // A parameter declaration decorator will have three arguments (see `ParameterDecorator` in                     // core.d.ts).                      const targetType = isConstructorDeclaration(node.parent) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent)) :                         getParentTypeOfClassElement(node.parent);                      const keyType = isConstructorDeclaration(node.parent) ? undefinedType :                         getClassElementPropertyKeyType(node.parent);                      const indexType = getNumberLiteralType(index);                      const targetParam = createParameter("target" as __String, targetType);                     const keyParam = createParameter("propertyKey" as __String, keyType);                     const indexParam = createParameter("parameterIndex" as __String, indexType);                     links.decoratorSignature = createCallSignature(                         /*typeParameters* / undefined,                         /*thisParameter* / undefined,                         [targetParam, keyParam, indexParam],                         voidType,                     );                     break;                 }                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                 case SyntaxKind.PropertyDeclaration: {                     const node = parent as MethodDeclaration | AccessorDeclaration | PropertyDeclaration;                     if (!isClassLike(node.parent)) break;                      // A method or accessor declaration decorator will have either two or three arguments (see                     // `PropertyDecorator` and `MethodDecorator` in core.d.ts).                      const targetType = getParentTypeOfClassElement(node);                     const targetParam = createParameter("target" as __String, targetType);                      const keyType = getClassElementPropertyKeyType(node);                     const keyParam = createParameter("propertyKey" as __String, keyType);                      const returnType = isPropertyDeclaration(node) ? voidType :                         createTypedPropertyDescriptorType(getTypeOfNode(node));                      const hasPropDesc = !isPropertyDeclaration(parent) || hasAccessorModifier(parent);                     if (hasPropDesc) {                         const descriptorType = createTypedPropertyDescriptorType(getTypeOfNode(node));                         const descriptorParam = createParameter("descriptor" as __String, descriptorType);                         links.decoratorSignature = createCallSignature(                             /*typeParameters* / undefined,                             /*thisParameter* / undefined,                             [targetParam, keyParam, descriptorParam],                             getUnionType([returnType, voidType]),                         );                     }                     else {                         links.decoratorSignature = createCallSignature(                             /*typeParameters* / undefined,                             /*thisParameter* / undefined,                             [targetParam, keyParam],                             getUnionType([returnType, voidType]),                         );                     }                     break;                 }             } */
		}
		return /* TODO(ConditionalExpression): links.decoratorSignature === anySignature ? undefined : links.decoratorSignature */ TODO
	}
	getDecoratorCallSignature := func(decorator Decorator) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature | undefined */ TODO {
		return /* TODO(ConditionalExpression): legacyDecorators ? getLegacyDecoratorCallSignature(decorator) :             getESDecoratorCallSignature(decorator) */ TODO
	}
	createPromiseType := func(promisedType Type) Type {
		globalPromiseType := getGlobalPromiseType(true)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalPromiseType !== emptyGenericType */ TODO {
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseType /* TODO(ArrayLiteralExpression): [promisedType] */, TODO)
		}
		return unknownType
	}
	createPromiseLikeType := func(promisedType Type) Type {
		globalPromiseLikeType := getGlobalPromiseLikeType(true)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalPromiseLikeType !== emptyGenericType */ TODO {
			promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType
			return createTypeReference(globalPromiseLikeType /* TODO(ArrayLiteralExpression): [promisedType] */, TODO)
		}
		return unknownType
	}
	createPromiseReturnType := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | ImportCall */ any, promisedType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		promiseType := createPromiseType(promisedType)
		if promiseType == unknownType {
			error(func_ /* TODO(ConditionalExpression): isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option */, TODO)
			return errorType
		} else if !getGlobalPromiseConstructorSymbol(true) {
			error(func_ /* TODO(ConditionalExpression): isImportCall(func) ?                     Diagnostics.A_dynamic_import_call_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option :                     Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option */, TODO)
		}
		return promiseType
	}
	createNewTargetExpressionType := func(targetType Type) Type {
		symbol := createSymbol(SymbolFlagsNone, "NewTargetExpression" /* as */ /* TODO(TypeReference): __String */)
		targetPropertySymbol := createSymbol(SymbolFlagsProperty, "target" /* as */ /* TODO(TypeReference): __String */, CheckFlagsReadonly)
		targetPropertySymbol.parent = symbol
		targetPropertySymbol.links.type_ = targetType
		members := createSymbolTable( /* TODO(ArrayLiteralExpression): [targetPropertySymbol] */ TODO)
		symbol.members = members
		return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray)
	}
	getReturnTypeFromBody := func(func_ FunctionLikeDeclaration, checkMode CheckMode) Type {
		if !func_.body {
			return errorType
		}
		functionFlags := getFunctionFlags(func_)
		isAsync := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
		isGenerator := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Generator) !== 0 */ TODO
		var returnType *Type
		var yieldType *Type
		var nextType *Type
		var fallbackReturnType Type = voidType
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.body.kind !== SyntaxKind.Block */ TODO {
			returnType = checkExpressionCached(func_.body, checkMode && checkMode&~CheckModeSkipGenericFunctions)
			if isAsync {
				returnType = unwrapAwaitedType(checkAwaitedType(returnType, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
			}
		} else if isGenerator {
			returnTypes := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !returnTypes {
				fallbackReturnType = neverType
			} else if returnTypes.length > 0 {
				returnType = getUnionType(returnTypes, UnionReductionSubtype)
			}
			TODO_IDENTIFIER := checkAndAggregateYieldOperandTypes(func_, checkMode)
			yieldType = /* TODO(ConditionalExpression): some(yieldTypes) ? getUnionType(yieldTypes, UnionReduction.Subtype) : undefined */ TODO
			nextType = /* TODO(ConditionalExpression): some(nextTypes) ? getIntersectionType(nextTypes) : undefined */ TODO
		} else {
			types := checkAndAggregateReturnExpressionTypes(func_, checkMode)
			if !types {
				return /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? createPromiseReturnType(func, neverType) // Async function                     : neverType */ TODO
			}
			if types.length == 0 {
				contextualReturnType := getContextualReturnType(func_, nil)
				returnType := /* TODO(ConditionalExpression): contextualReturnType && (unwrapReturnType(contextualReturnType, functionFlags) || voidType).flags & TypeFlags.Undefined ? undefinedType : voidType */ TODO
				return /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async ? createPromiseReturnType(func, returnType) : // Async function                     returnType */ TODO
			}
			returnType = getUnionType(types, UnionReductionSubtype)
		}
		if returnType || yieldType || nextType {
			if yieldType {
				/* TODO(CallExpression): reportErrorsFromWidening(func, yieldType, WideningKind.GeneratorYield) */
			}
			if returnType {
				/* TODO(CallExpression): reportErrorsFromWidening(func, returnType, WideningKind.FunctionReturn) */
			}
			if nextType {
				/* TODO(CallExpression): reportErrorsFromWidening(func, nextType, WideningKind.GeneratorNext) */
			}
			if returnType && isUnitType(returnType) || yieldType && isUnitType(yieldType) || nextType && isUnitType(nextType) {
				contextualSignature := getContextualSignatureForFunctionLikeDeclaration(func_)
				contextualType := /* TODO(ConditionalExpression): !contextualSignature ? undefined :                     contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? undefined : returnType :                     instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, /*contextFlags* / undefined) */ TODO
				if isGenerator {
					yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, IterationTypeKindYield, isAsync)
					returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, IterationTypeKindReturn, isAsync)
					nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, IterationTypeKindNext, isAsync)
				} else {
					returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync)
				}
			}
			if yieldType {
				/* TODO(BinaryExpression): yieldType = getWidenedType(yieldType) */
			}
			if returnType {
				/* TODO(BinaryExpression): returnType = getWidenedType(returnType) */
			}
			if nextType {
				/* TODO(BinaryExpression): nextType = getWidenedType(nextType) */
			}
		}
		if isGenerator {
			return createGeneratorType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(IterationTypeKindNext, func_) || unknownType, isAsync)
		} else {
			return /* TODO(ConditionalExpression): isAsync                 ? createPromiseType(returnType || fallbackReturnType)                 : returnType || fallbackReturnType */ TODO
		}
	}
	createGeneratorType := func(yieldType Type, returnType Type, nextType Type, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		globalGeneratorType := resolver.getGlobalGeneratorType(false)
		yieldType = resolver.resolveIterationType(yieldType, nil) || unknownType
		returnType = resolver.resolveIterationType(returnType, nil) || unknownType
		if globalGeneratorType == emptyGenericType {
			globalIterableIteratorType := resolver.getGlobalIterableIteratorType(false)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalIterableIteratorType !== emptyGenericType */ TODO {
				return createTypeFromGenericGlobalType(globalIterableIteratorType /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */, TODO)
			}
			resolver.getGlobalIterableIteratorType(true)
			return emptyObjectType
		}
		return createTypeFromGenericGlobalType(globalGeneratorType /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */, TODO)
	}
	checkAndAggregateYieldOperandTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(undefined): { yieldTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; nextTypes: import("/home/jabaile/work/TypeScript/src/compiler/types").Type[]; } */ TODO {
		var yieldTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		var nextTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		isAsync := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getFunctionFlags(func) & FunctionFlags.Async) !== 0 */ TODO
		forEachYieldExpression(func_.body /* as */ /* TODO(TypeReference): Block */, func(yieldExpression /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").YieldExpression */ TODO) {
			yieldExpressionType := /* TODO(ConditionalExpression): yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType */ TODO
			pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync))
			var nextType *Type
			if yieldExpression.asteriskToken {
				iterationTypes := getIterationTypesOfIterable(yieldExpressionType /* TODO(ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */, TODO, yieldExpression.expression)
				nextType = iterationTypes && iterationTypes.nextType
			} else {
				nextType = getContextualType(yieldExpression, nil)
			}
			if nextType {
				/* TODO(CallExpression): pushIfUnique(nextTypes, nextType) */
			}
		})
		return /* TODO(ObjectLiteralExpression): { yieldTypes, nextTypes } */ TODO
	}
	getYieldedTypeOfYieldExpression := func(node YieldExpression, expressionType Type, sentType Type, isAsync bool) *Type {
		errorNode := node.expression || node
		yieldedType := /* TODO(ConditionalExpression): node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar, expressionType, sentType, errorNode) : expressionType */ TODO
		return /* TODO(ConditionalExpression): !isAsync ? yieldedType : getAwaitedType(             yieldedType,             errorNode,             node.asteriskToken                 ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member                 : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member,         ) */ TODO
	}
	getNotEqualFactsFromTypeofSwitch := func(start number, end number, witnesses [] /* TODO(StringKeyword): string */ any) TypeFacts {
		var facts TypeFacts = TypeFactsNone
		/* TODO(ForStatement): for (let i = 0; i < witnesses.length; i++) {             const witness = i < start || i >= end ? witnesses[i] : undefined;             facts |= witness !== undefined ? typeofNEFacts.get(witness) || TypeFacts.TypeofNEHostObject : 0;         } */
		return facts
	}
	isExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		links := getNodeLinks(node)
		if links.isExhaustive == nil {
			links.isExhaustive = 0
			exhaustive := computeExhaustiveSwitchStatement(node)
			if links.isExhaustive == 0 {
				links.isExhaustive = exhaustive
			}
		} else if links.isExhaustive == 0 {
			links.isExhaustive = false
		}
		return links.isExhaustive
	}
	computeExhaustiveSwitchStatement := func(node SwitchStatement) bool {
		if node.expression.kind == SyntaxKindTypeOfExpression {
			witnesses := getSwitchClauseTypeOfWitnesses(node)
			if !witnesses {
				return false
			}
			operandConstraint := getBaseConstraintOrType(checkExpressionCached((node.expression /* as */ /* TODO(TypeReference): TypeOfExpression */).expression))
			notEqualFacts := getNotEqualFactsFromTypeofSwitch(0, 0, witnesses)
			if operandConstraint.flags & TypeFlagsAnyOrUnknown {
				return (TypeFactsAllTypeofNE & notEqualFacts) == TypeFactsAllTypeofNE
			}
			return !someType(operandConstraint, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(CallExpression): getTypeFacts(t, notEqualFacts) */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(Identifier): notEqualFacts */
			})
		}
		type_ := checkExpressionCached(node.expression)
		if !isLiteralType(type_) {
			return false
		}
		switchTypes := getSwitchClauseTypes(node)
		if !switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever) {
			return false
		}
		return eachTypeContainedIn(mapType(type_, getRegularTypeOfLiteralType), switchTypes)
	}
	functionHasImplicitReturn := func(func_ FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		return func_.endFlowNode && isReachableFlowNode(func_.endFlowNode)
	}
	checkAndAggregateReturnExpressionTypes := func(func_ FunctionLikeDeclaration, checkMode *CheckMode) /* TODO(ArrayType): Type[] */ any {
		functionFlags := getFunctionFlags(func_)
		var aggregatedTypes []Type = /* TODO(ArrayLiteralExpression): [] */ TODO
		hasReturnWithNoExpression := functionHasImplicitReturn(func_)
		hasReturnOfTypeNever := false
		forEachReturnStatement(func_.body /* as */ /* TODO(TypeReference): Block */, func(returnStatement /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) {
			expr := returnStatement.expression
			if expr {
				expr = skipParentheses(expr, true)
				if functionFlags&FunctionFlagsAsync && expr.kind == SyntaxKindAwaitExpression {
					expr = skipParentheses((expr /* as */ /* TODO(TypeReference): AwaitExpression */).expression, true)
				}
				if expr.kind == SyntaxKindCallExpression && (expr /* as */ /* TODO(TypeReference): CallExpression */).expression.kind == SyntaxKindIdentifier && checkExpressionCached((expr /* as */ /* TODO(TypeReference): CallExpression */).expression).symbol == getMergedSymbol(func_.symbol) && (!isFunctionExpressionOrArrowFunction( /* TODO(NonNullExpression): func.symbol.valueDeclaration! */ TODO) || isConstantReference((expr /* as */ /* TODO(TypeReference): CallExpression */).expression)) {
					hasReturnOfTypeNever = true
					return
				}
				type_ := checkExpressionCached(expr, checkMode && checkMode&~CheckModeSkipGenericFunctions)
				if functionFlags & FunctionFlagsAsync {
					type_ = unwrapAwaitedType(checkAwaitedType(type_, false, func_, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member))
				}
				if type_.flags & TypeFlagsNever {
					hasReturnOfTypeNever = true
				}
				pushIfUnique(aggregatedTypes, type_)
			} else {
				hasReturnWithNoExpression = true
			}
		})
		if aggregatedTypes.length == 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func_)) {
			return nil
		}
		if strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(isJSConstructor(func_) && aggregatedTypes.some(func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PropertyAccessExpression): t.symbol */
			/* TODO(EqualsEqualsEqualsToken): === */
			/* TODO(PropertyAccessExpression): func.symbol */
		})) {
			pushIfUnique(aggregatedTypes, undefinedType)
		}
		return aggregatedTypes
	}
	mayReturnNever := func(func_ FunctionLikeDeclaration) bool {
		/* TODO(SwitchStatement): switch (func.kind) {             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return true;             case SyntaxKind.MethodDeclaration:                 return func.parent.kind === SyntaxKind.ObjectLiteralExpression;             default:                 return false;         } */
	}
	getTypePredicateFromBody := func(func_ FunctionLikeDeclaration) *TypePredicate {
		/* TODO(SwitchStatement): switch (func.kind) {             case SyntaxKind.Constructor:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return undefined;         } */
		functionFlags := getFunctionFlags(func_)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): functionFlags !== FunctionFlags.Normal */ TODO {
			/* TODO(Identifier): undefined */
		}
		var singleReturn *Expression
		if func_.body && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.body.kind !== SyntaxKind.Block */ TODO {
			singleReturn = func_.body
		} else {
			bailedEarly := forEachReturnStatement(func_.body /* as */ /* TODO(TypeReference): Block */, func(returnStatement /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) /* TODO(undefined): true | undefined */ TODO {
				if singleReturn || !returnStatement.expression {
					/* TODO(TrueKeyword): true */
				}
				singleReturn = returnStatement.expression
			})
			if bailedEarly || !singleReturn || functionHasImplicitReturn(func_) {
				/* TODO(Identifier): undefined */
			}
		}
		return checkIfExpressionRefinesAnyParameter(func_, singleReturn)
	}
	checkIfExpressionRefinesAnyParameter := func(func_ FunctionLikeDeclaration, expr Expression) *TypePredicate {
		expr = skipParentheses(expr, true)
		returnType := checkExpressionCached(expr)
		if !(returnType.flags & TypeFlagsBoolean) {
			/* TODO(Identifier): undefined */
		}
		return forEach(func_.parameters, func(param /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, i /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypePredicate | undefined */ TODO {
			initType := getTypeOfSymbol(param.symbol)
			if !initType || initType.flags&TypeFlagsBoolean || !isIdentifier(param.name) || isSymbolAssigned(param.symbol) || isRestParameter(param) {
				return
			}
			trueType := checkIfExpressionRefinesParameter(func_, expr, param, initType)
			if trueType {
				return createTypePredicate(TypePredicateKindIdentifier, unescapeLeadingUnderscores(param.name.escapedText), i, trueType)
			}
		})
	}
	checkIfExpressionRefinesParameter := func(func_ FunctionLikeDeclaration, expr Expression, param ParameterDeclaration, initType Type) *Type {
		antecedent := (expr /* as */ /* TODO(IntersectionType): Expression & { flowNode?: FlowNode; } */).flowNode || expr.parent.kind == SyntaxKindReturnStatement && (expr.parent /* as */ /* TODO(TypeReference): ReturnStatement */).flowNode || createFlowNode(FlowFlagsStart, nil, nil)
		trueCondition := createFlowNode(FlowFlagsTrueCondition, expr, antecedent)
		trueType := getFlowTypeOfReference(param.name, initType, initType, func_, trueCondition)
		if trueType == initType {
			/* TODO(Identifier): undefined */
		}
		falseCondition := createFlowNode(FlowFlagsFalseCondition, expr, antecedent)
		falseSubtype := getFlowTypeOfReference(param.name, initType, trueType, func_, falseCondition)
		return /* TODO(ConditionalExpression): falseSubtype.flags & TypeFlags.Never ? trueType : undefined */ TODO
	}
	checkAllCodePathsInNonVoidFunctionReturnOrThrow := func(func_ /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnType *Type) {
		addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics)
		return
		checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics := func() {
			functionFlags := getFunctionFlags(func_)
			type_ := returnType && unwrapReturnType(returnType, functionFlags)
			if type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)) {
				return
			}
			if func_.kind == SyntaxKindMethodSignature || nodeIsMissing(func_.body) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.body!.kind !== SyntaxKind.Block */ TODO || !functionHasImplicitReturn(func_) {
				return
			}
			hasExplicitReturn := func_.flags & NodeFlagsHasExplicitReturn
			errorNode := getEffectiveReturnTypeNode(func_) || func_
			if type_ && type_.flags&TypeFlagsNever {
				error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point)
			} else if type_ && !hasExplicitReturn {
				error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value)
			} else if type_ && strictNullChecks && !isTypeAssignableTo(undefinedType, type_) {
				error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined)
			} else if compilerOptions.noImplicitReturns {
				if !type_ {
					if !hasExplicitReturn {
						return
					}
					inferredReturnType := getReturnTypeOfSignature(getSignatureFromDeclaration(func_))
					if isUnwrappedReturnTypeUndefinedVoidOrAny(func_, inferredReturnType) {
						return
					}
				}
				error(errorNode, Diagnostics.Not_all_code_paths_return_a_value)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) Type {
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		checkNodeDeferred(node)
		if isFunctionExpression(node) {
			checkCollisionsForDeclarationName(node, node.name)
		}
		if checkMode && checkMode&CheckModeSkipContextSensitive && isContextSensitive(node) {
			if !getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node) {
				contextualSignature := getContextualSignature(node)
				if contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature)) {
					links := getNodeLinks(node)
					if links.contextFreeType {
						return links.contextFreeType
					}
					returnType := getReturnTypeFromBody(node, checkMode)
					returnOnlySignature := createSignature(nil, nil, nil, emptyArray, returnType, nil, 0, SignatureFlagsIsNonInferrable)
					returnOnlyType := createAnonymousType(node.symbol, emptySymbols /* TODO(ArrayLiteralExpression): [returnOnlySignature] */, TODO, emptyArray, emptyArray)
					returnOnlyType.objectFlags |= ObjectFlagsNonInferrableType
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.contextFreeType = returnOnlyType */ TODO
				}
			}
			return anyFunctionType
		}
		hasGrammarError := checkGrammarFunctionLikeDeclaration(node)
		if !hasGrammarError && node.kind == SyntaxKindFunctionExpression {
			checkGrammarForGenerator(node)
		}
		contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	contextuallyCheckFunctionExpressionOrObjectLiteralMethod := func(node /* TODO(UnionType): FunctionExpression | ArrowFunction | MethodDeclaration */ any, checkMode CheckMode) {
		links := getNodeLinks(node)
		if !(links.flags & NodeCheckFlagsContextChecked) {
			contextualSignature := getContextualSignature(node)
			if !(links.flags & NodeCheckFlagsContextChecked) {
				links.flags |= NodeCheckFlagsContextChecked
				signature := firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), SignatureKindCall))
				if !signature {
					return
				}
				if isContextSensitive(node) {
					if contextualSignature {
						inferenceContext := getInferenceContext(node)
						var instantiatedContextualSignature *Signature
						if checkMode && checkMode&CheckModeInferential {
							inferFromAnnotatedParameters(signature, contextualSignature /* TODO(NonNullExpression): inferenceContext! */, TODO)
							restType := getEffectiveRestType(contextualSignature)
							if restType && restType.flags&TypeFlagsTypeParameter {
								instantiatedContextualSignature = instantiateSignature(contextualSignature /* TODO(NonNullExpression): inferenceContext! */, TODO.nonFixingMapper)
							}
						}
						/* TODO(ExpressionStatement): instantiatedContextualSignature ||= inferenceContext ?                             instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature; */
						assignContextualParameterTypes(signature, instantiatedContextualSignature)
					} else {
						assignNonContextualParameterTypes(signature)
					}
				} else if contextualSignature && !node.typeParameters && contextualSignature.parameters.length > node.parameters.length {
					inferenceContext := getInferenceContext(node)
					if checkMode && checkMode&CheckModeInferential {
						inferFromAnnotatedParameters(signature, contextualSignature /* TODO(NonNullExpression): inferenceContext! */, TODO)
					}
				}
				if contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType {
					returnType := getReturnTypeFromBody(node, checkMode)
					if !signature.resolvedReturnType {
						signature.resolvedReturnType = returnType
					}
				}
				checkSignatureDeclaration(node)
			}
		}
	}
	checkFunctionExpressionOrObjectLiteralMethodDeferred := func(node /* TODO(UnionType): ArrowFunction | FunctionExpression | MethodDeclaration */ any) {
		Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.MethodDeclaration */ TODO || isObjectLiteralMethod(node))
		functionFlags := getFunctionFlags(node)
		returnType := getReturnTypeFromAnnotation(node)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
		if node.body {
			if !getEffectiveReturnTypeNode(node) {
				getReturnTypeOfSignature(getSignatureFromDeclaration(node))
			}
			if node.body.kind == SyntaxKindBlock {
				checkSourceElement(node.body)
			} else {
				exprType := checkExpression(node.body)
				returnOrPromisedType := returnType && unwrapReturnType(returnType, functionFlags)
				if returnOrPromisedType {
					effectiveCheckNode := getEffectiveCheckNode(node.body)
					if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
						awaitedType := checkAwaitedType(exprType, false, effectiveCheckNode, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
						checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, effectiveCheckNode, effectiveCheckNode)
					}
				}
			}
		}
	}
	checkArithmeticOperandType := func(operand Node, type_ Type, diagnostic DiagnosticMessage, isAwaitValid /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) bool {
		if !isTypeAssignableTo(type_, numberOrBigIntType) {
			awaitedType := isAwaitValid && getAwaitedTypeOfPromise(type_)
			errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic)
			return false
		}
		return true
	}
	isReadonlyAssignmentDeclaration := func(d Declaration) /* TODO(undefined): boolean */ TODO {
		if !isCallExpression(d) {
			return false
		}
		if !isBindableObjectDefinePropertyCall(d) {
			return false
		}
		objectLitType := checkExpressionCached( /* TODO(ElementAccessExpression): d.arguments[2] */ TODO)
		valueType := getTypeOfPropertyOfType(objectLitType, "value" /* as */ /* TODO(TypeReference): __String */)
		if valueType {
			writableProp := getPropertyOfType(objectLitType, "writable" /* as */ /* TODO(TypeReference): __String */)
			writableType := writableProp && getTypeOfSymbol(writableProp)
			if !writableType || writableType == falseType || writableType == regularFalseType {
				return true
			}
			if writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration) {
				initializer := writableProp.valueDeclaration.initializer
				rawOriginalType := checkExpression(initializer)
				if rawOriginalType == falseType || rawOriginalType == regularFalseType {
					return true
				}
			}
			return false
		}
		setProp := getPropertyOfType(objectLitType, "set" /* as */ /* TODO(TypeReference): __String */)
		return !setProp
	}
	isReadonlySymbol := func(symbol Symbol) bool {
		return !!(getCheckFlags(symbol)&CheckFlagsReadonly || symbol.flags&SymbolFlagsProperty && getDeclarationModifierFlagsFromSymbol(symbol)&ModifierFlagsReadonly || symbol.flags&SymbolFlagsVariable && getDeclarationNodeFlagsFromSymbol(symbol)&NodeFlagsConstant || symbol.flags&SymbolFlagsAccessor && !(symbol.flags&SymbolFlagsSetAccessor) || symbol.flags&SymbolFlagsEnumMember || some(symbol.declarations, isReadonlyAssignmentDeclaration))
	}
	isAssignmentToReadonlyEntity := func(expr Expression, symbol Symbol, assignmentKind AssignmentKind) /* TODO(undefined): boolean */ TODO {
		if assignmentKind == AssignmentKindNone {
			return false
		}
		if isReadonlySymbol(symbol) {
			if symbol.flags&SymbolFlagsProperty && isAccessExpression(expr) && expr.expression.kind == SyntaxKindThisKeyword {
				ctor := getContainingFunction(expr)
				if !(ctor && (ctor.kind == SyntaxKindConstructor || isJSConstructor(ctor))) {
					return true
				}
				if symbol.valueDeclaration {
					isAssignmentDeclaration := isBinaryExpression(symbol.valueDeclaration)
					isLocalPropertyDeclaration := ctor.parent == symbol.valueDeclaration.parent
					isLocalParameterProperty := ctor == symbol.valueDeclaration.parent
					isLocalThisPropertyAssignment := isAssignmentDeclaration && symbol.parent.valueDeclaration == ctor.parent
					isLocalThisPropertyAssignmentConstructorFunction := isAssignmentDeclaration && symbol.parent.valueDeclaration == ctor
					isWriteableSymbol := isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction
					return !isWriteableSymbol
				}
			}
			return true
		}
		if isAccessExpression(expr) {
			node := skipParentheses(expr.expression)
			if node.kind == SyntaxKindIdentifier {
				symbol := /* TODO(NonNullExpression): getNodeLinks(node).resolvedSymbol! */ TODO
				if symbol.flags & SymbolFlagsAlias {
					declaration := getDeclarationOfAliasSymbol(symbol)
					return !!declaration && declaration.kind == SyntaxKindNamespaceImport
				}
			}
		}
		return false
	}
	checkReferenceExpression := func(expr Expression, invalidReferenceMessage DiagnosticMessage, invalidOptionalChainMessage DiagnosticMessage) bool {
		node := skipOuterExpressions(expr, OuterExpressionKindsAssertions|OuterExpressionKindsParentheses)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.Identifier */ TODO && !isAccessExpression(node) {
			error(expr, invalidReferenceMessage)
			return false
		}
		if node.flags & NodeFlagsOptionalChain {
			error(expr, invalidOptionalChainMessage)
			return false
		}
		return true
	}
	checkDeleteExpression := func(node DeleteExpression) Type {
		checkExpression(node.expression)
		expr := skipParentheses(node.expression)
		if !isAccessExpression(expr) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference)
			return booleanType
		}
		if isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier)
		}
		links := getNodeLinks(expr)
		symbol := getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol)
		if symbol {
			if isReadonlySymbol(symbol) {
				error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property)
			} else {
				checkDeleteExpressionMustBeOptional(expr, symbol)
			}
		}
		return booleanType
	}
	checkDeleteExpressionMustBeOptional := func(expr AccessExpression, symbol Symbol) {
		type_ := getTypeOfSymbol(symbol)
		if strictNullChecks && !(type_.flags & (TypeFlagsAnyOrUnknown | TypeFlagsNever)) && !( /* TODO(ConditionalExpression): exactOptionalPropertyTypes ? symbol.flags & SymbolFlags.Optional : hasTypeFacts(type, TypeFacts.IsUndefined) */ TODO) {
			error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional)
		}
	}
	checkTypeOfExpression := func(node TypeOfExpression) Type {
		checkExpression(node.expression)
		return typeofType
	}
	checkVoidExpression := func(node VoidExpression) Type {
		checkNodeDeferred(node)
		return undefinedWideningType
	}
	checkAwaitGrammar := func(node /* TODO(UnionType): AwaitExpression | VariableDeclarationList */ any) bool {
		hasError := false
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expression_cannot_be_used_inside_a_class_static_block :                 Diagnostics.await_using_statements_cannot_be_used_inside_a_class_static_block */ TODO
			error(node, message)
			hasError = true
		} else if !(node.flags & NodeFlagsAwaitContext) {
			if isInTopLevelContext(node) {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					var span *TextSpan
					if !isEffectiveExternalModule(sourceFile, compilerOptions) {
						/* TODO(ExpressionStatement): span ??= getSpanOfTokenAtPosition(sourceFile, node.pos); */
						message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module :                             Diagnostics.await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module */ TODO
						diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
						diagnostics.add(diagnostic)
						hasError = true
					}
					/* TODO(SwitchStatement): switch (moduleKind) {                         case ModuleKind.Node16:                         case ModuleKind.NodeNext:                             if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {                                 span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);                                 diagnostics.add(                                     createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),                                 );                                 hasError = true;                                 break;                             }                             // fallthrough                         case ModuleKind.ES2022:                         case ModuleKind.ESNext:                         case ModuleKind.Preserve:                         case ModuleKind.System:                             if (languageVersion >= ScriptTarget.ES2017) {                                 break;                             }                             // fallthrough                         default:                             span ??= getSpanOfTokenAtPosition(sourceFile, node.pos);                             const message = isAwaitExpression(node) ? Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher :                                 Diagnostics.Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher;                             diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message));                             hasError = true;                             break;                     } */
				}
			} else {
				sourceFile := getSourceFileOfNode(node)
				if !hasParseDiagnostics(sourceFile) {
					span := getSpanOfTokenAtPosition(sourceFile, node.pos)
					message := /* TODO(ConditionalExpression): isAwaitExpression(node) ? Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules :                         Diagnostics.await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules */ TODO
					diagnostic := createFileDiagnostic(sourceFile, span.start, span.length, message)
					if container && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): container.kind !== SyntaxKind.Constructor */ TODO && (getFunctionFlags(container)&FunctionFlagsAsync) == 0 {
						relatedInfo := createDiagnosticForNode(container, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
						addRelatedInfo(diagnostic, relatedInfo)
					}
					diagnostics.add(diagnostic)
					hasError = true
				}
			}
		}
		if isAwaitExpression(node) && isInParameterInitializerBeforeContainingFunction(node) {
			error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer)
			hasError = true
		}
		return hasError
	}
	checkAwaitExpression := func(node AwaitExpression) Type {
		addLazyDiagnostic(func() /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): checkAwaitGrammar */
			/* TODO(Identifier): node */
		})
		operandType := checkExpression(node.expression)
		awaitedType := checkAwaitedType(operandType, true, node, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		if awaitedType == operandType && !isErrorType(awaitedType) && !(operandType.flags & TypeFlagsAnyOrUnknown) {
			addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression))
		}
		return awaitedType
	}
	checkPrefixUnaryExpression := func(node PrefixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		/* TODO(SwitchStatement): switch (node.operand.kind) {             case SyntaxKind.NumericLiteral:                 switch (node.operator) {                     case SyntaxKind.MinusToken:                         return getFreshTypeOfLiteralType(getNumberLiteralType(-(node.operand as NumericLiteral).text));                     case SyntaxKind.PlusToken:                         return getFreshTypeOfLiteralType(getNumberLiteralType(+(node.operand as NumericLiteral).text));                 }                 break;             case SyntaxKind.BigIntLiteral:                 if (node.operator === SyntaxKind.MinusToken) {                     return getFreshTypeOfLiteralType(getBigIntLiteralType({                         negative: true,                         base10Value: parsePseudoBigInt((node.operand as BigIntLiteral).text),                     }));                 }         } */
		/* TODO(SwitchStatement): switch (node.operator) {             case SyntaxKind.PlusToken:             case SyntaxKind.MinusToken:             case SyntaxKind.TildeToken:                 checkNonNullType(operandType, node.operand);                 if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.ESSymbolLike)) {                     error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator));                 }                 if (node.operator === SyntaxKind.PlusToken) {                     if (maybeTypeOfKindConsideringBaseConstraint(operandType, TypeFlags.BigIntLike)) {                         error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));                     }                     return numberType;                 }                 return getUnaryResultType(operandType);             case SyntaxKind.ExclamationToken:                 checkTruthinessOfType(operandType, node.operand);                 const facts = getTypeFacts(operandType, TypeFacts.Truthy | TypeFacts.Falsy);                 return facts === TypeFacts.Truthy ? falseType :                     facts === TypeFacts.Falsy ? trueType :                     booleanType;             case SyntaxKind.PlusPlusToken:             case SyntaxKind.MinusMinusToken:                 const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);                 if (ok) {                     // run check only if former checks succeeded to avoid reporting cascading errors                     checkReferenceExpression(                         node.operand,                         Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,                         Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access,                     );                 }                 return getUnaryResultType(operandType);         } */
		return errorType
	}
	checkPostfixUnaryExpression := func(node PostfixUnaryExpression) Type {
		operandType := checkExpression(node.operand)
		if operandType == silentNeverType {
			return silentNeverType
		}
		ok := checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type)
		if ok {
			checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access)
		}
		return getUnaryResultType(operandType)
	}
	getUnaryResultType := func(operandType Type) Type {
		if maybeTypeOfKind(operandType, TypeFlagsBigIntLike) {
			return /* TODO(ConditionalExpression): isTypeAssignableToKind(operandType, TypeFlags.AnyOrUnknown) || maybeTypeOfKind(operandType, TypeFlags.NumberLike)                 ? numberOrBigIntType                 : bigintType */ TODO
		}
		return numberType
	}
	maybeTypeOfKindConsideringBaseConstraint := func(type_ Type, kind TypeFlags) bool {
		if maybeTypeOfKind(type_, kind) {
			return true
		}
		baseConstraint := getBaseConstraintOrType(type_)
		return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind)
	}
	maybeTypeOfKind := func(type_ Type, kind TypeFlags) bool {
		if type_.flags & kind {
			return true
		}
		if type_.flags & TypeFlagsUnionOrIntersection {
			types := (type_ /* as */ /* TODO(TypeReference): UnionOrIntersectionType */).types
			for _, t := range types {
				if maybeTypeOfKind(t, kind) {
					return true
				}
			}
		}
		return false
	}
	isTypeAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		if source.flags & kind {
			return true
		}
		if strict && source.flags&(TypeFlagsAnyOrUnknown|TypeFlagsVoid|TypeFlagsUndefined|TypeFlagsNull) {
			return false
		}
		return !!(kind&TypeFlagsNumberLike) && isTypeAssignableTo(source, numberType) || !!(kind&TypeFlagsBigIntLike) && isTypeAssignableTo(source, bigintType) || !!(kind&TypeFlagsStringLike) && isTypeAssignableTo(source, stringType) || !!(kind&TypeFlagsBooleanLike) && isTypeAssignableTo(source, booleanType) || !!(kind&TypeFlagsVoid) && isTypeAssignableTo(source, voidType) || !!(kind&TypeFlagsNever) && isTypeAssignableTo(source, neverType) || !!(kind&TypeFlagsNull) && isTypeAssignableTo(source, nullType) || !!(kind&TypeFlagsUndefined) && isTypeAssignableTo(source, undefinedType) || !!(kind&TypeFlagsESSymbol) && isTypeAssignableTo(source, esSymbolType) || !!(kind&TypeFlagsNonPrimitive) && isTypeAssignableTo(source, nonPrimitiveType)
	}
	allTypesAssignableToKind := func(source Type, kind TypeFlags, strict bool) bool {
		return /* TODO(ConditionalExpression): source.flags & TypeFlags.Union ?             every((source as UnionType).types, subType => allTypesAssignableToKind(subType, kind, strict)) :             isTypeAssignableToKind(source, kind, strict) */ TODO
	}
	isConstEnumObjectType := func(type_ Type) bool {
		return !!(getObjectFlags(type_) & ObjectFlagsAnonymous) && !!type_.symbol && isConstEnumSymbol(type_.symbol)
	}
	isConstEnumSymbol := func(symbol Symbol) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.ConstEnum) !== 0 */ TODO
	}
	getSymbolHasInstanceMethodOfObjectType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		hasInstancePropertyName := getPropertyNameForKnownSymbolName("hasInstance")
		if allTypesAssignableToKind(type_, TypeFlagsNonPrimitive) {
			hasInstanceProperty := getPropertyOfType(type_, hasInstancePropertyName)
			if hasInstanceProperty {
				hasInstancePropertyType := getTypeOfSymbol(hasInstanceProperty)
				if hasInstancePropertyType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSignaturesOfType(hasInstancePropertyType, SignatureKind.Call).length !== 0 */ TODO {
					return hasInstancePropertyType
				}
			}
		}
	}
	checkInstanceOfExpression := func(left Expression, right Expression, leftType Type, rightType Type, checkMode CheckMode) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if !isTypeAny(leftType) && allTypesAssignableToKind(leftType, TypeFlagsPrimitive) {
			error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter)
		}
		Debug.assert(isInstanceOfExpression(left.parent))
		signature := getResolvedSignature(left.parent, nil, checkMode)
		if signature == resolvingSignature {
			return silentNeverType
		}
		returnType := getReturnTypeOfSignature(signature)
		checkTypeAssignableTo(returnType, booleanType, right, Diagnostics.An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression)
		return booleanType
	}
	hasEmptyObjectIntersection := func(type_ Type) bool {
		return someType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): t === unknownEmptyObjectType */
			/* TODO(BarBarToken): || */
			/* TODO(BinaryExpression): !!(t.flags & TypeFlags.Intersection) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t)) */
		})
	}
	checkInExpression := func(left Expression, right Expression, leftType Type, rightType Type) Type {
		if leftType == silentNeverType || rightType == silentNeverType {
			return silentNeverType
		}
		if isPrivateIdentifier(left) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				checkExternalEmitHelpers(left, ExternalEmitHelpersClassPrivateFieldIn)
			}
			if !getNodeLinks(left).resolvedSymbol && getContainingClass(left) {
				isUncheckedJS := isUncheckedJSSuggestion(left, rightType.symbol, true)
				reportNonexistentProperty(left, rightType, isUncheckedJS)
			}
		} else {
			checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left)
		}
		if checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right) {
			if hasEmptyObjectIntersection(rightType) {
				error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType))
			}
		}
		return booleanType
	}
	checkObjectLiteralAssignment := func(node ObjectLiteralExpression, sourceType Type, rightIsThis bool) Type {
		properties := node.properties
		if strictNullChecks && properties.length == 0 {
			return checkNonNullType(sourceType, node)
		}
		/* TODO(ForStatement): for (let i = 0; i < properties.length; i++) {             checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);         } */
		return sourceType
	}
	checkObjectLiteralDestructuringPropertyAssignment := func(node ObjectLiteralExpression, objectLiteralType Type, propertyIndex number, allProperties NodeArray[ObjectLiteralElementLike], rightIsThis /* TODO(undefined): boolean */ TODO /* = */ /* TODO(FalseKeyword): false */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		properties := node.properties
		property := /* TODO(ElementAccessExpression): properties[propertyIndex] */ TODO
		if property.kind == SyntaxKindPropertyAssignment || property.kind == SyntaxKindShorthandPropertyAssignment {
			name := property.name
			exprType := getLiteralTypeFromPropertyName(name)
			if isTypeUsableAsPropertyName(exprType) {
				text := getPropertyNameFromType(exprType)
				prop := getPropertyOfType(objectLiteralType, text)
				if prop {
					markPropertyAsReferenced(prop, property, rightIsThis)
					checkPropertyAccessibility(property, false, true, objectLiteralType, prop)
				}
			}
			elementType := getIndexedAccessType(objectLiteralType, exprType, AccessFlagsExpressionPosition|( /* TODO(ConditionalExpression): hasDefaultValue(property) ? AccessFlags.AllowMissing : 0 */ TODO), name)
			type_ := getFlowTypeOfDestructuring(property, elementType)
			return checkDestructuringAssignment( /* TODO(ConditionalExpression): property.kind === SyntaxKind.ShorthandPropertyAssignment ? property : property.initializer */ TODO, type_)
		} else if property.kind == SyntaxKindSpreadAssignment {
			if propertyIndex < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): properties.length - 1 */ TODO {
				error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				if languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
					checkExternalEmitHelpers(property, ExternalEmitHelpersRest)
				}
				var nonRestNames []PropertyName = /* TODO(ArrayLiteralExpression): [] */ TODO
				if allProperties {
					for _, otherProperty := range allProperties {
						if !isSpreadAssignment(otherProperty) {
							nonRestNames.push(otherProperty.name)
						}
					}
				}
				type_ := getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol)
				checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
				return checkDestructuringAssignment(property.expression, type_)
			}
		} else {
			error(property, Diagnostics.Property_assignment_expected)
		}
	}
	checkArrayLiteralAssignment := func(node ArrayLiteralExpression, sourceType Type, checkMode CheckMode) Type {
		elements := node.elements
		if languageVersion < LanguageFeatureMinimumTargetDestructuringAssignment && compilerOptions.downlevelIteration {
			checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
		}
		possiblyOutOfBoundsType := checkIteratedTypeOrElementType(IterationUseDestructuring|IterationUsePossiblyOutOfBounds, sourceType, undefinedType, node) || errorType
		var inBoundsType *Type = /* TODO(ConditionalExpression): compilerOptions.noUncheckedIndexedAccess ? undefined : possiblyOutOfBoundsType */ TODO
		/* TODO(ForStatement): for (let i = 0; i < elements.length; i++) {             let type = possiblyOutOfBoundsType;             if (node.elements[i].kind === SyntaxKind.SpreadElement) {                 type = inBoundsType = inBoundsType ?? (checkIteratedTypeOrElementType(IterationUse.Destructuring, sourceType, undefinedType, node) || errorType);             }             checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type, checkMode);         } */
		return sourceType
	}
	checkArrayLiteralDestructuringElementAssignment := func(node ArrayLiteralExpression, sourceType Type, elementIndex number, elementType Type, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		elements := node.elements
		element := /* TODO(ElementAccessExpression): elements[elementIndex] */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): element.kind !== SyntaxKind.OmittedExpression */ TODO {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): element.kind !== SyntaxKind.SpreadElement */ TODO {
				indexType := getNumberLiteralType(elementIndex)
				if isArrayLikeType(sourceType) {
					accessFlags := AccessFlagsExpressionPosition | ( /* TODO(ConditionalExpression): hasDefaultValue(element) ? AccessFlags.AllowMissing : 0 */ TODO)
					elementType := getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType
					assignedType := /* TODO(ConditionalExpression): hasDefaultValue(element) ? getTypeWithFacts(elementType, TypeFacts.NEUndefined) : elementType */ TODO
					type_ := getFlowTypeOfDestructuring(element, assignedType)
					return checkDestructuringAssignment(element, type_, checkMode)
				}
				return checkDestructuringAssignment(element, elementType, checkMode)
			}
			if elementIndex < /* TODO(MinusToken): - */ /* TODO(BinaryExpression): elements.length - 1 */ TODO {
				error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			} else {
				restExpression := (element /* as */ /* TODO(TypeReference): SpreadElement */).expression
				if restExpression.kind == SyntaxKindBinaryExpression && (restExpression /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken {
					error((restExpression /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer)
				} else {
					checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
					type_ := /* TODO(ConditionalExpression): everyType(sourceType, isTupleType) ?                         mapType(sourceType, t => sliceTupleType(t as TupleTypeReference, elementIndex)) :                         createArrayType(elementType) */ TODO
					return checkDestructuringAssignment(restExpression, type_, checkMode)
				}
			}
		}
		return nil
	}
	checkDestructuringAssignment := func(exprOrAssignment /* TODO(UnionType): Expression | ShorthandPropertyAssignment */ any, sourceType Type, checkMode CheckMode, rightIsThis bool) Type {
		var target Expression
		if exprOrAssignment.kind == SyntaxKindShorthandPropertyAssignment {
			prop := exprOrAssignment /* as */ /* TODO(TypeReference): ShorthandPropertyAssignment */
			if prop.objectAssignmentInitializer {
				if strictNullChecks && !(hasTypeFacts(checkExpression(prop.objectAssignmentInitializer), TypeFactsIsUndefined)) {
					sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
				}
				checkBinaryLikeExpression(prop.name /* TODO(NonNullExpression): prop.equalsToken! */, TODO, prop.objectAssignmentInitializer, checkMode)
			}
			target = (exprOrAssignment /* as */ /* TODO(TypeReference): ShorthandPropertyAssignment */).name
		} else {
			target = exprOrAssignment
		}
		if target.kind == SyntaxKindBinaryExpression && (target /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindEqualsToken {
			checkBinaryExpression(target /* as */ /* TODO(TypeReference): BinaryExpression */, checkMode)
			target = (target /* as */ /* TODO(TypeReference): BinaryExpression */).left
			if strictNullChecks {
				sourceType = getTypeWithFacts(sourceType, TypeFactsNEUndefined)
			}
		}
		if target.kind == SyntaxKindObjectLiteralExpression {
			return checkObjectLiteralAssignment(target /* as */ /* TODO(TypeReference): ObjectLiteralExpression */, sourceType, rightIsThis)
		}
		if target.kind == SyntaxKindArrayLiteralExpression {
			return checkArrayLiteralAssignment(target /* as */ /* TODO(TypeReference): ArrayLiteralExpression */, sourceType, checkMode)
		}
		return checkReferenceAssignment(target, sourceType, checkMode)
	}
	checkReferenceAssignment := func(target Expression, sourceType Type, checkMode CheckMode) Type {
		targetType := checkExpression(target, checkMode)
		error := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access */ TODO
		optionalError := /* TODO(ConditionalExpression): target.parent.kind === SyntaxKind.SpreadAssignment ?             Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access :             Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access */ TODO
		if checkReferenceExpression(target, error, optionalError) {
			checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target)
		}
		if isPrivateIdentifierPropertyAccessExpression(target) {
			checkExternalEmitHelpers(target.parent, ExternalEmitHelpersClassPrivateFieldSet)
		}
		return sourceType
	}
	isSideEffectFree := func(node Node) bool {
		node = skipParentheses(node)
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.StringLiteral:             case SyntaxKind.RegularExpressionLiteral:             case SyntaxKind.TaggedTemplateExpression:             case SyntaxKind.TemplateExpression:             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.NumericLiteral:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.TrueKeyword:             case SyntaxKind.FalseKeyword:             case SyntaxKind.NullKeyword:             case SyntaxKind.UndefinedKeyword:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ClassExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.TypeOfExpression:             case SyntaxKind.NonNullExpression:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.JsxElement:                 return true;              case SyntaxKind.ConditionalExpression:                 return isSideEffectFree((node as ConditionalExpression).whenTrue) &&                     isSideEffectFree((node as ConditionalExpression).whenFalse);              case SyntaxKind.BinaryExpression:                 if (isAssignmentOperator((node as BinaryExpression).operatorToken.kind)) {                     return false;                 }                 return isSideEffectFree((node as BinaryExpression).left) &&                     isSideEffectFree((node as BinaryExpression).right);              case SyntaxKind.PrefixUnaryExpression:             case SyntaxKind.PostfixUnaryExpression:                 // Unary operators ~, !, +, and - have no side effects.                 // The rest do.                 switch ((node as PrefixUnaryExpression).operator) {                     case SyntaxKind.ExclamationToken:                     case SyntaxKind.PlusToken:                     case SyntaxKind.MinusToken:                     case SyntaxKind.TildeToken:                         return true;                 }                 return false;              // Some forms listed here for clarity             case SyntaxKind.VoidExpression: // Explicit opt-out             case SyntaxKind.TypeAssertionExpression: // Not SEF, but can produce useful type warnings             case SyntaxKind.AsExpression: // Not SEF, but can produce useful type warnings             default:                 return false;         } */
	}
	isTypeEqualityComparableTo := func(source Type, target Type) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (target.flags & TypeFlags.Nullable) !== 0 */ TODO || isTypeComparableTo(source, target)
	}
	createCheckBinaryExpression := func() /* TODO(undefined): (node: import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression, checkMode: import("/home/jabaile/work/TypeScript/src/compiler/checker").CheckMode | undefined) => import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		type WorkArea struct {
			checkMode  *CheckMode
			skip       bool
			stackIndex number
			typeStack  []*Type
		}
		trampoline := createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState)
		return func(node BinaryExpression, checkMode *CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
			result := trampoline(node, checkMode)
			Debug.assertIsDefined(result)
			return result
		}
		onEnter := func(node BinaryExpression, state *WorkArea, checkMode *CheckMode) /* TODO(undefined): WorkArea */ TODO {
			if state {
				state.stackIndex++
				state.skip = false
				setLeftType(state, nil)
				setLastResult(state, nil)
			} else {
				state = /* TODO(ObjectLiteralExpression): {                     checkMode,                     skip: false,                     stackIndex: 0,                     typeStack: [undefined, undefined],                 } */ TODO
			}
			if isInJSFile(node) && getAssignedExpandoInitializer(node) {
				state.skip = true
				setLastResult(state, checkExpression(node.right, checkMode))
				return state
			}
			checkNullishCoalesceOperands(node)
			operator := node.operatorToken.kind
			if operator == SyntaxKindEqualsToken && (node.left.kind == SyntaxKindObjectLiteralExpression || node.left.kind == SyntaxKindArrayLiteralExpression) {
				state.skip = true
				setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind == SyntaxKindThisKeyword))
				return state
			}
			return state
		}
		onLeft := func(left Expression, state WorkArea, _node BinaryExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
			if !state.skip {
				return maybeCheckExpression(state, left)
			}
		}
		onOperator := func(operatorToken BinaryOperatorToken, state WorkArea, node BinaryExpression) {
			if !state.skip {
				leftType := getLastResult(state)
				Debug.assertIsDefined(leftType)
				setLeftType(state, leftType)
				setLastResult(state, nil)
				operator := operatorToken.kind
				if isLogicalOrCoalescingBinaryOperator(operator) {
					parent := node.parent
					/* TODO(WhileStatement): while (parent.kind === SyntaxKind.ParenthesizedExpression || isLogicalOrCoalescingBinaryExpression(parent)) {                         parent = parent.parent;                     } */
					if operator == SyntaxKindAmpersandAmpersandToken || isIfStatement(parent) {
						checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.left, leftType /* TODO(ConditionalExpression): isIfStatement(parent) ? parent.thenStatement : undefined */, TODO)
					}
					if isBinaryLogicalOperator(operator) {
						checkTruthinessOfType(leftType, node.left)
					}
				}
			}
		}
		onRight := func(right Expression, state WorkArea, _node BinaryExpression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").BinaryExpression | undefined */ TODO {
			if !state.skip {
				return maybeCheckExpression(state, right)
			}
		}
		onExit := func(node BinaryExpression, state WorkArea) *Type {
			var result *Type
			if state.skip {
				result = getLastResult(state)
			} else {
				leftType := getLeftType(state)
				Debug.assertIsDefined(leftType)
				rightType := getLastResult(state)
				Debug.assertIsDefined(rightType)
				result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, state.checkMode, node)
			}
			state.skip = false
			setLeftType(state, nil)
			setLastResult(state, nil)
			state.stackIndex--
			return result
		}
		foldState := func(state WorkArea, result *Type, _side /* TODO(UnionType): "left" | "right" */ any) /* TODO(undefined): WorkArea */ TODO {
			setLastResult(state, result)
			return state
		}
		maybeCheckExpression := func(state WorkArea, node Expression) *BinaryExpression {
			if isBinaryExpression(node) {
				return node
			}
			setLastResult(state, checkExpression(node, state.checkMode))
		}
		getLeftType := func(state WorkArea) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex] */ TODO
		}
		setLeftType := func(state WorkArea, type_ *Type) {
			/* TODO(ElementAccessExpression): state.typeStack[state.stackIndex] */ TODO = type_
		}
		getLastResult := func(state WorkArea) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
			return /* TODO(ElementAccessExpression): state.typeStack[state.stackIndex + 1] */ TODO
		}
		setLastResult := func(state WorkArea, type_ *Type) {
			/* TODO(ElementAccessExpression): state.typeStack[state.stackIndex + 1] */ TODO = type_
		}
	}
	checkNullishCoalesceOperands := func(node BinaryExpression) {
		TODO_IDENTIFIER := node
		if operatorToken.kind == SyntaxKindQuestionQuestionToken {
			if isBinaryExpression(left) && (left.operatorToken.kind == SyntaxKindBarBarToken || left.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			if isBinaryExpression(right) && (right.operatorToken.kind == SyntaxKindBarBarToken || right.operatorToken.kind == SyntaxKindAmpersandAmpersandToken) {
				grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind))
			}
			leftTarget := skipOuterExpressions(left, OuterExpressionKindsAll)
			nullishSemantics := getSyntacticNullishnessSemantics(leftTarget)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nullishSemantics !== PredicateSemantics.Sometimes */ TODO {
				if node.parent.kind == SyntaxKindBinaryExpression {
					error(leftTarget, Diagnostics.This_binary_expression_is_never_nullish_Are_you_missing_parentheses)
				} else {
					if nullishSemantics == PredicateSemanticsAlways {
						error(leftTarget, Diagnostics.This_expression_is_always_nullish)
					} else {
						error(leftTarget, Diagnostics.Right_operand_of_is_unreachable_because_the_left_operand_is_never_nullish)
					}
				}
			}
		}
	}
	getSyntacticNullishnessSemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.AwaitExpression:             case SyntaxKind.CallExpression:             case SyntaxKind.ElementAccessExpression:             case SyntaxKind.NewExpression:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.YieldExpression:                 return PredicateSemantics.Sometimes;             case SyntaxKind.BinaryExpression:                 // List of operators that can produce null/undefined:                 // = ??= ?? || ||= && &&=                 switch ((node as BinaryExpression).operatorToken.kind) {                     case SyntaxKind.EqualsToken:                     case SyntaxKind.QuestionQuestionToken:                     case SyntaxKind.QuestionQuestionEqualsToken:                     case SyntaxKind.BarBarToken:                     case SyntaxKind.BarBarEqualsToken:                     case SyntaxKind.AmpersandAmpersandToken:                     case SyntaxKind.AmpersandAmpersandEqualsToken:                         return PredicateSemantics.Sometimes;                 }                 return PredicateSemantics.Never;             case SyntaxKind.ConditionalExpression:                 return getSyntacticNullishnessSemantics((node as ConditionalExpression).whenTrue) | getSyntacticNullishnessSemantics((node as ConditionalExpression).whenFalse);             case SyntaxKind.NullKeyword:                 return PredicateSemantics.Always;             case SyntaxKind.Identifier:                 if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {                     return PredicateSemantics.Always;                 }                 return PredicateSemantics.Sometimes;         } */
		return PredicateSemanticsNever
	}
	checkBinaryLikeExpression := func(left Expression, operatorToken BinaryOperatorToken, right Expression, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		if operator == SyntaxKindEqualsToken && (left.kind == SyntaxKindObjectLiteralExpression || left.kind == SyntaxKindArrayLiteralExpression) {
			return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind == SyntaxKindThisKeyword)
		}
		var leftType Type
		if isBinaryLogicalOperator(operator) {
			leftType = checkTruthinessExpression(left, checkMode)
		} else {
			leftType = checkExpression(left, checkMode)
		}
		rightType := checkExpression(right, checkMode)
		return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, checkMode, errorNode)
	}
	checkBinaryLikeExpressionWorker := func(left Expression, operatorToken BinaryOperatorToken, right Expression, leftType Type, rightType Type, checkMode CheckMode, errorNode Node) Type {
		operator := operatorToken.kind
		/* TODO(SwitchStatement): switch (operator) {             case SyntaxKind.AsteriskToken:             case SyntaxKind.AsteriskAsteriskToken:             case SyntaxKind.AsteriskEqualsToken:             case SyntaxKind.AsteriskAsteriskEqualsToken:             case SyntaxKind.SlashToken:             case SyntaxKind.SlashEqualsToken:             case SyntaxKind.PercentToken:             case SyntaxKind.PercentEqualsToken:             case SyntaxKind.MinusToken:             case SyntaxKind.MinusEqualsToken:             case SyntaxKind.LessThanLessThanToken:             case SyntaxKind.LessThanLessThanEqualsToken:             case SyntaxKind.GreaterThanGreaterThanToken:             case SyntaxKind.GreaterThanGreaterThanEqualsToken:             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:             case SyntaxKind.BarToken:             case SyntaxKind.BarEqualsToken:             case SyntaxKind.CaretToken:             case SyntaxKind.CaretEqualsToken:             case SyntaxKind.AmpersandToken:             case SyntaxKind.AmpersandEqualsToken:                 if (leftType === silentNeverType || rightType === silentNeverType) {                     return silentNeverType;                 }                  leftType = checkNonNullType(leftType, left);                 rightType = checkNonNullType(rightType, right);                  let suggestedOperator: PunctuationSyntaxKind | undefined;                 // if a user tries to apply a bitwise operator to 2 boolean operands                 // try and return them a helpful suggestion                 if (                     (leftType.flags & TypeFlags.BooleanLike) &&                     (rightType.flags & TypeFlags.BooleanLike) &&                     (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined                 ) {                     error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator));                     return numberType;                 }                 else {                     // otherwise just check each operand separately and report errors as normal                     const leftOk = checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid* / true);                     const rightOk = checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, /*isAwaitValid* / true);                     let resultType: Type;                     // If both are any or unknown, allow operation; assume it will resolve to number                     if (                         (isTypeAssignableToKind(leftType, TypeFlags.AnyOrUnknown) && isTypeAssignableToKind(rightType, TypeFlags.AnyOrUnknown)) ||                         // Or, if neither could be bigint, implicit coercion results in a number result                         !(maybeTypeOfKind(leftType, TypeFlags.BigIntLike) || maybeTypeOfKind(rightType, TypeFlags.BigIntLike))                     ) {                         resultType = numberType;                     }                     // At least one is assignable to bigint, so check that both are                     else if (bothAreBigIntLike(leftType, rightType)) {                         switch (operator) {                             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:                                 reportOperatorError();                                 break;                             case SyntaxKind.AsteriskAsteriskToken:                             case SyntaxKind.AsteriskAsteriskEqualsToken:                                 if (languageVersion < ScriptTarget.ES2016) {                                     error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);                                 }                         }                         resultType = bigintType;                     }                     // Exactly one of leftType/rightType is assignable to bigint                     else {                         reportOperatorError(bothAreBigIntLike);                         resultType = errorType;                     }                     if (leftOk && rightOk) {                         checkAssignmentOperator(resultType);                         switch (operator) {                             case SyntaxKind.LessThanLessThanToken:                             case SyntaxKind.LessThanLessThanEqualsToken:                             case SyntaxKind.GreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanEqualsToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:                             case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:                                 const rhsEval = evaluate(right);                                 if (typeof rhsEval.value === "number" && Math.abs(rhsEval.value) >= 32) {                                     errorOrSuggestion(                                         isEnumMember(walkUpParenthesizedExpressions(right.parent.parent)), // elevate from suggestion to error within an enum member                                         errorNode || operatorToken,                                         Diagnostics.This_operation_can_be_simplified_This_shift_is_identical_to_0_1_2,                                         getTextOfNode(left),                                         tokenToString(operator),                                         rhsEval.value % 32,                                     );                                 }                                 break;                             default:                                 break;                         }                     }                     return resultType;                 }             case SyntaxKind.PlusToken:             case SyntaxKind.PlusEqualsToken:                 if (leftType === silentNeverType || rightType === silentNeverType) {                     return silentNeverType;                 }                  if (!isTypeAssignableToKind(leftType, TypeFlags.StringLike) && !isTypeAssignableToKind(rightType, TypeFlags.StringLike)) {                     leftType = checkNonNullType(leftType, left);                     rightType = checkNonNullType(rightType, right);                 }                  let resultType: Type | undefined;                 if (isTypeAssignableToKind(leftType, TypeFlags.NumberLike, /*strict* / true) && isTypeAssignableToKind(rightType, TypeFlags.NumberLike, /*strict* / true)) {                     // Operands of an enum type are treated as having the primitive type Number.                     // If both operands are of the Number primitive type, the result is of the Number primitive type.                     resultType = numberType;                 }                 else if (isTypeAssignableToKind(leftType, TypeFlags.BigIntLike, /*strict* / true) && isTypeAssignableToKind(rightType, TypeFlags.BigIntLike, /*strict* / true)) {                     // If both operands are of the BigInt primitive type, the result is of the BigInt primitive type.                     resultType = bigintType;                 }                 else if (isTypeAssignableToKind(leftType, TypeFlags.StringLike, /*strict* / true) || isTypeAssignableToKind(rightType, TypeFlags.StringLike, /*strict* / true)) {                     // If one or both operands are of the String primitive type, the result is of the String primitive type.                     resultType = stringType;                 }                 else if (isTypeAny(leftType) || isTypeAny(rightType)) {                     // Otherwise, the result is of type Any.                     // NOTE: unknown type here denotes error type. Old compiler treated this case as any type so do we.                     resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;                 }                  // Symbols are not allowed at all in arithmetic expressions                 if (resultType && !checkForDisallowedESSymbolOperand(operator)) {                     return resultType;                 }                  if (!resultType) {                     // Types that have a reasonably good chance of being a valid operand type.                     // If both types have an awaited type of one of these, we'll assume the user                     // might be missing an await without doing an exhaustive check that inserting                     // await(s) will actually be a completely valid binary expression.                     const closeEnoughKind = TypeFlags.NumberLike | TypeFlags.BigIntLike | TypeFlags.StringLike | TypeFlags.AnyOrUnknown;                     reportOperatorError((left, right) =>                         isTypeAssignableToKind(left, closeEnoughKind) &&                         isTypeAssignableToKind(right, closeEnoughKind)                     );                     return anyType;                 }                  if (operator === SyntaxKind.PlusEqualsToken) {                     checkAssignmentOperator(resultType);                 }                 return resultType;             case SyntaxKind.LessThanToken:             case SyntaxKind.GreaterThanToken:             case SyntaxKind.LessThanEqualsToken:             case SyntaxKind.GreaterThanEqualsToken:                 if (checkForDisallowedESSymbolOperand(operator)) {                     leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left));                     rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right));                     reportOperatorErrorUnless((left, right) => {                         if (isTypeAny(left) || isTypeAny(right)) {                             return true;                         }                         const leftAssignableToNumber = isTypeAssignableTo(left, numberOrBigIntType);                         const rightAssignableToNumber = isTypeAssignableTo(right, numberOrBigIntType);                         return leftAssignableToNumber && rightAssignableToNumber ||                             !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left, right);                     });                 }                 return booleanType;             case SyntaxKind.EqualsEqualsToken:             case SyntaxKind.ExclamationEqualsToken:             case SyntaxKind.EqualsEqualsEqualsToken:             case SyntaxKind.ExclamationEqualsEqualsToken:                 // We suppress errors in CheckMode.TypeOnly (meaning the invocation came from getTypeOfExpression). During                 // control flow analysis it is possible for operands to temporarily have narrower types, and those narrower                 // types may cause the operands to not be comparable. We don't want such errors reported (see #46475).                 if (!(checkMode && checkMode & CheckMode.TypeOnly)) {                     if (                         (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) &&                         // only report for === and !== in JS, not == or !=                         (!isInJSFile(left) || (operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsEqualsToken))                     ) {                         const eqType = operator === SyntaxKind.EqualsEqualsToken || operator === SyntaxKind.EqualsEqualsEqualsToken;                         error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, eqType ? "false" : "true");                     }                     checkNaNEquality(errorNode, operator, left, right);                     reportOperatorErrorUnless((left, right) => isTypeEqualityComparableTo(left, right) || isTypeEqualityComparableTo(right, left));                 }                 return booleanType;             case SyntaxKind.InstanceOfKeyword:                 return checkInstanceOfExpression(left, right, leftType, rightType, checkMode);             case SyntaxKind.InKeyword:                 return checkInExpression(left, right, leftType, rightType);             case SyntaxKind.AmpersandAmpersandToken:             case SyntaxKind.AmpersandAmpersandEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.Truthy) ?                     getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) :                     leftType;                 if (operator === SyntaxKind.AmpersandAmpersandEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.BarBarToken:             case SyntaxKind.BarBarEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.Falsy) ?                     getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], UnionReduction.Subtype) :                     leftType;                 if (operator === SyntaxKind.BarBarEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.QuestionQuestionToken:             case SyntaxKind.QuestionQuestionEqualsToken: {                 const resultType = hasTypeFacts(leftType, TypeFacts.EQUndefinedOrNull) ?                     getUnionType([getNonNullableType(leftType), rightType], UnionReduction.Subtype) :                     leftType;                 if (operator === SyntaxKind.QuestionQuestionEqualsToken) {                     checkAssignmentOperator(rightType);                 }                 return resultType;             }             case SyntaxKind.EqualsToken:                 const declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : AssignmentDeclarationKind.None;                 checkAssignmentDeclaration(declKind, rightType);                 if (isAssignmentDeclaration(declKind)) {                     if (                         !(rightType.flags & TypeFlags.Object) ||                         declKind !== AssignmentDeclarationKind.ModuleExports &&                             declKind !== AssignmentDeclarationKind.Prototype &&                             !isEmptyObjectType(rightType) &&                             !isFunctionObjectType(rightType as ObjectType) &&                             !(getObjectFlags(rightType) & ObjectFlags.Class)                     ) {                         // don't check assignability of module.exports=, C.prototype=, or expando types because they will necessarily be incomplete                         checkAssignmentOperator(rightType);                     }                     return leftType;                 }                 else {                     checkAssignmentOperator(rightType);                     return rightType;                 }             case SyntaxKind.CommaToken:                 if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent as BinaryExpression)) {                     const sf = getSourceFileOfNode(left);                     const sourceText = sf.text;                     const start = skipTrivia(sourceText, left.pos);                     const isInDiag2657 = sf.parseDiagnostics.some(diag => {                         if (diag.code !== Diagnostics.JSX_expressions_must_have_one_parent_element.code) return false;                         return textSpanContainsPosition(diag, start);                     });                     if (!isInDiag2657) error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);                 }                 return rightType;              default:                 return Debug.fail();         } */
		bothAreBigIntLike := func(left Type, right Type) bool {
			return isTypeAssignableToKind(left, TypeFlagsBigIntLike) && isTypeAssignableToKind(right, TypeFlagsBigIntLike)
		}
		checkAssignmentDeclaration := func(kind AssignmentDeclarationKind, rightType Type) {
			if kind == AssignmentDeclarationKindModuleExports {
				for _, prop := range getPropertiesOfObjectType(rightType) {
					propType := getTypeOfSymbol(prop)
					if propType.symbol && propType.symbol.flags&SymbolFlagsClass {
						name := prop.escapedName
						symbol := resolveName(prop.valueDeclaration, name, SymbolFlagsType, nil, false)
						if symbol.declarations && symbol.declarations.some(isJSDocTypedefTag) {
							addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop)
							addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol)
						}
					}
				}
			}
		}
		isIndirectCall := func(node BinaryExpression) bool {
			return node.parent.kind == SyntaxKindParenthesizedExpression && isNumericLiteral(node.left) && node.left.text == "0" && (isCallExpression(node.parent.parent) && node.parent.parent.expression == node.parent || node.parent.parent.kind == SyntaxKindTaggedTemplateExpression) && (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText == "eval")
		}
		checkForDisallowedESSymbolOperand := func(operator PunctuationSyntaxKind) bool {
			offendingSymbolOperand := /* TODO(ConditionalExpression): maybeTypeOfKindConsideringBaseConstraint(leftType, TypeFlags.ESSymbolLike) ? left :                 maybeTypeOfKindConsideringBaseConstraint(rightType, TypeFlags.ESSymbolLike) ? right :                 undefined */ TODO
			if offendingSymbolOperand {
				error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator))
				return false
			}
			return true
		}
		getSuggestedBooleanOperator := func(operator SyntaxKind) *PunctuationSyntaxKind {
			/* TODO(SwitchStatement): switch (operator) {                 case SyntaxKind.BarToken:                 case SyntaxKind.BarEqualsToken:                     return SyntaxKind.BarBarToken;                 case SyntaxKind.CaretToken:                 case SyntaxKind.CaretEqualsToken:                     return SyntaxKind.ExclamationEqualsEqualsToken;                 case SyntaxKind.AmpersandToken:                 case SyntaxKind.AmpersandEqualsToken:                     return SyntaxKind.AmpersandAmpersandToken;                 default:                     return undefined;             } */
		}
		checkAssignmentOperator := func(valueType Type) {
			if isAssignmentOperator(operator) {
				addLazyDiagnostic(checkAssignmentOperatorWorker)
			}
			checkAssignmentOperatorWorker := func() {
				assigneeType := leftType
				if isCompoundAssignment(operatorToken.kind) && left.kind == SyntaxKindPropertyAccessExpression {
					assigneeType = checkPropertyAccessExpression(left /* as */ /* TODO(TypeReference): PropertyAccessExpression */, nil, true)
				}
				if checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access) {
					var headMessage *DiagnosticMessage
					if exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, TypeFlagsUndefined) {
						target := getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.escapedText)
						if isExactOptionalPropertyMismatch(valueType, target) {
							headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target
						}
					}
					checkTypeAssignableToAndOptionallyElaborate(valueType, assigneeType, left, right, headMessage)
				}
			}
		}
		isAssignmentDeclaration := func(kind AssignmentDeclarationKind) /* TODO(undefined): boolean */ TODO {
			/* TODO(SwitchStatement): switch (kind) {                 case AssignmentDeclarationKind.ModuleExports:                     return true;                 case AssignmentDeclarationKind.ExportsProperty:                 case AssignmentDeclarationKind.Property:                 case AssignmentDeclarationKind.Prototype:                 case AssignmentDeclarationKind.PrototypeProperty:                 case AssignmentDeclarationKind.ThisProperty:                     const symbol = getSymbolOfNode(left);                     const init = getAssignedExpandoInitializer(right);                     return !!init && isObjectLiteralExpression(init) &&                         !!symbol?.exports?.size;                 default:                     return false;             } */
		}
		reportOperatorErrorUnless := func(typesAreCompatible func(left Type, right Type) bool) bool {
			if !typesAreCompatible(leftType, rightType) {
				reportOperatorError(typesAreCompatible)
				return true
			}
			return false
		}
		reportOperatorError := func(isRelated func(left Type, right Type) bool) {
			wouldWorkWithAwait := false
			errNode := errorNode || operatorToken
			if isRelated {
				awaitedLeftType := getAwaitedTypeNoAlias(leftType)
				awaitedRightType := getAwaitedTypeNoAlias(rightType)
				wouldWorkWithAwait = !(awaitedLeftType == leftType && awaitedRightType == rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType)
			}
			effectiveLeft := leftType
			effectiveRight := rightType
			if !wouldWorkWithAwait && isRelated {
				/* TODO(ArrayLiteralExpression): [effectiveLeft, effectiveRight] */ TODO = getBaseTypesIfUnrelated(leftType, rightType, isRelated)
			}
			TODO_IDENTIFIER := getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight)
			if !tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr) {
				errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, tokenToString(operatorToken.kind), leftStr, rightStr)
			}
		}
		tryGiveBetterPrimaryError := func(errNode Node, maybeMissingAwait bool, leftStr string, rightStr string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Diagnostic | undefined */ TODO {
			/* TODO(SwitchStatement): switch (operatorToken.kind) {                 case SyntaxKind.EqualsEqualsEqualsToken:                 case SyntaxKind.EqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsEqualsToken:                 case SyntaxKind.ExclamationEqualsToken:                     return errorAndMaybeSuggestAwait(                         errNode,                         maybeMissingAwait,                         Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap,                         leftStr,                         rightStr,                     );                 default:                     return undefined;             } */
		}
		checkNaNEquality := func(errorNode Node, operator SyntaxKind, left Expression, right Expression) {
			isLeftNaN := isGlobalNaN(skipParentheses(left))
			isRightNaN := isGlobalNaN(skipParentheses(right))
			if isLeftNaN || isRightNaN {
				err := error(errorNode, Diagnostics.This_condition_will_always_return_0, tokenToString( /* TODO(ConditionalExpression): operator === SyntaxKind.EqualsEqualsEqualsToken || operator === SyntaxKind.EqualsEqualsToken ? SyntaxKind.FalseKeyword : SyntaxKind.TrueKeyword */ TODO))
				if isLeftNaN && isRightNaN {
				}
				operatorString := /* TODO(ConditionalExpression): operator === SyntaxKind.ExclamationEqualsEqualsToken || operator === SyntaxKind.ExclamationEqualsToken ? tokenToString(SyntaxKind.ExclamationToken) : "" */ TODO
				location := /* TODO(ConditionalExpression): isLeftNaN ? right : left */ TODO
				expression := skipParentheses(location)
				addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0 /* TODO(TemplateExpression): `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})` */, TODO))
			}
		}
		isGlobalNaN := func(expr Expression) bool {
			if isIdentifier(expr) && expr.escapedText == "NaN" {
				globalNaNSymbol := getGlobalNaNSymbol()
				return !!globalNaNSymbol && globalNaNSymbol == getResolvedSymbol(expr)
			}
			return false
		}
	}
	getBaseTypesIfUnrelated := func(leftType Type, rightType Type, isRelated func(left Type, right Type) bool) /* TODO(TupleType): [Type, Type] */ TODO {
		effectiveLeft := leftType
		effectiveRight := rightType
		leftBase := getBaseTypeOfLiteralType(leftType)
		rightBase := getBaseTypeOfLiteralType(rightType)
		if !isRelated(leftBase, rightBase) {
			effectiveLeft = leftBase
			effectiveRight = rightBase
		}
		return /* TODO(ArrayLiteralExpression): [effectiveLeft, effectiveRight] */ TODO
	}
	checkYieldExpression := func(node YieldExpression) Type {
		addLazyDiagnostic(checkYieldExpressionGrammar)
		func_ := getContainingFunction(node)
		if !func_ {
			/* TODO(Identifier): anyType */
		}
		functionFlags := getFunctionFlags(func_)
		if !(functionFlags & FunctionFlagsGenerator) {
			return anyType
		}
		isAsync := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */ TODO
		if node.asteriskToken {
			if isAsync && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncDelegatorIncludes)
			}
			if !isAsync && languageVersion < LanguageFeatureMinimumTargetGenerators && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersValues)
			}
		}
		returnType := getReturnTypeFromAnnotation(func_)
		if returnType && returnType.flags&TypeFlagsUnion {
			returnType = filterType(returnType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): checkGeneratorInstantiationAssignabilityToReturnType */
				/* TODO(Identifier): t */
				/* TODO(Identifier): functionFlags */
				/* TODO(Identifier): undefined */
			})
		}
		iterationTypes := returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync)
		signatureYieldType := iterationTypes && iterationTypes.yieldType || anyType
		signatureNextType := iterationTypes && iterationTypes.nextType || anyType
		yieldExpressionType := /* TODO(ConditionalExpression): node.expression ? checkExpression(node.expression) : undefinedWideningType */ TODO
		yieldedType := getYieldedTypeOfYieldExpression(node, yieldExpressionType, signatureNextType, isAsync)
		if returnType && yieldedType {
			checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression)
		}
		if node.asteriskToken {
			use := /* TODO(ConditionalExpression): isAsync ? IterationUse.AsyncYieldStar : IterationUse.YieldStar */ TODO
			return getIterationTypeOfIterable(use, IterationTypeKindReturn, yieldExpressionType, node.expression) || anyType
		} else if returnType {
			return getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType, isAsync) || anyType
		}
		type_ := getContextualIterationType(IterationTypeKindNext, func_)
		if !type_ {
			type_ = anyType
			addLazyDiagnostic(func() {
				if noImplicitAny && !expressionResultIsUnused(node) {
					contextualType := getContextualType(node, nil)
					if !contextualType || isTypeAny(contextualType) {
						error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation)
					}
				}
			})
		}
		return type_
		checkYieldExpressionGrammar := func() {
			if !(node.flags & NodeFlagsYieldContext) {
				grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body)
			}
			if isInParameterInitializerBeforeContainingFunction(node) {
				error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer)
			}
		}
	}
	checkConditionalExpression := func(node ConditionalExpression, checkMode CheckMode) Type {
		type_ := checkTruthinessExpression(node.condition, checkMode)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.condition, type_, node.whenTrue)
		type1 := checkExpression(node.whenTrue, checkMode)
		type2 := checkExpression(node.whenFalse, checkMode)
		return getUnionType( /* TODO(ArrayLiteralExpression): [type1, type2] */ TODO, UnionReductionSubtype)
	}
	isTemplateLiteralContext := func(node Node) bool {
		parent := node.parent
		return isParenthesizedExpression(parent) && isTemplateLiteralContext(parent) || isElementAccessExpression(parent) && parent.argumentExpression == node
	}
	checkTemplateExpression := func(node TemplateExpression) Type {
		texts := /* TODO(ArrayLiteralExpression): [node.head.text] */ TODO
		types := /* TODO(ArrayLiteralExpression): [] */ TODO
		for _, span := range node.templateSpans {
			type_ := checkExpression(span.expression)
			if maybeTypeOfKindConsideringBaseConstraint(type_, TypeFlagsESSymbolLike) {
				error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String)
			}
			texts.push(span.literal.text)
			types.push( /* TODO(ConditionalExpression): isTypeAssignableTo(type, templateConstraintType) ? type : stringType */ TODO)
		}
		evaluated := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.TaggedTemplateExpression */ TODO && evaluate(node).value
		if evaluated {
			return getFreshTypeOfLiteralType(getStringLiteralType(evaluated))
		}
		if isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType(node, nil) || unknownType, isTemplateLiteralContextualType) {
			return getTemplateLiteralType(texts, types)
		}
		return stringType
	}
	isTemplateLiteralContextualType := func(type_ Type) bool {
		return !!(type_.flags&(TypeFlagsStringLiteral|TypeFlagsTemplateLiteral) || type_.flags&TypeFlagsInstantiableNonPrimitive && maybeTypeOfKind(getBaseConstraintOfType(type_) || unknownType, TypeFlagsStringLike))
	}
	getContextNode := func(node Expression) Expression {
		if isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent) {
			return node.parent.parent
		}
		return node
	}
	checkExpressionWithContextualType := func(node Expression, contextualType Type, inferenceContext *InferenceContext, checkMode CheckMode) Type {
		contextNode := getContextNode(node)
		pushContextualType(contextNode, contextualType, false)
		pushInferenceContext(contextNode, inferenceContext)
		type_ := checkExpression(node, checkMode|CheckModeContextual|( /* TODO(ConditionalExpression): inferenceContext ? CheckMode.Inferential : 0 */ TODO))
		if inferenceContext && inferenceContext.intraExpressionInferenceSites {
			inferenceContext.intraExpressionInferenceSites = nil
		}
		result := /* TODO(ConditionalExpression): maybeTypeOfKind(type, TypeFlags.Literal) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, /*contextFlags* / undefined)) ?             getRegularTypeOfLiteralType(type) : type */ TODO
		popInferenceContext()
		popContextualType()
		return result
	}
	checkExpressionCached := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode) Type {
		if checkMode {
			return checkExpression(node, checkMode)
		}
		links := getNodeLinks(node)
		if !links.resolvedType {
			saveFlowLoopStart := flowLoopStart
			saveFlowTypeCache := flowTypeCache
			flowLoopStart = flowLoopCount
			flowTypeCache = nil
			links.resolvedType = checkExpression(node, checkMode)
			flowTypeCache = saveFlowTypeCache
			flowLoopStart = saveFlowLoopStart
		}
		return links.resolvedType
	}
	isTypeAssertion := func(node Expression) /* TODO(undefined): boolean */ TODO {
		node = skipParentheses(node, true)
		return node.kind == SyntaxKindTypeAssertionExpression || node.kind == SyntaxKindAsExpression || isJSDocTypeAssertion(node)
	}
	checkDeclarationInitializer := func(declaration HasExpressionInitializer, checkMode CheckMode, contextualType *Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		initializer := /* TODO(NonNullExpression): getEffectiveInitializer(declaration)! */ TODO
		if isInJSFile(declaration) {
			typeNode := tryGetJSDocSatisfiesTypeNode(declaration)
			if typeNode {
				return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode)
			}
		}
		type_ := getQuickTypeOfExpression(initializer) || ( /* TODO(ConditionalExpression): contextualType ?             checkExpressionWithContextualType(initializer, contextualType, /*inferenceContext* / undefined, checkMode || CheckMode.Normal) :             checkExpressionCached(initializer, checkMode) */ TODO)
		if isParameter( /* TODO(ConditionalExpression): isBindingElement(declaration) ? walkUpBindingElementsAndPatterns(declaration) : declaration */ TODO) {
			if declaration.name.kind == SyntaxKindObjectBindingPattern && isObjectLiteralType(type_) {
				return padObjectLiteralType(type_ /* as */ /* TODO(TypeReference): ObjectType */, declaration.name)
			}
			if declaration.name.kind == SyntaxKindArrayBindingPattern && isTupleType(type_) {
				return padTupleType(type_, declaration.name)
			}
		}
		return type_
	}
	padObjectLiteralType := func(type_ ObjectType, pattern ObjectBindingPattern) Type {
		var missingElements /* TODO(ArrayType): BindingElement[] */ any
		for _, e := range pattern.elements {
			if e.initializer {
				name := getPropertyNameFromBindingElement(e)
				if name && !getPropertyOfType(type_, name) {
					missingElements = append(missingElements, e)
				}
			}
		}
		if !missingElements {
			return type_
		}
		members := createSymbolTable()
		for _, prop := range getPropertiesOfObjectType(type_) {
			members.set(prop.escapedName, prop)
		}
		for _, e := range missingElements {
			symbol := createSymbol(SymbolFlagsProperty|SymbolFlagsOptional /* TODO(NonNullExpression): getPropertyNameFromBindingElement(e)! */, TODO)
			symbol.links.type_ = getTypeFromBindingElement(e, false, false)
			members.set(symbol.escapedName, symbol)
		}
		result := createAnonymousType(type_.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type_))
		result.objectFlags = type_.objectFlags
		return result
	}
	getPropertyNameFromBindingElement := func(e BindingElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		exprType := getLiteralTypeFromPropertyName(e.propertyName || e.name /* as */ /* TODO(TypeReference): Identifier */)
		return /* TODO(ConditionalExpression): isTypeUsableAsPropertyName(exprType) ? getPropertyNameFromType(exprType) : undefined */ TODO
	}
	padTupleType := func(type_ TupleTypeReference, pattern ArrayBindingPattern) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_.target.combinedFlags&ElementFlagsVariable || getTypeReferenceArity(type_) >= pattern.elements.length {
			return type_
		}
		patternElements := pattern.elements
		elementTypes := getElementTypes(type_).slice()
		elementFlags := type_.target.elementFlags.slice()
		/* TODO(ForStatement): for (let i = getTypeReferenceArity(type); i < patternElements.length; i++) {             const e = patternElements[i];             if (i < patternElements.length - 1 || !(e.kind === SyntaxKind.BindingElement && e.dotDotDotToken)) {                 elementTypes.push(!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, /*includePatternInType* / false, /*reportErrors* / false) : anyType);                 elementFlags.push(ElementFlags.Optional);                 if (!isOmittedExpression(e) && !hasDefaultValue(e)) {                     reportImplicitAny(e, anyType);                 }             }         } */
		return createTupleType(elementTypes, elementFlags, type_.target.readonly)
	}
	widenTypeInferredFromInitializer := func(declaration HasExpressionInitializer, type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		widened := /* TODO(ConditionalExpression): getCombinedNodeFlagsCached(declaration) & NodeFlags.Constant || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type) */ TODO
		if isInJSFile(declaration) {
			if isEmptyLiteralType(widened) {
				reportImplicitAny(declaration, anyType)
				return anyType
			} else if isEmptyArrayLiteralType(widened) {
				reportImplicitAny(declaration, anyArrayType)
				return anyArrayType
			}
		}
		return widened
	}
	isLiteralOfContextualType := func(candidateType Type, contextualType *Type) bool {
		if contextualType {
			if contextualType.flags & TypeFlagsUnionOrIntersection {
				types := (contextualType /* as */ /* TODO(TypeReference): UnionType */).types
				return some(types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(Identifier): isLiteralOfContextualType */
					/* TODO(Identifier): candidateType */
					/* TODO(Identifier): t */
				})
			}
			if contextualType.flags & TypeFlagsInstantiableNonPrimitive {
				constraint := getBaseConstraintOfType(contextualType) || unknownType
				return maybeTypeOfKind(constraint, TypeFlagsString) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || maybeTypeOfKind(constraint, TypeFlagsNumber) && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || maybeTypeOfKind(constraint, TypeFlagsBigInt) && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || maybeTypeOfKind(constraint, TypeFlagsESSymbol) && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol) || isLiteralOfContextualType(candidateType, constraint)
			}
			return !!(contextualType.flags&(TypeFlagsStringLiteral|TypeFlagsIndex|TypeFlagsTemplateLiteral|TypeFlagsStringMapping) && maybeTypeOfKind(candidateType, TypeFlagsStringLiteral) || contextualType.flags&TypeFlagsNumberLiteral && maybeTypeOfKind(candidateType, TypeFlagsNumberLiteral) || contextualType.flags&TypeFlagsBigIntLiteral && maybeTypeOfKind(candidateType, TypeFlagsBigIntLiteral) || contextualType.flags&TypeFlagsBooleanLiteral && maybeTypeOfKind(candidateType, TypeFlagsBooleanLiteral) || contextualType.flags&TypeFlagsUniqueESSymbol && maybeTypeOfKind(candidateType, TypeFlagsUniqueESSymbol))
		}
		return false
	}
	isConstContext := func(node Expression) bool {
		parent := node.parent
		return isAssertionExpression(parent) && isConstTypeReference(parent.type_) || isJSDocTypeAssertion(parent) && isConstTypeReference(getJSDocTypeAssertionType(parent)) || isValidConstAssertionArgument(node) && isConstTypeVariable(getContextualType(node, ContextFlagsNone)) || (isParenthesizedExpression(parent) || isArrayLiteralExpression(parent) || isSpreadElement(parent)) && isConstContext(parent) || (isPropertyAssignment(parent) || isShorthandPropertyAssignment(parent) || isTemplateSpan(parent)) && isConstContext(parent.parent)
	}
	checkExpressionForMutableLocation := func(node Expression, checkMode *CheckMode, forceTuple bool) Type {
		type_ := checkExpression(node, checkMode, forceTuple)
		return /* TODO(ConditionalExpression): isConstContext(node) || isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) :             isTypeAssertion(node) ? type :             getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(getContextualType(node, /*contextFlags* / undefined), node, /*contextFlags* / undefined)) */ TODO
	}
	checkPropertyAssignment := func(node PropertyAssignment, checkMode CheckMode) Type {
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		return checkExpressionForMutableLocation(node.initializer, checkMode)
	}
	checkObjectLiteralMethod := func(node MethodDeclaration, checkMode CheckMode) Type {
		checkGrammarMethod(node)
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		uninstantiatedType := checkFunctionExpressionOrObjectLiteralMethod(node, checkMode)
		return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
	}
	instantiateTypeWithSingleGenericCallSignature := func(node /* TODO(UnionType): Expression | MethodDeclaration | QualifiedName */ any, type_ Type, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if checkMode && checkMode&(CheckModeInferential|CheckModeSkipGenericFunctions) {
			callSignature := getSingleSignature(type_, SignatureKindCall, true)
			constructSignature := getSingleSignature(type_, SignatureKindConstruct, true)
			signature := callSignature || constructSignature
			if signature && signature.typeParameters {
				contextualType := getApparentTypeOfContextualType(node /* as */ /* TODO(TypeReference): Expression */, ContextFlagsNoConstraints)
				if contextualType {
					contextualSignature := getSingleSignature(getNonNullableType(contextualType) /* TODO(ConditionalExpression): callSignature ? SignatureKind.Call : SignatureKind.Construct */, TODO, false)
					if contextualSignature && !contextualSignature.typeParameters {
						if checkMode & CheckModeSkipGenericFunctions {
							skippedGenericFunction(node, checkMode)
							return anyFunctionType
						}
						context := /* TODO(NonNullExpression): getInferenceContext(node)! */ TODO
						returnType := context.signature && getReturnTypeOfSignature(context.signature)
						returnSignature := returnType && getSingleCallOrConstructSignature(returnType)
						if returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates) {
							uniqueTypeParameters := getUniqueTypeParameters(context, signature.typeParameters)
							instantiatedSignature := getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters)
							inferences := map_(context.inferences, func(info /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceInfo */ TODO {
								/* TODO(Identifier): createInferenceInfo */
								/* TODO(PropertyAccessExpression): info.typeParameter */
							})
							applyToParameterTypes(instantiatedSignature, contextualSignature, func(source /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
								inferTypes(inferences, source, target, 0, true)
							})
							if some(inferences, hasInferenceCandidates) {
								applyToReturnTypes(instantiatedSignature, contextualSignature, func(source /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO, target /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
									inferTypes(inferences, source, target)
								})
								if !hasOverlappingInferences(context.inferences, inferences) {
									mergeInferences(context.inferences, inferences)
									context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters)
									return getOrCreateTypeFromSignature(instantiatedSignature)
								}
							}
						}
						return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context), flatMap(inferenceContexts, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").InferenceContext | undefined */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
							/* TODO(Identifier): c */
							/* TODO(AmpersandAmpersandToken): && */
							/* TODO(CallExpression): map(c.inferences, i => i.typeParameter) */
						}).slice())
					}
				}
			}
		}
		return type_
	}
	skippedGenericFunction := func(node Node, checkMode CheckMode) {
		if checkMode & CheckModeInferential {
			context := /* TODO(NonNullExpression): getInferenceContext(node)! */ TODO
			context.flags |= InferenceFlagsSkippedGenericFunction
		}
	}
	hasInferenceCandidates := func(info InferenceInfo) /* TODO(undefined): boolean */ TODO {
		return !!(info.candidates || info.contraCandidates)
	}
	hasInferenceCandidatesOrDefault := func(info InferenceInfo) /* TODO(undefined): boolean */ TODO {
		return !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter))
	}
	hasOverlappingInferences := func(a []InferenceInfo, b []InferenceInfo) /* TODO(undefined): boolean */ TODO {
		/* TODO(ForStatement): for (let i = 0; i < a.length; i++) {             if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {                 return true;             }         } */
		return false
	}
	mergeInferences := func(target []InferenceInfo, source []InferenceInfo) {
		/* TODO(ForStatement): for (let i = 0; i < target.length; i++) {             if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {                 target[i] = source[i];             }         } */
	}
	getUniqueTypeParameters := func(context InferenceContext, typeParameters []TypeParameter) []TypeParameter {
		var result []TypeParameter = /* TODO(ArrayLiteralExpression): [] */ TODO
		var oldTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		var newTypeParameters /* TODO(ArrayType): TypeParameter[] */ any
		for _, tp := range typeParameters {
			name := tp.symbol.escapedName
			if hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name) {
				newName := getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name)
				symbol := createSymbol(SymbolFlagsTypeParameter, newName)
				newTypeParameter := createTypeParameter(symbol)
				newTypeParameter.target = tp
				oldTypeParameters = append(oldTypeParameters, tp)
				newTypeParameters = append(newTypeParameters, newTypeParameter)
				result.push(newTypeParameter)
			} else {
				result.push(tp)
			}
		}
		if newTypeParameters {
			mapper := createTypeMapper( /* TODO(NonNullExpression): oldTypeParameters! */ TODO, newTypeParameters)
			for _, tp := range newTypeParameters {
				tp.mapper = mapper
			}
		}
		return result
	}
	hasTypeParameterByName := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, name __String) /* TODO(undefined): boolean */ TODO {
		return some(typeParameters, func(tp /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PropertyAccessExpression): tp.symbol.escapedName */
			/* TODO(EqualsEqualsEqualsToken): === */
			/* TODO(Identifier): name */
		})
	}
	getUniqueTypeParameterName := func(typeParameters []TypeParameter, baseName __String) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO {
		len := (baseName /* as */ /* TODO(StringKeyword): string */).length
		/* TODO(WhileStatement): while (len > 1 && (baseName as string).charCodeAt(len - 1) >= CharacterCodes._0 && (baseName as string).charCodeAt(len - 1) <= CharacterCodes._9) len--; */
		s := (baseName /* as */ /* TODO(StringKeyword): string */).slice(0, len)
		/* TODO(ForStatement): for (let index = 1; true; index++) {             const augmentedName = s + index as __String;             if (!hasTypeParameterByName(typeParameters, augmentedName)) {                 return augmentedName;             }         } */
	}
	getReturnTypeOfSingleNonGenericCallSignature := func(funcType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signature := getSingleCallSignature(funcType)
		if signature && !signature.typeParameters {
			return getReturnTypeOfSignature(signature)
		}
	}
	getReturnTypeOfSingleNonGenericSignatureOfCallChain := func(expr CallChain) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		funcType := checkExpression(expr.expression)
		nonOptionalType := getOptionalExpressionType(funcType, expr.expression)
		returnType := getReturnTypeOfSingleNonGenericCallSignature(funcType)
		return returnType && propagateOptionalTypeMarker(returnType, expr /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nonOptionalType !== funcType */, TODO)
	}
	getTypeOfExpression := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		quickType := getQuickTypeOfExpression(node)
		if quickType {
			return quickType
		}
		if node.flags&NodeFlagsTypeCached && flowTypeCache {
			cachedType := /* TODO(ElementAccessExpression): flowTypeCache[getNodeId(node)] */ TODO
			if cachedType {
				return cachedType
			}
		}
		startInvocationCount := flowInvocationCount
		type_ := checkExpression(node, CheckModeTypeOnly)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): flowInvocationCount !== startInvocationCount */ TODO {
			cache := flowTypeCache || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): flowTypeCache = [] */ TODO)
			/* TODO(ElementAccessExpression): cache[getNodeId(node)] */ TODO = type_
			setNodeFlags(node, node.flags|NodeFlagsTypeCached)
		}
		return type_
	}
	getQuickTypeOfExpression := func(node Expression) *Type {
		expr := skipParentheses(node, true)
		if isJSDocTypeAssertion(expr) {
			type_ := getJSDocTypeAssertionType(expr)
			if !isConstTypeReference(type_) {
				return getTypeFromTypeNode(type_)
			}
		}
		expr = skipParentheses(node)
		if isAwaitExpression(expr) {
			type_ := getQuickTypeOfExpression(expr.expression)
			return /* TODO(ConditionalExpression): type ? getAwaitedType(type) : undefined */ TODO
		}
		if isCallExpression(expr) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): expr.expression.kind !== SyntaxKind.SuperKeyword */ TODO && !isRequireCall(expr, true) && !isSymbolOrSymbolForCall(expr) {
			return /* TODO(ConditionalExpression): isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) :                 getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression)) */ TODO
		} else if isAssertionExpression(expr) && !isConstTypeReference(expr.type_) {
			return getTypeFromTypeNode((expr /* as */ /* TODO(TypeReference): TypeAssertion */).type_)
		} else if isLiteralExpression(node) || isBooleanLiteral(node) {
			return checkExpression(node)
		}
		return nil
	}
	getContextFreeTypeOfExpression := func(node Expression) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		links := getNodeLinks(node)
		if links.contextFreeType {
			return links.contextFreeType
		}
		pushContextualType(node, anyType, false)
		type_ := /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.contextFreeType = checkExpression(node, CheckMode.SkipContextSensitive) */ TODO
		popContextualType()
		return type_
	}
	checkExpression := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode CheckMode, forceTuple bool) Type {
		tracing.push(tracing.Phase.Check, "checkExpression" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		uninstantiatedType := checkExpressionWorker(node, checkMode, forceTuple)
		type_ := instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode)
		if isConstEnumObjectType(type_) {
			checkConstEnumAccess(node, type_)
		}
		currentNode = saveCurrentNode
		tracing.pop()
		return type_
	}
	checkConstEnumAccess := func(node /* TODO(UnionType): Expression | QualifiedName */ any, type_ Type) {
		ok := (node.parent.kind == SyntaxKindPropertyAccessExpression && (node.parent /* as */ /* TODO(TypeReference): PropertyAccessExpression */).expression == node) || (node.parent.kind == SyntaxKindElementAccessExpression && (node.parent /* as */ /* TODO(TypeReference): ElementAccessExpression */).expression == node) || ((node.kind == SyntaxKindIdentifier || node.kind == SyntaxKindQualifiedName) && isInRightSideOfImportOrExportAssignment(node /* as */ /* TODO(TypeReference): Identifier */) || (node.parent.kind == SyntaxKindTypeQuery && (node.parent /* as */ /* TODO(TypeReference): TypeQueryNode */).exprName == node)) || (node.parent.kind == SyntaxKindExportSpecifier)
		if !ok {
			error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query)
		}
		if compilerOptions.isolatedModules || compilerOptions.verbatimModuleSyntax && ok && !resolveName(node, getFirstIdentifier(node /* as */ /* TODO(TypeReference): EntityNameOrEntityNameExpression */), SymbolFlagsAlias, nil, false, true) {
			Debug.assert(!!(type_.symbol.flags & SymbolFlagsConstEnum))
			constEnumDeclaration := type_.symbol.valueDeclaration /* as */ /* TODO(TypeReference): EnumDeclaration */
			redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
			if constEnumDeclaration.flags&NodeFlagsAmbient && !isValidTypeOnlyAliasUseSite(node) && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
				error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
			}
		}
	}
	checkParenthesizedExpression := func(node ParenthesizedExpression, checkMode CheckMode) Type {
		if hasJSDocNodes(node) {
			if isJSDocSatisfiesExpression(node) {
				return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode)
			}
			if isJSDocTypeAssertion(node) {
				return checkAssertionWorker(node, checkMode)
			}
		}
		return checkExpression(node.expression, checkMode)
	}
	checkExpressionWorker := func(node /* TODO(UnionType): Expression | QualifiedName */ any, checkMode *CheckMode, forceTuple bool) Type {
		kind := node.kind
		if cancellationToken {
			/* TODO(SwitchStatement): switch (kind) {                 case SyntaxKind.ClassExpression:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.ArrowFunction:                     cancellationToken.throwIfCancellationRequested();             } */
		}
		/* TODO(SwitchStatement): switch (kind) {             case SyntaxKind.Identifier:                 return checkIdentifier(node as Identifier, checkMode);             case SyntaxKind.PrivateIdentifier:                 return checkPrivateIdentifierExpression(node as PrivateIdentifier);             case SyntaxKind.ThisKeyword:                 return checkThisExpression(node);             case SyntaxKind.SuperKeyword:                 return checkSuperExpression(node);             case SyntaxKind.NullKeyword:                 return nullWideningType;             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.StringLiteral:                 return hasSkipDirectInferenceFlag(node) ?                     blockedStringType :                     getFreshTypeOfLiteralType(getStringLiteralType((node as StringLiteralLike).text));             case SyntaxKind.NumericLiteral:                 checkGrammarNumericLiteral(node as NumericLiteral);                 return getFreshTypeOfLiteralType(getNumberLiteralType(+(node as NumericLiteral).text));             case SyntaxKind.BigIntLiteral:                 checkGrammarBigIntLiteral(node as BigIntLiteral);                 return getFreshTypeOfLiteralType(getBigIntLiteralType({                     negative: false,                     base10Value: parsePseudoBigInt((node as BigIntLiteral).text),                 }));             case SyntaxKind.TrueKeyword:                 return trueType;             case SyntaxKind.FalseKeyword:                 return falseType;             case SyntaxKind.TemplateExpression:                 return checkTemplateExpression(node as TemplateExpression);             case SyntaxKind.RegularExpressionLiteral:                 return checkRegularExpressionLiteral(node as RegularExpressionLiteral);             case SyntaxKind.ArrayLiteralExpression:                 return checkArrayLiteral(node as ArrayLiteralExpression, checkMode, forceTuple);             case SyntaxKind.ObjectLiteralExpression:                 return checkObjectLiteral(node as ObjectLiteralExpression, checkMode);             case SyntaxKind.PropertyAccessExpression:                 return checkPropertyAccessExpression(node as PropertyAccessExpression, checkMode);             case SyntaxKind.QualifiedName:                 return checkQualifiedName(node as QualifiedName, checkMode);             case SyntaxKind.ElementAccessExpression:                 return checkIndexedAccess(node as ElementAccessExpression, checkMode);             case SyntaxKind.CallExpression:                 if ((node as CallExpression).expression.kind === SyntaxKind.ImportKeyword) {                     return checkImportCallExpression(node as ImportCall);                 }                 // falls through             case SyntaxKind.NewExpression:                 return checkCallExpression(node as CallExpression, checkMode);             case SyntaxKind.TaggedTemplateExpression:                 return checkTaggedTemplateExpression(node as TaggedTemplateExpression);             case SyntaxKind.ParenthesizedExpression:                 return checkParenthesizedExpression(node as ParenthesizedExpression, checkMode);             case SyntaxKind.ClassExpression:                 return checkClassExpression(node as ClassExpression);             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return checkFunctionExpressionOrObjectLiteralMethod(node as FunctionExpression | ArrowFunction, checkMode);             case SyntaxKind.TypeOfExpression:                 return checkTypeOfExpression(node as TypeOfExpression);             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:                 return checkAssertion(node as AssertionExpression, checkMode);             case SyntaxKind.NonNullExpression:                 return checkNonNullAssertion(node as NonNullExpression);             case SyntaxKind.ExpressionWithTypeArguments:                 return checkExpressionWithTypeArguments(node as ExpressionWithTypeArguments);             case SyntaxKind.SatisfiesExpression:                 return checkSatisfiesExpression(node as SatisfiesExpression);             case SyntaxKind.MetaProperty:                 return checkMetaProperty(node as MetaProperty);             case SyntaxKind.DeleteExpression:                 return checkDeleteExpression(node as DeleteExpression);             case SyntaxKind.VoidExpression:                 return checkVoidExpression(node as VoidExpression);             case SyntaxKind.AwaitExpression:                 return checkAwaitExpression(node as AwaitExpression);             case SyntaxKind.PrefixUnaryExpression:                 return checkPrefixUnaryExpression(node as PrefixUnaryExpression);             case SyntaxKind.PostfixUnaryExpression:                 return checkPostfixUnaryExpression(node as PostfixUnaryExpression);             case SyntaxKind.BinaryExpression:                 return checkBinaryExpression(node as BinaryExpression, checkMode);             case SyntaxKind.ConditionalExpression:                 return checkConditionalExpression(node as ConditionalExpression, checkMode);             case SyntaxKind.SpreadElement:                 return checkSpreadExpression(node as SpreadElement, checkMode);             case SyntaxKind.OmittedExpression:                 return undefinedWideningType;             case SyntaxKind.YieldExpression:                 return checkYieldExpression(node as YieldExpression);             case SyntaxKind.SyntheticExpression:                 return checkSyntheticExpression(node as SyntheticExpression);             case SyntaxKind.JsxExpression:                 return checkJsxExpression(node as JsxExpression, checkMode);             case SyntaxKind.JsxElement:                 return checkJsxElement(node as JsxElement, checkMode);             case SyntaxKind.JsxSelfClosingElement:                 return checkJsxSelfClosingElement(node as JsxSelfClosingElement, checkMode);             case SyntaxKind.JsxFragment:                 return checkJsxFragment(node as JsxFragment);             case SyntaxKind.JsxAttributes:                 return checkJsxAttributes(node as JsxAttributes, checkMode);             case SyntaxKind.JsxOpeningElement:                 Debug.fail("Shouldn't ever directly check a JsxOpeningElement");         } */
		return errorType
	}
	checkTypeParameter := func(node TypeParameterDeclaration) {
		checkGrammarModifiers(node)
		if node.expression {
			grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected)
		}
		checkSourceElement(node.constraint)
		checkSourceElement(node.default_)
		typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
		getBaseConstraintOfType(typeParameter)
		if !hasNonCircularTypeParameterDefault(typeParameter) {
			error(node.default_, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter))
		}
		constraintType := getConstraintOfTypeParameter(typeParameter)
		defaultType := getDefaultFromTypeParameter(typeParameter)
		if constraintType && defaultType {
			checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default_, Diagnostics.Type_0_does_not_satisfy_the_constraint_1)
		}
		checkNodeDeferred(node)
		addLazyDiagnostic(func() {
			/* TODO(Identifier): checkTypeNameIsReserved */
			/* TODO(PropertyAccessExpression): node.name */
			/* TODO(PropertyAccessExpression): Diagnostics.Type_parameter_name_cannot_be_0 */
		})
	}
	checkTypeParameterDeferred := func(node TypeParameterDeclaration) {
		if isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent) {
			typeParameter := getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node))
			modifiers := getTypeParameterModifiers(typeParameter) & (ModifierFlagsIn | ModifierFlagsOut)
			if modifiers {
				symbol := getSymbolOfDeclaration(node.parent)
				if isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (ObjectFlagsReference | ObjectFlagsAnonymous | ObjectFlagsMapped)) {
					error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types)
				} else if modifiers == ModifierFlagsIn || modifiers == ModifierFlagsOut {
					tracing.push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred" /* TODO(ObjectLiteralExpression): { parent: getTypeId(getDeclaredTypeOfSymbol(symbol)), id: getTypeId(typeParameter) } */, TODO)
					source := createMarkerType(symbol, typeParameter /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSubTypeForCheck : markerSuperTypeForCheck */, TODO)
					target := createMarkerType(symbol, typeParameter /* TODO(ConditionalExpression): modifiers === ModifierFlags.Out ? markerSuperTypeForCheck : markerSubTypeForCheck */, TODO)
					saveVarianceTypeParameter := typeParameter
					varianceTypeParameter = typeParameter
					checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation)
					varianceTypeParameter = saveVarianceTypeParameter
					tracing.pop()
				}
			}
		}
	}
	checkParameter := func(node ParameterDeclaration) {
		checkGrammarModifiers(node)
		checkVariableLikeDeclaration(node)
		func_ := /* TODO(NonNullExpression): getContainingFunction(node)! */ TODO
		if hasSyntacticModifier(node, ModifierFlagsParameterPropertyModifier) {
			if !(func_.kind == SyntaxKindConstructor && nodeIsPresent(func_.body)) {
				error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation)
			}
			if func_.kind == SyntaxKindConstructor && isIdentifier(node.name) && node.name.escapedText == "constructor" {
				error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name)
			}
		}
		if !node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && (func_ /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body {
			error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature)
		}
		if node.name && isIdentifier(node.name) && (node.name.escapedText == "this" || node.name.escapedText == "new") {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.parameters.indexOf(node) !== 0 */ TODO {
				error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText /* as */ /* TODO(StringKeyword): string */)
			}
			if func_.kind == SyntaxKindConstructor || func_.kind == SyntaxKindConstructSignature || func_.kind == SyntaxKindConstructorType {
				error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindArrowFunction {
				error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
			}
			if func_.kind == SyntaxKindGetAccessor || func_.kind == SyntaxKindSetAccessor {
				error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters)
			}
		}
		if node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType) {
			error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type)
		}
	}
	checkTypePredicate := func(node TypePredicateNode) {
		parent := getTypePredicateParent(node)
		if !parent {
			error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods)
			return
		}
		signature := getSignatureFromDeclaration(parent)
		typePredicate := getTypePredicateOfSignature(signature)
		if !typePredicate {
			return
		}
		checkSourceElement(node.type_)
		TODO_IDENTIFIER := node
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typePredicate.kind !== TypePredicateKind.This */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): typePredicate.kind !== TypePredicateKind.AssertsThis */ TODO {
			if typePredicate.parameterIndex >= 0 {
				if signatureHasRestParameter(signature) && typePredicate.parameterIndex == /* TODO(MinusToken): - */ /* TODO(BinaryExpression): signature.parameters.length - 1 */ TODO {
					error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter)
				} else {
					if typePredicate.type_ {
						leadingError := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
							/* TODO(Identifier): chainDiagnosticMessages */
							/* TODO(Identifier): undefined */
							/* TODO(PropertyAccessExpression): Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type */
						}
						checkTypeAssignableTo(typePredicate.type_, getTypeOfSymbol( /* TODO(ElementAccessExpression): signature.parameters[typePredicate.parameterIndex] */ TODO), node.type_, nil, leadingError)
					}
				}
			} else if parameterName {
				hasReportedError := false
				for _, TODO_IDENTIFIER := range parent.parameters {
					if isBindingPattern(name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName) {
						hasReportedError = true
						/* TODO(BreakStatement): break; */
					}
				}
				if !hasReportedError {
					error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName)
				}
			}
		}
	}
	getTypePredicateParent := func(node Node) *SignatureDeclaration {
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ArrowFunction:             case SyntaxKind.CallSignature:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.FunctionType:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 const parent = node.parent as SignatureDeclaration;                 if (node === parent.type) {                     return parent;                 }         } */
	}
	checkIfTypePredicateVariableIsDeclaredInBindingPattern := func(pattern BindingPattern, predicateVariableNode Node, predicateVariableName string) /* TODO(undefined): true | undefined */ TODO {
		for _, element := range pattern.elements {
			if isOmittedExpression(element) {
				/* TODO(ContinueStatement): continue; */
			}
			name := element.name
			if name.kind == SyntaxKindIdentifier && name.escapedText == predicateVariableName {
				error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName)
				return true
			} else if name.kind == SyntaxKindArrayBindingPattern || name.kind == SyntaxKindObjectBindingPattern {
				if checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName) {
					return true
				}
			}
		}
	}
	checkSignatureDeclaration := func(node SignatureDeclaration) {
		if node.kind == SyntaxKindIndexSignature {
			checkGrammarIndexSignature(node)
		} else if node.kind == SyntaxKindFunctionType || node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindConstructorType || node.kind == SyntaxKindCallSignature || node.kind == SyntaxKindConstructor || node.kind == SyntaxKindConstructSignature {
			checkGrammarFunctionLikeDeclaration(node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
		}
		functionFlags := getFunctionFlags(node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */)
		if !(functionFlags & FunctionFlagsInvalid) {
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsyncGenerator && languageVersion < LanguageFeatureMinimumTargetAsyncGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAsyncGeneratorIncludes)
			}
			if (functionFlags&FunctionFlagsAsyncGenerator) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetAsyncFunctions {
				checkExternalEmitHelpers(node, ExternalEmitHelpersAwaiter)
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.AsyncGenerator) !== FunctionFlags.Normal */ TODO && languageVersion < LanguageFeatureMinimumTargetGenerators {
				checkExternalEmitHelpers(node, ExternalEmitHelpersGenerator)
			}
		}
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkUnmatchedJSDocParameters(node)
		forEach(node.parameters, checkParameter)
		if node.type_ {
			checkSourceElement(node.type_)
		}
		addLazyDiagnostic(checkSignatureDeclarationDiagnostics)
		checkSignatureDeclarationDiagnostics := func() {
			checkCollisionWithArgumentsInGeneratedCode(node)
			returnTypeNode := getEffectiveReturnTypeNode(node)
			returnTypeErrorLocation := returnTypeNode
			if isInJSFile(node) {
				typeTag := getJSDocTypeTag(node)
				if typeTag && typeTag.typeExpression && isTypeReferenceNode(typeTag.typeExpression.type_) {
					signature := getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression))
					if signature && signature.declaration {
						returnTypeNode = getEffectiveReturnTypeNode(signature.declaration)
						returnTypeErrorLocation = typeTag.typeExpression.type_
					}
				}
			}
			if noImplicitAny && !returnTypeNode {
				/* TODO(SwitchStatement): switch (node.kind) {                     case SyntaxKind.ConstructSignature:                         error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);                         break;                     case SyntaxKind.CallSignature:                         error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);                         break;                 } */
			}
			if returnTypeNode && returnTypeErrorLocation {
				functionFlags := getFunctionFlags(node /* as */ /* TODO(TypeReference): FunctionDeclaration */)
				if (functionFlags & (FunctionFlagsInvalid | FunctionFlagsGenerator)) == FunctionFlagsGenerator {
					returnType := getTypeFromTypeNode(returnTypeNode)
					if returnType == voidType {
						error(returnTypeErrorLocation, Diagnostics.A_generator_cannot_have_a_void_type_annotation)
					} else {
						checkGeneratorInstantiationAssignabilityToReturnType(returnType, functionFlags, returnTypeErrorLocation)
					}
				} else if (functionFlags & FunctionFlagsAsyncGenerator) == FunctionFlagsAsync {
					checkAsyncFunctionReturnType(node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */, returnTypeNode, returnTypeErrorLocation)
				}
			}
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.IndexSignature */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.JSDocFunctionType */ TODO {
				registerForUnusedIdentifiersCheck(node)
			}
		}
	}
	checkGeneratorInstantiationAssignabilityToReturnType := func(returnType Type, functionFlags FunctionFlags, errorNode TypeNode) /* TODO(undefined): boolean */ TODO {
		generatorYieldType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindYield, returnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO) || anyType
		generatorReturnType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO) || generatorYieldType
		generatorNextType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindNext, returnType /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (functionFlags & FunctionFlags.Async) !== 0 */, TODO) || unknownType
		generatorInstantiation := createGeneratorType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags & FunctionFlagsAsync))
		return checkTypeAssignableTo(generatorInstantiation, returnType, errorNode)
	}
	checkClassForDuplicateDeclarations := func(node ClassLikeDeclaration) {
		instanceNames := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		staticNames := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		privateIdentifiers := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		for _, member := range node.members {
			if member.kind == SyntaxKindConstructor {
				for _, param := range (member /* as */ /* TODO(TypeReference): ConstructorDeclaration */).parameters {
					if isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name) {
						addName(instanceNames, param.name, param.name.escapedText, DeclarationMeaningGetOrSetAccessor)
					}
				}
			} else {
				isStaticMember := isStatic(member)
				name := member.name
				if !name {
					/* TODO(ContinueStatement): continue; */
				}
				isPrivate := isPrivateIdentifier(name)
				privateStaticFlags := /* TODO(ConditionalExpression): isPrivate && isStaticMember ? DeclarationMeaning.PrivateStatic : 0 */ TODO
				names := /* TODO(ConditionalExpression): isPrivate ? privateIdentifiers :                     isStaticMember ? staticNames :                     instanceNames */ TODO
				memberName := name && getEffectivePropertyNameForPropertyNameNode(name)
				if memberName {
					/* TODO(SwitchStatement): switch (member.kind) {                         case SyntaxKind.GetAccessor:                             addName(names, name, memberName, DeclarationMeaning.GetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.SetAccessor:                             addName(names, name, memberName, DeclarationMeaning.SetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.PropertyDeclaration:                             addName(names, name, memberName, DeclarationMeaning.GetOrSetAccessor | privateStaticFlags);                             break;                          case SyntaxKind.MethodDeclaration:                             addName(names, name, memberName, DeclarationMeaning.Method | privateStaticFlags);                             break;                     } */
				}
			}
		}
		addName := func(names Map[__String, DeclarationMeaning], location Node, name __String, meaning DeclarationMeaning) {
			prev := names.get(name)
			if prev {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (prev & DeclarationMeaning.PrivateStatic) !== (meaning & DeclarationMeaning.PrivateStatic) */ TODO {
					error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location))
				} else {
					prevIsMethod := !!(prev & DeclarationMeaningMethod)
					isMethod := !!(meaning & DeclarationMeaningMethod)
					if prevIsMethod || isMethod {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prevIsMethod !== isMethod */ TODO {
							error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
						}
					} else if prev & meaning & ~DeclarationMeaningPrivateStatic {
						error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location))
					} else {
						names.set(name, prev|meaning)
					}
				}
			} else {
				names.set(name, meaning)
			}
		}
	}
	checkClassForStaticPropertyNameConflicts := func(node ClassLikeDeclaration) {
		for _, member := range node.members {
			memberNameNode := member.name
			isStaticMember := isStatic(member)
			if isStaticMember && memberNameNode {
				memberName := getEffectivePropertyNameForPropertyNameNode(memberNameNode)
				/* TODO(SwitchStatement): switch (memberName) {                     case "name":                     case "length":                     case "caller":                     case "arguments":                         if (useDefineForClassFields) {                             break;                         }                         // fall through                     case "prototype":                         const message = Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;                         const className = getNameOfSymbolAsWritten(getSymbolOfDeclaration(node));                         error(memberNameNode, message, memberName, className);                         break;                 } */
			}
		}
	}
	checkObjectTypeForDuplicateDeclarations := func(node /* TODO(UnionType): TypeLiteralNode | InterfaceDeclaration */ any) {
		names := /* TODO(NewExpression): new Map<string, boolean>() */ TODO
		for _, member := range node.members {
			if member.kind == SyntaxKindPropertySignature {
				var memberName string
				name := /* TODO(NonNullExpression): member.name! */ TODO
				/* TODO(SwitchStatement): switch (name.kind) {                     case SyntaxKind.StringLiteral:                     case SyntaxKind.NumericLiteral:                         memberName = name.text;                         break;                     case SyntaxKind.Identifier:                         memberName = idText(name);                         break;                     default:                         continue;                 } */
				if names.get(memberName) {
					error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName)
					error(member.name, Diagnostics.Duplicate_identifier_0, memberName)
				} else {
					names.set(memberName, true)
				}
			}
		}
	}
	checkTypeForDuplicateIndexSignatures := func(node /* TODO(UnionType): ClassLikeDeclaration | InterfaceDeclaration | TypeLiteralNode */ any) {
		if node.kind == SyntaxKindInterfaceDeclaration {
			nodeSymbol := getSymbolOfDeclaration(node)
			if nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): nodeSymbol.declarations[0] !== node */ TODO {
				return
			}
		}
		indexSymbol := getIndexSymbol(getSymbolOfDeclaration(node))
		if indexSymbol.declarations {
			indexSignatureMap := /* TODO(NewExpression): new Map<TypeId, { type: Type; declarations: IndexSignatureDeclaration[]; }>() */ TODO
			for _, declaration := range indexSymbol.declarations /* as */ /* TODO(ArrayType): IndexSignatureDeclaration[] */ {
				if declaration.parameters.length == 1 && /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO.type_ {
					forEachType(getTypeFromTypeNode( /* TODO(ElementAccessExpression): declaration.parameters[0] */ TODO.type_), func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) {
						entry := indexSignatureMap.get(getTypeId(type_))
						if entry {
							entry.declarations.push(declaration)
						} else {
							indexSignatureMap.set(getTypeId(type_) /* TODO(ObjectLiteralExpression): { type, declarations: [declaration] } */, TODO)
						}
					})
				}
			}
			indexSignatureMap.forEach(func(entry /* TODO(undefined): { type: import("/home/jabaile/work/TypeScript/src/compiler/types").Type; declarations: import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration[]; } */ TODO) {
				if entry.declarations.length > 1 {
					for _, declaration := range entry.declarations {
						error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type_))
					}
				}
			})
		}
	}
	checkPropertyDeclaration := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) {
		if !checkGrammarModifiers(node) && !checkGrammarProperty(node) {
			/* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
		}
		checkVariableLikeDeclaration(node)
		setNodeLinksForPrivateIdentifierScope(node)
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindPropertyDeclaration && node.initializer {
			error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
	}
	checkPropertySignature := func(node PropertySignature) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		return checkPropertyDeclaration(node)
	}
	checkMethodDeclaration := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) {
		if !checkGrammarMethod(node) {
			/* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
		}
		if isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) == "constructor" {
			error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator)
		}
		checkFunctionOrMethodDeclaration(node)
		if hasSyntacticModifier(node, ModifierFlagsAbstract) && node.kind == SyntaxKindMethodDeclaration && node.body {
			error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name))
		}
		if isPrivateIdentifier(node.name) && !getContainingClass(node) {
			error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
		}
		setNodeLinksForPrivateIdentifierScope(node)
	}
	setNodeLinksForPrivateIdentifierScope := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */ any) {
		if isPrivateIdentifier(node.name) {
			if languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators || !useDefineForClassFields {
				/* TODO(ForStatement): for (let lexicalScope = getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)) {                     getNodeLinks(lexicalScope).flags |= NodeCheckFlags.ContainsClassWithPrivateIdentifiers;                 } */
				if isClassExpression(node.parent) {
					enclosingIterationStatement := getEnclosingIterationStatement(node.parent)
					if enclosingIterationStatement {
						getNodeLinks(node.name).flags |= NodeCheckFlagsBlockScopedBindingInLoop
						getNodeLinks(enclosingIterationStatement).flags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding
					}
				}
			}
		}
	}
	checkClassStaticBlockDeclaration := func(node ClassStaticBlockDeclaration) {
		checkGrammarModifiers(node)
		forEachChild(node, checkSourceElement)
	}
	checkConstructorDeclaration := func(node ConstructorDeclaration) {
		checkSignatureDeclaration(node)
		if !checkGrammarConstructorTypeParameters(node) {
			/* TODO(CallExpression): checkGrammarConstructorTypeAnnotation(node) */
		}
		checkSourceElement(node.body)
		symbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(symbol, node.kind)
		if node == firstDeclaration {
			checkFunctionOrConstructorSymbol(symbol)
		}
		if nodeIsMissing(node.body) {
			return
		}
		addLazyDiagnostic(checkConstructorDeclarationDiagnostics)
		return
		isInstancePropertyWithInitializerOrPrivateIdentifierProperty := func(n Node) bool {
			if isPrivateIdentifierClassElementDeclaration(n) {
				return true
			}
			return n.kind == SyntaxKindPropertyDeclaration && !isStatic(n) && !!(n /* as */ /* TODO(TypeReference): PropertyDeclaration */).initializer
		}
		checkConstructorDeclarationDiagnostics := func() {
			containingClassDecl := node.parent
			if getClassExtendsHeritageElement(containingClassDecl) {
				captureLexicalThis(node.parent, containingClassDecl)
				classExtendsNull := classDeclarationExtendsNull(containingClassDecl)
				superCall := findFirstSuperCall( /* TODO(NonNullExpression): node.body! */ TODO)
				if superCall {
					if classExtendsNull {
						error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null)
					}
					superCallShouldBeRootLevel := !emitStandardClassFields && (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) || some(node.parameters, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(Identifier): hasSyntacticModifier */
						/* TODO(Identifier): p */
						/* TODO(PropertyAccessExpression): ModifierFlags.ParameterPropertyModifier */
					}))
					if superCallShouldBeRootLevel {
						if !superCallIsRootLevelInConstructor(superCall /* TODO(NonNullExpression): node.body! */, TODO) {
							error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers)
						} else {
							var superCallStatement *ExpressionStatement
							for _, statement := range /* TODO(NonNullExpression): node.body! */ TODO.statements {
								if isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression)) {
									superCallStatement = statement
									/* TODO(BreakStatement): break; */
								}
								if nodeImmediatelyReferencesSuperOrThis(statement) {
									/* TODO(BreakStatement): break; */
								}
							}
							if superCallStatement == nil {
								error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers)
							}
						}
					}
				} else if !classExtendsNull {
					error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call)
				}
			}
		}
	}
	superCallIsRootLevelInConstructor := func(superCall Node, body Block) /* TODO(undefined): boolean */ TODO {
		superCallParent := walkUpParenthesizedExpressions(superCall.parent)
		return isExpressionStatement(superCallParent) && superCallParent.parent == body
	}
	nodeImmediatelyReferencesSuperOrThis := func(node Node) bool {
		if node.kind == SyntaxKindSuperKeyword || node.kind == SyntaxKindThisKeyword {
			return true
		}
		if isThisContainerOrFunctionBlock(node) {
			return false
		}
		return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis)
	}
	checkAccessorDeclaration := func(node AccessorDeclaration) {
		if isIdentifier(node.name) && idText(node.name) == "constructor" && isClassLike(node.parent) {
			error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor)
		}
		addLazyDiagnostic(checkAccessorDeclarationDiagnostics)
		checkSourceElement(node.body)
		setNodeLinksForPrivateIdentifierScope(node)
		checkAccessorDeclarationDiagnostics := func() {
			if !checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node) {
				/* TODO(CallExpression): checkGrammarComputedPropertyName(node.name) */
			}
			checkDecorators(node)
			checkSignatureDeclaration(node)
			if node.kind == SyntaxKindGetAccessor {
				if !(node.flags & NodeFlagsAmbient) && nodeIsPresent(node.body) && (node.flags & NodeFlagsHasImplicitReturn) {
					if !(node.flags & NodeFlagsHasExplicitReturn) {
						error(node.name, Diagnostics.A_get_accessor_must_return_a_value)
					}
				}
			}
			if node.name.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.name)
			}
			if hasBindableName(node) {
				symbol := getSymbolOfDeclaration(node)
				getter := getDeclarationOfKind(symbol, SyntaxKindGetAccessor)
				setter := getDeclarationOfKind(symbol, SyntaxKindSetAccessor)
				if getter && setter && !(getNodeCheckFlags(getter) & NodeCheckFlagsTypeChecked) {
					getNodeLinks(getter).flags |= NodeCheckFlagsTypeChecked
					getterFlags := getEffectiveModifierFlags(getter)
					setterFlags := getEffectiveModifierFlags(setter)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getterFlags & ModifierFlags.Abstract) !== (setterFlags & ModifierFlags.Abstract) */ TODO {
						error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
						error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract)
					}
					if ((getterFlags & ModifierFlagsProtected) && !(setterFlags & (ModifierFlagsProtected | ModifierFlagsPrivate))) || ((getterFlags & ModifierFlagsPrivate) && !(setterFlags & ModifierFlagsPrivate)) {
						error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
						error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter)
					}
				}
			}
			returnType := getTypeOfAccessors(getSymbolOfDeclaration(node))
			if node.kind == SyntaxKindGetAccessor {
				checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType)
			}
		}
	}
	checkMissingDeclaration := func(node Node) {
		checkDecorators(node)
	}
	getEffectiveTypeArgumentAtIndex := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any, typeParameters []TypeParameter, index number) Type {
		if node.typeArguments && index < node.typeArguments.length {
			return getTypeFromTypeNode( /* TODO(ElementAccessExpression): node.typeArguments[index] */ TODO)
		}
		return /* TODO(ElementAccessExpression): getEffectiveTypeArguments(node, typeParameters)[index] */ TODO
	}
	getEffectiveTypeArguments := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) []Type {
		return fillMissingTypeArguments(map_( /* TODO(NonNullExpression): node.typeArguments! */ TODO, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node))
	}
	checkTypeArgumentConstraints := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | NodeWithTypeArguments */ any, typeParameters []TypeParameter) bool {
		var typeArguments /* TODO(ArrayType): Type[] */ any
		var mapper *TypeMapper
		result := true
		/* TODO(ForStatement): for (let i = 0; i < typeParameters.length; i++) {             const constraint = getConstraintOfTypeParameter(typeParameters[i]);             if (constraint) {                 if (!typeArguments) {                     typeArguments = getEffectiveTypeArguments(node, typeParameters);                     mapper = createTypeMapper(typeParameters, typeArguments);                 }                 result = result && checkTypeAssignableTo(                     typeArguments[i],                     instantiateType(constraint, mapper),                     node.typeArguments![i],                     Diagnostics.Type_0_does_not_satisfy_the_constraint_1,                 );             }         } */
		return result
	}
	getTypeParametersForTypeAndSymbol := func(type_ Type, symbol Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		if !isErrorType(type_) {
			return symbol.flags&SymbolFlagsTypeAlias && getSymbolLinks(symbol).typeParameters || ( /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Reference ? (type as TypeReference).target.localTypeParameters : undefined */ TODO)
		}
		return nil
	}
	getTypeParametersForTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameter[] | undefined */ TODO {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				return getTypeParametersForTypeAndSymbol(type_, symbol)
			}
		}
		return nil
	}
	checkTypeReferenceNode := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments */ any) {
		checkGrammarTypeArguments(node, node.typeArguments)
		if node.kind == SyntaxKindTypeReference && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.typeName.end !== node.typeArguments.pos */ TODO {
			sourceFile := getSourceFileOfNode(node)
			if scanTokenAtPosition(sourceFile, node.typeName.end) == SyntaxKindDotToken {
				grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
		forEach(node.typeArguments, checkSourceElement)
		checkTypeReferenceOrImport(node)
	}
	checkTypeReferenceOrImport := func(node /* TODO(UnionType): TypeReferenceNode | ExpressionWithTypeArguments | ImportTypeNode */ any) {
		type_ := getTypeFromTypeNode(node)
		if !isErrorType(type_) {
			if node.typeArguments {
				addLazyDiagnostic(func() {
					typeParameters := getTypeParametersForTypeReferenceOrImport(node)
					if typeParameters {
						checkTypeArgumentConstraints(node, typeParameters)
					}
				})
			}
			symbol := getNodeLinks(node).resolvedSymbol
			if symbol {
				if some(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(CallExpression): isTypeDeclaration(d) */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(PrefixUnaryExpression): !!(d.flags & NodeFlags.Deprecated) */
				}) {
					addDeprecatedSuggestion(getDeprecatedSuggestionNode(node) /* TODO(NonNullExpression): symbol.declarations! */, TODO, symbol.escapedName /* as */ /* TODO(StringKeyword): string */)
				}
			}
		}
	}
	getTypeArgumentConstraint := func(node TypeNode) *Type {
		typeReferenceNode := tryCast(node.parent, isTypeReferenceType)
		if !typeReferenceNode {
			/* TODO(Identifier): undefined */
		}
		typeParameters := getTypeParametersForTypeReferenceOrImport(typeReferenceNode)
		if !typeParameters {
			/* TODO(Identifier): undefined */
		}
		constraint := getConstraintOfTypeParameter( /* TODO(ElementAccessExpression): typeParameters[typeReferenceNode.typeArguments!.indexOf(node)] */ TODO)
		return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments(typeReferenceNode, typeParameters)))
	}
	checkTypeQuery := func(node TypeQueryNode) {
		getTypeFromTypeQueryNode(node)
	}
	checkTypeLiteral := func(node TypeLiteralNode) {
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(checkTypeLiteralDiagnostics)
		checkTypeLiteralDiagnostics := func() {
			type_ := getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node)
			checkIndexConstraints(type_, type_.symbol)
			checkTypeForDuplicateIndexSignatures(node)
			checkObjectTypeForDuplicateDeclarations(node)
		}
	}
	checkArrayType := func(node ArrayTypeNode) {
		checkSourceElement(node.elementType)
	}
	checkTupleType := func(node TupleTypeNode) {
		seenOptionalElement := false
		seenRestElement := false
		for _, e := range node.elements {
			flags := getTupleElementFlags(e)
			if flags & ElementFlagsVariadic {
				type_ := getTypeFromTypeNode((e /* as */ /* TODO(UnionType): RestTypeNode | NamedTupleMember */).type_)
				if !isArrayLikeType(type_) {
					error(e, Diagnostics.A_rest_element_type_must_be_an_array_type)
					/* TODO(BreakStatement): break; */
				}
				if isArrayType(type_) || isTupleType(type_) && type_.target.combinedFlags&ElementFlagsRest {
					flags |= ElementFlagsRest
				}
			}
			if flags & ElementFlagsRest {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element)
					/* TODO(BreakStatement): break; */
				}
				seenRestElement = true
			} else if flags & ElementFlagsOptional {
				if seenRestElement {
					grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element)
					/* TODO(BreakStatement): break; */
				}
				seenOptionalElement = true
			} else if flags&ElementFlagsRequired && seenOptionalElement {
				grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element)
				/* TODO(BreakStatement): break; */
			}
		}
		forEach(node.elements, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkUnionOrIntersectionType := func(node UnionOrIntersectionTypeNode) {
		forEach(node.types, checkSourceElement)
		getTypeFromTypeNode(node)
	}
	checkIndexedAccessIndexType := func(type_ Type, accessNode /* TODO(UnionType): IndexedAccessTypeNode | ElementAccessExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if !(type_.flags & TypeFlagsIndexedAccess) {
			return type_
		}
		objectType := (type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).objectType
		indexType := (type_ /* as */ /* TODO(TypeReference): IndexedAccessType */).indexType
		objectIndexType := /* TODO(ConditionalExpression): isGenericMappedType(objectType) && getMappedTypeNameTypeKind(objectType) === MappedTypeNameTypeKind.Remapping             ? getIndexTypeForMappedType(objectType, IndexFlags.None)             : getIndexType(objectType, IndexFlags.None) */ TODO
		hasNumberIndexInfo := !!getIndexInfoOfType(objectType, numberType)
		if everyType(indexType, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): isTypeAssignableTo(t, objectIndexType) */
			/* TODO(BarBarToken): || */
			/* TODO(BinaryExpression): hasNumberIndexInfo && isApplicableIndexType(t, numberType) */
		}) {
			if accessNode.kind == SyntaxKindElementAccessExpression && isAssignmentTarget(accessNode) && getObjectFlags(objectType)&ObjectFlagsMapped && getMappedTypeModifiers(objectType /* as */ /* TODO(TypeReference): MappedType */)&MappedTypeModifiersIncludeReadonly {
				error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType))
			}
			return type_
		}
		if isGenericObjectType(objectType) {
			propertyName := getPropertyNameFromIndex(indexType, accessNode)
			if propertyName {
				propertySymbol := forEachType(getApparentType(objectType), func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
					/* TODO(Identifier): getPropertyOfType */
					/* TODO(Identifier): t */
					/* TODO(Identifier): propertyName */
				})
				if propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol)&ModifierFlagsNonPublicAccessibilityModifier {
					error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName))
					return errorType
				}
			}
		}
		error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType))
		return errorType
	}
	checkIndexedAccessType := func(node IndexedAccessTypeNode) {
		checkSourceElement(node.objectType)
		checkSourceElement(node.indexType)
		checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node)
	}
	checkMappedType := func(node MappedTypeNode) {
		checkGrammarMappedType(node)
		checkSourceElement(node.typeParameter)
		checkSourceElement(node.nameType)
		checkSourceElement(node.type_)
		if !node.type_ {
			reportImplicitAny(node, anyType)
		}
		type_ := getTypeFromMappedTypeNode(node) /* as */ /* TODO(TypeReference): MappedType */
		nameType := getNameTypeFromMappedType(type_)
		if nameType {
			checkTypeAssignableTo(nameType, stringNumberSymbolType, node.nameType)
		} else {
			constraintType := getConstraintTypeFromMappedType(type_)
			checkTypeAssignableTo(constraintType, stringNumberSymbolType, getEffectiveConstraintOfTypeParameter(node.typeParameter))
		}
	}
	checkGrammarMappedType := func(node MappedTypeNode) /* TODO(undefined): boolean | undefined */ TODO {
		if node.members.length {
			return grammarErrorOnNode( /* TODO(ElementAccessExpression): node.members[0] */ TODO, Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
	}
	checkThisType := func(node ThisTypeNode) {
		getTypeFromThisTypeNode(node)
	}
	checkTypeOperator := func(node TypeOperatorNode) {
		checkGrammarTypeOperatorNode(node)
		checkSourceElement(node.type_)
	}
	checkConditionalType := func(node ConditionalTypeNode) {
		forEachChild(node, checkSourceElement)
	}
	checkInferType := func(node InferTypeNode) {
		if !findAncestor(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): n.parent && n.parent.kind === SyntaxKind.ConditionalType */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(BinaryExpression): (n.parent as ConditionalTypeNode).extendsType === n */
		}) {
			grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type)
		}
		checkSourceElement(node.typeParameter)
		symbol := getSymbolOfDeclaration(node.typeParameter)
		if symbol.declarations && symbol.declarations.length > 1 {
			links := getSymbolLinks(symbol)
			if !links.typeParametersChecked {
				links.typeParametersChecked = true
				typeParameter := getDeclaredTypeOfTypeParameter(symbol)
				var declarations []TypeParameterDeclaration = getDeclarationsOfKind(symbol, SyntaxKindTypeParameter)
				if !areTypeParametersIdentical(declarations /* TODO(ArrayLiteralExpression): [typeParameter] */, TODO, func(decl /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeParameterDeclaration[] */ TODO {
					/* TODO(Identifier): decl */
				}) {
					name := symbolToString(symbol)
					for _, declaration := range declarations {
						error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name)
					}
				}
			}
		}
		registerForUnusedIdentifiersCheck(node)
	}
	checkTemplateLiteralType := func(node TemplateLiteralTypeNode) {
		for _, span := range node.templateSpans {
			checkSourceElement(span.type_)
			type_ := getTypeFromTypeNode(span.type_)
			checkTypeAssignableTo(type_, templateConstraintType, span.type_)
		}
		getTypeFromTypeNode(node)
	}
	checkImportType := func(node ImportTypeNode) {
		checkSourceElement(node.argument)
		if node.attributes {
			getResolutionModeOverride(node.attributes, grammarErrorOnNode)
		}
		checkTypeReferenceOrImport(node)
	}
	checkNamedTupleMember := func(node NamedTupleMember) {
		if node.dotDotDotToken && node.questionToken {
			grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest)
		}
		if node.type_.kind == SyntaxKindOptionalType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type)
		}
		if node.type_.kind == SyntaxKindRestType {
			grammarErrorOnNode(node.type_, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type)
		}
		checkSourceElement(node.type_)
		getTypeFromTypeNode(node)
	}
	isPrivateWithinAmbient := func(node Node) bool {
		return (hasEffectiveModifier(node, ModifierFlagsPrivate) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & NodeFlagsAmbient)
	}
	getEffectiveDeclarationFlags := func(n Declaration, flagsToCheck ModifierFlags) ModifierFlags {
		flags := getCombinedModifierFlagsCached(n)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): n.parent.kind !== SyntaxKind.InterfaceDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): n.parent.kind !== SyntaxKind.ClassDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): n.parent.kind !== SyntaxKind.ClassExpression */ TODO && n.flags&NodeFlagsAmbient {
			container := getEnclosingContainer(n)
			if (container && container.flags&NodeFlagsExportContext) && !(flags & ModifierFlagsAmbient) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent)) {
				flags |= ModifierFlagsExport
			}
			flags |= ModifierFlagsAmbient
		}
		return flags & flagsToCheck
	}
	checkFunctionOrConstructorSymbol := func(symbol Symbol) {
		addLazyDiagnostic(func() {
			/* TODO(Identifier): checkFunctionOrConstructorSymbolWorker */
			/* TODO(Identifier): symbol */
		})
	}
	checkFunctionOrConstructorSymbolWorker := func(symbol Symbol) {
		getCanonicalOverload := func(overloads []Declaration, implementation *FunctionLikeDeclaration) Declaration {
			implementationSharesContainerWithFirstOverload := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): implementation !== undefined */ TODO && implementation.parent == /* TODO(ElementAccessExpression): overloads[0] */ TODO.parent
			return /* TODO(ConditionalExpression): implementationSharesContainerWithFirstOverload ? implementation : overloads[0] */ TODO
		}
		checkFlagAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, flagsToCheck ModifierFlags, someOverloadFlags ModifierFlags, allOverloadFlags ModifierFlags) {
			someButNotAllOverloadFlags := /* TODO(CaretToken): ^ */ /* TODO(BinaryExpression): someOverloadFlags ^ allOverloadFlags */ TODO
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): someButNotAllOverloadFlags !== 0 */ TODO {
				canonicalFlags := getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck)
				group(overloads, func(o /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): string */ TODO {
					/* TODO(CallExpression): getSourceFileOfNode(o) */
					/* TODO(Identifier): fileName */
				}).forEach(func(overloadsInFile /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration[] */ TODO) {
					canonicalFlagsForFile := getEffectiveDeclarationFlags(getCanonicalOverload(overloadsInFile, implementation), flagsToCheck)
					for _, o := range overloadsInFile {
						deviation := /* TODO(CaretToken): ^ */ /* TODO(BinaryExpression): getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags */ TODO
						deviationInFile := /* TODO(CaretToken): ^ */ /* TODO(BinaryExpression): getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlagsForFile */ TODO
						if deviationInFile & ModifierFlagsExport {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported)
						} else if deviationInFile & ModifierFlagsAmbient {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient)
						} else if deviation & (ModifierFlagsPrivate | ModifierFlagsProtected) {
							error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected)
						} else if deviation & ModifierFlagsAbstract {
							error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract)
						}
					}
				})
			}
		}
		checkQuestionTokenAgreementBetweenOverloads := func(overloads []Declaration, implementation *FunctionLikeDeclaration, someHaveQuestionToken bool, allHaveQuestionToken bool) {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): someHaveQuestionToken !== allHaveQuestionToken */ TODO {
				canonicalHasQuestionToken := hasQuestionToken(getCanonicalOverload(overloads, implementation))
				forEach(overloads, func(o /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
					deviation := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): hasQuestionToken(o) !== canonicalHasQuestionToken */ TODO
					if deviation {
						error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required)
					}
				})
			}
		}
		var flagsToCheck ModifierFlags = ModifierFlagsExport | ModifierFlagsAmbient | ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAbstract
		var someNodeFlags ModifierFlags = ModifierFlagsNone
		allNodeFlags := flagsToCheck
		someHaveQuestionToken := false
		allHaveQuestionToken := true
		hasOverloads := false
		var bodyDeclaration *FunctionLikeDeclaration
		var lastSeenNonAmbientDeclaration *FunctionLikeDeclaration
		var previousDeclaration *SignatureDeclaration
		declarations := symbol.declarations
		isConstructor := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (symbol.flags & SymbolFlags.Constructor) !== 0 */ TODO
		reportImplementationExpectedError := func(node SignatureDeclaration) {
			if node.name && nodeIsMissing(node.name) {
				return
			}
			seen := false
			subsequentNode := forEachChild(node.parent, func(c /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node | undefined */ TODO {
				if seen {
					return c
				} else {
					seen = c == node
				}
			})
			if subsequentNode && subsequentNode.pos == node.end {
				if subsequentNode.kind == node.kind {
					var errorNode Node = (subsequentNode /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).name || subsequentNode
					subsequentName := (subsequentNode /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).name
					if node.name && subsequentName && (isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText == subsequentName.escapedText || isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) && isTypeIdenticalTo(checkComputedPropertyName(node.name), checkComputedPropertyName(subsequentName)) || isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) == getEscapedTextOfIdentifierOrLiteral(subsequentName)) {
						reportError := (node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isStatic(node) !== isStatic(subsequentNode) */ TODO
						if reportError {
							diagnostic := /* TODO(ConditionalExpression): isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static */ TODO
							error(errorNode, diagnostic)
						}
						return
					}
					if nodeIsPresent((subsequentNode /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body) {
						error(errorNode, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name))
						return
					}
				}
			}
			var errorNode Node = node.name || node
			if isConstructor {
				error(errorNode, Diagnostics.Constructor_implementation_is_missing)
			} else {
				if hasSyntacticModifier(node, ModifierFlagsAbstract) {
					error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive)
				} else {
					error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration)
				}
			}
		}
		duplicateFunctionDeclaration := false
		multipleConstructorImplementation := false
		hasNonAmbientClass := false
		functionDeclarations := /* TODO(ArrayLiteralExpression): [] */ TODO /* as */ /* TODO(ArrayType): Declaration[] */
		if declarations {
			for _, current := range declarations {
				node := current /* as */ /* TODO(UnionType): SignatureDeclaration | ClassDeclaration | ClassExpression */
				inAmbientContext := node.flags & NodeFlagsAmbient
				inAmbientContextOrInterface := node.parent && (node.parent.kind == SyntaxKindInterfaceDeclaration || node.parent.kind == SyntaxKindTypeLiteral) || inAmbientContext
				if inAmbientContextOrInterface {
					previousDeclaration = nil
				}
				if (node.kind == SyntaxKindClassDeclaration || node.kind == SyntaxKindClassExpression) && !inAmbientContext {
					hasNonAmbientClass = true
				}
				if node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindConstructor {
					functionDeclarations.push(node)
					currentNodeFlags := getEffectiveDeclarationFlags(node, flagsToCheck)
					someNodeFlags |= currentNodeFlags
					allNodeFlags &= currentNodeFlags
					someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node)
					allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node)
					bodyIsPresent := nodeIsPresent((node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body)
					if bodyIsPresent && bodyDeclaration {
						if isConstructor {
							multipleConstructorImplementation = true
						} else {
							duplicateFunctionDeclaration = true
						}
					} else if previousDeclaration.parent == node.parent && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): previousDeclaration.end !== node.pos */ TODO {
						reportImplementationExpectedError(previousDeclaration)
					}
					if bodyIsPresent {
						if !bodyDeclaration {
							bodyDeclaration = node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */
						}
					} else {
						hasOverloads = true
					}
					previousDeclaration = node
					if !inAmbientContextOrInterface {
						lastSeenNonAmbientDeclaration = node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */
					}
				}
				if isInJSFile(current) && isFunctionLike(current) && current.jsDoc {
					hasOverloads = length(getJSDocOverloadTags(current)) > 0
				}
			}
		}
		if multipleConstructorImplementation {
			forEach(functionDeclarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed)
			})
		}
		if duplicateFunctionDeclaration {
			forEach(functionDeclarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation)
			})
		}
		if hasNonAmbientClass && !isConstructor && symbol.flags&SymbolFlagsFunction && declarations {
			relatedDiagnostics := filter(declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): d.kind */
				/* TODO(EqualsEqualsEqualsToken): === */
				/* TODO(PropertyAccessExpression): SyntaxKind.ClassDeclaration */
			}).map_(func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
				/* TODO(Identifier): createDiagnosticForNode */
				/* TODO(Identifier): d */
				/* TODO(PropertyAccessExpression): Diagnostics.Consider_adding_a_declare_modifier_to_this_class */
			})
			forEach(declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
				diagnostic := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.ClassDeclaration                     ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0                     : declaration.kind === SyntaxKind.FunctionDeclaration                     ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient                     : undefined */ TODO
				if diagnostic {
					addRelatedInfo(error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)) /* TODO(SpreadElement): ...relatedDiagnostics */, TODO)
				}
			})
		}
		if lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(lastSeenNonAmbientDeclaration, ModifierFlagsAbstract) && !lastSeenNonAmbientDeclaration.questionToken {
			reportImplementationExpectedError(lastSeenNonAmbientDeclaration)
		}
		if hasOverloads {
			if declarations {
				checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags)
				checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken)
			}
			if bodyDeclaration {
				signatures := getSignaturesOfSymbol(symbol)
				bodySignature := getSignatureFromDeclaration(bodyDeclaration)
				for _, signature := range signatures {
					if !isImplementationCompatibleWithOverload(bodySignature, signature) {
						errorNode := /* TODO(ConditionalExpression): signature.declaration && isJSDocSignature(signature.declaration)                             ? (signature.declaration.parent as JSDocOverloadTag | JSDocCallbackTag).tagName                             : signature.declaration */ TODO
						addRelatedInfo(error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here))
						/* TODO(BreakStatement): break; */
					}
				}
			}
		}
	}
	checkExportsOnMergedDeclarations := func(node Declaration) {
		addLazyDiagnostic(func() {
			/* TODO(Identifier): checkExportsOnMergedDeclarationsWorker */
			/* TODO(Identifier): node */
		})
	}
	checkExportsOnMergedDeclarationsWorker := func(node Declaration) {
		symbol := node.localSymbol
		if !symbol {
			symbol = /* TODO(NonNullExpression): getSymbolOfDeclaration(node)! */ TODO
			if !symbol.exportSymbol {
				return
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getDeclarationOfKind(symbol, node.kind) !== node */ TODO {
			return
		}
		exportedDeclarationSpaces := DeclarationSpacesNone
		nonExportedDeclarationSpaces := DeclarationSpacesNone
		defaultExportedDeclarationSpaces := DeclarationSpacesNone
		for _, d := range /* TODO(NonNullExpression): symbol.declarations! */ TODO {
			declarationSpaces := getDeclarationSpaces(d)
			effectiveDeclarationFlags := getEffectiveDeclarationFlags(d, ModifierFlagsExport|ModifierFlagsDefault)
			if effectiveDeclarationFlags & ModifierFlagsExport {
				if effectiveDeclarationFlags & ModifierFlagsDefault {
					defaultExportedDeclarationSpaces |= declarationSpaces
				} else {
					exportedDeclarationSpaces |= declarationSpaces
				}
			} else {
				nonExportedDeclarationSpaces |= declarationSpaces
			}
		}
		nonDefaultExportedDeclarationSpaces := exportedDeclarationSpaces | nonExportedDeclarationSpaces
		commonDeclarationSpacesForExportsAndLocals := exportedDeclarationSpaces & nonExportedDeclarationSpaces
		commonDeclarationSpacesForDefaultAndNonDefault := defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces
		if commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault {
			for _, d := range /* TODO(NonNullExpression): symbol.declarations! */ TODO {
				declarationSpaces := getDeclarationSpaces(d)
				name := getNameOfDeclaration(d)
				if declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault {
					error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name))
				} else if declarationSpaces & commonDeclarationSpacesForExportsAndLocals {
					error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name))
				}
			}
		}
		getDeclarationSpaces := func(decl Declaration) DeclarationSpaces {
			d := decl /* as */ /* TODO(TypeReference): Node */
			/* TODO(SwitchStatement): switch (d.kind) {                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.TypeAliasDeclaration:                  // A jsdoc typedef and callback are, by definition, type aliases.                 // falls through                 case SyntaxKind.JSDocTypedefTag:                 case SyntaxKind.JSDocCallbackTag:                 case SyntaxKind.JSDocEnumTag:                     return DeclarationSpaces.ExportType;                 case SyntaxKind.ModuleDeclaration:                     return isAmbientModule(d as ModuleDeclaration) || getModuleInstanceState(d as ModuleDeclaration) !== ModuleInstanceState.NonInstantiated                         ? DeclarationSpaces.ExportNamespace | DeclarationSpaces.ExportValue                         : DeclarationSpaces.ExportNamespace;                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.EnumDeclaration:                 case SyntaxKind.EnumMember:                     return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue;                 case SyntaxKind.SourceFile:                     return DeclarationSpaces.ExportType | DeclarationSpaces.ExportValue | DeclarationSpaces.ExportNamespace;                 case SyntaxKind.ExportAssignment:                 case SyntaxKind.BinaryExpression:                     const node = d as ExportAssignment | BinaryExpression;                     const expression = isExportAssignment(node) ? node.expression : node.right;                     // Export assigned entity name expressions act as aliases and should fall through, otherwise they export values                     if (!isEntityNameExpression(expression)) {                         return DeclarationSpaces.ExportValue;                     }                     d = expression;                  // The below options all declare an Alias, which is allowed to merge with other values within the importing module.                 // falls through                 case SyntaxKind.ImportEqualsDeclaration:                 case SyntaxKind.NamespaceImport:                 case SyntaxKind.ImportClause:                     let result = DeclarationSpaces.None;                     const target = resolveAlias(getSymbolOfDeclaration(d as ImportEqualsDeclaration | NamespaceImport | ImportClause | ExportAssignment | BinaryExpression));                     forEach(target.declarations, d => {                         result |= getDeclarationSpaces(d);                     });                     return result;                 case SyntaxKind.VariableDeclaration:                 case SyntaxKind.BindingElement:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.ImportSpecifier: // https://github.com/Microsoft/TypeScript/pull/7591                 case SyntaxKind.Identifier: // https://github.com/microsoft/TypeScript/issues/36098                     // Identifiers are used as declarations of assignment declarations whose parents may be                     // SyntaxKind.CallExpression - `Object.defineProperty(thing, "aField", {value: 42});`                     // SyntaxKind.ElementAccessExpression - `thing["aField"] = 42;` or `thing["aField"];` (with a doc comment on it)                     // or SyntaxKind.PropertyAccessExpression - `thing.aField = 42;`                     // all of which are pretty much always values, or at least imply a value meaning.                     // It may be apprpriate to treat these as aliases in the future.                     return DeclarationSpaces.ExportValue;                 case SyntaxKind.MethodSignature:                 case SyntaxKind.PropertySignature:                     return DeclarationSpaces.ExportType;                 default:                     return Debug.failBadSyntaxKind(d);             } */
		}
	}
	getAwaitedTypeOfPromise := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		promisedType := getPromisedTypeOfPromise(type_, errorNode)
		return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
	}
	getPromisedTypeOfPromise := func(type_ Type, errorNode Node, thisTypeForErrorOut /* TODO(TypeLiteral): { value?: Type; } */ TODO) *Type {
		if isTypeAny(type_) {
			return nil
		}
		typeAsPromise := type_ /* as */ /* TODO(TypeReference): PromiseOrAwaitableType */
		if typeAsPromise.promisedTypeOfPromise {
			return typeAsPromise.promisedTypeOfPromise
		}
		if isReferenceToType(type_, getGlobalPromiseType(false)) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getTypeArguments(type as GenericType)[0] */ TODO
		}
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			return nil
		}
		thenFunction := /* TODO(NonNullExpression): getTypeOfPropertyOfType(type, "then" as __String)! */ TODO
		if isTypeAny(thenFunction) {
			return nil
		}
		thenSignatures := /* TODO(ConditionalExpression): thenFunction ? getSignaturesOfType(thenFunction, SignatureKind.Call) : emptyArray */ TODO
		if thenSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.A_promise_must_have_a_then_method)
			}
			return nil
		}
		var thisTypeForError *Type
		var candidates /* TODO(ArrayType): Signature[] */ any
		for _, thenSignature := range thenSignatures {
			thisType := getThisTypeOfSignature(thenSignature)
			if thisType && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): thisType !== voidType */ TODO && !isTypeRelatedTo(type_, thisType, subtypeRelation) {
				thisTypeForError = thisType
			} else {
				candidates = append(candidates, thenSignature)
			}
		}
		if !candidates {
			Debug.assertIsDefined(thisTypeForError)
			if thisTypeForErrorOut {
				thisTypeForErrorOut.value = thisTypeForError
			}
			if errorNode {
				error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForError))
			}
			return nil
		}
		onfulfilledParameterType := getTypeWithFacts(getUnionType(map_(candidates, getTypeOfFirstParameterOfSignature)), TypeFactsNEUndefinedOrNull)
		if isTypeAny(onfulfilledParameterType) {
			return nil
		}
		onfulfilledParameterSignatures := getSignaturesOfType(onfulfilledParameterType, SignatureKindCall)
		if onfulfilledParameterSignatures.length == 0 {
			if errorNode {
				error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback)
			}
			return nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), UnionReduction.Subtype) */ TODO
	}
	checkAwaitedType := func(type_ Type, withAlias bool, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) Type {
		awaitedType := /* TODO(ConditionalExpression): withAlias ?             getAwaitedType(type, errorNode, diagnosticMessage, ...args) :             getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, ...args) */ TODO
		return awaitedType || errorType
	}
	isThenableType := func(type_ Type) bool {
		if allTypesAssignableToKind(getBaseConstraintOrType(type_), TypeFlagsPrimitive|TypeFlagsNever) {
			return false
		}
		thenFunction := getTypeOfPropertyOfType(type_, "then" /* as */ /* TODO(TypeReference): __String */)
		return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, TypeFactsNEUndefinedOrNull), SignatureKindCall).length > 0
	}
	type AwaitedTypeInstantiation struct {
		_awaitedTypeBrand/* TODO(NeverKeyword): never */ TODO
		aliasSymbol        Symbol
		aliasTypeArguments []Type
	}
	isAwaitedTypeInstantiation := func(type_ Type) /* TODO(TypePredicate): type is AwaitedTypeInstantiation */ TODO {
		if type_.flags & TypeFlagsConditional {
			awaitedSymbol := getGlobalAwaitedSymbol(false)
			return !!awaitedSymbol && type_.aliasSymbol == awaitedSymbol && type_.aliasTypeArguments.length == 1
		}
		return false
	}
	unwrapAwaitedType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type.flags & TypeFlags.Union ? mapType(type, unwrapAwaitedType) :             isAwaitedTypeInstantiation(type) ? type.aliasTypeArguments[0] :             type */ TODO
	}
	isAwaitedTypeNeeded := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		if isTypeAny(type_) || isAwaitedTypeInstantiation(type_) {
			return false
		}
		if isGenericObjectType(type_) {
			baseConstraint := getBaseConstraintOfType(type_)
			if /* TODO(ConditionalExpression): baseConstraint ?                     baseConstraint.flags & TypeFlags.AnyOrUnknown || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) :                     maybeTypeOfKind(type, TypeFlags.TypeVariable) */ TODO {
				return true
			}
		}
		return false
	}
	tryCreateAwaitedType := func(type_ Type) *Type {
		awaitedSymbol := getGlobalAwaitedSymbol(true)
		if awaitedSymbol {
			return getTypeAliasInstantiation(awaitedSymbol /* TODO(ArrayLiteralExpression): [unwrapAwaitedType(type)] */, TODO)
		}
		return nil
	}
	createAwaitedTypeIfNeeded := func(type_ Type) Type {
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): tryCreateAwaitedType(type) ?? type */ TODO
		}
		Debug.assert(isAwaitedTypeInstantiation(type_) || getPromisedTypeOfPromise(type_) == nil, "type provided should not be a non-generic 'promise'-like.")
		return type_
	}
	getAwaitedType := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		awaitedType := getAwaitedTypeNoAlias(type_, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
		return awaitedType && createAwaitedTypeIfNeeded(awaitedType)
	}
	getAwaitedTypeNoAlias := func(type_ Type, errorNode Node, diagnosticMessage DiagnosticMessage, args DiagnosticArguments) *Type {
		if isTypeAny(type_) {
			return type_
		}
		if isAwaitedTypeInstantiation(type_) {
			return type_
		}
		typeAsAwaitable := type_ /* as */ /* TODO(TypeReference): PromiseOrAwaitableType */
		if typeAsAwaitable.awaitedTypeOfType {
			return typeAsAwaitable.awaitedTypeOfType
		}
		if type_.flags & TypeFlagsUnion {
			if awaitedTypeStack.lastIndexOf(type_.id) >= 0 {
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			mapper := /* TODO(ConditionalExpression): errorNode ? (constituentType: Type) => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, ...args) : getAwaitedTypeNoAlias */ TODO
			awaitedTypeStack.push(type_.id)
			mapped := mapType(type_, mapper)
			awaitedTypeStack.pop()
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = mapped */ TODO
		}
		if isAwaitedTypeNeeded(type_) {
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
		}
		var thisTypeForErrorOut /* TODO(TypeLiteral): { value: Type | undefined; } */ TODO = /* TODO(ObjectLiteralExpression): { value: undefined } */ TODO
		promisedType := getPromisedTypeOfPromise(type_, nil, thisTypeForErrorOut)
		if promisedType {
			if type_.id == promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0 {
				if errorNode {
					error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method)
				}
				return nil
			}
			awaitedTypeStack.push(type_.id)
			awaitedType := getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
			awaitedTypeStack.pop()
			if !awaitedType {
				return nil
			}
			return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = awaitedType */ TODO
		}
		if isThenableType(type_) {
			if errorNode {
				Debug.assertIsDefined(diagnosticMessage)
				var chain *DiagnosticMessageChain
				if thisTypeForErrorOut.value {
					chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type_), typeToString(thisTypeForErrorOut.value))
				}
				chain = chainDiagnosticMessages(chain, diagnosticMessage /* TODO(SpreadElement): ...args */, TODO)
				diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain))
			}
			return nil
		}
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): typeAsAwaitable.awaitedTypeOfType = type */ TODO
	}
	checkAsyncFunctionReturnType := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode) {
		returnType := getTypeFromTypeNode(returnTypeNode)
		if languageVersion >= ScriptTargetES2015 {
			if isErrorType(returnType) {
				return
			}
			globalPromiseType := getGlobalPromiseType(true)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalPromiseType !== emptyGenericType */ TODO && !isReferenceToType(returnType, globalPromiseType) {
				reportErrorForInvalidReturnType(Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, returnTypeNode, returnTypeErrorLocation, typeToString(getAwaitedTypeNoAlias(returnType) || voidType))
				return
			}
		} else {
			markLinkedReferences(node, ReferenceHintAsyncFunction)
			if isErrorType(returnType) {
				return
			}
			promiseConstructorName := getEntityNameFromTypeNode(returnTypeNode)
			if promiseConstructorName == nil {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, typeToString(returnType))
				return
			}
			promiseConstructorSymbol := resolveEntityName(promiseConstructorName, SymbolFlagsValue, true)
			promiseConstructorType := /* TODO(ConditionalExpression): promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType */ TODO
			if isErrorType(promiseConstructorType) {
				if promiseConstructorName.kind == SyntaxKindIdentifier && promiseConstructorName.escapedText == "Promise" && getTargetType(returnType) == getGlobalPromiseType(false) {
					error(returnTypeErrorLocation, Diagnostics.An_async_function_or_method_in_ES5_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option)
				} else {
					reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				}
				return
			}
			globalPromiseConstructorLikeType := getGlobalPromiseConstructorLikeType(true)
			if globalPromiseConstructorLikeType == emptyObjectType {
				reportErrorForInvalidReturnType(Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, returnTypeNode, returnTypeErrorLocation, entityNameToString(promiseConstructorName))
				return
			}
			headMessage := Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_because_it_does_not_refer_to_a_Promise_compatible_constructor_value
			errorInfo := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain | undefined */ TODO {
				/* TODO(BinaryExpression): returnTypeNode === returnTypeErrorLocation */
				/* TODO(QuestionToken): ? */
				/* TODO(Identifier): undefined */
				/* TODO(ColonToken): : */
				/* TODO(CallExpression): chainDiagnosticMessages(/*details* / undefined, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type) */
			}
			if !checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeErrorLocation, headMessage, errorInfo) {
				return
			}
			rootName := promiseConstructorName && getFirstIdentifier(promiseConstructorName)
			collidingSymbol := getSymbol( /* TODO(NonNullExpression): node.locals! */ TODO, rootName.escapedText, SymbolFlagsValue)
			if collidingSymbol {
				error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName))
				return
			}
		}
		checkAwaitedType(returnType, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
		reportErrorForInvalidReturnType := func(message DiagnosticMessage, returnTypeNode TypeNode, returnTypeErrorLocation TypeNode, typeName string) {
			if returnTypeNode == returnTypeErrorLocation {
				error(returnTypeErrorLocation, message, typeName)
			} else {
				diag := error(returnTypeErrorLocation, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type)
				addRelatedInfo(diag, createDiagnosticForNode(returnTypeNode, message, typeName))
			}
		}
	}
	checkGrammarDecorator := func(decorator Decorator) bool {
		sourceFile := getSourceFileOfNode(decorator)
		if !hasParseDiagnostics(sourceFile) {
			var node Expression = decorator.expression
			if isParenthesizedExpression(node) {
				return false
			}
			canHaveCallExpression := true
			var errorNode Node
			/* TODO(WhileStatement): while (true) {                 // Allow TS syntax such as non-null assertions and instantiation expressions                 if (isExpressionWithTypeArguments(node) || isNonNullExpression(node)) {                     node = node.expression;                     continue;                 }                  // DecoratorCallExpression :                 //   DecoratorMemberExpression Arguments                  if (isCallExpression(node)) {                     if (!canHaveCallExpression) {                         errorNode = node;                     }                     if (node.questionDotToken) {                         // Even if we already have an error node, error at the `?.` token since it appears earlier.                         errorNode = node.questionDotToken;                     }                     node = node.expression;                     canHaveCallExpression = false;                     continue;                 }                  // DecoratorMemberExpression :                 //   IdentifierReference                 //   DecoratorMemberExpression `.` IdentifierName                 //   DecoratorMemberExpression `.` PrivateIdentifier                  if (isPropertyAccessExpression(node)) {                     if (node.questionDotToken) {                         // Even if we already have an error node, error at the `?.` token since it appears earlier.                         errorNode = node.questionDotToken;                     }                     node = node.expression;                     canHaveCallExpression = false;                     continue;                 }                  if (!isIdentifier(node)) {                     // Even if we already have an error node, error at this node since it appears earlier.                     errorNode = node;                 }                  break;             } */
			if errorNode {
				addRelatedInfo(error(decorator.expression, Diagnostics.Expression_must_be_enclosed_in_parentheses_to_be_used_as_a_decorator), createDiagnosticForNode(errorNode, Diagnostics.Invalid_syntax_in_decorator))
				return true
			}
		}
		return false
	}
	checkDecorator := func(node Decorator) {
		checkGrammarDecorator(node)
		signature := getResolvedSignature(node)
		checkDeprecatedSignature(signature, node)
		returnType := getReturnTypeOfSignature(signature)
		if returnType.flags & TypeFlagsAny {
			return
		}
		decoratorSignature := getDecoratorCallSignature(node)
		if !decoratorSignature.resolvedReturnType {
		}
		var headMessage DiagnosticMessage
		expectedReturnType := decoratorSignature.resolvedReturnType
		/* TODO(SwitchStatement): switch (node.parent.kind) {             case SyntaxKind.ClassDeclaration:             case SyntaxKind.ClassExpression:                 headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                 break;              case SyntaxKind.PropertyDeclaration:                 if (!legacyDecorators) {                     headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                     break;                 }                 // falls through              case SyntaxKind.Parameter:                 headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any;                 break;              case SyntaxKind.MethodDeclaration:             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;                 break;              default:                 return Debug.failBadSyntaxKind(node.parent);         } */
		checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage)
	}
	createCallSignature := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number /* = */ /* TODO(PropertyAccessExpression): parameters.length */, flags SignatureFlags /* = */ /* TODO(PropertyAccessExpression): SignatureFlags.None */) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO {
		decl := factory.createFunctionTypeNode(nil, emptyArray, factory.createKeywordTypeNode(SyntaxKindAnyKeyword))
		return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
	}
	createFunctionType := func(typeParameters /* TODO(TypeOperator): readonly TypeParameter[] */ any, thisParameter *Symbol, parameters []Symbol, returnType Type, typePredicate TypePredicate, minArgumentCount number, flags SignatureFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		signature := createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags)
		return getOrCreateTypeFromSignature(signature)
	}
	createGetterFunctionType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		return createFunctionType(nil, nil, emptyArray, type_)
	}
	createSetterFunctionType := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ObjectType */ TODO {
		valueParam := createParameter("value" /* as */ /* TODO(TypeReference): __String */, type_)
		return createFunctionType(nil, nil /* TODO(ArrayLiteralExpression): [valueParam] */, TODO, voidType)
	}
	getEntityNameForDecoratorMetadata := func(node *TypeNode) *EntityName {
		if node {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.IntersectionType:                 case SyntaxKind.UnionType:                     return getEntityNameForDecoratorMetadataFromTypeList((node as UnionOrIntersectionTypeNode).types);                  case SyntaxKind.ConditionalType:                     return getEntityNameForDecoratorMetadataFromTypeList([(node as ConditionalTypeNode).trueType, (node as ConditionalTypeNode).falseType]);                  case SyntaxKind.ParenthesizedType:                 case SyntaxKind.NamedTupleMember:                     return getEntityNameForDecoratorMetadata((node as ParenthesizedTypeNode).type);                  case SyntaxKind.TypeReference:                     return (node as TypeReferenceNode).typeName;             } */
		}
	}
	getEntityNameForDecoratorMetadataFromTypeList := func(types []TypeNode) *EntityName {
		var commonEntityName *EntityName
		for _, typeNode := range types {
			/* TODO(WhileStatement): while (typeNode.kind === SyntaxKind.ParenthesizedType || typeNode.kind === SyntaxKind.NamedTupleMember) {                 typeNode = (typeNode as ParenthesizedTypeNode | NamedTupleMember).type; // Skip parens if need be             } */
			if typeNode.kind == SyntaxKindNeverKeyword {
				/* TODO(ContinueStatement): continue; */
			}
			if !strictNullChecks && (typeNode.kind == SyntaxKindLiteralType && (typeNode /* as */ /* TODO(TypeReference): LiteralTypeNode */).literal.kind == SyntaxKindNullKeyword || typeNode.kind == SyntaxKindUndefinedKeyword) {
				/* TODO(ContinueStatement): continue; */
			}
			individualEntityName := getEntityNameForDecoratorMetadata(typeNode)
			if !individualEntityName {
				return nil
			}
			if commonEntityName {
				if !isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): commonEntityName.escapedText !== individualEntityName.escapedText */ TODO {
					return nil
				}
			} else {
				commonEntityName = individualEntityName
			}
		}
		return commonEntityName
	}
	getParameterTypeNodeForDecoratorCheck := func(node ParameterDeclaration) *TypeNode {
		typeNode := getEffectiveTypeAnnotationNode(node)
		return /* TODO(ConditionalExpression): isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode */ TODO
	}
	checkDecorators := func(node Node) {
		if !canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
			return
		}
		firstDecorator := find(node.modifiers, isDecorator)
		if !firstDecorator {
			return
		}
		if legacyDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersDecorate)
			if node.kind == SyntaxKindParameter {
				checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersParam)
			}
		} else if languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators {
			checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersESDecorateAndRunInitializers)
			if isClassDeclaration(node) {
				if !node.name {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				} else {
					member := getFirstTransformableStaticClassElement(node)
					if member {
						checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
					}
				}
			} else if !isClassExpression(node) {
				if isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node)) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersSetFunctionName)
				}
				if isComputedPropertyName(node.name) {
					checkExternalEmitHelpers(firstDecorator, ExternalEmitHelpersPropKey)
				}
			}
		}
		markLinkedReferences(node, ReferenceHintDecorator)
		for _, modifier := range node.modifiers {
			if isDecorator(modifier) {
				checkDecorator(modifier)
			}
		}
	}
	checkFunctionDeclaration := func(node FunctionDeclaration) {
		addLazyDiagnostic(checkFunctionDeclarationDiagnostics)
		checkFunctionDeclarationDiagnostics := func() {
			checkFunctionOrMethodDeclaration(node)
			checkGrammarForGenerator(node)
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	checkJSDocTypeAliasTag := func(node /* TODO(UnionType): JSDocTypedefTag | JSDocCallbackTag */ any) {
		if !node.typeExpression {
			error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags)
		}
		if node.name {
			checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		}
		checkSourceElement(node.typeExpression)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
	}
	checkJSDocTemplateTag := func(node JSDocTemplateTag) {
		checkSourceElement(node.constraint)
		for _, tp := range node.typeParameters {
			checkSourceElement(tp)
		}
	}
	checkJSDocTypeTag := func(node JSDocTypeTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocSatisfiesTag := func(node JSDocSatisfiesTag) {
		checkSourceElement(node.typeExpression)
		host := getEffectiveJSDocHost(node)
		if host {
			tags := getAllJSDocTags(host, isJSDocSatisfiesTag)
			if length(tags) > 1 {
				/* TODO(ForStatement): for (let i = 1; i < length(tags); i++) {                     const tagName = tags[i].tagName;                     error(tagName, Diagnostics._0_tag_already_specified, idText(tagName));                 } */
			}
		}
	}
	checkJSDocLinkLikeTag := func(node /* TODO(UnionType): JSDocLink | JSDocLinkCode | JSDocLinkPlain */ any) {
		if node.name {
			resolveJSDocMemberName(node.name, true)
		}
	}
	checkJSDocParameterTag := func(node JSDocParameterTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocPropertyTag := func(node JSDocPropertyTag) {
		checkSourceElement(node.typeExpression)
	}
	checkJSDocFunctionType := func(node JSDocFunctionType) {
		addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny)
		checkSignatureDeclaration(node)
		checkJSDocFunctionTypeImplicitAny := func() {
			if !node.type_ && !isJSDocConstructSignature(node) {
				reportImplicitAny(node, anyType)
			}
		}
	}
	checkJSDocThisTag := func(node JSDocThisTag) {
		host := getEffectiveJSDocHost(node)
		if host && isArrowFunction(host) {
			error(node.tagName, Diagnostics.An_arrow_function_cannot_have_a_this_parameter)
		}
	}
	checkJSDocImportTag := func(node JSDocImportTag) {
		checkImportAttributes(node)
	}
	checkJSDocImplementsTag := func(node JSDocImplementsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
		}
	}
	checkJSDocAugmentsTag := func(node JSDocAugmentsTag) {
		classLike := getEffectiveJSDocHost(node)
		if !classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike) {
			error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName))
			return
		}
		augmentsTags := getJSDocTags(classLike).filter(isJSDocAugmentsTag)
		Debug.assert(augmentsTags.length > 0)
		if augmentsTags.length > 1 {
			error( /* TODO(ElementAccessExpression): augmentsTags[1] */ TODO, Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag)
		}
		name := getIdentifierFromEntityNameExpression(node.class.expression)
		extend := getClassExtendsHeritageElement(classLike)
		if extend {
			className := getIdentifierFromEntityNameExpression(extend.expression)
			if className && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name.escapedText !== className.escapedText */ TODO {
				error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className))
			}
		}
	}
	checkJSDocAccessibilityModifiers := func(node /* TODO(UnionType): JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag */ any) {
		host := getJSDocHost(node)
		if host && isPrivateIdentifierClassElementDeclaration(host) {
			error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier)
		}
	}
	// OVERLOAD: getIdentifierFromEntityNameExpression := func(node /* TODO(UnionType): Identifier | PropertyAccessExpression */ any) /* TODO(UnionType): Identifier | PrivateIdentifier */ any
	// OVERLOAD: getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any
	getIdentifierFromEntityNameExpression := func(node Expression) /* TODO(UnionType): Identifier | PrivateIdentifier | undefined */ any {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 return node as Identifier;             case SyntaxKind.PropertyAccessExpression:                 return (node as PropertyAccessExpression).name;             default:                 return undefined;         } */
	}
	checkFunctionOrMethodDeclaration := func(node /* TODO(UnionType): FunctionDeclaration | MethodDeclaration | MethodSignature */ any) {
		checkDecorators(node)
		checkSignatureDeclaration(node)
		functionFlags := getFunctionFlags(node)
		if node.name && node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
		}
		if hasBindableName(node) {
			symbol := getSymbolOfDeclaration(node)
			localSymbol := node.localSymbol || symbol
			firstDeclaration := localSymbol.declarations.find(func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(BinaryExpression): declaration.kind === node.kind */
				/* TODO(AmpersandAmpersandToken): && */
				/* TODO(PrefixUnaryExpression): !(declaration.flags & NodeFlags.JavaScriptFile) */
			})
			if node == firstDeclaration {
				checkFunctionOrConstructorSymbol(localSymbol)
			}
			if symbol.parent {
				checkFunctionOrConstructorSymbol(symbol)
			}
		}
		body := /* TODO(ConditionalExpression): node.kind === SyntaxKind.MethodSignature ? undefined : node.body */ TODO
		checkSourceElement(body)
		checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node))
		addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics)
		if isInJSFile(node) {
			typeTag := getJSDocTypeTag(node)
			if typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node) {
				error(typeTag.typeExpression.type_, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature)
			}
		}
		checkFunctionOrMethodDeclarationDiagnostics := func() {
			if !getEffectiveReturnTypeNode(node) {
				if nodeIsMissing(body) && !isPrivateWithinAmbient(node) {
					reportImplicitAny(node, anyType)
				}
				if functionFlags&FunctionFlagsGenerator && nodeIsPresent(body) {
					getReturnTypeOfSignature(getSignatureFromDeclaration(node))
				}
			}
		}
	}
	registerForUnusedIdentifiersCheck := func(node PotentiallyUnusedIdentifier) {
		addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics)
		registerForUnusedIdentifiersCheckDiagnostics := func() {
			sourceFile := getSourceFileOfNode(node)
			potentiallyUnusedIdentifiers := allPotentiallyUnusedIdentifiers.get(sourceFile.path)
			if !potentiallyUnusedIdentifiers {
				potentiallyUnusedIdentifiers = /* TODO(ArrayLiteralExpression): [] */ TODO
				allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers)
			}
			potentiallyUnusedIdentifiers.push(node)
		}
	}
	type PotentiallyUnusedIdentifier /* TODO(UnionType): SourceFile | ModuleDeclaration | ClassLikeDeclaration | InterfaceDeclaration | Block | CaseBlock | ForStatement | ForInStatement | ForOfStatement | Exclude<SignatureDeclaration, IndexSignatureDeclaration | JSDocFunctionType> | TypeAliasDeclaration | InferTypeNode */ any
	checkUnusedIdentifiers := func(potentiallyUnusedIdentifiers []PotentiallyUnusedIdentifier, addDiagnostic AddUnusedDiagnostic) {
		for _, node := range potentiallyUnusedIdentifiers {
			/* TODO(SwitchStatement): switch (node.kind) {                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.ClassExpression:                     checkUnusedClassMembers(node, addDiagnostic);                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.SourceFile:                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.Block:                 case SyntaxKind.CaseBlock:                 case SyntaxKind.ForStatement:                 case SyntaxKind.ForInStatement:                 case SyntaxKind.ForOfStatement:                     checkUnusedLocalsAndParameters(node, addDiagnostic);                     break;                 case SyntaxKind.Constructor:                 case SyntaxKind.FunctionExpression:                 case SyntaxKind.FunctionDeclaration:                 case SyntaxKind.ArrowFunction:                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     // Only report unused parameters on the implementation, not overloads.                     if (node.body) {                         checkUnusedLocalsAndParameters(node, addDiagnostic);                     }                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.MethodSignature:                 case SyntaxKind.CallSignature:                 case SyntaxKind.ConstructSignature:                 case SyntaxKind.FunctionType:                 case SyntaxKind.ConstructorType:                 case SyntaxKind.TypeAliasDeclaration:                 case SyntaxKind.InterfaceDeclaration:                     checkUnusedTypeParameters(node, addDiagnostic);                     break;                 case SyntaxKind.InferType:                     checkUnusedInferTypeParameter(node, addDiagnostic);                     break;                 default:                     Debug.assertNever(node, "Node should not have been registered for unused identifiers check");             } */
		}
	}
	errorUnusedLocal := func(declaration Declaration, name string, addDiagnostic AddUnusedDiagnostic) {
		node := getNameOfDeclaration(declaration) || declaration
		message := /* TODO(ConditionalExpression): isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read */ TODO
		addDiagnostic(declaration, UnusedKindLocal, createDiagnosticForNode(node, message, name))
	}
	isIdentifierThatStartsWithUnderscore := func(node Node) /* TODO(undefined): boolean */ TODO {
		return isIdentifier(node) && idText(node).charCodeAt(0) == CharacterCodes_
	}
	checkUnusedClassMembers := func(node /* TODO(UnionType): ClassDeclaration | ClassExpression */ any, addDiagnostic AddUnusedDiagnostic) {
		for _, member := range node.members {
			/* TODO(SwitchStatement): switch (member.kind) {                 case SyntaxKind.MethodDeclaration:                 case SyntaxKind.PropertyDeclaration:                 case SyntaxKind.GetAccessor:                 case SyntaxKind.SetAccessor:                     if (member.kind === SyntaxKind.SetAccessor && member.symbol.flags & SymbolFlags.GetAccessor) {                         // Already would have reported an error on the getter.                         break;                     }                     const symbol = getSymbolOfDeclaration(member);                     if (                         !symbol.isReferenced                         && (hasEffectiveModifier(member, ModifierFlags.Private) || isNamedDeclaration(member) && isPrivateIdentifier(member.name))                         && !(member.flags & NodeFlags.Ambient)                     ) {                         addDiagnostic(member, UnusedKind.Local, createDiagnosticForNode(member.name!, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));                     }                     break;                 case SyntaxKind.Constructor:                     for (const parameter of (member as ConstructorDeclaration).parameters) {                         if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, ModifierFlags.Private)) {                             addDiagnostic(parameter, UnusedKind.Local, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)));                         }                     }                     break;                 case SyntaxKind.IndexSignature:                 case SyntaxKind.SemicolonClassElement:                 case SyntaxKind.ClassStaticBlockDeclaration:                     // Can't be private                     break;                 default:                     Debug.fail("Unexpected class member");             } */
		}
	}
	checkUnusedInferTypeParameter := func(node InferTypeNode, addDiagnostic AddUnusedDiagnostic) {
		TODO_IDENTIFIER := node
		if isTypeParameterUnused(typeParameter) {
			addDiagnostic(node, UnusedKindParameter, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)))
		}
	}
	checkUnusedTypeParameters := func(node /* TODO(UnionType): ClassLikeDeclaration | SignatureDeclaration | InterfaceDeclaration | TypeAliasDeclaration */ any, addDiagnostic AddUnusedDiagnostic) {
		declarations := getSymbolOfDeclaration(node).declarations
		if !declarations || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): last(declarations) !== node */ TODO {
		}
		typeParameters := getEffectiveTypeParameterDeclarations(node)
		seenParentsWithEveryUnused := /* TODO(NewExpression): new Set<DeclarationWithTypeParameterChildren>() */ TODO
		for _, typeParameter := range typeParameters {
			if !isTypeParameterUnused(typeParameter) {
			}
			name := idText(typeParameter.name)
			TODO_IDENTIFIER := typeParameter
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): parent.kind !== SyntaxKind.InferType */ TODO && /* TODO(NonNullExpression): parent.typeParameters! */ TODO.every(isTypeParameterUnused) {
				if tryAddToSet(seenParentsWithEveryUnused, parent) {
					sourceFile := getSourceFileOfNode(parent)
					range_ := /* TODO(ConditionalExpression): isJSDocTemplateTag(parent)                         // Whole @template tag                         ? rangeOfNode(parent)                         // Include the `<>` in the error message                         : rangeOfTypeParameters(sourceFile, parent.typeParameters!) */ TODO
					only := /* TODO(NonNullExpression): parent.typeParameters! */ TODO.length == 1
					var messageAndArg DiagnosticAndArguments = /* TODO(ConditionalExpression): only                         ? [Diagnostics._0_is_declared_but_its_value_is_never_read, name]                         : [Diagnostics.All_type_parameters_are_unused] */ TODO
					addDiagnostic(typeParameter, UnusedKindParameter, createFileDiagnostic(sourceFile, range_.pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): range.end - range.pos */, TODO /* TODO(SpreadElement): ...messageAndArg */, TODO))
				}
			} else {
				addDiagnostic(typeParameter, UnusedKindParameter, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name))
			}
		}
	}
	isTypeParameterUnused := func(typeParameter TypeParameterDeclaration) bool {
		return !( /* TODO(NonNullExpression): getMergedSymbol(typeParameter.symbol).isReferenced! */ TODO & SymbolFlagsTypeParameter) && !isIdentifierThatStartsWithUnderscore(typeParameter.name)
	}
	addToGroup := func(map_ Map[string /* TODO(TupleType): [K, V[]] */, TODO], key K, value V, getKey func(key K) /* TODO(UnionType): number | string */ any) {
		keyString := String(getKey(key))
		group := map_.get(keyString)
		if group {
			/* TODO(ElementAccessExpression): group[1] */ TODO.push(value)
		} else {
			map_.set(keyString /* TODO(ArrayLiteralExpression): [key, [value]] */, TODO)
		}
	}
	tryGetRootParameterDeclaration := func(node Node) *ParameterDeclaration {
		return tryCast(getRootDeclaration(node), isParameter)
	}
	isValidUnusedLocalDeclaration := func(declaration Declaration) bool {
		if isBindingElement(declaration) {
			if isObjectBindingPattern(declaration.parent) {
				return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name))
			}
			return isIdentifierThatStartsWithUnderscore(declaration.name)
		}
		return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore( /* TODO(NonNullExpression): declaration.name! */ TODO)
	}
	checkUnusedLocalsAndParameters := func(nodeWithLocals HasLocals, addDiagnostic AddUnusedDiagnostic) {
		unusedImports := /* TODO(NewExpression): new Map<string, [ImportClause, ImportedDeclaration[]]>() */ TODO
		unusedDestructures := /* TODO(NewExpression): new Map<string, [BindingPattern, BindingElement[]]>() */ TODO
		unusedVariables := /* TODO(NewExpression): new Map<string, [VariableDeclarationList, VariableDeclaration[]]>() */ TODO
		/* TODO(NonNullExpression): nodeWithLocals.locals! */ TODO.forEach(func(local /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
			if /* TODO(ConditionalExpression): local.flags & SymbolFlags.TypeParameter ? !(local.flags & SymbolFlags.Variable && !(local.isReferenced! & SymbolFlags.Variable)) : local.isReferenced || local.exportSymbol */ TODO {
				return
			}
			if local.declarations {
				for _, declaration := range local.declarations {
					if isValidUnusedLocalDeclaration(declaration) {
						/* TODO(ContinueStatement): continue; */
					}
					if isImportedDeclaration(declaration) {
						addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId)
					} else if isBindingElement(declaration) && isObjectBindingPattern(declaration.parent) {
						lastElement := last(declaration.parent.elements)
						if declaration == lastElement || !last(declaration.parent.elements).dotDotDotToken {
							addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
						}
					} else if isVariableDeclaration(declaration) {
						blockScopeKind := getCombinedNodeFlagsCached(declaration) & NodeFlagsBlockScoped
						name := getNameOfDeclaration(declaration)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): blockScopeKind !== NodeFlags.Using */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): blockScopeKind !== NodeFlags.AwaitUsing */ TODO || !name || !isIdentifierThatStartsWithUnderscore(name) {
							addToGroup(unusedVariables, declaration.parent, declaration, getNodeId)
						}
					} else {
						parameter := local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration)
						name := local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration)
						if parameter && name {
							if !isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name) {
								if isBindingElement(declaration) && isArrayBindingPattern(declaration.parent) {
									addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId)
								} else {
									addDiagnostic(parameter, UnusedKindParameter, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)))
								}
							}
						} else {
							errorUnusedLocal(declaration, symbolName(local), addDiagnostic)
						}
					}
				}
			}
		})
		unusedImports.forEach(func(TODO_IDENTIFIER /* TODO(undefined): [import("/home/jabaile/work/TypeScript/src/compiler/types").ImportClause, ImportedDeclaration[]] */ TODO) {
			importDecl := importClause.parent
			nDeclarations := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): (importClause.name ? 1 : 0) +                 (importClause.namedBindings ?                     (importClause.namedBindings.kind === SyntaxKind.NamespaceImport ? 1 : importClause.namedBindings.elements.length)                     : 0) */ TODO
			if nDeclarations == unuseds.length {
				addDiagnostic(importDecl, UnusedKindLocal /* TODO(ConditionalExpression): unuseds.length === 1                         ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name!))                         : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused) */, TODO)
			} else {
				for _, unused := range unuseds {
					/* TODO(CallExpression): errorUnusedLocal(unused, idText(unused.name!), addDiagnostic) */
				}
			}
		})
		unusedDestructures.forEach(func(TODO_IDENTIFIER /* TODO(undefined): [import("/home/jabaile/work/TypeScript/src/compiler/types").BindingPattern, import("/home/jabaile/work/TypeScript/src/compiler/types").BindingElement[]] */ TODO) {
			kind := /* TODO(ConditionalExpression): tryGetRootParameterDeclaration(bindingPattern.parent) ? UnusedKind.Parameter : UnusedKind.Local */ TODO
			if bindingPattern.elements.length == bindingElements.length {
				if bindingElements.length == 1 && bindingPattern.parent.kind == SyntaxKindVariableDeclaration && bindingPattern.parent.parent.kind == SyntaxKindVariableDeclarationList {
					addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId)
				} else {
					addDiagnostic(bindingPattern, kind /* TODO(ConditionalExpression): bindingElements.length === 1                             ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name))                             : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused) */, TODO)
				}
			} else {
				for _, e := range bindingElements {
					addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)))
				}
			}
		})
		unusedVariables.forEach(func(TODO_IDENTIFIER /* TODO(undefined): [import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclarationList, import("/home/jabaile/work/TypeScript/src/compiler/types").VariableDeclaration[]] */ TODO) {
			if declarationList.declarations.length == declarations.length {
				addDiagnostic(declarationList, UnusedKindLocal /* TODO(ConditionalExpression): declarations.length === 1                         ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name))                         : createDiagnosticForNode(declarationList.parent.kind === SyntaxKind.VariableStatement ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused) */, TODO)
			} else {
				for _, decl := range declarations {
					addDiagnostic(decl, UnusedKindLocal, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)))
				}
			}
		})
	}
	checkPotentialUncheckedRenamedBindingElementsInTypes := func() {
		for _, node := range potentialUnusedRenamedBindingElementsInTypes {
			if !getSymbolOfDeclaration(node).isReferenced {
				wrappingDeclaration := walkUpBindingElementsAndPatterns(node)
				Debug.assert(isPartOfParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here")
				diagnostic := createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName))
				if !wrappingDeclaration.type_ {
					addRelatedInfo(diagnostic, createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 0, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	bindingNameText := func(name BindingName) string {
		/* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.Identifier:                 return idText(name);             case SyntaxKind.ArrayBindingPattern:             case SyntaxKind.ObjectBindingPattern:                 return bindingNameText(cast(first(name.elements), isBindingElement).name);             default:                 return Debug.assertNever(name);         } */
	}
	type ImportedDeclaration /* TODO(UnionType): ImportClause | ImportSpecifier | NamespaceImport */ any
	isImportedDeclaration := func(node Node) /* TODO(TypePredicate): node is ImportedDeclaration */ TODO {
		return node.kind == SyntaxKindImportClause || node.kind == SyntaxKindImportSpecifier || node.kind == SyntaxKindNamespaceImport
	}
	importClauseFromImported := func(decl ImportedDeclaration) ImportClause {
		return /* TODO(ConditionalExpression): decl.kind === SyntaxKind.ImportClause ? decl : decl.kind === SyntaxKind.NamespaceImport ? decl.parent : decl.parent.parent */ TODO
	}
	checkBlock := func(node Block) {
		if node.kind == SyntaxKindBlock {
			checkGrammarStatementInAmbientContext(node)
		}
		if isFunctionOrModuleBlock(node) {
			saveFlowAnalysisDisabled := flowAnalysisDisabled
			forEach(node.statements, checkSourceElement)
			flowAnalysisDisabled = saveFlowAnalysisDisabled
		} else {
			forEach(node.statements, checkSourceElement)
		}
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkCollisionWithArgumentsInGeneratedCode := func(node SignatureDeclaration) {
		if languageVersion >= ScriptTargetES2015 || !hasRestParameter(node) || node.flags&NodeFlagsAmbient || nodeIsMissing((node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body) {
			return
		}
		forEach(node.parameters, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) {
			if p.name && !isBindingPattern(p.name) && p.name.escapedText == argumentsSymbol.escapedName {
				errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters)
			}
		})
	}
	needCollisionCheckForIdentifier := func(node Node, identifier *Identifier, name string) bool {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): identifier?.escapedText !== name */ TODO {
			return false
		}
		if node.kind == SyntaxKindPropertyDeclaration || node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodDeclaration || node.kind == SyntaxKindMethodSignature || node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor || node.kind == SyntaxKindPropertyAssignment {
			return false
		}
		if node.flags & NodeFlagsAmbient {
			return false
		}
		if isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node) {
			if isTypeOnlyImportOrExportDeclaration(node) {
				return false
			}
		}
		root := getRootDeclaration(node)
		if isParameter(root) && nodeIsMissing((root.parent /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body) {
			return false
		}
		return true
	}
	checkIfThisIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureThis {
				isDeclaration := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.Identifier */ TODO
				if isDeclaration {
					error(getNameOfDeclaration(node /* as */ /* TODO(TypeReference): Declaration */), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference)
				}
				return true
			}
			return false
		})
	}
	checkIfNewTargetIsCapturedInEnclosingScope := func(node Node) {
		findAncestor(node, func(current /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
			if getNodeCheckFlags(current) & NodeCheckFlagsCaptureNewTarget {
				isDeclaration := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.Identifier */ TODO
				if isDeclaration {
					error(getNameOfDeclaration(node /* as */ /* TODO(TypeReference): Declaration */), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference)
				} else {
					error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference)
				}
				return true
			}
			return false
		})
	}
	checkCollisionWithRequireExportsInGeneratedCode := func(node Node, name *Identifier) {
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) >= ModuleKindES2015 {
			return
		}
		if !name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports") {
			return
		}
		if isModuleDeclaration(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getModuleInstanceState(node) !== ModuleInstanceState.Instantiated */ TODO {
			return
		}
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent /* as */ /* TODO(TypeReference): SourceFile */) {
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name))
		}
	}
	checkCollisionWithGlobalPromiseInGeneratedCode := func(node Node, name *Identifier) {
		if !name || languageVersion >= ScriptTargetES2017 || !needCollisionCheckForIdentifier(node, name, "Promise") {
			return
		}
		if isModuleDeclaration(node) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getModuleInstanceState(node) !== ModuleInstanceState.Instantiated */ TODO {
			return
		}
		parent := getDeclarationContainer(node)
		if parent.kind == SyntaxKindSourceFile && isExternalOrCommonJsModule(parent /* as */ /* TODO(TypeReference): SourceFile */) && parent.flags&NodeFlagsHasAsyncFunctions {
			errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name))
		}
	}
	recordPotentialCollisionWithWeakMapSetInGeneratedCode := func(node Node, name Identifier) {
		if languageVersion <= ScriptTargetES2021 && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet")) {
			potentialWeakMapSetCollisions.push(node)
		}
	}
	checkWeakMapSetCollision := func(node Node) {
		enclosingBlockScope := getEnclosingBlockScopeContainer(node)
		if getNodeCheckFlags(enclosingBlockScope) & NodeCheckFlagsContainsClassWithPrivateIdentifiers {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && /* TODO(TypeOfExpression): typeof node.name.escapedText */ TODO == "string", "The target of a WeakMap/WeakSet collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText)
		}
	}
	recordPotentialCollisionWithReflectInGeneratedCode := func(node Node, name *Identifier) {
		if name && languageVersion >= ScriptTargetES2015 && languageVersion <= ScriptTargetES2021 && needCollisionCheckForIdentifier(node, name, "Reflect") {
			potentialReflectCollisions.push(node)
		}
	}
	checkReflectCollision := func(node Node) {
		hasCollision := false
		if isClassExpression(node) {
			for _, member := range node.members {
				if getNodeCheckFlags(member) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
					hasCollision = true
					/* TODO(BreakStatement): break; */
				}
			}
		} else if isFunctionExpression(node) {
			if getNodeCheckFlags(node) & NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		} else {
			container := getEnclosingBlockScopeContainer(node)
			if container && getNodeCheckFlags(container)&NodeCheckFlagsContainsSuperPropertyInStaticInitializer {
				hasCollision = true
			}
		}
		if hasCollision {
			Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier")
			errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect")
		}
	}
	checkCollisionsForDeclarationName := func(node Node, name *Identifier) {
		if !name {
		}
		checkCollisionWithRequireExportsInGeneratedCode(node, name)
		checkCollisionWithGlobalPromiseInGeneratedCode(node, name)
		recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name)
		recordPotentialCollisionWithReflectInGeneratedCode(node, name)
		if isClassLike(node) {
			checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0)
			if !(node.flags & NodeFlagsAmbient) {
				checkClassNameCollisionWithObject(name)
			}
		} else if isEnumDeclaration(node) {
			checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0)
		}
	}
	checkVarDeclaredNamesNotShadowed := func(node /* TODO(UnionType): VariableDeclaration | BindingElement */ any) /* TODO(undefined): undefined */ TODO {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (getCombinedNodeFlagsCached(node) & NodeFlags.BlockScoped) !== 0 */ TODO || isPartOfParameterDeclaration(node) {
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags & SymbolFlagsFunctionScopedVariable {
			if !isIdentifier(node.name) {
				/* TODO(CallExpression): Debug.fail() */
			}
			localDeclarationSymbol := resolveName(node, node.name.escapedText, SymbolFlagsVariable, nil, false)
			if localDeclarationSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): localDeclarationSymbol !== symbol */ TODO && localDeclarationSymbol.flags&SymbolFlagsBlockScopedVariable {
				if getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & NodeFlagsBlockScoped {
					varDeclList := /* TODO(NonNullExpression): getAncestor(localDeclarationSymbol.valueDeclaration, SyntaxKind.VariableDeclarationList)! */ TODO
					container := /* TODO(ConditionalExpression): varDeclList.parent.kind === SyntaxKind.VariableStatement && varDeclList.parent.parent                         ? varDeclList.parent.parent                         : undefined */ TODO
					namesShareScope := container && (container.kind == SyntaxKindBlock && isFunctionLike(container.parent) || container.kind == SyntaxKindModuleBlock || container.kind == SyntaxKindModuleDeclaration || container.kind == SyntaxKindSourceFile)
					if !namesShareScope {
						name := symbolToString(localDeclarationSymbol)
						error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name)
					}
				}
			}
		}
	}
	convertAutoToAny := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return /* TODO(ConditionalExpression): type === autoType ? anyType : type === autoArrayType ? anyArrayType : type */ TODO
	}
	checkVariableLikeDeclaration := func(node /* TODO(UnionType): ParameterDeclaration | PropertyDeclaration | PropertySignature | VariableDeclaration | BindingElement */ any) {
		checkDecorators(node)
		if !isBindingElement(node) {
			checkSourceElement(node.type_)
		}
		if !node.name {
			return
		}
		if node.name.kind == SyntaxKindComputedPropertyName {
			checkComputedPropertyName(node.name)
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkExpressionCached(node.initializer)
			}
		}
		if isBindingElement(node) {
			if node.propertyName && isIdentifier(node.name) && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body) {
				potentialUnusedRenamedBindingElementsInTypes.push(node)
				return
			}
			if isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < LanguageFeatureMinimumTargetObjectSpreadRest {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRest)
			}
			if node.propertyName && node.propertyName.kind == SyntaxKindComputedPropertyName {
				checkComputedPropertyName(node.propertyName)
			}
			parent := node.parent.parent
			parentCheckMode := /* TODO(ConditionalExpression): node.dotDotDotToken ? CheckMode.RestBindingElement : CheckMode.Normal */ TODO
			parentType := getTypeForBindingElementParent(parent, parentCheckMode)
			name := node.propertyName || node.name
			if parentType && !isBindingPattern(name) {
				exprType := getLiteralTypeFromPropertyName(name)
				if isTypeUsableAsPropertyName(exprType) {
					nameText := getPropertyNameFromType(exprType)
					property := getPropertyOfType(parentType, nameText)
					if property {
						markPropertyAsReferenced(property, nil, false)
						checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind == SyntaxKindSuperKeyword, false, parentType, property)
					}
				}
			}
		}
		if isBindingPattern(node.name) {
			if node.name.kind == SyntaxKindArrayBindingPattern && languageVersion < LanguageFeatureMinimumTargetBindingPatterns && compilerOptions.downlevelIteration {
				checkExternalEmitHelpers(node, ExternalEmitHelpersRead)
			}
			forEach(node.name.elements, checkSourceElement)
		}
		if node.initializer && isPartOfParameterDeclaration(node) && nodeIsMissing((getContainingFunction(node) /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body) {
			error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation)
			return
		}
		if isBindingPattern(node.name) {
			if isInAmbientOrTypeNode(node) {
				return
			}
			needCheckInitializer := hasOnlyExpressionInitializer(node) && node.initializer && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO
			needCheckWidenedType := !some(node.name.elements, not(isOmittedExpression))
			if needCheckInitializer || needCheckWidenedType {
				widenedType := getWidenedTypeForVariableLikeDeclaration(node)
				if needCheckInitializer {
					initializerType := checkExpressionCached(node.initializer)
					if strictNullChecks && needCheckWidenedType {
						checkNonNullNonVoidType(initializerType, node)
					} else {
						checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer)
					}
				}
				if needCheckWidenedType {
					if isArrayBindingPattern(node.name) {
						checkIteratedTypeOrElementType(IterationUseDestructuring, widenedType, undefinedType, node)
					} else if strictNullChecks {
						checkNonNullNonVoidType(widenedType, node)
					}
				}
			}
			return
		}
		symbol := getSymbolOfDeclaration(node)
		if symbol.flags&SymbolFlagsAlias && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node)) {
			checkAliasSymbol(node)
			return
		}
		if node.name.kind == SyntaxKindBigIntLiteral {
			error(node.name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name)
		}
		type_ := convertAutoToAny(getTypeOfSymbol(symbol))
		if node == symbol.valueDeclaration {
			initializer := hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node)
			if initializer {
				isJSObjectLiteralInitializer := isInJSFile(node) && isObjectLiteralExpression(initializer) && (initializer.properties.length == 0 || isPrototypeAccess(node.name)) && !!symbol.exports.size
				if !isJSObjectLiteralInitializer && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO {
					initializerType := checkExpressionCached(initializer)
					checkTypeAssignableToAndOptionallyElaborate(initializerType, type_, node, initializer, nil)
					blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
					if blockScopeKind == NodeFlagsAwaitUsing {
						globalAsyncDisposableType := getGlobalAsyncDisposableType(true)
						globalDisposableType := getGlobalDisposableType(true)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalAsyncDisposableType !== emptyObjectType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalDisposableType !== emptyObjectType */ TODO {
							optionalDisposableType := getUnionType( /* TODO(ArrayLiteralExpression): [globalAsyncDisposableType, globalDisposableType, nullType, undefinedType] */ TODO)
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined)
						}
					} else if blockScopeKind == NodeFlagsUsing {
						globalDisposableType := getGlobalDisposableType(true)
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): globalDisposableType !== emptyObjectType */ TODO {
							optionalDisposableType := getUnionType( /* TODO(ArrayLiteralExpression): [globalDisposableType, nullType, undefinedType] */ TODO)
							checkTypeAssignableTo(widenTypeForVariableLikeDeclaration(initializerType, node), optionalDisposableType, initializer, Diagnostics.The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined)
						}
					}
				}
			}
			if symbol.declarations && symbol.declarations.length > 1 {
				if some(symbol.declarations, func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(BinaryExpression): d !== node && isVariableLike(d) */
					/* TODO(AmpersandAmpersandToken): && */
					/* TODO(PrefixUnaryExpression): !areDeclarationFlagsIdentical(d, node) */
				}) {
					error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
				}
			}
		} else {
			declarationType := convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node))
			if !isErrorType(type_) && !isErrorType(declarationType) && !isTypeIdenticalTo(type_, declarationType) && !(symbol.flags & SymbolFlagsAssignment) {
				errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type_, node, declarationType)
			}
			if hasOnlyExpressionInitializer(node) && node.initializer {
				checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, nil)
			}
			if symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration) {
				error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name))
			}
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.PropertyDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.PropertySignature */ TODO {
			checkExportsOnMergedDeclarations(node)
			if node.kind == SyntaxKindVariableDeclaration || node.kind == SyntaxKindBindingElement {
				checkVarDeclaredNamesNotShadowed(node)
			}
			checkCollisionsForDeclarationName(node, node.name)
		}
	}
	errorNextVariableOrPropertyDeclarationMustHaveSameType := func(firstDeclaration Declaration, firstType Type, nextDeclaration Declaration, nextType Type) {
		nextDeclarationName := getNameOfDeclaration(nextDeclaration)
		message := /* TODO(ConditionalExpression): nextDeclaration.kind === SyntaxKind.PropertyDeclaration || nextDeclaration.kind === SyntaxKind.PropertySignature             ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2             : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 */ TODO
		declName := declarationNameToString(nextDeclarationName)
		err := error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType))
		if firstDeclaration {
			addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName))
		}
	}
	areDeclarationFlagsIdentical := func(left Declaration, right Declaration) /* TODO(undefined): boolean */ TODO {
		if (left.kind == SyntaxKindParameter && right.kind == SyntaxKindVariableDeclaration) || (left.kind == SyntaxKindVariableDeclaration && right.kind == SyntaxKindParameter) {
			return true
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): hasQuestionToken(left) !== hasQuestionToken(right) */ TODO {
			return false
		}
		interestingFlags := ModifierFlagsPrivate | ModifierFlagsProtected | ModifierFlagsAsync | ModifierFlagsAbstract | ModifierFlagsReadonly | ModifierFlagsStatic
		return getSelectedEffectiveModifierFlags(left, interestingFlags) == getSelectedEffectiveModifierFlags(right, interestingFlags)
	}
	checkVariableDeclaration := func(node VariableDeclaration) {
		tracing.push(tracing.Phase.Check, "checkVariableDeclaration" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		checkGrammarVariableDeclaration(node)
		checkVariableLikeDeclaration(node)
		tracing.pop()
	}
	checkBindingElement := func(node BindingElement) {
		checkGrammarBindingElement(node)
		return checkVariableLikeDeclaration(node)
	}
	checkVariableDeclarationList := func(node VariableDeclarationList) {
		blockScopeKind := getCombinedNodeFlags(node) & NodeFlagsBlockScoped
		if (blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing) && languageVersion < LanguageFeatureMinimumTargetUsingAndAwaitUsing {
			checkExternalEmitHelpers(node, ExternalEmitHelpersAddDisposableResourceAndDisposeResources)
		}
		forEach(node.declarations, checkSourceElement)
	}
	checkVariableStatement := func(node VariableStatement) {
		if !checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList) {
			/* TODO(CallExpression): checkGrammarForDisallowedBlockScopedVariableStatement(node) */
		}
		checkVariableDeclarationList(node.declarationList)
	}
	checkExpressionStatement := func(node ExpressionStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkExpression(node.expression)
	}
	checkIfStatement := func(node IfStatement) {
		checkGrammarStatementInAmbientContext(node)
		type_ := checkTruthinessExpression(node.expression)
		checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType(node.expression, type_, node.thenStatement)
		checkSourceElement(node.thenStatement)
		if node.thenStatement.kind == SyntaxKindEmptyStatement {
			error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement)
		}
		checkSourceElement(node.elseStatement)
	}
	checkTestingKnownTruthyCallableOrAwaitableOrEnumMemberType := func(condExpr Expression, condType Type, body /* TODO(UnionType): Statement | Expression */ any) {
		if !strictNullChecks {
		}
		bothHelper(condExpr, body)
		bothHelper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
			condExpr = skipParentheses(condExpr)
			helper(condExpr, body)
			/* TODO(WhileStatement): while (isBinaryExpression(condExpr) && (condExpr.operatorToken.kind === SyntaxKind.BarBarToken || condExpr.operatorToken.kind === SyntaxKind.QuestionQuestionToken)) {                 condExpr = skipParentheses(condExpr.left);                 helper(condExpr, body);             } */
		}
		helper := func(condExpr Expression, body /* TODO(UnionType): Expression | Statement | undefined */ any) {
			location := /* TODO(ConditionalExpression): isLogicalOrCoalescingBinaryExpression(condExpr) ? skipParentheses(condExpr.right) : condExpr */ TODO
			if isModuleExportsAccessExpression(location) {
				return
			}
			if isLogicalOrCoalescingBinaryExpression(location) {
				bothHelper(location, body)
				return
			}
			type_ := /* TODO(ConditionalExpression): location === condExpr ? condType : checkExpression(location) */ TODO
			if type_.flags&TypeFlagsEnumLiteral && isPropertyAccessExpression(location) && ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getNodeLinks(location.expression).resolvedSymbol ?? unknownSymbol */ TODO).flags&SymbolFlagsEnum {
				error(location, Diagnostics.This_condition_will_always_return_0 /* TODO(ConditionalExpression): !!(type as LiteralType).value ? "true" : "false" */, TODO)
				return
			}
			isPropertyExpressionCast := isPropertyAccessExpression(location) && isTypeAssertion(location.expression)
			if !hasTypeFacts(type_, TypeFactsTruthy) || isPropertyExpressionCast {
			}
			callSignatures := getSignaturesOfType(type_, SignatureKindCall)
			isPromise := !!getAwaitedTypeOfPromise(type_)
			if callSignatures.length == 0 && !isPromise {
				return
			}
			testedNode := /* TODO(ConditionalExpression): isIdentifier(location) ? location                 : isPropertyAccessExpression(location) ? location.name                 : undefined */ TODO
			testedSymbol := testedNode && getSymbolAtLocation(testedNode)
			if !testedSymbol && !isPromise {
				return
			}
			isUsed := testedSymbol && isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol) || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol)
			if !isUsed {
				if isPromise {
					errorAndMaybeSuggestAwait(location, true, Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, getTypeNameForErrorDisplay(type_))
				} else {
					error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead)
				}
			}
		}
	}
	isSymbolUsedInConditionBody := func(expr Expression, body /* TODO(UnionType): Statement | Expression */ any, testedNode Node, testedSymbol Symbol) bool {
		return !!forEachChild(body /* TODO(FunctionExpression): function check(childNode): boolean | undefined {             if (isIdentifier(childNode)) {                 const childSymbol = getSymbolAtLocation(childNode);                 if (childSymbol && childSymbol === testedSymbol) {                     // If the test was a simple identifier, the above check is sufficient                     if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {                         return true;                     }                     // Otherwise we need to ensure the symbol is called on the same target                     let testedExpression = testedNode.parent;                     let childExpression = childNode.parent;                     while (testedExpression && childExpression) {                         if (                             isIdentifier(testedExpression) && isIdentifier(childExpression) ||                             testedExpression.kind === SyntaxKind.ThisKeyword && childExpression.kind === SyntaxKind.ThisKeyword                         ) {                             return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);                         }                         else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {                             if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {                                 return false;                             }                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {                             childExpression = childExpression.expression;                             testedExpression = testedExpression.expression;                         }                         else {                             return false;                         }                     }                 }             }             return forEachChild(childNode, check);         } */, TODO)
	}
	isSymbolUsedInBinaryExpressionChain := func(node Node, testedSymbol Symbol) bool {
		/* TODO(WhileStatement): while (isBinaryExpression(node) && node.operatorToken.kind === SyntaxKind.AmpersandAmpersandToken) {             const isUsed = forEachChild(node.right, function visit(child): boolean | undefined {                 if (isIdentifier(child)) {                     const symbol = getSymbolAtLocation(child);                     if (symbol && symbol === testedSymbol) {                         return true;                     }                 }                 return forEachChild(child, visit);             });             if (isUsed) {                 return true;             }             node = node.parent;         } */
		return false
	}
	checkDoStatement := func(node DoStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkSourceElement(node.statement)
		checkTruthinessExpression(node.expression)
	}
	checkWhileStatement := func(node WhileStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkTruthinessExpression(node.expression)
		checkSourceElement(node.statement)
	}
	checkTruthinessOfType := func(type_ Type, node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if type_.flags & TypeFlagsVoid {
			error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness)
		} else {
			semantics := getSyntacticTruthySemantics(node)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): semantics !== PredicateSemantics.Sometimes */ TODO {
				error(node /* TODO(ConditionalExpression): semantics === PredicateSemantics.Always ?                         Diagnostics.This_kind_of_expression_is_always_truthy :                         Diagnostics.This_kind_of_expression_is_always_falsy */, TODO)
			}
		}
		return type_
	}
	getSyntacticTruthySemantics := func(node Node) PredicateSemantics {
		node = skipOuterExpressions(node)
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.NumericLiteral:                 // Allow `while(0)` or `while(1)`                 if ((node as NumericLiteral).text === "0" || (node as NumericLiteral).text === "1") {                     return PredicateSemantics.Sometimes;                 }                 return PredicateSemantics.Always;             case SyntaxKind.ArrayLiteralExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.BigIntLiteral:             case SyntaxKind.ClassExpression:             case SyntaxKind.FunctionExpression:             case SyntaxKind.JsxElement:             case SyntaxKind.JsxSelfClosingElement:             case SyntaxKind.ObjectLiteralExpression:             case SyntaxKind.RegularExpressionLiteral:                 return PredicateSemantics.Always;             case SyntaxKind.VoidExpression:             case SyntaxKind.NullKeyword:                 return PredicateSemantics.Never;             case SyntaxKind.NoSubstitutionTemplateLiteral:             case SyntaxKind.StringLiteral:                 return !!(node as StringLiteral | NoSubstitutionTemplateLiteral).text ? PredicateSemantics.Always : PredicateSemantics.Never;             case SyntaxKind.ConditionalExpression:                 return getSyntacticTruthySemantics((node as ConditionalExpression).whenTrue) | getSyntacticTruthySemantics((node as ConditionalExpression).whenFalse);             case SyntaxKind.Identifier:                 if (getResolvedSymbol(node as Identifier) === undefinedSymbol) {                     return PredicateSemantics.Never;                 }                 return PredicateSemantics.Sometimes;         } */
		return PredicateSemanticsSometimes
	}
	checkTruthinessExpression := func(node Expression, checkMode CheckMode) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return checkTruthinessOfType(checkExpression(node, checkMode), node)
	}
	checkForStatement := func(node ForStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if node.initializer && node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkGrammarVariableDeclarationList(node.initializer /* as */ /* TODO(TypeReference): VariableDeclarationList */)
			}
		}
		if node.initializer {
			if node.initializer.kind == SyntaxKindVariableDeclarationList {
				checkVariableDeclarationList(node.initializer /* as */ /* TODO(TypeReference): VariableDeclarationList */)
			} else {
				checkExpression(node.initializer)
			}
		}
		if node.condition {
			/* TODO(CallExpression): checkTruthinessExpression(node.condition) */
		}
		if node.incrementor {
			/* TODO(CallExpression): checkExpression(node.incrementor) */
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForOfStatement := func(node ForOfStatement) {
		checkGrammarForInOrForOfStatement(node)
		container := getContainingFunctionOrClassStaticBlock(node)
		if node.awaitModifier {
			if container && isClassStaticBlockDeclaration(container) {
				grammarErrorOnNode(node.awaitModifier, Diagnostics.for_await_loops_cannot_be_used_inside_a_class_static_block)
			} else {
				functionFlags := getFunctionFlags(container)
				if (functionFlags&(FunctionFlagsInvalid|FunctionFlagsAsync)) == FunctionFlagsAsync && languageVersion < LanguageFeatureMinimumTargetForAwaitOf {
					checkExternalEmitHelpers(node, ExternalEmitHelpersForAwaitOfIncludes)
				}
			}
		} else if compilerOptions.downlevelIteration && languageVersion < LanguageFeatureMinimumTargetForOf {
			checkExternalEmitHelpers(node, ExternalEmitHelpersForOfIncludes)
		}
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			checkVariableDeclarationList(node.initializer /* as */ /* TODO(TypeReference): VariableDeclarationList */)
		} else {
			varExpr := node.initializer
			iteratedType := checkRightHandSideOfForOf(node)
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				checkDestructuringAssignment(varExpr, iteratedType || errorType)
			} else {
				leftType := checkExpression(varExpr)
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access)
				if iteratedType {
					checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression)
				}
			}
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkForInStatement := func(node ForInStatement) {
		checkGrammarForInOrForOfStatement(node)
		rightType := getNonNullableTypeIfNeeded(checkExpression(node.expression))
		if node.initializer.kind == SyntaxKindVariableDeclarationList {
			variable := /* TODO(ElementAccessExpression): (node.initializer as VariableDeclarationList).declarations[0] */ TODO
			if variable && isBindingPattern(variable.name) {
				error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			}
			checkVariableDeclarationList(node.initializer /* as */ /* TODO(TypeReference): VariableDeclarationList */)
		} else {
			varExpr := node.initializer
			leftType := checkExpression(varExpr)
			if varExpr.kind == SyntaxKindArrayLiteralExpression || varExpr.kind == SyntaxKindObjectLiteralExpression {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern)
			} else if !isTypeAssignableTo(getIndexTypeOrString(rightType), leftType) {
				error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any)
			} else {
				checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access)
			}
		}
		if rightType == neverType || !isTypeAssignableToKind(rightType, TypeFlagsNonPrimitive|TypeFlagsInstantiableNonPrimitive) {
			error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType))
		}
		checkSourceElement(node.statement)
		if node.locals {
			registerForUnusedIdentifiersCheck(node)
		}
	}
	checkRightHandSideOfForOf := func(statement ForOfStatement) Type {
		use := /* TODO(ConditionalExpression): statement.awaitModifier ? IterationUse.ForAwaitOf : IterationUse.ForOf */ TODO
		return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression)
	}
	checkIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node) Type {
		if isTypeAny(inputType) {
			return inputType
		}
		return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, true) || anyType
	}
	getIteratedTypeOrElementType := func(use IterationUse, inputType Type, sentType Type, errorNode Node, checkAssignability bool) *Type {
		allowAsyncIterables := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (use & IterationUse.AllowsAsyncIterablesFlag) !== 0 */ TODO
		if inputType == neverType {
			if errorNode {
				reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables)
			}
			return nil
		}
		uplevelIteration := languageVersion >= ScriptTargetES2015
		downlevelIteration := !uplevelIteration && compilerOptions.downlevelIteration
		possibleOutOfBounds := compilerOptions.noUncheckedIndexedAccess && !!(use & IterationUsePossiblyOutOfBounds)
		if uplevelIteration || downlevelIteration || allowAsyncIterables {
			iterationTypes := getIterationTypesOfIterable(inputType, use /* TODO(ConditionalExpression): uplevelIteration ? errorNode : undefined */, TODO)
			if checkAssignability {
				if iterationTypes {
					diagnostic := /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :                         use & IterationUse.SpreadFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :                         use & IterationUse.DestructuringFlag ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :                         use & IterationUse.YieldStarFlag ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :                         undefined */ TODO
					if diagnostic {
						checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic)
					}
				}
			}
			if iterationTypes || uplevelIteration {
				return /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType) */ TODO
			}
		}
		arrayType := inputType
		hasStringConstituent := false
		if use & IterationUseAllowsStringInputFlag {
			if arrayType.flags & TypeFlagsUnion {
				arrayTypes := (inputType /* as */ /* TODO(TypeReference): UnionType */).types
				filteredTypes := filter(arrayTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
					/* TODO(ParenthesizedExpression): (t.flags & TypeFlags.StringLike) */
				})
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): filteredTypes !== arrayTypes */ TODO {
					arrayType = getUnionType(filteredTypes, UnionReductionSubtype)
				}
			} else if arrayType.flags & TypeFlagsStringLike {
				arrayType = neverType
			}
			hasStringConstituent = /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): arrayType !== inputType */ TODO
			if hasStringConstituent {
				if arrayType.flags & TypeFlagsNever {
					return /* TODO(ConditionalExpression): possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType */ TODO
				}
			}
		}
		if !isArrayLikeType(arrayType) {
			if errorNode {
				allowsStrings := !!(use & IterationUseAllowsStringInputFlag) && !hasStringConstituent
				TODO_IDENTIFIER := getIterationDiagnosticDetails(allowsStrings, downlevelIteration)
				errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType))
			}
			return /* TODO(ConditionalExpression): hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined */ TODO
		}
		arrayElementType := getIndexTypeOfType(arrayType, numberType)
		if hasStringConstituent && arrayElementType {
			if arrayElementType.flags&TypeFlagsStringLike && !compilerOptions.noUncheckedIndexedAccess {
				return stringType
			}
			return getUnionType( /* TODO(ConditionalExpression): possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType] */ TODO, UnionReductionSubtype)
		}
		return /* TODO(ConditionalExpression): (use & IterationUse.PossiblyOutOfBounds) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType */ TODO
		getIterationDiagnosticDetails := func(allowsStrings bool, downlevelIteration /* TODO(BooleanKeyword): boolean */ any) /* TODO(TupleType): [error: DiagnosticMessage, maybeMissingAwait: boolean] */ TODO {
			if downlevelIteration {
				return /* TODO(ConditionalExpression): allowsStrings                     ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]                     : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true] */ TODO
			}
			yieldType := getIterationTypeOfIterable(use, IterationTypeKindYield, inputType, nil)
			if yieldType {
				return /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false] */ TODO
			}
			if isES2015OrLaterIterable(inputType.symbol.escapedName) {
				return /* TODO(ArrayLiteralExpression): [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true] */ TODO
			}
			return /* TODO(ConditionalExpression): allowsStrings                 ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]                 : [Diagnostics.Type_0_is_not_an_array_type, true] */ TODO
		}
	}
	isES2015OrLaterIterable := func(n __String) /* TODO(undefined): boolean */ TODO {
		/* TODO(SwitchStatement): switch (n) {             case "Float32Array":             case "Float64Array":             case "Int16Array":             case "Int32Array":             case "Int8Array":             case "NodeList":             case "Uint16Array":             case "Uint32Array":             case "Uint8Array":             case "Uint8ClampedArray":                 return true;         } */
		return false
	}
	getIterationTypeOfIterable := func(use IterationUse, typeKind IterationTypeKind, inputType Type, errorNode Node) *Type {
		if isTypeAny(inputType) {
			return nil
		}
		iterationTypes := getIterationTypesOfIterable(inputType, use, errorNode)
		return iterationTypes && /* TODO(ElementAccessExpression): iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)] */ TODO
	}
	createIterationTypes := func(yieldType Type /* = */ /* TODO(Identifier): neverType */, returnType Type /* = */ /* TODO(Identifier): neverType */, nextType Type /* = */ /* TODO(Identifier): unknownType */) IterationTypes {
		if yieldType.flags&TypeFlagsIntrinsic && returnType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) && nextType.flags&(TypeFlagsAny|TypeFlagsNever|TypeFlagsUnknown|TypeFlagsVoid|TypeFlagsUndefined) {
			id := getTypeListId( /* TODO(ArrayLiteralExpression): [yieldType, returnType, nextType] */ TODO)
			iterationTypes := iterationTypesCache.get(id)
			if !iterationTypes {
				iterationTypes = /* TODO(ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
				iterationTypesCache.set(id, iterationTypes)
			}
			return iterationTypes
		}
		return /* TODO(ObjectLiteralExpression): { yieldType, returnType, nextType } */ TODO
	}
	combineIterationTypes := func(array []*IterationTypes) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		var yieldTypes /* TODO(ArrayType): Type[] */ any
		var returnTypes /* TODO(ArrayType): Type[] */ any
		var nextTypes /* TODO(ArrayType): Type[] */ any
		for _, iterationTypes := range array {
			if iterationTypes == nil || iterationTypes == noIterationTypes {
				/* TODO(ContinueStatement): continue; */
			}
			if iterationTypes == anyIterationTypes {
				return anyIterationTypes
			}
			yieldTypes = append(yieldTypes, iterationTypes.yieldType)
			returnTypes = append(returnTypes, iterationTypes.returnType)
			nextTypes = append(nextTypes, iterationTypes.nextType)
		}
		if yieldTypes || returnTypes || nextTypes {
			return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes))
		}
		return noIterationTypes
	}
	getCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes]) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return /* TODO(ElementAccessExpression): (type as IterableOrIteratorType)[cacheKey] */ TODO
	}
	setCachedIterationTypes := func(type_ Type, cacheKey MatchingKeys[IterableOrIteratorType, *IterationTypes], cachedTypes IterationTypes) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): (type as IterableOrIteratorType)[cacheKey] = cachedTypes */ TODO
	}
	getIterationTypesOfIterable := func(type_ Type, use IterationUse, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		if !(type_.flags & TypeFlagsUnion) {
			var errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(type_, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer.errors {
						addRelatedInfo(rootDiag /* TODO(SpreadElement): ...errorOutputContainer.errors */, TODO)
					}
				}
				return nil
			} else if errorOutputContainer.errors.length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			return iterationTypes
		}
		cacheKey := /* TODO(ConditionalExpression): use & IterationUse.AllowsAsyncIterablesFlag ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable" */ TODO
		cachedTypes := getCachedIterationTypes(type_, cacheKey)
		if cachedTypes {
			/* TODO(ConditionalExpression): cachedTypes === noIterationTypes ? undefined : cachedTypes */
		}
		var allIterationTypes /* TODO(ArrayType): IterationTypes[] */ any
		for _, constituent := range (type_ /* as */ /* TODO(TypeReference): UnionType */).types {
			var errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any = /* TODO(ConditionalExpression): errorNode ? { errors: undefined } : undefined */ TODO
			iterationTypes := getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer)
			if iterationTypes == noIterationTypes {
				if errorNode {
					rootDiag := reportTypeNotIterableError(errorNode, type_, !!(use & IterationUseAllowsAsyncIterablesFlag))
					if errorOutputContainer.errors {
						addRelatedInfo(rootDiag /* TODO(SpreadElement): ...errorOutputContainer.errors */, TODO)
					}
				}
				setCachedIterationTypes(type_, cacheKey, noIterationTypes)
				return nil
			} else if errorOutputContainer.errors.length {
				for _, diag := range errorOutputContainer.errors {
					diagnostics.add(diag)
				}
			}
			allIterationTypes = append(allIterationTypes, iterationTypes)
		}
		iterationTypes := /* TODO(ConditionalExpression): allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes */ TODO
		setCachedIterationTypes(type_, cacheKey, iterationTypes)
		return /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
	}
	getAsyncFromSyncIterationTypes := func(iterationTypes IterationTypes, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if iterationTypes == noIterationTypes {
			/* TODO(Identifier): noIterationTypes */
		}
		if iterationTypes == anyIterationTypes {
			/* TODO(Identifier): anyIterationTypes */
		}
		TODO_IDENTIFIER := iterationTypes
		if errorNode {
			getGlobalAwaitedSymbol(true)
		}
		return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType)
	}
	getIterationTypesOfIterableWorker := func(type_ Type, use IterationUse, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		noCache := false
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, asyncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					noCache = true
				} else {
					return /* TODO(ConditionalExpression): use & IterationUse.ForOfFlag ?                         getAsyncFromSyncIterationTypes(iterationTypes, errorNode) :                         iterationTypes */ TODO
				}
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableCached(type_, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type_, syncIterationTypesResolver)
			if iterationTypes {
				if iterationTypes == noIterationTypes && errorNode {
					noCache = true
				} else {
					if use & IterationUseAllowsAsyncIterablesFlag {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
							iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
							return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
						}
					} else {
						return iterationTypes
					}
				}
			}
		}
		if use & IterationUseAllowsAsyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
				return iterationTypes
			}
		}
		if use & IterationUseAllowsSyncIterablesFlag {
			iterationTypes := getIterationTypesOfIterableSlow(type_, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): iterationTypes !== noIterationTypes */ TODO {
				if use & IterationUseAllowsAsyncIterablesFlag {
					iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
					return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes) */ TODO
				} else {
					return iterationTypes
				}
			}
		}
		return noIterationTypes
	}
	getIterationTypesOfIterableCached := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getCachedIterationTypes(type_, resolver.iterableCacheKey)
	}
	getIterationTypesOfIterableFast := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isReferenceToType(type_, resolver.getGlobalIterableType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, nil) || yieldType, resolver.resolveIterationType(returnType, nil) || returnType, nextType))
		}
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, nil) || yieldType, resolver.resolveIterationType(returnType, nil) || returnType, nextType))
		}
	}
	getPropertyNameForKnownSymbolName := func(symbolName string) __String {
		ctorType := getGlobalESSymbolConstructorSymbol(false)
		uniqueType := ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName))
		return /* TODO(ConditionalExpression): uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : `__@${symbolName}` as __String */ TODO
	}
	getIterationTypesOfIterableSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		method := getPropertyOfType(type_, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName))
		methodType := /* TODO(ConditionalExpression): method && !(method.flags & SymbolFlags.Optional) ? getTypeOfSymbol(method) : undefined */ TODO
		if isTypeAny(methodType) {
			return /* TODO(ConditionalExpression): noCache ? anyIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes) */ TODO
		}
		signatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : undefined */ TODO
		if !some(signatures) {
			return /* TODO(ConditionalExpression): noCache ? noIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes) */ TODO
		}
		iteratorType := getIntersectionType(map_(signatures, getReturnTypeOfSignature))
		iterationTypes := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache) ?? noIterationTypes */ TODO
		return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes) */ TODO
	}
	reportTypeNotIterableError := func(errorNode Node, type_ Type, allowAsyncIterables bool) Diagnostic {
		message := /* TODO(ConditionalExpression): allowAsyncIterables             ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator             : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator */ TODO
		suggestAwait := !!getAwaitedTypeOfPromise(type_) || (!allowAsyncIterables && isForOfStatement(errorNode.parent) && errorNode.parent.expression == errorNode && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getGlobalAsyncIterableType(/*reportErrors* / false) !== emptyGenericType */ TODO && isTypeAssignableTo(type_, createTypeFromGenericGlobalType(getGlobalAsyncIterableType(false) /* TODO(ArrayLiteralExpression): [anyType, anyType, anyType] */, TODO)))
		return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type_))
	}
	getIterationTypesOfIterator := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getIterationTypesOfIteratorWorker(type_, resolver, errorNode, errorOutputContainer, false)
	}
	getIterationTypesOfIteratorWorker := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		iterationTypes := getIterationTypesOfIteratorCached(type_, resolver) || getIterationTypesOfIteratorFast(type_, resolver)
		if iterationTypes == noIterationTypes && errorNode {
			iterationTypes = nil
			noCache = true
		}
		/* TODO(ExpressionStatement): iterationTypes ??= getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache); */
		return /* TODO(ConditionalExpression): iterationTypes === noIterationTypes ? undefined : iterationTypes */ TODO
	}
	getIterationTypesOfIteratorCached := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		return getCachedIterationTypes(type_, resolver.iteratorCacheKey)
	}
	getIterationTypesOfIteratorFast := func(type_ Type, resolver IterationTypesResolver) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isReferenceToType(type_, resolver.getGlobalIterableIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorType(false)) || isReferenceToType(type_, resolver.getGlobalIteratorObjectType(false)) || isReferenceToType(type_, resolver.getGlobalGeneratorType(false)) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
		if isReferenceToSomeType(type_, resolver.getGlobalBuiltinIteratorTypes()) {
			TODO_IDENTIFIER := getTypeArguments(type_ /* as */ /* TODO(TypeReference): GenericType */)
			returnType := getBuiltinIteratorReturnType()
			nextType := unknownType
			return setCachedIterationTypes(type_, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType))
		}
	}
	isIteratorResult := func(type_ Type, kind /* TODO(UnionType): IterationTypeKind.Yield | IterationTypeKind.Return */ any) /* TODO(undefined): boolean */ TODO {
		doneType := getTypeOfPropertyOfType(type_, "done" /* as */ /* TODO(TypeReference): __String */) || falseType
		return isTypeAssignableTo( /* TODO(ConditionalExpression): kind === IterationTypeKind.Yield ? falseType : trueType */ TODO, doneType)
	}
	isYieldIteratorResult := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return isIteratorResult(type_, IterationTypeKindYield)
	}
	isReturnIteratorResult := func(type_ Type) /* TODO(undefined): boolean */ TODO {
		return isIteratorResult(type_, IterationTypeKindReturn)
	}
	getIterationTypesOfIteratorResult := func(type_ Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		cachedTypes := getCachedIterationTypes(type_, "iterationTypesOfIteratorResult")
		if cachedTypes {
			return cachedTypes
		}
		if isReferenceToType(type_, getGlobalIteratorYieldResultType(false)) {
			yieldType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, nil, nil))
		}
		if isReferenceToType(type_, getGlobalIteratorReturnResultType(false)) {
			returnType := /* TODO(ElementAccessExpression): getTypeArguments(type as GenericType)[0] */ TODO
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(nil, returnType, nil))
		}
		yieldIteratorResult := filterType(type_, isYieldIteratorResult)
		yieldType := /* TODO(ConditionalExpression): yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value" as __String) : undefined */ TODO
		returnIteratorResult := filterType(type_, isReturnIteratorResult)
		returnType := /* TODO(ConditionalExpression): returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value" as __String) : undefined */ TODO
		if !yieldType && !returnType {
			return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", noIterationTypes)
		}
		return setCachedIterationTypes(type_, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, nil))
	}
	getIterationTypesOfMethod := func(type_ Type, resolver IterationTypesResolver, methodName /* TODO(UnionType): "next" | "return" | "throw" */ any, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any) *IterationTypes {
		method := getPropertyOfType(type_, methodName /* as */ /* TODO(TypeReference): __String */)
		if !method && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): methodName !== "next" */ TODO {
			return nil
		}
		methodType := /* TODO(ConditionalExpression): method && !(methodName === "next" && (method.flags & SymbolFlags.Optional))             ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), TypeFacts.NEUndefinedOrNull)             : undefined */ TODO
		if isTypeAny(methodType) {
			return anyIterationTypes
		}
		methodSignatures := /* TODO(ConditionalExpression): methodType ? getSignaturesOfType(methodType, SignatureKind.Call) : emptyArray */ TODO
		if methodSignatures.length == 0 {
			if errorNode {
				diagnostic := /* TODO(ConditionalExpression): methodName === "next"                     ? resolver.mustHaveANextMethodDiagnostic                     : resolver.mustBeAMethodDiagnostic */ TODO
				if errorOutputContainer {
					/* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName))
				} else {
					error(errorNode, diagnostic, methodName)
				}
			}
			return /* TODO(ConditionalExpression): methodName === "next" ? noIterationTypes : undefined */ TODO
		}
		if methodType.symbol && methodSignatures.length == 1 {
			globalGeneratorType := resolver.getGlobalGeneratorType(false)
			globalIteratorType := resolver.getGlobalIteratorType(false)
			isGeneratorMethod := globalGeneratorType.symbol.members.get(methodName /* as */ /* TODO(TypeReference): __String */) == methodType.symbol
			isIteratorMethod := !isGeneratorMethod && globalIteratorType.symbol.members.get(methodName /* as */ /* TODO(TypeReference): __String */) == methodType.symbol
			if isGeneratorMethod || isIteratorMethod {
				globalType := /* TODO(ConditionalExpression): isGeneratorMethod ? globalGeneratorType : globalIteratorType */ TODO
				TODO_IDENTIFIER := methodType /* as */ /* TODO(TypeReference): AnonymousType */
				return createIterationTypes(getMappedType( /* TODO(ElementAccessExpression): globalType.typeParameters![0] */ TODO /* TODO(NonNullExpression): mapper! */, TODO), getMappedType( /* TODO(ElementAccessExpression): globalType.typeParameters![1] */ TODO /* TODO(NonNullExpression): mapper! */, TODO) /* TODO(ConditionalExpression): methodName === "next" ? getMappedType(globalType.typeParameters![2], mapper!) : undefined */, TODO)
			}
		}
		var methodParameterTypes /* TODO(ArrayType): Type[] */ any
		var methodReturnTypes /* TODO(ArrayType): Type[] */ any
		for _, signature := range methodSignatures {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): methodName !== "throw" */ TODO && some(signature.parameters) {
				methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0))
			}
			methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature))
		}
		var returnTypes /* TODO(ArrayType): Type[] */ any
		var nextType *Type
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): methodName !== "throw" */ TODO {
			methodParameterType := /* TODO(ConditionalExpression): methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType */ TODO
			if methodName == "next" {
				nextType = methodParameterType
			} else if methodName == "return" {
				resolvedMethodParameterType := resolver.resolveIterationType(methodParameterType, errorNode) || anyType
				returnTypes = append(returnTypes, resolvedMethodParameterType)
			}
		}
		var yieldType Type
		methodReturnType := /* TODO(ConditionalExpression): methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType */ TODO
		resolvedMethodReturnType := resolver.resolveIterationType(methodReturnType, errorNode) || anyType
		iterationTypes := getIterationTypesOfIteratorResult(resolvedMethodReturnType)
		if iterationTypes == noIterationTypes {
			if errorNode {
				if errorOutputContainer {
					/* TODO(ExpressionStatement): errorOutputContainer.errors ??= []; */
					errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName))
				} else {
					error(errorNode, resolver.mustHaveAValueDiagnostic, methodName)
				}
			}
			yieldType = anyType
			returnTypes = append(returnTypes, anyType)
		} else {
			yieldType = iterationTypes.yieldType
			returnTypes = append(returnTypes, iterationTypes.returnType)
		}
		return createIterationTypes(yieldType, getUnionType(returnTypes), nextType)
	}
	getIterationTypesOfIteratorSlow := func(type_ Type, resolver IterationTypesResolver, errorNode Node, errorOutputContainer /* TODO(TypeLiteral): { errors: Diagnostic[] | undefined; } */ any, noCache bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes */ TODO {
		iterationTypes := combineIterationTypes( /* TODO(ArrayLiteralExpression): [             getIterationTypesOfMethod(type, resolver, "next", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "return", errorNode, errorOutputContainer),             getIterationTypesOfMethod(type, resolver, "throw", errorNode, errorOutputContainer),         ] */ TODO)
		return /* TODO(ConditionalExpression): noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes) */ TODO
	}
	getIterationTypeOfGeneratorFunctionReturnType := func(kind IterationTypeKind, returnType Type, isAsyncGenerator bool) *Type {
		if isTypeAny(returnType) {
			return nil
		}
		iterationTypes := getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator)
		return iterationTypes && /* TODO(ElementAccessExpression): iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)] */ TODO
	}
	getIterationTypesOfGeneratorFunctionReturnType := func(type_ Type, isAsyncGenerator bool) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IterationTypes | undefined */ TODO {
		if isTypeAny(type_) {
			return anyIterationTypes
		}
		use := /* TODO(ConditionalExpression): isAsyncGenerator ? IterationUse.AsyncGeneratorReturnType : IterationUse.GeneratorReturnType */ TODO
		resolver := /* TODO(ConditionalExpression): isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver */ TODO
		return getIterationTypesOfIterable(type_, use, nil) || getIterationTypesOfIterator(type_, resolver, nil, nil)
	}
	checkBreakOrContinueStatement := func(node BreakOrContinueStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			/* TODO(CallExpression): checkGrammarBreakOrContinueStatement(node) */
		}
	}
	unwrapReturnType := func(returnType Type, functionFlags FunctionFlags) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		isGenerator := !!(functionFlags & FunctionFlagsGenerator)
		isAsync := !!(functionFlags & FunctionFlagsAsync)
		if isGenerator {
			returnIterationType := getIterationTypeOfGeneratorFunctionReturnType(IterationTypeKindReturn, returnType, isAsync)
			if !returnIterationType {
				return errorType
			}
			return /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType)) : returnIterationType */ TODO
		}
		return /* TODO(ConditionalExpression): isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType */ TODO
	}
	isUnwrappedReturnTypeUndefinedVoidOrAny := func(func_ SignatureDeclaration, returnType Type) bool {
		type_ := unwrapReturnType(returnType, getFunctionFlags(func_))
		return !!(type_ && (maybeTypeOfKind(type_, TypeFlagsVoid) || type_.flags&(TypeFlagsAny|TypeFlagsUndefined)))
	}
	checkReturnStatement := func(node ReturnStatement) {
		if checkGrammarStatementInAmbientContext(node) {
			return
		}
		container := getContainingFunctionOrClassStaticBlock(node)
		if container && isClassStaticBlockDeclaration(container) {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block)
			return
		}
		if !container {
			grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body)
			return
		}
		signature := getSignatureFromDeclaration(container)
		returnType := getReturnTypeOfSignature(signature)
		functionFlags := getFunctionFlags(container)
		if strictNullChecks || node.expression || returnType.flags&TypeFlagsNever {
			exprType := /* TODO(ConditionalExpression): node.expression ? checkExpressionCached(node.expression) : undefinedType */ TODO
			if container.kind == SyntaxKindSetAccessor {
				if node.expression {
					error(node, Diagnostics.Setters_cannot_return_a_value)
				}
			} else if container.kind == SyntaxKindConstructor {
				if node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression) {
					error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class)
				}
			} else if getReturnTypeFromAnnotation(container) {
				unwrappedReturnType := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): unwrapReturnType(returnType, functionFlags) ?? returnType */ TODO
				unwrappedExprType := /* TODO(ConditionalExpression): functionFlags & FunctionFlags.Async                     ? checkAwaitedType(exprType, /*withAlias* / false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)                     : exprType */ TODO
				if unwrappedReturnType {
					checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression)
				}
			}
		} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): container.kind !== SyntaxKind.Constructor */ TODO && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeUndefinedVoidOrAny(container, returnType) {
			error(node, Diagnostics.Not_all_code_paths_return_a_value)
		}
	}
	checkWithStatement := func(node WithStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if node.flags & NodeFlagsAwaitContext {
				grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block)
			}
		}
		checkExpression(node.expression)
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			start := getSpanOfTokenAtPosition(sourceFile, node.pos).start
			end := node.statement.pos
			grammarErrorAtPos(sourceFile, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any)
		}
	}
	checkSwitchStatement := func(node SwitchStatement) {
		checkGrammarStatementInAmbientContext(node)
		var firstDefaultClause CaseOrDefaultClause
		hasDuplicateDefaultClause := false
		expressionType := checkExpression(node.expression)
		forEach(node.caseBlock.clauses, func(clause /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").CaseClause | import("/home/jabaile/work/TypeScript/src/compiler/types").DefaultClause */ TODO) {
			if clause.kind == SyntaxKindDefaultClause && !hasDuplicateDefaultClause {
				if firstDefaultClause == nil {
					firstDefaultClause = clause
				} else {
					grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement)
					hasDuplicateDefaultClause = true
				}
			}
			if clause.kind == SyntaxKindCaseClause {
				addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause))
			}
			forEach(clause.statements, checkSourceElement)
			if compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode) {
				error(clause, Diagnostics.Fallthrough_case_in_switch)
			}
			createLazyCaseClauseDiagnostics := func(clause CaseClause) /* TODO(undefined): () => void */ TODO {
				return func() {
					caseType := checkExpression(clause.expression)
					if !isTypeEqualityComparableTo(expressionType, caseType) {
						checkTypeComparableTo(caseType, expressionType, clause.expression, nil)
					}
				}
			}
		})
		if node.caseBlock.locals {
			registerForUnusedIdentifiersCheck(node.caseBlock)
		}
	}
	checkLabeledStatement := func(node LabeledStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			findAncestor(node.parent, func(current /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
				if isFunctionLike(current) {
					return "quit"
				}
				if current.kind == SyntaxKindLabeledStatement && (current /* as */ /* TODO(TypeReference): LabeledStatement */).label.escapedText == node.label.escapedText {
					grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label))
					return true
				}
				return false
			})
		}
		checkSourceElement(node.statement)
	}
	checkThrowStatement := func(node ThrowStatement) {
		if !checkGrammarStatementInAmbientContext(node) {
			if isIdentifier(node.expression) && !node.expression.escapedText {
				grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here)
			}
		}
		if node.expression {
			checkExpression(node.expression)
		}
	}
	checkTryStatement := func(node TryStatement) {
		checkGrammarStatementInAmbientContext(node)
		checkBlock(node.tryBlock)
		catchClause := node.catchClause
		if catchClause {
			if catchClause.variableDeclaration {
				declaration := catchClause.variableDeclaration
				checkVariableLikeDeclaration(declaration)
				typeNode := getEffectiveTypeAnnotationNode(declaration)
				if typeNode {
					type_ := getTypeFromTypeNode(typeNode)
					if type_ && !(type_.flags & TypeFlagsAnyOrUnknown) {
						grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified)
					}
				} else if declaration.initializer {
					grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer)
				} else {
					blockLocals := catchClause.block.locals
					if blockLocals {
						forEachKey( /* TODO(NonNullExpression): catchClause.locals! */ TODO, func(caughtName /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
							blockLocal := blockLocals.get(caughtName)
							if blockLocal.valueDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (blockLocal.flags & SymbolFlags.BlockScopedVariable) !== 0 */ TODO {
								grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, unescapeLeadingUnderscores(caughtName))
							}
						})
					}
				}
			}
			checkBlock(catchClause.block)
		}
		if node.finallyBlock {
			checkBlock(node.finallyBlock)
		}
	}
	checkIndexConstraints := func(type_ Type, symbol Symbol, isStaticIndex bool) {
		indexInfos := getIndexInfosOfType(type_)
		if indexInfos.length == 0 {
			return
		}
		for _, prop := range getPropertiesOfObjectType(type_) {
			if !(isStaticIndex && prop.flags&SymbolFlagsPrototype) {
				checkIndexConstraintForProperty(type_, prop, getLiteralTypeFromProperty(prop, TypeFlagsStringOrNumberLiteralOrUnique, true), getNonMissingTypeOfSymbol(prop))
			}
		}
		typeDeclaration := symbol.valueDeclaration
		if typeDeclaration && isClassLike(typeDeclaration) {
			for _, member := range typeDeclaration.members {
				if !isStatic(member) && !hasBindableName(member) {
					symbol := getSymbolOfDeclaration(member)
					checkIndexConstraintForProperty(type_, symbol, getTypeOfExpression((member /* as */ /* TODO(TypeReference): DynamicNamedDeclaration */).name.expression), getNonMissingTypeOfSymbol(symbol))
				}
			}
		}
		if indexInfos.length > 1 {
			for _, info := range indexInfos {
				checkIndexConstraintForIndexSignature(type_, info)
			}
		}
	}
	checkIndexConstraintForProperty := func(type_ Type, prop Symbol, propNameType Type, propType Type) {
		declaration := prop.valueDeclaration
		name := getNameOfDeclaration(declaration)
		if name && isPrivateIdentifier(name) {
			return
		}
		indexInfos := getApplicableIndexInfos(type_, propNameType)
		interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		propDeclaration := /* TODO(ConditionalExpression): declaration && declaration.kind === SyntaxKind.BinaryExpression ||                 name && name.kind === SyntaxKind.ComputedPropertyName ? declaration : undefined */ TODO
		localPropDeclaration := /* TODO(ConditionalExpression): getParentOfSymbol(prop) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			localIndexDeclaration := /* TODO(ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localPropDeclaration || localIndexDeclaration || ( /* TODO(ConditionalExpression): interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined */ TODO)
			if errorNode && !isTypeAssignableTo(propType, info.type_) {
				diagnostic := createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type_))
				if propDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): errorNode !== propDeclaration */ TODO {
					addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)))
				}
				diagnostics.add(diagnostic)
			}
		}
	}
	checkIndexConstraintForIndexSignature := func(type_ Type, checkInfo IndexInfo) {
		declaration := checkInfo.declaration
		indexInfos := getApplicableIndexInfos(type_, checkInfo.keyType)
		interfaceDeclaration := /* TODO(ConditionalExpression): getObjectFlags(type) & ObjectFlags.Interface ? getDeclarationOfKind(type.symbol, SyntaxKind.InterfaceDeclaration) : undefined */ TODO
		localCheckDeclaration := /* TODO(ConditionalExpression): declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : undefined */ TODO
		for _, info := range indexInfos {
			if info == checkInfo {
			}
			localIndexDeclaration := /* TODO(ConditionalExpression): info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : undefined */ TODO
			errorNode := localCheckDeclaration || localIndexDeclaration || ( /* TODO(ConditionalExpression): interfaceDeclaration && !some(getBaseTypes(type as InterfaceType), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : undefined */ TODO)
			if errorNode && !isTypeAssignableTo(checkInfo.type_, info.type_) {
				error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type_), typeToString(info.keyType), typeToString(info.type_))
			}
		}
	}
	checkTypeNameIsReserved := func(name Identifier, message DiagnosticMessage) {
		/* TODO(SwitchStatement): switch (name.escapedText) {             case "any":             case "unknown":             case "never":             case "number":             case "bigint":             case "boolean":             case "string":             case "symbol":             case "void":             case "object":             case "undefined":                 error(name, message, name.escapedText as string);         } */
	}
	checkClassNameCollisionWithObject := func(name Identifier) {
		if languageVersion >= ScriptTargetES5 && name.escapedText == "Object" && host.getEmitModuleFormatOfFile(getSourceFileOfNode(name)) < ModuleKindES2015 {
			error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0 /* TODO(ElementAccessExpression): ModuleKind[moduleKind] */, TODO)
		}
	}
	checkUnmatchedJSDocParameters := func(node SignatureDeclaration) {
		jsdocParameters := filter(getJSDocTags(node), isJSDocParameterTag)
		if !length(jsdocParameters) {
		}
		isJs := isInJSFile(node)
		parameters := /* TODO(NewExpression): new Set<__String>() */ TODO
		excludedParameters := /* TODO(NewExpression): new Set<number>() */ TODO
		forEach(node.parameters, func(TODO_IDENTIFIER /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, index /* TODO(undefined): number */ TODO) {
			if isIdentifier(name) {
				parameters.add(name.escapedText)
			}
			if isBindingPattern(name) {
				excludedParameters.add(index)
			}
		})
		containsArguments := containsArgumentsReference(node)
		if containsArguments {
			lastJSDocParamIndex := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): jsdocParameters.length - 1 */ TODO
			lastJSDocParam := /* TODO(ElementAccessExpression): jsdocParameters[lastJSDocParamIndex] */ TODO
			if isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression && lastJSDocParam.typeExpression.type_ && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type_)) {
				error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name))
			}
		} else {
			forEach(jsdocParameters, func(TODO_IDENTIFIER /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocParameterTag */ TODO, index /* TODO(undefined): number */ TODO) {
				if excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText) {
					return
				}
				if isQualifiedName(name) {
					if isJs {
						error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left))
					}
				} else {
					if !isNameFirst {
						errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name))
					}
				}
			})
		}
	}
	checkTypeParameters := func(typeParameterDeclarations /* TODO(TypeOperator): readonly TypeParameterDeclaration[] */ any) {
		seenDefault := false
		if typeParameterDeclarations {
			/* TODO(ForStatement): for (let i = 0; i < typeParameterDeclarations.length; i++) {                 const node = typeParameterDeclarations[i];                 checkTypeParameter(node);                  addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));             } */
		}
		createCheckTypeParameterDiagnostic := func(node TypeParameterDeclaration, i number) /* TODO(undefined): () => void */ TODO {
			return func() {
				if node.default_ {
					seenDefault = true
					checkTypeParametersNotReferenced(node.default_ /* TODO(NonNullExpression): typeParameterDeclarations! */, TODO, i)
				} else if seenDefault {
					error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters)
				}
				/* TODO(ForStatement): for (let j = 0; j < i; j++) {                     if (typeParameterDeclarations![j].symbol === node.symbol) {                         error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));                     }                 } */
			}
		}
	}
	checkTypeParametersNotReferenced := func(root TypeNode, typeParameters []TypeParameterDeclaration, index number) {
		visit(root)
		visit := func(node Node) {
			if node.kind == SyntaxKindTypeReference {
				type_ := getTypeFromTypeReference(node /* as */ /* TODO(TypeReference): TypeReferenceNode */)
				if type_.flags & TypeFlagsTypeParameter {
					/* TODO(ForStatement): for (let i = index; i < typeParameters.length; i++) {                         if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {                             error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);                         }                     } */
				}
			}
			forEachChild(node, visit)
		}
	}
	checkTypeParameterListsIdentical := func(symbol Symbol) {
		if symbol.declarations && symbol.declarations.length == 1 {
			return
		}
		links := getSymbolLinks(symbol)
		if !links.typeParametersChecked {
			links.typeParametersChecked = true
			declarations := getClassOrInterfaceDeclarationsOfSymbol(symbol)
			if !declarations || declarations.length <= 1 {
				return
			}
			type_ := getDeclaredTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): InterfaceType */
			if !areTypeParametersIdentical(declarations /* TODO(NonNullExpression): type.localTypeParameters! */, TODO, getEffectiveTypeParameterDeclarations) {
				name := symbolToString(symbol)
				for _, declaration := range declarations {
					error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name)
				}
			}
		}
	}
	areTypeParametersIdentical := func(declarations []T, targetParameters []TypeParameter, getTypeParameterDeclarations func(node T) []TypeParameterDeclaration) /* TODO(undefined): boolean */ TODO {
		maxTypeArgumentCount := length(targetParameters)
		minTypeArgumentCount := getMinTypeArgumentCount(targetParameters)
		for _, declaration := range declarations {
			sourceParameters := getTypeParameterDeclarations(declaration)
			numTypeParameters := sourceParameters.length
			if numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount {
				return false
			}
			/* TODO(ForStatement): for (let i = 0; i < numTypeParameters; i++) {                 const source = sourceParameters[i];                 const target = targetParameters[i];                  // If the type parameter node does not have the same as the resolved type                 // parameter at this position, we report an error.                 if (source.name.escapedText !== target.symbol.escapedName) {                     return false;                 }                  // If the type parameter node does not have an identical constraint as the resolved                 // type parameter at this position, we report an error.                 const constraint = getEffectiveConstraintOfTypeParameter(source);                 const sourceConstraint = constraint && getTypeFromTypeNode(constraint);                 const targetConstraint = getConstraintOfTypeParameter(target);                 // relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with                 // a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)                 if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {                     return false;                 }                  // If the type parameter node has a default and it is not identical to the default                 // for the type parameter at this position, we report an error.                 const sourceDefault = source.default && getTypeFromTypeNode(source.default);                 const targetDefault = getDefaultFromTypeParameter(target);                 if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {                     return false;                 }             } */
		}
		return true
	}
	getFirstTransformableStaticClassElement := func(node ClassLikeDeclaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Decorator | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").ClassStaticBlockDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierPropertyDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierMethodDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierGetAccessorDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").PrivateIdentifierSetAccessorDeclaration | (import("/home/jabaile/work/TypeScript/src/compiler/types").PropertyDeclaration & { initializer: import("/home/jabaile/work/TypeScript/src/compiler/types").Expression; }) | undefined */ TODO {
		willTransformStaticElementsOfDecoratedClass := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators && classOrConstructorParameterIsDecorated(false, node)
		willTransformPrivateElementsOrClassStaticBlocks := languageVersion < LanguageFeatureMinimumTargetPrivateNamesAndClassStaticBlocks || languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		willTransformInitializers := !emitStandardClassFields
		if willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks {
			for _, member := range node.members {
				if willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(false, member, node) {
					return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): firstOrUndefined(getDecorators(node)) ?? node */ TODO
				} else if willTransformPrivateElementsOrClassStaticBlocks {
					if isClassStaticBlockDeclaration(member) {
						return member
					} else if isStatic(member) {
						if isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member) {
							return member
						}
					}
				}
			}
		}
	}
	checkClassExpressionExternalHelpers := func(node ClassExpression) {
		if node.name {
		}
		parent := walkUpOuterExpressions(node)
		if !isNamedEvaluationSource(parent) {
		}
		willTransformESDecorators := !legacyDecorators && languageVersion < LanguageFeatureMinimumTargetClassAndClassElementDecorators
		var location Node
		if willTransformESDecorators && classOrConstructorParameterIsDecorated(false, node) {
			location = /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): firstOrUndefined(getDecorators(node)) ?? node */ TODO
		} else {
			location = getFirstTransformableStaticClassElement(node)
		}
		if location {
			checkExternalEmitHelpers(location, ExternalEmitHelpersSetFunctionName)
			if (isPropertyAssignment(parent) || isPropertyDeclaration(parent) || isBindingElement(parent)) && isComputedPropertyName(parent.name) {
				checkExternalEmitHelpers(location, ExternalEmitHelpersPropKey)
			}
		}
	}
	checkClassExpression := func(node ClassExpression) Type {
		checkClassLikeDeclaration(node)
		checkNodeDeferred(node)
		checkClassExpressionExternalHelpers(node)
		return getTypeOfSymbol(getSymbolOfDeclaration(node))
	}
	checkClassExpressionDeferred := func(node ClassExpression) {
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassDeclaration := func(node ClassDeclaration) {
		firstDecorator := find(node.modifiers, isDecorator)
		if legacyDecorators && firstDecorator && some(node.members, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ClassElement */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(CallExpression): hasStaticModifier(p) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isPrivateIdentifierClassElementDeclaration(p) */
		}) {
			grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator)
		}
		if !node.name && !hasSyntacticModifier(node, ModifierFlagsDefault) {
			grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name)
		}
		checkClassLikeDeclaration(node)
		forEach(node.members, checkSourceElement)
		registerForUnusedIdentifiersCheck(node)
	}
	checkClassLikeDeclaration := func(node ClassLikeDeclaration) {
		checkGrammarClassLikeDeclaration(node)
		checkDecorators(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkTypeParameters(getEffectiveTypeParameterDeclarations(node))
		checkExportsOnMergedDeclarations(node)
		symbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): InterfaceType */
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): ObjectType */
		checkTypeParameterListsIdentical(symbol)
		checkFunctionOrConstructorSymbol(symbol)
		checkClassForDuplicateDeclarations(node)
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if !nodeInAmbientContext {
			checkClassForStaticPropertyNameConflicts(node)
		}
		baseTypeNode := getEffectiveBaseTypeNode(node)
		if baseTypeNode {
			forEach(baseTypeNode.typeArguments, checkSourceElement)
			if languageVersion < LanguageFeatureMinimumTargetClasses {
				checkExternalEmitHelpers(baseTypeNode.parent, ExternalEmitHelpersExtends)
			}
			extendsNode := getClassExtendsHeritageElement(node)
			if extendsNode && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): extendsNode !== baseTypeNode */ TODO {
				checkExpression(extendsNode.expression)
			}
			baseTypes := getBaseTypes(type_)
			if baseTypes.length {
				addLazyDiagnostic(func() {
					baseType := /* TODO(ElementAccessExpression): baseTypes[0] */ TODO
					baseConstructorType := getBaseConstructorTypeOfClass(type_)
					staticBaseType := getApparentType(baseConstructorType)
					checkBaseTypeAccessibility(staticBaseType, baseTypeNode)
					checkSourceElement(baseTypeNode.expression)
					if some(baseTypeNode.typeArguments) {
						forEach(baseTypeNode.typeArguments, checkSourceElement)
						for _, constructor := range getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode) {
							if !checkTypeArgumentConstraints(baseTypeNode /* TODO(NonNullExpression): constructor.typeParameters! */, TODO) {
								/* TODO(BreakStatement): break; */
							}
						}
					}
					baseWithThis := getTypeWithThisArgument(baseType, type_.thisType)
					if !checkTypeAssignableTo(typeWithThis, baseWithThis, nil) {
						issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1)
					} else {
						checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1)
					}
					if baseConstructorType.flags & TypeFlagsTypeVariable {
						if !isMixinConstructorType(staticType) {
							error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any)
						} else {
							constructSignatures := getSignaturesOfType(baseConstructorType, SignatureKindConstruct)
							if constructSignatures.some(func(signature /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): number */ TODO {
								/* TODO(PropertyAccessExpression): signature.flags */
								/* TODO(AmpersandToken): & */
								/* TODO(PropertyAccessExpression): SignatureFlags.Abstract */
							}) && !hasSyntacticModifier(node, ModifierFlagsAbstract) {
								error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract)
							}
						}
					}
					if !(staticBaseType.symbol && staticBaseType.symbol.flags&SymbolFlagsClass) && !(baseConstructorType.flags & TypeFlagsTypeVariable) {
						constructors := getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)
						if forEach(constructors, func(sig /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Signature */ TODO) /* TODO(undefined): boolean */ TODO {
							/* TODO(PrefixUnaryExpression): !isJSConstructor(sig.declaration) */
							/* TODO(AmpersandAmpersandToken): && */
							/* TODO(PrefixUnaryExpression): !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType) */
						}) {
							error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type)
						}
					}
					checkKindsOfPropertyMemberOverrides(type_, baseType)
				})
			}
		}
		checkMembersForOverrideModifier(node, type_, typeWithThis, staticType)
		implementedTypeNodes := getEffectiveImplementsTypeNodes(node)
		if implementedTypeNodes {
			for _, typeRefNode := range implementedTypeNodes {
				if !isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression) {
					error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments)
				}
				checkTypeReferenceNode(typeRefNode)
				addLazyDiagnostic(createImplementsDiagnostics(typeRefNode))
			}
		}
		addLazyDiagnostic(func() {
			checkIndexConstraints(type_, symbol)
			checkIndexConstraints(staticType, symbol, true)
			checkTypeForDuplicateIndexSignatures(node)
			checkPropertyInitialization(node)
		})
		createImplementsDiagnostics := func(typeRefNode ExpressionWithTypeArguments) /* TODO(undefined): () => void */ TODO {
			return func() {
				t := getReducedType(getTypeFromTypeNode(typeRefNode))
				if !isErrorType(t) {
					if isValidBaseType(t) {
						genericDiag := /* TODO(ConditionalExpression): t.symbol && t.symbol.flags & SymbolFlags.Class ?                             Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :                             Diagnostics.Class_0_incorrectly_implements_interface_1 */ TODO
						baseWithThis := getTypeWithThisArgument(t, type_.thisType)
						if !checkTypeAssignableTo(typeWithThis, baseWithThis, nil) {
							issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag)
						}
					} else {
						error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members)
					}
				}
			}
		}
	}
	checkMembersForOverrideModifier := func(node ClassLikeDeclaration, type_ InterfaceType, typeWithThis Type, staticType ObjectType) {
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		for _, member := range node.members {
			if hasAmbientModifier(member) {
				/* TODO(ContinueStatement): continue; */
			}
			if isConstructorDeclaration(member) {
				forEach(member.parameters, func(param /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) {
					if isParameterPropertyDeclaration(param, member) {
						checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, param, true)
					}
				})
			}
			checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, member, false)
		}
	}
	checkExistingMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, member /* TODO(UnionType): ClassElement | ParameterPropertyDeclaration */ any, memberIsParameterProperty bool, reportErrors /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) MemberOverrideStatus {
		declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
		if !declaredProp {
			return MemberOverrideStatusOk
		}
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, declaredProp /* TODO(ConditionalExpression): reportErrors ? member : undefined */, TODO)
	}
	checkMemberForOverrideModifier := func(node ClassLikeDeclaration, staticType ObjectType, baseStaticType Type, baseWithThis *Type, type_ InterfaceType, typeWithThis Type, memberHasOverrideModifier bool, memberHasAbstractModifier bool, memberIsStatic bool, memberIsParameterProperty bool, member Symbol, errorNode Node) MemberOverrideStatus {
		isJs := isInJSFile(node)
		nodeInAmbientContext := !!(node.flags & NodeFlagsAmbient)
		if baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride) {
			thisType := /* TODO(ConditionalExpression): memberIsStatic ? staticType : typeWithThis */ TODO
			baseType := /* TODO(ConditionalExpression): memberIsStatic ? baseStaticType : baseWithThis */ TODO
			prop := getPropertyOfType(thisType, member.escapedName)
			baseProp := getPropertyOfType(baseType, member.escapedName)
			baseClassName := typeToString(baseWithThis)
			if prop && !baseProp && memberHasOverrideModifier {
				if errorNode {
					suggestion := getSuggestedSymbolForNonexistentClassMember(symbolName(member), baseType)
					/* TODO(ExpressionStatement): suggestion ?                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1,                             baseClassName,                             symbolToString(suggestion),                         ) :                         error(                             errorNode,                             isJs ?                                 Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 :                                 Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0,                             baseClassName,                         ); */
				}
				return MemberOverrideStatusHasInvalidOverride
			} else if prop && baseProp.declarations && compilerOptions.noImplicitOverride && !nodeInAmbientContext {
				baseHasAbstract := some(baseProp.declarations, hasAbstractModifier)
				if memberHasOverrideModifier {
					return MemberOverrideStatusOk
				}
				if !baseHasAbstract {
					if errorNode {
						diag := /* TODO(ConditionalExpression): memberIsParameterProperty ?                             isJs ?                                 Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                                 Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 :                             isJs ?                             Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :                             Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0 */ TODO
						error(errorNode, diag, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				} else if memberHasAbstractModifier && baseHasAbstract {
					if errorNode {
						error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName)
					}
					return MemberOverrideStatusNeedsOverride
				}
			}
		} else if memberHasOverrideModifier {
			if errorNode {
				className := typeToString(type_)
				error(errorNode /* TODO(ConditionalExpression): isJs ?                         Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class :                         Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class */, TODO, className)
			}
			return MemberOverrideStatusHasInvalidOverride
		}
		return MemberOverrideStatusOk
	}
	issueMemberSpecificError := func(node ClassLikeDeclaration, typeWithThis Type, baseWithThis Type, broadDiag DiagnosticMessage) {
		issuedMemberError := false
		for _, member := range node.members {
			if isStatic(member) {
				/* TODO(ContinueStatement): continue; */
			}
			declaredProp := member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member)
			if declaredProp {
				prop := getPropertyOfType(typeWithThis, declaredProp.escapedName)
				baseProp := getPropertyOfType(baseWithThis, declaredProp.escapedName)
				if prop && baseProp {
					rootChain := func() /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessageChain */ TODO {
						/* TODO(Identifier): chainDiagnosticMessages */
						/* TODO(Identifier): undefined */
						/* TODO(PropertyAccessExpression): Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 */
						/* TODO(CallExpression): symbolToString(declaredProp) */
						/* TODO(CallExpression): typeToString(typeWithThis) */
						/* TODO(CallExpression): typeToString(baseWithThis) */
					}
					if !checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, nil, rootChain) {
						issuedMemberError = true
					}
				}
			}
		}
		if !issuedMemberError {
			checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag)
		}
	}
	checkBaseTypeAccessibility := func(type_ Type, node ExpressionWithTypeArguments) {
		signatures := getSignaturesOfType(type_, SignatureKindConstruct)
		if signatures.length {
			declaration := /* TODO(ElementAccessExpression): signatures[0] */ TODO.declaration
			if declaration && hasEffectiveModifier(declaration, ModifierFlagsPrivate) {
				typeClassDeclaration := /* TODO(NonNullExpression): getClassLikeDeclarationOfSymbol(type.symbol)! */ TODO
				if !isNodeWithinClass(node, typeClassDeclaration) {
					error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type_.symbol))
				}
			}
		}
	}
	getMemberOverrideModifierStatus := func(node ClassLikeDeclaration, member ClassElement, memberSymbol Symbol) MemberOverrideStatus {
		if !member.name {
			return MemberOverrideStatusOk
		}
		classSymbol := getSymbolOfDeclaration(node)
		type_ := getDeclaredTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): InterfaceType */
		typeWithThis := getTypeWithThisArgument(type_)
		staticType := getTypeOfSymbol(classSymbol) /* as */ /* TODO(TypeReference): ObjectType */
		baseTypeNode := getEffectiveBaseTypeNode(node)
		baseTypes := baseTypeNode && getBaseTypes(type_)
		baseWithThis := /* TODO(ConditionalExpression): baseTypes?.length ? getTypeWithThisArgument(first(baseTypes), type.thisType) : undefined */ TODO
		baseStaticType := getBaseConstructorTypeOfClass(type_)
		memberHasOverrideModifier := /* TODO(ConditionalExpression): member.parent             ? hasOverrideModifier(member)             : hasSyntacticModifier(member, ModifierFlags.Override) */ TODO
		return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type_, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member), false, memberSymbol)
	}
	getTargetSymbol := func(s Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		return /* TODO(ConditionalExpression): getCheckFlags(s) & CheckFlags.Instantiated ? (s as TransientSymbol).links.target! : s */ TODO
	}
	getClassOrInterfaceDeclarationsOfSymbol := func(symbol Symbol) /* TODO(undefined): (import("/home/jabaile/work/TypeScript/src/compiler/types").ClassDeclaration | import("/home/jabaile/work/TypeScript/src/compiler/types").InterfaceDeclaration)[] | undefined */ TODO {
		return filter(symbol.declarations, func(d Declaration) /* TODO(TypePredicate): d is ClassDeclaration | InterfaceDeclaration */ TODO {
			/* TODO(BinaryExpression): d.kind === SyntaxKind.ClassDeclaration */
			/* TODO(BarBarToken): || */
			/* TODO(BinaryExpression): d.kind === SyntaxKind.InterfaceDeclaration */
		})
	}
	checkKindsOfPropertyMemberOverrides := func(type_ InterfaceType, baseType BaseType) {
		baseProperties := getPropertiesOfType(baseType)
		type MemberInfo struct {
			missedProperties []string
			baseTypeName     string
			typeName         string
		}
		notImplementedInfo := /* TODO(NewExpression): new Map<ClassLikeDeclaration, MemberInfo>() */ TODO
		/* TODO(LabeledStatement): basePropertyCheck: for (const baseProperty of baseProperties) {             const base = getTargetSymbol(baseProperty);              if (base.flags & SymbolFlags.Prototype) {                 continue;             }             const baseSymbol = getPropertyOfObjectType(type, base.escapedName);             if (!baseSymbol) {                 continue;             }             const derived = getTargetSymbol(baseSymbol);             const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);              Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");              // In order to resolve whether the inherited method was overridden in the base class or not,             // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*             // type declaration, derived and base resolve to the same symbol even in the case of generic classes.             if (derived === base) {                 // derived class inherits base without override/redeclaration                 const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol)!;                  // It is an error to inherit an abstract member without implementing it or being declared abstract.                 // If there is no declaration for the derived class (as in the case of class expressions),                 // then the class cannot be declared abstract.                 if (baseDeclarationFlags & ModifierFlags.Abstract && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, ModifierFlags.Abstract))) {                     // Searches other base types for a declaration that would satisfy the inherited abstract member.                     // (The class may have more than one base type via declaration merging with an interface with the                     // same name.)                     for (const otherBaseType of getBaseTypes(type)) {                         if (otherBaseType === baseType) continue;                         const baseSymbol = getPropertyOfObjectType(otherBaseType, base.escapedName);                         const derivedElsewhere = baseSymbol && getTargetSymbol(baseSymbol);                         if (derivedElsewhere && derivedElsewhere !== base) {                             continue basePropertyCheck;                         }                     }                     const baseTypeName = typeToString(baseType);                     const typeName = typeToString(type);                     const basePropertyName = symbolToString(baseProperty);                     const missedProperties = append(notImplementedInfo.get(derivedClassDecl)?.missedProperties, basePropertyName);                     notImplementedInfo.set(derivedClassDecl, { baseTypeName, typeName, missedProperties });                 }             }             else {                 // derived overrides base.                 const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);                 if (baseDeclarationFlags & ModifierFlags.Private || derivedDeclarationFlags & ModifierFlags.Private) {                     // either base or derived property is private - not override, skip it                     continue;                 }                  let errorMessage: DiagnosticMessage;                 const basePropertyFlags = base.flags & SymbolFlags.PropertyOrAccessor;                 const derivedPropertyFlags = derived.flags & SymbolFlags.PropertyOrAccessor;                 if (basePropertyFlags && derivedPropertyFlags) {                     // property/accessor is overridden with property/accessor                     if (                         (getCheckFlags(base) & CheckFlags.Synthetic                             ? base.declarations?.some(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags))                             : base.declarations?.every(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags)))                         || getCheckFlags(base) & CheckFlags.Mapped                         || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration)                     ) {                         // when the base property is abstract or from an interface, base/derived flags don't need to match                         // for intersection properties, this must be true of *any* of the declarations, for others it must be true of *all*                         // same when the derived property is from an assignment                         continue;                     }                      const overriddenInstanceProperty = basePropertyFlags !== SymbolFlags.Property && derivedPropertyFlags === SymbolFlags.Property;                     const overriddenInstanceAccessor = basePropertyFlags === SymbolFlags.Property && derivedPropertyFlags !== SymbolFlags.Property;                     if (overriddenInstanceProperty || overriddenInstanceAccessor) {                         const errorMessage = overriddenInstanceProperty ?                             Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property :                             Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;                         error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType), typeToString(type));                     }                     else if (useDefineForClassFields) {                         const uninitialized = derived.declarations?.find(d => d.kind === SyntaxKind.PropertyDeclaration && !(d as PropertyDeclaration).initializer);                         if (                             uninitialized                             && !(derived.flags & SymbolFlags.Transient)                             && !(baseDeclarationFlags & ModifierFlags.Abstract)                             && !(derivedDeclarationFlags & ModifierFlags.Abstract)                             && !derived.declarations?.some(d => !!(d.flags & NodeFlags.Ambient))                         ) {                             const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol)!);                             const propName = (uninitialized as PropertyDeclaration).name;                             if (                                 (uninitialized as PropertyDeclaration).exclamationToken                                 || !constructor                                 || !isIdentifier(propName)                                 || !strictNullChecks                                 || !isPropertyInitializedInConstructor(propName, type, constructor)                             ) {                                 const errorMessage = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;                                 error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, symbolToString(base), typeToString(baseType));                             }                         }                     }                      // correct case                     continue;                 }                 else if (isPrototypeProperty(base)) {                     if (isPrototypeProperty(derived) || derived.flags & SymbolFlags.Property) {                         // method is overridden with method or property -- correct case                         continue;                     }                     else {                         Debug.assert(!!(derived.flags & SymbolFlags.Accessor));                         errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;                     }                 }                 else if (base.flags & SymbolFlags.Accessor) {                     errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                 else {                     errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;                 }                  error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));             }         } */
		for _, TODO_IDENTIFIER := range notImplementedInfo {
			if length(memberInfo.missedProperties) == 1 {
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, memberInfo.typeName, first(memberInfo.missedProperties), memberInfo.baseTypeName)
				}
			} else if length(memberInfo.missedProperties) > 5 {
				missedProperties := map_(memberInfo.missedProperties.slice(0, 4), func(prop /* TODO(undefined): string */ TODO) /* TODO(undefined): string */ TODO {
					/* TODO(TemplateHead): `'${ */
					/* TODO(TemplateSpan): prop}'` */
				}).join(", ")
				remainingMissedProperties := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): length(memberInfo.missedProperties) - 4 */ TODO
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1_and_2_more, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2_and_3_more, memberInfo.typeName, memberInfo.baseTypeName, missedProperties, remainingMissedProperties)
				}
			} else {
				missedProperties := map_(memberInfo.missedProperties, func(prop /* TODO(undefined): string */ TODO) /* TODO(undefined): string */ TODO {
					/* TODO(TemplateHead): `'${ */
					/* TODO(TemplateSpan): prop}'` */
				}).join(", ")
				if isClassExpression(errorNode) {
					error(errorNode, Diagnostics.Non_abstract_class_expression_is_missing_implementations_for_the_following_members_of_0_Colon_1, memberInfo.baseTypeName, missedProperties)
				} else {
					error(errorNode, Diagnostics.Non_abstract_class_0_is_missing_implementations_for_the_following_members_of_1_Colon_2, memberInfo.typeName, memberInfo.baseTypeName, missedProperties)
				}
			}
		}
	}
	isPropertyAbstractOrInterface := func(declaration Declaration, baseDeclarationFlags ModifierFlags) /* TODO(undefined): boolean */ TODO {
		return baseDeclarationFlags&ModifierFlagsAbstract && (!isPropertyDeclaration(declaration) || !declaration.initializer) || isInterfaceDeclaration(declaration.parent)
	}
	getNonInheritedProperties := func(type_ InterfaceType, baseTypes []BaseType, properties []Symbol) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol[] */ TODO {
		if !length(baseTypes) {
			return properties
		}
		seen := /* TODO(NewExpression): new Map<__String, Symbol>() */ TODO
		forEach(properties, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
			seen.set(p.escapedName, p)
		})
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if existing && prop.parent == existing.parent {
					seen.delete(prop.escapedName)
				}
			}
		}
		return arrayFrom(seen.values())
	}
	checkInheritedPropertiesAreIdentical := func(type_ InterfaceType, typeNode Node) bool {
		baseTypes := getBaseTypes(type_)
		if baseTypes.length < 2 {
			return true
		}
		type InheritanceInfoMap struct {
			prop           Symbol
			containingType Type
		}
		seen := /* TODO(NewExpression): new Map<__String, InheritanceInfoMap>() */ TODO
		forEach(resolveDeclaredMembers(type_).declaredProperties, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
			seen.set(p.escapedName /* TODO(ObjectLiteralExpression): { prop: p, containingType: type } */, TODO)
		})
		ok := true
		for _, base := range baseTypes {
			properties := getPropertiesOfType(getTypeWithThisArgument(base, type_.thisType))
			for _, prop := range properties {
				existing := seen.get(prop.escapedName)
				if !existing {
					seen.set(prop.escapedName /* TODO(ObjectLiteralExpression): { prop, containingType: base } */, TODO)
				} else {
					isInheritedProperty := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): existing.containingType !== type */ TODO
					if isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop) {
						ok = false
						typeName1 := typeToString(existing.containingType)
						typeName2 := typeToString(base)
						errorInfo := chainDiagnosticMessages(nil, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2)
						errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type_), typeName1, typeName2)
						diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo))
					}
				}
			}
		}
		return ok
	}
	checkPropertyInitialization := func(node ClassLikeDeclaration) {
		if !strictNullChecks || !strictPropertyInitialization || node.flags&NodeFlagsAmbient {
			return
		}
		constructor := findConstructorDeclaration(node)
		for _, member := range node.members {
			if getEffectiveModifierFlags(member) & ModifierFlagsAmbient {
				/* TODO(ContinueStatement): continue; */
			}
			if !isStatic(member) && isPropertyWithoutInitializer(member) {
				propName := (member /* as */ /* TODO(TypeReference): PropertyDeclaration */).name
				if isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName) {
					type_ := getTypeOfSymbol(getSymbolOfDeclaration(member))
					if !(type_.flags&TypeFlagsAnyOrUnknown || containsUndefinedType(type_)) {
						if !constructor || !isPropertyInitializedInConstructor(propName, type_, constructor) {
							error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName))
						}
					}
				}
			}
		}
	}
	isPropertyWithoutInitializer := func(node Node) /* TODO(undefined): boolean */ TODO {
		return node.kind == SyntaxKindPropertyDeclaration && !hasAbstractModifier(node) && !(node /* as */ /* TODO(TypeReference): PropertyDeclaration */).exclamationToken && !(node /* as */ /* TODO(TypeReference): PropertyDeclaration */).initializer
	}
	isPropertyInitializedInStaticBlocks := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier */ any, propType Type, staticBlocks []ClassStaticBlockDeclaration, startPos number, endPos number) /* TODO(undefined): boolean */ TODO {
		for _, staticBlock := range staticBlocks {
			if staticBlock.pos >= startPos && staticBlock.pos <= endPos {
				reference := factory.createPropertyAccessExpression(factory.createThis(), propName)
				setParent(reference.expression, reference)
				setParent(reference, staticBlock)
				reference.flowNode = staticBlock.returnFlowNode
				flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
				if !containsUndefinedType(flowType) {
					return true
				}
			}
		}
		return false
	}
	isPropertyInitializedInConstructor := func(propName /* TODO(UnionType): Identifier | PrivateIdentifier | ComputedPropertyName */ any, propType Type, constructor ConstructorDeclaration) /* TODO(undefined): boolean */ TODO {
		reference := /* TODO(ConditionalExpression): isComputedPropertyName(propName)             ? factory.createElementAccessExpression(factory.createThis(), propName.expression)             : factory.createPropertyAccessExpression(factory.createThis(), propName) */ TODO
		setParent(reference.expression, reference)
		setParent(reference, constructor)
		reference.flowNode = constructor.returnFlowNode
		flowType := getFlowTypeOfReference(reference, propType, getOptionalType(propType))
		return !containsUndefinedType(flowType)
	}
	checkInterfaceDeclaration := func(node InterfaceDeclaration) {
		if !checkGrammarModifiers(node) {
			/* TODO(CallExpression): checkGrammarInterfaceDeclaration(node) */
		}
		checkTypeParameters(node.typeParameters)
		addLazyDiagnostic(func() {
			checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0)
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			checkTypeParameterListsIdentical(symbol)
			firstInterfaceDecl := getDeclarationOfKind(symbol, SyntaxKindInterfaceDeclaration)
			if node == firstInterfaceDecl {
				type_ := getDeclaredTypeOfSymbol(symbol) /* as */ /* TODO(TypeReference): InterfaceType */
				typeWithThis := getTypeWithThisArgument(type_)
				if checkInheritedPropertiesAreIdentical(type_, node.name) {
					for _, baseType := range getBaseTypes(type_) {
						checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type_.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1)
					}
					checkIndexConstraints(type_, symbol)
				}
			}
			checkObjectTypeForDuplicateDeclarations(node)
		})
		forEach(getInterfaceBaseTypeNodes(node), func(heritageElement /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ExpressionWithTypeArguments */ TODO) {
			if !isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression) {
				error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments)
			}
			checkTypeReferenceNode(heritageElement)
		})
		forEach(node.members, checkSourceElement)
		addLazyDiagnostic(func() {
			checkTypeForDuplicateIndexSignatures(node)
			registerForUnusedIdentifiersCheck(node)
		})
	}
	checkTypeAliasDeclaration := func(node TypeAliasDeclaration) {
		checkGrammarModifiers(node)
		checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0)
		checkExportsOnMergedDeclarations(node)
		checkTypeParameters(node.typeParameters)
		if node.type_.kind == SyntaxKindIntrinsicKeyword {
			typeParameterCount := length(node.typeParameters)
			valid := /* TODO(ConditionalExpression): typeParameterCount === 0 ? node.name.escapedText === "BuiltinIteratorReturn" :                 typeParameterCount === 1 && intrinsicTypeKinds.has(node.name.escapedText as string) */ TODO
			if !valid {
				error(node.type_, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types)
			}
		} else {
			checkSourceElement(node.type_)
			registerForUnusedIdentifiersCheck(node)
		}
	}
	computeEnumMemberValues := func(node EnumDeclaration) {
		nodeLinks := getNodeLinks(node)
		if !(nodeLinks.flags & NodeCheckFlagsEnumValuesComputed) {
			nodeLinks.flags |= NodeCheckFlagsEnumValuesComputed
			var autoValue /* TODO(NumberKeyword): number */ any = 0
			var previous *EnumMember
			for _, member := range node.members {
				result := computeEnumMemberValue(member, autoValue, previous)
				getNodeLinks(member).enumMemberValue = result
				autoValue = /* TODO(ConditionalExpression): typeof result.value === "number" ? result.value + 1 : undefined */ TODO
				previous = member
			}
		}
	}
	computeEnumMemberValue := func(member EnumMember, autoValue /* TODO(NumberKeyword): number */ any, previous *EnumMember) EvaluatorResult {
		if isComputedNonLiteralName(member.name) {
			error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums)
		} else {
			text := getTextOfPropertyName(member.name)
			if isNumericLiteralName(text) && !isInfinityOrNaNString(text) {
				error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name)
			}
		}
		if member.initializer {
			return computeConstantEnumMemberValue(member)
		}
		if member.parent.flags&NodeFlagsAmbient && !isEnumConst(member.parent) {
			return evaluatorResult(nil)
		}
		if autoValue == nil {
			error(member.name, Diagnostics.Enum_member_must_have_initializer)
			return evaluatorResult(nil)
		}
		if getIsolatedModules(compilerOptions) && previous.initializer {
			prevValue := getEnumMemberValue(previous)
			if !( /* TODO(TypeOfExpression): typeof prevValue.value */ TODO == "number" && !prevValue.resolvedOtherFiles) {
				error(member.name, Diagnostics.Enum_member_following_a_non_literal_numeric_member_must_have_an_initializer_when_isolatedModules_is_enabled)
			}
		}
		return evaluatorResult(autoValue)
	}
	computeConstantEnumMemberValue := func(member EnumMember) EvaluatorResult {
		isConstEnum := isEnumConst(member.parent)
		initializer := /* TODO(NonNullExpression): member.initializer! */ TODO
		result := evaluate(initializer, member)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): result.value !== undefined */ TODO {
			if isConstEnum && /* TODO(TypeOfExpression): typeof result.value */ TODO == "number" && !isFinite(result.value) {
				error(initializer /* TODO(ConditionalExpression): isNaN(result.value) ?                         Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN :                         Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value */, TODO)
			} else if getIsolatedModules(compilerOptions) && /* TODO(TypeOfExpression): typeof result.value */ TODO == "string" && !result.isSyntacticallyString {
				error(initializer, Diagnostics._0_has_a_string_type_but_must_have_syntactically_recognizable_string_syntax_when_isolatedModules_is_enabled /* TODO(TemplateExpression): `${idText(member.parent.name)}.${getTextOfPropertyName(member.name)}` */, TODO)
			}
		} else if isConstEnum {
			error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions)
		} else if member.parent.flags & NodeFlagsAmbient {
			error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression)
		} else {
			checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values)
		}
		return result
	}
	evaluateEntityNameExpression := func(expr EntityNameExpression, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		symbol := resolveEntityName(expr, SymbolFlagsValue, true)
		if !symbol {
			/* TODO(CallExpression): evaluatorResult(/*value* / undefined) */
		}
		if expr.kind == SyntaxKindIdentifier {
			identifier := expr
			if isInfinityOrNaNString(identifier.escapedText) && (symbol == getGlobalSymbol(identifier.escapedText, SymbolFlagsValue, nil)) {
				return evaluatorResult(+(identifier.escapedText), false)
			}
		}
		if symbol.flags & SymbolFlagsEnumMember {
			return /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, symbol, location) : getEnumMemberValue(symbol.valueDeclaration as EnumMember) */ TODO
		}
		if isConstantVariable(symbol) {
			declaration := symbol.valueDeclaration
			if declaration && isVariableDeclaration(declaration) && !declaration.type_ && declaration.initializer && (!location || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration !== location */ TODO && isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
				result := evaluate(declaration.initializer, declaration)
				if location && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(location) !== getSourceFileOfNode(declaration) */ TODO {
					return evaluatorResult(result.value, false, true, true)
				}
				return evaluatorResult(result.value, result.isSyntacticallyString, result.resolvedOtherFiles, true)
			}
		}
		return evaluatorResult(nil)
	}
	evaluateElementAccessExpression := func(expr ElementAccessExpression, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		root := expr.expression
		if isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression) {
			rootSymbol := resolveEntityName(root, SymbolFlagsValue, true)
			if rootSymbol && rootSymbol.flags&SymbolFlagsEnum {
				name := escapeLeadingUnderscores(expr.argumentExpression.text)
				member := /* TODO(NonNullExpression): rootSymbol.exports! */ TODO.get(name)
				if member {
					Debug.assert(getSourceFileOfNode(member.valueDeclaration) == getSourceFileOfNode(rootSymbol.valueDeclaration))
					return /* TODO(ConditionalExpression): location ? evaluateEnumMember(expr, member, location) : getEnumMemberValue(member.valueDeclaration as EnumMember) */ TODO
				}
			}
		}
		return evaluatorResult(nil)
	}
	evaluateEnumMember := func(expr Expression, symbol Symbol, location Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").EvaluatorResult<string | number | undefined> */ TODO {
		declaration := symbol.valueDeclaration
		if !declaration || declaration == location {
			error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol))
			return evaluatorResult(nil)
		}
		if !isBlockScopedNameDeclaredBeforeUse(declaration, location) {
			error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums)
			return evaluatorResult(0)
		}
		value := getEnumMemberValue(declaration /* as */ /* TODO(TypeReference): EnumMember */)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): location.parent !== declaration.parent */ TODO {
			return evaluatorResult(value.value, value.isSyntacticallyString, value.resolvedOtherFiles, true)
		}
		return value
	}
	checkEnumDeclaration := func(node EnumDeclaration) {
		addLazyDiagnostic(func() {
			/* TODO(Identifier): checkEnumDeclarationWorker */
			/* TODO(Identifier): node */
		})
	}
	checkEnumDeclarationWorker := func(node EnumDeclaration) {
		checkGrammarModifiers(node)
		checkCollisionsForDeclarationName(node, node.name)
		checkExportsOnMergedDeclarations(node)
		node.members.forEach(checkEnumMember)
		computeEnumMemberValues(node)
		enumSymbol := getSymbolOfDeclaration(node)
		firstDeclaration := getDeclarationOfKind(enumSymbol, node.kind)
		if node == firstDeclaration {
			if enumSymbol.declarations && enumSymbol.declarations.length > 1 {
				enumIsConst := isEnumConst(node)
				forEach(enumSymbol.declarations, func(decl /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) {
					if isEnumDeclaration(decl) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): isEnumConst(decl) !== enumIsConst */ TODO {
						error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const)
					}
				})
			}
			seenEnumMissingInitialInitializer := false
			forEach(enumSymbol.declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): false | undefined */ TODO {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.EnumDeclaration */ TODO {
					return false
				}
				enumDeclaration := declaration /* as */ /* TODO(TypeReference): EnumDeclaration */
				if !enumDeclaration.members.length {
					return false
				}
				firstEnumMember := /* TODO(ElementAccessExpression): enumDeclaration.members[0] */ TODO
				if !firstEnumMember.initializer {
					if seenEnumMissingInitialInitializer {
						error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element)
					} else {
						seenEnumMissingInitialInitializer = true
					}
				}
			})
		}
	}
	checkEnumMember := func(node EnumMember) {
		if isPrivateIdentifier(node.name) {
			error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier)
		}
		if node.initializer {
			checkExpression(node.initializer)
		}
	}
	getFirstNonAmbientClassOrFunctionDeclaration := func(symbol Symbol) Declaration {
		declarations := symbol.declarations
		if declarations {
			for _, declaration := range declarations {
				if (declaration.kind == SyntaxKindClassDeclaration || (declaration.kind == SyntaxKindFunctionDeclaration && nodeIsPresent((declaration /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body))) && !(declaration.flags & NodeFlagsAmbient) {
					return declaration
				}
			}
		}
		return nil
	}
	inSameLexicalScope := func(node1 Node, node2 Node) /* TODO(undefined): boolean */ TODO {
		container1 := getEnclosingBlockScopeContainer(node1)
		container2 := getEnclosingBlockScopeContainer(node2)
		if isGlobalSourceFile(container1) {
			return isGlobalSourceFile(container2)
		} else if isGlobalSourceFile(container2) {
			return false
		} else {
			return container1 == container2
		}
	}
	checkModuleDeclaration := func(node ModuleDeclaration) {
		if node.body {
			checkSourceElement(node.body)
			if !isGlobalScopeAugmentation(node) {
				registerForUnusedIdentifiersCheck(node)
			}
		}
		addLazyDiagnostic(checkModuleDeclarationDiagnostics)
		checkModuleDeclarationDiagnostics := func() {
			isGlobalAugmentation := isGlobalScopeAugmentation(node)
			inAmbientContext := node.flags & NodeFlagsAmbient
			if isGlobalAugmentation && !inAmbientContext {
				error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context)
			}
			var isAmbientExternalModule bool = isAmbientModule(node)
			contextErrorMessage := /* TODO(ConditionalExpression): isAmbientExternalModule                 ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file                 : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module */ TODO
			if checkGrammarModuleElementContext(node, contextErrorMessage) {
				return
			}
			if !checkGrammarModifiers(node) {
				if !inAmbientContext && node.name.kind == SyntaxKindStringLiteral {
					grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names)
				}
			}
			if isIdentifier(node.name) {
				checkCollisionsForDeclarationName(node, node.name)
				if !(node.flags & (NodeFlagsNamespace | NodeFlagsGlobalAugmentation)) {
					sourceFile := getSourceFileOfNode(node)
					pos := getNonModifierTokenPosOfNode(node)
					span := getSpanOfTokenAtPosition(sourceFile, pos)
					suggestionDiagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.A_namespace_declaration_should_not_be_declared_using_the_module_keyword_Please_use_the_namespace_keyword_instead))
				}
			}
			checkExportsOnMergedDeclarations(node)
			symbol := getSymbolOfDeclaration(node)
			if symbol.flags&SymbolFlagsValueModule && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions)) {
				if getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator {
					error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName)
				}
				if /* TODO(NonNullExpression): symbol.declarations?.length! */ TODO > 1 {
					firstNonAmbientClassOrFunc := getFirstNonAmbientClassOrFunctionDeclaration(symbol)
					if firstNonAmbientClassOrFunc {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(node) !== getSourceFileOfNode(firstNonAmbientClassOrFunc) */ TODO {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged)
						} else if node.pos < firstNonAmbientClassOrFunc.pos {
							error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged)
						}
					}
					mergedClass := getDeclarationOfKind(symbol, SyntaxKindClassDeclaration)
					if mergedClass && inSameLexicalScope(node, mergedClass) {
						getNodeLinks(node).flags |= NodeCheckFlagsLexicalModuleMergesWithClass
					}
				}
				if compilerOptions.verbatimModuleSyntax && node.parent.kind == SyntaxKindSourceFile && host.getEmitModuleFormatOfFile(node.parent) == ModuleKindCommonJS {
					exportModifier := node.modifiers.find(func(m /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierLike */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(PropertyAccessExpression): m.kind */
						/* TODO(EqualsEqualsEqualsToken): === */
						/* TODO(PropertyAccessExpression): SyntaxKind.ExportKeyword */
					})
					if exportModifier {
						error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
					}
				}
			}
			if isAmbientExternalModule {
				if isExternalModuleAugmentation(node) {
					checkBody := isGlobalAugmentation || (getSymbolOfDeclaration(node).flags & SymbolFlagsTransient)
					if checkBody && node.body {
						for _, statement := range node.body.statements {
							checkModuleAugmentationElement(statement, isGlobalAugmentation)
						}
					}
				} else if isGlobalSourceFile(node.parent) {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else if isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name)) {
						error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name)
					}
				} else {
					if isGlobalAugmentation {
						error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations)
					} else {
						error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces)
					}
				}
			}
		}
	}
	checkModuleAugmentationElement := func(node Node, isGlobalAugmentation bool) {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.VariableStatement:                 // error each individual name in variable statement instead of marking the entire variable statement                 for (const decl of (node as VariableStatement).declarationList.declarations) {                     checkModuleAugmentationElement(decl, isGlobalAugmentation);                 }                 break;             case SyntaxKind.ExportAssignment:             case SyntaxKind.ExportDeclaration:                 grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);                 break;             case SyntaxKind.ImportEqualsDeclaration:                 // import a = e.x; in module augmentation is ok, but not import a = require('fs)                 if (isInternalModuleImportEqualsDeclaration(node)) break;                 // falls through             case SyntaxKind.ImportDeclaration:                 grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);                 break;             case SyntaxKind.BindingElement:             case SyntaxKind.VariableDeclaration:                 const name = (node as VariableDeclaration | BindingElement).name;                 if (isBindingPattern(name)) {                     for (const el of name.elements) {                         // mark individual names in binding pattern                         checkModuleAugmentationElement(el, isGlobalAugmentation);                     }                     break;                 }                 // falls through             case SyntaxKind.ClassDeclaration:             case SyntaxKind.EnumDeclaration:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.InterfaceDeclaration:             case SyntaxKind.ModuleDeclaration:             case SyntaxKind.TypeAliasDeclaration:                 if (isGlobalAugmentation) {                     return;                 }                 break;         } */
	}
	getFirstNonModuleExportsIdentifier := func(node EntityNameOrEntityNameExpression) Identifier {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:                 return node;             case SyntaxKind.QualifiedName:                 do {                     node = node.left;                 }                 while (node.kind !== SyntaxKind.Identifier);                 return node;             case SyntaxKind.PropertyAccessExpression:                 do {                     if (isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name)) {                         return node.name;                     }                     node = node.expression;                 }                 while (node.kind !== SyntaxKind.Identifier);                 return node;         } */
	}
	checkExternalImportOrExportDeclaration := func(node /* TODO(UnionType): ImportDeclaration | ImportEqualsDeclaration | ExportDeclaration */ any) bool {
		moduleName := getExternalModuleName(node)
		if !moduleName || nodeIsMissing(moduleName) {
			return false
		}
		if !isStringLiteral(moduleName) {
			error(moduleName, Diagnostics.String_literal_expected)
			return false
		}
		inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile */ TODO && !inAmbientExternalModule {
			error(moduleName /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExportDeclaration ?                     Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :                     Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module */, TODO)
			return false
		}
		if inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text) {
			if !isTopLevelInExternalModuleAugmentation(node) {
				error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name)
				return false
			}
		}
		if !isImportEqualsDeclaration(node) && node.attributes {
			diagnostic := /* TODO(ConditionalExpression): node.attributes.token === SyntaxKind.WithKeyword ? Diagnostics.Import_attribute_values_must_be_string_literal_expressions : Diagnostics.Import_assertion_values_must_be_string_literal_expressions */ TODO
			hasError := false
			for _, attr := range node.attributes.elements {
				if !isStringLiteral(attr.value) {
					hasError = true
					error(attr.value, diagnostic)
				}
			}
			return !hasError
		}
		return true
	}
	checkModuleExportName := func(name *ModuleExportName, allowStringLiteral /* TODO(undefined): boolean */ TODO /* = */ /* TODO(TrueKeyword): true */) {
		if name == nil || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): name.kind !== SyntaxKind.StringLiteral */ TODO {
			return
		}
		if !allowStringLiteral {
			grammarErrorOnNode(name, Diagnostics.Identifier_expected)
		} else if moduleKind == ModuleKindES2015 || moduleKind == ModuleKindES2020 {
			grammarErrorOnNode(name, Diagnostics.String_literal_import_and_export_names_are_not_supported_when_the_module_flag_is_set_to_es2015_or_es2020)
		}
	}
	checkAliasSymbol := func(node AliasDeclarationNode) {
		symbol := getSymbolOfDeclaration(node)
		target := resolveAlias(symbol)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== unknownSymbol */ TODO {
			symbol = getMergedSymbol(symbol.exportSymbol || symbol)
			if isInJSFile(node) && !(target.flags & SymbolFlagsValue) && !isTypeOnlyImportOrExportDeclaration(node) {
				errorNode := /* TODO(ConditionalExpression): isImportOrExportSpecifier(node) ? node.propertyName || node.name :                     isNamedDeclaration(node) ? node.name :                     node */ TODO
				Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.NamespaceExport */ TODO)
				if node.kind == SyntaxKindExportSpecifier {
					diag := error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files)
					alreadyExportedSymbol := getSourceFileOfNode(node).symbol.exports.get(moduleExportNameTextEscaped(node.propertyName || node.name))
					if alreadyExportedSymbol == target {
						exportingDeclaration := alreadyExportedSymbol.declarations.find(isJSDocNode)
						if exportingDeclaration {
							addRelatedInfo(diag, createDiagnosticForNode(exportingDeclaration, Diagnostics._0_is_automatically_exported_here, unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName)))
						}
					}
				} else {
					Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.VariableDeclaration */ TODO)
					importDeclaration := findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration))
					moduleSpecifier := /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): (importDeclaration && tryGetModuleSpecifierFromDeclaration(importDeclaration)?.text) ?? "..." */ TODO
					importedIdentifier := unescapeLeadingUnderscores( /* TODO(ConditionalExpression): isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName */ TODO)
					error(errorNode, Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation, importedIdentifier /* TODO(TemplateExpression): `import("${moduleSpecifier}").${importedIdentifier}` */, TODO)
				}
				return
			}
			targetFlags := getSymbolFlags(target)
			excludedMeanings := ( /* TODO(ConditionalExpression): symbol.flags & (SymbolFlags.Value | SymbolFlags.ExportValue) ? SymbolFlags.Value : 0 */ TODO) | ( /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Type ? SymbolFlags.Type : 0 */ TODO) | ( /* TODO(ConditionalExpression): symbol.flags & SymbolFlags.Namespace ? SymbolFlags.Namespace : 0 */ TODO)
			if targetFlags & excludedMeanings {
				message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.ExportSpecifier ?                     Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :                     Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0 */ TODO
				error(node, message, symbolToString(symbol))
			} else if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ExportSpecifier */ TODO {
				appearsValueyToTranspiler := compilerOptions.isolatedModules && !findAncestor(node, isTypeOnlyImportOrExportDeclaration)
				if appearsValueyToTranspiler && symbol.flags&(SymbolFlagsValue|SymbolFlagsExportValue) {
					error(node, Diagnostics.Import_0_conflicts_with_local_value_so_must_be_declared_with_a_type_only_import_when_isolatedModules_is_enabled, symbolToString(symbol), isolatedModulesLikeFlagName)
				}
			}
			if getIsolatedModules(compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) {
				typeOnlyAlias := getTypeOnlyAliasDeclaration(symbol)
				isType := !(targetFlags & SymbolFlagsValue)
				if isType || typeOnlyAlias {
					/* TODO(SwitchStatement): switch (node.kind) {                         case SyntaxKind.ImportClause:                         case SyntaxKind.ImportSpecifier:                         case SyntaxKind.ImportEqualsDeclaration: {                             if (compilerOptions.verbatimModuleSyntax) {                                 Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");                                 const message = compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node)                                     ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled                                     : isType                                     ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled;                                 const name = moduleExportNameTextUnescaped(node.kind === SyntaxKind.ImportSpecifier ? node.propertyName || node.name : node.name);                                 addTypeOnlyDeclarationRelatedInfo(                                     error(node, message, name),                                     isType ? undefined : typeOnlyAlias,                                     name,                                 );                             }                             if (isType && node.kind === SyntaxKind.ImportEqualsDeclaration && hasEffectiveModifier(node, ModifierFlags.Export)) {                                 error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName);                             }                             break;                         }                         case SyntaxKind.ExportSpecifier: {                             // Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.                             // The exception is that `import type { A } from './a'; export { A }` is allowed                             // because single-file analysis can determine that the export should be dropped.                             if (compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(node)) {                                 const name = moduleExportNameTextUnescaped(node.propertyName || node.name);                                 const diagnostic = isType                                     ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName)                                     : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName);                                 addTypeOnlyDeclarationRelatedInfo(diagnostic, isType ? undefined : typeOnlyAlias, name);                                 break;                             }                         }                     } */
				}
				if compilerOptions.verbatimModuleSyntax && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ImportEqualsDeclaration */ TODO && !isInJSFile(node) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
				} else if moduleKind == ModuleKindPreserve && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ImportEqualsDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.VariableDeclaration */ TODO && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS {
					error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_module_is_set_to_preserve)
				}
				if compilerOptions.verbatimModuleSyntax && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & NodeFlagsAmbient) && targetFlags&SymbolFlagsConstEnum {
					constEnumDeclaration := target.valueDeclaration /* as */ /* TODO(TypeReference): EnumDeclaration */
					redirect := host.getRedirectReferenceForResolutionFromSourceOfProject(getSourceFileOfNode(constEnumDeclaration).resolvedPath)
					if constEnumDeclaration.flags&NodeFlagsAmbient && (!redirect || !shouldPreserveConstEnums(redirect.commandLine.options)) {
						error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName)
					}
				}
			}
			if isImportSpecifier(node) {
				targetSymbol := resolveAliasWithDeprecationCheck(symbol, node)
				if isDeprecatedSymbol(targetSymbol) && targetSymbol.declarations {
					addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName /* as */ /* TODO(StringKeyword): string */)
				}
			}
		}
	}
	resolveAliasWithDeprecationCheck := func(symbol Symbol, location Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		if !(symbol.flags & SymbolFlagsAlias) || isDeprecatedSymbol(symbol) || !getDeclarationOfAliasSymbol(symbol) {
			return symbol
		}
		targetSymbol := resolveAlias(symbol)
		if targetSymbol == unknownSymbol {
			/* TODO(Identifier): targetSymbol */
		}
		/* TODO(WhileStatement): while (symbol.flags & SymbolFlags.Alias) {             const target = getImmediateAliasedSymbol(symbol);             if (target) {                 if (target === targetSymbol) break;                 if (target.declarations && length(target.declarations)) {                     if (isDeprecatedSymbol(target)) {                         addDeprecatedSuggestion(location, target.declarations, target.escapedName as string);                         break;                     }                     else {                         if (symbol === targetSymbol) break;                         symbol = target;                     }                 }             }             else {                 break;             }         } */
		return targetSymbol
	}
	checkImportBinding := func(node /* TODO(UnionType): ImportEqualsDeclaration | ImportClause | NamespaceImport | ImportSpecifier */ any) {
		checkCollisionsForDeclarationName(node, node.name)
		checkAliasSymbol(node)
		if node.kind == SyntaxKindImportSpecifier {
			checkModuleExportName(node.propertyName)
			if moduleExportNameIsDefault(node.propertyName || node.name) && getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkImportAttributes := func(declaration /* TODO(UnionType): ImportDeclaration | ExportDeclaration | JSDocImportTag */ any) /* TODO(undefined): boolean | undefined */ TODO {
		node := declaration.attributes
		if node {
			importAttributesType := getGlobalImportAttributesType(true)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): importAttributesType !== emptyObjectType */ TODO {
				checkTypeAssignableTo(getTypeFromImportAttributes(node), getNullableType(importAttributesType, TypeFlagsUndefined), node)
			}
			validForTypeAttributes := isExclusivelyTypeOnlyImportOrExport(declaration)
			override := getResolutionModeOverride(node /* TODO(ConditionalExpression): validForTypeAttributes ? grammarErrorOnNode : undefined */, TODO)
			isImportAttributes := declaration.attributes.token == SyntaxKindWithKeyword
			if validForTypeAttributes && override {
				return
			}
			mode := (moduleKind == ModuleKindNodeNext) && declaration.moduleSpecifier && getEmitSyntaxForModuleSpecifierExpression(declaration.moduleSpecifier)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): mode !== ModuleKind.ESNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.ESNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Preserve */ TODO {
				message := /* TODO(ConditionalExpression): isImportAttributes                     ? moduleKind === ModuleKind.NodeNext                         ? Diagnostics.Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                         : Diagnostics.Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve                     : moduleKind === ModuleKind.NodeNext                     ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls                     : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_nodenext_or_preserve */ TODO
				return grammarErrorOnNode(node, message)
			}
			isTypeOnly := isJSDocImportTag(declaration) || ( /* TODO(ConditionalExpression): isImportDeclaration(declaration) ? declaration.importClause?.isTypeOnly : declaration.isTypeOnly */ TODO)
			if isTypeOnly {
				return grammarErrorOnNode(node /* TODO(ConditionalExpression): isImportAttributes ? Diagnostics.Import_attributes_cannot_be_used_with_type_only_imports_or_exports : Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports */, TODO)
			}
			if override {
				return grammarErrorOnNode(node, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports)
			}
		}
	}
	checkImportAttribute := func(node ImportAttribute) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		return getRegularTypeOfLiteralType(checkExpressionCached(node.value))
	}
	checkImportDeclaration := func(node ImportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && node.modifiers {
			grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers)
		}
		if checkExternalImportOrExportDeclaration(node) {
			importClause := node.importClause
			if importClause && !checkGrammarImportClause(importClause) {
				if importClause.name {
					checkImportBinding(importClause)
				}
				if importClause.namedBindings {
					if importClause.namedBindings.kind == SyntaxKindNamespaceImport {
						checkImportBinding(importClause.namedBindings)
						if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						moduleExisted := resolveExternalModuleName(node, node.moduleSpecifier)
						if moduleExisted {
							forEach(importClause.namedBindings.elements, checkImportBinding)
						}
					}
				}
			} else if noUncheckedSideEffectImports && !importClause {
				/* TODO(ExpressionStatement): void resolveExternalModuleName(node, node.moduleSpecifier); */
			}
		}
		checkImportAttributes(node)
	}
	checkImportEqualsDeclaration := func(node ImportEqualsDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		checkGrammarModifiers(node)
		if isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node) {
			checkImportBinding(node)
			markLinkedReferences(node, ReferenceHintExportImportEquals)
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.moduleReference.kind !== SyntaxKind.ExternalModuleReference */ TODO {
				target := resolveAlias(getSymbolOfDeclaration(node))
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): target !== unknownSymbol */ TODO {
					targetFlags := getSymbolFlags(target)
					if targetFlags & SymbolFlagsValue {
						moduleName := getFirstIdentifier(node.moduleReference)
						if !( /* TODO(NonNullExpression): resolveEntityName(moduleName, SymbolFlags.Value | SymbolFlags.Namespace)! */ TODO.flags & SymbolFlagsNamespace) {
							error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName))
						}
					}
					if targetFlags & SymbolFlagsType {
						checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0)
					}
				}
				if node.isTypeOnly {
					grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type)
				}
			} else {
				if ModuleKindES2015 <= moduleKind && moduleKind <= ModuleKindESNext && !node.isTypeOnly && !(node.flags & NodeFlagsAmbient) {
					grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead)
				}
			}
		}
	}
	checkExportDeclaration := func(node ExportDeclaration) {
		if checkGrammarModuleElementContext(node /* TODO(ConditionalExpression): isInJSFile(node) ? Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module */, TODO) {
			return
		}
		if !checkGrammarModifiers(node) && hasSyntacticModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers)
		}
		checkGrammarExportDeclaration(node)
		if !node.moduleSpecifier || checkExternalImportOrExportDeclaration(node) {
			if node.exportClause && !isNamespaceExport(node.exportClause) {
				forEach(node.exportClause.elements, checkExportSpecifier)
				inAmbientExternalModule := node.parent.kind == SyntaxKindModuleBlock && isAmbientModule(node.parent.parent)
				inAmbientNamespaceDeclaration := !inAmbientExternalModule && node.parent.kind == SyntaxKindModuleBlock && !node.moduleSpecifier && node.flags&NodeFlagsAmbient
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile */ TODO && !inAmbientExternalModule && !inAmbientNamespaceDeclaration {
					error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace)
				}
			} else {
				moduleSymbol := resolveExternalModuleName(node /* TODO(NonNullExpression): node.moduleSpecifier! */, TODO)
				if moduleSymbol && hasExportAssignmentSymbol(moduleSymbol) {
					error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol))
				} else if node.exportClause {
					checkAliasSymbol(node.exportClause)
					checkModuleExportName(node.exportClause.name)
				}
				if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem {
					if node.exportClause {
						if getESModuleInterop(compilerOptions) {
							checkExternalEmitHelpers(node, ExternalEmitHelpersImportStar)
						}
					} else {
						checkExternalEmitHelpers(node, ExternalEmitHelpersExportStar)
					}
				}
			}
		}
		checkImportAttributes(node)
	}
	checkGrammarExportDeclaration := func(node ExportDeclaration) bool {
		if node.isTypeOnly && node.exportClause.kind == SyntaxKindNamedExports {
			return checkGrammarNamedImportsOrExports(node.exportClause)
		}
		return false
	}
	checkGrammarModuleElementContext := func(node Statement, errorMessage DiagnosticMessage) bool {
		isInAppropriateContext := node.parent.kind == SyntaxKindSourceFile || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindModuleDeclaration
		if !isInAppropriateContext {
			grammarErrorOnFirstToken(node, errorMessage)
		}
		return !isInAppropriateContext
	}
	checkExportSpecifier := func(node ExportSpecifier) {
		checkAliasSymbol(node)
		hasModuleSpecifier := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.moduleSpecifier !== undefined */ TODO
		checkModuleExportName(node.propertyName, hasModuleSpecifier)
		checkModuleExportName(node.name)
		if getEmitDeclarations(compilerOptions) {
			collectLinkedAliases(node.propertyName || node.name, true)
		}
		if !hasModuleSpecifier {
			exportedName := node.propertyName || node.name
			if exportedName.kind == SyntaxKindStringLiteral {
				return
			}
			symbol := resolveName(exportedName, exportedName.escapedText, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, nil, true)
			if symbol && (symbol == undefinedSymbol || symbol == globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer( /* TODO(ElementAccessExpression): symbol.declarations[0] */ TODO))) {
				error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName))
			} else {
				markLinkedReferences(node, ReferenceHintExportSpecifier)
			}
		} else {
			if getESModuleInterop(compilerOptions) && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && moduleExportNameIsDefault(node.propertyName || node.name) {
				checkExternalEmitHelpers(node, ExternalEmitHelpersImportDefault)
			}
		}
	}
	checkExportAssignment := func(node ExportAssignment) {
		illegalContextMessage := /* TODO(ConditionalExpression): node.isExportEquals             ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration             : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration */ TODO
		if checkGrammarModuleElementContext(node, illegalContextMessage) {
			return
		}
		container := /* TODO(ConditionalExpression): node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent as ModuleDeclaration */ TODO
		if container.kind == SyntaxKindModuleDeclaration && !isAmbientModule(container) {
			if node.isExportEquals {
				error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace)
			} else {
				error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module)
			}
			return
		}
		if !checkGrammarModifiers(node) && hasEffectiveModifiers(node) {
			grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers)
		}
		typeAnnotationNode := getEffectiveTypeAnnotationNode(node)
		if typeAnnotationNode {
			checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression)
		}
		isIllegalExportDefaultInCJS := !node.isExportEquals && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) == ModuleKindCommonJS
		if node.expression.kind == SyntaxKindIdentifier {
			id := node.expression /* as */ /* TODO(TypeReference): Identifier */
			sym := getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, SymbolFlagsAll, true, true, node))
			if sym {
				markLinkedReferences(node, ReferenceHintExportAssignment)
				typeOnlyDeclaration := getTypeOnlyAliasDeclaration(sym, SymbolFlagsValue)
				if getSymbolFlags(sym) & SymbolFlagsValue {
					checkExpressionCached(id)
					if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax && typeOnlyDeclaration {
						error(id /* TODO(ConditionalExpression): node.isExportEquals                                 ? Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration                                 : Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration */, TODO, idText(id))
					}
				} else if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && compilerOptions.verbatimModuleSyntax {
					error(id /* TODO(ConditionalExpression): node.isExportEquals                             ? Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type                             : Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type */, TODO, idText(id))
				}
				if !isIllegalExportDefaultInCJS && !(node.flags & NodeFlagsAmbient) && getIsolatedModules(compilerOptions) && !(sym.flags & SymbolFlagsValue) {
					nonLocalMeanings := getSymbolFlags(sym, false, true)
					if sym.flags&SymbolFlagsAlias && nonLocalMeanings&SymbolFlagsType && !(nonLocalMeanings & SymbolFlagsValue) && (!typeOnlyDeclaration || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node) */ TODO) {
						error(id /* TODO(ConditionalExpression): node.isExportEquals ?                                 Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                 : Diagnostics._0_resolves_to_a_type_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName)
					} else if typeOnlyDeclaration && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSourceFileOfNode(typeOnlyDeclaration) !== getSourceFileOfNode(node) */ TODO {
						addTypeOnlyDeclarationRelatedInfo(error(id /* TODO(ConditionalExpression): node.isExportEquals ?                                     Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_import_type_where_0_is_imported                                     : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_marked_type_only_in_this_file_before_re_exporting_when_1_is_enabled_Consider_using_export_type_0_as_default */, TODO, idText(id), isolatedModulesLikeFlagName), typeOnlyDeclaration, idText(id))
					}
				}
			} else {
				checkExpressionCached(id)
			}
			if getEmitDeclarations(compilerOptions) {
				collectLinkedAliases(id, true)
			}
		} else {
			checkExpressionCached(node.expression)
		}
		if isIllegalExportDefaultInCJS {
			error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		checkExternalModuleExports(container)
		if (node.flags & NodeFlagsAmbient) && !isEntityNameExpression(node.expression) {
			grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context)
		}
		if node.isExportEquals {
			if moduleKind >= ModuleKindES2015 && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Preserve */ TODO && ((node.flags&NodeFlagsAmbient && host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) == ModuleKindESNext) || (!(node.flags & NodeFlagsAmbient) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): host.getImpliedNodeFormatForEmit(getSourceFileOfNode(node)) !== ModuleKind.CommonJS */ TODO)) {
				grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead)
			} else if moduleKind == ModuleKindSystem && !(node.flags & NodeFlagsAmbient) {
				grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system)
			}
		}
	}
	hasExportedMembers := func(moduleSymbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		return forEachEntry( /* TODO(NonNullExpression): moduleSymbol.exports! */ TODO, func(_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): id */
			/* TODO(ExclamationEqualsEqualsToken): !== */
			/* TODO(StringLiteral): "export=" */
		})
	}
	checkExternalModuleExports := func(node /* TODO(UnionType): SourceFile | ModuleDeclaration */ any) {
		moduleSymbol := getSymbolOfDeclaration(node)
		links := getSymbolLinks(moduleSymbol)
		if !links.exportsChecked {
			exportEqualsSymbol := /* TODO(NonNullExpression): moduleSymbol.exports! */ TODO.get("export=" /* as */ /* TODO(TypeReference): __String */)
			if exportEqualsSymbol && hasExportedMembers(moduleSymbol) {
				declaration := getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration
				if declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration) {
					error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements)
				}
			}
			exports := getExportsOfModule(moduleSymbol)
			if exports {
				exports.forEach(func(TODO_IDENTIFIER /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					if id == "__export" {
						return
					}
					if flags & (SymbolFlagsNamespace | SymbolFlagsEnum) {
						return
					}
					exportedDeclarationsCount := countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)))
					if flags&SymbolFlagsTypeAlias && exportedDeclarationsCount <= 2 {
						return
					}
					if exportedDeclarationsCount > 1 {
						if !isDuplicatedCommonJSExport(declarations) {
							for _, declaration := range /* TODO(NonNullExpression): declarations! */ TODO {
								if isNotOverload(declaration) {
									diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)))
								}
							}
						}
					}
				})
			}
			links.exportsChecked = true
		}
	}
	isDuplicatedCommonJSExport := func(declarations /* TODO(ArrayType): Declaration[] */ any) /* TODO(undefined): boolean | undefined */ TODO {
		return declarations && declarations.length > 1 && declarations.every(func(d /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): isInJSFile(d) && isAccessExpression(d) */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(ParenthesizedExpression): (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression)) */
		})
	}
	checkSourceElement := func(node Node) {
		if node {
			saveCurrentNode := currentNode
			currentNode = node
			instantiationCount = 0
			checkSourceElementWorker(node)
			currentNode = saveCurrentNode
		}
	}
	checkSourceElementWorker := func(node Node) {
		if getNodeCheckFlags(node) & NodeCheckFlagsPartiallyTypeChecked {
			return
		}
		if canHaveJSDoc(node) {
			forEach(node.jsDoc, func(TODO_IDENTIFIER /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JSDoc */ TODO) {
				checkJSDocCommentWorker(comment)
				forEach(tags, func(tag /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocTag */ TODO) {
					checkJSDocCommentWorker(tag.comment)
					if isInJSFile(node) {
						checkSourceElement(tag)
					}
				})
			})
		}
		kind := node.kind
		if cancellationToken {
			/* TODO(SwitchStatement): switch (kind) {                 case SyntaxKind.ModuleDeclaration:                 case SyntaxKind.ClassDeclaration:                 case SyntaxKind.InterfaceDeclaration:                 case SyntaxKind.FunctionDeclaration:                     cancellationToken.throwIfCancellationRequested();             } */
		}
		if kind >= SyntaxKindFirstStatement && kind <= SyntaxKindLastStatement && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode) {
			errorOrSuggestion(compilerOptions.allowUnreachableCode == false, node, Diagnostics.Unreachable_code_detected)
		}
		/* TODO(SwitchStatement): switch (kind) {             case SyntaxKind.TypeParameter:                 return checkTypeParameter(node as TypeParameterDeclaration);             case SyntaxKind.Parameter:                 return checkParameter(node as ParameterDeclaration);             case SyntaxKind.PropertyDeclaration:                 return checkPropertyDeclaration(node as PropertyDeclaration);             case SyntaxKind.PropertySignature:                 return checkPropertySignature(node as PropertySignature);             case SyntaxKind.ConstructorType:             case SyntaxKind.FunctionType:             case SyntaxKind.CallSignature:             case SyntaxKind.ConstructSignature:             case SyntaxKind.IndexSignature:                 return checkSignatureDeclaration(node as SignatureDeclaration);             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 return checkMethodDeclaration(node as MethodDeclaration | MethodSignature);             case SyntaxKind.ClassStaticBlockDeclaration:                 return checkClassStaticBlockDeclaration(node as ClassStaticBlockDeclaration);             case SyntaxKind.Constructor:                 return checkConstructorDeclaration(node as ConstructorDeclaration);             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 return checkAccessorDeclaration(node as AccessorDeclaration);             case SyntaxKind.TypeReference:                 return checkTypeReferenceNode(node as TypeReferenceNode);             case SyntaxKind.TypePredicate:                 return checkTypePredicate(node as TypePredicateNode);             case SyntaxKind.TypeQuery:                 return checkTypeQuery(node as TypeQueryNode);             case SyntaxKind.TypeLiteral:                 return checkTypeLiteral(node as TypeLiteralNode);             case SyntaxKind.ArrayType:                 return checkArrayType(node as ArrayTypeNode);             case SyntaxKind.TupleType:                 return checkTupleType(node as TupleTypeNode);             case SyntaxKind.UnionType:             case SyntaxKind.IntersectionType:                 return checkUnionOrIntersectionType(node as UnionOrIntersectionTypeNode);             case SyntaxKind.ParenthesizedType:             case SyntaxKind.OptionalType:             case SyntaxKind.RestType:                 return checkSourceElement((node as ParenthesizedTypeNode | OptionalTypeNode | RestTypeNode).type);             case SyntaxKind.ThisType:                 return checkThisType(node as ThisTypeNode);             case SyntaxKind.TypeOperator:                 return checkTypeOperator(node as TypeOperatorNode);             case SyntaxKind.ConditionalType:                 return checkConditionalType(node as ConditionalTypeNode);             case SyntaxKind.InferType:                 return checkInferType(node as InferTypeNode);             case SyntaxKind.TemplateLiteralType:                 return checkTemplateLiteralType(node as TemplateLiteralTypeNode);             case SyntaxKind.ImportType:                 return checkImportType(node as ImportTypeNode);             case SyntaxKind.NamedTupleMember:                 return checkNamedTupleMember(node as NamedTupleMember);             case SyntaxKind.JSDocAugmentsTag:                 return checkJSDocAugmentsTag(node as JSDocAugmentsTag);             case SyntaxKind.JSDocImplementsTag:                 return checkJSDocImplementsTag(node as JSDocImplementsTag);             case SyntaxKind.JSDocTypedefTag:             case SyntaxKind.JSDocCallbackTag:             case SyntaxKind.JSDocEnumTag:                 return checkJSDocTypeAliasTag(node as JSDocTypedefTag);             case SyntaxKind.JSDocTemplateTag:                 return checkJSDocTemplateTag(node as JSDocTemplateTag);             case SyntaxKind.JSDocTypeTag:                 return checkJSDocTypeTag(node as JSDocTypeTag);             case SyntaxKind.JSDocLink:             case SyntaxKind.JSDocLinkCode:             case SyntaxKind.JSDocLinkPlain:                 return checkJSDocLinkLikeTag(node as JSDocLink | JSDocLinkCode | JSDocLinkPlain);             case SyntaxKind.JSDocParameterTag:                 return checkJSDocParameterTag(node as JSDocParameterTag);             case SyntaxKind.JSDocPropertyTag:                 return checkJSDocPropertyTag(node as JSDocPropertyTag);             case SyntaxKind.JSDocFunctionType:                 checkJSDocFunctionType(node as JSDocFunctionType);                 // falls through             case SyntaxKind.JSDocNonNullableType:             case SyntaxKind.JSDocNullableType:             case SyntaxKind.JSDocAllType:             case SyntaxKind.JSDocUnknownType:             case SyntaxKind.JSDocTypeLiteral:                 checkJSDocTypeIsInJsFile(node);                 forEachChild(node, checkSourceElement);                 return;             case SyntaxKind.JSDocVariadicType:                 checkJSDocVariadicType(node as JSDocVariadicType);                 return;             case SyntaxKind.JSDocTypeExpression:                 return checkSourceElement((node as JSDocTypeExpression).type);             case SyntaxKind.JSDocPublicTag:             case SyntaxKind.JSDocProtectedTag:             case SyntaxKind.JSDocPrivateTag:                 return checkJSDocAccessibilityModifiers(node as JSDocPublicTag | JSDocProtectedTag | JSDocPrivateTag);             case SyntaxKind.JSDocSatisfiesTag:                 return checkJSDocSatisfiesTag(node as JSDocSatisfiesTag);             case SyntaxKind.JSDocThisTag:                 return checkJSDocThisTag(node as JSDocThisTag);             case SyntaxKind.JSDocImportTag:                 return checkJSDocImportTag(node as JSDocImportTag);             case SyntaxKind.IndexedAccessType:                 return checkIndexedAccessType(node as IndexedAccessTypeNode);             case SyntaxKind.MappedType:                 return checkMappedType(node as MappedTypeNode);             case SyntaxKind.FunctionDeclaration:                 return checkFunctionDeclaration(node as FunctionDeclaration);             case SyntaxKind.Block:             case SyntaxKind.ModuleBlock:                 return checkBlock(node as Block);             case SyntaxKind.VariableStatement:                 return checkVariableStatement(node as VariableStatement);             case SyntaxKind.ExpressionStatement:                 return checkExpressionStatement(node as ExpressionStatement);             case SyntaxKind.IfStatement:                 return checkIfStatement(node as IfStatement);             case SyntaxKind.DoStatement:                 return checkDoStatement(node as DoStatement);             case SyntaxKind.WhileStatement:                 return checkWhileStatement(node as WhileStatement);             case SyntaxKind.ForStatement:                 return checkForStatement(node as ForStatement);             case SyntaxKind.ForInStatement:                 return checkForInStatement(node as ForInStatement);             case SyntaxKind.ForOfStatement:                 return checkForOfStatement(node as ForOfStatement);             case SyntaxKind.ContinueStatement:             case SyntaxKind.BreakStatement:                 return checkBreakOrContinueStatement(node as BreakOrContinueStatement);             case SyntaxKind.ReturnStatement:                 return checkReturnStatement(node as ReturnStatement);             case SyntaxKind.WithStatement:                 return checkWithStatement(node as WithStatement);             case SyntaxKind.SwitchStatement:                 return checkSwitchStatement(node as SwitchStatement);             case SyntaxKind.LabeledStatement:                 return checkLabeledStatement(node as LabeledStatement);             case SyntaxKind.ThrowStatement:                 return checkThrowStatement(node as ThrowStatement);             case SyntaxKind.TryStatement:                 return checkTryStatement(node as TryStatement);             case SyntaxKind.VariableDeclaration:                 return checkVariableDeclaration(node as VariableDeclaration);             case SyntaxKind.BindingElement:                 return checkBindingElement(node as BindingElement);             case SyntaxKind.ClassDeclaration:                 return checkClassDeclaration(node as ClassDeclaration);             case SyntaxKind.InterfaceDeclaration:                 return checkInterfaceDeclaration(node as InterfaceDeclaration);             case SyntaxKind.TypeAliasDeclaration:                 return checkTypeAliasDeclaration(node as TypeAliasDeclaration);             case SyntaxKind.EnumDeclaration:                 return checkEnumDeclaration(node as EnumDeclaration);             case SyntaxKind.ModuleDeclaration:                 return checkModuleDeclaration(node as ModuleDeclaration);             case SyntaxKind.ImportDeclaration:                 return checkImportDeclaration(node as ImportDeclaration);             case SyntaxKind.ImportEqualsDeclaration:                 return checkImportEqualsDeclaration(node as ImportEqualsDeclaration);             case SyntaxKind.ExportDeclaration:                 return checkExportDeclaration(node as ExportDeclaration);             case SyntaxKind.ExportAssignment:                 return checkExportAssignment(node as ExportAssignment);             case SyntaxKind.EmptyStatement:             case SyntaxKind.DebuggerStatement:                 checkGrammarStatementInAmbientContext(node);                 return;             case SyntaxKind.MissingDeclaration:                 return checkMissingDeclaration(node);         } */
	}
	checkJSDocCommentWorker := func(node /* TODO(UnionType): string | readonly JSDocComment[] | undefined */ any) {
		if isArray(node) {
			forEach(node, func(tag /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").JSDocComment */ TODO) {
				if isJSDocLinkLike(tag) {
					checkSourceElement(tag)
				}
			})
		}
	}
	checkJSDocTypeIsInJsFile := func(node Node) {
		if !isInJSFile(node) {
			if isJSDocNonNullableType(node) || isJSDocNullableType(node) {
				token := tokenToString( /* TODO(ConditionalExpression): isJSDocNonNullableType(node) ? SyntaxKind.ExclamationToken : SyntaxKind.QuestionToken */ TODO)
				diagnostic := /* TODO(ConditionalExpression): node.postfix                     ? Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1                     : Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 */ TODO
				typeNode := node.type_
				type_ := getTypeFromTypeNode(typeNode)
				grammarErrorOnNode(node, diagnostic, token, typeToString( /* TODO(ConditionalExpression): isJSDocNullableType(node) && !(type === neverType || type === voidType)                             ? getUnionType(append([type, undefinedType], node.postfix ? undefined : nullType)) : type */ TODO))
			} else {
				grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments)
			}
		}
	}
	checkJSDocVariadicType := func(node JSDocVariadicType) {
		checkJSDocTypeIsInJsFile(node)
		checkSourceElement(node.type_)
		TODO_IDENTIFIER := node
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): last(parent.parent.parameters) !== parent */ TODO {
				error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
			}
			return
		}
		if !isJSDocTypeExpression(parent) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
		}
		paramTag := node.parent.parent
		if !isJSDocParameterTag(paramTag) {
			error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature)
			return
		}
		param := getParameterSymbolFromJSDoc(paramTag)
		if !param {
			return
		}
		host := getHostSignatureFromJSDoc(paramTag)
		if !host || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): last(host.parameters).symbol !== param */ TODO {
			error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list)
		}
	}
	getTypeFromJSDocVariadicType := func(node JSDocVariadicType) Type {
		type_ := getTypeFromTypeNode(node.type_)
		TODO_IDENTIFIER := node
		paramTag := node.parent.parent
		if isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag) {
			host := getHostSignatureFromJSDoc(paramTag)
			isCallbackTag := isJSDocCallbackTag(paramTag.parent.parent)
			if host || isCallbackTag {
				lastParamDeclaration := /* TODO(ConditionalExpression): isCallbackTag                     ? lastOrUndefined((paramTag.parent.parent as unknown as JSDocCallbackTag).typeExpression.parameters)                     : lastOrUndefined(host!.parameters) */ TODO
				symbol := getParameterSymbolFromJSDoc(paramTag)
				if !lastParamDeclaration || symbol && lastParamDeclaration.symbol == symbol && isRestParameter(lastParamDeclaration) {
					return createArrayType(type_)
				}
			}
		}
		if isParameter(parent) && isJSDocFunctionType(parent.parent) {
			return createArrayType(type_)
		}
		return addOptionality(type_)
	}
	checkNodeDeferred := func(node Node) {
		enclosingFile := getSourceFileOfNode(node)
		links := getNodeLinks(enclosingFile)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			/* TODO(ExpressionStatement): links.deferredNodes ||= new Set(); */
			links.deferredNodes.add(node)
		} else {
			Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.")
		}
	}
	checkDeferredNodes := func(context SourceFile) {
		links := getNodeLinks(context)
		if links.deferredNodes {
			links.deferredNodes.forEach(checkDeferredNode)
		}
		links.deferredNodes = nil
	}
	checkDeferredNode := func(node Node) {
		tracing.push(tracing.Phase.Check, "checkDeferredNode" /* TODO(ObjectLiteralExpression): { kind: node.kind, pos: node.pos, end: node.end, path: (node as TracingNode).tracingPath } */, TODO)
		saveCurrentNode := currentNode
		currentNode = node
		instantiationCount = 0
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.CallExpression:             case SyntaxKind.NewExpression:             case SyntaxKind.TaggedTemplateExpression:             case SyntaxKind.Decorator:             case SyntaxKind.JsxOpeningElement:                 // These node kinds are deferred checked when overload resolution fails                 // To save on work, we ensure the arguments are checked just once, in                 // a deferred way                 resolveUntypedCall(node as CallLikeExpression);                 break;             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:                 checkFunctionExpressionOrObjectLiteralMethodDeferred(node as FunctionExpression);                 break;             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:                 checkAccessorDeclaration(node as AccessorDeclaration);                 break;             case SyntaxKind.ClassExpression:                 checkClassExpressionDeferred(node as ClassExpression);                 break;             case SyntaxKind.TypeParameter:                 checkTypeParameterDeferred(node as TypeParameterDeclaration);                 break;             case SyntaxKind.JsxSelfClosingElement:                 checkJsxSelfClosingElementDeferred(node as JsxSelfClosingElement);                 break;             case SyntaxKind.JsxElement:                 checkJsxElementDeferred(node as JsxElement);                 break;             case SyntaxKind.TypeAssertionExpression:             case SyntaxKind.AsExpression:             case SyntaxKind.ParenthesizedExpression:                 checkAssertionDeferred(node as AssertionExpression | JSDocTypeAssertion);                 break;             case SyntaxKind.VoidExpression:                 checkExpression((node as VoidExpression).expression);                 break;             case SyntaxKind.BinaryExpression:                 if (isInstanceOfExpression(node)) {                     resolveUntypedCall(node);                 }                 break;         } */
		currentNode = saveCurrentNode
		tracing.pop()
	}
	checkSourceFile := func(node SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) {
		tracing.push(tracing.Phase.Check /* TODO(ConditionalExpression): nodesToCheck ? "checkSourceFileNodes" : "checkSourceFile" */, TODO /* TODO(ObjectLiteralExpression): { path: node.path } */, TODO, true)
		beforeMark := /* TODO(ConditionalExpression): nodesToCheck ? "beforeCheckNodes" : "beforeCheck" */ TODO
		afterMark := /* TODO(ConditionalExpression): nodesToCheck ? "afterCheckNodes" : "afterCheck" */ TODO
		performance.mark(beforeMark)
		/* TODO(ExpressionStatement): nodesToCheck ? checkSourceFileNodesWorker(node, nodesToCheck) : checkSourceFileWorker(node); */
		performance.mark(afterMark)
		performance.measure("Check", beforeMark, afterMark)
		tracing.pop()
	}
	unusedIsError := func(kind UnusedKind, isAmbient bool) bool {
		if isAmbient {
			return false
		}
		/* TODO(SwitchStatement): switch (kind) {             case UnusedKind.Local:                 return !!compilerOptions.noUnusedLocals;             case UnusedKind.Parameter:                 return !!compilerOptions.noUnusedParameters;             default:                 return Debug.assertNever(kind);         } */
	}
	getPotentiallyUnusedIdentifiers := func(sourceFile SourceFile) []PotentiallyUnusedIdentifier {
		return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray
	}
	checkSourceFileWorker := func(node SourceFile) {
		links := getNodeLinks(node)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(node, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(node)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			if links.flags & NodeCheckFlagsPartiallyTypeChecked {
				potentialThisCollisions = /* TODO(NonNullExpression): links.potentialThisCollisions! */ TODO
				potentialNewTargetCollisions = /* TODO(NonNullExpression): links.potentialNewTargetCollisions! */ TODO
				potentialWeakMapSetCollisions = /* TODO(NonNullExpression): links.potentialWeakMapSetCollisions! */ TODO
				potentialReflectCollisions = /* TODO(NonNullExpression): links.potentialReflectCollisions! */ TODO
				potentialUnusedRenamedBindingElementsInTypes = /* TODO(NonNullExpression): links.potentialUnusedRenamedBindingElementsInTypes! */ TODO
			}
			forEach(node.statements, checkSourceElement)
			checkSourceElement(node.endOfFileToken)
			checkDeferredNodes(node)
			if isExternalOrCommonJsModule(node) {
				registerForUnusedIdentifiersCheck(node)
			}
			addLazyDiagnostic(func() {
				if !node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters) {
					checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), func(containingNode /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO, kind /* TODO(undefined): UnusedKind */ TODO, diag /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO) {
						if !containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags&NodeFlagsAmbient)) {
							diagnostics.add(diag)
						}
					})
				}
				if !node.isDeclarationFile {
					checkPotentialUncheckedRenamedBindingElementsInTypes()
				}
			})
			if isExternalOrCommonJsModule(node) {
				checkExternalModuleExports(node)
			}
			if potentialThisCollisions.length {
				forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope)
				clear(potentialThisCollisions)
			}
			if potentialNewTargetCollisions.length {
				forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope)
				clear(potentialNewTargetCollisions)
			}
			if potentialWeakMapSetCollisions.length {
				forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision)
				clear(potentialWeakMapSetCollisions)
			}
			if potentialReflectCollisions.length {
				forEach(potentialReflectCollisions, checkReflectCollision)
				clear(potentialReflectCollisions)
			}
			links.flags |= NodeCheckFlagsTypeChecked
		}
	}
	checkSourceFileNodesWorker := func(file SourceFile, nodes []Node) {
		links := getNodeLinks(file)
		if !(links.flags & NodeCheckFlagsTypeChecked) {
			if skipTypeChecking(file, compilerOptions, host) {
				return
			}
			checkGrammarSourceFile(file)
			clear(potentialThisCollisions)
			clear(potentialNewTargetCollisions)
			clear(potentialWeakMapSetCollisions)
			clear(potentialReflectCollisions)
			clear(potentialUnusedRenamedBindingElementsInTypes)
			forEach(nodes, checkSourceElement)
			checkDeferredNodes(file)
			(links.potentialThisCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialThisCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialThisCollisions */ TODO)
			(links.potentialNewTargetCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialNewTargetCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialNewTargetCollisions */ TODO)
			(links.potentialWeakMapSetCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialWeakMapSetCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialWeakMapSetCollisions */ TODO)
			(links.potentialReflectCollisions || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialReflectCollisions = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialReflectCollisions */ TODO)
			(links.potentialUnusedRenamedBindingElementsInTypes || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.potentialUnusedRenamedBindingElementsInTypes = [] */ TODO)).push( /* TODO(SpreadElement): ...potentialUnusedRenamedBindingElementsInTypes */ TODO)
			links.flags |= NodeCheckFlagsPartiallyTypeChecked
			for _, node := range nodes {
				nodeLinks := getNodeLinks(node)
				nodeLinks.flags |= NodeCheckFlagsPartiallyTypeChecked
			}
		}
	}
	getDiagnostics := func(sourceFile SourceFile, ct CancellationToken, nodesToCheck []Node) []Diagnostic {
		/* TODO(TryStatement): try {             // Record the cancellation token so it can be checked later on during checkSourceElement.             // Do this in a finally block so we can ensure that it gets reset back to nothing after             // this call is done.             cancellationToken = ct;             return getDiagnosticsWorker(sourceFile, nodesToCheck);         }         finally {             cancellationToken = undefined;         } */
	}
	ensurePendingDiagnosticWorkComplete := func() {
		for _, cb := range deferredDiagnosticsCallbacks {
			cb()
		}
		deferredDiagnosticsCallbacks = /* TODO(ArrayLiteralExpression): [] */ TODO
	}
	checkSourceFileWithEagerDiagnostics := func(sourceFile SourceFile, nodesToCheck []Node) {
		ensurePendingDiagnosticWorkComplete()
		oldAddLazyDiagnostics := addLazyDiagnostic
		addLazyDiagnostic = func(cb /* TODO(undefined): () => void */ TODO) {
			/* TODO(Identifier): cb */
		}
		checkSourceFile(sourceFile, nodesToCheck)
		addLazyDiagnostic = oldAddLazyDiagnostics
	}
	getDiagnosticsWorker := func(sourceFile SourceFile, nodesToCheck /* TODO(ArrayType): Node[] */ any) []Diagnostic {
		if sourceFile {
			ensurePendingDiagnosticWorkComplete()
			previousGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			previousGlobalDiagnosticsSize := previousGlobalDiagnostics.length
			checkSourceFileWithEagerDiagnostics(sourceFile, nodesToCheck)
			semanticDiagnostics := diagnostics.getDiagnostics(sourceFile.fileName)
			if nodesToCheck {
				return semanticDiagnostics
			}
			currentGlobalDiagnostics := diagnostics.getGlobalDiagnostics()
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): currentGlobalDiagnostics !== previousGlobalDiagnostics */ TODO {
				deferredGlobalDiagnostics := relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics)
				return concatenate(deferredGlobalDiagnostics, semanticDiagnostics)
			} else if previousGlobalDiagnosticsSize == 0 && currentGlobalDiagnostics.length > 0 {
				return concatenate(currentGlobalDiagnostics, semanticDiagnostics)
			}
			return semanticDiagnostics
		}
		forEach(host.getSourceFiles(), func(file /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").SourceFile */ TODO) {
			/* TODO(Identifier): checkSourceFileWithEagerDiagnostics */
			/* TODO(Identifier): file */
		})
		return diagnostics.getDiagnostics()
	}
	getGlobalDiagnostics := func() []Diagnostic {
		ensurePendingDiagnosticWorkComplete()
		return diagnostics.getGlobalDiagnostics()
	}
	getSymbolsInScope := func(location Node, meaning SymbolFlags) []Symbol {
		if location.flags & NodeFlagsInWithStatement {
			return /* TODO(ArrayLiteralExpression): [] */ TODO
		}
		symbols := createSymbolTable()
		isStaticSymbol := false
		populateSymbols()
		symbols.delete(InternalSymbolNameThis)
		return symbolsToArray(symbols)
		populateSymbols := func() {
			/* TODO(WhileStatement): while (location) {                 if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {                     copySymbols(location.locals, meaning);                 }                  switch (location.kind) {                     case SyntaxKind.SourceFile:                         if (!isExternalModule(location as SourceFile)) break;                         // falls through                     case SyntaxKind.ModuleDeclaration:                         copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location as ModuleDeclaration | SourceFile).exports!, meaning & SymbolFlags.ModuleMember);                         break;                     case SyntaxKind.EnumDeclaration:                         copySymbols(getSymbolOfDeclaration(location as EnumDeclaration).exports!, meaning & SymbolFlags.EnumMember);                         break;                     case SyntaxKind.ClassExpression:                         const className = (location as ClassExpression).name;                         if (className) {                             copySymbol((location as ClassExpression).symbol, meaning);                         }                      // this fall-through is necessary because we would like to handle                     // type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration.                     // falls through                     case SyntaxKind.ClassDeclaration:                     case SyntaxKind.InterfaceDeclaration:                         // If we didn't come from static member of class or interface,                         // add the type parameters into the symbol table                         // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.                         // Note: that the memberFlags come from previous iteration.                         if (!isStaticSymbol) {                             copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location as ClassDeclaration | InterfaceDeclaration)), meaning & SymbolFlags.Type);                         }                         break;                     case SyntaxKind.FunctionExpression:                         const funcName = (location as FunctionExpression).name;                         if (funcName) {                             copySymbol((location as FunctionExpression).symbol, meaning);                         }                         break;                 }                  if (introducesArgumentsExoticObject(location)) {                     copySymbol(argumentsSymbol, meaning);                 }                  isStaticSymbol = isStatic(location);                 location = location.parent;             } */
			copySymbols(globals, meaning)
		}
		copySymbol := func(symbol Symbol, meaning SymbolFlags) {
			if getCombinedLocalAndExportSymbolFlags(symbol) & meaning {
				id := symbol.escapedName
				if !symbols.has(id) {
					symbols.set(id, symbol)
				}
			}
		}
		copySymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
					copySymbol(symbol, meaning)
				})
			}
		}
		copyLocallyVisibleExportSymbols := func(source SymbolTable, meaning SymbolFlags) {
			if meaning {
				source.forEach(func(symbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
					if !getDeclarationOfKind(symbol, SyntaxKindExportSpecifier) && !getDeclarationOfKind(symbol, SyntaxKindNamespaceExport) && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbol.escapedName !== InternalSymbolName.Default */ TODO {
						copySymbol(symbol, meaning)
					}
				})
			}
		}
	}
	isTypeDeclarationName := func(name Node) bool {
		return name.kind == SyntaxKindIdentifier && isTypeDeclaration(name.parent) && getNameOfDeclaration(name.parent) == name
	}
	isTypeReferenceIdentifier := func(node EntityName) bool {
		/* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.QualifiedName) {             node = node.parent as QualifiedName;         } */
		return node.parent.kind == SyntaxKindTypeReference
	}
	isInNameOfExpressionWithTypeArguments := func(node Node) bool {
		/* TODO(WhileStatement): while (node.parent.kind === SyntaxKind.PropertyAccessExpression) {             node = node.parent;         } */
		return node.parent.kind == SyntaxKindExpressionWithTypeArguments
	}
	forEachEnclosingClass := func(node Node, callback func(node ClassLikeDeclaration) *T) *T {
		var result *T
		containingClass := getContainingClass(node)
		/* TODO(WhileStatement): while (containingClass) {             if (result = callback(containingClass)) break;             containingClass = getContainingClass(containingClass);         } */
		return result
	}
	isNodeUsedDuringClassInitialization := func(node Node) /* TODO(undefined): boolean */ TODO {
		return !!findAncestor(node, func(element /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean | "quit" */ TODO {
			if isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element) {
				return true
			} else if isClassLike(element) || isFunctionLikeDeclaration(element) {
				return "quit"
			}
			return false
		})
	}
	isNodeWithinClass := func(node Node, classDeclaration ClassLikeDeclaration) /* TODO(undefined): boolean */ TODO {
		return !!forEachEnclosingClass(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ClassLikeDeclaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(Identifier): n */
			/* TODO(EqualsEqualsEqualsToken): === */
			/* TODO(Identifier): classDeclaration */
		})
	}
	getLeftSideOfImportEqualsOrExportAssignment := func(nodeOnRightSide EntityName) /* TODO(UnionType): ImportEqualsDeclaration | ExportAssignment | undefined */ any {
		/* TODO(WhileStatement): while (nodeOnRightSide.parent.kind === SyntaxKind.QualifiedName) {             nodeOnRightSide = nodeOnRightSide.parent as QualifiedName;         } */
		if nodeOnRightSide.parent.kind == SyntaxKindImportEqualsDeclaration {
			return /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ImportEqualsDeclaration).moduleReference === nodeOnRightSide ? nodeOnRightSide.parent as ImportEqualsDeclaration : undefined */ TODO
		}
		if nodeOnRightSide.parent.kind == SyntaxKindExportAssignment {
			return /* TODO(ConditionalExpression): (nodeOnRightSide.parent as ExportAssignment).expression === nodeOnRightSide as Node ? nodeOnRightSide.parent as ExportAssignment : undefined */ TODO
		}
		return nil
	}
	isInRightSideOfImportOrExportAssignment := func(node EntityName) /* TODO(undefined): boolean */ TODO {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined */ TODO
	}
	getSpecialPropertyAssignmentSymbolFromEntityName := func(entityName /* TODO(UnionType): EntityName | PropertyAccessExpression */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		specialPropertyAssignmentKind := getAssignmentDeclarationKind(entityName.parent.parent /* as */ /* TODO(TypeReference): BinaryExpression */)
		/* TODO(SwitchStatement): switch (specialPropertyAssignmentKind) {             case AssignmentDeclarationKind.ExportsProperty:             case AssignmentDeclarationKind.PrototypeProperty:                 return getSymbolOfNode(entityName.parent);             case AssignmentDeclarationKind.Property:                 if (isPropertyAccessExpression(entityName.parent) && getLeftmostAccessExpression(entityName.parent) === entityName) {                     return undefined;                 }                 // falls through             case AssignmentDeclarationKind.ThisProperty:             case AssignmentDeclarationKind.ModuleExports:                 return getSymbolOfDeclaration(entityName.parent.parent as BinaryExpression);         } */
	}
	isImportTypeQualifierPart := func(node EntityName) *ImportTypeNode {
		parent := node.parent
		/* TODO(WhileStatement): while (isQualifiedName(parent)) {             node = parent;             parent = parent.parent;         } */
		if parent && parent.kind == SyntaxKindImportType && (parent /* as */ /* TODO(TypeReference): ImportTypeNode */).qualifier == node {
			return parent /* as */ /* TODO(TypeReference): ImportTypeNode */
		}
		return nil
	}
	isThisPropertyAndThisTyped := func(node PropertyAccessExpression) /* TODO(undefined): boolean | undefined */ TODO {
		if node.expression.kind == SyntaxKindThisKeyword {
			container := getThisContainer(node, false, false)
			if isFunctionLike(container) {
				containingLiteral := getContainingObjectLiteral(container)
				if containingLiteral {
					contextualType := getApparentTypeOfContextualType(containingLiteral, nil)
					type_ := getThisTypeOfObjectLiteralFromContextualType(containingLiteral, contextualType)
					return type_ && !isTypeAny(type_)
				}
			}
		}
	}
	getSymbolOfNameOrPropertyAccessExpression := func(name /* TODO(UnionType): EntityName | PrivateIdentifier | PropertyAccessExpression | JSDocMemberName */ any) *Symbol {
		if isDeclarationName(name) {
			return getSymbolOfNode(name.parent)
		}
		if isInJSFile(name) && name.parent.kind == SyntaxKindPropertyAccessExpression && name.parent == (name.parent.parent /* as */ /* TODO(TypeReference): BinaryExpression */).left {
			if !isPrivateIdentifier(name) && !isJSDocMemberName(name) && !isThisPropertyAndThisTyped(name.parent /* as */ /* TODO(TypeReference): PropertyAccessExpression */) {
				specialPropertyAssignmentSymbol := getSpecialPropertyAssignmentSymbolFromEntityName(name)
				if specialPropertyAssignmentSymbol {
					return specialPropertyAssignmentSymbol
				}
			}
		}
		if name.parent.kind == SyntaxKindExportAssignment && isEntityNameExpression(name) {
			success := resolveEntityName(name, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias, true)
			if success && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): success !== unknownSymbol */ TODO {
				return success
			}
		} else if isEntityName(name) && isInRightSideOfImportOrExportAssignment(name) {
			importEqualsDeclaration := getAncestor(name, SyntaxKindImportEqualsDeclaration)
			Debug.assert( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): importEqualsDeclaration !== undefined */ TODO)
			return getSymbolOfPartOfRightHandSideOfImportEquals(name, true)
		}
		if isEntityName(name) {
			possibleImportNode := isImportTypeQualifierPart(name)
			if possibleImportNode {
				getTypeFromTypeNode(possibleImportNode)
				sym := getNodeLinks(name).resolvedSymbol
				return /* TODO(ConditionalExpression): sym === unknownSymbol ? undefined : sym */ TODO
			}
		}
		/* TODO(WhileStatement): while (isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {             name = name.parent as QualifiedName | PropertyAccessEntityNameExpression | JSDocMemberName;         } */
		if isInNameOfExpressionWithTypeArguments(name) {
			meaning := SymbolFlagsNone
			if name.parent.kind == SyntaxKindExpressionWithTypeArguments {
				meaning = /* TODO(ConditionalExpression): isPartOfTypeNode(name) ? SymbolFlags.Type : SymbolFlags.Value */ TODO
				if isExpressionWithTypeArgumentsInClassExtendsClause(name.parent) {
					meaning |= SymbolFlagsValue
				}
			} else {
				meaning = SymbolFlagsNamespace
			}
			meaning |= SymbolFlagsAlias
			entityNameSymbol := /* TODO(ConditionalExpression): isEntityNameExpression(name) ? resolveEntityName(name, meaning, /*ignoreErrors* / true) : undefined */ TODO
			if entityNameSymbol {
				return entityNameSymbol
			}
		}
		if name.parent.kind == SyntaxKindJSDocParameterTag {
			return getParameterSymbolFromJSDoc(name.parent /* as */ /* TODO(TypeReference): JSDocParameterTag */)
		}
		if name.parent.kind == SyntaxKindTypeParameter && name.parent.parent.kind == SyntaxKindJSDocTemplateTag {
			Debug.assert(!isInJSFile(name))
			typeParameter := getTypeParameterFromJsDoc(name.parent /* as */ /* TODO(IntersectionType): TypeParameterDeclaration & { parent: JSDocTemplateTag; } */)
			return typeParameter && typeParameter.symbol
		}
		if isExpressionNode(name) {
			if nodeIsMissing(name) {
				return nil
			}
			isJSDoc := findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName))
			meaning := /* TODO(ConditionalExpression): isJSDoc ? SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Value : SymbolFlags.Value */ TODO
			if name.kind == SyntaxKindIdentifier {
				if isJSXTagName(name) && isJsxIntrinsicTagName(name) {
					symbol := getIntrinsicTagSymbol(name.parent /* as */ /* TODO(TypeReference): JsxOpeningLikeElement */)
					return /* TODO(ConditionalExpression): symbol === unknownSymbol ? undefined : symbol */ TODO
				}
				result := resolveEntityName(name, meaning, true, true, getHostSignatureFromJSDoc(name))
				if !result && isJSDoc {
					container := findAncestor(name, or(isClassLike, isInterfaceDeclaration))
					if container {
						return resolveJSDocMemberName(name, true, getSymbolOfDeclaration(container))
					}
				}
				if result && isJSDoc {
					container := getJSDocHost(name)
					if container && isEnumMember(container) && container == result.valueDeclaration {
						return resolveEntityName(name, meaning, true, true, getSourceFileOfNode(container)) || result
					}
				}
				return result
			} else if isPrivateIdentifier(name) {
				return getSymbolForPrivateIdentifierExpression(name)
			} else if name.kind == SyntaxKindPropertyAccessExpression || name.kind == SyntaxKindQualifiedName {
				links := getNodeLinks(name)
				if links.resolvedSymbol {
					return links.resolvedSymbol
				}
				if name.kind == SyntaxKindPropertyAccessExpression {
					checkPropertyAccessExpression(name, CheckModeNormal)
					if !links.resolvedSymbol {
						links.resolvedSymbol = getApplicableIndexSymbol(checkExpressionCached(name.expression), getLiteralTypeFromPropertyName(name.name))
					}
				} else {
					checkQualifiedName(name, CheckModeNormal)
				}
				if !links.resolvedSymbol && isJSDoc && isQualifiedName(name) {
					return resolveJSDocMemberName(name)
				}
				return links.resolvedSymbol
			} else if isJSDocMemberName(name) {
				return resolveJSDocMemberName(name)
			}
		} else if isTypeReferenceIdentifier(name /* as */ /* TODO(TypeReference): EntityName */) {
			meaning := /* TODO(ConditionalExpression): name.parent.kind === SyntaxKind.TypeReference ? SymbolFlags.Type : SymbolFlags.Namespace */ TODO
			symbol := resolveEntityName(name /* as */ /* TODO(TypeReference): EntityName */, meaning, false, true)
			return /* TODO(ConditionalExpression): symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name as EntityName) */ TODO
		}
		if name.parent.kind == SyntaxKindTypePredicate {
			return resolveEntityName(name /* as */ /* TODO(TypeReference): Identifier */, SymbolFlagsFunctionScopedVariable)
		}
		return nil
	}
	getApplicableIndexSymbol := func(type_ Type, keyType Type) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		infos := getApplicableIndexInfos(type_, keyType)
		if infos.length && (type_ /* as */ /* TODO(TypeReference): ObjectType */).members {
			symbol := getIndexSymbolFromSymbolTable(resolveStructuredTypeMembers(type_ /* as */ /* TODO(TypeReference): ObjectType */).members)
			if infos == getIndexInfosOfType(type_) {
				return symbol
			} else if symbol {
				symbolLinks := getSymbolLinks(symbol)
				declarationList := mapDefined(infos, func(i /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined */ TODO {
					/* TODO(Identifier): i */
					/* TODO(Identifier): declaration */
				})
				nodeListId := map_(declarationList, getNodeId).join(",")
				if !symbolLinks.filteredIndexSymbolCache {
					symbolLinks.filteredIndexSymbolCache = /* TODO(NewExpression): new Map() */ TODO
				}
				if symbolLinks.filteredIndexSymbolCache.has(nodeListId) {
					return /* TODO(NonNullExpression): symbolLinks.filteredIndexSymbolCache.get(nodeListId)! */ TODO
				} else {
					copy := createSymbol(SymbolFlagsSignature, InternalSymbolNameIndex)
					copy.declarations = mapDefined(infos, func(i /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").IndexSignatureDeclaration | undefined */ TODO {
						/* TODO(Identifier): i */
						/* TODO(Identifier): declaration */
					})
					copy.parent = /* TODO(ConditionalExpression): type.aliasSymbol ? type.aliasSymbol : type.symbol ? type.symbol : getSymbolAtLocation(copy.declarations[0].parent) */ TODO
					symbolLinks.filteredIndexSymbolCache.set(nodeListId, copy)
					return copy
				}
			}
		}
	}
	resolveJSDocMemberName := func(name /* TODO(UnionType): EntityName | JSDocMemberName */ any, ignoreErrors bool, container Symbol) *Symbol {
		if isEntityName(name) {
			meaning := SymbolFlagsType | SymbolFlagsNamespace | SymbolFlagsValue
			symbol := resolveEntityName(name, meaning, ignoreErrors, true, getHostSignatureFromJSDoc(name))
			if !symbol && isIdentifier(name) && container {
				symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning))
			}
			if symbol {
				return symbol
			}
		}
		left := /* TODO(ConditionalExpression): isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container) */ TODO
		right := /* TODO(ConditionalExpression): isIdentifier(name) ? name.escapedText : name.right.escapedText */ TODO
		if left {
			proto := left.flags&SymbolFlagsValue && getPropertyOfType(getTypeOfSymbol(left), "prototype" /* as */ /* TODO(TypeReference): __String */)
			t := /* TODO(ConditionalExpression): proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left) */ TODO
			return getPropertyOfType(t, right)
		}
	}
	getSymbolAtLocation := func(node Node, ignoreErrors bool) *Symbol {
		if isSourceFile(node) {
			return /* TODO(ConditionalExpression): isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined */ TODO
		}
		TODO_IDENTIFIER := node
		grandParent := parent.parent
		if node.flags & NodeFlagsInWithStatement {
			return nil
		}
		if isDeclarationNameOrImportPropertyName(node) {
			parentSymbol := getSymbolOfDeclaration(parent /* as */ /* TODO(TypeReference): Declaration */)
			return /* TODO(ConditionalExpression): isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node                 ? getImmediateAliasedSymbol(parentSymbol)                 : parentSymbol */ TODO
		} else if isLiteralComputedPropertyDeclarationName(node) {
			return getSymbolOfDeclaration(parent.parent /* as */ /* TODO(TypeReference): Declaration */)
		}
		if node.kind == SyntaxKindIdentifier {
			if isInRightSideOfImportOrExportAssignment(node /* as */ /* TODO(TypeReference): Identifier */) {
				return getSymbolOfNameOrPropertyAccessExpression(node /* as */ /* TODO(TypeReference): Identifier */)
			} else if parent.kind == SyntaxKindBindingElement && grandParent.kind == SyntaxKindObjectBindingPattern && node == (parent /* as */ /* TODO(TypeReference): BindingElement */).propertyName {
				typeOfPattern := getTypeOfNode(grandParent)
				propertyDeclaration := getPropertyOfType(typeOfPattern, (node /* as */ /* TODO(TypeReference): Identifier */).escapedText)
				if propertyDeclaration {
					return propertyDeclaration
				}
			} else if isMetaProperty(parent) && parent.name == node {
				if parent.keywordToken == SyntaxKindNewKeyword && idText(node /* as */ /* TODO(TypeReference): Identifier */) == "target" {
					return checkNewTargetMetaProperty(parent).symbol
				}
				if parent.keywordToken == SyntaxKindImportKeyword && idText(node /* as */ /* TODO(TypeReference): Identifier */) == "meta" {
					return /* TODO(NonNullExpression): getGlobalImportMetaExpressionType().members! */ TODO.get("meta" /* as */ /* TODO(TypeReference): __String */)
				}
				return nil
			}
		}
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.Identifier:             case SyntaxKind.PrivateIdentifier:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.QualifiedName:                 if (!isThisInTypeQuery(node)) {                     return getSymbolOfNameOrPropertyAccessExpression(node as EntityName | PrivateIdentifier | PropertyAccessExpression);                 }                 // falls through              case SyntaxKind.ThisKeyword:                 const container = getThisContainer(node, /*includeArrowFunctions* / false, /*includeClassComputedPropertyName* / false);                 if (isFunctionLike(container)) {                     const sig = getSignatureFromDeclaration(container);                     if (sig.thisParameter) {                         return sig.thisParameter;                     }                 }                 if (isInExpressionContext(node)) {                     return checkExpression(node as Expression).symbol;                 }                 // falls through              case SyntaxKind.ThisType:                 return getTypeFromThisTypeNode(node as ThisExpression | ThisTypeNode).symbol;              case SyntaxKind.SuperKeyword:                 return checkExpression(node as Expression).symbol;              case SyntaxKind.ConstructorKeyword:                 // constructor keyword for an overload, should take us to the definition if it exist                 const constructorDeclaration = node.parent;                 if (constructorDeclaration && constructorDeclaration.kind === SyntaxKind.Constructor) {                     return (constructorDeclaration.parent as ClassDeclaration).symbol;                 }                 return undefined;              case SyntaxKind.StringLiteral:             case SyntaxKind.NoSubstitutionTemplateLiteral:                 // 1). import x = require("./mo/*gotToDefinitionHere* /d")                 // 2). External module name in an import declaration                 // 3). Dynamic import call or require in javascript                 // 4). type A = import("./f/*gotToDefinitionHere* /oo")                 if (                     (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||                     ((node.parent.kind === SyntaxKind.ImportDeclaration || node.parent.kind === SyntaxKind.ExportDeclaration) && (node.parent as ImportDeclaration).moduleSpecifier === node) ||                     (isInJSFile(node) && isJSDocImportTag(node.parent) && node.parent.moduleSpecifier === node) ||                     ((isInJSFile(node) && isRequireCall(node.parent, /*requireStringLiteralLikeArgument* / false)) || isImportCall(node.parent)) ||                     (isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent)                 ) {                     return resolveExternalModuleName(node, node as LiteralExpression, ignoreErrors);                 }                 if (isCallExpression(parent) && isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] === node) {                     return getSymbolOfDeclaration(parent);                 }                 // falls through              case SyntaxKind.NumericLiteral:                 // index access                 const objectType = isElementAccessExpression(parent)                     ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined                     : isLiteralTypeNode(parent) && isIndexedAccessTypeNode(grandParent)                     ? getTypeFromTypeNode(grandParent.objectType)                     : undefined;                 return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores((node as StringLiteral | NumericLiteral).text));              case SyntaxKind.DefaultKeyword:             case SyntaxKind.FunctionKeyword:             case SyntaxKind.EqualsGreaterThanToken:             case SyntaxKind.ClassKeyword:                 return getSymbolOfNode(node.parent);             case SyntaxKind.ImportType:                 return isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined;              case SyntaxKind.ExportKeyword:                 return isExportAssignment(node.parent) ? Debug.checkDefined(node.parent.symbol) : undefined;              case SyntaxKind.ImportKeyword:             case SyntaxKind.NewKeyword:                 return isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : undefined;             case SyntaxKind.InstanceOfKeyword:                 if (isBinaryExpression(node.parent)) {                     const type = getTypeOfExpression(node.parent.right);                     const hasInstanceMethodType = getSymbolHasInstanceMethodOfObjectType(type);                     return hasInstanceMethodType?.symbol ?? type.symbol;                 }                 return undefined;             case SyntaxKind.MetaProperty:                 return checkExpression(node as Expression).symbol;             case SyntaxKind.JsxNamespacedName:                 if (isJSXTagName(node) && isJsxIntrinsicTagName(node)) {                     const symbol = getIntrinsicTagSymbol(node.parent as JsxOpeningLikeElement);                     return symbol === unknownSymbol ? undefined : symbol;                 }                 // falls through              default:                 return undefined;         } */
	}
	getIndexInfosAtLocation := func(node Node) /* TODO(TypeOperator): readonly IndexInfo[] */ any {
		if isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name == node {
			keyType := getLiteralTypeFromPropertyName(node)
			objectType := getTypeOfExpression(node.parent.expression)
			objectTypes := /* TODO(ConditionalExpression): objectType.flags & TypeFlags.Union ? (objectType as UnionType).types : [objectType] */ TODO
			return flatMap(objectTypes, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): readonly import("/home/jabaile/work/TypeScript/src/compiler/types").IndexInfo[] */ TODO {
				/* TODO(Identifier): filter */
				/* TODO(CallExpression): getIndexInfosOfType(t) */
				/* TODO(ArrowFunction): info => isApplicableIndexType(keyType, info.keyType) */
			})
		}
		return nil
	}
	getShorthandAssignmentValueSymbol := func(location Node) *Symbol {
		if location && location.kind == SyntaxKindShorthandPropertyAssignment {
			return resolveEntityName((location /* as */ /* TODO(TypeReference): ShorthandPropertyAssignment */).name, SymbolFlagsValue|SymbolFlagsAlias)
		}
		return nil
	}
	getExportSpecifierLocalTargetSymbol := func(node /* TODO(UnionType): ExportSpecifier | Identifier */ any) *Symbol {
		if isExportSpecifier(node) {
			name := node.propertyName || node.name
			return /* TODO(ConditionalExpression): node.parent.parent.moduleSpecifier ?                 getExternalModuleMember(node.parent.parent, node) :                 name.kind === SyntaxKind.StringLiteral ? undefined : // Skip for invalid syntax like this: export { "x" }                 resolveEntityName(name, SymbolFlags.Value | SymbolFlags.Type | SymbolFlags.Namespace | SymbolFlags.Alias) */ TODO
		} else {
			return resolveEntityName(node, SymbolFlagsValue|SymbolFlagsType|SymbolFlagsNamespace|SymbolFlagsAlias)
		}
	}
	getTypeOfNode := func(node Node) Type {
		if isSourceFile(node) && !isExternalModule(node) {
			return errorType
		}
		if node.flags & NodeFlagsInWithStatement {
			return errorType
		}
		classDecl := tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node)
		classType := classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class))
		if isPartOfTypeNode(node) {
			typeFromTypeNode := getTypeFromTypeNode(node /* as */ /* TODO(TypeReference): TypeNode */)
			return /* TODO(ConditionalExpression): classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode */ TODO
		}
		if isExpressionNode(node) {
			return getRegularTypeOfExpression(node /* as */ /* TODO(TypeReference): Expression */)
		}
		if classType && !classDecl.isImplements {
			baseType := firstOrUndefined(getBaseTypes(classType))
			return /* TODO(ConditionalExpression): baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType */ TODO
		}
		if isTypeDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			return getDeclaredTypeOfSymbol(symbol)
		}
		if isTypeDeclarationName(node) {
			symbol := getSymbolAtLocation(node)
			return /* TODO(ConditionalExpression): symbol ? getDeclaredTypeOfSymbol(symbol) : errorType */ TODO
		}
		if isBindingElement(node) {
			return getTypeForVariableLikeDeclaration(node, true, CheckModeNormal) || errorType
		}
		if isDeclaration(node) {
			symbol := getSymbolOfDeclaration(node)
			return /* TODO(ConditionalExpression): symbol ? getTypeOfSymbol(symbol) : errorType */ TODO
		}
		if isDeclarationNameOrImportPropertyName(node) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				return getTypeOfSymbol(symbol)
			}
			return errorType
		}
		if isBindingPattern(node) {
			return getTypeForVariableLikeDeclaration(node.parent, true, CheckModeNormal) || errorType
		}
		if isInRightSideOfImportOrExportAssignment(node /* as */ /* TODO(TypeReference): Identifier */) {
			symbol := getSymbolAtLocation(node)
			if symbol {
				declaredType := getDeclaredTypeOfSymbol(symbol)
				return /* TODO(ConditionalExpression): !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol) */ TODO
			}
		}
		if isMetaProperty(node.parent) && node.parent.keywordToken == node.kind {
			return checkMetaPropertyKeyword(node.parent)
		}
		if isImportAttributes(node) {
			return getGlobalImportAttributesType(false)
		}
		return errorType
	}
	getTypeOfAssignmentPattern := func(expr AssignmentPattern) *Type {
		Debug.assert(expr.kind == SyntaxKindObjectLiteralExpression || expr.kind == SyntaxKindArrayLiteralExpression)
		if expr.parent.kind == SyntaxKindForOfStatement {
			iteratedType := checkRightHandSideOfForOf(expr.parent /* as */ /* TODO(TypeReference): ForOfStatement */)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if expr.parent.kind == SyntaxKindBinaryExpression {
			iteratedType := getTypeOfExpression((expr.parent /* as */ /* TODO(TypeReference): BinaryExpression */).right)
			return checkDestructuringAssignment(expr, iteratedType || errorType)
		}
		if expr.parent.kind == SyntaxKindPropertyAssignment {
			node := cast(expr.parent.parent, isObjectLiteralExpression)
			typeOfParentObjectLiteral := getTypeOfAssignmentPattern(node) || errorType
			propertyIndex := indexOfNode(node.properties, expr.parent)
			return checkObjectLiteralDestructuringPropertyAssignment(node, typeOfParentObjectLiteral, propertyIndex)
		}
		node := cast(expr.parent, isArrayLiteralExpression)
		typeOfArrayLiteral := getTypeOfAssignmentPattern(node) || errorType
		elementType := checkIteratedTypeOrElementType(IterationUseDestructuring, typeOfArrayLiteral, undefinedType, expr.parent) || errorType
		return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType)
	}
	getPropertySymbolOfDestructuringAssignment := func(location Identifier) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
		typeOfObjectLiteral := getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern))
		return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText)
	}
	getRegularTypeOfExpression := func(expr Expression) Type {
		if isRightSideOfQualifiedNameOrPropertyAccess(expr) {
			expr = expr.parent /* as */ /* TODO(TypeReference): Expression */
		}
		return getRegularTypeOfLiteralType(getTypeOfExpression(expr))
	}
	getParentTypeOfClassElement := func(node ClassElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		classSymbol := /* TODO(NonNullExpression): getSymbolOfNode(node.parent)! */ TODO
		return /* TODO(ConditionalExpression): isStatic(node)             ? getTypeOfSymbol(classSymbol)             : getDeclaredTypeOfSymbol(classSymbol) */ TODO
	}
	getClassElementPropertyKeyType := func(element ClassElement) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		name := /* TODO(NonNullExpression): element.name! */ TODO
		/* TODO(SwitchStatement): switch (name.kind) {             case SyntaxKind.Identifier:                 return getStringLiteralType(idText(name));             case SyntaxKind.NumericLiteral:             case SyntaxKind.StringLiteral:                 return getStringLiteralType(name.text);             case SyntaxKind.ComputedPropertyName:                 const nameType = checkComputedPropertyName(name);                 return isTypeAssignableToKind(nameType, TypeFlags.ESSymbolLike) ? nameType : stringType;             default:                 return Debug.fail("Unsupported property name.");         } */
	}
	getAugmentedPropertiesOfType := func(type_ Type) []Symbol {
		type_ = getApparentType(type_)
		propsByName := createSymbolTable(getPropertiesOfType(type_))
		functionType := /* TODO(ConditionalExpression): getSignaturesOfType(type, SignatureKind.Call).length ? globalCallableFunctionType :             getSignaturesOfType(type, SignatureKind.Construct).length ? globalNewableFunctionType :             undefined */ TODO
		if functionType {
			forEach(getPropertiesOfType(functionType), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) {
				if !propsByName.has(p.escapedName) {
					propsByName.set(p.escapedName, p)
				}
			})
		}
		return getNamedMembers(propsByName)
	}
	typeHasCallOrConstructSignatures := func(type_ Type) bool {
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSignaturesOfType(type, SignatureKind.Call).length !== 0 */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): getSignaturesOfType(type, SignatureKind.Construct).length !== 0 */ TODO
	}
	getRootSymbols := func(symbol Symbol) []Symbol {
		roots := getImmediateRootSymbols(symbol)
		return /* TODO(ConditionalExpression): roots ? flatMap(roots, getRootSymbols) : [symbol] */ TODO
	}
	getImmediateRootSymbols := func(symbol Symbol) /* TODO(TypeOperator): readonly Symbol[] */ any {
		if getCheckFlags(symbol) & CheckFlagsSynthetic {
			return mapDefined( /* TODO(NonNullExpression): getSymbolLinks(symbol).containingType! */ TODO.types, func(type_ /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol | undefined */ TODO {
				/* TODO(Identifier): getPropertyOfType */
				/* TODO(Identifier): type */
				/* TODO(PropertyAccessExpression): symbol.escapedName */
			})
		} else if symbol.flags & SymbolFlagsTransient {
			TODO_IDENTIFIER := symbol /* as */ /* TODO(TypeReference): TransientSymbol */
			return /* TODO(ConditionalExpression): leftSpread ? [leftSpread, rightSpread!]                 : syntheticOrigin ? [syntheticOrigin]                 : singleElementArray(tryGetTarget(symbol)) */ TODO
		}
		return nil
	}
	tryGetTarget := func(symbol Symbol) *Symbol {
		var target *Symbol
		var next *Symbol = symbol
		/* TODO(WhileStatement): while (next = getSymbolLinks(next).target) {             target = next;         } */
		return target
	}
	isArgumentsLocalBinding := func(nodeIn Identifier) bool {
		if isGeneratedIdentifier(nodeIn) {
			/* TODO(FalseKeyword): false */
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if !node {
			/* TODO(FalseKeyword): false */
		}
		parent := node.parent
		if !parent {
			/* TODO(FalseKeyword): false */
		}
		isPropertyName := (isPropertyAccessExpression(parent) || isPropertyAssignment(parent)) && parent.name == node
		return !isPropertyName && getReferencedValueSymbol(node) == argumentsSymbol
	}
	isNameOfModuleOrEnumDeclaration := func(node Identifier) /* TODO(undefined): boolean */ TODO {
		return isModuleOrEnumDeclaration(node.parent) && node == node.parent.name
	}
	getReferencedExportContainer := func(nodeIn Identifier, prefixLocals bool) /* TODO(UnionType): SourceFile | ModuleDeclaration | EnumDeclaration | undefined */ any {
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node))
			if symbol {
				if symbol.flags & SymbolFlagsExportValue {
					exportSymbol := getMergedSymbol( /* TODO(NonNullExpression): symbol.exportSymbol! */ TODO)
					if !prefixLocals && exportSymbol.flags&SymbolFlagsExportHasLocal && !(exportSymbol.flags & SymbolFlagsVariable) {
						return nil
					}
					symbol = exportSymbol
				}
				parentSymbol := getParentOfSymbol(symbol)
				if parentSymbol {
					if parentSymbol.flags&SymbolFlagsValueModule && parentSymbol.valueDeclaration.kind == SyntaxKindSourceFile {
						symbolFile := parentSymbol.valueDeclaration /* as */ /* TODO(TypeReference): SourceFile */
						referenceFile := getSourceFileOfNode(node)
						symbolIsUmdExport := /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): symbolFile !== referenceFile */ TODO
						return /* TODO(ConditionalExpression): symbolIsUmdExport ? undefined : symbolFile */ TODO
					}
					return findAncestor(node.parent, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(TypePredicate): n is ModuleDeclaration | EnumDeclaration */ TODO {
						/* TODO(CallExpression): isModuleOrEnumDeclaration(n) */
						/* TODO(AmpersandAmpersandToken): && */
						/* TODO(BinaryExpression): getSymbolOfDeclaration(n) === parentSymbol */
					})
				}
			}
		}
	}
	getReferencedImportDeclaration := func(nodeIn Identifier) Declaration {
		specifier := getIdentifierGeneratedImportReference(nodeIn)
		if specifier {
			return specifier
		}
		node := getParseTreeNode(nodeIn, isIdentifier)
		if node {
			symbol := getReferencedValueOrAliasSymbol(node)
			if isNonLocalAlias(symbol, SymbolFlagsValue) && !getTypeOnlyAliasDeclaration(symbol, SymbolFlagsValue) {
				return getDeclarationOfAliasSymbol(symbol)
			}
		}
		return nil
	}
	isSymbolOfDestructuredElementOfCatchBinding := func(symbol Symbol) /* TODO(undefined): boolean | undefined */ TODO {
		return symbol.valueDeclaration && isBindingElement(symbol.valueDeclaration) && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind == SyntaxKindCatchClause
	}
	isSymbolOfDeclarationWithCollidingName := func(symbol Symbol) bool {
		if symbol.flags&SymbolFlagsBlockScoped && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration) {
			links := getSymbolLinks(symbol)
			if links.isDeclarationWithCollidingName == nil {
				container := getEnclosingBlockScopeContainer(symbol.valueDeclaration)
				if isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol) {
					if resolveName(container.parent, symbol.escapedName, SymbolFlagsValue, nil, false) {
						links.isDeclarationWithCollidingName = true
					} else if hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsCapturedBlockScopedBinding) {
						isDeclaredInLoop := hasNodeCheckFlag(symbol.valueDeclaration, NodeCheckFlagsBlockScopedBindingInLoop)
						inLoopInitializer := isIterationStatement(container, false)
						inLoopBodyBlock := container.kind == SyntaxKindBlock && isIterationStatement(container.parent, false)
						links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock))
					} else {
						links.isDeclarationWithCollidingName = false
					}
				}
			}
			return /* TODO(NonNullExpression): links.isDeclarationWithCollidingName! */ TODO
		}
		return false
	}
	getReferencedDeclarationWithCollidingName := func(nodeIn Identifier) Declaration {
		if !isGeneratedIdentifier(nodeIn) {
			node := getParseTreeNode(nodeIn, isIdentifier)
			if node {
				symbol := getReferencedValueSymbol(node)
				if symbol && isSymbolOfDeclarationWithCollidingName(symbol) {
					return symbol.valueDeclaration
				}
			}
		}
		return nil
	}
	isDeclarationWithCollidingName := func(nodeIn Declaration) bool {
		node := getParseTreeNode(nodeIn, isDeclaration)
		if node {
			symbol := getSymbolOfDeclaration(node)
			if symbol {
				return isSymbolOfDeclarationWithCollidingName(symbol)
			}
		}
		return false
	}
	isValueAliasDeclaration := func(node Node) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.ImportEqualsDeclaration:                 return isAliasResolvedToValue(getSymbolOfDeclaration(node as ImportEqualsDeclaration));             case SyntaxKind.ImportClause:             case SyntaxKind.NamespaceImport:             case SyntaxKind.ImportSpecifier:             case SyntaxKind.ExportSpecifier:                 const symbol = getSymbolOfDeclaration(node as ImportClause | NamespaceImport | ImportSpecifier | ExportSpecifier);                 return !!symbol && isAliasResolvedToValue(symbol, /*excludeTypeOnlyValues* / true);             case SyntaxKind.ExportDeclaration:                 const exportClause = (node as ExportDeclaration).exportClause;                 return !!exportClause && (                     isNamespaceExport(exportClause) ||                     some(exportClause.elements, isValueAliasDeclaration)                 );             case SyntaxKind.ExportAssignment:                 return (node as ExportAssignment).expression && (node as ExportAssignment).expression.kind === SyntaxKind.Identifier ?                     isAliasResolvedToValue(getSymbolOfDeclaration(node as ExportAssignment), /*excludeTypeOnlyValues* / true) :                     true;         } */
		return false
	}
	isTopLevelValueImportEqualsWithEntityName := func(nodeIn ImportEqualsDeclaration) bool {
		node := getParseTreeNode(nodeIn, isImportEqualsDeclaration)
		if node == nil || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.kind !== SyntaxKind.SourceFile */ TODO || !isInternalModuleImportEqualsDeclaration(node) {
			return false
		}
		isValue := isAliasResolvedToValue(getSymbolOfDeclaration(node))
		return isValue && node.moduleReference && !nodeIsMissing(node.moduleReference)
	}
	isAliasResolvedToValue := func(symbol *Symbol, excludeTypeOnlyValues bool) bool {
		if !symbol {
			return false
		}
		container := getSourceFileOfNode(symbol.valueDeclaration)
		fileSymbol := container && getSymbolOfDeclaration(container)
		/* TODO(ExpressionStatement): void resolveExternalModuleSymbol(fileSymbol); */
		target := getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol))
		if target == unknownSymbol {
			return !excludeTypeOnlyValues || !getTypeOnlyAliasDeclaration(symbol)
		}
		return !!(getSymbolFlags(symbol, excludeTypeOnlyValues, true) & SymbolFlagsValue) && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target))
	}
	isConstEnumOrConstEnumOnlyModule := func(s Symbol) bool {
		return isConstEnumSymbol(s) || !!s.constEnumOnlyModule
	}
	isReferencedAliasDeclaration := func(node Node, checkChildren bool) bool {
		Debug.assert(canCollectSymbolAliasAccessabilityData)
		if isAliasSymbolDeclaration(node) {
			symbol := getSymbolOfDeclaration(node /* as */ /* TODO(TypeReference): Declaration */)
			links := symbol && getSymbolLinks(symbol)
			if links.referenced {
				return true
			}
			target := getSymbolLinks(symbol).aliasTarget
			if target && getEffectiveModifierFlags(node)&ModifierFlagsExport && getSymbolFlags(target)&SymbolFlagsValue && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target)) {
				return true
			}
		}
		if checkChildren {
			return !!forEachChild(node, func(node /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(Identifier): isReferencedAliasDeclaration */
				/* TODO(Identifier): node */
				/* TODO(Identifier): checkChildren */
			})
		}
		return false
	}
	isImplementationOfOverload := func(node SignatureDeclaration) /* TODO(undefined): boolean */ TODO {
		if nodeIsPresent((node /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body) {
			if isGetAccessor(node) || isSetAccessor(node) {
				/* TODO(FalseKeyword): false */
			}
			symbol := getSymbolOfDeclaration(node)
			signaturesOfSymbol := getSignaturesOfSymbol(symbol)
			return signaturesOfSymbol.length > 1 || (signaturesOfSymbol.length == 1 && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): signaturesOfSymbol[0].declaration !== node */ TODO)
		}
		return false
	}
	declaredParameterTypeContainsUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO(undefined): boolean */ TODO {
		typeNode := getNonlocalEffectiveTypeAnnotationNode(parameter)
		if !typeNode {
			/* TODO(FalseKeyword): false */
		}
		type_ := getTypeFromTypeNode(typeNode)
		return containsUndefinedType(type_)
	}
	requiresAddingImplicitUndefined := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) /* TODO(undefined): boolean */ TODO {
		return (isRequiredInitializedParameter(parameter, enclosingDeclaration) || isOptionalUninitializedParameterProperty(parameter)) && !declaredParameterTypeContainsUndefined(parameter)
	}
	isRequiredInitializedParameter := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any, enclosingDeclaration Node) bool {
		if !strictNullChecks || isOptionalParameter(parameter) || isJSDocParameterTag(parameter) || !parameter.initializer {
			return false
		}
		if hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier) {
			return !!enclosingDeclaration && isFunctionLikeDeclaration(enclosingDeclaration)
		}
		return true
	}
	isOptionalUninitializedParameterProperty := func(parameter /* TODO(UnionType): ParameterDeclaration | JSDocParameterTag */ any) /* TODO(undefined): boolean */ TODO {
		return strictNullChecks && isOptionalParameter(parameter) && (isJSDocParameterTag(parameter) || !parameter.initializer) && hasSyntacticModifier(parameter, ModifierFlagsParameterPropertyModifier)
	}
	isExpandoFunctionDeclaration := func(node Declaration) bool {
		declaration := getParseTreeNode(node, func(n /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Node */ TODO) /* TODO(TypePredicate): n is FunctionDeclaration | VariableDeclaration */ TODO {
			/* TODO(CallExpression): isFunctionDeclaration(n) */
			/* TODO(BarBarToken): || */
			/* TODO(CallExpression): isVariableDeclaration(n) */
		})
		if !declaration {
			return false
		}
		var symbol *Symbol
		if isVariableDeclaration(declaration) {
			if declaration.type_ || (!isInJSFile(declaration) && !isVarConstLike(declaration)) {
				return false
			}
			initializer := getDeclaredExpandoInitializer(declaration)
			if !initializer || !canHaveSymbol(initializer) {
				return false
			}
			symbol = getSymbolOfDeclaration(initializer)
		} else {
			symbol = getSymbolOfDeclaration(declaration)
		}
		if !symbol || !(symbol.flags&SymbolFlagsFunction | SymbolFlagsVariable) {
			return false
		}
		return !!forEachEntry(getExportsOfSymbol(symbol), func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): boolean | 0 */ TODO {
			/* TODO(BinaryExpression): p.flags & SymbolFlags.Value */
			/* TODO(AmpersandAmpersandToken): && */
			/* TODO(CallExpression): isExpandoPropertyDeclaration(p.valueDeclaration) */
		})
	}
	getPropertiesOfContainerFunction := func(node Declaration) []Symbol {
		declaration := getParseTreeNode(node, isFunctionDeclaration)
		if !declaration {
			return emptyArray
		}
		symbol := getSymbolOfDeclaration(declaration)
		return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray
	}
	getNodeCheckFlags := func(node Node) NodeCheckFlags {
		nodeId := node.id || 0
		if nodeId < 0 || nodeId >= nodeLinks.length {
			/* TODO(NumericLiteral): 0 */
		}
		return /* TODO(ElementAccessExpression): nodeLinks[nodeId] */ TODO.flags || 0
	}
	hasNodeCheckFlag := func(node Node, flag LazyNodeCheckFlags) /* TODO(undefined): boolean */ TODO {
		calculateNodeCheckFlagWorker(node, flag)
		return !!(getNodeCheckFlags(node) & flag)
	}
	calculateNodeCheckFlagWorker := func(node Node, flag LazyNodeCheckFlags) {
		if !compilerOptions.noCheck && canIncludeBindAndCheckDiagnostics(getSourceFileOfNode(node), compilerOptions) {
			return
		}
		links := getNodeLinks(node)
		if links.calculatedFlags & flag {
			return
		}
		/* TODO(SwitchStatement): switch (flag) {             case NodeCheckFlags.SuperInstance:             case NodeCheckFlags.SuperStatic:                 return checkSingleSuperExpression(node);             case NodeCheckFlags.MethodWithSuperPropertyAccessInAsync:             case NodeCheckFlags.MethodWithSuperPropertyAssignmentInAsync:             case NodeCheckFlags.ContainsSuperPropertyInStaticInitializer:                 return checkChildSuperExpressions(node);             case NodeCheckFlags.CaptureArguments:             case NodeCheckFlags.ContainsCapturedBlockScopeBinding:             case NodeCheckFlags.NeedsLoopOutParameter:             case NodeCheckFlags.ContainsConstructorReference:                 return checkChildIdentifiers(node);             case NodeCheckFlags.ConstructorReference:                 return checkSingleIdentifier(node);             case NodeCheckFlags.LoopWithCapturedBlockScopedBinding:             case NodeCheckFlags.BlockScopedBindingInLoop:             case NodeCheckFlags.CapturedBlockScopedBinding:                 return checkContainingBlockScopeBindingUses(node);             default:                 return Debug.assertNever(flag, `Unhandled node check flag calculation: ${Debug.formatNodeCheckFlags(flag)}`);         } */
		forEachNodeRecursively := func(root Node, cb func(node Node, parent Node) /* TODO(UnionType): T | "skip" | undefined */ any) *T {
			rootResult := cb(root, root.parent)
			if rootResult == "skip" {
				/* TODO(Identifier): undefined */
			}
			if rootResult {
				/* TODO(Identifier): rootResult */
			}
			return forEachChildRecursively(root, cb)
		}
		checkSuperExpressions := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				/* TODO(StringLiteral): "skip" */
			}
			links.calculatedFlags |= NodeCheckFlagsMethodWithSuperPropertyAccessInAsync | NodeCheckFlagsMethodWithSuperPropertyAssignmentInAsync | NodeCheckFlagsContainsSuperPropertyInStaticInitializer
			checkSingleSuperExpression(node)
			return nil
		}
		checkChildSuperExpressions := func(node Node) {
			forEachNodeRecursively(node, checkSuperExpressions)
		}
		checkSingleSuperExpression := func(node Node) {
			nodeLinks := getNodeLinks(node)
			nodeLinks.calculatedFlags |= NodeCheckFlagsSuperInstance | NodeCheckFlagsSuperStatic
			if node.kind == SyntaxKindSuperKeyword {
				checkSuperExpression(node)
			}
		}
		checkIdentifiers := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				/* TODO(StringLiteral): "skip" */
			}
			links.calculatedFlags |= NodeCheckFlagsCaptureArguments | NodeCheckFlagsContainsCapturedBlockScopeBinding | NodeCheckFlagsNeedsLoopOutParameter | NodeCheckFlagsContainsConstructorReference
			checkSingleIdentifier(node)
			return nil
		}
		checkChildIdentifiers := func(node Node) {
			forEachNodeRecursively(node, checkIdentifiers)
		}
		isExpressionNodeOrShorthandPropertyAssignmentName := func(node Identifier) /* TODO(undefined): boolean */ TODO {
			return isExpressionNode(node) || isShorthandPropertyAssignment(node.parent) && ( /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): node.parent.objectAssignmentInitializer ?? node.parent.name */ TODO) == node
		}
		checkSingleIdentifier := func(node Node) {
			nodeLinks := getNodeLinks(node)
			nodeLinks.calculatedFlags |= NodeCheckFlagsConstructorReference
			if isIdentifier(node) {
				nodeLinks.calculatedFlags |= NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
				if isExpressionNodeOrShorthandPropertyAssignmentName(node) && !(isPropertyAccessExpression(node.parent) && node.parent.name == node) {
					s := getResolvedSymbol(node)
					if s && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): s !== unknownSymbol */ TODO {
						checkIdentifierCalculateNodeCheckFlags(node, s)
					}
				}
			}
		}
		checkBlockScopeBindings := func(node Node) /* TODO(undefined): "skip" | undefined */ TODO {
			links := getNodeLinks(node)
			if links.calculatedFlags & flag {
				/* TODO(StringLiteral): "skip" */
			}
			links.calculatedFlags |= NodeCheckFlagsLoopWithCapturedBlockScopedBinding | NodeCheckFlagsBlockScopedBindingInLoop | NodeCheckFlagsCapturedBlockScopedBinding
			checkSingleBlockScopeBinding(node)
			return nil
		}
		checkContainingBlockScopeBindingUses := func(node Node) {
			scope := getEnclosingBlockScopeContainer( /* TODO(ConditionalExpression): isDeclarationName(node) ? node.parent : node */ TODO)
			forEachNodeRecursively(scope, checkBlockScopeBindings)
		}
		checkSingleBlockScopeBinding := func(node Node) {
			checkSingleIdentifier(node)
			if isComputedPropertyName(node) {
				checkComputedPropertyName(node)
			}
			if isPrivateIdentifier(node) && isClassElement(node.parent) {
				setNodeLinksForPrivateIdentifierScope(node.parent /* as */ /* TODO(UnionType): PropertyDeclaration | PropertySignature | MethodDeclaration | MethodSignature | AccessorDeclaration */)
			}
		}
	}
	getEnumMemberValue := func(node EnumMember) EvaluatorResult {
		computeEnumMemberValues(node.parent)
		return /* TODO(QuestionQuestionToken): ?? */ /* TODO(BinaryExpression): getNodeLinks(node).enumMemberValue ?? evaluatorResult(/*value* / undefined) */ TODO
	}
	canHaveConstantValue := func(node Node) /* TODO(TypePredicate): node is EnumMember | AccessExpression */ TODO {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.EnumMember:             case SyntaxKind.PropertyAccessExpression:             case SyntaxKind.ElementAccessExpression:                 return true;         } */
		return false
	}
	getConstantValue := func(node /* TODO(UnionType): EnumMember | AccessExpression */ any) /* TODO(UnionType): string | number | undefined */ any {
		if node.kind == SyntaxKindEnumMember {
			return getEnumMemberValue(node).value
		}
		if !getNodeLinks(node).resolvedSymbol {
			/* TODO(ExpressionStatement): void checkExpressionCached(node); */
		}
		symbol := getNodeLinks(node).resolvedSymbol || ( /* TODO(ConditionalExpression): isEntityNameExpression(node) ? resolveEntityName(node, SymbolFlags.Value, /*ignoreErrors* / true) : undefined */ TODO)
		if symbol && (symbol.flags & SymbolFlagsEnumMember) {
			member := symbol.valueDeclaration /* as */ /* TODO(TypeReference): EnumMember */
			if isEnumConst(member.parent) {
				return getEnumMemberValue(member).value
			}
		}
		return nil
	}
	isFunctionType := func(type_ Type) bool {
		return !!(type_.flags & TypeFlagsObject) && getSignaturesOfType(type_, SignatureKindCall).length > 0
	}
	getTypeReferenceSerializationKind := func(typeNameIn EntityName, location Node) TypeReferenceSerializationKind {
		typeName := getParseTreeNode(typeNameIn, isEntityName)
		if !typeName {
			/* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Unknown */
		}
		if location {
			location = getParseTreeNode(location)
			if !location {
				/* TODO(PropertyAccessExpression): TypeReferenceSerializationKind.Unknown */
			}
		}
		isTypeOnly := false
		if isQualifiedName(typeName) {
			rootValueSymbol := resolveEntityName(getFirstIdentifier(typeName), SymbolFlagsValue, true, true, location)
			isTypeOnly = !!rootValueSymbol.declarations.every(isTypeOnlyImportOrExportDeclaration)
		}
		valueSymbol := resolveEntityName(typeName, SymbolFlagsValue, true, true, location)
		resolvedValueSymbol := /* TODO(ConditionalExpression): valueSymbol && valueSymbol.flags & SymbolFlags.Alias ? resolveAlias(valueSymbol) : valueSymbol */ TODO
		/* TODO(ExpressionStatement): isTypeOnly ||= !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, SymbolFlags.Value)); */
		typeSymbol := resolveEntityName(typeName, SymbolFlagsType, true, true, location)
		resolvedTypeSymbol := /* TODO(ConditionalExpression): typeSymbol && typeSymbol.flags & SymbolFlags.Alias ? resolveAlias(typeSymbol) : typeSymbol */ TODO
		if !valueSymbol {
			/* TODO(ExpressionStatement): isTypeOnly ||= !!(typeSymbol && getTypeOnlyAliasDeclaration(typeSymbol, SymbolFlags.Type)); */
		}
		if resolvedValueSymbol && resolvedValueSymbol == resolvedTypeSymbol {
			globalPromiseSymbol := getGlobalPromiseConstructorSymbol(false)
			if globalPromiseSymbol && resolvedValueSymbol == globalPromiseSymbol {
				return TypeReferenceSerializationKindPromise
			}
			constructorType := getTypeOfSymbol(resolvedValueSymbol)
			if constructorType && isConstructorType(constructorType) {
				return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.TypeWithCallSignature : TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue */ TODO
			}
		}
		if !resolvedTypeSymbol {
			return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
		}
		type_ := getDeclaredTypeOfSymbol(resolvedTypeSymbol)
		if isErrorType(type_) {
			return /* TODO(ConditionalExpression): isTypeOnly ? TypeReferenceSerializationKind.ObjectType : TypeReferenceSerializationKind.Unknown */ TODO
		} else if type_.flags & TypeFlagsAnyOrUnknown {
			return TypeReferenceSerializationKindObjectType
		} else if isTypeAssignableToKind(type_, TypeFlagsVoid|TypeFlagsNullable|TypeFlagsNever) {
			return TypeReferenceSerializationKindVoidNullableOrNeverType
		} else if isTypeAssignableToKind(type_, TypeFlagsBooleanLike) {
			return TypeReferenceSerializationKindBooleanType
		} else if isTypeAssignableToKind(type_, TypeFlagsNumberLike) {
			return TypeReferenceSerializationKindNumberLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsBigIntLike) {
			return TypeReferenceSerializationKindBigIntLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsStringLike) {
			return TypeReferenceSerializationKindStringLikeType
		} else if isTupleType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else if isTypeAssignableToKind(type_, TypeFlagsESSymbolLike) {
			return TypeReferenceSerializationKindESSymbolType
		} else if isFunctionType(type_) {
			return TypeReferenceSerializationKindTypeWithCallSignature
		} else if isArrayType(type_) {
			return TypeReferenceSerializationKindArrayLikeType
		} else {
			return TypeReferenceSerializationKindObjectType
		}
	}
	createTypeOfDeclaration := func(declarationIn /* TODO(UnionType): AccessorDeclaration | VariableLikeDeclaration | PropertyAccessExpression */ any, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		declaration := getParseTreeNode(declarationIn, isVariableLikeOrAccessor)
		if !declaration {
			return factory.createToken(SyntaxKindAnyKeyword) /* as */ /* TODO(TypeReference): KeywordTypeNode */
		}
		symbol := getSymbolOfDeclaration(declaration)
		type_ := /* TODO(ConditionalExpression): symbol && !(symbol.flags & (SymbolFlags.TypeLiteral | SymbolFlags.Signature))             ? getWidenedLiteralType(getTypeOfSymbol(symbol))             : errorType */ TODO
		return nodeBuilder.serializeTypeForDeclaration(declaration, type_, symbol, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	type DeclarationWithPotentialInnerNodeReuse /* TODO(UnionType): | SignatureDeclaration         | JSDocSignature         | AccessorDeclaration         | VariableLikeDeclaration         | PropertyAccessExpression         | ExportAssignment */ any
	isDeclarationWithPossibleInnerTypeNodeReuse := func(declaration Declaration) /* TODO(TypePredicate): declaration is DeclarationWithPotentialInnerNodeReuse */ TODO {
		return isFunctionLike(declaration) || isExportAssignment(declaration) || isVariableLike(declaration)
	}
	getAllAccessorDeclarationsForDeclaration := func(accessor AccessorDeclaration) AllAccessorDeclarations {
		accessor = /* TODO(NonNullExpression): getParseTreeNode(accessor, isGetOrSetAccessorDeclaration)! */ TODO
		otherKind := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? SyntaxKind.GetAccessor : SyntaxKind.SetAccessor */ TODO
		otherAccessor := getDeclarationOfKind(getSymbolOfDeclaration(accessor), otherKind)
		firstAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor */ TODO
		secondAccessor := /* TODO(ConditionalExpression): otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor */ TODO
		setAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.SetAccessor ? accessor : otherAccessor as SetAccessorDeclaration */ TODO
		getAccessor := /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? accessor : otherAccessor as GetAccessorDeclaration */ TODO
		return /* TODO(ObjectLiteralExpression): {             firstAccessor,             secondAccessor,             setAccessor,             getAccessor,         } */ TODO
	}
	getPossibleTypeNodeReuseExpression := func(declaration DeclarationWithPotentialInnerNodeReuse) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression | undefined */ TODO {
		return /* TODO(ConditionalExpression): isFunctionLike(declaration) && !isSetAccessor(declaration)             ? getSingleReturnExpression(declaration)             : isExportAssignment(declaration)             ? declaration.expression             : !!(declaration as HasInitializer).initializer             ? (declaration as HasInitializer & typeof declaration).initializer             : isParameter(declaration) && isSetAccessor(declaration.parent)             ? getSingleReturnExpression(getAllAccessorDeclarationsForDeclaration(declaration.parent).getAccessor)             : undefined */ TODO
	}
	getSingleReturnExpression := func(declaration *SignatureDeclaration) *Expression {
		var candidateExpr *Expression
		if declaration && !nodeIsMissing((declaration /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body) {
			if getFunctionFlags(declaration) & FunctionFlagsAsyncGenerator {
				/* TODO(Identifier): undefined */
			}
			body := (declaration /* as */ /* TODO(TypeReference): FunctionLikeDeclaration */).body
			if body && isBlock(body) {
				forEachReturnStatement(body, func(s /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ReturnStatement */ TODO) /* TODO(undefined): true | undefined */ TODO {
					if !candidateExpr {
						candidateExpr = s.expression
					} else {
						candidateExpr = nil
						return true
					}
				})
			} else {
				candidateExpr = body
			}
		}
		return candidateExpr
	}
	createReturnTypeOfSignatureDeclaration := func(signatureDeclarationIn SignatureDeclaration, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		signatureDeclaration := getParseTreeNode(signatureDeclarationIn, isFunctionLike)
		if !signatureDeclaration {
			return factory.createToken(SyntaxKindAnyKeyword) /* as */ /* TODO(TypeReference): KeywordTypeNode */
		}
		return nodeBuilder.serializeReturnTypeForSignature(getSignatureFromDeclaration(signatureDeclaration), enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	createTypeOfExpression := func(exprIn Expression, enclosingDeclaration Node, flags NodeBuilderFlags, internalFlags InternalNodeBuilderFlags, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		expr := getParseTreeNode(exprIn, isExpression)
		if !expr {
			return factory.createToken(SyntaxKindAnyKeyword) /* as */ /* TODO(TypeReference): KeywordTypeNode */
		}
		type_ := getWidenedType(getRegularTypeOfExpression(expr))
		return nodeBuilder.expressionOrTypeToTypeNode(expr, type_, nil, enclosingDeclaration, flags|NodeBuilderFlagsMultilineObjectLiterals, internalFlags, tracker)
	}
	hasGlobalName := func(name string) bool {
		return globals.has(escapeLeadingUnderscores(name))
	}
	getReferencedValueSymbol := func(reference Identifier, startInDeclarationContainer bool) *Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol {
			return resolvedSymbol
		}
		var location Node = reference
		if startInDeclarationContainer {
			parent := reference.parent
			if isDeclaration(parent) && reference == parent.name {
				location = getDeclarationContainer(parent)
			}
		}
		return resolveName(location, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true)
	}
	getReferencedValueOrAliasSymbol := func(reference Identifier) *Symbol {
		resolvedSymbol := getNodeLinks(reference).resolvedSymbol
		if resolvedSymbol && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): resolvedSymbol !== unknownSymbol */ TODO {
			return resolvedSymbol
		}
		return resolveName(reference, reference.escapedText, SymbolFlagsValue|SymbolFlagsExportValue|SymbolFlagsAlias, nil, true, nil)
	}
	getReferencedValueDeclaration := func(referenceIn Identifier) Declaration {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration
				}
			}
		}
		return nil
	}
	getReferencedValueDeclarations := func(referenceIn Identifier) /* TODO(ArrayType): Declaration[] */ any {
		if !isGeneratedIdentifier(referenceIn) {
			reference := getParseTreeNode(referenceIn, isIdentifier)
			if reference {
				symbol := getReferencedValueSymbol(reference)
				if symbol {
					return filter(getExportSymbolOfValueSymbolIfExported(symbol).declarations, func(declaration /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Declaration */ TODO) /* TODO(undefined): boolean */ TODO {
						/* TODO(SwitchStatement): switch (declaration.kind) {                             case SyntaxKind.VariableDeclaration:                             case SyntaxKind.Parameter:                             case SyntaxKind.BindingElement:                             case SyntaxKind.PropertyDeclaration:                             case SyntaxKind.PropertyAssignment:                             case SyntaxKind.ShorthandPropertyAssignment:                             case SyntaxKind.EnumMember:                             case SyntaxKind.ObjectLiteralExpression:                             case SyntaxKind.FunctionDeclaration:                             case SyntaxKind.FunctionExpression:                             case SyntaxKind.ArrowFunction:                             case SyntaxKind.ClassDeclaration:                             case SyntaxKind.ClassExpression:                             case SyntaxKind.EnumDeclaration:                             case SyntaxKind.MethodDeclaration:                             case SyntaxKind.GetAccessor:                             case SyntaxKind.SetAccessor:                             case SyntaxKind.ModuleDeclaration:                                 return true;                         } */
						return false
					})
				}
			}
		}
		return nil
	}
	isLiteralConstDeclaration := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any) bool {
		if isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConstLike(node) {
			return isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)))
		}
		return false
	}
	literalTypeToNode := func(type_ FreshableType, enclosing Node, tracker SymbolTracker) Expression {
		enumResult := /* TODO(ConditionalExpression): type.flags & TypeFlags.EnumLike ? nodeBuilder.symbolToExpression(type.symbol, SymbolFlags.Value, enclosing, /*flags* / undefined, /*internalFlags* / undefined, tracker)             : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse() */ TODO
		if enumResult {
			/* TODO(Identifier): enumResult */
		}
		literalValue := (type_ /* as */ /* TODO(TypeReference): LiteralType */).value
		return /* TODO(ConditionalExpression): typeof literalValue === "object" ? factory.createBigIntLiteral(literalValue) :             typeof literalValue === "string" ? factory.createStringLiteral(literalValue) :             literalValue < 0 ? factory.createPrefixUnaryExpression(SyntaxKind.MinusToken, factory.createNumericLiteral(-literalValue)) :             factory.createNumericLiteral(literalValue) */ TODO
	}
	createLiteralConstValue := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature | ParameterDeclaration */ any, tracker SymbolTracker) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Expression */ TODO {
		type_ := getTypeOfSymbol(getSymbolOfDeclaration(node))
		return literalTypeToNode(type_ /* as */ /* TODO(TypeReference): FreshableType */, node, tracker)
	}
	getJsxFactoryEntity := func(location Node) *EntityName {
		return /* TODO(ConditionalExpression): location ? (getJsxNamespace(location), (getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity */ TODO
	}
	getJsxFragmentFactoryEntity := func(location Node) *EntityName {
		if location {
			file := getSourceFileOfNode(location)
			if file {
				if file.localJsxFragmentFactory {
					return file.localJsxFragmentFactory
				}
				jsxFragPragmas := file.pragmas.get("jsxfrag")
				jsxFragPragma := /* TODO(ConditionalExpression): isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas */ TODO
				if jsxFragPragma {
					file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion)
					return file.localJsxFragmentFactory
				}
			}
		}
		if compilerOptions.jsxFragmentFactory {
			return parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion)
		}
	}
	getNonlocalEffectiveTypeAnnotationNode := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		direct := getEffectiveTypeAnnotationNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindParameter && node.parent.kind == SyntaxKindSetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node.parent /* as */ /* TODO(TypeReference): SetAccessorDeclaration */).getAccessor
			if other {
				return getEffectiveReturnTypeNode(other)
			}
		}
		return nil
	}
	getNonlocalEffectiveReturnTypeAnnotationNode := func(node /* TODO(UnionType): SignatureDeclaration | JSDocSignature */ any) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").TypeNode | undefined */ TODO {
		direct := getEffectiveReturnTypeNode(node)
		if direct {
			return direct
		}
		if node.kind == SyntaxKindGetAccessor {
			other := getAllAccessorDeclarationsForDeclaration(node).setAccessor
			if other {
				param := getSetAccessorValueParameter(other)
				if param {
					return getEffectiveTypeAnnotationNode(param)
				}
			}
		}
		return nil
	}
	createResolver := func() EmitResolver {
		return /* TODO(ObjectLiteralExpression): {             getReferencedExportContainer,             getReferencedImportDeclaration,             getReferencedDeclarationWithCollidingName,             isDeclarationWithCollidingName,             isValueAliasDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated like values.                 return node && canCollectSymbolAliasAccessabilityData ? isValueAliasDeclaration(node) : true;             },             hasGlobalName,             isReferencedAliasDeclaration: (nodeIn, checkChildren?) => {                 const node = getParseTreeNode(nodeIn);                 // Synthesized nodes are always treated as referenced.                 return node && canCollectSymbolAliasAccessabilityData ? isReferencedAliasDeclaration(node, checkChildren) : true;             },             hasNodeCheckFlag: (nodeIn, flag) => {                 const node = getParseTreeNode(nodeIn);                 if (!node) return false;                 return hasNodeCheckFlag(node, flag);             },             isTopLevelValueImportEqualsWithEntityName,             isDeclarationVisible,             isImplementationOfOverload,             requiresAddingImplicitUndefined,             isExpandoFunctionDeclaration,             getPropertiesOfContainerFunction,             createTypeOfDeclaration,             createReturnTypeOfSignatureDeclaration,             createTypeOfExpression,             createLiteralConstValue,             isSymbolAccessible,             isEntityNameVisible,             getConstantValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, canHaveConstantValue);                 return node ? getConstantValue(node) : undefined;             },             getEnumMemberValue: nodeIn => {                 const node = getParseTreeNode(nodeIn, isEnumMember);                 return node ? getEnumMemberValue(node) : undefined;             },             collectLinkedAliases,             markLinkedReferences: nodeIn => {                 const node = getParseTreeNode(nodeIn);                 return node && markLinkedReferences(node, ReferenceHint.Unspecified);             },             getReferencedValueDeclaration,             getReferencedValueDeclarations,             getTypeReferenceSerializationKind,             isOptionalParameter,             isArgumentsLocalBinding,             getExternalModuleFileFromDeclaration: nodeIn => {                 const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference);                 return node && getExternalModuleFileFromDeclaration(node);             },             isLiteralConstDeclaration,             isLateBound: (nodeIn: Declaration): nodeIn is LateBoundDeclaration => {                 const node = getParseTreeNode(nodeIn, isDeclaration);                 const symbol = node && getSymbolOfDeclaration(node);                 return !!(symbol && getCheckFlags(symbol) & CheckFlags.Late);             },             getJsxFactoryEntity,             getJsxFragmentFactoryEntity,             isBindingCapturedByNode: (node, decl) => {                 const parseNode = getParseTreeNode(node);                 const parseDecl = getParseTreeNode(decl);                 return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);             },             getDeclarationStatementsForSourceFile: (node, flags, internalFlags, tracker) => {                 const n = getParseTreeNode(node) as SourceFile;                 Debug.assert(n && n.kind === SyntaxKind.SourceFile, "Non-sourcefile node passed into getDeclarationsForSourceFile");                 const sym = getSymbolOfDeclaration(node);                 if (!sym) {                     return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, internalFlags, tracker);                 }                 resolveExternalModuleSymbol(sym); // ensures cjs export assignment is setup                 return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, internalFlags, tracker);             },             isImportRequiredByAugmentation,             isDefinitelyReferenceToGlobalSymbolObject,         } */ TODO
		isImportRequiredByAugmentation := func(node ImportDeclaration) /* TODO(undefined): boolean */ TODO {
			file := getSourceFileOfNode(node)
			if !file.symbol {
				/* TODO(FalseKeyword): false */
			}
			importTarget := getExternalModuleFileFromDeclaration(node)
			if !importTarget {
				/* TODO(FalseKeyword): false */
			}
			if importTarget == file {
				/* TODO(FalseKeyword): false */
			}
			exports := getExportsOfModule(file.symbol)
			for _, s := range arrayFrom(exports.values()) {
				if s.mergeId {
					merged := getMergedSymbol(s)
					if merged.declarations {
						for _, d := range merged.declarations {
							declFile := getSourceFileOfNode(d)
							if declFile == importTarget {
								return true
							}
						}
					}
				}
			}
			return false
		}
	}
	getExternalModuleFileFromDeclaration := func(declaration /* TODO(UnionType): AnyImportOrReExport | ModuleDeclaration | ImportTypeNode | ImportCall */ any) *SourceFile {
		specifier := /* TODO(ConditionalExpression): declaration.kind === SyntaxKind.ModuleDeclaration ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration) */ TODO
		moduleSymbol := resolveExternalModuleNameWorker( /* TODO(NonNullExpression): specifier! */ TODO /* TODO(NonNullExpression): specifier! */, TODO, nil)
		if !moduleSymbol {
			return nil
		}
		return getDeclarationOfKind(moduleSymbol, SyntaxKindSourceFile)
	}
	initializeTypeChecker := func() {
		for _, file := range host.getSourceFiles() {
			bindSourceFile(file, compilerOptions)
		}
		amalgamatedDuplicates = /* TODO(NewExpression): new Map() */ TODO
		var augmentations /* TODO(ArrayType): (readonly (StringLiteral | Identifier)[])[] */ any
		for _, file := range host.getSourceFiles() {
			if file.redirectInfo {
				/* TODO(ContinueStatement): continue; */
			}
			if !isExternalOrCommonJsModule(file) {
				fileGlobalThisSymbol := /* TODO(NonNullExpression): file.locals! */ TODO.get("globalThis" /* as */ /* TODO(TypeReference): __String */)
				if fileGlobalThisSymbol.declarations {
					for _, declaration := range fileGlobalThisSymbol.declarations {
						diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"))
					}
				}
				mergeSymbolTable(globals /* TODO(NonNullExpression): file.locals! */, TODO)
			}
			if file.jsGlobalAugmentations {
				mergeSymbolTable(globals, file.jsGlobalAugmentations)
			}
			if file.patternAmbientModules && file.patternAmbientModules.length {
				patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules)
			}
			if file.moduleAugmentations.length {
				(augmentations || ( /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): augmentations = [] */ TODO)).push(file.moduleAugmentations)
			}
			if file.symbol && file.symbol.globalExports {
				source := file.symbol.globalExports
				source.forEach(func(sourceSymbol /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, id /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
					if !globals.has(id) {
						globals.set(id, sourceSymbol)
					}
				})
			}
		}
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if !isGlobalScopeAugmentation(augmentation.parent /* as */ /* TODO(TypeReference): ModuleDeclaration */) {
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		addUndefinedToGlobalsOrErrorOnRedeclaration()
		getSymbolLinks(undefinedSymbol).type_ = undefinedWideningType
		getSymbolLinks(argumentsSymbol).type_ = getGlobalType("IArguments" /* as */ /* TODO(TypeReference): __String */, 0, true)
		getSymbolLinks(unknownSymbol).type_ = errorType
		getSymbolLinks(globalThisSymbol).type_ = createObjectType(ObjectFlagsAnonymous, globalThisSymbol)
		globalArrayType = getGlobalType("Array" /* as */ /* TODO(TypeReference): __String */, 1, true)
		globalObjectType = getGlobalType("Object" /* as */ /* TODO(TypeReference): __String */, 0, true)
		globalFunctionType = getGlobalType("Function" /* as */ /* TODO(TypeReference): __String */, 0, true)
		globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction" /* as */ /* TODO(TypeReference): __String */, 0, true) || globalFunctionType
		globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction" /* as */ /* TODO(TypeReference): __String */, 0, true) || globalFunctionType
		globalStringType = getGlobalType("String" /* as */ /* TODO(TypeReference): __String */, 0, true)
		globalNumberType = getGlobalType("Number" /* as */ /* TODO(TypeReference): __String */, 0, true)
		globalBooleanType = getGlobalType("Boolean" /* as */ /* TODO(TypeReference): __String */, 0, true)
		globalRegExpType = getGlobalType("RegExp" /* as */ /* TODO(TypeReference): __String */, 0, true)
		anyArrayType = createArrayType(anyType)
		autoArrayType = createArrayType(autoType)
		if autoArrayType == emptyObjectType {
			autoArrayType = createAnonymousType(nil, emptySymbols, emptyArray, emptyArray, emptyArray)
		}
		globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray" /* as */ /* TODO(TypeReference): __String */, 1) /* as */ /* TODO(TypeReference): GenericType */ || globalArrayType
		anyReadonlyArrayType = /* TODO(ConditionalExpression): globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType */ TODO
		globalThisType = getGlobalTypeOrUndefined("ThisType" /* as */ /* TODO(TypeReference): __String */, 1) /* as */ /* TODO(TypeReference): GenericType */
		if augmentations {
			for _, list := range augmentations {
				for _, augmentation := range list {
					if isGlobalScopeAugmentation(augmentation.parent /* as */ /* TODO(TypeReference): ModuleDeclaration */) {
					}
					mergeModuleAugmentation(augmentation)
				}
			}
		}
		amalgamatedDuplicates.forEach(func(TODO_IDENTIFIER /* TODO(undefined): DuplicateInfoForFiles */ TODO) {
			if conflictingSymbols.size < 8 {
				conflictingSymbols.forEach(func(TODO_IDENTIFIER /* TODO(undefined): DuplicateInfoForSymbol */ TODO, symbolName /* TODO(undefined): string */ TODO) {
					message := /* TODO(ConditionalExpression): isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0 */ TODO
					for _, node := range firstFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, secondFileLocations)
					}
					for _, node := range secondFileLocations {
						addDuplicateDeclarationError(node, message, symbolName, firstFileLocations)
					}
				})
			} else {
				list := arrayFrom(conflictingSymbols.keys()).join(", ")
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file)))
				diagnostics.add(addRelatedInfo(createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file)))
			}
		})
		amalgamatedDuplicates = nil
	}
	checkExternalEmitHelpers := func(location Node, helpers ExternalEmitHelpers) {
		if compilerOptions.importHelpers {
			sourceFile := getSourceFileOfNode(location)
			if isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & NodeFlagsAmbient) {
				helpersModule := resolveHelpersModule(sourceFile, location)
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): helpersModule !== unknownSymbol */ TODO {
					links := getSymbolLinks(helpersModule)
					/* TODO(ExpressionStatement): links.requestedExternalEmitHelpers ??= 0 as ExternalEmitHelpers; */
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): (links.requestedExternalEmitHelpers & helpers) !== helpers */ TODO {
						uncheckedHelpers := helpers & ~links.requestedExternalEmitHelpers
						/* TODO(ForStatement): for (let helper = ExternalEmitHelpers.FirstEmitHelper; helper <= ExternalEmitHelpers.LastEmitHelper; helper <<= 1) {                             if (uncheckedHelpers & helper) {                                 for (const name of getHelperNames(helper)) {                                     const symbol = resolveSymbol(getSymbol(getExportsOfModule(helpersModule), escapeLeadingUnderscores(name), SymbolFlags.Value));                                     if (!symbol) {                                         error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name);                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldGet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 3)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.ClassPrivateFieldSet) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 4)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5);                                         }                                     }                                     else if (helper & ExternalEmitHelpers.SpreadArray) {                                         if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 2)) {                                             error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3);                                         }                                     }                                 }                             }                         } */
					}
					links.requestedExternalEmitHelpers |= helpers
				}
			}
		}
	}
	getHelperNames := func(helper ExternalEmitHelpers) /* TODO(undefined): string[] */ TODO {
		/* TODO(SwitchStatement): switch (helper) {             case ExternalEmitHelpers.Extends:                 return ["__extends"];             case ExternalEmitHelpers.Assign:                 return ["__assign"];             case ExternalEmitHelpers.Rest:                 return ["__rest"];             case ExternalEmitHelpers.Decorate:                 return legacyDecorators ? ["__decorate"] : ["__esDecorate", "__runInitializers"];             case ExternalEmitHelpers.Metadata:                 return ["__metadata"];             case ExternalEmitHelpers.Param:                 return ["__param"];             case ExternalEmitHelpers.Awaiter:                 return ["__awaiter"];             case ExternalEmitHelpers.Generator:                 return ["__generator"];             case ExternalEmitHelpers.Values:                 return ["__values"];             case ExternalEmitHelpers.Read:                 return ["__read"];             case ExternalEmitHelpers.SpreadArray:                 return ["__spreadArray"];             case ExternalEmitHelpers.Await:                 return ["__await"];             case ExternalEmitHelpers.AsyncGenerator:                 return ["__asyncGenerator"];             case ExternalEmitHelpers.AsyncDelegator:                 return ["__asyncDelegator"];             case ExternalEmitHelpers.AsyncValues:                 return ["__asyncValues"];             case ExternalEmitHelpers.ExportStar:                 return ["__exportStar"];             case ExternalEmitHelpers.ImportStar:                 return ["__importStar"];             case ExternalEmitHelpers.ImportDefault:                 return ["__importDefault"];             case ExternalEmitHelpers.MakeTemplateObject:                 return ["__makeTemplateObject"];             case ExternalEmitHelpers.ClassPrivateFieldGet:                 return ["__classPrivateFieldGet"];             case ExternalEmitHelpers.ClassPrivateFieldSet:                 return ["__classPrivateFieldSet"];             case ExternalEmitHelpers.ClassPrivateFieldIn:                 return ["__classPrivateFieldIn"];             case ExternalEmitHelpers.SetFunctionName:                 return ["__setFunctionName"];             case ExternalEmitHelpers.PropKey:                 return ["__propKey"];             case ExternalEmitHelpers.AddDisposableResourceAndDisposeResources:                 return ["__addDisposableResource", "__disposeResources"];             default:                 return Debug.fail("Unrecognized helper");         } */
	}
	resolveHelpersModule := func(file SourceFile, errorNode Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO {
		links := getNodeLinks(file)
		if !links.externalHelpersModule {
			links.externalHelpersModule = resolveExternalModule(getImportHelpersImportSpecifier(file), externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol
		}
		return links.externalHelpersModule
	}
	checkGrammarModifiers := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) bool {
		quickResult := reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node)
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): quickResult !== undefined */ TODO {
			return quickResult
		}
		if isParameter(node) && parameterIsThisKeyword(node) {
			return grammarErrorOnFirstToken(node, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters)
		}
		blockScopeKind := /* TODO(ConditionalExpression): isVariableStatement(node) ? node.declarationList.flags & NodeFlags.BlockScoped : NodeFlags.None */ TODO
		var lastStatic Node
		var lastDeclare Node
		var lastAsync Node
		var lastOverride Node
		var firstDecorator *Decorator
		flags := ModifierFlagsNone
		sawExportBeforeDecorators := false
		hasLeadingDecorators := false
		for _, modifier := range /* TODO(NonNullExpression): (node as HasModifiers).modifiers! */ TODO {
			if isDecorator(modifier) {
				if !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent) {
					if node.kind == SyntaxKindMethodDeclaration && !nodeIsPresent(node.body) {
						return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload)
					} else {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here)
					}
				} else if legacyDecorators && (node.kind == SyntaxKindGetAccessor || node.kind == SyntaxKindSetAccessor) {
					accessors := getAllAccessorDeclarationsForDeclaration(node /* as */ /* TODO(TypeReference): AccessorDeclaration */)
					if hasDecorators(accessors.firstAccessor) && node == accessors.secondAccessor {
						return grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name)
					}
				}
				if flags & ~(ModifierFlagsExportDefault | ModifierFlagsDecorator) {
					return grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here)
				}
				if hasLeadingDecorators && flags&ModifierFlagsModifier {
					Debug.assertIsDefined(firstDecorator)
					sourceFile := getSourceFileOfNode(modifier)
					if !hasParseDiagnostics(sourceFile) {
						addRelatedInfo(error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export), createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here))
						return true
					}
					return false
				}
				flags |= ModifierFlagsDecorator
				if !(flags & ModifierFlagsModifier) {
					hasLeadingDecorators = true
				} else if flags & ModifierFlagsExport {
					sawExportBeforeDecorators = true
				}
				/* TODO(ExpressionStatement): firstDecorator ??= modifier; */
			} else {
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.ReadonlyKeyword */ TODO {
					if node.kind == SyntaxKindPropertySignature || node.kind == SyntaxKindMethodSignature {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind))
					}
					if node.kind == SyntaxKindIndexSignature && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.StaticKeyword */ TODO || !isClassLike(node.parent)) {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind))
					}
				}
				if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.InKeyword */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.OutKeyword */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): modifier.kind !== SyntaxKind.ConstKeyword */ TODO {
					if node.kind == SyntaxKindTypeParameter {
						return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind))
					}
				}
				/* TODO(SwitchStatement): switch (modifier.kind) {                     case SyntaxKind.ConstKeyword: {                         if (node.kind !== SyntaxKind.EnumDeclaration && node.kind !== SyntaxKind.TypeParameter) {                             return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(SyntaxKind.ConstKeyword));                         }                         const parent = (isJSDocTemplateTag(node.parent) && getEffectiveJSDocHost(node.parent)) || node.parent;                         if (                             node.kind === SyntaxKind.TypeParameter && !(isFunctionLikeDeclaration(parent) || isClassLike(parent) || isFunctionTypeNode(parent) ||                                 isConstructorTypeNode(parent) || isCallSignatureDeclaration(parent) || isConstructSignatureDeclaration(parent) || isMethodSignature(parent))                         ) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind));                         }                         break;                     }                     case SyntaxKind.OverrideKeyword:                         // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.                         if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async");                         }                         flags |= ModifierFlags.Override;                         lastOverride = modifier;                         break;                      case SyntaxKind.PublicKeyword:                     case SyntaxKind.ProtectedKeyword:                     case SyntaxKind.PrivateKeyword:                         const text = visibilityToString(modifierToFlag(modifier.kind));                          if (flags & ModifierFlags.AccessibilityModifier) {                             return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen);                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override");                         }                         else if (flags & ModifierFlags.Static) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async");                         }                         else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);                         }                         else if (flags & ModifierFlags.Abstract) {                             if (modifier.kind === SyntaxKind.PrivateKeyword) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");                             }                             else {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");                             }                         }                         else if (isPrivateIdentifierClassElementDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);                         }                         flags |= modifierToFlag(modifier.kind);                         break;                      case SyntaxKind.StaticKeyword:                         if (flags & ModifierFlags.Static) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor");                         }                         else if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");                         }                         else if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override");                         }                         flags |= ModifierFlags.Static;                         lastStatic = modifier;                         break;                      case SyntaxKind.AccessorKeyword:                         if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor");                         }                         else if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare");                         }                         else if (node.kind !== SyntaxKind.PropertyDeclaration) {                             return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration);                         }                          flags |= ModifierFlags.Accessor;                         break;                      case SyntaxKind.ReadonlyKeyword:                         if (flags & ModifierFlags.Readonly) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly");                         }                         else if (node.kind !== SyntaxKind.PropertyDeclaration && node.kind !== SyntaxKind.PropertySignature && node.kind !== SyntaxKind.IndexSignature && node.kind !== SyntaxKind.Parameter) {                             // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.                             return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor");                         }                         flags |= ModifierFlags.Readonly;                         break;                      case SyntaxKind.ExportKeyword:                         if (                             compilerOptions.verbatimModuleSyntax &&                             !(node.flags & NodeFlags.Ambient) &&                             node.kind !== SyntaxKind.TypeAliasDeclaration &&                             node.kind !== SyntaxKind.InterfaceDeclaration &&                             // ModuleDeclaration needs to be checked that it is uninstantiated later                             node.kind !== SyntaxKind.ModuleDeclaration &&                             node.parent.kind === SyntaxKind.SourceFile &&                             host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) === ModuleKind.CommonJS                         ) {                             return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);                         }                         if (flags & ModifierFlags.Export) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export");                         }                         else if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");                         }                         else if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");                         }                         else if (isClassLike(node.parent)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "export");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "export");                         }                         flags |= ModifierFlags.Export;                         break;                     case SyntaxKind.DefaultKeyword:                         const container = node.parent.kind === SyntaxKind.SourceFile ? node.parent : node.parent.parent;                         if (container.kind === SyntaxKind.ModuleDeclaration && !isAmbientModule(container)) {                             return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "default");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "default");                         }                         else if (!(flags & ModifierFlags.Export)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default");                         }                         else if (sawExportBeforeDecorators) {                             return grammarErrorOnNode(firstDecorator!, Diagnostics.Decorators_are_not_valid_here);                         }                          flags |= ModifierFlags.Default;                         break;                     case SyntaxKind.DeclareKeyword:                         if (flags & ModifierFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare");                         }                         else if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");                         }                         else if (flags & ModifierFlags.Override) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override");                         }                         else if (isClassLike(node.parent) && !isPropertyDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");                         }                         else if (blockScopeKind === NodeFlags.Using) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_using_declaration, "declare");                         }                         else if (blockScopeKind === NodeFlags.AwaitUsing) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_await_using_declaration, "declare");                         }                         else if ((node.parent.flags & NodeFlags.Ambient) && node.parent.kind === SyntaxKind.ModuleBlock) {                             return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);                         }                         else if (isPrivateIdentifierClassElementDeclaration(node)) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare");                         }                         else if (flags & ModifierFlags.Accessor) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor");                         }                         flags |= ModifierFlags.Ambient;                         lastDeclare = modifier;                         break;                      case SyntaxKind.AbstractKeyword:                         if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract");                         }                         if (                             node.kind !== SyntaxKind.ClassDeclaration &&                             node.kind !== SyntaxKind.ConstructorType                         ) {                             if (                                 node.kind !== SyntaxKind.MethodDeclaration &&                                 node.kind !== SyntaxKind.PropertyDeclaration &&                                 node.kind !== SyntaxKind.GetAccessor &&                                 node.kind !== SyntaxKind.SetAccessor                             ) {                                 return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);                             }                             if (!(node.parent.kind === SyntaxKind.ClassDeclaration && hasSyntacticModifier(node.parent, ModifierFlags.Abstract))) {                                 const message = node.kind === SyntaxKind.PropertyDeclaration                                     ? Diagnostics.Abstract_properties_can_only_appear_within_an_abstract_class                                     : Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class;                                 return grammarErrorOnNode(modifier, message);                             }                             if (flags & ModifierFlags.Static) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");                             }                             if (flags & ModifierFlags.Private) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");                             }                             if (flags & ModifierFlags.Async && lastAsync) {                                 return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");                             }                             if (flags & ModifierFlags.Override) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override");                             }                             if (flags & ModifierFlags.Accessor) {                                 return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor");                             }                         }                         if (isNamedDeclaration(node) && node.name.kind === SyntaxKind.PrivateIdentifier) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract");                         }                          flags |= ModifierFlags.Abstract;                         break;                      case SyntaxKind.AsyncKeyword:                         if (flags & ModifierFlags.Async) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async");                         }                         else if (flags & ModifierFlags.Ambient || node.parent.flags & NodeFlags.Ambient) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");                         }                         else if (node.kind === SyntaxKind.Parameter) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");                         }                         if (flags & ModifierFlags.Abstract) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");                         }                         flags |= ModifierFlags.Async;                         lastAsync = modifier;                         break;                      case SyntaxKind.InKeyword:                     case SyntaxKind.OutKeyword: {                         const inOutFlag = modifier.kind === SyntaxKind.InKeyword ? ModifierFlags.In : ModifierFlags.Out;                         const inOutText = modifier.kind === SyntaxKind.InKeyword ? "in" : "out";                         const parent = isJSDocTemplateTag(node.parent) && (getEffectiveJSDocHost(node.parent) || find(getJSDocRoot(node.parent)?.tags, isJSDocTypedefTag)) || node.parent;                         if (node.kind !== SyntaxKind.TypeParameter || parent && !(isInterfaceDeclaration(parent) || isClassLike(parent) || isTypeAliasDeclaration(parent) || isJSDocTypedefTag(parent))) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText);                         }                         if (flags & inOutFlag) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText);                         }                         if (inOutFlag & ModifierFlags.In && flags & ModifierFlags.Out) {                             return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out");                         }                         flags |= inOutFlag;                         break;                     }                 } */
			}
		}
		if node.kind == SyntaxKindConstructor {
			if flags & ModifierFlagsStatic {
				return grammarErrorOnNode( /* TODO(NonNullExpression): lastStatic! */ TODO, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static")
			}
			if flags & ModifierFlagsOverride {
				return grammarErrorOnNode( /* TODO(NonNullExpression): lastOverride! */ TODO, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override")
			}
			if flags & ModifierFlagsAsync {
				return grammarErrorOnNode( /* TODO(NonNullExpression): lastAsync! */ TODO, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async")
			}
			return false
		} else if (node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration) && flags&ModifierFlagsAmbient {
			return grammarErrorOnNode( /* TODO(NonNullExpression): lastDeclare! */ TODO, Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare")
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && isBindingPattern(node.name) {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern)
		} else if node.kind == SyntaxKindParameter && (flags & ModifierFlagsParameterPropertyModifier) && node.dotDotDotToken {
			return grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter)
		}
		if flags & ModifierFlagsAsync {
			return checkGrammarAsyncModifier(node /* TODO(NonNullExpression): lastAsync! */, TODO)
		}
		return false
	}
	reportObviousModifierErrors := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) /* TODO(BooleanKeyword): boolean */ any {
		if !node.modifiers {
			/* TODO(FalseKeyword): false */
		}
		modifier := findFirstIllegalModifier(node)
		return modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here)
	}
	findFirstModifierExcept := func(node HasModifiers, allowedModifier SyntaxKind) *Modifier {
		modifier := find(node.modifiers, isModifier)
		return /* TODO(ConditionalExpression): modifier && modifier.kind !== allowedModifier ? modifier : undefined */ TODO
	}
	findFirstIllegalModifier := func(node /* TODO(UnionType): HasModifiers | HasIllegalModifiers */ any) *Modifier {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.GetAccessor:             case SyntaxKind.SetAccessor:             case SyntaxKind.Constructor:             case SyntaxKind.PropertyDeclaration:             case SyntaxKind.PropertySignature:             case SyntaxKind.MethodDeclaration:             case SyntaxKind.MethodSignature:             case SyntaxKind.IndexSignature:             case SyntaxKind.ModuleDeclaration:             case SyntaxKind.ImportDeclaration:             case SyntaxKind.ImportEqualsDeclaration:             case SyntaxKind.ExportDeclaration:             case SyntaxKind.ExportAssignment:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:             case SyntaxKind.Parameter:             case SyntaxKind.TypeParameter:                 return undefined;             case SyntaxKind.ClassStaticBlockDeclaration:             case SyntaxKind.PropertyAssignment:             case SyntaxKind.ShorthandPropertyAssignment:             case SyntaxKind.NamespaceExportDeclaration:             case SyntaxKind.MissingDeclaration:                 return find(node.modifiers, isModifier);             default:                 if (node.parent.kind === SyntaxKind.ModuleBlock || node.parent.kind === SyntaxKind.SourceFile) {                     return undefined;                 }                 switch (node.kind) {                     case SyntaxKind.FunctionDeclaration:                         return findFirstModifierExcept(node, SyntaxKind.AsyncKeyword);                     case SyntaxKind.ClassDeclaration:                     case SyntaxKind.ConstructorType:                         return findFirstModifierExcept(node, SyntaxKind.AbstractKeyword);                     case SyntaxKind.ClassExpression:                     case SyntaxKind.InterfaceDeclaration:                     case SyntaxKind.TypeAliasDeclaration:                         return find(node.modifiers, isModifier);                     case SyntaxKind.VariableStatement:                         return node.declarationList.flags & NodeFlags.Using ?                             findFirstModifierExcept(node, SyntaxKind.AwaitKeyword) :                             find(node.modifiers, isModifier);                     case SyntaxKind.EnumDeclaration:                         return findFirstModifierExcept(node, SyntaxKind.ConstKeyword);                     default:                         Debug.assertNever(node);                 }         } */
	}
	reportObviousDecoratorErrors := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) /* TODO(undefined): boolean | undefined */ TODO {
		decorator := findFirstIllegalDecorator(node)
		return decorator && grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here)
	}
	findFirstIllegalDecorator := func(node /* TODO(UnionType): HasModifiers | HasDecorators | HasIllegalModifiers | HasIllegalDecorators */ any) *Decorator {
		return /* TODO(ConditionalExpression): canHaveIllegalDecorators(node) ? find(node.modifiers, isDecorator) : undefined */ TODO
	}
	checkGrammarAsyncModifier := func(node Node, asyncModifier Node) bool {
		/* TODO(SwitchStatement): switch (node.kind) {             case SyntaxKind.MethodDeclaration:             case SyntaxKind.FunctionDeclaration:             case SyntaxKind.FunctionExpression:             case SyntaxKind.ArrowFunction:                 return false;         } */
		return grammarErrorOnNode(asyncModifier, Diagnostics._0_modifier_cannot_be_used_here, "async")
	}
	checkGrammarForDisallowedTrailingComma := func(list *NodeArray[Node], diag /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticMessage */ TODO /* = */ /* TODO(PropertyAccessExpression): Diagnostics.Trailing_comma_not_allowed */) bool {
		if list && list.hasTrailingComma {
			return grammarErrorAtPos( /* TODO(ElementAccessExpression): list[0] */ TODO /* TODO(MinusToken): - */ /* TODO(BinaryExpression): list.end - ",".length */, TODO, ",".length, diag)
		}
		return false
	}
	checkGrammarTypeParameterList := func(typeParameters *NodeArray[TypeParameterDeclaration], file SourceFile) bool {
		if typeParameters && typeParameters.length == 0 {
			start := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): typeParameters.pos - "<".length */ TODO
			end := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): skipTrivia(file.text, typeParameters.end) + ">".length */ TODO
			return grammarErrorAtPos(file, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO, Diagnostics.Type_parameter_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarParameterList := func(parameters NodeArray[ParameterDeclaration]) /* TODO(undefined): boolean | undefined */ TODO {
		seenOptionalParameter := false
		parameterCount := parameters.length
		/* TODO(ForStatement): for (let i = 0; i < parameterCount; i++) {             const parameter = parameters[i];             if (parameter.dotDotDotToken) {                 if (i !== (parameterCount - 1)) {                     return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);                 }                 if (!(parameter.flags & NodeFlags.Ambient)) { // Allow `...foo,` in ambient declarations; see GH#23070                     checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);                 }                  if (parameter.questionToken) {                     return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional);                 }                  if (parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);                 }             }             else if (hasEffectiveQuestionToken(parameter)) {                 seenOptionalParameter = true;                 if (parameter.questionToken && parameter.initializer) {                     return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);                 }             }             else if (seenOptionalParameter && !parameter.initializer) {                 return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);             }         } */
	}
	getNonSimpleParameters := func(parameters []ParameterDeclaration) []ParameterDeclaration {
		return filter(parameters, func(parameter /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(BinaryExpression): !!parameter.initializer || isBindingPattern(parameter.name) */
			/* TODO(BarBarToken): || */
			/* TODO(CallExpression): isRestParameter(parameter) */
		})
	}
	checkGrammarForUseStrictSimpleParameterList := func(node FunctionLikeDeclaration) bool {
		if languageVersion >= ScriptTargetES2016 {
			useStrictDirective := node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements)
			if useStrictDirective {
				nonSimpleParameters := getNonSimpleParameters(node.parameters)
				if length(nonSimpleParameters) {
					forEach(nonSimpleParameters, func(parameter /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO) {
						addRelatedInfo(error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here))
					})
					diagnostics := nonSimpleParameters.map_(func(parameter /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO, index /* TODO(undefined): number */ TODO) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").DiagnosticWithLocation */ TODO {
						/* TODO(ConditionalExpression): index === 0 ? createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, Diagnostics.and_here) */
					}) /* as */ /* TODO(TupleType): [DiagnosticWithLocation, ...DiagnosticWithLocation[]] */
					addRelatedInfo(error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list) /* TODO(SpreadElement): ...diagnostics */, TODO)
					return true
				}
			}
		}
		return false
	}
	checkGrammarFunctionLikeDeclaration := func(node /* TODO(UnionType): FunctionLikeDeclaration | MethodSignature */ any) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarModifiers(node) || checkGrammarTypeParameterList(node.typeParameters, file) || checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(node, file) || (isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node))
	}
	checkGrammarClassLikeDeclaration := func(node ClassLikeDeclaration) bool {
		file := getSourceFileOfNode(node)
		return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file)
	}
	checkGrammarArrowFunction := func(node Node, file SourceFile) bool {
		if !isArrowFunction(node) {
			return false
		}
		if node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || /* TODO(ElementAccessExpression): node.typeParameters[0] */ TODO.constraint) {
			if file && fileExtensionIsOneOf(file.fileName /* TODO(ArrayLiteralExpression): [Extension.Mts, Extension.Cts] */, TODO) {
				grammarErrorOnNode( /* TODO(ElementAccessExpression): node.typeParameters[0] */ TODO, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint)
			}
		}
		TODO_IDENTIFIER := node
		startLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line
		endLine := getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line
		return /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): startLine !== endLine */ TODO && grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow)
	}
	checkGrammarIndexSignatureParameters := func(node SignatureDeclaration) bool {
		parameter := /* TODO(ElementAccessExpression): node.parameters[0] */ TODO
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parameters.length !== 1 */ TODO {
			if parameter {
				return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			} else {
				return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter)
			}
		}
		checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma)
		if parameter.dotDotDotToken {
			return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter)
		}
		if hasEffectiveModifiers(parameter) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier)
		}
		if parameter.questionToken {
			return grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark)
		}
		if parameter.initializer {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer)
		}
		if !parameter.type_ {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation)
		}
		type_ := getTypeFromTypeNode(parameter.type_)
		if someType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
			/* TODO(PrefixUnaryExpression): !(t.flags & TypeFlags.StringOrNumberLiteralOrUnique) */
		}) || isGenericType(type_) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead)
		}
		if !everyType(type_, isValidIndexKeyType) {
			return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type)
		}
		if !node.type_ {
			return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation)
		}
		return false
	}
	checkGrammarIndexSignature := func(node IndexSignatureDeclaration) /* TODO(undefined): boolean */ TODO {
		return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node)
	}
	checkGrammarForAtLeastOneTypeArgument := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		if typeArguments && typeArguments.length == 0 {
			sourceFile := getSourceFileOfNode(node)
			start := /* TODO(MinusToken): - */ /* TODO(BinaryExpression): typeArguments.pos - "<".length */ TODO
			end := /* TODO(PlusToken): + */ /* TODO(BinaryExpression): skipTrivia(sourceFile.text, typeArguments.end) + ">".length */ TODO
			return grammarErrorAtPos(sourceFile, start /* TODO(MinusToken): - */ /* TODO(BinaryExpression): end - start */, TODO, Diagnostics.Type_argument_list_cannot_be_empty)
		}
		return false
	}
	checkGrammarTypeArguments := func(node Node, typeArguments *NodeArray[TypeNode]) bool {
		return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(node, typeArguments)
	}
	checkGrammarTaggedTemplateChain := func(node TaggedTemplateExpression) bool {
		if node.questionDotToken || node.flags&NodeFlagsOptionalChain {
			return grammarErrorOnNode(node.template, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain)
		}
		return false
	}
	checkGrammarHeritageClause := func(node HeritageClause) bool {
		types := node.types
		if checkGrammarForDisallowedTrailingComma(types) {
			return true
		}
		if types && types.length == 0 {
			listType := tokenToString(node.token)
			return grammarErrorAtPos(node, types.pos, 0, Diagnostics._0_list_cannot_be_empty, listType)
		}
		return some(types, checkGrammarExpressionWithTypeArguments)
	}
	checkGrammarExpressionWithTypeArguments := func(node /* TODO(UnionType): ExpressionWithTypeArguments | TypeQueryNode */ any) /* TODO(undefined): boolean */ TODO {
		if isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		return checkGrammarTypeArguments(node, node.typeArguments)
	}
	checkGrammarClassDeclarationHeritageClauses := func(node ClassLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		seenExtendsClause := false
		seenImplementsClause := false
		if !checkGrammarModifiers(node) && node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause)
					}
					if heritageClause.types.length > 1 {
						return grammarErrorOnFirstToken( /* TODO(ElementAccessExpression): heritageClause.types[1] */ TODO, Diagnostics.Classes_can_only_extend_a_single_class)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					if seenImplementsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen)
					}
					seenImplementsClause = true
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
	}
	checkGrammarInterfaceDeclaration := func(node InterfaceDeclaration) /* TODO(undefined): boolean */ TODO {
		seenExtendsClause := false
		if node.heritageClauses {
			for _, heritageClause := range node.heritageClauses {
				if heritageClause.token == SyntaxKindExtendsKeyword {
					if seenExtendsClause {
						return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen)
					}
					seenExtendsClause = true
				} else {
					Debug.assert(heritageClause.token == SyntaxKindImplementsKeyword)
					return grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause)
				}
				checkGrammarHeritageClause(heritageClause)
			}
		}
		return false
	}
	checkGrammarComputedPropertyName := func(node Node) bool {
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.kind !== SyntaxKind.ComputedPropertyName */ TODO {
			return false
		}
		computedPropertyName := node /* as */ /* TODO(TypeReference): ComputedPropertyName */
		if computedPropertyName.expression.kind == SyntaxKindBinaryExpression && (computedPropertyName.expression /* as */ /* TODO(TypeReference): BinaryExpression */).operatorToken.kind == SyntaxKindCommaToken {
			return grammarErrorOnNode(computedPropertyName.expression, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name)
		}
		return false
	}
	checkGrammarForGenerator := func(node FunctionLikeDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		if node.asteriskToken {
			Debug.assert(node.kind == SyntaxKindFunctionDeclaration || node.kind == SyntaxKindFunctionExpression || node.kind == SyntaxKindMethodDeclaration)
			if node.flags & NodeFlagsAmbient {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.Generators_are_not_allowed_in_an_ambient_context)
			}
			if !node.body {
				return grammarErrorOnNode(node.asteriskToken, Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator)
			}
		}
	}
	checkGrammarForInvalidQuestionMark := func(questionToken *QuestionToken, message DiagnosticMessage) bool {
		return !!questionToken && grammarErrorOnNode(questionToken, message)
	}
	checkGrammarForInvalidExclamationToken := func(exclamationToken *ExclamationToken, message DiagnosticMessage) bool {
		return !!exclamationToken && grammarErrorOnNode(exclamationToken, message)
	}
	checkGrammarObjectLiteralExpression := func(node ObjectLiteralExpression, inDestructuring bool) /* TODO(undefined): boolean | undefined */ TODO {
		seen := /* TODO(NewExpression): new Map<__String, DeclarationMeaning>() */ TODO
		for _, prop := range node.properties {
			if prop.kind == SyntaxKindSpreadAssignment {
				if inDestructuring {
					expression := skipParentheses(prop.expression)
					if isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression) {
						return grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern)
					}
				}
				/* TODO(ContinueStatement): continue; */
			}
			name := prop.name
			if name.kind == SyntaxKindComputedPropertyName {
				checkGrammarComputedPropertyName(name)
			}
			if prop.kind == SyntaxKindShorthandPropertyAssignment && !inDestructuring && prop.objectAssignmentInitializer {
				grammarErrorOnNode( /* TODO(NonNullExpression): prop.equalsToken! */ TODO, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern)
			}
			if name.kind == SyntaxKindPrivateIdentifier {
				grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies)
			}
			if canHaveModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): mod.kind !== SyntaxKind.AsyncKeyword */ TODO || /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): prop.kind !== SyntaxKind.MethodDeclaration */ TODO) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			} else if canHaveIllegalModifiers(prop) && prop.modifiers {
				for _, mod := range prop.modifiers {
					if isModifier(mod) {
						grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod))
					}
				}
			}
			var currentKind DeclarationMeaning
			/* TODO(SwitchStatement): switch (prop.kind) {                 case SyntaxKind.ShorthandPropertyAssignment:                 case SyntaxKind.PropertyAssignment:                     // Grammar checking for computedPropertyName and shorthandPropertyAssignment                     checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context);                     checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional);                     if (name.kind === SyntaxKind.NumericLiteral) {                         checkGrammarNumericLiteral(name);                     }                     if (name.kind === SyntaxKind.BigIntLiteral) {                         addErrorOrSuggestion(/*isError* / true, createDiagnosticForNode(name, Diagnostics.A_bigint_literal_cannot_be_used_as_a_property_name));                     }                     currentKind = DeclarationMeaning.PropertyAssignment;                     break;                 case SyntaxKind.MethodDeclaration:                     currentKind = DeclarationMeaning.Method;                     break;                 case SyntaxKind.GetAccessor:                     currentKind = DeclarationMeaning.GetAccessor;                     break;                 case SyntaxKind.SetAccessor:                     currentKind = DeclarationMeaning.SetAccessor;                     break;                 default:                     Debug.assertNever(prop, "Unexpected syntax kind:" + (prop as Node).kind);             } */
			if !inDestructuring {
				effectiveName := getEffectivePropertyNameForPropertyNameNode(name)
				if effectiveName == nil {
					/* TODO(ContinueStatement): continue; */
				}
				existingKind := seen.get(effectiveName)
				if !existingKind {
					seen.set(effectiveName, currentKind)
				} else {
					if (currentKind & DeclarationMeaningMethod) && (existingKind & DeclarationMeaningMethod) {
						grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningPropertyAssignment) && (existingKind & DeclarationMeaningPropertyAssignment) {
						grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name))
					} else if (currentKind & DeclarationMeaningGetOrSetAccessor) && (existingKind & DeclarationMeaningGetOrSetAccessor) {
						if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): existingKind !== DeclarationMeaning.GetOrSetAccessor */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): currentKind !== existingKind */ TODO {
							seen.set(effectiveName, currentKind|existingKind)
						} else {
							return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name)
						}
					} else {
						return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name)
					}
				}
			}
		}
	}
	checkGrammarJsxElement := func(node JsxOpeningLikeElement) /* TODO(undefined): boolean | undefined */ TODO {
		checkGrammarJsxName(node.tagName)
		checkGrammarTypeArguments(node, node.typeArguments)
		seen := /* TODO(NewExpression): new Map<__String, boolean>() */ TODO
		for _, attr := range node.attributes.properties {
			if attr.kind == SyntaxKindJsxSpreadAttribute {
				/* TODO(ContinueStatement): continue; */
			}
			TODO_IDENTIFIER := attr
			escapedText := getEscapedTextOfJsxAttributeName(name)
			if !seen.get(escapedText) {
				seen.set(escapedText, true)
			} else {
				return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name)
			}
			if initializer && initializer.kind == SyntaxKindJsxExpression && !initializer.expression {
				return grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression)
			}
		}
	}
	checkGrammarJsxName := func(node JsxTagNameExpression) /* TODO(undefined): boolean | undefined */ TODO {
		if isPropertyAccessExpression(node) && isJsxNamespacedName(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names)
		}
		if isJsxNamespacedName(node) && getJSXTransformEnabled(compilerOptions) && !isIntrinsicJsxName(node.namespace.escapedText) {
			return grammarErrorOnNode(node, Diagnostics.React_components_cannot_include_JSX_namespace_names)
		}
	}
	checkGrammarJsxExpression := func(node JsxExpression) /* TODO(undefined): boolean | undefined */ TODO {
		if node.expression && isCommaSequence(node.expression) {
			return grammarErrorOnNode(node.expression, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array)
		}
	}
	checkGrammarForInOrForOfStatement := func(forInOrOfStatement ForInOrOfStatement) bool {
		if checkGrammarStatementInAmbientContext(forInOrOfStatement) {
			return true
		}
		if forInOrOfStatement.kind == SyntaxKindForOfStatement && forInOrOfStatement.awaitModifier {
			if !(forInOrOfStatement.flags & NodeFlagsAwaitContext) {
				sourceFile := getSourceFileOfNode(forInOrOfStatement)
				if isInTopLevelContext(forInOrOfStatement) {
					if !hasParseDiagnostics(sourceFile) {
						if !isEffectiveExternalModule(sourceFile, compilerOptions) {
							diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module))
						}
						/* TODO(SwitchStatement): switch (moduleKind) {                             case ModuleKind.Node16:                             case ModuleKind.NodeNext:                                 if (sourceFile.impliedNodeFormat === ModuleKind.CommonJS) {                                     diagnostics.add(                                         createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level),                                     );                                     break;                                 }                                 // fallthrough                             case ModuleKind.ES2022:                             case ModuleKind.ESNext:                             case ModuleKind.Preserve:                             case ModuleKind.System:                                 if (languageVersion >= ScriptTarget.ES2017) {                                     break;                                 }                                 // fallthrough                             default:                                 diagnostics.add(                                     createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_nodenext_or_preserve_and_the_target_option_is_set_to_es2017_or_higher),                                 );                                 break;                         } */
					}
				} else {
					if !hasParseDiagnostics(sourceFile) {
						diagnostic := createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules)
						func_ := getContainingFunction(forInOrOfStatement)
						if func_ && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): func.kind !== SyntaxKind.Constructor */ TODO {
							Debug.assert((getFunctionFlags(func_)&FunctionFlagsAsync) == 0, "Enclosing function should never be an async function.")
							relatedInfo := createDiagnosticForNode(func_, Diagnostics.Did_you_mean_to_mark_this_function_as_async)
							addRelatedInfo(diagnostic, relatedInfo)
						}
						diagnostics.add(diagnostic)
						return true
					}
				}
			}
		}
		if isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & NodeFlagsAwaitContext) && isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText == "async" {
			grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async)
			return false
		}
		if forInOrOfStatement.initializer.kind == SyntaxKindVariableDeclarationList {
			variableList := forInOrOfStatement.initializer /* as */ /* TODO(TypeReference): VariableDeclarationList */
			if !checkGrammarVariableDeclarationList(variableList) {
				declarations := variableList.declarations
				if !declarations.length {
					return false
				}
				if declarations.length > 1 {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement                         : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement */ TODO
					return grammarErrorOnFirstToken( /* TODO(ElementAccessExpression): variableList.declarations[1] */ TODO, diagnostic)
				}
				firstDeclaration := /* TODO(ElementAccessExpression): declarations[0] */ TODO
				if firstDeclaration.initializer {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer                         : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer */ TODO
					return grammarErrorOnNode(firstDeclaration.name, diagnostic)
				}
				if firstDeclaration.type_ {
					diagnostic := /* TODO(ConditionalExpression): forInOrOfStatement.kind === SyntaxKind.ForInStatement                         ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation                         : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation */ TODO
					return grammarErrorOnNode(firstDeclaration, diagnostic)
				}
			}
		}
		return false
	}
	checkGrammarAccessor := func(accessor AccessorDeclaration) bool {
		if !(accessor.flags & NodeFlagsAmbient) && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): accessor.parent.kind !== SyntaxKind.TypeLiteral */ TODO) && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): accessor.parent.kind !== SyntaxKind.InterfaceDeclaration */ TODO) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(accessor.name) {
				return grammarErrorOnNode(accessor.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if accessor.body == nil && !hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorAtPos(accessor /* TODO(MinusToken): - */ /* TODO(BinaryExpression): accessor.end - 1 */, TODO, ";".length, Diagnostics._0_expected, "{")
			}
		}
		if accessor.body {
			if hasSyntacticModifier(accessor, ModifierFlagsAbstract) {
				return grammarErrorOnNode(accessor, Diagnostics.An_abstract_accessor_cannot_have_an_implementation)
			}
			if accessor.parent.kind == SyntaxKindTypeLiteral || accessor.parent.kind == SyntaxKindInterfaceDeclaration {
				return grammarErrorOnNode(accessor.body, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts)
			}
		}
		if accessor.typeParameters {
			return grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters)
		}
		if !doesAccessorHaveCorrectParameterCount(accessor) {
			return grammarErrorOnNode(accessor.name /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ?                     Diagnostics.A_get_accessor_cannot_have_parameters :                     Diagnostics.A_set_accessor_must_have_exactly_one_parameter */, TODO)
		}
		if accessor.kind == SyntaxKindSetAccessor {
			if accessor.type_ {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation)
			}
			parameter := Debug.checkDefined(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.")
			if parameter.dotDotDotToken {
				return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_set_accessor_cannot_have_rest_parameter)
			}
			if parameter.questionToken {
				return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter)
			}
			if parameter.initializer {
				return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer)
			}
		}
		return false
	}
	doesAccessorHaveCorrectParameterCount := func(accessor AccessorDeclaration) /* TODO(undefined): boolean | import("/home/jabaile/work/TypeScript/src/compiler/types").ParameterDeclaration */ TODO {
		return getAccessorThisParameter(accessor) || accessor.parameters.length == ( /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? 0 : 1 */ TODO)
	}
	getAccessorThisParameter := func(accessor AccessorDeclaration) *ParameterDeclaration {
		if accessor.parameters.length == ( /* TODO(ConditionalExpression): accessor.kind === SyntaxKind.GetAccessor ? 1 : 2 */ TODO) {
			return getThisParameter(accessor)
		}
	}
	checkGrammarTypeOperatorNode := func(node TypeOperatorNode) /* TODO(undefined): boolean | undefined */ TODO {
		if node.operator == SyntaxKindUniqueKeyword {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.SymbolKeyword */ TODO {
				return grammarErrorOnNode(node.type_, Diagnostics._0_expected, tokenToString(SyntaxKindSymbolKeyword))
			}
			parent := walkUpParenthesizedTypes(node.parent)
			if isInJSFile(parent) && isJSDocTypeExpression(parent) {
				host := getJSDocHost(parent)
				if host {
					parent = getSingleVariableOfVariableStatement(host) || host
				}
			}
			/* TODO(SwitchStatement): switch (parent.kind) {                 case SyntaxKind.VariableDeclaration:                     const decl = parent as VariableDeclaration;                     if (decl.name.kind !== SyntaxKind.Identifier) {                         return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);                     }                     if (!isVariableDeclarationInVariableStatement(decl)) {                         return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);                     }                     if (!(decl.parent.flags & NodeFlags.Const)) {                         return grammarErrorOnNode((parent as VariableDeclaration).name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);                     }                     break;                  case SyntaxKind.PropertyDeclaration:                     if (                         !isStatic(parent) ||                         !hasEffectiveReadonlyModifier(parent)                     ) {                         return grammarErrorOnNode((parent as PropertyDeclaration).name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);                     }                     break;                  case SyntaxKind.PropertySignature:                     if (!hasSyntacticModifier(parent, ModifierFlags.Readonly)) {                         return grammarErrorOnNode((parent as PropertySignature).name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);                     }                     break;                  default:                     return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here);             } */
		} else if node.operator == SyntaxKindReadonlyKeyword {
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.ArrayType */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.type.kind !== SyntaxKind.TupleType */ TODO {
				return grammarErrorOnFirstToken(node, Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, tokenToString(SyntaxKindSymbolKeyword))
			}
		}
	}
	checkGrammarForInvalidDynamicName := func(node DeclarationName, message DiagnosticMessage) /* TODO(undefined): boolean | undefined */ TODO {
		if isNonBindableDynamicName(node) {
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarMethod := func(node /* TODO(UnionType): MethodDeclaration | MethodSignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
		if checkGrammarFunctionLikeDeclaration(node) {
			return true
		}
		if node.kind == SyntaxKindMethodDeclaration {
			if node.parent.kind == SyntaxKindObjectLiteralExpression {
				if node.modifiers && !(node.modifiers.length == 1 && first(node.modifiers).kind == SyntaxKindAsyncKeyword) {
					return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here)
				} else if checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional) {
					return true
				} else if checkGrammarForInvalidExclamationToken(node.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context) {
					return true
				} else if node.body == nil {
					return grammarErrorAtPos(node /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.end - 1 */, TODO, ";".length, Diagnostics._0_expected, "{")
				}
			}
			if checkGrammarForGenerator(node) {
				return true
			}
		}
		if isClassLike(node.parent) {
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if node.flags & NodeFlagsAmbient {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			} else if node.kind == SyntaxKindMethodDeclaration && !node.body {
				return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		} else if node.parent.kind == SyntaxKindTypeLiteral {
			return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)
		}
	}
	checkGrammarBreakOrContinueStatement := func(node BreakOrContinueStatement) bool {
		var current Node = node
		/* TODO(WhileStatement): while (current) {             if (isFunctionLikeOrClassStaticBlockDeclaration(current)) {                 return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);             }              switch (current.kind) {                 case SyntaxKind.LabeledStatement:                     if (node.label && (current as LabeledStatement).label.escapedText === node.label.escapedText) {                         // found matching label - verify that label usage is correct                         // continue can only target labels that are on iteration statements                         const isMisplacedContinueLabel = node.kind === SyntaxKind.ContinueStatement                             && !isIterationStatement((current as LabeledStatement).statement, /*lookInLabeledStatements* / true);                          if (isMisplacedContinueLabel) {                             return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);                         }                          return false;                     }                     break;                 case SyntaxKind.SwitchStatement:                     if (node.kind === SyntaxKind.BreakStatement && !node.label) {                         // unlabeled break within switch statement - ok                         return false;                     }                     break;                 default:                     if (isIterationStatement(current, /*lookInLabeledStatements* / false) && !node.label) {                         // unlabeled break or continue within iteration statement - ok                         return false;                     }                     break;             }              current = current.parent;         } */
		if node.label {
			message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement                 : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		} else {
			message := /* TODO(ConditionalExpression): node.kind === SyntaxKind.BreakStatement                 ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement                 : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement */ TODO
			return grammarErrorOnNode(node, message)
		}
	}
	checkGrammarBindingElement := func(node BindingElement) /* TODO(undefined): boolean | undefined */ TODO {
		if node.dotDotDotToken {
			elements := node.parent.elements
			if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node !== last(elements) */ TODO {
				return grammarErrorOnNode(node, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern)
			}
			checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma)
			if node.propertyName {
				return grammarErrorOnNode(node.name, Diagnostics.A_rest_element_cannot_have_a_property_name)
			}
		}
		if node.dotDotDotToken && node.initializer {
			return grammarErrorAtPos(node /* TODO(MinusToken): - */ /* TODO(BinaryExpression): node.initializer.pos - 1 */, TODO, 1, Diagnostics.A_rest_element_cannot_have_an_initializer)
		}
	}
	isStringOrNumberLiteralExpression := func(expr Expression) /* TODO(undefined): boolean */ TODO {
		return isStringOrNumericLiteralLike(expr) || expr.kind == SyntaxKindPrefixUnaryExpression && (expr /* as */ /* TODO(TypeReference): PrefixUnaryExpression */).operator == SyntaxKindMinusToken && (expr /* as */ /* TODO(TypeReference): PrefixUnaryExpression */).operand.kind == SyntaxKindNumericLiteral
	}
	isBigIntLiteralExpression := func(expr Expression) /* TODO(undefined): boolean */ TODO {
		return expr.kind == SyntaxKindBigIntLiteral || expr.kind == SyntaxKindPrefixUnaryExpression && (expr /* as */ /* TODO(TypeReference): PrefixUnaryExpression */).operator == SyntaxKindMinusToken && (expr /* as */ /* TODO(TypeReference): PrefixUnaryExpression */).operand.kind == SyntaxKindBigIntLiteral
	}
	isSimpleLiteralEnumReference := func(expr Expression) /* TODO(undefined): boolean | undefined */ TODO {
		if (isPropertyAccessExpression(expr) || (isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) && isEntityNameExpression(expr.expression) {
			return !!(checkExpressionCached(expr).flags & TypeFlagsEnumLike)
		}
	}
	checkAmbientInitializer := func(node /* TODO(UnionType): VariableDeclaration | PropertyDeclaration | PropertySignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
		initializer := node.initializer
		if initializer {
			isInvalidInitializer := !(isStringOrNumberLiteralExpression(initializer) || isSimpleLiteralEnumReference(initializer) || initializer.kind == SyntaxKindTrueKeyword || initializer.kind == SyntaxKindFalseKeyword || isBigIntLiteralExpression(initializer))
			isConstOrReadonly := isDeclarationReadonly(node) || isVariableDeclaration(node) && (isVarConstLike(node))
			if isConstOrReadonly && !node.type_ {
				if isInvalidInitializer {
					return grammarErrorOnNode(initializer, Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference)
				}
			} else {
				return grammarErrorOnNode(initializer, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts)
			}
		}
	}
	checkGrammarVariableDeclaration := func(node VariableDeclaration) /* TODO(undefined): boolean */ TODO {
		nodeFlags := getCombinedNodeFlagsCached(node)
		blockScopeKind := nodeFlags & NodeFlagsBlockScoped
		if isBindingPattern(node.name) {
			/* TODO(SwitchStatement): switch (blockScopeKind) {                 case NodeFlags.AwaitUsing:                     return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "await using");                 case NodeFlags.Using:                     return grammarErrorOnNode(node, Diagnostics._0_declarations_may_not_have_binding_patterns, "using");             } */
		}
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForInStatement */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.ForOfStatement */ TODO {
			if nodeFlags & NodeFlagsAmbient {
				checkAmbientInitializer(node)
			} else if !node.initializer {
				if isBindingPattern(node.name) && !isBindingPattern(node.parent) {
					return grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer)
				}
				/* TODO(SwitchStatement): switch (blockScopeKind) {                     case NodeFlags.AwaitUsing:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "await using");                     case NodeFlags.Using:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "using");                     case NodeFlags.Const:                         return grammarErrorOnNode(node, Diagnostics._0_declarations_must_be_initialized, "const");                 } */
			}
		}
		if node.exclamationToken && ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): node.parent.parent.kind !== SyntaxKind.VariableStatement */ TODO || !node.type_ || node.initializer || nodeFlags&NodeFlagsAmbient) {
			message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode(node.exclamationToken, message)
		}
		if host.getEmitModuleFormatOfFile(getSourceFileOfNode(node)) < ModuleKindSystem && !(node.parent.parent.flags & NodeFlagsAmbient) && hasSyntacticModifier(node.parent.parent, ModifierFlagsExport) {
			checkESModuleMarker(node.name)
		}
		return !!blockScopeKind && checkGrammarNameInLetOrConstDeclarations(node.name)
	}
	checkESModuleMarker := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if idText(name) == "__esModule" {
				return grammarErrorOnNodeSkippedOn("noEmit", name, Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					return checkESModuleMarker(element.name)
				}
			}
		}
		return false
	}
	checkGrammarNameInLetOrConstDeclarations := func(name /* TODO(UnionType): Identifier | BindingPattern */ any) bool {
		if name.kind == SyntaxKindIdentifier {
			if name.escapedText == "let" {
				return grammarErrorOnNode(name, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations)
			}
		} else {
			elements := name.elements
			for _, element := range elements {
				if !isOmittedExpression(element) {
					checkGrammarNameInLetOrConstDeclarations(element.name)
				}
			}
		}
		return false
	}
	checkGrammarVariableDeclarationList := func(declarationList VariableDeclarationList) bool {
		declarations := declarationList.declarations
		if checkGrammarForDisallowedTrailingComma(declarationList.declarations) {
			return true
		}
		if !declarationList.declarations.length {
			return grammarErrorAtPos(declarationList, declarations.pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): declarations.end - declarations.pos */, TODO, Diagnostics.Variable_declaration_list_cannot_be_empty)
		}
		blockScopeFlags := declarationList.flags & NodeFlagsBlockScoped
		if (blockScopeFlags == NodeFlagsUsing || blockScopeFlags == NodeFlagsAwaitUsing) && isForInStatement(declarationList.parent) {
			return grammarErrorOnNode(declarationList /* TODO(ConditionalExpression): blockScopeFlags === NodeFlags.Using ?                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration :                     Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration */, TODO)
		}
		if blockScopeFlags == NodeFlagsAwaitUsing {
			return checkAwaitGrammar(declarationList)
		}
		return false
	}
	allowLetAndConstDeclarations := func(parent Node) bool {
		/* TODO(SwitchStatement): switch (parent.kind) {             case SyntaxKind.IfStatement:             case SyntaxKind.DoStatement:             case SyntaxKind.WhileStatement:             case SyntaxKind.WithStatement:             case SyntaxKind.ForStatement:             case SyntaxKind.ForInStatement:             case SyntaxKind.ForOfStatement:                 return false;             case SyntaxKind.LabeledStatement:                 return allowLetAndConstDeclarations(parent.parent);         } */
		return true
	}
	checkGrammarForDisallowedBlockScopedVariableStatement := func(node VariableStatement) /* TODO(undefined): boolean | undefined */ TODO {
		if !allowLetAndConstDeclarations(node.parent) {
			blockScopeKind := getCombinedNodeFlagsCached(node.declarationList) & NodeFlagsBlockScoped
			if blockScopeKind {
				keyword := /* TODO(ConditionalExpression): blockScopeKind === NodeFlags.Let ? "let" :                     blockScopeKind === NodeFlags.Const ? "const" :                     blockScopeKind === NodeFlags.Using ? "using" :                     blockScopeKind === NodeFlags.AwaitUsing ? "await using" :                     Debug.fail("Unknown BlockScope flag") */ TODO
				return grammarErrorOnNode(node, Diagnostics._0_declarations_can_only_be_declared_inside_a_block, keyword)
			}
		}
	}
	checkGrammarMetaProperty := func(node MetaProperty) /* TODO(undefined): boolean | undefined */ TODO {
		escapedText := node.name.escapedText
		/* TODO(SwitchStatement): switch (node.keywordToken) {             case SyntaxKind.NewKeyword:                 if (escapedText !== "target") {                     return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "target");                 }                 break;             case SyntaxKind.ImportKeyword:                 if (escapedText !== "meta") {                     return grammarErrorOnNode(node.name, Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, unescapeLeadingUnderscores(node.name.escapedText), tokenToString(node.keywordToken), "meta");                 }                 break;         } */
	}
	hasParseDiagnostics := func(sourceFile SourceFile) bool {
		return sourceFile.parseDiagnostics.length > 0
	}
	grammarErrorOnFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	grammarErrorAtPos := func(nodeForSourceFile Node, start number, length number, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(nodeForSourceFile)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createFileDiagnostic(sourceFile, start, length, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	grammarErrorOnNodeSkippedOn := func(key CompilerOptions, node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			errorSkippedOn(key, node, message /* TODO(SpreadElement): ...args */, TODO)
			return true
		}
		return false
	}
	grammarErrorOnNode := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			diagnostics.add(createDiagnosticForNode(node, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	checkGrammarConstructorTypeParameters := func(node ConstructorDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		jsdocTypeParameters := /* TODO(ConditionalExpression): isInJSFile(node) ? getJSDocTypeParameterDeclarations(node) : undefined */ TODO
		range_ := node.typeParameters || jsdocTypeParameters && firstOrUndefined(jsdocTypeParameters)
		if range_ {
			pos := /* TODO(ConditionalExpression): range.pos === range.end ? range.pos : skipTrivia(getSourceFileOfNode(node).text, range.pos) */ TODO
			return grammarErrorAtPos(node, pos /* TODO(MinusToken): - */ /* TODO(BinaryExpression): range.end - pos */, TODO, Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarConstructorTypeAnnotation := func(node ConstructorDeclaration) /* TODO(undefined): boolean | undefined */ TODO {
		type_ := node.type_ || getEffectiveReturnTypeNode(node)
		if type_ {
			return grammarErrorOnNode(type_, Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration)
		}
	}
	checkGrammarProperty := func(node /* TODO(UnionType): PropertyDeclaration | PropertySignature */ any) /* TODO(undefined): boolean | undefined */ TODO {
		if isComputedPropertyName(node.name) && isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind == SyntaxKindInKeyword {
			return grammarErrorOnNode( /* TODO(ElementAccessExpression): node.parent.members[0] */ TODO, Diagnostics.A_mapped_type_may_not_declare_properties_or_methods)
		}
		if isClassLike(node.parent) {
			if isStringLiteral(node.name) && node.name.text == "constructor" {
				return grammarErrorOnNode(node.name, Diagnostics.Classes_may_not_have_a_field_named_constructor)
			}
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type) {
				return true
			}
			if languageVersion < ScriptTargetES2015 && isPrivateIdentifier(node.name) {
				return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if languageVersion < ScriptTargetES2015 && isAutoAccessorPropertyDeclaration(node) {
				return grammarErrorOnNode(node.name, Diagnostics.Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher)
			}
			if isAutoAccessorPropertyDeclaration(node) && checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_accessor_property_cannot_be_declared_optional) {
				return true
			}
		} else if node.parent.kind == SyntaxKindInterfaceDeclaration {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.An_interface_property_cannot_have_an_initializer)
			}
		} else if isTypeLiteralNode(node.parent) {
			if checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type) {
				return true
			}
			Debug.assertNode(node, isPropertySignature)
			if node.initializer {
				return grammarErrorOnNode(node.initializer, Diagnostics.A_type_literal_property_cannot_have_an_initializer)
			}
		}
		if node.flags & NodeFlagsAmbient {
			checkAmbientInitializer(node)
		}
		if isPropertyDeclaration(node) && node.exclamationToken && (!isClassLike(node.parent) || !node.type_ || node.initializer || node.flags&NodeFlagsAmbient || isStatic(node) || hasAbstractModifier(node)) {
			message := /* TODO(ConditionalExpression): node.initializer                 ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions                 : !node.type                 ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations                 : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context */ TODO
			return grammarErrorOnNode(node.exclamationToken, message)
		}
	}
	checkGrammarTopLevelElementForRequiredDeclareModifier := func(node Node) bool {
		if node.kind == SyntaxKindInterfaceDeclaration || node.kind == SyntaxKindTypeAliasDeclaration || node.kind == SyntaxKindImportDeclaration || node.kind == SyntaxKindImportEqualsDeclaration || node.kind == SyntaxKindExportDeclaration || node.kind == SyntaxKindExportAssignment || node.kind == SyntaxKindNamespaceExportDeclaration || hasSyntacticModifier(node, ModifierFlagsAmbient|ModifierFlagsExport|ModifierFlagsDefault) {
			return false
		}
		return grammarErrorOnFirstToken(node, Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier)
	}
	checkGrammarTopLevelElementsForRequiredDeclareModifier := func(file SourceFile) bool {
		for _, decl := range file.statements {
			if isDeclaration(decl) || decl.kind == SyntaxKindVariableStatement {
				if checkGrammarTopLevelElementForRequiredDeclareModifier(decl) {
					return true
				}
			}
		}
		return false
	}
	checkGrammarSourceFile := func(node SourceFile) bool {
		return !!(node.flags & NodeFlagsAmbient) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node)
	}
	checkGrammarStatementInAmbientContext := func(node Node) bool {
		if node.flags & NodeFlagsAmbient {
			links := getNodeLinks(node)
			if !links.hasReportedStatementInAmbientContext && (isFunctionLike(node.parent) || isAccessor(node.parent)) {
				return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts) */ TODO
			}
			if node.parent.kind == SyntaxKindBlock || node.parent.kind == SyntaxKindModuleBlock || node.parent.kind == SyntaxKindSourceFile {
				links := getNodeLinks(node.parent)
				if !links.hasReportedStatementInAmbientContext {
					return /* TODO(EqualsToken): = */ /* TODO(BinaryExpression): links.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, Diagnostics.Statements_are_not_allowed_in_ambient_contexts) */ TODO
				}
			} else {
			}
		}
		return false
	}
	checkGrammarNumericLiteral := func(node NumericLiteral) {
		isFractional := getTextOfNode(node).includes(".")
		isScientific := node.numericLiteralFlags & TokenFlagsScientific
		if isFractional || isScientific {
			return
		}
		value := +node.text
		if value <= /* TODO(MinusToken): - */ /* TODO(BinaryExpression): 2 ** 53 - 1 */ TODO {
			return
		}
		addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers))
	}
	checkGrammarBigIntLiteral := func(node BigIntLiteral) bool {
		literalType := isLiteralTypeNode(node.parent) || isPrefixUnaryExpression(node.parent) && isLiteralTypeNode(node.parent.parent)
		if !literalType {
			if languageVersion < ScriptTargetES2020 {
				if grammarErrorOnNode(node, Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020) {
					return true
				}
			}
		}
		return false
	}
	grammarErrorAfterFirstToken := func(node Node, message DiagnosticMessage, args DiagnosticArguments) bool {
		sourceFile := getSourceFileOfNode(node)
		if !hasParseDiagnostics(sourceFile) {
			span := getSpanOfTokenAtPosition(sourceFile, node.pos)
			diagnostics.add(createFileDiagnostic(sourceFile, textSpanEnd(span), 0, message /* TODO(SpreadElement): ...args */, TODO))
			return true
		}
		return false
	}
	getAmbientModules := func() []Symbol {
		if !ambientModulesCache {
			ambientModulesCache = /* TODO(ArrayLiteralExpression): [] */ TODO
			globals.forEach(func(global /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO, sym /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String */ TODO) {
				if ambientModuleSymbolRegex.test(sym /* as */ /* TODO(StringKeyword): string */) {
					/* TODO(NonNullExpression): ambientModulesCache! */ TODO.push(global)
				}
			})
		}
		return ambientModulesCache
	}
	checkGrammarImportClause := func(node ImportClause) bool {
		if node.isTypeOnly && node.name && node.namedBindings {
			return grammarErrorOnNode(node, Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both)
		}
		if node.isTypeOnly && node.namedBindings.kind == SyntaxKindNamedImports {
			return checkGrammarNamedImportsOrExports(node.namedBindings)
		}
		return false
	}
	checkGrammarNamedImportsOrExports := func(namedBindings NamedImportsOrExports) bool {
		return !!forEach(namedBindings.elements, func(specifier /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ImportSpecifier | import("/home/jabaile/work/TypeScript/src/compiler/types").ExportSpecifier */ TODO) /* TODO(undefined): boolean | undefined */ TODO {
			if specifier.isTypeOnly {
				return grammarErrorOnFirstToken(specifier /* TODO(ConditionalExpression): specifier.kind === SyntaxKind.ImportSpecifier                         ? Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement                         : Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement */, TODO)
			}
		})
	}
	checkGrammarImportCallExpression := func(node ImportCall) bool {
		if compilerOptions.verbatimModuleSyntax && moduleKind == ModuleKindCommonJS {
			return grammarErrorOnNode(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled)
		}
		if moduleKind == ModuleKindES2015 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext)
		}
		if node.typeArguments {
			return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments)
		}
		nodeArguments := node.arguments
		if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.ESNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.NodeNext */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Node16 */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): moduleKind !== ModuleKind.Preserve */ TODO {
			checkGrammarForDisallowedTrailingComma(nodeArguments)
			if nodeArguments.length > 1 {
				importAttributesArgument := /* TODO(ElementAccessExpression): nodeArguments[1] */ TODO
				return grammarErrorOnNode(importAttributesArgument, Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_nodenext_or_preserve)
			}
		}
		if nodeArguments.length == 0 || nodeArguments.length > 2 {
			return grammarErrorOnNode(node, Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments)
		}
		spreadElement := find(nodeArguments, isSpreadElement)
		if spreadElement {
			return grammarErrorOnNode(spreadElement, Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element)
		}
		return false
	}
	findMatchingTypeReferenceOrTypeAliasReference := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		sourceObjectFlags := getObjectFlags(source)
		if sourceObjectFlags&(ObjectFlagsReference|ObjectFlagsAnonymous) && unionTarget.flags&TypeFlagsUnion {
			return find(unionTarget.types, func(target /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				if target.flags & TypeFlagsObject {
					overlapObjFlags := sourceObjectFlags & getObjectFlags(target)
					if overlapObjFlags & ObjectFlagsReference {
						return (source /* as */ /* TODO(TypeReference): TypeReference */).target == (target /* as */ /* TODO(TypeReference): TypeReference */).target
					}
					if overlapObjFlags & ObjectFlagsAnonymous {
						return !!(source /* as */ /* TODO(TypeReference): AnonymousType */).aliasSymbol && (source /* as */ /* TODO(TypeReference): AnonymousType */).aliasSymbol == (target /* as */ /* TODO(TypeReference): AnonymousType */).aliasSymbol
					}
				}
				return false
			})
		}
	}
	findBestTypeForObjectLiteral := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if getObjectFlags(source)&ObjectFlagsObjectLiteral && someType(unionTarget, isArrayLikeType) {
			return find(unionTarget.types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(CallExpression): isArrayLikeType(t) */
			})
		}
	}
	findBestTypeForInvokable := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		signatureKind := SignatureKindCall
		hasSignatures := getSignaturesOfType(source, signatureKind).length > 0 || ( /* TODO(CommaToken): , */ /* TODO(BinaryExpression): signatureKind = SignatureKind.Construct, getSignaturesOfType(source, signatureKind).length > 0 */ TODO)
		if hasSignatures {
			return find(unionTarget.types, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(PropertyAccessExpression): getSignaturesOfType(t, signatureKind).length */
				/* TODO(GreaterThanToken): > */
				/* TODO(NumericLiteral): 0 */
			})
		}
	}
	findMostOverlappyType := func(source Type, unionTarget UnionOrIntersectionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		var bestMatch *Type
		if !(source.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
			matchingCount := 0
			for _, target := range unionTarget.types {
				if !(target.flags & (TypeFlagsPrimitive | TypeFlagsInstantiablePrimitive)) {
					overlap := getIntersectionType( /* TODO(ArrayLiteralExpression): [getIndexType(source), getIndexType(target)] */ TODO)
					if overlap.flags & TypeFlagsIndex {
						return target
					} else if isUnitType(overlap) || overlap.flags&TypeFlagsUnion {
						len := /* TODO(ConditionalExpression): overlap.flags & TypeFlags.Union ? countWhere((overlap as UnionType).types, isUnitType) : 1 */ TODO
						if len >= matchingCount {
							bestMatch = target
							matchingCount = len
						}
					}
				}
			}
		}
		return bestMatch
	}
	filterPrimitivesIfContainsNonPrimitive := func(type_ UnionType) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO {
		if maybeTypeOfKind(type_, TypeFlagsNonPrimitive) {
			result := filterType(type_, func(t /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type */ TODO) /* TODO(undefined): boolean */ TODO {
				/* TODO(ParenthesizedExpression): (t.flags & TypeFlags.Primitive) */
			})
			if !(result.flags & TypeFlagsNever) {
				return result
			}
		}
		return type_
	}
	findMatchingDiscriminantType := func(source Type, target Type, isRelatedTo func(source Type, target Type) Ternary) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Type | undefined */ TODO {
		if target.flags&TypeFlagsUnion && source.flags&(TypeFlagsIntersection|TypeFlagsObject) {
			match := getMatchingUnionConstituentForType(target /* as */ /* TODO(TypeReference): UnionType */, source)
			if match {
				return match
			}
			sourceProperties := getPropertiesOfType(source)
			if sourceProperties {
				sourcePropertiesFiltered := findDiscriminantProperties(sourceProperties, target)
				if sourcePropertiesFiltered {
					discriminated := discriminateTypeByDiscriminableItems(target /* as */ /* TODO(TypeReference): UnionType */, map_(sourcePropertiesFiltered, func(p /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").Symbol */ TODO) /* TODO(undefined): [() => import("/home/jabaile/work/TypeScript/src/compiler/types").Type, import("/home/jabaile/work/TypeScript/src/compiler/types").__String] */ TODO {
						/* TODO(AsExpression): [() => getTypeOfSymbol(p), p.escapedName] as [() => Type, __String] */
					}), isRelatedTo)
					if /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): discriminated !== target */ TODO {
						return discriminated
					}
				}
			}
		}
		return nil
	}
	getEffectivePropertyNameForPropertyNameNode := func(node PropertyName) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").__String | undefined */ TODO {
		name := getPropertyNameForPropertyNameNode(node)
		return /* TODO(ConditionalExpression): name ? name :             isComputedPropertyName(node) ? tryGetNameFromType(getTypeOfExpression(node.expression)) : undefined */ TODO
	}
	getCombinedModifierFlagsCached := func(node Declaration) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").ModifierFlags */ TODO {
		if lastGetCombinedModifierFlagsNode == node {
			return lastGetCombinedModifierFlagsResult
		}
		lastGetCombinedModifierFlagsNode = node
		lastGetCombinedModifierFlagsResult = getCombinedModifierFlags(node)
		return lastGetCombinedModifierFlagsResult
	}
	getCombinedNodeFlagsCached := func(node Node) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").NodeFlags */ TODO {
		if lastGetCombinedNodeFlagsNode == node {
			return lastGetCombinedNodeFlagsResult
		}
		lastGetCombinedNodeFlagsNode = node
		lastGetCombinedNodeFlagsResult = getCombinedNodeFlags(node)
		return lastGetCombinedNodeFlagsResult
	}
	isVarConstLike := func(node /* TODO(UnionType): VariableDeclaration | VariableDeclarationList */ any) /* TODO(undefined): boolean */ TODO {
		blockScopeKind := getCombinedNodeFlagsCached(node) & NodeFlagsBlockScoped
		return blockScopeKind == NodeFlagsConst || blockScopeKind == NodeFlagsUsing || blockScopeKind == NodeFlagsAwaitUsing
	}
	getJSXRuntimeImportSpecifier := func(file *SourceFile, specifierText string) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike | undefined */ TODO {
		jsxImportIndex := /* TODO(ConditionalExpression): compilerOptions.importHelpers ? 1 : 0 */ TODO
		specifier := /* TODO(ElementAccessExpression): file?.imports[jsxImportIndex] */ TODO
		if specifier {
			Debug.assert(nodeIsSynthesized(specifier) && specifier.text == specifierText /* TODO(TemplateExpression): `Expected sourceFile.imports[${jsxImportIndex}] to be the synthesized JSX runtime import` */, TODO)
		}
		return specifier
	}
	getImportHelpersImportSpecifier := func(file SourceFile) /* TODO(undefined): import("/home/jabaile/work/TypeScript/src/compiler/types").StringLiteralLike */ TODO {
		Debug.assert(compilerOptions.importHelpers, "Expected importHelpers to be enabled")
		specifier := /* TODO(ElementAccessExpression): file.imports[0] */ TODO
		Debug.assert(specifier && nodeIsSynthesized(specifier) && specifier.text == "tslib", `Expected sourceFile.imports[0] to be the synthesized tslib import`)
		return specifier
	}
}
func isNotAccessor(declaration Declaration) bool {
	return !isAccessor(declaration)
}
func isNotOverload(declaration Declaration) bool {
	return ( /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.FunctionDeclaration */ TODO && /* TODO(ExclamationEqualsEqualsToken): !== */ /* TODO(BinaryExpression): declaration.kind !== SyntaxKind.MethodDeclaration */ TODO) || !!(declaration /* as */ /* TODO(TypeReference): FunctionDeclaration */).body
}
func isDeclarationNameOrImportPropertyName(name Node) bool {
	/* TODO(SwitchStatement): switch (name.parent.kind) {         case SyntaxKind.ImportSpecifier:         case SyntaxKind.ExportSpecifier:             return isIdentifier(name) || name.kind === SyntaxKind.StringLiteral;         default:             return isDeclarationName(name);     } */
}

/* TODO(ModuleDeclaration): namespace JsxNames {     export const JSX = "JSX" as __String;     export const IntrinsicElements = "IntrinsicElements" as __String;     export const ElementClass = "ElementClass" as __String;     export const ElementAttributesPropertyNameContainer = "ElementAttributesProperty" as __String; // TODO: Deprecate and remove support     export const ElementChildrenAttributeNameContainer = "ElementChildrenAttribute" as __String;     export const Element = "Element" as __String;     export const ElementType = "ElementType" as __String;     export const IntrinsicAttributes = "IntrinsicAttributes" as __String;     export const IntrinsicClassAttributes = "IntrinsicClassAttributes" as __String;     export const LibraryManagedAttributes = "LibraryManagedAttributes" as __String; } */
func getIterationTypesKeyFromIterationTypeKind(typeKind IterationTypeKind) /* TODO(undefined): "yieldType" | "returnType" | "nextType" */ TODO {
	/* TODO(SwitchStatement): switch (typeKind) {         case IterationTypeKind.Yield:             return "yieldType";         case IterationTypeKind.Return:             return "returnType";         case IterationTypeKind.Next:             return "nextType";     } */
}
func signatureHasRestParameter(s Signature) /* TODO(undefined): boolean */ TODO {
	return !!(s.flags & SignatureFlagsHasRestParameter)
}
func signatureHasLiteralTypes(s Signature) /* TODO(undefined): boolean */ TODO {
	return !!(s.flags & SignatureFlagsHasLiteralTypes)
}
func createBasicNodeBuilderModuleSpecifierResolutionHost(host TypeCheckerHost) ModuleSpecifierResolutionHost {
	return /* TODO(ObjectLiteralExpression): {         getCommonSourceDirectory: !!(host as Program).getCommonSourceDirectory ? () => (host as Program).getCommonSourceDirectory() : () => "",         getCurrentDirectory: () => host.getCurrentDirectory(),         getSymlinkCache: maybeBind(host, host.getSymlinkCache),         getPackageJsonInfoCache: () => host.getPackageJsonInfoCache?.(),         useCaseSensitiveFileNames: maybeBind(host, host.useCaseSensitiveFileNames),         redirectTargetsMap: host.redirectTargetsMap,         getProjectReferenceRedirect: fileName => host.getProjectReferenceRedirect(fileName),         isSourceOfProjectReferenceRedirect: fileName => host.isSourceOfProjectReferenceRedirect(fileName),         fileExists: fileName => host.fileExists(fileName),         getFileIncludeReasons: () => host.getFileIncludeReasons(),         readFile: host.readFile ? (fileName => host.readFile!(fileName)) : undefined,         getDefaultResolutionModeForFile: file => host.getDefaultResolutionModeForFile(file),         getModeForResolutionAtIndex: (file, index) => host.getModeForResolutionAtIndex(file, index),     } */ TODO
}

type NodeBuilderContext struct {
	enclosingDeclaration Node
	enclosingFile        *SourceFile
	flags                NodeBuilderFlags
	internalFlags        InternalNodeBuilderFlags
	tracker              SymbolTrackerImpl
	encounteredError     bool
	reportedDiagnostic   bool
	trackedSymbols/* TODO(ArrayType): TrackedSymbol[] */ any
	visitedTypes *Set[number]
	symbolDepth  *Map[string, number]
	inferTypeParameters/* TODO(ArrayType): TypeParameter[] */ any
	approximateLength                     number
	truncating                            bool
	mustCreateTypeParameterSymbolList     bool
	typeParameterSymbolList               *Set[number]
	mustCreateTypeParametersNamesLookups  bool
	typeParameterNames                    *Map[TypeId, Identifier]
	typeParameterNamesByText              *Set[string]
	typeParameterNamesByTextNextNameCount *Map[string, number]
	usedSymbolNames                       *Set[string]
	remappedSymbolNames                   *Map[SymbolId, string]
	remappedSymbolReferences              *Map[SymbolId, Symbol]
	reverseMappedStack/* TODO(ArrayType): ReverseMappedSymbol[] */ any
	bundled bool
	mapper  *TypeMapper
}

/* TODO(ClassDeclaration): class SymbolTrackerImpl implements SymbolTracker {     moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined = undefined;     context: NodeBuilderContext;      readonly inner: SymbolTracker | undefined = undefined;     readonly canTrackSymbol: boolean;     disableTrackSymbol = false;      constructor(context: NodeBuilderContext, tracker: SymbolTracker | undefined, moduleResolverHost: ModuleSpecifierResolutionHost & { getCommonSourceDirectory(): string; } | undefined) {         while (tracker instanceof SymbolTrackerImpl) {             tracker = tracker.inner;         }          this.inner = tracker;         this.moduleResolverHost = moduleResolverHost;         this.context = context;         this.canTrackSymbol = !!this.inner?.trackSymbol;     }      trackSymbol(symbol: Symbol, enclosingDeclaration: Node | undefined, meaning: SymbolFlags): boolean {         if (this.inner?.trackSymbol && !this.disableTrackSymbol) {             if (this.inner.trackSymbol(symbol, enclosingDeclaration, meaning)) {                 this.onDiagnosticReported();                 return true;             }             // Skip recording type parameters as they dont contribute to late painted statements             if (!(symbol.flags & SymbolFlags.TypeParameter)) (this.context.trackedSymbols ??= []).push([symbol, enclosingDeclaration, meaning]);         }         return false;     }      reportInaccessibleThisError(): void {         if (this.inner?.reportInaccessibleThisError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleThisError();         }     }      reportPrivateInBaseOfClassExpression(propertyName: string): void {         if (this.inner?.reportPrivateInBaseOfClassExpression) {             this.onDiagnosticReported();             this.inner.reportPrivateInBaseOfClassExpression(propertyName);         }     }      reportInaccessibleUniqueSymbolError(): void {         if (this.inner?.reportInaccessibleUniqueSymbolError) {             this.onDiagnosticReported();             this.inner.reportInaccessibleUniqueSymbolError();         }     }      reportCyclicStructureError(): void {         if (this.inner?.reportCyclicStructureError) {             this.onDiagnosticReported();             this.inner.reportCyclicStructureError();         }     }      reportLikelyUnsafeImportRequiredError(specifier: string): void {         if (this.inner?.reportLikelyUnsafeImportRequiredError) {             this.onDiagnosticReported();             this.inner.reportLikelyUnsafeImportRequiredError(specifier);         }     }      reportTruncationError(): void {         if (this.inner?.reportTruncationError) {             this.onDiagnosticReported();             this.inner.reportTruncationError();         }     }      reportNonlocalAugmentation(containingFile: SourceFile, parentSymbol: Symbol, augmentingSymbol: Symbol): void {         if (this.inner?.reportNonlocalAugmentation) {             this.onDiagnosticReported();             this.inner.reportNonlocalAugmentation(containingFile, parentSymbol, augmentingSymbol);         }     }      reportNonSerializableProperty(propertyName: string): void {         if (this.inner?.reportNonSerializableProperty) {             this.onDiagnosticReported();             this.inner.reportNonSerializableProperty(propertyName);         }     }      private onDiagnosticReported() {         this.context.reportedDiagnostic = true;     }      reportInferenceFallback(node: Node): void {         if (this.inner?.reportInferenceFallback) {             this.inner.reportInferenceFallback(node);         }     } } */